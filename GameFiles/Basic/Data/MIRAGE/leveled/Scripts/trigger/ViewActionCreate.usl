class CViewActionCreate inherit CEnhancedFrameWindow
	var CGuid		m_xGuid;
	var int			m_iSubIdx;
	var int			m_iPage;
	var ^CWindow	m_pxCurPage;

	var ^CButton	m_pxBackButton;
	var ^CButton	m_pxNextButton;
	var ^CButton	m_pxFinishButton;

	var string				m_sType;
	var ^CActionTypePages	m_pxTypePages;
	var ^CActionPages		m_pxPages;

	var int 				m_iDifficulty;

	export var procref<void>	m_xOnFinish;

	export constructor(CGuid p_xGuid,int p_iSubIdx, int p_iDifficulty)
		m_iDifficulty=p_iDifficulty;
		m_xGuid=p_xGuid;
		m_iSubIdx=p_iSubIdx;
		if(m_iSubIdx==-1)then
			m_iPage=0;
		else
			m_iPage=1;
		endif;
		var ^CTriggerDesc.CAction pxAction=GetAction();
		if(pxAction!=null)then
			m_sType=pxAction^.GetType().AsString();
		else
			m_sType="USER";
		endif;

		if(!InitFromResource("Trigger/ViewActionCreate","ActionView"))then
			CLevelEditorWrap.LogError("UI.ViewActionCreate","InitFromResource failed");
			return;
		endif;
		
		var ^CButton pxCancel=cast<CButton>(GetControl("Btn_Cancel"));
		pxCancel^.m_xOnClick=OnClose;

		m_pxBackButton=cast<CButton>(GetControl("Btn_Back"));
		m_pxBackButton^.m_xOnClick=OnBack;
		m_pxNextButton=cast<CButton>(GetControl("Btn_Next"));
		m_pxNextButton^.m_xOnClick=OnNext;

		m_pxFinishButton=cast<CButton>(GetControl("Btn_Ready"));
		m_pxFinishButton^.m_xOnClick=OnFinish;

		UpdateContent();
		UpdateButtons();

		LoadPosition("ConditionView");
		SetVisible(true);
	endconstructor;

	export destructor()
		delete m_pxPages;
	enddestructor;

	proc ^CTriggerDesc.CAction GetAction()
		var ^CTriggerDescMgr pxTM=^(CLevelEditorWrap.GetTriggerDescMgr());
		var int iTIdx=pxTM^.FindTrigger(m_xGuid);
		if(iTIdx==-1)then return null; endif;
		var ^CTriggerDesc pxTrigger=pxTM^.GetTrigger(iTIdx);
		if(m_iSubIdx<0||m_iSubIdx>=pxTrigger^.NumActions())then return null; endif;
		return pxTrigger^.GetAction(m_iSubIdx);
	endproc;

	proc void UpdateContent()
		var ^CWindow pxNewPage=new CWindow;
		if(m_iPage==0)then
			m_pxTypePages=new CActionTypePages(m_sType);
			pxNewPage=m_pxTypePages^.GetPage(m_iPage);
			delete m_pxPages;
			m_pxCurPage = null;
		else
			if(m_iPage==1 && m_pxPages==null)then
				if(m_pxTypePages!=null)then
					m_sType=m_pxTypePages^.GetType();
				endif;

				if(m_sType=="USER")then
					m_pxPages=new CActionPages();
				elseif(m_sType=="UNIT")then
					m_pxPages=new CActionUnitPages(m_xGuid);
				elseif(m_sType=="RSRC")then
					m_pxPages=new CActionRessesPages();
				elseif(m_sType=="QUIT")then
					m_pxPages=new CActionQuitPages();
				elseif(m_sType=="BONI")then
					m_pxPages=new CActionBoniPages();
				elseif(m_sType=="OCPY")then
					m_pxPages=new CActionOccupyPages(m_xGuid);
				elseif(m_sType=="COBJ")then
					m_pxPages=new CActionCreateObjPages(m_xGuid);
				elseif(m_sType=="SFOW")then
					m_pxPages=new CActionShowFOWPages(m_xGuid);
				elseif(m_sType=="CAM_")then
					m_pxPages=new CActionPlaceCamPages();
				elseif(m_sType=="ACDO")then
					m_pxPages=new CActionObjDoPages(m_xGuid);
				elseif(m_sType=="WYPT")then
					m_pxPages=new CActionWaypointsPages(m_xGuid);
				elseif(m_sType=="AIKH")then
					m_pxPages=new CActionAIKotHPages(m_xGuid);
				elseif(m_sType=="SQNZ")then
					m_pxPages=new CActionSequencePages();
				elseif(m_sType=="TRIG")then
					m_pxPages=new CActionTrigPages();
				elseif(m_sType=="OBAP")then
					m_pxPages=new CActionObjAppearPages(m_xGuid);
				elseif(m_sType=="OBHP")then
					m_pxPages=new CActionObjHitpointsPages(m_xGuid);
				elseif(m_sType=="TECH")then
					m_pxPages=new CActionTechTreePages();
				elseif(m_sType == "FDBK")then
					m_pxPages = new CActionFeedback();
				elseif(m_sType=="DGSC")then
					m_pxPages=new CActionDialogScenePages(m_xGuid);
				elseif(m_sType=="QUES")then
					m_pxPages=new CActionQuestPages();
				elseif(m_sType=="CPLX")then
					m_pxPages=new CComplexObjPages();
				elseif(m_sType=="ACND")then
					m_pxPages=new CActionNodePages();
				elseif(m_sType=="MPNG")then
					m_pxPages=new CActionMapPing(m_xGuid);
				elseif(m_sType=="POPL")then
					m_pxPages=new CActionPopulationLimit();
				elseif(m_sType=="BLSL")then
					m_pxPages=new CActionBlockSlots();
				elseif(m_sType=="DIPL")then
					m_pxPages=new CActionDiplomacyPages();
				elseif(m_sType=="GAOV")then
					m_pxPages=new CActionGameOverPages();
				elseif(m_sType=="AIRG")then
					m_pxPages=new CActionAiRegionPages();
				elseif(m_sType=="AIBV")then
					m_pxPages=new CActionAiBehaviorPages();
				elseif(m_sType=="AIAM")then
					m_pxPages=new CActionAiAggressionPages();
				elseif(m_sType=="AICM")then
					m_pxPages=new CActionAiCallModulePages();
				elseif(m_sType=="AIDA")then
					m_pxPages=new CActionAiDefendAreaPages();
				elseif(m_sType=="AILU")then
					m_pxPages=new CActionAiLockUnitPages(m_xGuid);
				elseif(m_sType=="VARS")then
					m_pxPages=new CActionVarsPages(m_xGuid);
				elseif(m_sType=="WTHR")then
					m_pxPages=new CActionWeatherPages(m_xGuid);
				elseif(m_sType=="HELP")then
					m_pxPages=new CActionHelpPages(m_xGuid);
				elseif(m_sType=="PSND")then
					m_pxPages=new CActionSoundPages(m_xGuid);
				elseif(m_sType=="DELO")then
					m_pxPages=new CActionDelObjPages(m_xGuid);
				elseif(m_sType=="REPL")then
					m_pxPages=new CActionReplaceObjPages(m_xGuid);
				elseif(m_sType=="VTME")then
					m_pxPages=new CActionSetTimePages(m_xGuid);
				elseif(m_sType=="SPGR")then
					m_pxPages=new CActionSpawnGroupPages(m_xGuid);
				elseif(m_sType=="AIFT")then
					m_pxPages=new CActionAiFightPages(m_xGuid);
				elseif(m_sType=="ADGR")then
					m_pxPages=new CActionAddToGroupPages(m_xGuid);
				elseif(m_sType=="RMGR")then
					m_pxPages=new CActionRemoveFromGroupPages(m_xGuid);
				elseif(m_sType=="TRSP")then
					m_pxPages=new CActionTransportMountingPages(m_xGuid);
				elseif(m_sType=="MUSI")then
					m_pxPages=new CActionMusicPages(m_xGuid);
				elseif(m_sType=="INBA")then
					m_pxPages=new CActionInfoBarPages(m_xGuid);
				elseif(m_sType=="QUSA")then
					m_pxPages=new CActionQuickSavePages(m_xGuid);
				elseif(m_sType=="MRGN")then
					m_pxPages=new CActionMoveRegionPages(m_xGuid);
				elseif(m_sType=="SNFA")then
					m_pxPages=new CActionSetNeutralForAnimalsPages(m_xGuid);
				elseif(m_sType=="PLCP")then
					m_pxPages=new CActionPlayerCapsPages(m_xGuid);
				elseif(m_sType=="ARGN")then
					m_pxPages=new CActionActivateRegionPages(m_xGuid);
				elseif(m_sType=="NWTK")then
					m_pxPages=new CActionNewsTicker();
				elseif(m_sType=="UIFF")then
					m_pxPages=new CActionUIFeedbackFramePages();
				elseif(m_sType=="SCRE")then
					m_pxPages=new CActionScreenRegionPages();		
				elseif(m_sType=="QMRK")then
					m_pxPages=new CActionQuestionMarkPages();
				elseif(m_sType=="TIMR")then
					m_pxPages=new CActionTimerPages();
				elseif(m_sType=="EFCT")then
					m_pxPages=new CActionEffectPages(m_xGuid);
				elseif(m_sType=="DGFB")then
					m_pxPages=new CActionDialogFeedbackPages(m_xGuid);
				endif;
				if(GetAction()!=null)then
					if(m_pxPages!=null)then m_pxPages^.OnInit(GetAction()^.GetParams()); endif;
				endif;
				delete m_pxTypePages;
				m_pxCurPage = null;
			endif;
			if(m_pxPages!=null)then
				pxNewPage=m_pxPages^.GetPage(m_iPage-1);
			endif;
		endif;
		if(m_pxCurPage!=null)then
			RemoveChild(m_pxCurPage);
		endif;
		m_pxCurPage=pxNewPage;
		if(m_pxCurPage!=null)then
			AddChildWithLayout(m_pxCurPage,"content");
		endif;
	endproc;

	proc void UpdateButtons()
		m_pxBackButton^.SetDisabled(m_iSubIdx!=-1 || m_iPage==0);
		var int iLastPage=1;
		if(m_pxPages!=null)then
			iLastPage=m_pxPages^.NumPages();
		endif;
		m_pxNextButton^.SetDisabled(m_iPage==iLastPage);
		m_pxFinishButton^.SetDisabled(m_iPage!=iLastPage);
	endproc;

	proc bool OnClose()
		super.OnClose();
		Destroy();
		return(true);
	endproc;

	proc bool OnBack()
		m_iPage=Math.Max(m_iPage-1,0);
		UpdateContent();
		UpdateButtons();
		return(true);
	endproc;

	proc bool OnNext()
		var int iLastPage=1;
		if(m_pxPages!=null)then
			iLastPage=m_pxPages^.NumPages();
		endif;
		m_iPage=Math.Min(m_iPage+1,iLastPage);
		UpdateContent();
		UpdateButtons();
		return(true);
	endproc;

	export proc bool OnFinish()
		var ^CTriggerDescMgr pxTM=^(CLevelEditorWrap.GetTriggerDescMgr());
		var int iTIdx=pxTM^.FindTrigger(m_xGuid);
		if(iTIdx!=-1)then
			var ^CTriggerDesc pxTrigger=pxTM^.GetTrigger(iTIdx);
			if(m_iSubIdx==-1)then
				var CFourCC xType=m_sType;
				m_iSubIdx=pxTrigger^.AddAction(xType);
			endif;
			if(m_pxPages!=null)then
				var ^CTriggerDesc.CAction pxAction=pxTrigger^.GetAction(m_iSubIdx);
				m_pxPages^.OnFinish(pxAction^.GetParams());
				pxAction^.GetParams().SetValue("difficulty", m_iDifficulty);
			endif;
		endif;
		if(!m_xOnFinish.IsNull())then
			m_xOnFinish.Call();
		endif;
		return OnClose();
	endproc;
endclass;


//----------------------------------------------------------
// Class:	ActionPages
//----------------------------------------------------------
class CActionPages
	var array ^CWindow	m_apxPages;

	export constructor()
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_USER");
	endconstructor;

	export destructor()
		var int i;
		for (i=0) cond (i<m_apxPages.NumEntries()) iter (++i) do
			delete m_apxPages[i];
		endfor;
	enddestructor;

	export proc int NumPages()
		return m_apxPages.NumEntries();
	endproc;

	export proc ^CWindow GetPage(int p_iIdx)
		return m_apxPages[p_iIdx];
	endproc;

	export proc void OnInit(ref CAttribs p_rxParams)

	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)

	endproc;

	proc void FillObjList(^CDropList p_pxList)
		var ^CList pxObjList = CEnhancedMenu.Get().GetObjFinder()^.GetObjList();
		if(pxObjList == null)then return; endif;

		var int iCount = pxObjList^.NumItems();
		var int i;
		for (i=0) cond (i<iCount)iter(++i) do
			var ^CFinderItem pxItem = cast<CFinderItem>(pxObjList^.GetItemData(i));
			if(pxItem==null)then continue; endif;
			if(pxItem^.GetType() == CFinderItem.TYPE_OBJECT)then
				var CClntHndl xHndl = (cast<CFinderItemObject>(pxItem))^.GetHndl();
				if(xHndl.IsValid())then
					var ^CObj pxObj = xHndl.GetObj();
					if( pxObj!=null)then
						var CFourCC xType = pxObj^.GetType();
						p_pxList^.AddItem(xHndl.GetObj()^.GetName());
					endif;
				endif;
			endif;
		endfor;
	endproc;

	//----------------------------------------------------------
	// GetObject()
	//----------------------------------------------------------
	/*export proc CClntHndl GetObject(string p_sUnitName)
		var CClntHndl xInvalid;
		xInvalid.Invalidate();
		var ^CList pxList = CEnhancedMenu.Get().GetObjFinder()^.GetObjList();
		if(pxList==null)then return xInvalid; endif;
		var int iNumItems = pxList^.NumItems();
		var int i;
		for (i=0) cond (i<iNumItems) iter (++i) do
			var ^CFinderItem pxItem = cast<CFinderItem>(pxList^.GetItemData(i));
			if(pxItem==null)then continue; endif;
			if(pxItem^.GetType() == CFinderItem.TYPE_OBJECT)then
				var CClntHndl xHndl = (cast<CFinderItemObject>(pxItem))^.GetHndl();
				if(xHndl.IsValid())then
					if(xHndl.GetObj()^.GetName() == p_sUnitName)then return xHndl; endif;
				endif;
			endif;
		endfor;
		return xInvalid;
	endproc;*/
endclass;



//----------------------------------------------------------
// Class:	ActionTypePages
//----------------------------------------------------------
class CActionTypePages inherit CActionPages

	class CTypeData inherit CItemData

		export constructor(string p_sType)
			m_xType = p_sType;
		endconstructor;

		export var CFourCC m_xType;
	endclass;

	var ^CList m_pxTypes;

	export constructor(string p_sType)
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		if(m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","ActionType"))then
			var ^CList pxTypes=cast<CList>(m_apxPages[0]^.GetControl("List_Type"));
			pxTypes^.Clear();
			pxTypes^.AddItem("Feedback ( FDBK )", new CTypeData("FDBK"));
			//pxTypes^.AddItem("USER");
			pxTypes^.AddItem("UnitPropeperties ( UNIT )", new CTypeData("UNIT"));
			pxTypes^.AddItem("Resources ( RSRC )", new CTypeData("RSRC"));
			pxTypes^.AddItem("Bonus Points ( BONI )", new CTypeData("BONI"));
			pxTypes^.AddItem("Quit ( QUIT )", new CTypeData("QUIT"));
			pxTypes^.AddItem("Occupy ( OCPY )", new CTypeData("OCPY"));
			pxTypes^.AddItem("Create Object ( COBJ )", new CTypeData("COBJ"));
			pxTypes^.AddItem("Show FogOfWar ( SFOW )", new CTypeData("SFOW"));
			pxTypes^.AddItem("SetCamera ( CAM_ )", new CTypeData("CAM_"));
			pxTypes^.AddItem("Object Action ( ACDO )", new CTypeData("ACDO"));
			pxTypes^.AddItem("Waypoints ( WYPT )", new CTypeData("WYPT"));
			pxTypes^.AddItem("Ai KotH mode ( AIKH )", new CTypeData("AIKH"));
			pxTypes^.AddItem("Play Sequence ( SQNZ )", new CTypeData("SQNZ"));
			pxTypes^.AddItem("Enable/Disable Trigger ( TRIG )", new CTypeData("TRIG"));
			pxTypes^.AddItem("Object Appearance ( OBAP )", new CTypeData("OBAP"));
			pxTypes^.AddItem("Object Hitpoints ( OBHP )", new CTypeData("OBHP"));
			pxTypes^.AddItem("TechTree ( TECH )", new CTypeData("TECH"));
			pxTypes^.AddItem("Play DialogScene ( DGSC )", new CTypeData("DGSC"));
			pxTypes^.AddItem("Change Quests ( QUES )", new CTypeData("QUES"));
			pxTypes^.AddItem("Create Complex Unit ( CPLX )", new CTypeData("CPLX"));
			pxTypes^.AddItem("Activate/Deactivate Node ( ACND )", new CTypeData("ACND"));
			pxTypes^.AddItem("Map Ping ( MPNG )", new CTypeData("MPNG"));
			pxTypes^.AddItem("Open/Close LevelSlots ( BLSL )", new CTypeData("BLSL"));
			pxTypes^.AddItem("Set Population Limit ( POPL )", new CTypeData("POPL"));
			pxTypes^.AddItem("Diplomacy ( DIPL )", new CTypeData("DIPL"));
			pxTypes^.AddItem("GameOver ( GAOV )", new CTypeData("GAOV"));
			pxTypes^.AddItem("Ai Region ( AIRG )", new CTypeData("AIRG"));
			pxTypes^.AddItem("Ai Behavior ( AIBV )", new CTypeData("AIBV"));
			pxTypes^.AddItem("Ai Module Call ( AICM )", new CTypeData("AICM"));
			pxTypes^.AddItem("Ai Defend Area ( AIDA )", new CTypeData("AIDA"));
			pxTypes^.AddItem("Ai Lock Units ( AILU )", new CTypeData("AILU"));
			pxTypes^.AddItem("Ai Fight ( AIFT )", new CTypeData("AIFT"));
			pxTypes^.AddItem("Ai Aggression Mode ( AIAM )", new CTypeData("AIAM"));
			pxTypes^.AddItem("Set Level Variable ( VARS )", new CTypeData("VARS"));
			pxTypes^.AddItem("Change Weather ( WTHR )", new CTypeData("WTHR"));
			pxTypes^.AddItem("Show Help ( HELP )", new CTypeData("HELP"));
			pxTypes^.AddItem("Play Sound ( PSND )", new CTypeData("PSND"));
			pxTypes^.AddItem("Delete Object ( DELO )", new CTypeData("DELO"));
			pxTypes^.AddItem("Replace Object ( REPL )", new CTypeData("REPL"));
			pxTypes^.AddItem("Set Virtual Time ( VTME )", new CTypeData("VTME"));
			pxTypes^.AddItem("Spawn Group ( SPGR )", new CTypeData("SPGR"));
			pxTypes^.AddItem("Add to Group ( ADGR )", new CTypeData("ADGR"));
			pxTypes^.AddItem("Remove from Group ( RMGR )", new CTypeData("RMGR"));
			pxTypes^.AddItem("Mount/Unmount Transport ( TRSP )", new CTypeData("TRSP"));
			pxTypes^.AddItem("Play Music File ( MUSI )", new CTypeData("MUSI"));
			pxTypes^.AddItem("Set Info-Bar Text ( INBA )", new CTypeData("INBA"));
			pxTypes^.AddItem("Quicksave ( QUSA )", new CTypeData("QUSA"));
			pxTypes^.AddItem("Move Region ( MRGN )", new CTypeData("MRGN"));
			pxTypes^.AddItem("Set Neutral for World-Anml ( SNFA )", new CTypeData("SNFA"));
			pxTypes^.AddItem("Set Player ResourceCaps ( PLCP )", new CTypeData("PLCP"));
			pxTypes^.AddItem("Activate/Deactivate Region ( ARGN )", new CTypeData("ARGN"));
			pxTypes^.AddItem("NewsTicker message ( NWTK )", new CTypeData("NWTK"));
			pxTypes^.AddItem("UI FeedbackFrame ( UIFF )", new CTypeData("UIFF"));
			pxTypes^.AddItem("ScreenRegion ( SCRE )", new CTypeData("SCRE"));
			pxTypes^.AddItem("change QuestionMark State ( QMRK )", new CTypeData("QMRK"));
			pxTypes^.AddItem("Timer ( TIMR )", new CTypeData("TIMR"));
			pxTypes^.AddItem("Effect ( EFCT )", new CTypeData("EFCT"));
			pxTypes^.AddItem("Play DialogFeedback ( DGFB )", new CTypeData("DGFB"));
			//pxTypes^.SelectItemBeginningWithString(p_sType);
			pxTypes^.RemoveSelection();
			pxTypes^.QSort();

			m_pxTypes = pxTypes;
		endif;
	endconstructor;

	export destructor()
		if(m_pxTypes!=null)then
			var int i, iC = m_pxTypes^.NumItems();
			for(i=0) cond(i<iC) iter(++i) do
				delete m_pxTypes^.GetItemData(i);
			endfor;
			m_pxTypes^.Clear();
			m_pxTypes=null;
		endif;
	enddestructor;

	export proc string GetType()
		var ^CList pxTypes=cast<CList>(m_apxPages[0]^.GetControl("List_Type"));

		var int iItem = pxTypes^.GetSelectedItem();
		if(iItem >= 0)then
			var ^CTypeData pxTD = cast<CTypeData>(pxTypes^.GetItemData(iItem));
			if(pxTD!=null)then
				return pxTD^.m_xType.AsString();
			endif;
		endif;
		return "";
	endproc;
endclass;


//----------------------------------------------------------
// Class:	CActionUnitPages
//----------------------------------------------------------
class CActionUnitPages inherit CActionPages

	var ^CDropList	m_pxAttrib;
	var ^CEdit		m_pxValue;
	var ^CActionObjSelector m_pxObjSel;

	//----------------------------------------------------------
	// ctor()
	//----------------------------------------------------------
	export constructor(CGuid p_xGuid)
		m_apxPages=1;

		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_UNIT");

		m_pxAttrib 			= cast<CDropList>(m_apxPages[0]^.GetControl("Drop_Attribs"));
		m_pxValue			= cast<CEdit>(m_apxPages[0]^.GetControl("Edit_Value"));
		m_pxObjSel			= cast<CActionObjSelector>(m_apxPages[0]^.GetControl("ObjSelector"));

		m_pxAttrib^.SetAllowAnyText(true);
		m_pxObjSel^.Init(p_xGuid);

		m_pxObjSel^.m_xOnChange = UpdateAttribsList;
		m_pxObjSel^.m_pxSelector^.m_xOnStateChange = UpdateAttribsList;
	endconstructor;

	destructor()
	enddestructor;

	proc bool UpdateAttribsList()
		m_pxAttrib^.Clear();

		var ^CAttribs pxAttr = null;
		var ^CObj pxO = m_pxObjSel^.GetSelectedObj();
		if(pxO != null)then
			pxAttr = pxO^.GetAttribs();
		else
			var string sClass = m_pxObjSel^.GetSelectedClass();
			if(!sClass.IsEmpty())then
				pxO = CObjHelper.FindObjOfClass(sClass);
				if(pxO!=null)then
					pxAttr = pxO^.GetAttribs();
				endif;
			else
				var CFourCC xT = m_pxObjSel^.GetSelectedType();
				if(!(xT=="All"))then
					pxO = CObjHelper.FindObjOfType(xT);
					if(pxO!=null)then pxAttr=pxO^.GetAttribs();endif;
				endif;
			endif;
		endif;

		if(pxAttr!=null)then
			var int i, iC = pxAttr^.NumEntries();
			for (i=0) cond(i<iC) iter(++i) do
				var string sKey, sVal;
				if(pxAttr^.GetEntry(i, sKey, sVal))then
					m_pxAttrib^.AddItem(sKey);
				endif;
			endfor;
		endif;
		return true;
	endproc;

	//----------------------------------------------------------
	// OnInit()
	//----------------------------------------------------------
	export proc void OnInit(ref CAttribs p_rxParams)
		m_pxObjSel^.OnInit(p_rxParams);
		UpdateAttribsList();

		var string sAttr = p_rxParams.GetValue("attrib_name");
		if( sAttr != "")then
			m_pxValue^.SetText(p_rxParams.GetValue("attrib_mod"));
			m_pxValue^.SetDisabled(false);
			m_pxAttrib^.SetText(sAttr);
		endif;
	endproc;

	//----------------------------------------------------------
	// OnFinish()
	//----------------------------------------------------------
	export proc void OnFinish(ref CAttribs po_rxParams)
		m_pxObjSel^.OnFinish(po_rxParams);
		po_rxParams.SetValue("attrib_name", m_pxAttrib^.GetText());
		po_rxParams.SetValue("attrib_mod", m_pxValue^.GetText());
	endproc;

endclass;



//----------------------------------------------------------
// Class:	CActionRessesPages
//----------------------------------------------------------
class CActionRessesPages inherit CActionPages

	var ^CDropList 		m_pxPlayer;
	var ^CDropList		m_pxRes;
	var ^CEdit			m_pxMod;
	var ^CCheckBox		m_pxCapacity;
	var ^CList			m_pxResourcesList;
	var ^CButton		m_pxBtnApply;
	var ^CButton 		m_pxBtnRemove;

	export constructor()
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_RSRC");

		m_pxPlayer			= cast<CDropList>(m_apxPages[0]^.GetControl("Drop_Player"));
		m_pxRes				= cast<CDropList>(m_apxPages[0]^.GetControl("Drop_Res"));
		m_pxMod				= cast<CEdit>(m_apxPages[0]^.GetControl("Edit_Mod"));
		m_pxCapacity 		= cast<CCheckBox>(m_apxPages[0]^.GetControl("Check_Capacity"));
		m_pxResourcesList	= cast<CList>(m_apxPages[0]^.GetControl("List_Resources"));
		m_pxBtnApply		= cast<CButton>(m_apxPages[0]^.GetControl("Btn_Apply"));
		m_pxBtnRemove		= cast<CButton>(m_apxPages[0]^.GetControl("Btn_Remove"));
		

		var int i, iC=8;
		for(i=0) cond(i<iC) iter(++i) do
			m_pxPlayer^.AddItem(i.ToString());
		endfor;

		m_pxRes^.AddItem("wood");
		m_pxRes^.AddItem("stone");
		m_pxRes^.AddItem("food");
		//m_pxRes^.AddItem("resin");
		//m_pxRes^.AddItem("bone");
		//m_pxRes^.AddItem("hide");
		m_pxRes^.AddItem("iron");

		m_pxMod^.SetText("0");
		
		m_pxBtnApply^.m_xOnClick = OnApply;
		m_pxBtnRemove^.m_xOnClick = OnRemove;
		m_pxResourcesList^.m_xOnSelect = OnSelect;
		
	endconstructor;

	export proc void OnInit(ref CAttribs p_rxParams)
		var string sResourceList = p_rxParams.GetValue("res_rsrclist");	
			if(sResourceList!="")then
				var int i;
				var array string asTokens;
				sResourceList.Split(asTokens, ":", true);
				for (i=0) cond (i < asTokens.NumEntries()) iter(++i) do	
					m_pxResourcesList^.AddItem(asTokens[i]);
				endfor;
			else
				sResourceList=p_rxParams.GetValue("res_name")+"|"+p_rxParams.GetValue("res_mod")+"|"+p_rxParams.GetValueInt("res_cap").ToString();
				m_pxResourcesList^.AddItem(sResourceList);
			endif;
		m_pxResourcesList^.Select(0);
		OnSelect();
		m_pxPlayer^.Select(m_pxPlayer^.FindItem(p_rxParams.GetValueInt("player_id").ToString()));
		/*m_pxRes^.Select(m_pxRes^.FindItem(p_rxParams.GetValue("res_name")));
		m_pxMod^.SetText(p_rxParams.GetValue("res_mod"));
		m_pxCapacity^.SetChecked(p_rxParams.GetValueInt("res_cap"));*/
	endproc;
	
	export proc void OnFinish(ref CAttribs po_rxParams)
		if(m_pxResourcesList^.NumItems()>0)then
			var string sResourceList="";
			var int i;
			for (i=0) cond (i < m_pxResourcesList^.NumItems()) iter(++i) do
				sResourceList=sResourceList+m_pxResourcesList^.GetItem(i)+":";
			endfor;
			sResourceList.TrimRight(":");
			po_rxParams.SetValue("res_rsrclist", sResourceList);
		endif;
		if(m_pxRes^.GetSelectedItemAsString()!="")then
			po_rxParams.SetValue("player_id", m_pxPlayer^.GetSelectedItemAsString().ToInt());
			po_rxParams.SetValue("res_name", m_pxRes^.GetSelectedItemAsString());
			po_rxParams.SetValue("res_mod", m_pxMod^.GetText());
			po_rxParams.SetValue("res_cap", m_pxCapacity^.GetChecked());
		endif;
	endproc;
	
	proc bool OnApply()
		var string sResourceList;
		sResourceList=m_pxRes^.GetSelectedItemAsString()+"|"+m_pxMod^.GetText()+"|"+m_pxCapacity^.GetChecked().ToString();
		m_pxResourcesList^.AddItem(sResourceList);
		return true;
	endproc;
	
	proc bool OnRemove()
		var int iSel=-1;
		iSel=m_pxResourcesList^.GetSelectedItem();
		if(iSel<0)then return false; endif;
		m_pxResourcesList^.DeleteItem(iSel);
		m_pxResourcesList^.Select(iSel);
		return true;
	endproc;
	
	proc bool OnSelect()
		if(m_pxResourcesList^.OnSelect())then
			var string sRes = m_pxResourcesList^.GetSelectedItemAsString();		
			var array string asTokens;
			if(sRes!="")then
				sRes.Split(asTokens, "|", true);
				m_pxRes^.Select(m_pxRes^.FindItem(asTokens[0]));
				m_pxMod^.SetText(asTokens[1]);
				m_pxCapacity^.SetChecked(asTokens[2].ToInt());
			endif;
		endif;
		return true;
	endproc;
endclass;


//----------------------------------------------------------
// Class:	CActionQuitPages
//----------------------------------------------------------
class CActionQuitPages inherit CActionPages

	var ^CEdit			m_pxResult;

	export constructor()
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_QUIT");

		m_pxResult		= cast<CEdit>(m_apxPages[0]^.GetControl("Edit_Result"));
		m_pxResult^.SetText("Exit_0");
	endconstructor;

	export proc void OnInit(ref CAttribs p_rxParams)
		m_pxResult^.SetText(p_rxParams.GetValue("result"));
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		po_rxParams.SetValue("result", m_pxResult^.GetText());
	endproc;
endclass;


//----------------------------------------------------------

//----------------------------------------------------------
// Class:	CActionBoniPages
//----------------------------------------------------------
class CActionBoniPages inherit CActionPages

	var ^CSpinCtrlNumber			m_pxPoints;

	export constructor()
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_BONI");

		m_pxPoints = cast<CSpinCtrlNumber>(m_apxPages[0]^.GetControl("SpinCtrl_Boni"));
		m_pxPoints^.SetLimits(-10000,10000,10);
		m_pxPoints^.SetValue(0);
	endconstructor;

	export proc void OnInit(ref CAttribs p_rxParams)
		m_pxPoints^.SetValue(p_rxParams.GetValueInt("points"));
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		po_rxParams.SetValue("points", m_pxPoints^.GetValueInt());
	endproc;
endclass;


//----------------------------------------------------------
// Class:	CActionTrigPages
//----------------------------------------------------------
class CActionTrigPages inherit CActionPages

	var ^CRadioButton		m_pxOn, m_pxOff, m_pxToggle;
	var ^CTreeCtrl			m_pxTree;
	var ^CEdit				m_pxDesc;

	export constructor()
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_TRIG");

		m_pxTree 	= cast<CTreeCtrl>(m_apxPages[0]^.GetControl("GBox_Tree/Tree_Trigger"));
		m_pxOn 	 	= cast<CRadioButton>(m_apxPages[0]^.GetControl("Radio_Activate"));
		m_pxOff	 	= cast<CRadioButton>(m_apxPages[0]^.GetControl("Radio_Deactivate"));
		m_pxToggle	= cast<CRadioButton>(m_apxPages[0]^.GetControl("Radio_Toggle"));
		m_pxDesc 	= cast<CEdit>(m_apxPages[0]^.GetControl("Edit_Desc"));

		UpdateTree();

		m_pxTree^.m_xOnSelect = OnSelectTrigger;
	endconstructor;

	export proc void OnInit(ref CAttribs p_rxParams)
		var string sGuid = p_rxParams.GetValue("guid");
		var CGuid xGuid;
		xGuid.FromString(sGuid);

		var int iState = p_rxParams.GetValueInt("state");
		SetState(iState);

		var int iIdx = CLevelEditorWrap.GetTriggerDescMgr()^.FindTrigger(xGuid);
		if(iIdx<0)then return; endif;
		var ^CTriggerDesc pxCurTrig = CLevelEditorWrap.GetTriggerDescMgr()^.GetTrigger(iIdx);
		if(pxCurTrig != null)then
			var int iSelIdx = m_pxTree^.FindItem(0, pxCurTrig^.GetName());
			if(iSelIdx>=0)then
				m_pxTree^.Select(iSelIdx);
				m_pxTree^.EnsureVisible(iSelIdx);
			else
				KLog.LogError("UI.ViewActionCreate", "Trigger not in List");
			endif;
		endif;
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		var string sName = m_pxTree^.GetSelectedItemAsString();
		var string sGuid;
		var int i;
		for (i=0) cond (i<CLevelEditorWrap.GetTriggerDescMgr()^.NumTrigger()) iter (++i) do
			var ^CTriggerDesc pxTrig = CLevelEditorWrap.GetTriggerDescMgr()^.GetTrigger(i);
			if(pxTrig != null && pxTrig^.GetName()==sName)then
				sGuid = pxTrig^.GetGuid().ToString();
			endif;
		endfor;
		po_rxParams.SetValue("guid", sGuid);
		po_rxParams.SetValue("state", GetState());
	endproc;

	proc bool OnSelectTrigger()
		var string sName = m_pxTree^.GetSelectedItemAsString();
		var ^CTriggerDescMgr pxTM = CLevelEditorWrap.GetTriggerDescMgr();
		var int i, iC = pxTM^.NumTrigger();
		for(i=0) cond(i<iC) iter(++i) do
			var ^CTriggerDesc pxTDesc = pxTM^.GetTrigger(i);
			if(pxTDesc^.GetName() == sName)then
				m_pxDesc^.SetText(pxTDesc^.GetDesc());
				return true;
			endif;
		endfor;
		return false;
	endproc;

	proc int GetState()
		if(m_pxOn^.GetSelected())then return 1;
		elseif(m_pxOff^.GetSelected())then return 0;
		else return 2; endif;
	endproc;

	proc void SetState(int p_iState)
		if(p_iState==1)then m_pxOn^.SetSelected(true);
		elseif(p_iState==0)then m_pxOff^.SetSelected(true);
		else m_pxToggle^.SetSelected(true); endif;
	endproc;

	proc bool UpdateTree()
		var ^CTriggerDescMgr pxTriggerMgr = ^(CLevelEditorWrap.GetTriggerDescMgr());

		var CTriggerDescMgr.CNode xRoot = pxTriggerMgr^.GetHierarchyRoot();
		if(xRoot.IsValid())then
			FillTreeCtrlRec(xRoot, m_pxTree^.AddItem(0, xRoot.GetData()^.GetNodeName()));
		endif;
		return true;
	endproc;

	proc void FillTreeCtrlRec(CTriggerDescMgr.CNode p_xNode, int p_iItem)
		if(!p_xNode.IsValid())then return; endif;

		var int i, iC = p_xNode.GetData()^.NumTriggers();
		for(i=0) cond(i<iC) iter(++i) do
			var ^CTriggerDesc pxT = p_xNode.GetData()^.GetTrigger(i);
			if(pxT!=null)then
				var int iTriggerIdx = m_pxTree^.AddItem(p_iItem, pxT^.GetName());
			endif;
		endfor;

		iC = p_xNode.NumChildren();
		for(i=0) cond(i<iC) iter(++i) do
			var CTriggerDescMgr.CNode xChild = p_xNode.GetChild(i);
			if(xChild.IsValid())then
				FillTreeCtrlRec(xChild, m_pxTree^.AddItem(p_iItem, xChild.GetData()^.GetNodeName()));
			endif;
		endfor;
	endproc;
endclass;


//----------------------------------------------------------
// Class:	CActionMapsPages
//----------------------------------------------------------
class CActionMapsPages inherit CActionPages

	var ^CDropList			m_pxMaps;

	export constructor()
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_MAPS");

		m_pxMaps	= cast<CDropList>(m_apxPages[0]^.GetControl("Drop_Level"));
		var string sUrsRel = CClientWrap.GetUrsRelPath();

		var Filesystem.CFileList xFiles;
		var int iCount;
		var int i;
		iCount = xFiles.ReadListEx(sUrsRel+"/Data/Base/Maps/Testmaps", "*.ula", false, false);
		for (i=0) cond (i<iCount) iter (++i) do
			var string sFileName=xFiles[i].m_sName;
			var int iDot=sFileName.FindRev('.');
			sFileName.Delete(iDot,sFileName.GetLength()-iDot);
			if(!sFileName.IsEmpty())then
				m_pxMaps^.AddItem(sFileName);
			endif;
		endfor;
		iCount = xFiles.ReadListEx(sUrsRel+"/Data/Base/Maps/Testmaps", "*.lus", false, false);
		for (i=0) cond (i<iCount) iter (++i) do
			var string sFileName=xFiles[i].m_sName;
			var int iDot=sFileName.FindRev('.');
			sFileName.Delete(iDot,sFileName.GetLength()-iDot);
			if(!sFileName.IsEmpty())then
				m_pxMaps^.AddItem(sFileName);
			endif;
		endfor;

	endconstructor;

	export proc void OnInit(ref CAttribs p_rxParams)
		m_pxMaps^.Select(m_pxMaps^.FindItem(p_rxParams.GetValue("map_name")));
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		po_rxParams.SetValue("map_name", m_pxMaps^.GetSelectedItemAsString());
	endproc;
endclass;


//----------------------------------------------------------
// Class:	CActionOccupyPages
//----------------------------------------------------------
class CActionOccupyPages inherit CActionPages

	var ^CDropList			m_pxNewOwner;
	var ^CActionObjSelector	m_pxObjSelector;
	var ^CCheckBox			m_pxHighlightObj;
	var ^CEdit				m_pxTimeObjIsHighlighted;
	var ^CDropList			m_pxObject, m_pxClass;

	export constructor(CGuid p_xGuid)
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_OCPY");

		m_pxNewOwner = cast<CDropList>(m_apxPages[0]^.GetControl("Drop_Owner"));
		var int i;
		for(i=-1)cond(i<8)iter(++i)do
			m_pxNewOwner^.AddItem(i.ToString());
		endfor;

		m_pxObjSelector				= cast<CActionObjSelector>(m_apxPages[0]^.GetControl("ObjSelector"));
		m_pxObjSelector^.Init(p_xGuid);
		
		m_pxObject					= cast<CDropList>((m_apxPages[0]^.GetControl("ObjSelector/Drop_Object")));
		m_pxClass					= cast<CDropList>((m_apxPages[0]^.GetControl("ObjSelector/Drop_Class")));
		
		m_pxHighlightObj			= cast<CCheckBox>(m_apxPages[0]^.GetControl("Check_HighlightObj"));
		m_pxTimeObjIsHighlighted	= cast<CEdit>(m_apxPages[0]^.GetControl("Edit_HighlightTime"));
		
		m_pxHighlightObj^.m_xOnStateChange = OnHighlightObject;
		m_pxTimeObjIsHighlighted^.SetText("0");
		m_pxTimeObjIsHighlighted^.SetTextLimit(4);
	endconstructor;

	destructor()
	enddestructor;

	export proc void OnInit(ref CAttribs p_rxParams)
		m_pxNewOwner^.SetText(p_rxParams.GetValueInt("new_owner").ToString());
		if(m_pxObjSelector!=null)then m_pxObjSelector^.OnInit(p_rxParams); endif;
		m_pxTimeObjIsHighlighted^.SetText(p_rxParams.GetValueInt("highlight_time").ToString());
		m_pxHighlightObj^.SetChecked(p_rxParams.GetValueInt("chk_highlight"));
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		po_rxParams.SetValue("new_owner",m_pxNewOwner^.GetText().ToInt());
		po_rxParams.SetValue("highlight_time",m_pxTimeObjIsHighlighted^.GetText().ToInt());
		po_rxParams.SetValue("chk_highlight",m_pxHighlightObj^.GetChecked());
		if(m_pxObjSelector!=null)then m_pxObjSelector^.OnFinish(po_rxParams); endif;
		m_pxTimeObjIsHighlighted^.SetText(po_rxParams.GetValueInt("highlight_time").ToString());
	endproc;
	
	proc bool OnHighlightObject()
		if(m_pxHighlightObj^.GetChecked() == 1)then
			m_pxTimeObjIsHighlighted^.SetDisabled(false);
		else
			m_pxTimeObjIsHighlighted^.SetDisabled(true);
			m_pxTimeObjIsHighlighted^.SetText("0");
		endif;
		return true;
	endproc;
	
endclass;

//----------------------------------------------------------
// Class:	CActionCreateObjPages
//----------------------------------------------------------
class CActionCreateObjPages inherit CActionPages

	var ^CObjectTreeCtrl m_pxTree;
	var ^CStaticCtrl	m_pxName;
	var ^CDropList		m_pxOwner;
	var ^CEdit			m_pxPos;
	var ^CEdit 			m_pxRot;
	var ^CActionObjSelector m_pxObjSel;
	var ^CCheckBox 		m_pxPosFromObj;
	var ^CCheckBox 		m_pxIgnorePyramid;
	var ^CSpinCtrlNumber m_pxLevel;
	var int 				m_iCheck;
	var string			m_sTmpClass;
	var int					m_iTmpOwner;
	var string			m_sTmpPos;
	var string			m_sTmpRot;
	var ^CList			m_pxBuildUps;
	var point				m_xMousePlacement;
	
	export constructor(CGuid p_xGuid)
		CMainController.Get().AddNewClickProcRef(SetDummy);
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_COBJ");

		m_pxTree 	= cast<CObjectTreeCtrl>(m_apxPages[0]^.GetControl("Tree_Classes"));
		//m_pxName   	= cast<CStaticCtrl>(m_apxPages[0]^.GetControl("Text_Name"));
		m_pxOwner  	= cast<CDropList>(m_apxPages[0]^.GetControl("Drop_Owner"));
		m_pxPos		= cast<CEdit>(m_apxPages[0]^.GetControl("Edit_Pos"));
		m_pxRot 	= cast<CEdit>(m_apxPages[0]^.GetControl("Edit_Rot"));
		m_pxLevel 	= cast<CSpinCtrlNumber>(m_apxPages[0]^.GetControl("Spin_Level"));
		m_pxPosFromObj = cast<CCheckBox>(m_apxPages[0]^.GetControl("Chk_PosFromObj"));
		m_pxIgnorePyramid = cast<CCheckBox>(m_apxPages[0]^.GetControl("Chk_IgnorePyramid"));
		m_pxBuildUps	= cast<CList>(m_apxPages[0]^.GetControl("List_BuildUps"));
		m_pxObjSel 		= cast<CActionObjSelector>(m_apxPages[0]^.GetControl("ObjSelector"));
		m_pxObjSel^.Init(p_xGuid, "trgt_");
		m_pxObjSel^.SetDisabled(true);
		m_pxPosFromObj^.m_xOnStateChange = OnObjFromPos;
		m_iCheck=0;
		
		var int i;
		for (i=-1) cond (i<8) iter (++i) do
			m_pxOwner^.AddItem(i.ToString());
		endfor;

		m_pxTree^.FillTree(CObjectTreeCtrl.SHOW_ALL);
		m_pxTree^.m_xOnLBtnDblClick = OnDblClicked_Tree;
		m_pxPos^.SetText("0.0, 0.0, 0.0");
		m_pxRot^.SetText("0.0, 0.0, 0.0");
		m_pxRot^.m_xOnChange=OnChangeRot;
		m_pxTree^.m_xOnSelect = OnSelect;
		
		/*var ^CWindow pxWnd = CGameWrap.GetDesktop()^.GetControl("ActionCreate");
		if(pxWnd!=null)then
			(cast<CViewActionCreate>(pxWnd))^.ReleaseModal();
		endif;*/
	endconstructor;

	export destructor()
		CMainController.Get().RemoveNewClickProcRef(SetDummy);
		if(m_iCheck == 0)then
			HideDummyObj();
		endif;
		if(m_iCheck == 2)then 
			var vec3 vPos; vPos.FromString(m_sTmpPos);
			var vec3 vR; vR.FromString(m_sTmpRot);
			var Quat qR; qR.FromVec3(vR);
			ShowDummyObj(m_sTmpClass,m_iTmpOwner,vPos, qR);
		endif;
	enddestructor;
	
	proc bool OnObjFromPos()
		m_pxObjSel^.SetDisabled(m_pxPosFromObj^.GetChecked()==0);
		return true;
	endproc;

	proc bool SetPos()
		if(m_pxPosFromObj^.GetChecked()!=0)then
			var CClntHndl xHit = CClientWrap.GetObjMgr().GetHitObj();
			if(xHit.IsValid())then
				var ^CObj pxObj = xHit.GetObj();
				if(pxObj!=null)then
					var string sName = pxObj^.GetName();
					var int iIdx = sName.FindRev('_');
					if(iIdx>=0)then sName.Delete(iIdx, 999); endif;
	
					var int iItemIdx = m_pxTree^.FindItem(0, sName);
					if(iItemIdx >= 0)then
						m_pxTree^.Select(iItemIdx);
						m_pxTree^.EnsureVisible(iItemIdx);
						m_pxPos^.SetText(pxObj^.GetPos().ToString());
						m_pxRot^.SetText(pxObj^.GetRotation().ToString());
						m_pxOwner^.Select(m_pxOwner^.FindItem(pxObj^.GetOwner().ToString()));
						return true;
					endif;
				endif;
			endif;
		endif;

		var vec3 vPos = CClientWrap.GetScapeMgr().GetPickPoint();
		if(vPos.Abs()>0.1f)then
			var string sTmp = vPos.ToString();
			sTmp.TrimLeft("[");	sTmp.TrimRight("]");
			m_pxPos^.SetText(sTmp);
		endif;
		
		return true;
	endproc;

	proc bool OnDblClicked_Tree()
	//	m_pxName^.SetText(m_pxTree^.GetSelectedItemAsString());
		return true;
	endproc;

	export proc void OnInit(ref CAttribs p_rxParams)
		//m_pxName^.SetText(p_rxParams.GetValue("obj_name"));
		m_pxPos^.SetText(p_rxParams.GetValue("obj_pos"));
		m_pxRot^.SetText(p_rxParams.GetValue("obj_rot"));
		m_pxOwner^.Select(m_pxOwner^.FindItem(p_rxParams.GetValue("obj_owner")));
		m_pxTree^.OnInit(p_rxParams.GetValue("obj_name"));
		m_pxLevel^.SetValue(p_rxParams.GetValueInt("obj_level")+1);
		m_pxPosFromObj^.SetChecked(p_rxParams.GetValueInt("pos_from_obj"));
		m_pxIgnorePyramid^.SetChecked(p_rxParams.GetValueInt("ignore_pyramid"));
		m_pxObjSel^.OnInit(p_rxParams);
		var int iPos = m_pxBuildUps^.FindItem(p_rxParams.GetValue("buildup"));
		if(iPos>=0)then
			m_pxBuildUps^.Select(iPos);
		endif;
		m_iCheck=2;
		m_sTmpClass = p_rxParams.GetValue("obj_name");
		m_iTmpOwner = p_rxParams.GetValueInt("obj_owner");
		m_sTmpPos   = p_rxParams.GetValue("obj_pos");
		m_sTmpRot	= p_rxParams.GetValue("obj_rot");
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		po_rxParams.SetValue("obj_pos", m_pxPos^.GetText());
		var string sObj;
		po_rxParams.SetValue("obj_name", m_pxTree^.GetSelectedItemAsString());
		po_rxParams.SetValue("obj_owner", m_pxOwner^.GetSelectedItemAsString().ToInt());
		po_rxParams.SetValue("obj_rot", m_pxRot^.GetText());
		po_rxParams.SetValue("obj_level", m_pxLevel^.GetValueInt()-1);
		po_rxParams.SetValue("buildup", m_pxBuildUps^.GetSelectedItemAsString());
		po_rxParams.SetValue("renderable", 1);
		po_rxParams.SetValue("renderable_type", "CreationDummy");
		
		po_rxParams.SetValue("pos_from_obj", m_pxPosFromObj^.GetChecked());
		po_rxParams.SetValue("ignore_pyramid", m_pxIgnorePyramid^.GetChecked());
		m_pxObjSel^.OnFinish(po_rxParams);
		m_iCheck=1;
	endproc;
	
	proc bool OnSelect()
		m_pxBuildUps^.Clear();
		var ^CObjectTreeCtrl.CObjectItem pxItemData =cast <CObjectTreeCtrl.CObjectItem>( m_pxTree^.GetItemData(m_pxTree^.GetSelectedItem()));
		if(pxItemData!=null)then
			var ^CTechTree.CNode pxTechTreeNode = pxItemData^.m_pxNode;
			var int iObjTTLvl= pxTechTreeNode^.GetSubValueI("captainlevel");
//			m_pxLevel^.SetLimits(iObjTTLvl,5,1);
			m_pxLevel^.SetLimits(1,5,1);
			m_pxLevel^.SetValue(iObjTTLvl);
			var ^CTechTreeMgr pxTTMgr=^(CLevelEditorWrap.GetClient().GetTechTreeMgr());
			var int i,iC=pxTTMgr^.NumEntries();
			var string sAnimal = m_pxTree^.GetSelectedItemAsString();
			if(sAnimal!="")then
				for(i=0)cond(i<iC)iter(i++)do
					var string sPath=pxTTMgr^.GetFilterPath(i);
					if(sPath.Find("Upgrades/"+sAnimal) >= 0 && sPath.Find("_Remove") < 0  && sPath.Find("_Bonus") < 0 && sPath.Find("_capacity_") < 0 && sPath.Find("age_") < 0 && sPath.Find("_upgrade_") < 0 && sPath.Find("Lvl4_tt") < 0 && sPath.Find("Lvl5_tt") < 0 && sPath.Find("RangeEffect") < 0 && sPath.Find("_defensive_mode") < 0 && sPath.Find("pirate_captain") < 0)then
						var string sP = sPath;
						var int iP = sP.FindRev('/');
						sP.Delete(0,iP+1);
						if(m_pxBuildUps^.FindItem(sP)<0)then
							m_pxBuildUps^.AddItem(sP);
						endif;
					endif;
				endfor;
			endif;
			if(m_pxPos^.GetText()!="0.0,0.0,0.0")then
				var vec3 vPos; vPos.FromString(m_pxPos^.GetText());
				var string sRot   = m_pxRot^.GetText();
				var vec3 vR; vR.FromString(sRot);
				var Quat qR; qR.FromVec3(vR);
				var string sClass = m_pxTree^.GetSelectedItemAsString();
				if(sClass!="")then
					ShowDummyObj(sClass, m_pxOwner^.GetSelectedItemAsString().ToInt(),vPos, qR);
				endif;
			endif;
		endif;
		return true;
	endproc;
	
	proc void HandleRenderable()
		var string sClass = m_pxTree^.GetSelectedItemAsString();
		if(sClass!="")then
			var string sPos   = m_pxPos^.GetText();
			var vec3 vPos; vPos.FromString(sPos);
			var string sRot   = m_pxRot^.GetText();
			var vec3 vR; vR.FromString(sRot);
			var Quat qR; qR.FromVec3(vR);
			ShowDummyObj(sClass, m_pxOwner^.GetSelectedItemAsString().ToInt(), vPos, qR);
		endif;
	endproc;
	
	proc void HandleRenderable(bitset p_dwType, bitset p_dwFlags, int p_iX, int p_iY)
		var bool bShift = ((p_dwFlags&Msg.KM_SHIFT)!=0d);
		var string sClass = m_pxTree^.GetSelectedItemAsString();
		if(sClass!="" /*&& p_dwType==CInputController.MT_MouseMove*/)then
			var string sPos = m_pxPos^.GetText();
			var vec3 vPos; vPos.FromString(sPos);
			var string sRot = m_pxRot^.GetText();
			var vec3 vR; vR.FromString(sRot);
			var Quat qR; qR.FromVec3(vR);
			if(!bShift)then
				vPos = CClientWrap.GetScapeMgr().GetPickPoint();
				if(vPos.Abs()>0.1f)then
					var string sTmp = vPos.ToString();
					sTmp.TrimLeft("[");
					sTmp.TrimRight("]");
					m_pxPos^.SetText(sTmp);
				endif;
				m_xMousePlacement.SetX(p_iX);
				m_xMousePlacement.SetY(p_iY);
				ShowAndRotateDummy(sClass, m_pxOwner^.GetSelectedItemAsString().ToInt(), vPos, qR, p_iX,p_iY);
			else
				ShowAndRotateDummy(sClass, m_pxOwner^.GetSelectedItemAsString().ToInt(), vPos, qR, p_iX,p_iY);
				CWindowMgr.Get().SetMousePosNoMMove(m_xMousePlacement);
			endif;
			CMainController.Get().GetObjCreator()^.SetIgnoreMessages(true);
		endif;
	endproc;
	
	proc void ShowAndRotateDummy(string p_sClass, int p_iOwner, vec3 p_vPos, Quat p_qRot, int p_iX, int p_iY)
		if(p_sClass == "Healing" || p_sClass == "hu_spear_b_m" || p_sClass == "hu_spear_b_s")then return; endif;
		//var bool bNew = false;
		/*
		if(CLevelEditorWrap.GetObjMgr().GetGhost()==null || CLevelEditorWrap.GetObjMgr().GetGhost()^.GetClassName() != p_sClass)then
			bNew = true;
			CLevelEditorWrap.GetObjMgr().DeleteGhost();
			CLevelEditorWrap.GetObjMgr().CreateGhost(p_sClass);
		endif;
		*/
		if(CLevelEditorWrap.GetObjMgr().GetGhost()!=null)then
			CLevelEditorWrap.GetObjMgr().DeleteGhost();
		endif;
		CLevelEditorWrap.GetObjMgr().CreateGhost(p_sClass);
		var ^CGhost pxGhost = CLevelEditorWrap.GetObjMgr().GetGhost();
		if(pxGhost!=null)then
			pxGhost^.SetOwner(p_iOwner);
			pxGhost^.SetPos(p_vPos);
			//if(bNew)then
			pxGhost^.SetRot(p_qRot);
			//endif;
			var vec3 vRotation = pxGhost^.GetRotation();
			var int iDiffX = (p_iX - m_xMousePlacement.GetX())%360;
			vRotation.SetZ(vRotation.GetZ()+(iDiffX.ToReal()/360.0)*Math.Pi()*2.0);
			pxGhost^.SetRotation(vRotation);
			m_pxRot^.SetText(pxGhost^.GetRotation().ToString());
		endif;
	endproc;
	
	proc void ShowDummyObj(string p_sClass, int p_iOwner, vec3 p_vPos, Quat p_qRot)
		if(p_sClass == "Healing" || p_sClass == "hu_spear_b_m" || p_sClass == "hu_spear_b_s")then return; endif;
		if(CLevelEditorWrap.GetObjMgr().GetGhost()!=null)then
			CLevelEditorWrap.GetObjMgr().DeleteGhost();
		endif;
		
		CLevelEditorWrap.GetObjMgr().CreateGhost(p_sClass);
		var ^CGhost pxGhost = CLevelEditorWrap.GetObjMgr().GetGhost();
		if(pxGhost!=null)then
			pxGhost^.SetOwner(p_iOwner);
			pxGhost^.SetPos(p_vPos);
			pxGhost^.SetRot(p_qRot);
		endif;
		CMainController.Get().GetObjCreator()^.SetIgnoreMessages(true);
	endproc;
	
	proc bool SetDummy(bitset p_dwType, bitset p_dwFlags, int p_iX, int p_iY)
		if(m_pxTree^.GetSelectedItem() < 1)then return false; endif;
		if(m_pxPosFromObj^.GetChecked()==0 && m_pxTree^.GetSelectedItem()>0)then 
			HandleRenderable(p_dwType,p_dwFlags,p_iX,p_iY);
			return true;
		endif;
		return false;
	endproc;
	
	proc void HideDummyObj()
		CLevelEditorWrap.GetObjMgr().DeleteGhost();
		CMainController.Get().GetObjCreator()^.SetIgnoreMessages(false);
	endproc;
	
	proc bool OnChangeRot()
		if(m_pxTree^.GetSelectedItem() < 1)then return false; endif;
		if(m_pxPosFromObj^.GetChecked()==0 && m_pxTree^.GetSelectedItem()>0)then 
			HandleRenderable();
		endif;
		return true;
	endproc;
	
endclass;

//----------------------------------------------------------
// Class:	CActionShowFOW
//----------------------------------------------------------
class CActionShowFOWPages inherit CActionPages

	var ^CEdit		m_pxPos;
	var ^CEdit 		m_pxRadius;
	var ^CEdit		m_pxDuration;
	var ^CDropList	m_pxOwner;
	var ^CCheckBox	m_pxObjBound;
	var ^CActionObjSelector m_pxObjSel;
	
	export constructor(CGuid p_xGuid)
		CMainController.Get().AddClickProcRef(SetPos);
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_SFOW");

		m_pxPos 	= cast<CEdit>(m_apxPages[0]^.GetControl("Edit_Pos"));
		m_pxRadius 	= cast<CEdit>(m_apxPages[0]^.GetControl("Edit_Radius"));
		m_pxOwner 	= cast<CDropList>(m_apxPages[0]^.GetControl("Drop_Owner"));
		m_pxDuration= cast<CEdit>(m_apxPages[0]^.GetControl("Edit_Dur"));
		m_pxObjBound= cast<CCheckBox>(m_apxPages[0]^.GetControl("Check_ObjBound"));
		m_pxObjSel	= cast<CActionObjSelector>(m_apxPages[0]^.GetControl("ObjSelector"));


		m_pxObjBound^.m_xOnStateChange = OnCheckObjBound;
		var int i;
		for (i=-2) cond (i < 8) iter (++i) do
			m_pxOwner^.AddItem(i.ToString());
		endfor;

		m_pxObjSel^.Init(p_xGuid);
	endconstructor;

	destructor()
		CMainController.Get().RemoveClickProcRef(SetPos);
		CClientWrap.GetObjMgr().ClearPosiotionMarker();
	enddestructor;

	proc bool OnCheckObjBound()
		if(m_pxObjBound^.GetCheckMark())then
			m_pxObjSel^.SetDisabled(false);
			m_pxPos^.SetText("");
			m_pxPos^.SetDisabled(true);
		else
			m_pxObjSel^.SetDisabled(true);
			m_pxPos^.SetDisabled(false);
		endif;
		return true;
	endproc;

	proc bool SetPos()
		if(m_pxObjBound^.GetCheckMark())then return false; endif;
		var vec3 vPos = CClientWrap.GetScapeMgr().GetPickPoint();
		var string sTmp = vPos.ToString();
		sTmp.TrimLeft("[");	sTmp.TrimRight("]");
		m_pxPos^.SetText(sTmp);
		return true;
	endproc;

	proc bool OnChangePosRad()
		CClientWrap.GetObjMgr().SetPosiotionMarker("Region",vec3.CreateFromString(m_pxPos^.GetText()),m_pxRadius^.GetText().ToReal());
		return true;
	endproc;

	export proc void OnInit(ref CAttribs p_rxParams)
		var string sPos=p_rxParams.GetValue("pos");
		var int iRad=p_rxParams.GetValueInt("radius");
		m_pxPos^.SetText(sPos);
		m_pxRadius^.SetText(iRad.ToString());
		m_pxOwner^.Select(m_pxOwner^.FindItem(p_rxParams.GetValueInt("owner").ToString()));
		m_pxDuration^.SetText(p_rxParams.GetValueFloat("duration").ToString(1));

		CClientWrap.GetObjMgr().SetPosiotionMarker("Region",vec3.CreateFromString(sPos),iRad.ToReal());
		m_pxPos^.m_xOnChange=OnChangePosRad;
		m_pxRadius^.m_xOnChange=OnChangePosRad;

		m_pxObjSel^.OnInit(p_rxParams);

		var vec3 vP; vP.FromString(m_pxPos^.GetText());
		if(vP.Abs() < 0.0001f)then m_pxObjBound^.SetChecked(1); endif;
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		CClientWrap.GetObjMgr().ClearPosiotionMarker();
		var vec3 vPos;
		if(!m_pxObjBound^.GetCheckMark())then vPos.FromString(m_pxPos^.GetText()); endif;
		po_rxParams.SetValue("pos", vPos.ToString());
		po_rxParams.SetValue("radius", m_pxRadius^.GetText().ToInt());
		po_rxParams.SetValue("owner", m_pxOwner^.GetSelectedItemAsString().ToInt());
		po_rxParams.SetValue("duration", m_pxDuration^.GetText().ToReal());

		m_pxObjSel^.OnFinish(po_rxParams);
	endproc;
endclass;

//----------------------------------------------------------
// Class:	CActionPlaceCam
//----------------------------------------------------------
class CActionPlaceCamPages inherit CActionPages

	var ^CEdit		m_pxLookAt;
	var ^CDropList	m_pxClient;
	var ^CCheckBox	m_pxSetDefault;


	export constructor()
		CMainController.Get().AddClickProcRef(SetPos);
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_CAM");

		m_pxLookAt = cast<CEdit>(m_apxPages[0]^.GetControl("Edit_LookAt"));
		m_pxClient = cast<CDropList>(m_apxPages[0]^.GetControl("Drop_Client"));
		m_pxSetDefault = cast<CCheckBox>(m_apxPages[0]^.GetControl("Set_Default"));

		var int i;
		for (i=0) cond (i < 9) iter (++i) do
			m_pxClient^.AddItem(i.ToString());
		endfor;
	endconstructor;

	export destructor()
		CMainController.Get().RemoveClickProcRef(SetPos);
	enddestructor;

	proc bool SetPos()
		var vec3 vPos = CClientWrap.GetScapeMgr().GetPickPoint();
		var string sTmp = vPos.ToString();
		sTmp.TrimLeft("[");	sTmp.TrimRight("]");
		m_pxLookAt^.SetText(sTmp);
		return true;
	endproc;

	proc bool CheckLookAt()
		return CheckString(m_pxLookAt);
	endproc;

	proc bool CheckString( ^CEdit p_pxCtrl )
		if(p_pxCtrl==null)then return false; endif;
		var vec3 vTest;
		vTest.FromString(p_pxCtrl^.GetText());
		if(vTest == {0.0, 0.0, 0.0} )then
			CMessageBox.MsgBox("Invalid Value", "Value is not a valid vector");
			p_pxCtrl^.SetText("0.0, 0.0, 0.0");
			return false;
		endif;
		return true;
	endproc;

	export proc void OnInit(ref CAttribs p_rxParams)
		m_pxLookAt^.SetText(p_rxParams.GetValue("lookat"));
		m_pxClient^.Select(m_pxClient^.FindItem(p_rxParams.GetValueInt("client_id").ToString()));

		m_pxLookAt^.m_xOnUpdate = CheckLookAt;
		m_pxClient^.Select(m_pxClient^.FindItem(p_rxParams.GetValueInt("client_id").ToString()));
		
		m_pxSetDefault^.SetChecked(p_rxParams.GetValueInt("set_default"));
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		po_rxParams.SetValue("lookat", m_pxLookAt^.GetText());
		po_rxParams.SetValue("client_id", m_pxClient^.GetSelectedItemAsString().ToInt());
		po_rxParams.SetValue("set_default", m_pxSetDefault^.GetCheckMark());
	endproc;

endclass;

//----------------------------------------------------------
// Class:	ObjDo
//----------------------------------------------------------
class CActionObjDoPages inherit CActionPages

	var ^CActionObjSelector	m_pxObjSel;
	var ^CActionObjSelector	m_pxSubSel;
	var ^CObjSelector		m_pxObjSelObject;
	var ^CObjSelector		m_pxObjSelSubject;
	var ^CDropList			m_pxCommand;
	var ^CDropList			m_pxParams;
	var string				m_sPositionKeeper;
	var string				m_sLastCommand;
	var ^CDropList			m_pxObjectDropObj,m_pxTargetDropObj,m_pxObjectDropClass,m_pxTargetDropClass;
	var ^CCheckBox			m_pxSubjectsDis;

	export constructor(CGuid p_xGuid)
		CMainController.Get().AddClickProcRef(SetPos);
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_ACDO");

		m_sPositionKeeper="[0.0f 0.0f 0.0f]";

		m_pxObjSel			= cast<CActionObjSelector>(m_apxPages[0]^.GetControl("GBox_Object/ObjSelector"));
		m_pxSubSel			= cast<CActionObjSelector>(m_apxPages[0]^.GetControl("GBox_Subject/TargetSelector"));
		m_pxCommand 		= cast<CDropList>(m_apxPages[0]^.GetControl("Drop_Command"));
		m_pxParams			= cast<CDropList>(m_apxPages[0]^.GetControl("Drop_Params"));
		
		m_pxSubjectsDis		= cast<CCheckBox>(m_apxPages[0]^.GetControl("Subject_Disabled"));
		m_pxSubjectsDis^.SetVisible(false);
		m_pxSubjectsDis^.m_xOnStateChange = OnSubjectsStateChange;
		
		m_pxObjectDropObj	= cast<CDropList>(m_apxPages[0]^.GetControl("GBox_Object/ObjSelector/ObjSelector/ObjSelector/Drop_Object"));
		m_pxTargetDropObj	= cast<CDropList>(m_apxPages[0]^.GetControl("GBox_Subject/TargetSelector/ObjSelector/ObjSelector/Drop_Object"));
		m_pxObjectDropClass	= cast<CDropList>(m_apxPages[0]^.GetControl("GBox_Object/ObjSelector/ObjSelector/ObjSelector/Drop_Class"));
		m_pxTargetDropClass	= cast<CDropList>(m_apxPages[0]^.GetControl("GBox_Subject/TargetSelector/ObjSelector/ObjSelector/Drop_Class"));
		
		//m_pxObjectDropObj^.m_xOnChange		= ShowObjectObjItem;
		//m_pxTargetDropObj^.m_xOnChange		= ShowTargetObjItem;

		m_pxParams^.SetAllowAnyText(true);

		m_pxCommand^.AddItem("WalkAction");
		m_pxCommand^.AddItem("Aggressive Walk");
		m_pxCommand^.AddItem("AdvanceAction");
		m_pxCommand^.AddItem("SetPos");
		m_pxCommand^.AddItem("RotateTo");
		m_pxCommand^.AddItem("Attack");
		m_pxCommand^.AddItem("PrepareUnboard");
		m_pxCommand^.AddItem("SetAnim");
		m_pxCommand^.AddItem("Kill");
		m_pxCommand^.AddItem("AbortTask");
		m_pxCommand^.AddItem("WeaponRemove"); //Kr1s1m: Added a weapon removal ACDO (ActionObjDo) trigger to perform disarm
		m_pxCommand^.AddItem("Open Gate");
		m_pxCommand^.AddItem("Close Gate");
		m_pxCommand^.AddItem("Auto Gate");
		m_pxCommand^.AddItem("Invulnerability");
		m_pxCommand^.AddItem("Disguise");
		m_pxCommand^.AddItem("Oracle");
		m_pxCommand^.AddItem("entrench");
		m_pxCommand^.AddItem("lockpicking");
		m_pxCommand^.AddItem("JumpOffWall");
		m_pxCommand^.AddItem("camouflage");
		m_pxCommand^.AddItem("LevelUp");
		m_pxCommand^.AddItem("Walk");
		m_pxCommand^.AddItem("FountainHeal");
		m_pxCommand^.AddItem("BoardTransporter");
		m_pxCommand^.AddItem("UnboardTransporter");
		m_pxCommand^.AddItem("AggroState");
		m_pxCommand^.AddItem("Stop");
		m_pxCommand^.AddItem("Hu Ladder");
		m_pxCommand^.AddItem("FeignDeath");
		m_pxCommand^.AddItem("RamAttack");
		m_pxCommand^.AddItem("BuildDown");
		m_pxCommand^.AddItem("GiveItem");
		m_pxCommand^.AddItem("Repair");
		m_pxCommand^.AddItem("Coles Shotgun");
		m_pxCommand^.AddItem("Belas Throwdown-Shot");
		m_pxCommand^.AddItem("AjeQuicksand");
		m_pxCommand^.AddItem("TeslaLvl16Task");
		m_pxCommand^.AddItem("Whirlewind");
		m_pxCommand^.AddItem("SetRallyPoint");
		m_pxCommand^.AddItem("BuildUp");
		m_pxCommand^.AddItem("FullHeal");
		m_pxCommand^.AddItem("StartHatching");
		m_pxCommand^.AddItem("Use");
		m_pxCommand^.AddItem("HarvestWood");
		m_pxCommand^.AddItem("SetBlocker");
		m_pxCommand^.AddItem("SetNoParticles");
		m_pxCommand^.AddItem("SetDisableShadowCast");
		m_pxCommand^.AddItem("SetDisableShadowReceive");
		m_pxCommand^.AddItem("Production");

		m_pxCommand^.m_xOnChange = OnSelectCommand;

		m_pxObjSel^.Init(p_xGuid);
		m_pxSubSel^.Init(p_xGuid, "dst_");

		m_pxObjSel^.m_xOnChange = OnSelectCommand;
		m_pxObjSel^.m_pxSelector^.m_xOnStateChange = OnSelectCommand;
	endconstructor;

	destructor()
		CMainController.Get().RemoveClickProcRef(SetPos);
		CClientWrap.GetObjMgr().ClearPosiotionMarker();
	enddestructor;
	
	proc bool SetPos()
		if(m_pxParams^.GetDisabled())then return false; endif;
		var vec3 vPos = CClientWrap.GetScapeMgr().GetPickPoint();
		if(vPos.Abs()>0.01)then
			var string sTmp = vPos.ToString();		
			m_sPositionKeeper=sTmp;
			CClientWrap.GetObjMgr().SetPosiotionMarker("Region",vPos);
			if(m_pxCommand^.GetText()=="WalkAction" || m_pxCommand^.GetText()=="SetPos" || m_pxCommand^.GetText()=="Aggressive Walk" || m_pxCommand^.GetText()=="RotateTo")then
				var string sT = m_pxParams^.GetText();
				var array string asToks;
				sT.Split(asToks, "|", true);
				sT = sTmp;
	
				if(asToks.NumEntries()>1)then
					asToks[1].TrimLeft(" ");
					sT+= " | " + asToks[1];
				endif;
	
				m_pxParams^.SetText(sT);
			elseif(m_pxCommand^.GetText()=="Oracle")then
				m_pxParams^.SetText(m_sPositionKeeper);
			elseif(m_pxCommand^.GetText()=="PrepareUnboard")then
				m_pxParams^.SetText(m_sPositionKeeper);
			elseif(m_pxCommand^.GetText()=="SetRallyPoint")then
				m_pxParams^.SetText(sTmp);
			elseif(m_pxCommand^.GetText()=="HarvestWood")then
				if(m_pxSubjectsDis^.GetChecked() == 1)then
					m_pxParams^.SetText(m_sPositionKeeper);
				endif;
				m_pxParams^.SetText(m_sPositionKeeper);
			elseif(m_pxCommand^.GetText() == "AjeQuicksand" || m_pxCommand^.GetText() == "Whirlewind")then
				if(m_pxSubjectsDis^.GetChecked() == 1)then
					m_pxParams^.SetText(sTmp);
				endif;
			endif;
		endif;
		return true;
	endproc;

	proc bool ShowItem(^CObj p_pxObject)	
		var vec3 vPos = p_pxObject^.GetPos();
		CMainController.Get().SetCameraTarget(vPos);
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		if(pxSel!=null)then
			var CClntHndl xHndl = p_pxObject^.GetHandle();
			if(xHndl.IsValid()==false)then return false; endif;
			pxSel^.Clear();
			pxSel^.Select(xHndl);
		endif;
		return true;
	endproc;
	
	proc bool ShowObjectObjItem()
		var ^CObj pxO = m_pxObjSel^.GetSelectedObj();
		if(pxO!=null)then 
			ShowItem(pxO);
		endif;
		return true;
	endproc;
	
	proc bool ShowTargetObjItem()	
		var ^CObj pxO = m_pxSubSel^.GetSelectedObj();
		if(pxO!=null)then 
			ShowItem(pxO);
		endif;
		return true;
	endproc;

	proc bool OnSelectCommand()
		var string sCmd = m_pxCommand^.GetText();
		if(sCmd==m_sLastCommand)then
			return true;
		endif;
		CClientWrap.GetObjMgr().ClearPosiotionMarker();
		m_pxParams^.Clear();
		m_pxParams^.SetToolTipText("");
		m_sLastCommand=sCmd;
		if(sCmd == "WalkAction" || sCmd == "SetPos" || sCmd=="Aggressive Walk" || sCmd=="RotateTo")then
			m_pxParams^.SetText(m_sPositionKeeper+" | 2");
			m_pxParams^.SetToolTipText("vec3 Destination | int Speed");
			m_pxParams^.SetDisabled(false);
			m_pxSubjectsDis^.SetVisible(false);
			//m_pxSubSel^.SetDisabled(true);
		elseif(sCmd == "PrepareUnboard")then
			m_pxParams^.SetText(m_sPositionKeeper);
			m_pxParams^.SetToolTipText("vec3 Destination");
			m_pxParams^.SetDisabled(false);
			m_pxSubjectsDis^.SetVisible(false);
			//m_pxSubSel^.SetDisabled(true);
		elseif(sCmd == "Attack")then
			m_pxParams^.SetText("");
			m_pxParams^.SetToolTipText("Don't need additional params");
			m_pxParams^.SetDisabled(true);
			m_pxSubSel^.SetDisabled(false);
			m_pxSubjectsDis^.SetVisible(false);
		elseif(sCmd == "AdvanceAction")then
			m_pxParams^.SetText("1.0 | 3");
			m_pxParams^.SetToolTipText("MinDistance | WalkSpeed");
			m_pxParams^.SetDisabled(false);
			m_pxSubSel^.SetDisabled(false);
			m_pxSubjectsDis^.SetVisible(false);
		elseif(sCmd == "Open Gate")then
			m_pxParams^.SetDisabled(true);
			m_pxSubSel^.SetDisabled(true);
			m_pxSubjectsDis^.SetVisible(false);
		elseif(sCmd == "Close Gate")then
			m_pxParams^.SetDisabled(true);
			m_pxSubSel^.SetDisabled(true);
			m_pxSubjectsDis^.SetVisible(false);
		elseif(sCmd == "SetAnim")then
			var ^CObj pxO = m_pxObjSel^.GetSelectedObj();
			var CStringArray asAnims;
			if(pxO!=null)then
				pxO^.GetAllAnims(asAnims);
			else
				var string sClass = m_pxObjSel^.GetSelectedClass();
				if(!sClass.IsEmpty())then
					CClientWrap.GetObjMgr().CreateGhost(sClass);

					var ^CGhost pxG = CClientWrap.GetObjMgr().GetGhost();
					if(pxG!=null)then
						pxG^.GetAllAnims(asAnims);
					endif;
					CClientWrap.GetObjMgr().DeleteGhost();
				endif;
			endif;
			var int i, iC = asAnims.NumEntries();
			for (i=0) cond(i<iC) iter(++i) do
				m_pxParams^.AddItem(asAnims[i] + " | 1");
			endfor;
			m_pxParams^.SetToolTipText("(string)Name of the animation | (int)NumLoops.");
			m_pxParams^.SetDisabled(false);
			m_pxSubSel^.SetDisabled(true);
			m_pxSubjectsDis^.SetVisible(false);
		elseif(sCmd == "Kill")then
			m_pxParams^.SetText("");
			m_pxParams^.SetDisabled(true);
			m_pxSubSel^.SetDisabled(true);
			m_pxSubjectsDis^.SetVisible(false);
		elseif(sCmd == "AbortTask")then
			m_pxParams^.SetText("");
			m_pxParams^.SetDisabled(true);
			m_pxSubSel^.SetDisabled(true);
			m_pxSubjectsDis^.SetVisible(false);
		elseif(sCmd == "WeaponRemove")then //Kr1s1m: If the command is weapon removal then...
			//Kr1s1m: ...set up view similar to Invulnerability:
			m_pxParams^.SetDisabled(false);
			m_pxParams^.AddItem("Enable");
			m_pxParams^.AddItem("Disable");
			m_pxParams^.AddItem("Timer: ");
			m_pxParams^.SetToolTipText("To set the Timer enter timespan after the -> Timer:");
			m_pxSubSel^.SetDisabled(false);
			m_pxSubjectsDis^.SetVisible(false);
		elseif(sCmd == "Invulnerability")then
			m_pxParams^.SetDisabled(false);
			m_pxParams^.AddItem("Enable");
			m_pxParams^.AddItem("Disable");
			m_pxParams^.AddItem("Timer: ");
			m_pxParams^.SetToolTipText("To set the Timer enter timespan after the -> Timer:");
			m_pxSubSel^.SetDisabled(false);
			m_pxSubjectsDis^.SetVisible(false);
		elseif(sCmd == "Coles Shotgun")then
			m_pxParams^.SetDisabled(true);
			m_pxSubSel^.SetDisabled(false);
			m_pxSubjectsDis^.SetVisible(false);
		elseif(sCmd == "Belas Throwdown-Shot")then
			m_pxParams^.SetDisabled(true);
			m_pxSubSel^.SetDisabled(false);
			m_pxSubjectsDis^.SetVisible(false);
		elseif(sCmd == "Disguise")then
			m_pxParams^.SetDisabled(true);
			m_pxSubSel^.SetDisabled(true);
			m_pxSubjectsDis^.SetVisible(false);
		elseif(sCmd == "Oracle")then
			m_pxParams^.SetDisabled(false);
			m_pxSubSel^.SetDisabled(true);
			m_pxSubjectsDis^.SetVisible(false);
		elseif(sCmd == "AjeQuicksand" || sCmd == "Whirlewind" )then
			m_pxSubjectsDis^.SetVisible(true);
			m_pxParams^.SetDisabled(true);
		elseif(sCmd == "BuildUp")then
			m_pxParams^.SetDisabled(true);
			m_pxSubSel^.SetDisabled(false);
			m_pxSubjectsDis^.SetVisible(false);
		elseif(sCmd == "FullHeal")then
			m_pxParams^.SetDisabled(true);
			m_pxSubSel^.SetDisabled(true);
			m_pxSubjectsDis^.SetVisible(false);
		elseif(sCmd == "StartHatching")then
			m_pxParams^.SetDisabled(true);
			m_pxSubSel^.SetDisabled(true);
			m_pxSubjectsDis^.SetVisible(false);
		elseif(sCmd == "HarvestWood")then
			m_pxParams^.SetText(m_sPositionKeeper);
			m_pxParams^.SetToolTipText("vec3 Destination");
			m_pxSubjectsDis^.SetVisible(true);
			//m_pxSubSel^.SetDisabled(true);
		elseif(sCmd == "SetBlocker"||sCmd == "SetNoParticles"||sCmd == "SetDisableShadowCast"||sCmd == "SetDisableShadowReceive")then
//			m_pxParams^.SetText("true");
			m_pxParams^.AddItem("true");
			m_pxParams^.AddItem("false");
			m_pxParams^.SetToolTipText("use 'true' or 'false' (without apostrophes...)");
			m_pxParams^.SetDisabled(false);
			m_pxSubjectsDis^.SetVisible(false);
		elseif(sCmd == "Production")then
			m_pxParams^.SetToolTipText("Type in the path for the Action you want the object to execute. \nTo make the barracks produce a level 3 NM warrior (without apostrophes!): 'Actions/Hu/Build/CHTR/hu_warrior_3' \nTo skip conditions checking (resources, unit limit, etc) the ending part should be this (with starting space and without apostrophes!): ' /AI_Help'");
			m_pxParams^.SetDisabled(false);
			m_pxSubjectsDis^.SetVisible(false);
		endif;
		return true;
	endproc;

	proc bool OnSubjectsStateChange()
		if(m_pxSubjectsDis^.GetChecked() == 1)then
			m_pxParams^.SetDisabled(false);
			m_pxParams^.SetText("[0.0f 0.0f 0.0f]");
			m_pxSubSel^.SetDisabled(true);
		else
			m_pxParams^.SetDisabled(true);
			m_pxParams^.SetText("[0.0f 0.0f 0.0f]");
			m_pxSubSel^.SetDisabled(false);
		endif;
		return true;	
	endproc;

	proc bool OnSelectTarget()
		return true;
	endproc;

	export proc void OnInit(ref CAttribs p_rxParams)
		m_pxObjSel^.OnInit(p_rxParams);
		m_pxSubSel^.OnInit(p_rxParams);
		m_pxCommand^.Select(m_pxCommand^.FindItem(p_rxParams.GetValue("action")));
		if(p_rxParams.GetValue("action") == "AjeQuicksand" || p_rxParams.GetValue("action") == "Whirlewind" || p_rxParams.GetValue("action") == "HarvestWood")then
			m_pxSubjectsDis^.SetVisible(true);
			m_pxSubjectsDis^.SetChecked(p_rxParams.GetValueInt("check_subj"));
		endif;
		m_pxParams^.SetText(p_rxParams.GetValue("additional_params"));
		var vec3 vPos;
		var array string asTokens;
		if(p_rxParams.GetValue("additional_params").GetLength() > 0)then
			p_rxParams.GetValue("additional_params").Split(asTokens, "|", true);
			if(asTokens[0].GetLength() < 9 || vPos.ToBool() == false)then
				return; 
			else
				vPos.FromString(asTokens[0]);
				CClientWrap.GetObjMgr().SetPosiotionMarker("Region",vPos);
			endif;
		endif;
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		m_pxObjSel^.OnFinish(po_rxParams);
		m_pxSubSel^.OnFinish(po_rxParams);
		po_rxParams.SetValue("action", m_pxCommand^.GetText());
		po_rxParams.SetValue("additional_params", m_pxParams^.GetText());
		po_rxParams.SetValue("check_subj",m_pxSubjectsDis^.GetChecked().ToString());
		CClientWrap.GetObjMgr().ClearPosiotionMarker();
	endproc;

endclass;


class CTightMultistateButton inherit CButton

	var array string m_asStates;
	var int			 m_iCurState;

	export constructor()
		m_iCurState=0;

		m_xOnClick = OnClick;
	endconstructor;

	export proc void AddState(string p_sState)
		m_asStates.AddEntry(p_sState);
	endproc;

	export proc void ClearStates()
		m_asStates=0;
	endproc;

	proc int GetNextState()
		var int iState = m_iCurState;
		++iState;
		if(iState>=m_asStates.NumEntries())then
			iState=0;
		endif;
		return iState;
	endproc;

	export proc bool CallOnClick() //Hack
		return OnClick();
	endproc; 

	proc bool OnClick()
		m_iCurState = GetNextState();
		SetText(m_asStates[m_iCurState]);
		return true;
	endproc;

	export proc string GetStateAsString()
		return m_asStates[m_iCurState];
	endproc;

	export proc int GetState()
		return m_iCurState;
	endproc;

	export proc void SetState(int p_iState)
		m_iCurState = p_iState;
		SetText(m_asStates[m_iCurState]);
	endproc;
endclass;

//----------------------------------------------------------
// Class:	CActionWaypointsPages
//----------------------------------------------------------
class CActionWaypointsPages inherit CActionPages

	//var ^CDropList 	m_pxObject;
	var ^CList		m_pxWaypoints;
	var ^CButton	m_pxBtnAdd;
	var ^CButton 	m_pxBtnRem;
	var ^CEdit		m_pxPosition;
	var ^CTightMultistateButton m_pxPatrol;
	var ^CActionObjSelector m_pxObjSel;
	var ^CSpinCtrlNumber m_pxSpeed;
	var ^CCheckBox m_pxIgnoreMaterial;
	var ^CCheckBox m_pxStraightWalk;

	export constructor(CGuid p_xGuid)
		CMainController.Get().AddClickProcRef(SetPos);
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_WYPT");

		//m_pxObject 		= cast<CDropList>(m_apxPages[0]^.GetControl("Drop_Object"));
		m_pxObjSel		= cast<CActionObjSelector>(m_apxPages[0]^.GetControl("ObjSelector"));
		m_pxWaypoints 	= cast<CList>(m_apxPages[0]^.GetControl("List_Waypoints"));
		m_pxBtnAdd		= cast<CButton>(m_apxPages[0]^.GetControl("Btn_Add"));
		m_pxBtnRem		= cast<CButton>(m_apxPages[0]^.GetControl("Btn_Rem"));
		m_pxPosition	= cast<CEdit>(m_apxPages[0]^.GetControl("Edit_Position"));
		m_pxPatrol 		= cast<CTightMultistateButton>(m_apxPages[0]^.GetControl("Tight_Patrol"));
		m_pxSpeed 		= cast<CSpinCtrlNumber>(m_apxPages[0]^.GetControl("Spin_Speed"));
		m_pxIgnoreMaterial = cast<CCheckBox>(m_apxPages[0]^.GetControl("Chk_IgnoreMaterial"));
		m_pxStraightWalk = cast<CCheckBox>(m_apxPages[0]^.GetControl("Chk_StraightWalk"));

		m_pxPatrol^.AddState("Simple Walk");
		m_pxPatrol^.AddState("Circular Patrol");
		m_pxPatrol^.AddState("Linear Patrol");
		m_pxPatrol^.SetState(0);
		//m_pxObject^.AddItem("From Condition");
		//FillObjList(m_pxObject);

		m_pxObjSel^.Init(p_xGuid);
		m_pxBtnAdd^.m_xOnClick = OnAdd;
		m_pxBtnRem^.m_xOnClick = OnRem;
		m_pxWaypoints^.m_xOnSelect = OnSelectWpt;
		m_pxPosition^.m_xOnUpdate = OnChangePos;

		/*var ^CWindow pxWnd = CGameWrap.GetDesktop()^.GetControl("ActionCreate");
		if(pxWnd!=null)then
			(cast<CViewActionCreate>(pxWnd))^.ReleaseModal();
		endif;*/
	endconstructor;

	destructor()
		CMainController.Get().RemoveClickProcRef(SetPos);
	enddestructor;

	export proc void OnInit(ref CAttribs p_rxParams)
		/*var ^CWindow pxWnd = CGameWrap.GetDesktop()^.GetControl("ActionCreate");
		if(pxWnd!=null)then
			(cast<CViewActionCreate>(pxWnd))^.ReleaseModal();
		endif;*/

		/*var string sObj = p_rxParams.GetValue("obj_guid");
		if(sObj=="From Condition")then
			m_pxObject^.Select(0);
		else
			var CGuid xGuid;
			xGuid.FromString(sObj);
			var CClntHndl xHndl = CObjHelper.GetObjByGuid(xGuid);
			if(xHndl.IsValid())then
				m_pxObject^.Select(m_pxObject^.FindItem(xHndl.GetObj()^.GetName()));
			endif;
		endif;*/

		var string sWpts = p_rxParams.GetValue("waypoints");
		var array string asTokens;
		sWpts.Split(asTokens, "|", true);
		if(asTokens.NumEntries()>0 && asTokens[0]!="0.0, 0.0, 0.0")then
			var vec3 vPos;
			vPos.FromString(asTokens[0]);
			CMainController.Get().SetCameraTarget(vPos);
		endif;
		
		var int i;
		var bool bTmp = true;
		for (i=0) cond (i<asTokens.NumEntries()) iter (++i) do
			m_pxWaypoints^.AddItem("Wpt_" + (i+1).ToString() + " : " + asTokens[i]);				
		endfor;
		
		var ^CObjMgr.CWaypointPath pxPath = CLevelEditorWrap.GetObjMgr().GetWaypointPath();
		pxPath^.SetDraw(true);
		m_pxPatrol^.SetState(p_rxParams.GetValueInt("patrolmode"));
		m_pxObjSel^.OnInit(p_rxParams);
		m_pxSpeed^.SetValue(p_rxParams.GetValueInt("walkspeed"));
		m_pxIgnoreMaterial^.SetChecked(p_rxParams.GetValueInt("ignorematerial"));
		m_pxStraightWalk^.SetChecked(p_rxParams.GetValueInt("straightwalk"));
	endproc;

	proc bool SetPos()
		var vec3 vPos = CClientWrap.GetScapeMgr().GetPickPoint();
		var string sTmp = vPos.ToString();
		sTmp.TrimLeft("[");	sTmp.TrimRight("]");
		m_pxPosition^.SetText(sTmp);
		OnChangePos();
		return true;
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)

		/*if(m_pxObject^.GetSelectedItemAsString() == "From Condition")then
			po_rxParams.SetValue("obj_guid", "From Condition");
		else
			var CClntHndl xObj = CObjHelper.GetObjByName(m_pxObject^.GetSelectedItemAsString());
			if(xObj.IsValid())then
				po_rxParams.SetValue("obj_guid", xObj.GetObj()^.GetGuid().ToString());
			endif;
		endif;
		*/
		m_pxObjSel^.OnFinish(po_rxParams);
		var string sWpts = "";

		var int i;
		for (i=0) cond (i < m_pxWaypoints^.NumItems()) iter(++i) do
			var string sTmp = m_pxWaypoints^.GetItem(i);
			sTmp.Delete(0, sTmp.FindRev(':')+1);
			sTmp.TrimLeft();
			sWpts+= sTmp + "|";
		endfor;

		po_rxParams.SetValue("waypoints", sWpts);

		po_rxParams.SetValue("renderable", 1);
		po_rxParams.SetValue("renderable_type", "Waypoints");
		po_rxParams.SetValue("renderable_name", "Waypoints-Action");

		po_rxParams.SetValue("patrolmode", m_pxPatrol^.GetState());
		po_rxParams.SetValue("walkspeed", m_pxSpeed^.GetValueInt());

		var int iIgnoreMaterial = 0;
		if(m_pxIgnoreMaterial^.GetCheckMark())then
			iIgnoreMaterial = 1;
		endif;
		var int iStraightWalk = 0;
		if(m_pxStraightWalk^.GetCheckMark())then
			iStraightWalk = 1;
		endif;
		po_rxParams.SetValue("straightwalk", iStraightWalk);
		po_rxParams.SetValue("ignorematerial", iIgnoreMaterial);
	endproc;

	proc bool OnSelectWpt()
		var string sTmp = m_pxWaypoints^.GetSelectedItemAsString();
		sTmp.Delete(0, sTmp.Find(":")+1);
		m_pxPosition^.SetText(sTmp);
		return true;
	endproc;

	proc bool OnAdd()
		m_pxWaypoints^.AddItem("Wpt_" + (m_pxWaypoints^.NumItems()+1).ToString() + "  : 0.0, 0.0, 0.0");
		m_pxWaypoints^.Select(m_pxWaypoints^.NumItems()-1);
		var ^CObjMgr.CWaypointPath pxPath = CLevelEditorWrap.GetObjMgr().GetWaypointPath();
		var vec3 vP;
		pxPath^.AddWaypoint(vP);
		pxPath^.SetDraw(true);
		return true;
	endproc;

	proc bool OnRem()
		var int iIdx = m_pxWaypoints^.GetSelectedItem();
		if(iIdx >= 0)then
			m_pxWaypoints^.DeleteItem(iIdx);
			var ^CObjMgr.CWaypointPath pxPath = CLevelEditorWrap.GetObjMgr().GetWaypointPath();
			pxPath^.RemWaypoint(iIdx);
			pxPath^.SetDraw(true);
		endif;
		return true;
	endproc;

	proc bool OnChangePos()
		var int iIdx = m_pxWaypoints^.GetSelectedItem();
		if(iIdx>=0)then
			var string sTmp = m_pxWaypoints^.GetSelectedItemAsString();
			var string sPre = sTmp.Left(7);
			m_pxWaypoints^.SetItemText(iIdx, sPre + ": " + m_pxPosition^.GetText());

			var vec3 vP; vP.FromString(m_pxPosition^.GetText());
			var ^CObjMgr.CWaypointPath pxPath = CLevelEditorWrap.GetObjMgr().GetWaypointPath();
			pxPath^.GetWaypoint(iIdx) = vP;
		endif;
		return true;
	endproc;

endclass;


//----------------------------------------------------------
// Class:	CActionAIKotHPages
//----------------------------------------------------------
class CActionAIKotHPages inherit CActionPages

	//var ^CDropList 	m_pxObject;
	var ^CList		m_pxAreas;
	var ^CButton	m_pxBtnAdd;
	var ^CButton 	m_pxBtnRem;
	var ^CEdit		m_pxPosition;
	var ^CEdit		m_pxRadius;
	var vec3		m_vPos;
	var real		m_fRadius;
	var ^CObjMgr.CRangeMarker m_pxRangeMarker;

	export constructor(CGuid p_xGuid)
		CMainController.Get().AddClickProcRef(SetPos);
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_AIKH");

		m_pxAreas	 	= cast<CList>(m_apxPages[0]^.GetControl("List_Areas"));
		m_pxBtnAdd		= cast<CButton>(m_apxPages[0]^.GetControl("Btn_Add"));
		m_pxBtnRem		= cast<CButton>(m_apxPages[0]^.GetControl("Btn_Rem"));
		m_pxPosition	= cast<CEdit>(m_apxPages[0]^.GetControl("Edit_Position"));
		m_pxRadius		= cast<CEdit>(m_apxPages[0]^.GetControl("Edit_Radius"));

		m_pxBtnAdd^.m_xOnClick = OnAdd;
		m_pxBtnRem^.m_xOnClick = OnRem;
		m_pxAreas^.m_xOnSelect = OnSelectArea;
		m_pxPosition^.m_xOnUpdate = OnChangePos;
		m_pxRadius^.m_xOnUpdate = OnChangeRadius;

		OnSelectArea();
	endconstructor;

	destructor()
		CMainController.Get().RemoveClickProcRef(SetPos);
	enddestructor;

	export proc void OnInit(ref CAttribs p_rxParams)
		var string sAreas = p_rxParams.GetValue("areas");
		var array string asTokens;
		sAreas.Split(asTokens, "|", true);

		var int i;
		for (i=0) cond (i<asTokens.NumEntries()) iter (++i) do
			m_pxAreas^.AddItem("Area_" + (i+1).ToString() + " : " + asTokens[i]);
		endfor;
	endproc;

	proc bool SetPos()
		var vec3 vPos = CClientWrap.GetScapeMgr().GetPickPoint();
		var string sTmp = vPos.ToString();
		sTmp.TrimLeft("[");	sTmp.TrimRight("]");
		m_pxPosition^.SetText(sTmp);
		OnChangePos();
		return true;
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)

		var string sAreas = "";

		var int i;
		for (i=0) cond (i < m_pxAreas^.NumItems()) iter(++i) do
			var string sTmp = m_pxAreas^.GetItem(i);
			sTmp.Delete(0, sTmp.FindRev(':')+1);
			sAreas += sTmp + "|";
		endfor;

		CClientWrap.GetObjMgr().ClearPosiotionMarker();
		CClientWrap.GetObjMgr().DeleteRangeMarker(m_pxRangeMarker);
		m_pxRangeMarker = null;
		po_rxParams.SetValue("areas", sAreas);
	endproc;

	proc bool OnSelectArea()
		var string sTmp = m_pxAreas^.GetSelectedItemAsString();
		var array string asTokens;
		sTmp.Delete(0, sTmp.Find(":")+1);
		sTmp.Split(asTokens, ";", true);
		var int iNumTokens = asTokens.NumEntries();
		if(iNumTokens > 0)then
			m_pxPosition^.SetText(asTokens[0]);
			if(iNumTokens > 1)then
				m_pxRadius^.SetText(asTokens[1]);
			endif;
		endif;
		OnChangeRadius();
		OnChangePos();
		return true;
	endproc;

	proc bool OnAdd()
		m_pxAreas^.AddItem("Area_" + (m_pxAreas^.NumItems()+1).ToString() + "  : 0.0, 0.0, 0.0");
		m_pxAreas^.Select(m_pxAreas^.NumItems()-1);
		return true;
	endproc;

	proc bool OnRem()
		var int iIdx = m_pxAreas^.GetSelectedItem();
		if(iIdx >= 0)then
			m_pxAreas^.DeleteItem(iIdx);
		endif;
		return true;
	endproc;

	proc void UpdatePosMarker()
		if(m_vPos != {0.0, 0.0, 0.0})then
//			KLog.LogSpam("RoSt", "Setting Pos marker: "+m_vPos.ToString()+","+m_fRadius.ToString());
			CClientWrap.GetObjMgr().SetPosiotionMarker("Region",m_vPos,m_fRadius);
			if(m_pxRangeMarker == null)then
				m_pxRangeMarker = CClientWrap.GetObjMgr().CreateRangeMarker();
			endif;
			if(m_pxRangeMarker == null)then
				KLog.LogWarn("RoSt", "m_pxRangeMarker is null in CActionAIKotHPages::UpdatePosMarker()!");
				return;
			endif;
			m_pxRangeMarker^.m_vPos = m_vPos;
			m_pxRangeMarker^.m_fRange = m_fRadius;
			m_pxRangeMarker^.m_bVisible = true;
			m_pxRangeMarker^.m_fWidth1 = m_fRadius;
			m_pxRangeMarker^.m_fWidth2 = m_fRadius;
		endif;
	endproc;

	proc bool OnChangePos()
		var int iIdx = m_pxAreas^.GetSelectedItem();
		if(iIdx>=0)then
			var string sTmp = m_pxAreas^.GetSelectedItemAsString();
			var string sPre = sTmp.Left(sTmp.Find(":"));
			var string sContent = sTmp.Mid(sTmp.Find(":")+2);
			var array string asTokens;
			sContent.Split(asTokens, ";", true);
			sTmp = sPre + ": " + m_pxPosition^.GetText() + ";";
			if(asTokens.NumEntries() > 1)then
				sTmp+=asTokens[1];
			endif;
			m_pxAreas^.SetItemText(iIdx, sTmp);
			m_vPos.FromString(m_pxPosition^.GetText());
			UpdatePosMarker();
		endif;
		return true;
	endproc;

	proc bool OnChangeRadius()
		var int iIdx = m_pxAreas^.GetSelectedItem();
		if(iIdx>=0)then
			var string sTmp = m_pxAreas^.GetSelectedItemAsString();
			var string sPre = sTmp.Left(sTmp.Find(":"));
			var string sContent = sTmp.Mid(sTmp.Find(":")+2);
			var array string asTokens;
			sContent.Split(asTokens, ";", true);
			sTmp = sPre + ": ";
			if(asTokens.NumEntries() > 0)then
				sTmp+=asTokens[0];
			endif;
			sTmp += ";" + m_pxRadius^.GetText();
			m_pxAreas^.SetItemText(iIdx, sTmp);
			m_fRadius=m_pxRadius^.GetText().ToReal();
			UpdatePosMarker();
		endif;
		return true;
	endproc;

endclass;

//----------------------------------------------------------
// Class:	CActionSequence
//----------------------------------------------------------
class CActionSequencePages inherit CActionPages

	var ^CEdit					m_pxText;
	var ^CButton				m_pxChangeBtn;
	var ^CCheckBox				m_pxQuit;
	var ^CEdit 					m_pxReason;
	var ^CCheckBox				m_pxSnapCameraBack;
	//var ^CButton				m_pxSetCameraBtn;
	var ^CEdit					m_pxCameraLookAt;	
	//var ^CButton				m_pxGoToCameraBtn;
	var ^CCheckBox				m_pxSnapActorsBack;
	var ^CCheckBox				m_pxDisableFOW;
	var ^CEdit					m_pxFOWPos;
	var ^CSpinCtrlNumber		m_pxFOWRadius;

	export constructor()
		CMainController.Get().AddClickProcRef(SetPos);
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_SQNZ");

		m_pxText 	= cast<CEdit>(m_apxPages[0]^.GetControl("Edit_Text"));
		m_pxChangeBtn=cast<CButton>(m_apxPages[0]^.GetControl("ChangeBtn"));
		m_pxChangeBtn^.m_xOnClick=OnChangeName;
		m_pxQuit	= cast<CCheckBox>(m_apxPages[0]^.GetControl("Chk_Quit"));
		m_pxReason	= cast<CEdit>(m_apxPages[0]^.GetControl("Edit_Quitreason"));
		m_pxSnapCameraBack= cast<CCheckBox>(m_apxPages[0]^.GetControl("Chk_SnapCamBack"));
		m_pxSnapCameraBack^.m_xOnStateChange=OnSnapCameraBack;
		//m_pxSetCameraBtn=cast<CButton>(m_apxPages[0]^.GetControl("SetCamera"));
		//m_pxSetCameraBtn^.m_xOnClick=OnSetCamera;
		m_pxCameraLookAt=cast<CEdit>(m_apxPages[0]^.GetControl("CameraData"));
		//m_pxGoToCameraBtn=cast<CButton>(m_apxPages[0]^.GetControl("GoToCamera"));		
		//m_pxGoToCameraBtn^.m_xOnClick=OnGoToCamera;
		m_pxSnapActorsBack= cast<CCheckBox>(m_apxPages[0]^.GetControl("Chk_SnapActorsBack"));
		m_pxDisableFOW=cast<CCheckBox>(m_apxPages[0]^.GetControl("Chk_DisableFOW"));
		m_pxDisableFOW^.m_xOnStateChange=OnChangeDisableFOW;
		m_pxFOWPos=cast<CEdit>(m_apxPages[0]^.GetControl("FOW_Pos"));
		m_pxFOWPos^.SetDisabled(true);
		m_pxFOWRadius=cast<CSpinCtrlNumber>(m_apxPages[0]^.GetControl("FOW_Radius"));
		m_pxFOWRadius^.SetDisabled(true);
		m_pxFOWRadius^.m_xOnChange = OnChangePosRad;

		m_pxQuit^.m_xOnStateChange = OnQuit;		
		m_pxReason^.SetText("Exit_0");
	endconstructor;
	
	export destructor()
		CMainController.Get().RemoveClickProcRef(SetPos);
		CClientWrap.GetObjMgr().ClearPosiotionMarker();
		CClientWrap.GetObjMgr().DeleteAllRangeMarkers();
	enddestructor;
	
	proc bool SetPos()		
		var ^CDesktop pxDesktop=CClientWrap.GetDesktop();
		if(pxDesktop==null)then return true; endif;
		var SHWND hLastFocusWnd=pxDesktop^.GetLastFocusWnd();
		var vec3 vPos=CClientWrap.GetScapeMgr().GetPickPoint();
		if(m_pxCameraLookAt^.GetSHWND()==hLastFocusWnd)then			
			var string sTmp = vPos.ToString();
			m_pxCameraLookAt^.SetText(sTmp);
			return true;
		endif;
		if(m_pxFOWPos^.GetSHWND()==hLastFocusWnd)then			
			var string sTmp = vPos.ToString();
			m_pxFOWPos^.SetText(sTmp);
			OnChangePosRad();
			return true;
		endif;		
		return true;
	endproc;

	proc bool OnQuit()
		if(m_pxQuit^.GetCheckMark())then
			m_pxReason^.SetDisabled(false);
		else
			m_pxReason^.SetDisabled(true);
			m_pxReason^.SetText("");
		endif;
		return true;
	endproc;
	
	proc bool OnChangePosRad()
		var vec3 vPos = vec3.CreateFromString(m_pxFOWPos^.GetText());
		if(m_pxDisableFOW^.GetChecked() == 1 && vPos != {0.0, 0.0, 0.0})then
			CClientWrap.GetObjMgr().ClearPosiotionMarker();
			CClientWrap.GetObjMgr().SetPosiotionMarker("Region",vPos,m_pxFOWRadius^.GetValueInt().ToReal());
			CClientWrap.GetObjMgr().DeleteAllRangeMarkers();
			var ^CObjMgr.CRangeMarker pxMarker = CClientWrap.GetObjMgr().CreateRangeMarker();
			if(pxMarker == null)then
				return true;
			endif;
			pxMarker^.m_vPos		= vPos;
			pxMarker^.m_fRange		= m_pxFOWRadius^.GetValueInt().ToReal();
			pxMarker^.m_fWidth1		= 0.5f;
			pxMarker^.m_xColor1		= {{255,140,140,0}};
			pxMarker^.m_xColor2		= {{255,150,150,100}};
			pxMarker^.m_bVisible	= true;
		endif;
		return true;
	endproc;

	export proc void OnInit(ref CAttribs p_rxParams)
		m_pxText^.SetText(p_rxParams.GetValue("sequence"));
		m_pxQuit^.SetChecked(p_rxParams.GetValueInt("quit"));
		m_pxReason^.SetText(p_rxParams.GetValue("reason"));
		m_pxSnapCameraBack^.SetChecked(p_rxParams.GetValueInt("snap_cam_back"));
		m_pxCameraLookAt^.SetText(p_rxParams.GetValue("camera_data"));
		m_pxSnapActorsBack^.SetChecked(p_rxParams.GetValueInt("snap_actors_back"));
		m_pxDisableFOW^.SetChecked(p_rxParams.GetValueInt("disable_fow"));

		m_pxFOWPos^.SetText(p_rxParams.GetValue("fow_pos"));
		m_pxFOWRadius^.SetValue(p_rxParams.GetValueInt("fow_radius"));		
		OnSnapCameraBack();	
		OnChangePosRad();
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		po_rxParams.SetValue("sequence", m_pxText^.GetText());

		var int iA = 0;
		if(m_pxQuit^.GetCheckMark())then iA = 1; endif;
		po_rxParams.SetValue("quit", iA);

		iA = 0;
		if(m_pxSnapCameraBack^.GetCheckMark())then iA = 1; endif;
		po_rxParams.SetValue("snap_cam_back", iA);
		iA = 0;
		if(m_pxSnapActorsBack^.GetCheckMark())then iA = 1; endif;
		po_rxParams.SetValue("snap_actors_back", iA);

		iA = 0;
		if(m_pxDisableFOW^.GetCheckMark())then iA = 1; endif;
		po_rxParams.SetValue("disable_fow", iA);

		po_rxParams.SetValue("fow_pos",m_pxFOWPos^.GetText());
		po_rxParams.SetValue("fow_radius",m_pxFOWRadius^.GetValueInt());

		po_rxParams.SetValue("reason", m_pxReason^.GetText());
		
		po_rxParams.SetValue("camera_data",m_pxCameraLookAt^.GetText());
			
		CClientWrap.GetObjMgr().ClearPosiotionMarker();
		CClientWrap.GetObjMgr().DeleteAllRangeMarkers();
	endproc;

	proc bool OnChangeName()
		var ^CEnhancedLoadSaveDialog pxTmp = new CEnhancedLoadSaveDialog(0,"custom");
		pxTmp^.ClearFilters();
		pxTmp^.AddFilter("Sequence Files","*.seq");
		var string sBasePath=CClientWrap.GetUrsRelPath()+"/Data";
		pxTmp^.SetBasePath(sBasePath);
		pxTmp^.SetUniqueSettingName("SeqActLoadSaveDlg");
		pxTmp^.m_xReturnFileString=OnReturnLoadString;
		CClientWrap.GetDesktop()^.AddChild(pxTmp);
		CWindowMgr.Get().BringWindowToTop(pxTmp, true);
		CWindowMgr.Get().SetModal(pxTmp);
		return true;
	endproc;

	proc bool OnReturnLoadString(string p_sFileString)
		p_sFileString.Replace("\\","/");
		var string sTmp="/Data/";
		var int iIdx=p_sFileString.Find(sTmp);
		if(iIdx!=-1)then
			p_sFileString.Delete(0,iIdx+sTmp.GetLength());
		endif;
		m_pxText^.SetText(p_sFileString);
		return(true);
	endproc;

	proc bool OnChangeDisableFOW()
		m_pxFOWPos^.SetDisabled(true);
		m_pxFOWRadius^.SetDisabled(true);
		if(m_pxDisableFOW^.GetCheckMark())then
			m_pxFOWPos^.SetDisabled(false);
			m_pxFOWRadius^.SetDisabled(false);			
		endif;
		return true;
	endproc;
	
	proc bool OnSnapCameraBack()
		var bool bSnapCameraBack=m_pxSnapCameraBack^.GetChecked()==1;
		//m_pxSetCameraBtn^.SetDisabled(bSnapCameraBack);
		m_pxCameraLookAt^.SetDisabled(bSnapCameraBack);
		//m_pxGoToCameraBtn^.SetDisabled(bSnapCameraBack);		
		return true;
	endproc;

endclass;

//----------------------------------------------------------
// Class:	CActionDialogScenePages
//----------------------------------------------------------
class CActionDialogScenePages inherit CActionPages

	var ^CEdit		m_pxScene;
	var ^CButton	m_pxChangeBtn;

	export constructor(CGuid p_xGuid)
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_DGSC");

		m_pxScene = cast<CEdit>(m_apxPages[0]^.GetControl("Edit_Scene"));
		m_pxChangeBtn=cast<CButton>(m_apxPages[0]^.GetControl("ChangeBtn"));
		m_pxChangeBtn^.m_xOnClick=OnChangeName;
	endconstructor;

	export proc void OnInit(ref CAttribs p_rxParams)
		var string sScene=p_rxParams.GetValue("scene");
		CLevelEditorWrap.LogSpam("DialogScene", "CActionDialogScenePages::OnInit() :"+sScene);
		m_pxScene^.SetText(sScene);
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		po_rxParams.SetValue("scene", m_pxScene^.GetText());
		var string sScene=po_rxParams.GetValue("scene");
		CLevelEditorWrap.LogSpam("DialogScene", "CActionDialogScenePages::OnFinish() : "+sScene);
	endproc;

	proc bool OnChangeName()
		var ^CEnhancedLoadSaveDialog pxTmp = new CEnhancedLoadSaveDialog(0,"custom");
		pxTmp^.ClearFilters();
		pxTmp^.AddFilter("DialogScene Files","*.dlg");
		var string sBasePath=CClientWrap.GetUrsRelPath()+"/Data";
		pxTmp^.SetBasePath(sBasePath);
		pxTmp^.SetUniqueSettingName("DlgSceneActLoadSaveDlg");
		pxTmp^.m_xReturnFileString=OnReturnLoadString;
		CClientWrap.GetDesktop()^.AddChild(pxTmp);
		CWindowMgr.Get().BringWindowToTop(pxTmp, true);
		CWindowMgr.Get().SetModal(pxTmp);
		return true;
	endproc;

	proc bool OnReturnLoadString(string p_sFileString)
		p_sFileString.Replace("\\","/");
		var string sTmp="/Data/";
		var int iIdx=p_sFileString.Find(sTmp);
		if(iIdx!=-1)then
			p_sFileString.Delete(0,iIdx+sTmp.GetLength());
		endif;
		m_pxScene^.SetText(p_sFileString);
		return(true);
	endproc;
endclass;

//----------------------------------------------------------
// Class:	CActionDialogFeedbackPages
//----------------------------------------------------------
class CActionDialogFeedbackPages inherit CActionPages

	var ^CEdit			m_pxScene;
	var ^CDropList	m_pxPlayer;
	var ^CButton		m_pxChangeBtn;

	export constructor(CGuid p_xGuid)
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_DGFB");

		m_pxPlayer  = cast<CDropList>(m_apxPages[0]^.GetControl("Drop_Player"));
		m_pxScene = cast<CEdit>(m_apxPages[0]^.GetControl("Edit_Scene"));
		m_pxChangeBtn=cast<CButton>(m_apxPages[0]^.GetControl("ChangeBtn"));
		m_pxChangeBtn^.m_xOnClick=OnChangeName;
		var int i, iC = 8;
		for (i=0) cond(i<iC) iter(++i) do
			m_pxPlayer^.AddItem(i.ToString());
		endfor;
	endconstructor;

	export proc void OnInit(ref CAttribs p_rxParams)
		var string sScene=p_rxParams.GetValue("scene");
		var int i = p_rxParams.GetValueInt("player_id");
		m_pxScene^.SetText(sScene);
		m_pxPlayer^.Select(i);
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		po_rxParams.SetValue("scene", m_pxScene^.GetText());
		var int i = m_pxPlayer^.GetSelectedItemAsString().ToInt();
		po_rxParams.SetValue("player_id", i);
	endproc;

	proc bool OnChangeName()
		var ^CEnhancedLoadSaveDialog pxTmp = new CEnhancedLoadSaveDialog(0,"custom");
		pxTmp^.ClearFilters();
		pxTmp^.AddFilter("DialogScene Files","*.dlg");
		var string sBasePath=CClientWrap.GetUrsRelPath()+"/Data";
		pxTmp^.SetBasePath(sBasePath);
		pxTmp^.SetUniqueSettingName("DlgSceneActLoadSaveDlg");
		pxTmp^.m_xReturnFileString=OnReturnLoadString;
		CClientWrap.GetDesktop()^.AddChild(pxTmp);
		CWindowMgr.Get().BringWindowToTop(pxTmp, true);
		CWindowMgr.Get().SetModal(pxTmp);
		return true;
	endproc;

	proc bool OnReturnLoadString(string p_sFileString)
		p_sFileString.Replace("\\","/");
		var string sTmp="/Data/";
		var int iIdx=p_sFileString.Find(sTmp);
		if(iIdx!=-1)then
			p_sFileString.Delete(0,iIdx+sTmp.GetLength());
		endif;
		m_pxScene^.SetText(p_sFileString);
		return(true);
	endproc;
endclass;

//----------------------------------------------------------
// Class:	CActionFeedback
//----------------------------------------------------------
class CActionFeedback inherit CActionPages

	var ^CDropList	m_pxPlayer;
	var ^CEdit		m_pxText;


	export constructor()
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_FDBK");

		m_pxPlayer  = cast<CDropList>(m_apxPages[0]^.GetControl("Drop_Player"));
		m_pxText 	= cast<CEdit>(m_apxPages[0]^.GetControl("Edit_Text"));

		m_pxPlayer^.AddItem("All");
		var int i, iC = 8;
		for (i=0) cond(i<iC) iter(++i) do
			m_pxPlayer^.AddItem(i.ToString());
		endfor;
	endconstructor;


	export proc void OnInit(ref CAttribs p_rxParams)
		m_pxText^.SetText(p_rxParams.GetValue("msg_text"));

		var int i = p_rxParams.GetValueInt("player_id");
		m_pxPlayer^.Select(i+1);
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		po_rxParams.SetValue("msg_text", m_pxText^.GetText());

		var int i = m_pxPlayer^.GetSelectedItemAsString().ToInt();

		if(m_pxPlayer^.GetSelectedItemAsString()=="All")then
			i = -1;
		endif;
		po_rxParams.SetValue("player_id", i);
	endproc;
endclass;



//----------------------------------------------------------
// Class:	CActionObjAppearance
//----------------------------------------------------------
class CActionObjAppearPages inherit CActionPages

	var ^CActionObjSelector m_pxObjSel;
	var ^CCheckBox m_pxVisible;
	var ^CCheckBox m_pxSelectable;
	var ^CCheckBox m_pxHitable;
	var ^CCheckBox m_pxConstructable;
	var ^CCheckBox m_pxDestructable;
	var ^CCheckBox m_pxDeconstructible;
//	var ^CCheckBox m_pxBlocker;

	const bitset VISIBLE 		= 01b;
	const bitset HITABLE 		= 010b;
	const bitset SELECTABLE 	= 0100b;
	const bitset CONSTRUCTIBLE 	= 01000b;
	const bitset DESTRUCTIBLE 	= 010000b;
	const bitset DECONSTRUCTIBLE= 0100000b;
	const bitset BLOCKER 		= 01000000b;

	export constructor( CGuid p_xGuid)
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_OBAP");

		m_pxObjSel			= cast<CActionObjSelector>(m_apxPages[0]^.GetControl("ObjSelector"));
		m_pxVisible			= cast<CCheckBox>(m_apxPages[0]^.GetControl("Check_Visible"));
		m_pxHitable			= cast<CCheckBox>(m_apxPages[0]^.GetControl("Check_Hitable"));
		m_pxSelectable		= cast<CCheckBox>(m_apxPages[0]^.GetControl("Check_Selectable"));
		m_pxConstructable	= cast<CCheckBox>(m_apxPages[0]^.GetControl("Check_Constructable"));
		m_pxDestructable	= cast<CCheckBox>(m_apxPages[0]^.GetControl("Check_Destructable"));
		m_pxDeconstructible	= cast<CCheckBox>(m_apxPages[0]^.GetControl("Check_Dismantable"));
//		m_pxBlocker			= cast<CCheckBox>(m_apxPages[0]^.GetControl("Check_Blocker"));

		m_pxObjSel^.Init(p_xGuid);
	endconstructor;

	destructor()
	enddestructor;

	export proc void OnInit(ref CAttribs p_rxParams)
		var bitset dwFlags = Math.IntToBitset(p_rxParams.GetValueInt("flags"));
		if( (dwFlags&VISIBLE)==VISIBLE)then m_pxVisible^.SetChecked(1); else m_pxVisible^.SetChecked(0); endif;
		if( (dwFlags&SELECTABLE)==SELECTABLE)then m_pxSelectable^.SetChecked(1); else m_pxSelectable^.SetChecked(0); endif;
		if( (dwFlags&HITABLE)==HITABLE)then m_pxHitable^.SetChecked(1); else m_pxHitable^.SetChecked(0); endif;
		if( (dwFlags&CONSTRUCTIBLE)!=0b)then m_pxConstructable^.SetChecked(1); else m_pxConstructable^.SetChecked(0); endif;
		if( (dwFlags&DECONSTRUCTIBLE)!=0b)then m_pxDeconstructible^.SetChecked(1); else m_pxDeconstructible^.SetChecked(0); endif;
		if( (dwFlags&DESTRUCTIBLE)!=0b)then m_pxDestructable^.SetChecked(1); else m_pxDestructable^.SetChecked(0); endif;
//		if( (dwFlags&BLOCKER)!=0b)then m_pxBlocker^.SetChecked(1); else m_pxBlocker^.SetChecked(0); endif;

		m_pxObjSel^.OnInit(p_rxParams);
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		var bitset dwFlags = 0b;
		if(m_pxVisible^.GetCheckMark()) 			then dwFlags |= VISIBLE; endif;
		if(m_pxSelectable^.GetCheckMark()) 		then dwFlags |= SELECTABLE; endif;
		if(m_pxHitable^.GetCheckMark()) 			then dwFlags |= HITABLE; endif;
		if(m_pxConstructable^.GetCheckMark())		then dwFlags |= CONSTRUCTIBLE; endif;
		if(m_pxDeconstructible^.GetCheckMark())	then dwFlags |= DECONSTRUCTIBLE; endif;
		if(m_pxDestructable^.GetCheckMark()) 		then dwFlags |= DESTRUCTIBLE; endif;
//		if(m_pxBlocker^.GetCheckMark())			then dwFlags |= BLOCKER; endif;
//		CMirageSDKMgr.Debug("dwFlags: '"+(dwFlags).ToString()+"'");
		var int iVal = Math.BitsetToInt(dwFlags);
		po_rxParams.SetValue("flags", iVal);
		m_pxObjSel^.OnFinish(po_rxParams);
	endproc;
endclass;

//----------------------------------------------------------
// Class:	CActionObjHitpoints
// By AyCe
//----------------------------------------------------------
class CActionObjHitpointsPages inherit CActionPages

	var ^CActionObjSelector m_pxObjSel;
	var ^CCheckBox		m_pxDeath;
	var ^CDropList		m_pxType;
	var ^CDropList		m_pxArmour;
	var ^CSpinCtrlNumber	m_pxValue;

	class CTypeData inherit CItemData

		export constructor(int p_iType)
			m_iType = p_iType;
		endconstructor;

		export var int m_iType;
	endclass;

	class CArmourData inherit CItemData

		export constructor(int p_iArmour)
			m_iArmour = p_iArmour;
		endconstructor;

		export var int m_iArmour;
	endclass;

	export constructor(CGuid p_xGuid)
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_OBHP");

		m_pxObjSel = cast<CActionObjSelector>(m_apxPages[0]^.GetControl("ObjSelector"));
		m_pxDeath = cast<CCheckBox>(m_apxPages[0]^.GetControl("Check_Death"));
		m_pxType = cast<CDropList>(m_apxPages[0]^.GetControl("Drop_Type"));
		m_pxArmour = cast<CDropList>(m_apxPages[0]^.GetControl("Drop_Armour"));
		m_pxValue = cast<CSpinCtrlNumber>(m_apxPages[0]^.GetControl("Edit_Value"));

		m_pxDeath^.SetChecked(1);

		m_pxType^.AddItem("Set HP to absolute value", new CTypeData(0));
		m_pxType^.AddItem("Set HP to percent of max HP", new CTypeData(1));
		m_pxType^.AddItem("Cause absolute damage", new CTypeData(2));
		m_pxType^.AddItem("Cause damage in percent to current HP", new CTypeData(3));
		m_pxType^.AddItem("Cause damage in percent to max HP", new CTypeData(4));

		m_pxArmour^.AddItem("None", new CArmourData(0));
		m_pxArmour^.AddItem("Melee", new CArmourData(1));
		m_pxArmour^.AddItem("Long-range", new CArmourData(2));

		m_pxValue^.SetDecimals(6);
		m_pxValue^.SetLimits(-999999.99, 999999.99, 0.1);
		m_pxValue^.SetValue(1.0);

		m_pxObjSel^.Init(p_xGuid);
	endconstructor;

	destructor()
	enddestructor;

	export proc void OnInit(ref CAttribs p_rxParams)
		m_pxObjSel^.OnInit(p_rxParams);
		if(p_rxParams.GetValueBool("allow_death"))then
			m_pxDeath^.SetChecked(1);
		else
			m_pxDeath^.SetChecked(0);
		endif;
		m_pxType^.Select(p_rxParams.GetValueInt("hitpoint_type"));
		m_pxArmour^.Select(p_rxParams.GetValueInt("use_armour"));
		m_pxValue^.SetValue(p_rxParams.GetValueFloat("damage_value"));
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		m_pxObjSel^.OnFinish(po_rxParams);
		po_rxParams.SetValue("allow_death", m_pxDeath^.GetCheckMark());
		po_rxParams.SetValue("hitpoint_type", m_pxType^.GetSelectedItem());
		po_rxParams.SetValue("use_armour", m_pxArmour^.GetSelectedItem());
		po_rxParams.SetValue("damage_value", m_pxValue^.GetValueFloat());
	endproc;
endclass;

class CActionTechTreePages inherit CActionPages

	var ^CDropList			m_pxPlayer;
	var ^CTreeCtrl			m_pxTT;
	var ^CList					m_pxFilters;
	var ^CButton				m_pxAdd, m_pxRem;
	var ^CRadioButton		m_pxActAdd, m_pxActRem;

	var ^CPropDB				m_pxLI;
	var CBitmapPtr			m_pxDefBitmap,m_pxSelBitmap;

	class CFilterData inherit CItemData

		export constructor(int p_iIdx)
			m_iFilterIdx = p_iIdx;
		endconstructor;

		export var int m_iFilterIdx;
	endclass;

	static var array string ms_asFilterAction;

	class CAppliedFilterData inherit CItemData

		export const int ACTION_ADD_FILTER = 1;
		export const int ACTION_REM_FILTER = 0;
		export var int m_iFilterIdx;
		export var int m_iOwner;
		export var int m_iAction;

		export constructor(int p_iFilterIdx, int p_iOwner, int p_iAction)
			m_iFilterIdx = p_iFilterIdx;
			m_iOwner = p_iOwner;
			m_iAction = p_iAction;
		endconstructor;

	endclass;

	export constructor()
		if(ms_asFilterAction.NumEntries()==0)then
			ms_asFilterAction.AddEntry("Rem ");
			ms_asFilterAction.AddEntry("Add ");
		endif;

		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		if(m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_TECH"))then
			m_pxPlayer	= cast<CDropList>(m_apxPages[0]^.GetControl("Drop_Player"));
			m_pxTT			= cast<CTreeCtrl>(m_apxPages[0]^.GetControl("Tree_TT"));
			m_pxAdd			= cast<CButton>(m_apxPages[0]^.GetControl("Btn_Add"));
			m_pxRem			= cast<CButton>(m_apxPages[0]^.GetControl("Btn_Rem"));
			m_pxActAdd	= cast<CRadioButton>(m_apxPages[0]^.GetControl("GBox_List/GBox_Radios/Radio_Add"));
			m_pxActRem	= cast<CRadioButton>(m_apxPages[0]^.GetControl("GBox_List/GBox_Radios/Radio_Rem"));
			m_pxFilters	= cast<CList>(m_apxPages[0]^.GetControl("GBox_List/List_Filters"));
		endif;

		var ^CLevelInfo pxLevelInfo=^(CLevelEditorWrap.GetClient().GetLevelInfo());
		m_pxLI = ^(pxLevelInfo^.GetGenericData());

		var ^CPropDB.CNode pxBaseNode=^((m_pxLI^)["Base"]);

		var int i, iC = pxBaseNode^.GetValueI("MaxPlayers");
		for (i=0) cond (i<iC) iter (++i) do
			m_pxPlayer^.AddItem(i.ToString());
		endfor;

		m_pxTT^.m_xOnLBtnDblClick=OnDbClickFilter;
		m_pxAdd^.m_xOnClick = OnDbClickFilter;
		m_pxRem^.m_xOnClick = OnRemoveAppliedFilter;
		m_pxActAdd^.m_xOnChange = OnRadiosChanged;
		m_pxActRem^.m_xOnChange = OnRadiosChanged;
		//m_pxFilters^.m_xOnSelect = OnSelectAppliedFilter;

		m_pxDefBitmap=CBitmapPtr.Create("treedefaultimg.tga");
		m_pxSelBitmap=CBitmapPtr.Create("check.tga");

		m_pxPlayer^.m_xOnChange = OnSelectPlayer;
		m_pxPlayer^.Select(0);
		OnSelectPlayer();
		m_pxFilters^.AllowMultiSelection(true);
	endconstructor;

	proc string CreateFilterItemText(^CActionTechTreePages.CAppliedFilterData p_pxAFD)
		var ^CTechTreeMgr pxTTMgr=^(CLevelEditorWrap.GetClient().GetTechTreeMgr());
		var string sPath = pxTTMgr^.GetFilterPath(p_pxAFD^.m_iFilterIdx);
		return "[" + p_pxAFD^.m_iOwner.ToString() + "] " + ms_asFilterAction[p_pxAFD^.m_iAction] + " \"" + sPath + "\"";
	endproc;

	proc bool OnDbClickFilter()
		var int iItem = m_pxTT^.GetSelectedItem();
		if(iItem <= 0)then return false; endif;

		if(m_pxTT^.ItemNumChildren(iItem)!=0)then return false; endif;

		var int iFilterIdx = cast<CFilterData>(m_pxTT^.GetItemData(iItem))^.m_iFilterIdx;

		var ^CTechTreeMgr pxTTMgr=^(CLevelEditorWrap.GetClient().GetTechTreeMgr());

		var int iPlayer = m_pxPlayer^.GetSelectedItem();
		var int iAction = 0;
		if(m_pxActRem^.GetSelected())then
			iAction = 0;
		else
			iAction = 1;
		endif;
		//if(m_pxTT^.GetItemBitmap(iItem) == m_pxSelBitmap)then iAction = 0; endif;

		var string sPath = pxTTMgr^.GetFilterPath(iFilterIdx);
		var int i,iC = m_pxFilters^.NumItems();
		for(i=0) cond(i<iC) iter(++i) do
			//var string sFilterItem = m_pxFilters^.GetItem(i);
			//if(sFilterItem.Find("\""+sPath+"\"") >= 0 && sFilterItem.Find("[""+iPlayer.ToString()+"]"") >= 0)then
			if(m_pxFilters^.GetItem(i).Find("\""+sPath+"\"") >= 0)then
				return false;
			endif;
		endfor;

		var ^CAppliedFilterData pxAFD = new CAppliedFilterData(iFilterIdx, iPlayer, iAction);
		m_pxFilters^.AddItem(CreateFilterItemText(pxAFD), pxAFD);
		return true;
	endproc;

	proc bool OnRemoveAppliedFilter()
		var int i, iC=m_pxFilters^.NumItems();
		for(i=0) cond(i<iC) iter(++i) do
			if(m_pxFilters^.IsItemSelected(i))then
				delete m_pxFilters^.GetItemData(i);
				m_pxFilters^.DeleteItem(i--);--iC;
			endif;
		endfor;
		return true;
	endproc;

	proc bool OnRadiosChanged()
		/*
		var int iItem = m_pxFilters^.GetSelectedItem();
		if(iItem>=0)then
			var ^CAppliedFilterData pxAFD = cast<CAppliedFilterData>(m_pxFilters^.GetItemData(iItem));
			if(m_pxActAdd^.GetSelected())then
				pxAFD^.m_iAction = 1;
			else
				pxAFD^.m_iAction = 0;
			endif;
			UpdateAppliedFilterItem(iItem);
			return true;
		endif;
		*/
		//Henry: to allow multiple selection change...
		if(m_pxFilters^.GetNumberOfSelectedItems()<1)then return false; endif;
		var int iAction = 1;
		if(m_pxActRem^.GetSelected())then
			iAction = 0;
		endif;
		var int i, iC = m_pxFilters^.NumItems();
		for(i=0)cond(i<iC)iter(++i)do
			if(!m_pxFilters^.IsItemSelected(i))then continue; endif;
			var ^CAppliedFilterData pxAFD = cast<CAppliedFilterData>(m_pxFilters^.GetItemData(i));
			pxAFD^.m_iAction = iAction;
			UpdateAppliedFilterItem(i);
		endfor;
		return true;
	endproc;

	proc bool UpdateAppliedFilterItem(int p_iItem)
		var ^CAppliedFilterData pxAFD = cast<CAppliedFilterData>(m_pxFilters^.GetItemData(p_iItem));
		if(pxAFD!=null)then
			var ^CTechTreeMgr pxTTMgr=^(CLevelEditorWrap.GetClient().GetTechTreeMgr());
			var string sPath = pxTTMgr^.GetFilterPath(pxAFD^.m_iFilterIdx);
			m_pxFilters^.SetItemText(p_iItem, CreateFilterItemText(pxAFD));
			return true;
		endif;
		return false;
	endproc;

	proc bool OnSelectAppliedFilter()
		var int iItem = m_pxFilters^.GetSelectedItem();
		if(iItem>=0)then
			m_pxActAdd^.m_xOnChange.Clear();
			m_pxActRem^.m_xOnChange.Clear();

			var ^CAppliedFilterData pxAFD = cast<CAppliedFilterData>(m_pxFilters^.GetItemData(iItem));
			if(pxAFD!=null)then
				if(pxAFD^.m_iAction == 0)then
					m_pxActAdd^.SetSelected(false);
					m_pxActRem^.SetSelected(true);
				else
					m_pxActAdd^.SetSelected(true);
					m_pxActRem^.SetSelected(false);
				endif;
			endif;

			m_pxActAdd^.m_xOnChange = OnRadiosChanged;
			m_pxActRem^.m_xOnChange = OnRadiosChanged;
			return true;
		endif;
		return false;
	endproc;

	proc bool OnSelectPlayer()
		var int iPlayer = m_pxPlayer^.GetSelectedItem();

		var ^CPropDB.CNode pxPlayerSettingsNode = ^((m_pxLI^)["PlayerSettings"]);
		if(pxPlayerSettingsNode==null)then
			return false;
		endif;

		var ^CPropDB.CNode pxPlayer = pxPlayerSettingsNode^.Get("Player_" + iPlayer.ToString());
		if(pxPlayer==null)then
			pxPlayer = ^(pxPlayerSettingsNode^.AddValue("Player_" + iPlayer.ToString(), ""));
		endif;

		var ^CPropDB.CNode pxRestrictions = pxPlayer^.Get("Restrictions");
		if(pxRestrictions==null)then
			pxRestrictions=^(pxPlayer^.AddValue("Restrictions",""));
		endif;

		var ^CPropDB.CNode pxTT = pxRestrictions^.Get("TTDef");
		if(pxTT==null)then
			pxTT = ^(pxRestrictions^.AddValue("TTDef", ""));
		endif;

		UpdateTree(pxTT);
		//Henry: to allow multiple selection change...
		if(m_pxFilters^.GetNumberOfSelectedItems()<1)then return true; endif;
		var int i, iC = m_pxFilters^.NumItems();
		for(i=0)cond(i<iC)iter(++i)do
			if(!m_pxFilters^.IsItemSelected(i))then continue; endif;
			var ^CAppliedFilterData pxAFD = cast<CAppliedFilterData>(m_pxFilters^.GetItemData(i));
			pxAFD^.m_iOwner = iPlayer;
			UpdateAppliedFilterItem(i);
		endfor;
		return true;
	endproc;

	proc void ClearTreeData(int p_iParent)
		var int i, iC = m_pxTT^.ItemNumChildren(p_iParent);
		for(i=0) cond(i<iC) iter(++i) do
			var int iItem = m_pxTT^.GetChildItem(p_iParent, i);
			ClearTreeData(iItem);

			delete m_pxTT^.GetItemData(iItem);
		endfor;
	endproc;

	proc void ClearFilterList()
		var int i, iC = m_pxFilters^.NumItems();
		for(i=0) cond(i<iC) iter(++i) do
			delete m_pxFilters^.GetItemData(i);
		endfor;

		m_pxFilters^.Clear();
	endproc;

	proc void UpdateTree(^CPropDB.CNode p_pxTTNode)
		var array string asData;
		var int i,iC=p_pxTTNode^.NumSubs();
		for(i=0)cond(i<iC)iter(i++)do
			var string sFilter=p_pxTTNode^.Get(i).Name();
			if(!sFilter.IsEmpty())then
				asData.AddEntry(sFilter);
			endif;
		endfor;

		ClearTreeData(0);
		m_pxTT^.Clear();
		var ^CTechTreeMgr pxTTMgr=^(CLevelEditorWrap.GetClient().GetTechTreeMgr());
		iC=pxTTMgr^.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var string sPath=pxTTMgr^.GetFilterPath(i);
			var int iFilterIdx = i;
			if(sPath.Find("_RemoveMe")==-1)then
				var bool bExist=(asData.FindEntry(sPath)!=-1);
				var array string asParts;
				sPath.Split(asParts,"/",true);
				var int iRootIdx=0;
				var int i,iC=asParts.NumEntries();
				for(i=0)cond(i<iC)iter(i++)do
					var int iWalkIdx=FindItem(iRootIdx,asParts[i]);
					if(iWalkIdx==0)then
						var CBitmapPtr pxBmp=m_pxDefBitmap;
						if(bExist && i==(iC-1))then
							pxBmp=m_pxSelBitmap;
						endif;
						iWalkIdx=m_pxTT^.AddItem(iRootIdx,asParts[i], new CFilterData(iFilterIdx), pxBmp);
					endif;
					iRootIdx=iWalkIdx;
				endfor;
			endif;
		endfor;
	endproc;

	proc int FindItem(int p_iParent,string p_sText)
		var int iL,iLC=m_pxTT^.ItemNumChildren(p_iParent);
		for(iL=0)cond(iL<iLC)iter(iL++)do
			var int iIdx=m_pxTT^.GetChildItem(p_iParent,iL);
			if(m_pxTT^.GetItemText(iIdx)==p_sText)then
				return iIdx;
			endif;
		endfor;
		return 0;
	endproc;

	export proc void OnInit(ref CAttribs p_rxParams)
		var string sAll = p_rxParams.GetValue("filters");
		var ^CTechTreeMgr pxTTMgr=^(CLevelEditorWrap.GetClient().GetTechTreeMgr());

		var array string asFilters;
		sAll.Split(asFilters, "\n", true);

		ClearFilterList();
		var int i, iC = asFilters.NumEntries();
		for(i=0) cond(i<iC) iter(++i) do
			var array string asToks;
			asFilters[i].Split(asToks, "|", true);

			var ^CAppliedFilterData pxAFD = new CAppliedFilterData(pxTTMgr^.GetFilterIdx(asToks[2]),asToks[0].ToInt(), asToks[1].ToInt());

			m_pxFilters^.AddItem(CreateFilterItemText(pxAFD), pxAFD);
		endfor;
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		var ^CTechTreeMgr pxTTMgr=^(CLevelEditorWrap.GetClient().GetTechTreeMgr());

		var string sSend;
		var int i, iC = m_pxFilters^.NumItems();
		for(i=0) cond(i<iC) iter(++i)do
			var ^CAppliedFilterData pxAFD = cast<CAppliedFilterData>(m_pxFilters^.GetItemData(i));
			if(pxAFD!=null)then
				var string sPath = pxTTMgr^.GetFilterPath(pxAFD^.m_iFilterIdx);
				sSend += pxAFD^.m_iOwner.ToString() + "|" + pxAFD^.m_iAction.ToString() + "|" + sPath + "\n";
			endif;
		endfor;
		po_rxParams.SetValue("filters", sSend);
	endproc;

endclass;

class CObjHelper

	export static proc CClntHndl GetObjByName( string p_sName )
		var CClntHndl xHndl;
		xHndl.Invalidate();

		if(p_sName.IsEmpty())then return xHndl; endif;

		var ^CList pxList = CEnhancedMenu.Get().GetObjFinder()^.GetObjList();
		if(pxList==null)then return xHndl; endif;
		var int iNumItems = pxList^.NumItems();
		var int i;
		for (i=0) cond (i<iNumItems) iter (++i) do
			var ^CFinderItem pxItem = cast<CFinderItem>(pxList^.GetItemData(i));
			if(pxItem==null)then continue; endif;
			if(pxItem^.GetType() == CFinderItem.TYPE_OBJECT)then
				xHndl = (cast<CFinderItemObject>(pxItem))^.GetHndl();
				if(xHndl.IsValid())then
					if(xHndl.GetObj()^.GetName() == p_sName)then return xHndl; endif;
				endif;
			endif;
		endfor;
		return xHndl;
	endproc;

	export static proc CClntHndl GetObjByIndex(int p_iIdx)
		var CClntHndl xHndl;
		xHndl.Invalidate();

		var ^CList pxObjList = CEnhancedMenu.Get().GetObjFinder()^.GetObjList();
		var ^CFinderItem pxItem = cast<CFinderItem>(pxObjList^.GetItemData(p_iIdx));

		if(pxItem!=null && pxItem^.GetType() == CFinderItem.TYPE_OBJECT)then
			xHndl = (cast<CFinderItemObject>(pxItem))^.GetHndl();
		endif;
		return xHndl;
	endproc;

	//----------------------------------------------------------
	// GetObjByGuid()
	//----------------------------------------------------------
	export static proc CClntHndl GetObjByGuid(ref CGuid p_rxGuid)
		var CClntHndl xInvalid;
		xInvalid.Invalidate();

		var ^CList pxList = CEnhancedMenu.Get().GetObjFinder()^.GetObjList();
		if(pxList==null)then return xInvalid; endif;
		var int i;
		for (i=0) cond (i<pxList^.NumItems()) iter(++i) do
			var ^CFinderItem pxItem = cast<CFinderItem>(pxList^.GetItemData(i));
			if(pxItem==null)then return xInvalid; endif;
			if(pxItem^.GetType()==CFinderItem.TYPE_OBJECT)then
				var CClntHndl xHndl = (cast<CFinderItemObject>(pxItem))^.GetHndl();
				if(xHndl.IsValid())then
					if(xHndl.GetObj()^.GetGuid() == p_rxGuid)then return xHndl; endif;
				endif;
			endif;
		endfor;
		return xInvalid;
	endproc;

	export static proc ^CObj FindObjOfType(CFourCC p_xType)
		var int i, iC = GetNumObjects();
		for(i=0) cond(i<iC) iter(++i) do
			var ^CObj pxObj = GetObjByIndex(i).GetObj();
			if(pxObj!=null)then
				if(pxObj^.GetType()==p_xType)then
					return pxObj;
				endif;
			endif;
		endfor;
		return null;
	endproc;

	export static proc ^CObj FindObjOfClass(string p_sClass)
		var int i, iC = GetNumObjects();
		for(i=0) cond(i<iC) iter(++i) do
			var ^CObj pxObj = GetObjByIndex(i).GetObj();
			if(pxObj!=null)then
				if(pxObj^.GetClassName()==p_sClass)then
					return pxObj;
				endif;
			endif;
		endfor;
		return null;
	endproc;

	export static proc int GetNumObjects()
		var ^CList pxObjList = CEnhancedMenu.Get().GetObjFinder()^.GetObjList();
		if(pxObjList == null)then return 0; endif;
		return pxObjList^.NumItems();
	endproc;

endclass;

//----------------------------------------------------------
// Class:	CActionQuestPages
//----------------------------------------------------------
class CActionQuestPages inherit CActionPages

	var ^CList		m_pxQuests;
	var ^CEdit		m_pxHeadline;
	var ^CEdit		m_pxDesc;
	var ^CDropList	m_pxOwner;
	var ^CCheckBox	m_pxVisible;
	var ^CCheckBox	m_pxAccomp;
	var ^CCheckBox	m_pxUnaccomp;

	class CQuestInfo
		export var string 	m_sName;
		export var string	m_sHead;
		export var string	m_sDesc;
		export var CGuid	m_xGuid;
	endclass;

	var array CQuestInfo	m_axQuests;

	//----------------------------------------------------------
	// ctor()
	//----------------------------------------------------------
	export constructor()
		m_apxPages=1;

		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_QUES");

		m_pxQuests 		= cast<CList>(m_apxPages[0]^.GetControl("GBox_Questbox/List_Quests"));
		m_pxHeadline 	= cast<CEdit>(m_apxPages[0]^.GetControl("GBox_Questbox/Edit_Headline"));
		m_pxDesc		= cast<CEdit>(m_apxPages[0]^.GetControl("GBox_Questbox/Edit_Desc"));
		m_pxOwner		= cast<CDropList>(m_apxPages[0]^.GetControl("Drop_Owner"));
		m_pxVisible		= cast<CCheckBox>(m_apxPages[0]^.GetControl("GBox_Action/Check_Visible"));
		m_pxAccomp		= cast<CCheckBox>(m_apxPages[0]^.GetControl("GBox_Action/Check_Accomplished"));
		m_pxUnaccomp	= cast<CCheckBox>(m_apxPages[0]^.GetControl("GBox_Action/Check_Unaccomplishable"));

		m_pxQuests^.m_xOnSelect = OnSelectQuest;
		m_pxUnaccomp^.m_xOnStateChange = OnUnaccomp;
		m_pxAccomp^.m_xOnStateChange = OnAccomp;

		LoadQuestInfo();
	endconstructor;

	destructor()
	enddestructor;

	proc bool OnSelectQuest()
		var int iSel = m_pxQuests^.GetSelectedItem();
		if(iSel < m_axQuests.NumEntries() && iSel >= 0)then
			m_pxHeadline^.SetText(m_axQuests[iSel].m_sHead);
			m_pxDesc^.SetText(m_axQuests[iSel].m_sDesc);
		endif;
		return true;
	endproc;

	proc bool OnUnaccomp()
		if(m_pxUnaccomp^.GetCheckMark())then
			m_pxAccomp^.SetChecked(0);
			m_pxAccomp^.SetDisabled(true);
			m_pxVisible^.SetChecked(1);
			m_pxVisible^.SetDisabled(true);
		else
			m_pxVisible^.SetDisabled(false);
			m_pxAccomp^.SetDisabled(false);
		endif;
		return true;
	endproc;
	proc bool OnAccomp()
		if(m_pxAccomp^.GetCheckMark())then
			m_pxUnaccomp^.SetChecked(0);
			m_pxUnaccomp^.SetDisabled(true);
			m_pxVisible^.SetChecked(1);
			m_pxVisible^.SetDisabled(true);
		else
			m_pxVisible^.SetDisabled(false);
			m_pxUnaccomp^.SetDisabled(false);
		endif;
		return true;
	endproc;

	proc void LoadQuestInfo()
		var ^CQuestMgrClient pxQM=^(CClientWrap.GetClient().GetQuestMgr());
		var int i,iC=pxQM^.NumQuests();
		m_axQuests = iC;
		for(i=0)cond(i<iC)iter(i++)do
			var ^CQuestMgr.CQuest pxWalk=^(pxQM^.GetQuest(i));
			m_axQuests[i].m_sName = pxWalk^.GetName();
			m_axQuests[i].m_sHead = pxWalk^.GetHeadline();
			m_axQuests[i].m_sDesc = pxWalk^.GetDescription();
			m_axQuests[i].m_xGuid = pxWalk^.GetGuid();
		endfor;
		m_pxQuests^.Clear();

		iC = m_axQuests.NumEntries();
		for(i=0) cond(i<iC) iter(++i) do
			m_pxQuests^.AddItem(m_axQuests[i].m_sName);
		endfor;

		if(iC > 0)then m_pxQuests^.Select(0); endif;

		m_pxOwner^.Clear();
		m_pxOwner^.AddItem("All");
		iC = 8;
		for (i=0) cond(i<iC) iter(++i) do
			m_pxOwner^.AddItem(i.ToString());
		endfor;

	endproc;

	//----------------------------------------------------------
	// OnInit()
	//----------------------------------------------------------
	export proc void OnInit(ref CAttribs p_rxParams)
		LoadQuestInfo();

		var string sCurQuest=p_rxParams.GetValue("quest_guid");
		var CGuid xG; xG.FromString(sCurQuest);
		
		var int iItemIdx = -1;
		var int i, iC = m_axQuests.NumEntries();
		for(i=0) cond(i<iC) iter(++i) do
			if(xG==m_axQuests[i].m_xGuid)then
				iItemIdx = i;
				break;
			endif;
		endfor;
		
		if(iItemIdx<0)then
			sCurQuest = p_rxParams.GetValue("quest_name");
			iItemIdx=m_pxQuests^.FindItem(sCurQuest);
		endif;
		
		if(iItemIdx!=-1)then
			m_pxQuests^.Select(iItemIdx);
		endif;

		m_pxVisible^.SetChecked(0);
		m_pxAccomp^.SetChecked(0);
		m_pxUnaccomp^.SetChecked(0);

		var int iState = p_rxParams.GetValueInt("dest_state");

		if(iState==0)then
			m_pxVisible^.SetChecked(1);
		elseif(iState == 1)then
			m_pxVisible^.SetChecked(1);
			m_pxAccomp^.SetChecked(1);
		elseif(iState==2)then
			m_pxVisible^.SetChecked(1);
			m_pxUnaccomp^.SetChecked(1);
		endif;

		var int iOwner = p_rxParams.GetValueInt("owner");
		if(iOwner < 0)then
			m_pxOwner^.SetText("All");
		else
			m_pxOwner^.SetText(iOwner.ToString());
		endif;
	endproc;

	//----------------------------------------------------------
	// OnFinish()
	//----------------------------------------------------------
	export proc void OnFinish(ref CAttribs po_rxParams)
		var int iSel = m_pxQuests^.GetSelectedItem();
		if(iSel>=0)then
			po_rxParams.SetValue("quest_guid", m_axQuests[iSel].m_xGuid.ToString());
				
			var string sOwn = m_pxOwner^.GetText();
			var int iOwn = sOwn.ToInt();
			if(sOwn=="All")then
				iOwn = -1;
			endif;
			po_rxParams.SetValue("owner", iOwn);
	
			var int iState = 3;
			if(m_pxUnaccomp^.GetCheckMark())then
				iState = 2;
			else
				if(m_pxAccomp^.GetCheckMark())then
					iState = 1;
				endif;
			endif;
	
			if(m_pxVisible^.GetCheckMark() && iState == 3)then
				iState = 0;
			endif;
	
			po_rxParams.SetValue("dest_state", iState);
		endif;
	endproc;

endclass;


class CAttribsRecognizator

	export static proc bool Do(CFourCC p_xType, ref array string po_rasAttribs)
		var string sClass = "";
		if(p_xType == "CHTR")then
			sClass = "hu_worker";
		elseif(p_xType == "ANML")then
			sClass = "Allosaurus";
		elseif(p_xType == "VHCL")then
			sClass = "hu_steam_tank";
		elseif(p_xType == "SHIP")then
			sClass = "hu_fishing_boat";
		elseif(p_xType == "HERO")then
			sClass = "bela_s0";
		elseif(p_xType == "BLDG")then
			sClass = "hu_fireplace";
		endif;

		if(!sClass.IsEmpty())then
			return Do(sClass, po_rasAttribs);
		endif;
		return false;
	endproc;

	export static proc bool Do(string p_sClass, ref array string po_rasAttribs)
		var CGuid xGuid;
		xGuid.Generate();
		var Quat qRot;
		var vec3 vP;

		CEvt_CreateObj.Send(p_sClass, 0, xGuid, vP);

		var ^CObj pxO = null;

		if(pxO!=null)then
			var ^CAttribs pxAttr = pxO^.GetAttribs();
			if(pxAttr!=null)then
				var string sName, sVal;
				var int i, iC = pxAttr^.NumEntries();
				po_rasAttribs = iC;
				for(i=0) cond(i<iC) iter(++i) do
					pxAttr^.GetEntry(i, sName, sVal);
					po_rasAttribs[i] = sName;
				endfor;
			endif;
		endif;
		CClientWrap.GetObjMgr().DeleteGhost();
		return po_rasAttribs.NumEntries() > 0;
	endproc;
endclass;


//----------------------------------------------------------
// Class:	
//----------------------------------------------------------
class CComplexObjPages inherit CActionPages

	class CPasWnd inherit CEnhancedFrameWindow
		var ^CDropList m_pxClass;
		var ^CSpinCtrlNumber m_pxLevel;
		var ^CButton m_pxOK, m_pxCancel;

		export var procref<bool,string,int> m_xOnOK;

		export constructor(string p_sTribe)
			InitFromResource("Trigger/ViewActionCreate","Action_CPLX_Passenger");
			m_pxClass = cast<CDropList>(GetControl("Drop_Class"));
			m_pxLevel = cast<CSpinCtrlNumber>(GetControl("Spin_Level"));
			m_pxOK = cast<CButton>(GetControl("Btn_OK"));
			m_pxCancel = cast<CButton>(GetControl("Btn_Cancel"));
			var CTechTreeDef xTTDef;
			var ^CTechTreeMgr pxTTMgr = ^(CLevelEditorWrap.GetClient().GetTechTreeMgr());
			var CTechTree xTT = pxTTMgr^.GetTechTree(xTTDef);
			var array string asTypes;
			asTypes.AddEntry("CHTR");
			asTypes.AddEntry("ANML");
			asTypes.AddEntry("VHCL");
			if(p_sTribe.GetLength() > 0)then
				var string sTmp;
				sTmp = p_sTribe.Left(1);
				sTmp.MakeUpper();
				sTmp += p_sTribe.Mid(1);
				p_sTribe = sTmp;
				//L //L KLog.LogSpam("RoSt", "Tribe is "+p_sTribe);
			endif;
			var int iType, iTypeC = asTypes.NumEntries();
			if(p_sTribe=="Seas" || p_sTribe=="seas")then p_sTribe="SEAS"; endif;
			for(iType=0)cond(iType<iTypeC)iter(iType++)do
				var ^CTechTree.CNode pxObjNode = xTT.FindNode("/Objects/"+p_sTribe+"/"+asTypes[iType]);
				if(pxObjNode!=null)then
					var int i, iC = pxObjNode^.NumSubs();
					//L //L KLog.LogSpam("RoSt", "Numsubs: "+iC.ToString());
					for(i=0) cond(i<iC) iter(++i) do
						var ^CTechTree.CNode pxChild = pxObjNode^.GetSub(i);
						var ^CObjectTreeCtrl.CObjectItem pxItemData =new CObjectTreeCtrl.CObjectItem();
						pxItemData^.m_pxNode=pxChild;
						m_pxClass^.AddItem(pxChild^.GetName(),pxItemData);
					endfor;
				else
					//L //L KLog.LogSpam("RoSt", "Didn't find node '/Objects/"+p_sTribe+"/"+asTypes[iType]+"'!");
				endif;
			endfor;
			m_pxOK^.m_xOnClick = OnOK;
			m_pxCancel^.m_xOnClick = Close;
			m_pxClass^.m_xOnChange=OnSelectPassengers;
		endconstructor;
		
		proc bool OnSelectPassengers()
			var ^CObjectTreeCtrl.CObjectItem pxItemData =cast <CObjectTreeCtrl.CObjectItem>( m_pxClass^.GetItemData(m_pxClass^.GetSelectedItem()));
			if(pxItemData!=null)then
				var ^CTechTree.CNode pxTechTreeNode = pxItemData^.m_pxNode;
				var int iObjTTLvl= pxTechTreeNode^.GetSubValueI("captainlevel");
//				m_pxLevel^.SetLimits(iObjTTLvl,5,1);
				m_pxLevel^.SetLimits(1,5,1);
				m_pxLevel^.SetValue(iObjTTLvl);
			endif;
			return true;
		endproc;
		
		export proc void Init(string p_sCaste, int p_iLvl)
			m_pxClass^.SetText(p_sCaste);
			m_pxLevel^.SetValue(p_iLvl);
		endproc;
		
		proc bool OnOK()
			if(!m_xOnOK.IsNull())then
				m_xOnOK.Call(m_pxClass^.GetText(), m_pxLevel^.GetValueInt());
			endif;
			Close();
			return true;
		endproc;
		
		proc bool Close()
			CClientWrap.GetDesktop()^.RemoveChild(this);
			CWindowMgr.Get().ReleaseModal(this);
			CWindowMgr.Get().DeleteWindowDelayed(this);
			return true;
		endproc;
		
	endclass;

	var ^CObjectTreeCtrl	m_pxObjects;
	var ^CList						m_pxBuildUps;
	var ^CSpinCtrlNumber	m_pxOwner;
	var ^CEdit						m_pxPos;
	var ^CEdit						m_pxCustom;
	var ^CSpinCtrlNumber	m_pxCptLvl;
	var ^CStaticCtrl			m_pxCaptain;
	var ^CCheckBox				m_pxIgnorePyramid;

	var ^CList						m_pxPassengers;
	var ^CButton					m_pxAddPas;
	var ^CButton					m_pxRemPas;
	var ^CButton					m_pxEditPas;
	var string						m_sBuildupPath;

	//----------------------------------------------------------
	// ctor()
	//----------------------------------------------------------
	export constructor()
		CMainController.Get().AddClickProcRef(SetPos);
		m_apxPages=1;

		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_CPLX");

		m_pxObjects				= cast<CObjectTreeCtrl>(m_apxPages[0]^.GetControl("List_TransportObj"));
		m_pxBuildUps			= cast<CList>(m_apxPages[0]^.GetControl("List_BuildUps"));
		m_pxOwner					= cast<CSpinCtrlNumber>(m_apxPages[0]^.GetControl("Drop_Owner"));
		m_pxPos						= cast<CEdit>(m_apxPages[0]^.GetControl("Edit_Pos"));
		m_pxCustom				= cast<CEdit>(m_apxPages[0]^.GetControl("Edit_Custom"));
		m_pxPassengers		= cast<CList>(m_apxPages[0]^.GetControl("List_Passengers"));
		m_pxAddPas				= cast<CButton>(m_apxPages[0]^.GetControl("Btn_Add"));
		m_pxRemPas				= cast<CButton>(m_apxPages[0]^.GetControl("Btn_Rem"));
		m_pxEditPas				= cast<CButton>(m_apxPages[0]^.GetControl("Btn_Edit"));
		m_pxCptLvl				= cast<CSpinCtrlNumber>(m_apxPages[0]^.GetControl("Spin_CptLvl"));
		m_pxCaptain				= cast<CStaticCtrl>(m_apxPages[0]^.GetControl("Txt_CaptainClass"));
		m_pxIgnorePyramid	= cast<CCheckBox>(m_apxPages[0]^.GetControl("Check_Ignore_Pyramid"));
		
//		m_pxCustom^.SetMultiLine(true);
		m_pxCustom^.m_xOnChange = OnChangePassenger;
		m_pxPassengers^.m_xOnSelect = OnPassengerSelect;
		
		m_pxObjects^.m_xOnSelect = Update;
		m_pxOwner^.m_xOnChange = InitObjList;

		InitObjList();

		/*iC = 5;
		for(i=0) cond(i<iC) iter(++i) do
			m_pxPassengers^.AddItem(i.ToString());
		endfor;
		*/
		m_pxAddPas^.m_xOnClick = OnAddPassenger;
		m_pxRemPas^.m_xOnClick = OnRemPassenger;
		m_pxEditPas^.m_xOnClick = OnEditPassenger;
		
		var ^CLevelInfo pxLevelInfo=^(CLevelEditorWrap.GetClient().GetLevelInfo());
		var ^CPropDB pxLI = ^(pxLevelInfo^.GetGenericData());
		var ^CPropDB.CNode pxBaseNode=^((pxLI^)["Base"]);
		var int iMaxPlayer = pxBaseNode^.GetValueI("MaxPlayers");
		if(iMaxPlayer==0)then iMaxPlayer=1; endif;
//		m_pxOwner^.SetLimits(0, iMaxPlayer-1, 1);
		m_pxOwner^.SetLimits(0, 7, 1);
	endconstructor;

	destructor()
		CMainController.Get().RemoveClickProcRef(SetPos);
	enddestructor;

	proc bool DoAdd(string p_sCaste, int p_iLvl)
		m_pxPassengers^.AddItem(p_sCaste + "/" + p_iLvl.ToString());
		OnPassengerSelect();
		return true;
	endproc;

	proc bool DoEdit(string p_sCaste, int p_iLvl)
		var int iIdx = m_pxPassengers^.GetSelectedItem();
		if(iIdx>=0)then
			m_pxPassengers^.SetItemText(iIdx, p_sCaste+"/"+p_iLvl.ToString());
		endif;
		OnPassengerSelect();
		return true;
	endproc;

	proc bool OnAddPassenger()
		if(!m_pxObjects^.IsObjSelected())then return false; endif;
		var string sA = m_pxObjects^.GetSelectedItemAsString();
		var ^CObjectTreeCtrl.CObjectItem pxItemData =cast <CObjectTreeCtrl.CObjectItem>( m_pxObjects^.GetItemData(m_pxObjects^.GetSelectedItem()));
		var ^CTechTree.CNode pxTechTreeNode = pxItemData^.m_pxNode;
		if(m_pxBuildUps^.NumItems() == 0)then
			if(pxTechTreeNode^.GetSubValueI("max_passengers")<=m_pxPassengers^.NumItems())then return false; endif;
			var int iP = sA.Find('_');
			sA = sA.Left(iP);
			var ^CPasWnd pxW = new CPasWnd(sA);
			pxW^.m_xOnOK = DoAdd;
			CClientWrap.GetDesktop()^.AddChild(pxW);
			CWindowMgr.Get().BringWindowToTop(pxW, true);
			CWindowMgr.Get().SetModal(pxW);
		else
			var string sObject = m_pxBuildUps^.GetSelectedItemAsString();
			var CTechTreeDef xTTDef;
			xTTDef.EnableFilter(m_sBuildupPath+sObject);
			var ^CTechTreeMgr pxTTMgr = ^(CLevelEditorWrap.GetClient().GetTechTreeMgr());
			var CTechTree xTT = pxTTMgr^.GetTechTree(xTTDef);
			var ^CTechTree.CNode pxTTNode = xTT.FindNode(pxTechTreeNode^.GetAbsPath());
			if(!sObject.IsEmpty() && pxTTNode != null)then
				if(pxTTNode^.GetSubValueI("max_passengers")<=m_pxPassengers^.NumItems())then return false; endif;
				var int iP = sObject.Find('_');
				sObject = sObject.Left(iP);
				var ^CPasWnd pxW = new CPasWnd(sObject);
				pxW^.m_xOnOK = DoAdd;
				CClientWrap.GetDesktop()^.AddChild(pxW);
				CWindowMgr.Get().BringWindowToTop(pxW, true);
				CWindowMgr.Get().SetModal(pxW);
			endif;
		endif;
		return true;
	endproc;

	proc bool OnEditPassenger()
		if(!m_pxObjects^.IsObjSelected())then return false; endif;
		var string sA = m_pxObjects^.GetSelectedItemAsString();
		var int iP = sA.Find('_');
		sA = sA.Left(iP);
		var ^CPasWnd pxW = new CPasWnd(sA);
		sA = m_pxPassengers^.GetSelectedItemAsString();
		var array string asTok;
		sA.Split(asTok,"/",true);
		if(asTok.NumEntries()>=2)then
			pxW^.Init(asTok[0], asTok[1].ToInt());
		endif;
		pxW^.m_xOnOK=DoEdit;
		CClientWrap.GetDesktop()^.AddChild(pxW);
		CWindowMgr.Get().BringWindowToTop(pxW, true);
		CWindowMgr.Get().SetModal(pxW);
		return true;
	endproc;

	proc bool OnRemPassenger()
		if(!m_pxObjects^.IsObjSelected())then return false; endif;
		var int iIdx = m_pxPassengers^.GetSelectedItem();
		if(iIdx >= 0)then
			m_pxPassengers^.DeleteItem(iIdx);
		endif;
		OnPassengerSelect();
		return true;
	endproc;

	proc bool InitObjList()
		m_pxPassengers^.Clear();
		var bitset dwTribe = 0b;
		var ^CLevelInfo pxLevelInfo=^(CLevelEditorWrap.GetClient().GetLevelInfo());
		var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
		var string sTribe = "";
		var ^CPropDB.CNode pxNode = pxGenericDB^.FindNode("PlayerSettings/Player_"+m_pxOwner^.GetValueInt().ToString()+"/Restrictions/Base/Tribes", false);
		if(pxNode!=null)then
			sTribe = pxNode^.Value();
		endif;
		KLog.LogSpam("MaZi", "Tribes: "+sTribe);
//		if(sTribe.Find("Hu")>=0)then
//			dwTribe |= CObjectTreeCtrl.SHOW_HU;
//		endif;
//		if(sTribe.Find("Aje")>=0)then
//			dwTribe |= CObjectTreeCtrl.SHOW_AJE;
//		endif;
//		if(sTribe.Find("Ninigi")>=0)then
//			dwTribe |= CObjectTreeCtrl.SHOW_NINIGI;
//		endif;
//		if(sTribe.Find("SEAS")>=0)then
//			dwTribe |= CObjectTreeCtrl.SHOW_SEAS;
//		endif;
		dwTribe |= CObjectTreeCtrl.SHOW_AJE;
		dwTribe |= CObjectTreeCtrl.SHOW_HU;
		dwTribe |= CObjectTreeCtrl.SHOW_NINIGI;
		dwTribe |= CObjectTreeCtrl.SHOW_SEAS;
		KLog.LogSpam("MaZi", "dwTribe: " + dwTribe.ToString());
		m_pxObjects^.FillTree(CObjectTreeCtrl.SHOW_ANML | CObjectTreeCtrl.SHOW_VHCL | CObjectTreeCtrl.SHOW_SHIP | dwTribe);
		return true;
	endproc;

	proc bool SetPos()
		var vec3 vPos = CClientWrap.GetScapeMgr().GetPickPoint();
		var string sTmp = vPos.ToString();
		m_pxPos^.SetText(sTmp);
		return true;
	endproc;

	proc bool Update()
		m_pxBuildUps^.Clear();
		m_pxPassengers^.Clear();
		var string sObject = m_pxObjects^.GetSelectedItemAsString();
		var ^CTechTree.CNode pxTTNode = m_pxObjects^.GetSelectedTTNode();
		if(!sObject.IsEmpty() && pxTTNode!=null)then
			// set captain info
			var string sCptCaste = pxTTNode^.GetSubValue("captaincaste", "");
			var string sClass = m_pxObjects^.GetSelectedTribe()+"_";
			sClass.MakeLower();
			if(sCptCaste=="nat")then
				sClass+="spearman";
			elseif(sCptCaste=="tec")then
				sClass+="archer";
			elseif(sCptCaste=="res")then
				sClass+="worker";
			endif;
			m_pxCaptain^.SetText(sClass);
			var int iMinLevel = pxTTNode^.GetSubValueI("captainlevel", 0);
//			m_pxCptLvl^.SetLimits(iMinLevel, 5, 1);
			m_pxCptLvl^.SetLimits(1,5,1);
			m_pxCptLvl^.SetValue(iMinLevel);
		endif;
		var ^CTechTreeMgr pxTTMgr=^(CLevelEditorWrap.GetClient().GetTechTreeMgr());
		var int i,iC=pxTTMgr^.NumEntries();
		var string sAnimal = m_pxObjects^.GetSelectedItemAsString();
		if(sAnimal!="")then
			for(i=0)cond(i<iC)iter(i++)do
				var string sPath=pxTTMgr^.GetFilterPath(i);
				if(sPath.Find("Upgrades/"+sAnimal) >= 0 && sPath.Find("_Remove") < 0  && sPath.Find("_Bonus") < 0 && sPath.Find("_capacity_") < 0 && sPath.Find("age_") < 0 && sPath.Find("_upgrade_") < 0)then
					var string sP = sPath;
					var int iP = sP.FindRev('/');
					sP.Delete(0,iP+1);
					if(m_pxBuildUps^.FindItem(sP)<0)then
						m_sBuildupPath = sPath.Left(iP+1);
						m_pxBuildUps^.AddItem(sP);
					endif;
				endif;
			endfor;
		endif;
		return true;
	endproc;
	
	//----------------------------------------------------------
	// OnInit()
	//----------------------------------------------------------
	export proc void OnInit(ref CAttribs p_rxParams)
		m_pxOwner^.SetValue(p_rxParams.GetValueInt("obj_owner"));
		m_pxObjects^.OnInit(p_rxParams.GetValue("obj_name"));
		m_pxCptLvl^.SetValue(p_rxParams.GetValueInt("cptlvl"));
		m_pxIgnorePyramid^.SetChecked(p_rxParams.GetValueInt("ignore_pyramid"));
		/*var int iPos = m_pxObjects^.FindItem(p_rxParams.GetValue("obj_name"));
		if(iPos>=0)then
			m_pxObjects^.Select(iPos);
		endif;*/
		var int iPos = m_pxBuildUps^.FindItem(p_rxParams.GetValue("buildup"));
		if(iPos>=0)then
			m_pxBuildUps^.Select(iPos);
		endif;
		m_pxPassengers^.Clear();
		var string sPas = p_rxParams.GetValue("passengers");
		var array string asTok;
		sPas.Split(asTok,"|",true);
		var int i,iC=asTok.NumEntries();
		for(i=0)cond(i<iC)iter(++i) do
			m_pxPassengers^.AddItem(asTok[i]);
		endfor;
		m_pxPos^.SetText(p_rxParams.GetValue("obj_pos"));
		if(iC>0)then
			m_pxPassengers^.Select(0);
			m_pxCustom^.SetText(asTok[0]);
		else
			m_pxCustom^.SetText("");
		endif;
	endproc;

	//----------------------------------------------------------
	// OnFinish()
	//----------------------------------------------------------
	export proc void OnFinish(ref CAttribs po_rxParams)
		po_rxParams.SetValue("obj_name", m_pxObjects^.GetSelectedItemAsString());
		po_rxParams.SetValue("buildup", m_pxBuildUps^.GetSelectedItemAsString());
		//po_rxParams.SetValue("num_passengers", m_pxPassengers^.GetText().ToInt());
		var string sPas;
		var int i, iC = m_pxPassengers^.NumItems();
		for(i=0)cond(i<iC)iter(++i)do
			sPas += m_pxPassengers^.GetItem(i) + "|";
		endfor;
		po_rxParams.SetValue("passengers", sPas);
		po_rxParams.SetValue("obj_pos", m_pxPos^.GetText());
		po_rxParams.SetValue("obj_owner", m_pxOwner^.GetValueInt());
		po_rxParams.SetValue("cptlvl", m_pxCptLvl^.GetValueInt());
		po_rxParams.SetValue("ignore_pyramid", m_pxIgnorePyramid^.GetCheckMark());
		po_rxParams.SetValue("renderable", 1);
		po_rxParams.SetValue("renderable_type", "CreationDummy");
	endproc;
	
	proc bool OnChangePassenger()
		if(m_pxPassengers^.NumItems()>0)then
			m_pxPassengers^.SetItemText(m_pxPassengers^.GetSelectedItem(),m_pxCustom^.GetText());
		endif;
		return true;
	endproc;
	
	proc bool OnPassengerSelect()
		if(m_pxPassengers^.NumItems()>0)then
			m_pxCustom^.SetText(m_pxPassengers^.GetSelectedItemAsString());
		else
			m_pxCustom^.SetText("");
		endif;
		return true;
	endproc;
	
endclass;

//----------------------------------------------------------
// Class:	CActionNodePages
//----------------------------------------------------------
class CActionNodePages inherit CActionPages

	var ^CTreeCtrl 			m_pxTree;
	var ^CRadioButton		m_pxActivate, m_pxDeactivate;

	//----------------------------------------------------------
	// ctor()
	//----------------------------------------------------------
	export constructor()
		m_apxPages=1;

		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_ACND");

		m_pxTree 		= cast<CTreeCtrl>(m_apxPages[0]^.GetControl("GBox_Tree/Tree_Trigger"));
		m_pxActivate	= cast<CRadioButton>(m_apxPages[0]^.GetControl("Radio_Activate"));
		m_pxDeactivate	= cast<CRadioButton>(m_apxPages[0]^.GetControl("Radio_Deactivate"));

		m_pxActivate^.m_xOnChange 	= OnActivate;
		m_pxDeactivate^.m_xOnChange = OnDeactivate;
		m_pxTree^.m_xOnSelect = OnSelectNode;
		UpdateTree();
	endconstructor;

	destructor()
	enddestructor;

	proc bool OnActivate()
		m_pxActivate^.SetSelected(true);
		m_pxDeactivate^.SetSelected(false);
		return true;
	endproc;

	proc bool OnDeactivate()
		m_pxActivate^.SetSelected(false);
		m_pxDeactivate^.SetSelected(true);
		return true;
	endproc;

	proc bool UpdateTree()
		var ^CTriggerDescMgr pxTriggerMgr = ^(CLevelEditorWrap.GetTriggerDescMgr());

		var CTriggerDescMgr.CNode xRoot = pxTriggerMgr^.GetHierarchyRoot();
		if(xRoot.IsValid())then
			FillTreeCtrlRec(xRoot, m_pxTree^.AddItem(0, xRoot.GetData()^.GetNodeName()));
		endif;
		return true;
	endproc;

	proc void FillTreeCtrlRec(CTriggerDescMgr.CNode p_xNode, int p_iItem)
		if(!p_xNode.IsValid())then return; endif;

		var int i, iC = p_xNode.GetData()^.NumTriggers();
		for(i=0) cond(i<iC) iter(++i) do
			var ^CTriggerDesc pxT = p_xNode.GetData()^.GetTrigger(i);
			if(pxT!=null)then
				var int iTriggerIdx = m_pxTree^.AddItem(p_iItem, ">>> " + pxT^.GetName());
				m_pxTree^.SetItemDisabled(iTriggerIdx, true, false);
			endif;
		endfor;

		iC = p_xNode.NumChildren();
		for(i=0) cond(i<iC) iter(++i) do
			var CTriggerDescMgr.CNode xChild = p_xNode.GetChild(i);
			if(xChild.IsValid())then
				FillTreeCtrlRec(xChild, m_pxTree^.AddItem(p_iItem, xChild.GetData()^.GetNodeName()));
			endif;
		endfor;
	endproc;

	proc bool OnSelectNode()
		m_pxTree^.m_xOnSelect.Clear();
		var int iItem = m_pxTree^.GetSelectedItem();
		if(iItem>0)then
			var string sName = m_pxTree^.GetSelectedItemAsString();
			if(sName.Find(">>> ")==0)then
				m_pxTree^.Select(m_pxTree^.GetParentItem(iItem));
			endif;
		endif;
		m_pxTree^.m_xOnSelect = OnSelectNode;
		return true;
	endproc;

	//----------------------------------------------------------
	// OnInit()
	//----------------------------------------------------------
	export proc void OnInit(ref CAttribs p_rxParams)
		var string 	sNodeName  = p_rxParams.GetValue("nodename");
		var int 	iDestState = p_rxParams.GetValueInt("deststate");

		var array string asToks;
		sNodeName.Split(asToks, "/", true);
		var int i=0, iC=asToks.NumEntries();
		var int iCur = m_pxTree^.FindItem(0, "Root");

		if(asToks.NumEntries() > 0)then
			if(asToks[0] == "Root")then i=1; endif;
			for(i=i) cond(i<iC) iter(++i) do
				var int iChild = FindChildItem(iCur, asToks[i]);
				if(iChild>0)then iCur = iChild; endif;
			endfor;
		endif;
		m_pxTree^.EnsureVisible(iCur);
		m_pxTree^.Select(iCur);

		if(iDestState>0)then
			OnActivate();
		else
			OnDeactivate();
		endif;
	endproc;

	//----------------------------------------------------------
	// OnFinish()
	//----------------------------------------------------------
	export proc void OnFinish(ref CAttribs po_rxParams)
		var string sNode = BuildFullPath(m_pxTree^.GetSelectedItem());
		po_rxParams.SetValue("nodename", sNode);
		po_rxParams.SetValue("deststate", GetDestState());
	endproc;

	proc int GetDestState()
		if(m_pxActivate^.GetSelected())then return 1; else return 0; endif;
	endproc;

	proc string BuildFullPath(int p_iLeaf)
		if(p_iLeaf<=0)then return ""; endif;
		var string sPath, sTmp;
		var int iCur = p_iLeaf;
		repeat
			sTmp = m_pxTree^.GetItemText(iCur);
			sPath = sTmp + "/" + sPath;
			iCur = m_pxTree^.GetParentItem(iCur);
		until(iCur<=0) endrepeat;
		return sPath;
	endproc;

	proc int FindChildItem(int p_iParent, string p_sItem)
		var int i, iC = m_pxTree^.ItemNumChildren(p_iParent);
		var int iChild = -1;
		for (i=0) cond(i<iC) iter(++i) do
			iChild = m_pxTree^.GetChildItem(p_iParent, i);
			if(iChild>0)then
				if(m_pxTree^.GetItemText(iChild) == p_sItem)then return iChild; endif;
			endif;
		endfor;
		return -1;
	endproc;

endclass;

//----------------------------------------------------------
// Class:	CActionMapPing
//----------------------------------------------------------
class CActionMapPing inherit CActionPages

	var	^CRadioButton			m_pxPosRButton;
	var	^CRadioButton			m_pxObjQueryRButton;
	var ^CEdit					m_pxPos;
	var ^CDropList				m_pxOwner;
	var ^CActionObjSelector 	m_pxObjSel;

	var ^CCheckBox				m_pxExtended;
	var ^CTightMultistateButton	m_pxAddRemove;
	var ^CEdit					m_pxID;
	var ^CEdit					m_pxTimeToLife;
	var ^CEdit					m_pxNumRepeats;
	var ^CEdit					m_pxMSBetween;
	
	var	^CDropList				m_pxColorType;
	var ^CSpinCtrlNumber		m_pxRValue;
	var ^CSpinCtrlNumber		m_pxGValue;
	var ^CSpinCtrlNumber		m_pxBValue;
	var ^CPane					m_pxColorPane;

	export constructor(CGuid p_xGuid)
		CMainController.Get().AddClickProcRef(SetPos);
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_MPNG");

		m_pxPosRButton= cast<CRadioButton>(m_apxPages[0]^.GetControl("PosRButton"));
		m_pxObjQueryRButton= cast<CRadioButton>(m_apxPages[0]^.GetControl("ObjQueryRButton"));
		m_pxPosRButton^.m_xOnChange=OnClickPos_ObjQuery;
		m_pxObjQueryRButton^.m_xOnChange=OnClickPos_ObjQuery;
		m_pxPosRButton^.SetSelected(true);

		m_pxPos 	= cast<CEdit>(m_apxPages[0]^.GetControl("Edit_Pos"));
		m_pxObjSel	= cast<CActionObjSelector>(m_apxPages[0]^.GetControl("ObjSelectorBox/ObjSelector"));
		m_pxOwner 	= cast<CDropList>(m_apxPages[0]^.GetControl("Owner"));
		m_pxOwner^.AddItem("All");
		m_pxOwner^.AddItem("trigger obj");
		m_pxOwner^.AddItem("0");
		m_pxOwner^.AddItem("1");
		m_pxOwner^.AddItem("2");
		m_pxOwner^.AddItem("3");
		m_pxOwner^.AddItem("4");
		m_pxOwner^.AddItem("5");
		m_pxOwner^.AddItem("6");
		m_pxOwner^.AddItem("7");


		m_pxObjSel^.Init(p_xGuid);
		OnClickPos_ObjQuery();

		m_pxExtended = cast<CCheckBox>(m_apxPages[0]^.GetControl("Chk_Extended"));
		m_pxAddRemove = cast<CTightMultistateButton>(m_apxPages[0]^.GetControl("TMSBtn_AddRemove"));
		m_pxID = cast<CEdit>(m_apxPages[0]^.GetControl("Edit_ID"));
		m_pxTimeToLife = cast<CEdit>(m_apxPages[0]^.GetControl("Edit_TimeToLife"));
		m_pxNumRepeats = cast<CEdit>(m_apxPages[0]^.GetControl("Edit_NumRepeats"));
		m_pxMSBetween = cast<CEdit>(m_apxPages[0]^.GetControl("Edit_MSBetween"));
		
		m_pxExtended^.m_xOnStateChange = OnExtended;
		m_pxAddRemove^.AddState("Add");
		m_pxAddRemove^.AddState("Remove");
		m_pxAddRemove^.m_xOnClick = OnAddRemove;

		m_pxColorType=cast<CDropList>(m_apxPages[0]^.GetControl("ColorType"));
		m_pxColorType^.AddItem("Attack");
		m_pxColorType^.AddItem("Finished");
		m_pxColorType^.AddItem("SPMainQuest");
		m_pxColorType^.AddItem("SPOptQuest");
		m_pxColorType^.AddItem("SPHint");
		m_pxColorType^.AddItem("FixedColor");
		m_pxColorType^.m_xOnChange=OnChangeColorType;
		m_pxRValue=cast<CSpinCtrlNumber>(m_apxPages[0]^.GetControl("R_Value"));
		m_pxRValue^.m_xOnChange=UpdateColorPane;
		m_pxGValue=cast<CSpinCtrlNumber>(m_apxPages[0]^.GetControl("G_Value"));
		m_pxGValue^.m_xOnChange=UpdateColorPane;
		m_pxBValue=cast<CSpinCtrlNumber>(m_apxPages[0]^.GetControl("B_Value"));
		m_pxBValue^.m_xOnChange=UpdateColorPane;
		m_pxColorPane=cast<CPane>(m_apxPages[0]^.GetControl("ColorPane"));
		OnChangeColorType();
		UpdateColorPane();
		OnExtended();
	endconstructor;

	destructor()
		CMainController.Get().RemoveClickProcRef(SetPos);
		CClientWrap.GetObjMgr().ClearPosiotionMarker();
	enddestructor;

	proc bool OnExtended()
		if(m_pxExtended^.GetDisabled() == true)then;
			return true;
		endif;
		if(m_pxExtended^.GetCheckMark() == true)then
			m_pxAddRemove^.SetDisabled(false);
			m_pxID^.SetDisabled(false);
			if(m_pxAddRemove^.GetState() == 0)then
				m_pxTimeToLife^.SetDisabled(false);
				m_pxNumRepeats^.SetDisabled(false);
				m_pxMSBetween^.SetDisabled(false);
			else
				m_pxTimeToLife^.SetDisabled(true);
				m_pxNumRepeats^.SetDisabled(true);
				m_pxMSBetween^.SetDisabled(true);
			endif;
		else
			m_pxAddRemove^.SetDisabled(true);
			m_pxID^.SetDisabled(true);
			m_pxTimeToLife^.SetDisabled(true);
			m_pxNumRepeats^.SetDisabled(true);
			m_pxMSBetween^.SetDisabled(true);
		endif;
		return true;
	endproc;
	
	proc bool OnAddRemove()
		m_pxAddRemove^.CallOnClick();
		if(m_pxAddRemove^.GetState() == 0)then
			m_pxTimeToLife^.SetDisabled(false);
			m_pxNumRepeats^.SetDisabled(false);
			m_pxMSBetween^.SetDisabled(false);
		else
			m_pxTimeToLife^.SetDisabled(true);
			m_pxNumRepeats^.SetDisabled(true);
			m_pxMSBetween^.SetDisabled(true);
		endif;
		return true;
	endproc;
	
	proc bool OnClickPos_ObjQuery()
		if(m_pxPosRButton^.GetSelected())then
			m_pxPos^.SetDisabled(false);
			m_pxObjSel^.SetDisabled(true);
		else
			m_pxPos^.SetDisabled(true);
			m_pxObjSel^.SetDisabled(false);
		endif;
		
		return true;
	endproc;
	proc bool SetPos()
		if(m_pxPos^.GetDisabled())then return false; endif;
		var vec3 vPos = CClientWrap.GetScapeMgr().GetPickPoint();
		var string sTmp = vPos.ToString();
		sTmp.TrimLeft("[");	sTmp.TrimRight("]");
		m_pxPos^.SetText(sTmp);
		return true;
	endproc;

	export proc void OnInit(ref CAttribs p_rxParams)
		var string sPos=p_rxParams.GetValue("pos");
		m_pxPos^.SetText(sPos);
		var vec3 vPos=vec3.CreateFromString(sPos);

		var bool bUsePos=p_rxParams.GetValueBool("pos_objquery_flag");
		if(!bUsePos)then
			m_pxObjQueryRButton^.SetSelected(true);
		else
			m_pxPosRButton^.SetSelected(true);
		endif;
		OnClickPos_ObjQuery();

		var string sOwner=p_rxParams.GetValue("owner");
		m_pxOwner^.Select(m_pxOwner^.FindItem(sOwner));

		CClientWrap.GetObjMgr().SetPosiotionMarker("Region",vPos,2.0f);
		m_pxPos^.m_xOnChange=OnChangePos;

		m_pxObjSel^.OnInit(p_rxParams);

		m_pxExtended^.SetChecked(p_rxParams.GetValueInt("extended"));
		m_pxAddRemove^.SetState(p_rxParams.GetValueInt("add_remove"));
		m_pxID^.SetText(p_rxParams.GetValue("id"));
		m_pxTimeToLife^.SetText(p_rxParams.GetValueInt("time_to_life").ToString());
		m_pxNumRepeats^.SetText(p_rxParams.GetValueInt("num_repeats").ToString());
		m_pxMSBetween^.SetText(p_rxParams.GetValueInt("ms_between").ToString());

		var string sColorType=p_rxParams.GetValue("colortype");
		m_pxColorType^.SetText(sColorType);
		var string sFixedColor=p_rxParams.GetValue("fixedcolor");
		var array string asRGB;
		sFixedColor.Split(asRGB,":",false);
		if(asRGB.NumEntries()==3)then
			m_pxRValue^.SetValue(asRGB[0].ToInt());
			m_pxGValue^.SetValue(asRGB[1].ToInt());
			m_pxBValue^.SetValue(asRGB[2].ToInt());
		endif;
		OnExtended();
	endproc;

	proc bool OnChangePos()
		CClientWrap.GetObjMgr().SetPosiotionMarker("Region",vec3.CreateFromString(m_pxPos^.GetText()),2.0f);
		return true;
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		CClientWrap.GetObjMgr().ClearPosiotionMarker();
		var vec3 vPos;
		vPos.FromString(m_pxPos^.GetText());
		po_rxParams.SetValue("pos", vPos.ToString());
		po_rxParams.SetValue("owner", m_pxOwner^.GetSelectedItemAsString());
		po_rxParams.SetValue("pos_objquery_flag",!m_pxPos^.GetDisabled());

		po_rxParams.SetValue("extended", m_pxExtended^.GetCheckMark());
		po_rxParams.SetValue("add_remove", m_pxAddRemove^.GetState());
		po_rxParams.SetValue("id", m_pxID^.GetText());
		po_rxParams.SetValue("time_to_life", m_pxTimeToLife^.GetText().ToInt());
		po_rxParams.SetValue("num_repeats", m_pxNumRepeats^.GetText().ToInt());
		po_rxParams.SetValue("ms_between", m_pxMSBetween^.GetText().ToInt());

		po_rxParams.SetValue("colortype",m_pxColorType^.GetText());
		var string sColor=m_pxRValue^.GetValueInt().ToString()+":"+m_pxGValue^.GetValueInt().ToString()+":"+m_pxBValue^.GetValueInt().ToString();
		po_rxParams.SetValue("fixedcolor",sColor);
		m_pxObjSel^.OnFinish(po_rxParams);
	endproc;

	proc bool OnChangeColorType()
		var string sColorType=m_pxColorType^.GetText();
		var bool bFixedColor=sColorType=="FixedColor";

//		m_pxExtended^.SetDisabled(!bFixedColor);
		m_pxAddRemove^.SetDisabled(!bFixedColor);
		m_pxID^.SetDisabled(!bFixedColor);
		m_pxTimeToLife^.SetDisabled(!bFixedColor);
		m_pxNumRepeats^.SetDisabled(!bFixedColor);
		m_pxMSBetween^.SetDisabled(!bFixedColor);

		m_pxRValue^.SetDisabled(!bFixedColor);
		m_pxGValue^.SetDisabled(!bFixedColor);
		m_pxBValue^.SetDisabled(!bFixedColor);
		
		m_pxColorPane^.SetDisabled(!bFixedColor);
		OnExtended();
		return true;
	endproc;

	proc bool UpdateColorPane()
		var color xColor;
		xColor.SetRed(m_pxRValue^.GetValueInt());
		xColor.SetGreen(m_pxGValue^.GetValueInt());
		xColor.SetBlue(m_pxBValue^.GetValueInt());
		m_pxColorPane^.SetColor(xColor);
		return true;
	endproc;
endclass;

//----------------------------------------------------------
// Class:	CActionPopulationLimit
//----------------------------------------------------------
class CActionPopulationLimit inherit CActionPages

	var ^CSpinCtrlNumber m_pxLimit;
	var ^CSpinCtrlNumber m_pxPlayer;

	export constructor()
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_POPL");

		m_pxLimit = cast<CSpinCtrlNumber>(m_apxPages[0]^.GetControl("Spin_Limit"));
		m_pxPlayer = cast<CSpinCtrlNumber>(m_apxPages[0]^.GetControl("Spin_Player"));

	endconstructor;


	export proc void OnInit(ref CAttribs p_rxParams)
		m_pxLimit^.SetValue(p_rxParams.GetValueInt("limit"));
		m_pxPlayer^.SetValue(p_rxParams.GetValueInt("player_id"));
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		po_rxParams.SetValue("limit", m_pxLimit^.GetValueInt());
		po_rxParams.SetValue("player_id", m_pxPlayer^.GetValueInt());
	endproc;
endclass;

//----------------------------------------------------------
// Class:	CActionBlockSlots
//----------------------------------------------------------
class CActionBlockSlots inherit CActionPages

	var ^CSpinCtrlNumber m_pxPlayer;
	var array ^CSpinCtrlNumber m_apxOpen, m_apxClosed, m_apxAll;
	var array int m_aiSlotsInLvl;

	export constructor()
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_BLSL");
		m_pxPlayer = cast<CSpinCtrlNumber>(m_apxPages[0]^.GetControl("Spin_Player"));

		var int i, iC = 5;
		for(i=0) cond(i<iC) iter(++i) do
			m_apxOpen.AddEntry(cast<CSpinCtrlNumber>(m_apxPages[0]^.GetControl("Spin_Open" + (i+1).ToString())));
			m_apxClosed.AddEntry(cast<CSpinCtrlNumber>(m_apxPages[0]^.GetControl("Spin_Closed" + (i+1).ToString())));
			m_apxAll.AddEntry(cast<CSpinCtrlNumber>(m_apxPages[0]^.GetControl("Spin_All" + (i+1).ToString())));
		endfor;

		m_aiSlotsInLvl=5;
		m_aiSlotsInLvl[0]=25;
		m_aiSlotsInLvl[1]=15;
		m_aiSlotsInLvl[2]=8;
		m_aiSlotsInLvl[3]=3;
		m_aiSlotsInLvl[4]=1;

		for (i=0) cond(i<iC) iter(++i) do
			m_apxOpen[i]^.m_xOnChange = OnChangeOpen;
			m_apxClosed[i]^.m_xOnChange = OnChangeClosed;
			m_apxAll[i]^.SetValue(m_aiSlotsInLvl[i]);
		endfor;
	endconstructor;


	proc bool OnChangeOpen()
		var int i, iC = 5;
		for(i=0) cond(i<iC) iter(++i) do
			m_apxOpen[i]^.m_xOnChange.Clear();
			m_apxClosed[i]^.m_xOnChange.Clear();
			var int iClosed = m_apxAll[i]^.GetValueInt()-m_apxOpen[i]^.GetValueInt();
			if(iClosed < 0)then
				m_apxOpen[i]^.SetValue(m_apxOpen[i]^.GetValueInt()+iClosed);
				iClosed=0;
			endif;
			m_apxClosed[i]^.SetValue(iClosed);
			m_apxOpen[i]^.m_xOnChange = OnChangeOpen;
			m_apxClosed[i]^.m_xOnChange = OnChangeClosed;
		endfor;
		return true;
	endproc;


	proc bool OnChangeClosed()
		var int i, iC = 5;
		for(i=0) cond(i<iC) iter(++i) do
			m_apxOpen[i]^.m_xOnChange.Clear();
			m_apxClosed[i]^.m_xOnChange.Clear();
			var int iOpen = m_apxAll[i]^.GetValueInt()-m_apxClosed[i]^.GetValueInt();
			if(iOpen < 0)then
				m_apxClosed[i]^.SetValue(m_apxClosed[i]^.GetValueInt()+iOpen);
				iOpen=0;
			endif;
			m_apxOpen[i]^.SetValue(iOpen);
			m_apxOpen[i]^.m_xOnChange = OnChangeOpen;
			m_apxClosed[i]^.m_xOnChange = OnChangeClosed;
		endfor;
		return true;
	endproc;


	export proc void OnInit(ref CAttribs p_rxParams)
		var int i, iC = 5;
		for(i=0) cond(i<iC) iter(++i) do
			m_apxOpen[i]^.SetValue(p_rxParams.GetValueInt("open_" + (i+1).ToString()));
		endfor;
		m_pxPlayer^.SetValue(p_rxParams.GetValueInt("player_id"));
	endproc;


	export proc void OnFinish(ref CAttribs po_rxParams)
		po_rxParams.SetValue("player_id", m_pxPlayer^.GetValueInt());
		var int i, iC = 5;
		for(i=0) cond(i<iC) iter(++i) do
			po_rxParams.SetValue("open_" + (i+1).ToString(), m_apxOpen[i]^.GetValueInt());
		endfor;
	endproc;
endclass;


//----------------------------------------------------------
// Class:	CActionDiplomacy
//----------------------------------------------------------
class CActionDiplomacyPages inherit CActionPages

	var ^CSpinCtrlNumber m_pxPlyr1, m_pxPlyr2;
	var ^CDropList m_pxRelation;
	var ^CList m_pxChanges;

	var ^CButton m_pxAdd, m_pxRem;

	export constructor()
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_DIPL");

		m_pxPlyr1 = cast<CSpinCtrlNumber>(m_apxPages[0]^.GetControl("Spin_Player1"));
		m_pxPlyr2 = cast<CSpinCtrlNumber>(m_apxPages[0]^.GetControl("Spin_Player2"));
		m_pxRelation = cast<CDropList>(m_apxPages[0]^.GetControl("Drop_Relation"));
		m_pxChanges = cast<CList>(m_apxPages[0]^.GetControl("List_Changes"));
		m_pxAdd = cast<CButton>(m_apxPages[0]^.GetControl("Btn_Apply"));
		m_pxRem = cast<CButton>(m_apxPages[0]^.GetControl("Btn_Remove"));

		m_pxAdd^.m_xOnClick = OnApplyChange;
		m_pxRem^.m_xOnClick = OnRemoveChange;

		m_pxRelation^.AddItem("is an enemy of");
		m_pxRelation^.AddItem("is neutral to");
		m_pxRelation^.AddItem("is a friend of");

		var ^CLevelInfo pxLevelInfo=^(CLevelEditorWrap.GetClient().GetLevelInfo());
		var ^CPropDB pxLI = ^(pxLevelInfo^.GetGenericData());
		var ^CPropDB.CNode pxBaseNode=^((pxLI^)["Base"]);
		var int iMaxPlayer = pxBaseNode^.GetValueI("MaxPlayers");
		if(iMaxPlayer==0)then iMaxPlayer=1; endif;
		m_pxPlyr1^.SetLimits(0, iMaxPlayer-1, 1);
		m_pxPlyr2^.SetLimits(0, iMaxPlayer-1, 1);

	endconstructor;

	proc bool OnApplyChange()
		var int iPlayer1 = m_pxPlyr1^.GetValueInt();
		var int iPlayer2 = m_pxPlyr2^.GetValueInt();

		if(iPlayer1==iPlayer2)then return false; endif;

		var int i, iC = m_pxChanges^.NumItems();
		for(i=0) cond(i<iC) iter(++i) do
			var int iA, iB;
			var string sText = m_pxChanges^.GetItem(i);
			iA = sText.Find(iPlayer1.ToString());
			iB = sText.Find(iPlayer2.ToString());

			if((iA >= 0 && iB >= 0) && iA < iB)then
				return false;
			endif;
		endfor;
		m_pxChanges^.AddItem(m_pxPlyr1^.GetValueInt().ToString() + " " + m_pxRelation^.GetSelectedItemAsString() +
							 " " + m_pxPlyr2^.GetValueInt().ToString());
		return true;
	endproc;

	proc bool OnRemoveChange()
		var int iItem = m_pxChanges^.GetSelectedItem();
		if(iItem>=0)then m_pxChanges^.DeleteItem(iItem); endif;
		return true;
	endproc;

	proc string CreateAttribsString(string p_sStr)
		if(p_sStr.Find("enemy") >= 0)then
			p_sStr.Replace(" is an enemy of ", "|0|");
		elseif(p_sStr.Find("neutral") >= 0)then
			p_sStr.Replace(" is neutral to ", "|1|");
		elseif(p_sStr.Find("friend") >= 0)then
			p_sStr.Replace(" is a friend of ", "|2|");
		else
			return "";
		endif;
		return p_sStr+"\n";
	endproc;

	export proc void OnInit(ref CAttribs p_rxParams)
		var string sChanges = p_rxParams.GetValue("changes");

		var array string asRels;
		sChanges.Split(asRels,"\n",true);

		var int i, iC = asRels.NumEntries();
		for(i=0) cond(i<iC) iter(++i)do
			var array string asToks;

			asRels[i].Split(asToks, "|", true);
			m_pxChanges^.AddItem(asToks[0] + " " + m_pxRelation^.GetItem(asToks[1].ToInt()) + " " + asToks[2]);
		endfor;
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		var string sSend;
		var int i, iC = m_pxChanges^.NumItems();
		for(i=0) cond(i<iC) iter(++i) do
			sSend += CreateAttribsString(m_pxChanges^.GetItem(i));
		endfor;
		po_rxParams.SetValue("changes", sSend);
	endproc;
endclass;

//----------------------------------------------------------
// Class:	CActionGameOverPages
//----------------------------------------------------------
class CActionGameOverPages inherit CActionPages

	var ^CSpinCtrlNumber 	m_pxPlayer;
	var ^CDropList			m_pxReason;
	var ^CList 				m_pxToolTipList;
	var string				m_sReason;
	var ^CStaticCtrlEx 		m_pxToolTip;

	export constructor()
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_GAOV");

		m_pxPlayer = cast<CSpinCtrlNumber>(m_apxPages[0]^.GetControl("Spin_Owner"));
		m_pxReason = cast<CDropList>(m_apxPages[0]^.GetControl("Drop_Reason"));
		m_pxToolTipList=cast<CList>(m_apxPages[0]^.GetControl("ToolTipList"));
		m_pxToolTip=cast<CStaticCtrlEx>(m_apxPages[0]^.GetControl("ToolTip"));
		
		m_pxToolTipList^.m_xOnSelect=OnSelectToolTip;

		var ^CLevelInfo pxLevelInfo=^(CLevelEditorWrap.GetClient().GetLevelInfo());
		var ^CPropDB pxLI = ^(pxLevelInfo^.GetGenericData());

		var ^CPropDB.CNode pxBaseNode=^((pxLI^)["Base"]);

		var int iMaxPlayer=pxBaseNode^.GetValueI("MaxPlayers");
		if(iMaxPlayer==0)then iMaxPlayer=1; endif;
		m_pxPlayer^.SetLimits(0, iMaxPlayer-1, 1);
		
		begin load_keys;
			var int i,iC=CLocalizer.Get().NumKeys();
			for(i=0)cond(i<iC)iter(i++)do
				var string sKey;
				if(CLocalizer.Get().GetKey(i,sKey))then
					if(sKey.Left(6)=="_GAOV_")then
						m_pxReason^.AddItem(sKey);
						m_pxToolTipList^.AddItem(sKey);
					endif;
				endif;
			endfor;
			// Fix by AyCe
			CSDKLocalizationMgr.Get().CustomGameoverreasons(m_pxReason,m_pxToolTipList);
			// Fix end
			m_pxReason^.QSort();
			m_pxToolTipList^.QSort();
		end load_keys;

		/*
		var string sQuestionsLMF=CClientWrap.GetUrsRelPath()+"/Data/Base/Texts/gameoverreasons.lmf";
		var CSourceFileLineSplitter xLS;
		var int iLine=0;
		if(xLS.Open(sQuestionsLMF))then
			var string sLine;
			while(xLS.GetLine(iLine,sLine))do
				var array string asTokens;
				sLine.Split(asTokens,";",true);
				if(asTokens.NumEntries()>0)then
					var string sKey=asTokens[0];
					sKey.TrimLeft("\"");
					sKey.TrimRight("\"");
					if(sKey.Left(6)=="_GAOV_")then
						m_pxReason^.AddItem(sKey);
						m_pxToolTipList^.AddItem(sKey);
					endif;
				endif;				
				iLine++;
			endwhile;
		endif;
		xLS.Close();
		*/
	endconstructor;
	
	proc bool OnSelectToolTip()
		var string sTTKey=m_pxToolTipList^.GetSelectedItemAsString();
		var string sToolTipText=CLocalizer.Get().Translate(sTTKey);
		// Fix by AyCe
		if(sToolTipText==sTTKey)then
			sToolTipText = CSDKLocalizationMgr.Get().GetHelper(sTTKey);
		endif;
		// Fix end
		m_pxToolTip^.SetText(sToolTipText);
		return true;
	endproc;

	export proc void OnInit(ref CAttribs p_rxParams)
		var int iPlayer = p_rxParams.GetValueInt("player_id");
		var string sReason = p_rxParams.GetValue("reason");		
		m_pxPlayer^.SetValue(iPlayer);
		m_pxReason^.SetText(sReason);
		m_sReason=sReason;
		// Fix by AyCe (so it's marked if possible)
		var int iC = m_pxReason^.NumItems();
		var int i;
		for (i=0) cond (i < iC) iter(++i) do
			if(m_pxReason^.GetItem(i) == sReason)then
				m_pxToolTipList^.Select(i);
				break;
			endif;
		endfor;
		// Fix end
	endproc;
	
	export proc void OnFinish(ref CAttribs po_rxParams)
		po_rxParams.SetValue("player_id", m_pxPlayer^.GetValueInt());
		po_rxParams.SetValue("reason", m_pxReason^.GetText());
	endproc;
endclass;

//----------------------------------------------------------
// Class:	CActionAiRegionPages
//----------------------------------------------------------
class CActionAiRegionPages inherit CActionPages

	var ^CSpinCtrlNumber	m_pxPlayer;
	var ^CCheckBox			m_pxAllPlayers;
	var ^CCheckBox			m_pxGlobal;
	var ^CDropList			m_pxMap;
	var ^CDropList			m_pxRegion;
	var ^CRadioButton		m_pxActionAdd;
	var ^CRadioButton		m_pxActionRem;
	//var ^CDropList		m_pxBehavior;


	export constructor()
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_AIRG");

		m_pxPlayer = cast<CSpinCtrlNumber>(m_apxPages[0]^.GetControl("Spin_Player"));
		m_pxAllPlayers = cast<CCheckBox>(m_apxPages[0]^.GetControl("CB_AllPlayers"));
		m_pxGlobal = cast<CCheckBox>(m_apxPages[0]^.GetControl("CB_Global"));
		m_pxMap = cast<CDropList>(m_apxPages[0]^.GetControl("List_Map"));
		//m_pxBehavior = cast<CDropList>(m_apxPages[0]^.GetControl("List_Behavior"));
		m_pxRegion = cast<CDropList>(m_apxPages[0]^.GetControl("List_Region"));
		m_pxActionAdd = cast<CRadioButton>(m_apxPages[0]^.GetControl("RB_Add_Edit"));
		m_pxActionRem = cast<CRadioButton>(m_apxPages[0]^.GetControl("RB_Remove"));
		
		m_pxRegion^.AddItem("UniqueWorldRegion");
		m_pxMap^.SetAllowAnyText(true);
		m_pxRegion^.SetAllowAnyText(true);
		
		//m_pxBehavior^.SetAllowAnyText(true);

		m_pxAllPlayers^.m_xOnStateChange = OnChangeAllPlayers;
		m_pxGlobal^.m_xOnStateChange = OnChangeGlobal;
		m_pxGlobal^.SetDisabled(true);
		m_pxActionAdd^.m_xOnChange = OnChangeAction;
		m_pxActionRem^.m_xOnChange = OnChangeAction;

		// set up Player spin control
		var ^CLevelInfo pxLevelInfo=^(CLevelEditorWrap.GetClient().GetLevelInfo());
		var ^CPropDB pxLI = ^(pxLevelInfo^.GetGenericData());
		var ^CPropDB.CNode pxBaseNode=^((pxLI^)["Base"]);
		var int iMaxPlayer=pxBaseNode^.GetValueI("MaxPlayers");
		if(iMaxPlayer==0)then iMaxPlayer=1; endif;
		m_pxPlayer^.SetLimits(0, iMaxPlayer-1, 1);
		
		FillRegions();
		FillMaps();
	endconstructor;

	
	/// on change players
	proc bool OnChangeAllPlayers()
		if(m_pxAllPlayers^.GetCheckMark()==true)then
			m_pxPlayer^.SetDisabled(true);
		else
			m_pxPlayer^.SetDisabled(false);
		endif;
		return true;
	endproc;


	///on change global
	proc bool OnChangeGlobal()
		if(m_pxGlobal^.GetCheckMark()==true)then
			m_pxPlayer^.SetDisabled(true);
			m_pxAllPlayers^.SetDisabled(true);
		else
			m_pxPlayer^.SetDisabled(false);
			m_pxAllPlayers^.SetDisabled(false);
		endif;
		FillMaps();
		return true;
	endproc;


	///on change action
	proc bool OnChangeAction()
		if(m_pxActionRem^.GetSelected()==true)then
			//m_pxValue^.SetDisabled(true);
		else
			//m_pxValue^.SetDisabled(false);
		endif;
		return true;
	endproc;


	///on init
	export proc void OnInit(ref CAttribs p_rxParams)
		var int iPlayer = p_rxParams.GetValueInt("player_id");
		var bool bAllPlayers = p_rxParams.GetValueBool("all_players");
		var string sMap = p_rxParams.GetValue("map_name");
		var string sMapDesc = p_rxParams.GetValue("map_description");
		//var string sBehavior=p_rxParams.GetValue("behavior_name");
		var bool bAddEdit = p_rxParams.GetValueBool("add_edit");
		var string sRegion = p_rxParams.GetValue("region_name");

		m_pxPlayer^.SetValue(iPlayer);
		if(iPlayer==-1)then
			m_pxGlobal^.SetChecked(1);
		endif;
		if(bAllPlayers==true)then
			m_pxAllPlayers^.SetChecked(1);
		else
			m_pxAllPlayers^.SetChecked(0);
		endif;
		m_pxMap^.SetText(sMapDesc);
		//m_pxBehavior^.SetText(sBehavior);
		if(bAddEdit==true)then
			m_pxActionAdd^.SetSelected(true);
			m_pxActionRem^.SetSelected(false);
		else
			m_pxActionAdd^.SetSelected(false);
			m_pxActionRem^.SetSelected(true);
		endif;
		m_pxRegion^.SetText(sRegion);
	endproc;


	///fill regions
	proc void FillRegions()
		m_pxRegion^.Clear();
		m_pxRegion^.AddItem("UniqueWorldRegion");
		var ^CRegionMgrClient pxRM=CClientWrap.GetRegionMgr();
		if(pxRM==null)then
			return;
		endif;
		var int iCR=pxRM^.NumRegions();
		var int i;
		for(i=0)cond(i<iCR)iter(i++)do
			var ^CRegionBase pxR=pxRM^.GetRegion(i);
			if(pxR!=null)then
				m_pxRegion^.AddItem(pxR^.GetName());
			endif;
		endfor;
	endproc;


	///fill maps
	proc void FillMaps()
		m_pxMap^.Clear();
		if(m_pxGlobal^.GetCheckMark()==true)then
			// add global AiMaps to the list
			m_pxMap^.AddItem("Land");//Land
			m_pxMap^.AddItem("Forest");//Forest
			m_pxMap^.AddItem("WOOD");//WOOD
			m_pxMap^.AddItem("FOOD");//FOOD
			m_pxMap^.AddItem("FRUI");//FRUI
			m_pxMap^.AddItem("Fish");//Fish
			m_pxMap^.AddItem("STON");//STON
			m_pxMap^.AddItem("Coast");//Coast
			m_pxMap^.AddItem("HostileAnimal");//HostileAnimal
			m_pxMap^.AddItem("FriendlyAnimal");//FriendlyAnimal
		else
			// add non-global AiMaps to the list
			m_pxMap^.AddItem("Ignore Wood Ressources");
			m_pxMap^.AddItem("Focus on Wood Ressources");			
			m_pxMap^.AddItem("Ignore Stone Ressources");
			m_pxMap^.AddItem("Focus on Stone Ressources");			
			m_pxMap^.AddItem("Ignore Fruit Ressources");
			m_pxMap^.AddItem("Focus on Fruit Ressources");			
			m_pxMap^.AddItem("Ignore Fish Ressources");
			m_pxMap^.AddItem("Focus on Fish Ressources");		
			m_pxMap^.AddItem("Ignore Animal Ressources");
			m_pxMap^.AddItem("Focus on Animal Ressources");			
			m_pxMap^.AddItem("Ignore Food Ressources");
			m_pxMap^.AddItem("Focus on Food Ressources");			
			m_pxMap^.AddItem("Ignore all Ressources");
			m_pxMap^.AddItem("Focus on all Ressources");			
			m_pxMap^.AddItem("Ignore all Enemies");
			m_pxMap^.AddItem("Focus on Enemy");
			m_pxMap^.AddItem("Attack Enemy");
			
			m_pxMap^.AddItem("Ignore all Buildings");
			m_pxMap^.AddItem("Focus on all Buildings");
			m_pxMap^.AddItem("Ignore Towers");
			m_pxMap^.AddItem("Focus on Towers");
			m_pxMap^.AddItem("Ignore Walls");
			m_pxMap^.AddItem("Focus on Walls");
			m_pxMap^.AddItem("Ignore Harbour");
			m_pxMap^.AddItem("Focus on Harbour");

			m_pxMap^.AddItem("Focus on hunt friendly animal");
			m_pxMap^.AddItem("Ignore hunt friendly animal");
			m_pxMap^.AddItem("Focus on hunt neutral animal");
			m_pxMap^.AddItem("Ignore hunt neutral animal");
			m_pxMap^.AddItem("Focus on hunt hostile animal");
			m_pxMap^.AddItem("Ignore hunt hostile animal");
		endif;
	endproc;
	

	///on finish
	export proc void OnFinish(ref CAttribs po_rxParams)
		if(m_pxGlobal^.GetCheckMark()==true)then
			var int iGlobal = -1;
			po_rxParams.SetValue("player_id",iGlobal);
		else
			po_rxParams.SetValue("player_id",m_pxPlayer^.GetValueInt());
		endif;
		po_rxParams.SetValue("all_players",m_pxAllPlayers^.GetChecked());
		po_rxParams.SetValue("map_name",GetMapNames());
		//po_rxParams.SetValue("behavior_name",m_pxBehavior^.GetText());
		po_rxParams.SetValue("add_edit",m_pxActionAdd^.GetSelected());
		po_rxParams.SetValue("region_name",m_pxRegion^.GetText());
		po_rxParams.SetValue("value",GetValues(m_pxMap^.GetText()));
		po_rxParams.SetValue("map_description", m_pxMap^.GetText());
	endproc;
	
	
	proc string GetMapNames()
		var string sMapNames = m_pxMap^.GetText();
		//ressources
		if((sMapNames=="Ignore Wood Ressources")||(sMapNames=="Focus on Wood Ressources"))then 					sMapNames="WOOD";		
		elseif((sMapNames=="Ignore Stone Ressources")||(sMapNames=="Focus on Stone Ressources"))then 			sMapNames="STON";		
		elseif((sMapNames=="Ignore Fruit Ressources")||(sMapNames=="Focus on Fruit Ressources"))then 			sMapNames="FRUI";	
		elseif((sMapNames=="Ignore Fish Ressources")||(sMapNames=="Focus on Fish Ressources"))then 				sMapNames="Fish"; 		
		elseif((sMapNames=="Ignore Animal Ressources")||(sMapNames=="Focus on Animal Ressources"))then 			sMapNames="FOOD";		
		elseif((sMapNames=="Ignore Food Ressources")||(sMapNames=="Focus on Food Ressources"))then 				sMapNames="ALLFOOD";		
		elseif((sMapNames=="Ignore all Ressources")||(sMapNames=="Focus on all Ressources"))then 				sMapNames="WOOD/STON/ALLFOOD";
		
		//enemy		
		elseif((sMapNames=="Ignore all Enemies")||(sMapNames=="Focus on Enemy")||(sMapNames=="Attack Enemy"))then sMapNames="Enemy";
		
		//economy
		elseif((sMapNames=="Ignore all Buildings")||(sMapNames=="Focus on all Buildings"))then 					sMapNames="BuildModifier";		//is ne map
		elseif((sMapNames=="Ignore Towers")||(sMapNames=="Focus on Towers"))then 								sMapNames="DefensiveCoverage";	//is ne map	
		elseif((sMapNames=="Ignore Walls")||(sMapNames=="Focus on Walls"))then 									sMapNames="village_level X3";	//WallVillageLevel		
		elseif((sMapNames=="Ignore Harbour")||(sMapNames=="Focus on Harbour"))then	 							sMapNames="CoastModifier";		//is ne map
		
		//special
		elseif((sMapNames=="Ignore hunt friendly animal")||(sMapNames=="Focus on hunt friendly animal"))then 	sMapNames="FriendlyAnimalModifier";
		elseif((sMapNames=="Ignore hunt neutral animal")||(sMapNames=="Focus on hunt neutral animal"))then 		sMapNames="NeutralAnimalModifier";
		elseif((sMapNames=="Ignore hunt hostile animal")||(sMapNames=="Focus on hunt hostile animal"))then 		sMapNames="HostileAnimalModifier";
		
		//outpost
		elseif(sMapNames=="Ressource Outpost")then sMapNames="village_level X1"; 	//Ressource Outpost
		elseif(sMapNames=="Attack Outpost")then sMapNames="village_level X2";		//Attack OutPost
		endif;
		return sMapNames;
	endproc;
	
	
	proc real GetValues(string p_sMap)
		var real 	fValue;
		var string 	sMapNames=p_sMap;
		
		//ressources
		if(sMapNames=="Ignore Wood Ressources")then fValue=-1.00;
		elseif(sMapNames=="Focus on Wood Ressources")then fValue=100.00;
		elseif(sMapNames=="Ignore Stone Ressources")then fValue=-1.00;
		elseif(sMapNames=="Focus on Stone Ressources")then fValue=100.00;		
		elseif(sMapNames=="Ignore Fruit Ressources")then fValue=-1.00;
		elseif(sMapNames=="Focus on Fruit Ressources")then fValue=100.00;
		elseif(sMapNames=="Ignore Fish Ressources")then fValue=-1.00;
		elseif(sMapNames=="Focus on Fish Ressources")then fValue=100.00;		
		elseif(sMapNames=="Ignore Animal Ressources")then fValue=-1.00;
		elseif(sMapNames=="Focus on Animal Ressources")then fValue=100.00;		
		elseif(sMapNames=="Ignore Food Ressources")then fValue=-1.00;
		elseif(sMapNames=="Focus on Food Ressources")then fValue=100.00;		
		elseif(sMapNames=="Ignore all Ressources")then fValue=-1.00;
		elseif(sMapNames=="Focus on all Ressources")then fValue=100.00;
			
		//enemy		
		elseif(sMapNames=="Ignore all Enemies")then fValue=-1.00;
		elseif(sMapNames=="Focus on Enemy")then fValue=50.00;
		elseif(sMapNames=="Attack Enemy")then fValue=100.00;
			
		//economy
		elseif(sMapNames=="Ignore all Buildings")then fValue=-1.00;
		elseif(sMapNames=="Focus on all Buildings")then fValue=100.00;		
		elseif(sMapNames=="Ignore Towers")then fValue=100.00;
		elseif(sMapNames=="Focus on Towers")then fValue=-1.00;			
		elseif(sMapNames=="Ignore Walls")then fValue=-1.00;
		elseif(sMapNames=="Focus on Walls")then fValue=100.00;			
		elseif(sMapNames=="Ignore Harbour")then fValue=-1.00;
		elseif(sMapNames=="Focus on Harbour")then fValue=100.00;
			
		//special
		elseif(sMapNames=="Ignore hunt friendly animal")then fValue=-1.00;
		elseif(sMapNames=="Focus on hunt friendly animal")then fValue=100.00;	
		elseif(sMapNames=="Ignore hunt hostile animal")then fValue=-1.00;
		elseif(sMapNames=="Focus on hunt hostile animal")then fValue=100.00;
		
		//outpost
		elseif(sMapNames=="Ressource Outpost")then fValue=100.00;
		elseif(sMapNames=="Attack Outpost")then fValue=100.00;
		endif;
		
		return fValue;
	endproc;
	
	
endclass;

//----------------------------------------------------------
// Class:	CActionAiBehaviorPages
//----------------------------------------------------------
class CActionAiBehaviorPages inherit CActionPages

	var ^CSpinCtrlNumber	m_pxPlayer;
	var ^CDropList			m_pxModule;
	var ^CDropList			m_pxBehavior;

	export constructor()
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_AIBV");

		m_pxPlayer = cast<CSpinCtrlNumber>(m_apxPages[0]^.GetControl("Spin_Player"));
		m_pxModule = cast<CDropList>(m_apxPages[0]^.GetControl("List_Module"));
		m_pxBehavior = cast<CDropList>(m_apxPages[0]^.GetControl("Edit_Behavior"));

		// set up Player spin control
		var ^CLevelInfo pxLevelInfo=^(CLevelEditorWrap.GetClient().GetLevelInfo());
		var ^CPropDB pxLI = ^(pxLevelInfo^.GetGenericData());
		var ^CPropDB.CNode pxBaseNode=^((pxLI^)["Base"]);
		var int iMaxPlayer=pxBaseNode^.GetValueI("MaxPlayers");
		if(iMaxPlayer==0)then iMaxPlayer=1; endif;
		m_pxPlayer^.SetLimits(0, iMaxPlayer-1, 1);

		m_pxModule^.SetAllowAnyText(true);
		m_pxBehavior^.SetAllowAnyText(true);

		FillModules();
		FillBehaviors();
	endconstructor;

	export proc void OnInit(ref CAttribs p_rxParams)
		var int iPlayer = p_rxParams.GetValueInt("player_id");
		var string sModule = p_rxParams.GetValue("module");
		var string sBehavior = p_rxParams.GetValue("behavior");

		m_pxPlayer^.SetValue(iPlayer);
		m_pxModule^.SetText(sModule);
		m_pxBehavior^.SetText(sBehavior);
	endproc;

	proc void FillModules()
		m_pxModule^.Clear();
		m_pxModule^.AddItem("CTRL - Control Module");
		m_pxModule^.AddItem("ECON - Economy Module");
		m_pxModule^.AddItem("FGHT - Fight Module");
		m_pxModule^.AddItem("DFNS - Defense Module");
		m_pxModule^.AddItem("AREA - Area Module");
	endproc;

	proc void FillBehaviors()
		m_pxBehavior^.Clear();
		m_pxBehavior^.AddItem("Schnecke");
		m_pxBehavior^.AddItem("Giraffe");
		m_pxBehavior^.AddItem("Dodo");
		m_pxBehavior^.AddItem("Turtle");
		m_pxBehavior^.AddItem("Mikrobe");
		m_pxBehavior^.AddItem("FightOnly");
		m_pxBehavior^.AddItem("enable");
		m_pxBehavior^.AddItem("disable");
		m_pxBehavior^.AddItem("aggressiveness <0..100>");
		m_pxBehavior^.AddItem("riskiness <0..100>");
		m_pxBehavior^.AddItem("tactics <Subtaktik>");
		m_pxBehavior^.AddItem("max_age <1..5>");
		m_pxBehavior^.AddItem("village_level <Dorfstufe>");
		m_pxBehavior^.AddItem("Singleplayer_L3_1");
		m_pxBehavior^.AddItem("Singleplayer_L3_2");
		m_pxBehavior^.AddItem("Singleplayer_L3_3");		
		m_pxBehavior^.AddItem("Singleplayer_L8_1");
		m_pxBehavior^.AddItem("Singleplayer_L8_2");
		m_pxBehavior^.AddItem("forbid_building");
		m_pxBehavior^.AddItem("reset_building");		
		m_pxBehavior^.AddItem("HighDefenseMode <true|false>");
		m_pxBehavior^.AddItem("CancelAttacksInDefense <radius>");
		m_pxBehavior^.AddItem("ProtectedTransport <true|false>");
		m_pxBehavior^.AddItem("EnableAiKotH <true|false>");
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		po_rxParams.SetValue("player_id",m_pxPlayer^.GetValueInt());
		po_rxParams.SetValue("module",m_pxModule^.GetText().Left(4));
		po_rxParams.SetValue("behavior",m_pxBehavior^.GetText());
	endproc;
endclass;

//----------------------------------------------------------
// Class:	CActionAiCallModulePages
//----------------------------------------------------------
class CActionAiCallModulePages inherit CActionPages

	var ^CSpinCtrlNumber	m_pxPlayer;
	var ^CDropList			m_pxModule;
	var ^CEdit				m_pxCommand;

	export constructor()
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_AICM");

		m_pxPlayer = cast<CSpinCtrlNumber>(m_apxPages[0]^.GetControl("Spin_Player"));
		m_pxModule = cast<CDropList>(m_apxPages[0]^.GetControl("List_Module"));
		m_pxCommand = cast<CEdit>(m_apxPages[0]^.GetControl("Edit_Command"));

		// set up Player spin control
		var ^CLevelInfo pxLevelInfo=^(CLevelEditorWrap.GetClient().GetLevelInfo());
		var ^CPropDB pxLI = ^(pxLevelInfo^.GetGenericData());
		var ^CPropDB.CNode pxBaseNode=^((pxLI^)["Base"]);
		var int iMaxPlayer=pxBaseNode^.GetValueI("MaxPlayers");
		if(iMaxPlayer==0)then iMaxPlayer=1; endif;
		m_pxPlayer^.SetLimits(0, iMaxPlayer-1, 1);

		m_pxModule^.SetAllowAnyText(true);

		FillModules();
	endconstructor;

	export proc void OnInit(ref CAttribs p_rxParams)
		var int iPlayer = p_rxParams.GetValueInt("player_id");
		var string sModule = p_rxParams.GetValue("module");
		var string sCommand = p_rxParams.GetValue("command");

		m_pxPlayer^.SetValue(iPlayer);
		m_pxModule^.SetText(sModule);
		m_pxCommand^.SetText(sCommand);
	endproc;

	proc void FillModules()
		m_pxModule^.Clear();
		m_pxModule^.AddItem("CTRL - Control Module");
		m_pxModule^.AddItem("ECON - Economy Module");
		m_pxModule^.AddItem("FGHT - Fight Module");
		m_pxModule^.AddItem("DFNS - Defense Module");
		m_pxModule^.AddItem("AREA - Area Module");
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		po_rxParams.SetValue("player_id",m_pxPlayer^.GetValueInt());
		po_rxParams.SetValue("module",m_pxModule^.GetText().Left(4));
		po_rxParams.SetValue("command",m_pxCommand^.GetText());
	endproc;
endclass;


//----------------------------------------------------------
// Class:	CActionAiDefendAreaPages
//----------------------------------------------------------
class CActionAiDefendAreaPages inherit CActionPages

	var ^CSpinCtrlNumber	m_pxPlayer;
	var ^CDropList			m_pxAddRemove;
	var ^CEdit				m_pxID;
	var ^CEdit				m_pxPosition;
	var ^CEdit				m_pxRadius;
	var ^CEdit				m_pxMaxUnits;

	export constructor()
		CMainController.Get().AddClickProcRef(SetPos);
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_AIDA");

		m_pxPlayer = cast<CSpinCtrlNumber>(m_apxPages[0]^.GetControl("Spin_Player"));
		m_pxAddRemove = cast<CDropList>(m_apxPages[0]^.GetControl("Drop_AddRemove"));
		m_pxID = cast<CEdit>(m_apxPages[0]^.GetControl("Edit_ID"));
		m_pxPosition = cast<CEdit>(m_apxPages[0]^.GetControl("Edit_Position"));
		m_pxRadius = cast<CEdit>(m_apxPages[0]^.GetControl("Edit_Radius"));
		m_pxMaxUnits = cast<CEdit>(m_apxPages[0]^.GetControl("Edit_MaxUnits"));

		// set up Player spin control
		var ^CLevelInfo pxLevelInfo=^(CLevelEditorWrap.GetClient().GetLevelInfo());
		var ^CPropDB pxLI = ^(pxLevelInfo^.GetGenericData());
		var ^CPropDB.CNode pxBaseNode=^((pxLI^)["Base"]);
		var int iMaxPlayer=pxBaseNode^.GetValueI("MaxPlayers");
		if(iMaxPlayer==0)then iMaxPlayer=1; endif;
		m_pxPlayer^.SetLimits(0, iMaxPlayer-1, 1);
		m_pxAddRemove^.Clear();
		m_pxAddRemove^.AddItem("Add");
		m_pxAddRemove^.AddItem("Remove");
		m_pxAddRemove^.m_xOnChange = OnAddRemoveChange;
	endconstructor;

	export destructor()
		CMainController.Get().RemoveClickProcRef(SetPos);
	enddestructor;

	proc bool OnAddRemoveChange()
		if(m_pxAddRemove^.GetText() == "Remove")then
			m_pxPosition^.SetDisabled(true);
			m_pxRadius^.SetDisabled(true);
			m_pxMaxUnits^.SetDisabled(true);
		else
			m_pxPosition^.SetDisabled(false);
			m_pxRadius^.SetDisabled(false);
			m_pxMaxUnits^.SetDisabled(false);
		endif;
		return true;
	endproc;
	
	proc bool SetPos()
		var vec3 vPos = CClientWrap.GetScapeMgr().GetPickPoint();
		var string sTmp = vPos.ToString();
		//sTmp.TrimLeft("[");	sTmp.TrimRight("]");
		sTmp.Replace(" ", ",");
		m_pxPosition^.SetText(sTmp);
		return true;
	endproc;

	export proc void OnInit(ref CAttribs p_rxParams)
		m_pxPlayer^.SetValue(p_rxParams.GetValueInt("player_id"));
		m_pxID^.SetText(p_rxParams.GetValue("id"));
		m_pxPosition^.SetText(p_rxParams.GetValue("position"));
		m_pxRadius^.SetText(p_rxParams.GetValue("radius"));
		m_pxMaxUnits^.SetText(p_rxParams.GetValue("max_units"));
		var int iMaxUnits = p_rxParams.GetValueInt("max_units");
		if(iMaxUnits <= 0)then
			m_pxAddRemove^.SetText("Remove");
		else
			m_pxAddRemove^.SetText("Add");
		endif;
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		var string sID = m_pxID^.GetText();
		
		sID.Replace(" ", "_");
		po_rxParams.SetValue("player_id",m_pxPlayer^.GetValueInt());
		po_rxParams.SetValue("id",sID);
		po_rxParams.SetValue("position",m_pxPosition^.GetText());
		po_rxParams.SetValue("radius",m_pxRadius^.GetText());
		po_rxParams.SetValue("max_units",m_pxMaxUnits^.GetText());
		if(m_pxAddRemove^.GetText() == "Remove")then
			po_rxParams.SetValue("max_units","0");
		endif;
	endproc;
endclass;

class CObjListData inherit CItemData
	export var ^CObj m_pxObj;

	export constructor(^CObj p_pxObj)
		m_pxObj=p_pxObj;
	endconstructor;
endclass;

//----------------------------------------------------------
// Class:	CActionAiLockUnitPages
//----------------------------------------------------------
class CActionAiLockUnitPages inherit CActionPages

	var ^CSpinCtrlNumber	m_pxPlayer;
	var ^CRadioButton		m_pxActionLock;
	var ^CRadioButton		m_pxActionUnlock;

	var ^CObjSelectionList	m_pxSelectionList;

/*	var ^CList				m_pxSelectionList;
	var ^CButton			m_pxSelectionAdd;
	var ^CButton			m_pxSelectionDel;
	var ^CButton			m_pxSelectionClr;
	var array ^CObj			m_apxSelection;
*/	var ^CActionObjSelector m_pxObjSel;
	var ^CCheckBox			m_pxCheckBox;


	///constructor
	export constructor(CGuid p_xGuid)
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_AILU");

		m_pxPlayer = cast<CSpinCtrlNumber>(m_apxPages[0]^.GetControl("Spin_Player"));
		m_pxActionLock = cast<CRadioButton>(m_apxPages[0]^.GetControl("RB_Lock"));
		m_pxActionUnlock = cast<CRadioButton>(m_apxPages[0]^.GetControl("RB_Unlock"));
		m_pxSelectionList = cast<CObjSelectionList>(m_apxPages[0]^.GetControl("SelectionList"));
		m_pxObjSel = cast<CActionObjSelector>(m_apxPages[0]^.GetControl("Obj_Selection"));
		m_pxCheckBox = cast<CCheckBox>(m_apxPages[0]^.GetControl("Obj_Disabled"));
		
		//checkbox to disable objquery
		m_pxCheckBox^.m_xOnStateChange = OnEnableDisabled;
		m_pxObjSel^.SetDisabled(m_pxObjSel^.GetDisabled());
		
		// set up Player spin control
		var ^CLevelInfo pxLevelInfo=^(CLevelEditorWrap.GetClient().GetLevelInfo());
		var ^CPropDB pxLI = ^(pxLevelInfo^.GetGenericData());
		var ^CPropDB.CNode pxBaseNode=^((pxLI^)["Base"]);
		var int iMaxPlayer=pxBaseNode^.GetValueI("MaxPlayers");
		if(iMaxPlayer==0)then iMaxPlayer=1; endif;
		m_pxPlayer^.SetLimits(0, iMaxPlayer-1, 1);

		m_pxObjSel^.Init(p_xGuid);
	endconstructor;
	
	
	//enable/disable obj query
	proc bool OnEnableDisabled()
		if(m_pxCheckBox^.GetCheckMark())then
			m_pxObjSel^.SetDisabled(false);
			return true;
		else
			m_pxObjSel^.SetDisabled(true);
			return true;
		endif;
	endproc;
	
	///OnInit
	export proc void OnInit(ref CAttribs p_rxParams)
		var int iPlayer = p_rxParams.GetValueInt("player_id");
		var bool bLock = p_rxParams.GetValueBool("lock");
		var bool bEnableObjSel = p_rxParams.GetValueBool("enable_objsel");
		
		if(m_pxObjSel^.GetDisabled()==false)then
			m_pxObjSel^.OnInit(p_rxParams);
		endif;
		if(bEnableObjSel == true)then
			m_pxCheckBox^.SetChecked(1);
			m_pxObjSel^.SetDisabled(false);
		else
			m_pxCheckBox^.SetChecked(0);
			m_pxObjSel^.SetDisabled(true);
		endif;
		m_pxPlayer^.SetValue(iPlayer);
		if(bLock==true)then
			m_pxActionLock^.SetSelected(true);
			m_pxActionUnlock^.SetSelected(false);
		else
			m_pxActionLock^.SetSelected(false);
			m_pxActionUnlock^.SetSelected(true);
		endif;
		m_pxSelectionList^.OnInit(p_rxParams, "units");
	endproc;


	//OnFinish
	export proc void OnFinish(ref CAttribs po_rxParams)
		po_rxParams.SetValue("player_id",m_pxPlayer^.GetValueInt());
		po_rxParams.SetValue("lock",m_pxActionLock^.GetSelected());
		po_rxParams.SetValue("enable_objsel",m_pxCheckBox^.GetCheckMark());
		if(m_pxObjSel^.GetDisabled()==false)then
			m_pxObjSel^.OnFinish(po_rxParams);
		endif;
		m_pxSelectionList^.OnFinish(po_rxParams, "units");
	endproc;
endclass;

//----------------------------------------------------------
// Class:	CActionAiAggressionPages
//----------------------------------------------------------
class CActionAiAggressionPages inherit CActionPages

	var ^CActionObjSelector m_pxObjSel;
	var ^CDropList			m_pxAggressionMode;
	var ^CCheckBox			m_pxObjDis;

	var ^CObjSelectionList	m_pxSelectionList;
	

	export constructor()
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_AIAM");
		m_pxObjSel			= cast<CActionObjSelector>(m_apxPages[0]^.GetControl("objsel"));
		m_pxAggressionMode	= cast<CDropList>(m_apxPages[0]^.GetControl("aggro_drop"));
		m_pxAggressionMode^.SetAllowAnyText(true);

		m_pxObjDis			= cast<CCheckBox>(m_apxPages[0]^.GetControl("selector_enabled"));
		m_pxObjDis^.m_xOnStateChange = OnEnableObj;

		m_pxSelectionList	= cast<CObjSelectionList>(m_apxPages[0]^.GetControl("SelectionList"));

		FillAggressionModes();
	endconstructor;

	export proc void OnInit(ref CAttribs p_rxParams)
		var int iAggroState = p_rxParams.GetValueInt("aggro_state");

		if(iAggroState == 0)then
			m_pxAggressionMode^.SetText("stand ground");
		elseif(iAggroState == 1)then
			m_pxAggressionMode^.SetText("defensive");
		elseif(iAggroState == 2)then
			m_pxAggressionMode^.SetText("aggressive");
		endif;
		m_pxObjSel^.OnInit(p_rxParams);
		m_pxObjDis^.SetChecked(p_rxParams.GetValueInt("selector_enabled"));
		m_pxObjSel^.SetDisabled(!m_pxObjDis^.GetCheckMark());
		m_pxSelectionList^.OnInit(p_rxParams, "aggro_state_units");
	endproc;

	proc bool OnEnableObj()
		if(m_pxObjDis^.GetCheckMark())then
			m_pxObjSel^.SetDisabled(false);
			return true;
		else
			m_pxObjSel^.SetDisabled(true);
			return true;
		endif;
	endproc;

	proc void FillAggressionModes()
		m_pxAggressionMode^.Clear();
		m_pxAggressionMode^.AddItem("stand ground");
		m_pxAggressionMode^.AddItem("defensive");
		m_pxAggressionMode^.AddItem("aggressive");
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		var string sVal = m_pxAggressionMode^.GetText();

		if(sVal == "stand ground")then
			po_rxParams.SetValue("aggro_state", 0);
		elseif(sVal == "defensive")then
			po_rxParams.SetValue("aggro_state", 1);
		elseif(sVal == "aggressive")then
			po_rxParams.SetValue("aggro_state", 2);
		endif;
		m_pxObjSel^.OnFinish(po_rxParams);
		po_rxParams.SetValue("selector_enabled", m_pxObjDis^.GetChecked());
		m_pxSelectionList^.OnFinish(po_rxParams, "aggro_state_units");
	endproc;
endclass;


//----------------------------------------------------------
// Class:	CActionVarsPages
//----------------------------------------------------------
class CActionVarsPages inherit CActionPages

	var ^CList					m_pxList;
	var ^CStaticCtrl		m_pxType;
	var ^CEdit					m_pxValue;
	var ^CRadioButton		m_pxLocal;
	var ^CRadioButton		m_pxGlobal;

	export constructor(CGuid p_xGuid)
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_VARS");
		m_pxList = cast<CList>(m_apxPages[0]^.GetControl("List_Vars"));
		m_pxType = cast<CStaticCtrl>(m_apxPages[0]^.GetControl("Txt_Type"));
		m_pxValue = cast<CEdit>(m_apxPages[0]^.GetControl("Edit_Value"));
		m_pxLocal = cast<CRadioButton>(m_apxPages[0]^.GetControl("Radio_Local"));
		m_pxGlobal = cast<CRadioButton>(m_apxPages[0]^.GetControl("Radio_Global"));
		m_pxList^.m_xOnSelect = OnSelect;
		m_pxValue^.m_xOnChange = CheckValue;
		m_pxLocal^.SetSelected(true);
		LoadVars(true);
		m_pxLocal^.m_xOnChange = OnCheckRadio;
		m_pxGlobal^.m_xOnChange = OnCheckRadio;
	endconstructor;

	export destructor()
		ClearList();
	enddestructor;

	proc bool OnCheckRadio()
		LoadVars(m_pxLocal^.GetSelected());
		return true;
	endproc;

	proc string GetVarName(^CViewTCVariables.CVarInfo p_pxV)
		return p_pxV^.m_sType + " " + p_pxV^.m_sName + " = '" + p_pxV^.m_sValue + "'";
	endproc;

	proc void ClearList()
		var int i, iC = m_pxList^.NumItems();
		for(i=0) cond(i<iC) iter(++i) do
			delete m_pxList^.GetItemData(i);
		endfor;
		m_pxList^.Clear();
	endproc;

	proc void LoadVars(bool p_bLocal)
		ClearList();
		var ^CPropDB pxDB;
		var ^CPropDB.CNode pxNode;
		if(p_bLocal)then
			var ^CLevelInfo pxLevelInfo=^(CLevelEditorWrap.GetClient().GetLevelInfo());
			pxNode = pxLevelInfo^.GetGenericData().FindNode("Variables", false);
		else
			pxDB = new CPropDB();
			if(pxDB^.Load(CClientWrap.GetUrsRelPath()+"/Data/Base/Scripts/Server/settings/ProfileVariables.txt"))then
				pxNode = ^(pxDB^.GetRoot());//FindNode("Variables", false);
			else
				KLog.LogSpam("MaZi", "NOT FOUND");
			endif;
		endif;
		if(pxNode!=null)then
			var int i, iC = pxNode^.NumSubs();
			for(i=0) cond(i<iC) iter(++i) do
				var ^CPropDB.CNode pxSub = ^(pxNode^.Get(i));
				var ^CViewTCVariables.CVarInfo pxVI = new CViewTCVariables.CVarInfo();
				if(p_bLocal)then
					pxVI^.Set(pxSub^.Name(), pxSub^.GetValueS("type"), pxSub^.GetValueS("value"));
				else
					KLog.LogSpam("MaZi", pxSub^.GetValueS("type")+" "+pxSub^.Name()+"="+pxSub^.GetValueS("default"));
					pxVI^.Set(pxSub^.Name(), pxSub^.GetValueS("type"), pxSub^.GetValueS("default"));
				endif;
				m_pxList^.AddItem(GetVarName(pxVI), new CViewTCVariables.CVarData(pxVI));
			endfor;
		endif;
		delete pxDB;
	endproc;

	proc bool OnSelect()
		var int iSel = m_pxList^.GetSelectedItem();
		if(iSel>=0)then
			var ^CViewTCVariables.CVarData pxVD = cast<CViewTCVariables.CVarData>(m_pxList^.GetItemData(iSel));
			if(pxVD==null)then return false; endif;
			var ^CViewTCVariables.CVarInfo pxVI = pxVD^.m_pxVar;
			if(pxVI==null)then return false; endif;
			m_pxType^.SetText(pxVI^.m_sType);
			m_pxValue^.SetText("");
		endif;
		return true;
	endproc;

	proc bool CheckValue()
		var string sD, sE;
		return CheckValueImpl(sD, sE);
	endproc;

	proc bool CheckValueImpl(ref string po_rsVal, ref string po_rsOp)
		m_pxValue^.m_xOnChange.Clear();
		var string sType = m_pxType^.GetText();
		var string sValue = m_pxValue^.GetText();
		if(sType == "string")then
			po_rsVal = sValue;
			po_rsOp = "set";
			return true;
		elseif(sType == "int" || sType == "float")then
			po_rsOp = "set";
			var char cA = sValue.GetAt(0);
			if(cA=='+' || cA=='-' || cA=='*' || cA=='/')then
				sValue = sValue.Mid(1);
				po_rsOp = cA;
			endif;
			if((sType=="int" && (sValue.ToInt().ToString()==sValue)) ||
				(sType=="float" && (sValue.ToReal().ToString()==sValue)))  then
				po_rsVal = sValue;
				return true;
			endif;
		elseif(sType == "bool")then
			if(sValue.CompareNoCase("true")==0 || sValue.CompareNoCase("false")==0)then
				po_rsVal = sValue;
				po_rsOp = "set";
				return true;
			else
				m_pxValue^.SetText("false");
				po_rsVal = "false";
				po_rsOp = "set";
			endif;
		endif;
		po_rsVal="";
		po_rsOp="";
		m_pxValue^.SetText("");;
		return false;
	endproc;

	export proc void OnInit(ref CAttribs p_rxParams)
		var bool bLocal = p_rxParams.GetValueInt("local")==1;
		var string sName = p_rxParams.GetValue("varname");
		var string sValue = p_rxParams.GetValue("value");
		var string sOp = p_rxParams.GetValue("operation");
		if(bLocal)then
			m_pxLocal^.SetSelected(true);
		else
			m_pxGlobal^.SetSelected(true);
		endif;
		LoadVars(bLocal);
		var int i, iC = m_pxList^.NumItems();
		for(i=0) cond(i<iC) iter(++i) do
			var ^CViewTCVariables.CVarData pxVD = cast<CViewTCVariables.CVarData>(m_pxList^.GetItemData(i));
			if(pxVD==null)then return; endif;
			var ^CViewTCVariables.CVarInfo pxVI = pxVD^.m_pxVar;
			if(pxVI==null)then return; endif;
			if(pxVI^.m_sName == sName)then break; endif;
		endfor;
		if(i<iC)then
			m_pxList^.Select(i);
			m_pxValue^.m_xOnChange.Clear();
			if(sOp=="set")then
				m_pxValue^.SetText(sValue);
			else
				m_pxValue^.SetText(sOp+sValue);
			endif;
			m_pxValue^.m_xOnChange = CheckValue;
		endif;
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		var int iSel = m_pxList^.GetSelectedItem();
		if(iSel<0)then return; endif;
		var string sName, sVal, sOp;
		if(CheckValueImpl(sVal, sOp))then
			var ^CViewTCVariables.CVarData pxVD = cast<CViewTCVariables.CVarData>(m_pxList^.GetItemData(iSel));
			if(pxVD==null)then return; endif;
			var ^CViewTCVariables.CVarInfo pxVI = pxVD^.m_pxVar;
			if(pxVI==null)then return; endif;
			sName = pxVI^.m_sName;
		endif;
		var int iLocal = 0;
		if(m_pxLocal^.GetSelected())then iLocal = 1; endif;
		po_rxParams.SetValue("local", iLocal);
		po_rxParams.SetValue("varname", sName);
		po_rxParams.SetValue("value", sVal);
		po_rxParams.SetValue("operation", sOp);
	endproc;
endclass;

// Weather Action
class CActionWeatherPages inherit CActionPages

	var ^CList 			m_pxList;
	var ^CRadioButton	m_pxChgProg;
	var ^CRadioButton	m_pxNextTrack;

	class CWeatherDesc inherit CItemData

		export var string m_sPath;

		export constructor()
		endconstructor;

		export constructor(string p_sPath)
			m_sPath = p_sPath;
		endconstructor;

	endclass;

	export constructor(CGuid p_xGuid)
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_WTHR");

		m_pxList		= cast<CList>(m_apxPages[0]^.GetControl("List_Weather"));
		m_pxChgProg		= cast<CRadioButton>(m_apxPages[0]^.GetControl("Radio_ChgProg"));
		m_pxNextTrack	= cast<CRadioButton>(m_apxPages[0]^.GetControl("Radio_NextTrack"));

		m_pxChgProg^.m_xOnChange = OnClickRadio;
		m_pxNextTrack^.m_xOnChange = OnClickRadio;

		FillWeatherList("Custom");
		FillWeatherList("Predefined");

		m_pxChgProg^.SetSelected(true);
	endconstructor;

	proc bool OnClickRadio()
		if(m_pxChgProg^.GetSelected())then
			m_pxList^.SetDisabled(false);
		else
			m_pxList^.SetDisabled(true);
		endif;
		return true;
	endproc;

	proc bool FillWeatherList(string p_sType)
		var Filesystem.CFileList xFileList;
		var string sPath=CClientWrap.GetUrsRelPath()+"/Data/LevelEd/Scripts/options/Weather/"+p_sType+"Weather";
		var int i,j;
		var array string asLists;
		var int iNumFiles=xFileList.ReadListEx(sPath,"*.swl",true,true);
		for(i=0)cond(i<iNumFiles)iter(i++)do
			if(i>xFileList.NumEntries()-1)then break;endif;
			if(xFileList[i].m_sName.Right(4)!=".swl")then
				xFileList.DeleteEntry(i);
				i--;
			else
				var string sTemp=xFileList[i].m_sName;
				var int iP = sTemp.FindRev('/');
				sTemp = sTemp.Mid(iP+1);
				sTemp.Replace(".swl","");
				asLists.AddEntry(sTemp);
			endif;
		endfor;
		iNumFiles=asLists.NumEntries();
		for(i=0)cond(i<iNumFiles)iter(i++)do
			m_pxList^.AddItem("<"+p_sType+">  " + asLists[i], new CWeatherDesc(xFileList[i].m_sName));
		endfor;
		return true;
	endproc;

	proc void ClearList()
		var int i, iC = m_pxList^.NumItems();
		for(i=0) cond(i<iC) iter(++i) do
			delete m_pxList^.GetItemData(i);
		endfor;
	endproc;

	export proc void OnInit(ref CAttribs p_rxParams)
		var int iChgType = p_rxParams.GetValueInt("chgtype");
		if(iChgType == 0)then
			m_pxChgProg^.SetSelected(true);
			m_pxList^.SetDisabled(false);
		else
			m_pxNextTrack^.SetSelected(true);
			m_pxList^.SetDisabled(true);
		endif;

		var string sProgName = p_rxParams.GetValue("progpath");

		var int i, iC = m_pxList^.NumItems();
		for(i=0) cond(i<iC) iter(++i) do
			var ^CWeatherDesc pxWD = cast<CWeatherDesc>(m_pxList^.GetItemData(i));
			if(pxWD!=null && pxWD^.m_sPath == sProgName)then
				m_pxList^.Select(i);
				break;
			endif;
		endfor;
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		var int iChgType = 0;
		if(m_pxNextTrack^.GetSelected())then
			iChgType = 1;
		endif;

		po_rxParams.SetValue("chgtype", iChgType);

		if(iChgType==1)then return; endif;

		var int iSel = m_pxList^.GetSelectedItem();
		if(iSel>=0)then
			po_rxParams.SetValue("progpath", (cast<CWeatherDesc>(m_pxList^.GetItemData(iSel)))^.m_sPath);
		endif;
	endproc;
endclass;

class CActionHelpPages inherit CActionPages

	var ^CTreeCtrl		m_pxTree;
	var ^CSemlView 		m_pxHelpText;
	var ^CDropList		m_pxOwner;

	class CIndexListData inherit CItemData
		export var int 		m_iItemID;
		export var string 	m_sName;
		export var string	m_sSEMLFile;
	endclass;

	var array CIndexListData m_axIndexItemData;
	var string m_sHelpPath;

	export constructor(CGuid p_xGuid)
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_HELP");

		m_pxTree = cast<CTreeCtrl>(m_apxPages[0]^.GetControl("Tree_Help"));
		m_pxHelpText = cast<CSemlView>(m_apxPages[0]^.GetControl("Help"));
		m_pxOwner = cast<CDropList>(m_apxPages[0]^.GetControl("Drop_Owner"));

		m_pxOwner^.AddItem("All");
		var int i, iC=8;
		for(i=0) cond(i<iC) iter(++i) do
			m_pxOwner^.AddItem(i.ToString());
		endfor;

		m_pxTree^.m_xOnSelect = OnIndexSelected;
		BuildIndex();
	endconstructor;

	export destructor()
/*		m_pxTree^.StartIterate();

		var int iCur = 0;
		repeat
			m_pxTree^.Iterate(iCur);
			if(iCur <= 1)then break; endif;
			delete m_pxTree^.GetItemData(iCur);
		until ( iCur <= 0 ) endrepeat;*/
	enddestructor;


	proc void BuildIndex()
		m_sHelpPath = CClientWrap.GetUrsRelPath()+"/Data/Base/Texts/Help/";
		var string sIndexFile=m_sHelpPath+"index.txt";
		var CPropDB xDB;
		if(!xDB.Load(sIndexFile))then KLog.LogError("CHelpMenu","Internal: index file not found!"); return; endif;
		BuildIndexRec(xDB.GetRoot(),null);
	endproc;

	proc void BuildIndexRec(ref CPropDB.CNode p_rxPDBNode,^CActionHelpPages.CIndexListData p_pxTreeItem)
		var int i,iC=p_rxPDBNode.NumSubs();
		for(i=0) cond(i<iC) iter(i++) do
			var ^CPropDB.CNode pxSub=^(p_rxPDBNode.Get(i));
			if(pxSub^.NumSubs()>0)then
				var string sName=pxSub^.Name();
				var string sText=sName;
				pxSub^.GetValue("text",sText);
				sText=CLocalizer.Get().Translate(sText);
				var ^CIndexListData pxID=^(m_axIndexItemData.NewEntryRef());
				pxID^.m_sName=sName;
				pxID^.m_sName.MakeLower();
				var int iParentID=0;
				if(p_pxTreeItem!=null)then
					iParentID=p_pxTreeItem^.m_iItemID;
				endif;
				pxSub^.GetValue("helpfile",pxID^.m_sSEMLFile);
				//pxID^.m_sSEMLFile.MakeLower();
				pxID^.m_iItemID=m_pxTree^.AddItem(iParentID,sText,pxID);

				m_pxHelpText^.Navigate(m_sHelpPath+pxID^.m_sSEMLFile);
				var CPropDB xTDB;
				m_pxHelpText^.BuildTopicTree(xTDB);
				if(xTDB.GetRoot().NumSubs()>0)then
					BuildIndexRec(pxID^.m_sSEMLFile,xTDB.GetRoot(),pxID);
				endif;

				BuildIndexRec(pxSub^,pxID);
			endif;
		endfor;
	endproc;

	proc void BuildIndexRec(string p_sBaseFile,ref CPropDB.CNode p_rxPDBNode,^CActionHelpPages.CIndexListData p_pxTreeItem)
		var string sName=p_rxPDBNode.Name();
		var string sTopic=+p_rxPDBNode.Value();
		if(sName!="Root")then
			sName.TrimRight();
			var int iParentID=p_pxTreeItem^.m_iItemID;
			var ^CIndexListData pxID=^(m_axIndexItemData.NewEntryRef());
			pxID^.m_sName=sTopic;
			pxID^.m_sName.MakeLower();
			pxID^.m_sSEMLFile=p_sBaseFile+"#"+sTopic;
			pxID^.m_sSEMLFile.MakeLower();
			//KLog.LogWarn("CHP","N:"+pxID^.m_sName+",S:"+pxID^.m_sSEMLFile);
			pxID^.m_iItemID=m_pxTree^.AddItem(iParentID,sName,pxID);
			p_pxTreeItem=pxID;
		endif;
		var int i,iC=p_rxPDBNode.NumSubs();
		for(i=0) cond(i<iC) iter(i++) do
			BuildIndexRec(p_sBaseFile,p_rxPDBNode.Get(i),p_pxTreeItem);
		endfor;
	endproc;

	proc bool OnIndexSelected()
		var int iSel = m_pxTree^.GetSelectedItem();
		if(iSel <= 0)then return false; endif;

		var ^CIndexListData pxI = cast<CIndexListData>(m_pxTree^.GetItemData(iSel));
		if(pxI!=null)then
			m_pxHelpText^.Navigate(m_sHelpPath+pxI^.m_sSEMLFile);
		endif;
		return true;
	endproc;

	export proc void OnInit(ref CAttribs p_rxParams)
		m_pxOwner^.SetText(p_rxParams.GetValue("player"));

		var string sUrl = p_rxParams.GetValue("semlurl");

		m_pxTree^.StartIterate();
		var int iCur = 0;
		repeat
			m_pxTree^.Iterate(iCur);
			if(iCur <= 1)then break; endif;
			var ^CIndexListData pxID = cast<CIndexListData>(m_pxTree^.GetItemData(iCur));
			if(pxID!=null)then
				if(pxID^.m_sSEMLFile == sUrl)then
					m_pxTree^.Select(iCur);
					m_pxTree^.EnsureVisible(iCur);
					break;
				endif;
			endif;
		until ( iCur <= 0 ) endrepeat;
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		var int iOwner=-1;
		var string sOwner = m_pxOwner^.GetSelectedItemAsString();
		if(sOwner!="All")then iOwner = sOwner.ToInt(); endif;

		var string sURL;
		var int iSel = m_pxTree^.GetSelectedItem();
		if(iSel>0)then
			var ^CIndexListData pxID = cast<CIndexListData>(m_pxTree^.GetItemData(iSel));
			if(pxID!=null)then
				sURL = pxID^.m_sSEMLFile;
			endif;
		endif;

		po_rxParams.SetValue("player", iOwner);
		po_rxParams.SetValue("semlurl", sURL);
	endproc;
endclass;

class CActionSoundPages inherit CActionPages

	var ^CTreeCtrl				m_pxTree;
	var array ^CRadioButton		m_apxSoundType;
	var ^CDropList				m_pxOwner;
	var ^CEdit					m_pxPosition;
	var ^CCheckBox				m_pxChkPos;

	var array CActionSoundPages.CFileItemData		m_axItemData;

	class CFileItemData inherit CItemData
		export var string m_sFullPath;
		export var bool m_bDir;
	endclass;

	export constructor(CGuid p_xGuid)
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_PSND");

		m_pxTree = cast<CTreeCtrl>(m_apxPages[0]^.GetControl("Tree_Sounds"));
		m_pxOwner = cast<CDropList>(m_apxPages[0]^.GetControl("GBox_Settings/Drop_Player"));
		m_apxSoundType = 3;
		m_apxSoundType[0] = cast<CRadioButton>(m_apxPages[0]^.GetControl("GBox_Settings/Radio_SoundType3D"));
		m_apxSoundType[1] = cast<CRadioButton>(m_apxPages[0]^.GetControl("GBox_Settings/Radio_SoundTypeFake3D"));
		m_apxSoundType[2] = cast<CRadioButton>(m_apxPages[0]^.GetControl("GBox_Settings/Radio_SoundTypeGlobal"));
		m_pxChkPos = cast<CCheckBox>(m_apxPages[0]^.GetControl("GBox_Settings/Chk_Position"));
		m_pxPosition = cast<CEdit>(m_apxPages[0]^.GetControl("GBox_Settings/Edit_Position"));

		m_apxSoundType[2]^.SetSelected(true);

		FillSoundList();
		m_pxOwner^.AddItem("All");
		var int i, iC = 8;
		for(i=0)cond(i<iC)iter(++i) do m_pxOwner^.AddItem(i.ToString()); endfor;

		m_pxChkPos^.m_xOnStateChange = OnChkPositional;
	endconstructor;

	export destructor()
		CMainController.Get().RemoveClickProcRef(SetPos);
	enddestructor;

	export proc void OnInit(ref CAttribs p_rxParams)
		var int iType = p_rxParams.GetValueInt("soundtype");
		var string sSound = p_rxParams.GetValue("soundname");
		var int iPlayer = p_rxParams.GetValueInt("player");
		var string sPosition = p_rxParams.GetValue("position");

		m_pxOwner^.Select(iPlayer+1);
		if(sPosition.IsEmpty())then
			m_pxChkPos^.SetChecked(0);
		else
			m_pxChkPos^.SetChecked(1);
		endif;

		m_pxPosition^.SetText(sPosition);
		m_apxSoundType[iType-1]^.SetSelected(true);

		var int iItem = m_pxTree^.FindItem(0, sSound);
		if(iItem>0)then
			m_pxTree^.Select(iItem);
			m_pxTree^.EnsureVisible(iItem);
		endif;
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		var int iSel = m_pxTree^.GetSelectedItem();
		if(iSel>0)then
			po_rxParams.SetValue("soundname", m_pxTree^.GetItemText(iSel));
		endif;
		po_rxParams.SetValue("player", m_pxOwner^.GetSelectedItem()-1);

		var int iType = 0;
		if(m_apxSoundType[0]^.GetSelected())then
			iType=1;
		elseif(m_apxSoundType[1]^.GetSelected())then
			iType=2;
		elseif(m_apxSoundType[2]^.GetSelected())then
			iType=3;
		endif;
		po_rxParams.SetValue("soundtype", iType);
		var string sPos = m_pxPosition^.GetText();
		if(!m_pxChkPos^.GetCheckMark())then
			sPos="";
		endif;
		po_rxParams.SetValue("position", sPos);
	endproc;

	proc void FillSoundList()
		var string sBase = CLevelEditorWrap.GetUrsRelPath()+"/Data/Base/Scripts/Server/Init/";
		var int iRoot = m_pxTree^.AddItem(0, "SoundEvents");

		var CPropDB xDB;
		if(xDB.Load(sBase+"soundevents.txt"))then
			var ^CPropDB.CNode pxRoot = ^(xDB.GetRoot());
			var int i, iC=pxRoot^.NumSubs();
			for(i=0) cond(i<iC) iter(++i) do
				var ^CPropDB.CNode pxSub = ^(pxRoot^.Get(i));
				var CPropDB xSubDB;
				if(xSubDB.Load(sBase+pxSub^.Value()))then
					LoadSoundEvents(^(xSubDB.GetRoot()), m_pxTree^.AddItem(iRoot, pxSub^.Name()));
				endif;
			endfor;
		endif;
	endproc;

	proc void LoadSoundEvents(^CPropDB.CNode p_pxRoot, int p_iItem)
		var int i, iC = p_pxRoot^.NumSubs();
		for(i=0) cond(i<iC) iter(++i) do
			var ^CPropDB.CNode pxNode = ^(p_pxRoot^.Get(i));
			if(pxNode^.Name()=="soundpath")then continue; endif;
			m_pxTree^.AddItem(p_iItem, pxNode^.Name());
		endfor;
	endproc;
	/*
	proc void FillSoundList()
		var string sBase = CLevelEditorWrap.GetUrsRelPath()+"/Data/Base/Audio/Sound";
		var int iBaseLen = 0;
		sBase.Replace('\\', '/');
		var Filesystem.CFileList xFiles;
		var int i, iC = xFiles.ReadListEx(sBase, "*.*", true, true);
		sBase+="/";
		iBaseLen=sBase.GetLength();

		for(i=0) cond(i<iC) iter(++i) do
			var string sFile = xFiles[i].m_sName;
			KLog.LogSpam("MaZi", "Current: " + sFile );
			if(sFile.Find(sBase)>=0)then
				sFile.Delete(0,iBaseLen);

				var array string asToks;
				sFile.Split(asToks, "/", true);

				var int iCurItem=0;
				var int j, iJC = asToks.NumEntries();
				for(j=0) cond(j<iJC) iter(++j) do
					var int iItem = m_pxTree^.FindItem(iCurItem, asToks[j]);
					if(iItem<=0)then
						var ^CFileItemData pxID = ^(m_axItemData.NewEntryRef());
						pxID^.m_sFullPath = xFiles[i].m_sName;
						pxID^.m_bDir=true;
						if(j==asToks.NumEntries()-1)then
							pxID^.m_bDir=false;
						endif;
						iItem = m_pxTree^.AddItem(iCurItem, asToks[j], pxID);
					endif;
					iCurItem=iItem;
				endfor;
			endif;
		endfor;
	endproc;
	*/
	proc bool OnChkPositional()
		if(m_pxChkPos^.GetCheckMark())then
			m_apxSoundType[0]^.SetDisabled(false);
			m_apxSoundType[1]^.SetDisabled(false);
			m_pxPosition^.SetDisabled(false);
			CMainController.Get().AddClickProcRef(SetPos);
		else
			m_apxSoundType[0]^.SetDisabled(true);
			m_apxSoundType[1]^.SetDisabled(true);
			m_pxPosition^.SetDisabled(true);
			m_apxSoundType[2]^.SetSelected(true);
			CMainController.Get().RemoveClickProcRef(SetPos);
		endif;
		return true;
	endproc;

	proc bool SetPos()
		var vec3 vPos = CClientWrap.GetScapeMgr().GetPickPoint();
		var string sTmp = vPos.ToString();
		sTmp.TrimLeft("[");	sTmp.TrimRight("]");
		m_pxPosition^.SetText(sTmp);
		return true;
	endproc;
endclass;

class CActionDelObjPages inherit CActionPages

	var ^CActionObjSelector m_pxObjSel;
	var ^CSpinCtrlNumber	m_pxMaxObjs;

	export constructor(CGuid p_xGuid)
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_DELO");

		m_pxObjSel = cast<CActionObjSelector>(m_apxPages[0]^.GetControl("ObjSel"));
		m_pxMaxObjs = cast<CSpinCtrlNumber>(m_apxPages[0]^.GetControl("maxobjs"));
	endconstructor;

	export proc void OnInit(ref CAttribs p_rxParams)
		m_pxObjSel^.OnInit(p_rxParams);
		m_pxMaxObjs^.SetValue(p_rxParams.GetValueInt("maxobjs"));
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		m_pxObjSel^.OnFinish(po_rxParams);
		po_rxParams.SetValue("maxobjs",m_pxMaxObjs^.GetValueInt());
	endproc;
endclass;

class CActionReplaceObjPages inherit CActionPages

	var ^CActionObjSelector m_pxObjSel;
	var ^CObjectTreeCtrl m_pxTree;
	var ^CSpinCtrlNumber m_pxLevel;
	
	export constructor(CGuid p_xGuid)
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_REPL");
		
		m_pxObjSel = cast<CActionObjSelector>(m_apxPages[0]^.GetControl("ObjSelector"));
		m_pxTree = cast<CObjectTreeCtrl>(m_apxPages[0]^.GetControl("Tree_Objects"));
		m_pxLevel = cast<CSpinCtrlNumber>(m_apxPages[0]^.GetControl("Spin_Level"));
		m_pxTree^.FillTree(CObjectTreeCtrl.SHOW_ALL);
		m_pxTree^.m_xOnSelect = OnSelect;
	endconstructor;

	export proc void OnInit(ref CAttribs p_rxParams)
	
		m_pxObjSel^.OnInit(p_rxParams);
		m_pxTree^.OnInit(p_rxParams.GetValue("new_obj"));
		m_pxLevel^.SetValue(p_rxParams.GetValueInt("obj_level")+1);
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		m_pxObjSel^.OnFinish(po_rxParams);
		po_rxParams.SetValue("new_obj", m_pxTree^.GetSelectedItemAsString());
		po_rxParams.SetValue("obj_level", m_pxLevel^.GetValueInt()-1);

		//m_asTmpClassParents.FindEntry(p_pxWalk^.m_pxParent^.m_sName)
		
	endproc;

	proc bool OnSelect()
		var ^CObjectTreeCtrl.CObjectItem pxItemData =cast <CObjectTreeCtrl.CObjectItem>( m_pxTree^.GetItemData(m_pxTree^.GetSelectedItem()));
		if(pxItemData!=null)then
			var ^CTechTree.CNode pxTechTreeNode = pxItemData^.m_pxNode;
			var int iObjTTLvl= pxTechTreeNode^.GetSubValueI("captainlevel");
//			m_pxLevel^.SetLimits(iObjTTLvl,5,1);
			m_pxLevel^.SetLimits(1,5,1);
			m_pxLevel^.SetValue(iObjTTLvl);
		endif;
		return true;
	endproc;
endclass;

class CActionSetTimePages inherit CActionPages

	var ^CEdit	m_pxTime;

	export constructor(CGuid p_xGuid)
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_VTME");
		m_pxTime = cast<CEdit>(m_apxPages[0]^.GetControl("Edit_Time"));
	endconstructor;

	export proc void OnInit(ref CAttribs p_rxParams)
		m_pxTime^.SetText(p_rxParams.GetValue("time"));
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		po_rxParams.SetValue("time", m_pxTime^.GetText());
	endproc;
endclass;


class CActionSpawnGroupPages inherit CActionPages

	class CGroupItem inherit CItemData
		export var CClntHndl m_xGroupHndl;
	endclass;

	var array CGroupItem	m_axItems;

	var ^CEdit				m_pxPos;
	var ^CList 				m_pxUnits;
	var ^CObjectTreeCtrl 	m_pxObjs;
	var ^CButton			m_pxAdd, m_pxRem;
	var ^CSpinCtrlNumber	m_pxOwner, m_pxLevel;
	var ^CDropList			m_pxGroup;
	var ^CCheckBox			m_pxCheckPyramid;
	var ^CCheckBox			m_pxUseSpawnObj;
	var ^CSpinCtrlNumber	m_pxSpawnDelay;
	var ^CActionObjSelector m_pxSpawnObjSel;
	var ^CList				m_pxBuildUps;

	export constructor(CGuid p_xGuid)
		CMainController.Get().AddClickProcRef(SetPos);
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_SPGR");

		m_pxUnits = cast<CList>(m_apxPages[0]^.GetControl("List_Units"));
		m_pxObjs = cast<CObjectTreeCtrl>(m_apxPages[0]^.GetControl("ObjTree"));
		m_pxAdd = cast<CButton>(m_apxPages[0]^.GetControl("Btn_Add"));
		m_pxRem = cast<CButton>(m_apxPages[0]^.GetControl("Btn_Rem"));
		m_pxOwner = cast<CSpinCtrlNumber>(m_apxPages[0]^.GetControl("Spin_Owner"));
		m_pxLevel = cast<CSpinCtrlNumber>(m_apxPages[0]^.GetControl("Spin_Level"));
		m_pxPos = cast<CEdit>(m_apxPages[0]^.GetControl("Edit_Pos"));
		m_pxGroup = cast<CDropList>(m_apxPages[0]^.GetControl("Drop_Group"));
		m_pxCheckPyramid = cast<CCheckBox>(m_apxPages[0]^.GetControl("Check_Pyramid"));
		m_pxUseSpawnObj = cast<CCheckBox>(m_apxPages[0]^.GetControl("Chk_SpawnObj"));
		m_pxSpawnDelay = cast<CSpinCtrlNumber>(m_apxPages[0]^.GetControl("Spin_SpawnDelay"));
		m_pxSpawnObjSel = cast<CActionObjSelector>(m_apxPages[0]^.GetControl("SpawnObjSel"));
		m_pxBuildUps	= cast<CList>(m_apxPages[0]^.GetControl("List_BuildUps"));

		m_pxSpawnObjSel^.SetDisabled(true);
		m_pxSpawnDelay^.SetDisabled(true);
		
		m_pxUseSpawnObj^.m_xOnStateChange = OnUseSpawnObj;

		m_pxObjs^.FillTree(CObjectTreeCtrl.SHOW_ALL &~ CObjectTreeCtrl.SHOW_REST);
		m_pxAdd^.m_xOnClick = OnAdd;
		m_pxRem^.m_xOnClick = OnRem;
		m_pxObjs^.m_xOnLBtnDblClick = OnAdd;
		m_pxUnits^.m_xOnLBtnDblClick = OnRem;
		FillGroupList();
		m_pxObjs^.m_xOnSelect = OnSelect;
	endconstructor;

	export destructor()
		CMainController.Get().RemoveClickProcRef(SetPos);
	enddestructor;
	
	proc bool OnUseSpawnObj()
		if(m_pxUseSpawnObj^.GetChecked()==1)then
			m_pxSpawnObjSel^.SetDisabled(false);
			m_pxSpawnDelay^.SetDisabled(false);
		else
			m_pxSpawnObjSel^.SetDisabled(true);
			m_pxSpawnDelay^.SetDisabled(true);
		endif;
		return true;
	endproc;

	proc bool OnSelect()
		var ^CObjectTreeCtrl.CObjectItem pxItemData =cast <CObjectTreeCtrl.CObjectItem>( m_pxObjs^.GetItemData(m_pxObjs^.GetSelectedItem()));
		if(pxItemData == null)then return true; endif;
		var ^CTechTree.CNode pxTechTreeNode = pxItemData^.m_pxNode;
		var int iObjTTLvl= pxTechTreeNode^.GetSubValueI("captainlevel");
//		m_pxLevel^.SetLimits(iObjTTLvl,5,1);
		m_pxLevel^.SetLimits(1,5,1);
		m_pxLevel^.SetValue(iObjTTLvl);
		
		m_pxBuildUps^.Clear();
		var ^CTechTreeMgr pxTTMgr=^(CLevelEditorWrap.GetClient().GetTechTreeMgr());
		var int i,iC=pxTTMgr^.NumEntries();
		var string sAnimal = m_pxObjs^.GetSelectedItemAsString();
		if(sAnimal!="")then
			for(i=0)cond(i<iC)iter(i++)do
				var string sPath=pxTTMgr^.GetFilterPath(i);
				if(sPath.Find("Upgrades/"+sAnimal) >= 0 && sPath.Find("_Remove") < 0  && sPath.Find("_Bonus") < 0 && sPath.Find("_capacity_") < 0 && sPath.Find("age_") < 0 && sPath.Find("_upgrade_") < 0  && sPath.Find("Lvl4_tt") < 0 && sPath.Find("Lvl5_tt") < 0 && sPath.Find("RangeEffect") < 0 && sPath.Find("_defensive_mode") < 0 && sPath.Find("pirate_captain") < 0)then
					var string sP = sPath;
					var int iP = sP.FindRev('/');
					sP.Delete(0,iP+1);
					if(m_pxBuildUps^.FindItem(sP)<0)then
						m_pxBuildUps^.AddItem(sP);
					endif;
				endif;
			endfor;
		endif;
		return true;
	endproc;

	proc bool OnAdd()
		var string sName;
		if(m_pxBuildUps^.NumItems()==0)then 
			sName = m_pxObjs^.GetSelectedItemAsString();
		else
			sName = m_pxObjs^.GetSelectedItemAsString()+""+m_pxBuildUps^.GetSelectedItemAsString();
		endif;
		if(!sName.IsEmpty())then
			var int i, iC = m_pxUnits^.NumItems();
			for(i=0) cond(i<iC) iter(++i) do
				var string sItem = m_pxUnits^.GetItem(i);
				var array string asToks;
				sItem.Split(asToks, " ", true);
				if(sItem.Find(sName) >=0)then
					if(asToks[1].ToInt()==m_pxLevel^.GetValueInt())then
						var int iI = asToks[2].ToInt();
						asToks[2] = (++iI).ToString();
						m_pxUnits^.SetItemText(i, sName+" "+asToks[1]+" "+asToks[2]);
						return true;
					endif;
				endif;
			endfor;
			m_pxUnits^.AddItem(sName+" "+m_pxLevel^.GetValueInt().ToString()+" 1");
		endif;
		return false;
	endproc;

	proc bool OnRem()
		var int iSel = m_pxUnits^.GetSelectedItem();
		if(iSel>=0)then
			var string sItem = m_pxUnits^.GetItem(iSel);
			var array string asToks;
			sItem.Split(asToks, " ", true);
			var int iCnt = asToks[2].ToInt();
			if(--iCnt<=0)then
				m_pxUnits^.DeleteItem(iSel);
			else
				m_pxUnits^.SetItemText(iSel, asToks[0]+" "+asToks[1]+" "+iCnt.ToString());
			endif;
			return true;
		endif;
		return false;
	endproc;
	
	export proc void OnInit(ref CAttribs p_rxParams)
		var CGuid xG;
		xG.FromString(p_rxParams.GetValue("group"));
		var ^CObj pxGroup = CLevelEditorWrap.GetObjMgr().GetObj(xG);
		if(pxGroup!=null)then
			m_pxGroup^.SetText(pxGroup^.GetName());
		endif;
		m_pxOwner^.SetValue(p_rxParams.GetValueInt("owner"));
		m_pxPos^.SetText(p_rxParams.GetValue("pos"));
		var int iState = 0;
		if(p_rxParams.GetValueBool("checkpyramid"))then
			iState = 1;
		endif;
		m_pxCheckPyramid^.SetChecked(iState);
		var int i, iC = p_rxParams.GetValueInt("num_stages");
		for(i=0) cond(i<iC) iter(++i) do
			var string sStage = p_rxParams.GetValue("classes_"+i.ToString());
			KLog.LogSpam("MaZi", i.ToString()+":   "+sStage);
			if(sStage.IsEmpty())then break; endif;

			var array string asToks;
			sStage.Split(asToks, "|", true);

			var int j, iJC = asToks.NumEntries();
			for(j=0) cond(j<iJC) iter(++j) do
				if(!asToks[j].IsEmpty())then
					m_pxUnits^.AddItem(asToks[j]);
				endif;
			endfor;
		endfor;
		
		m_pxUseSpawnObj^.SetChecked(p_rxParams.GetValueInt("use_spawn_obj"));
		m_pxSpawnDelay^.SetValue(p_rxParams.GetValueInt("spawn_delay"));
		m_pxSpawnObjSel^.OnInit(p_rxParams);
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		var int iGrSel = m_pxGroup^.GetSelectedItem();
		if(iGrSel>=0)then
			var ^CGroupItem pxGI = cast<CGroupItem>(m_pxGroup^.GetItemData(iGrSel));
			if(pxGI!=null)then
				var CClntHndl xHndl = pxGI^.m_xGroupHndl;
				if(xHndl.IsValid())then
					var ^CObj pxO = xHndl.GetObj();
					if(pxO!=null)then
						po_rxParams.SetValue("group", pxO^.GetGuid().ToString());
					endif;
				endif;
			endif;
		endif;

		po_rxParams.SetValue("owner", m_pxOwner^.GetValueInt());
		po_rxParams.SetValue("pos", m_pxPos^.GetText());
		po_rxParams.SetValue("checkpyramid", m_pxCheckPyramid^.GetCheckMark());
		
		var int iNumStages = po_rxParams.GetValueInt("num_stages");

		var int iStage=0;
		var string sStage;
		var int i,iC=m_pxUnits^.NumItems();
		for(i=0) cond(i<iC) iter(++i) do
			var string sCur = m_pxUnits^.GetItem(i);
			if(!sCur.IsEmpty())then
				if((sStage.GetLength()+sCur.GetLength()+1)>255)then
					po_rxParams.SetValue("classes_"+iStage++.ToString(), sStage);
					sStage="";
					if(iStage>=iNumStages)then
						KLog.LogError("MaZi", "Maximal count of groupable units reached. Ignoring ...");
						break;
					endif;
				endif;
				sStage+=sCur+"|";
			endif;
		endfor;

		if(!sStage.IsEmpty())then
			po_rxParams.SetValue("classes_"+iStage++.ToString(), sStage);
			sStage="";
		endif;

		iC=iNumStages;
		for(i=iStage) cond(i<iC) iter(++i) do
			po_rxParams.SetValue("classes_"+iStage.ToString(), sStage);
		endfor;
		
		var int iUse = m_pxUseSpawnObj^.GetChecked();
		po_rxParams.SetValue("use_spawn_obj", iUse);
		
		po_rxParams.SetValue("spawn_delay", m_pxSpawnDelay^.GetValueInt());
		m_pxSpawnObjSel^.OnFinish(po_rxParams);
	endproc;

	proc bool SetPos()
		var vec3 vPos = CClientWrap.GetScapeMgr().GetPickPoint();
		var string sTmp = vPos.ToString();
		sTmp.TrimLeft("[");	sTmp.TrimRight("]");
		m_pxPos^.SetText(sTmp);
		return true;
	endproc;

	proc void FillGroupList()
		var CObjQueryCln xQ;
		xQ.SetType("GROU");
		var CObjList xL;
		xQ.Execute(xL);

		var int i, iC=xL.NumEntries();
		for(i=0) cond(i<iC) iter(++i) do
			var ^CObj pxO = xL[i].GetObj();
			if(pxO!=null)then
				var ^CGroupItem pxGI = ^(m_axItems.NewEntryRef());
				pxGI^.m_xGroupHndl = xL[i];
				m_pxGroup^.AddItem(pxO^.GetName(), pxGI);
			endif;
		endfor;
	endproc;
endclass;



/**
	class CActionAiFightPages
*/
class CActionAiFightPages inherit CActionPages

	var ^CCheckBox 			m_pxTargetObj;
	var ^CActionObjSelector m_pxObjSel;
	var ^CSpinCtrlNumber	m_pxPlayer;
	var ^CCheckBox			m_pxAttackWithAll, m_pxAttackOnTheWay, m_pxKill, m_pxShip, m_pxShipLand, m_pxIgnoreLocations;
	var ^CDropList			m_pxAttackType;
	var ^CDropList			m_pxAttackBehavior;
	var ^CEdit				m_pxPosition;
	var ^CEdit				m_pxSpawnPosition;
	var bool 				m_bBlah;

	///constructor
	export constructor(CGuid p_xGuid)
		CMainController.Get().AddClickProcRef(SetPos);
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_AIFT");
		m_pxObjSel = cast<CActionObjSelector>(m_apxPages[0]^.GetControl("Obj_Selection"));
		m_pxPlayer= cast<CSpinCtrlNumber>(m_apxPages[0]^.GetControl("Player_Spin"));
		
		m_pxAttackType=cast<CDropList>(m_apxPages[0]^.GetControl("Attack_Type"));
		m_pxAttackBehavior=cast<CDropList>(m_apxPages[0]^.GetControl("Attack_Behavior"));
		m_pxPosition=cast<CEdit>(m_apxPages[0]^.GetControl("Edit_Position"));
		m_pxSpawnPosition=cast<CEdit>(m_apxPages[0]^.GetControl("Spawn_Position"));
		m_pxAttackWithAll=cast<CCheckBox>(m_apxPages[0]^.GetControl("Attack_With_All"));
		m_pxIgnoreLocations=cast<CCheckBox>(m_apxPages[0]^.GetControl("Ignore_Locations"));
		m_pxAttackOnTheWay=cast<CCheckBox>(m_apxPages[0]^.GetControl("Attack_On_The_Way"));
		m_pxTargetObj= cast<CCheckBox>(m_apxPages[0]^.GetControl("Check_ObjOnly"));
		m_pxShip= cast<CCheckBox>(m_apxPages[0]^.GetControl("Attack_With_Ships"));
		m_pxShipLand= cast<CCheckBox>(m_apxPages[0]^.GetControl("Attack_With_Ships_And_Land"));
		
		m_pxPlayer^.m_xOnChange = OnUpdateAttackTypes;
		m_pxShip^.m_xOnStateChange = OnShip;
		m_pxShipLand^.m_xOnStateChange = OnShipLand;
		m_pxAttackBehavior^.m_xOnChange=OnChangeBehaviorType;
		
		// set up Player spin control
		var ^CLevelInfo pxLevelInfo=^(CLevelEditorWrap.GetClient().GetLevelInfo());
		var ^CPropDB pxLI = ^(pxLevelInfo^.GetGenericData());
		var ^CPropDB.CNode pxBaseNode=^((pxLI^)["Base"]);
		var int iMaxPlayer=pxBaseNode^.GetValueI("MaxPlayers");
		if(iMaxPlayer==0)then iMaxPlayer=1; endif;
		
		m_pxPlayer^.SetLimits(0, iMaxPlayer-1, 1);		
		m_pxObjSel^.Init(p_xGuid);
		
		var array string asBehavior;
		asBehavior=13;
		asBehavior[0]="Dodo";
		asBehavior[1]="DodoEasy";
		asBehavior[2]="DodoMedium";
		asBehavior[3]="DodoHard";
		asBehavior[4]="Giraffe";
		asBehavior[5]="GiraffeEasy";
		asBehavior[6]="GiraffeMedium";
		asBehavior[7]="GiraffeHard";
		asBehavior[8]="Schnecke";
		asBehavior[9]="SchneckeEasy";
		asBehavior[10]="SchneckeMedium";
		asBehavior[11]="SchneckeHard";
		asBehavior[12]="Singleplayer";			
			
		FillAttackBehavior(asBehavior);
		OnUpdateAttackTypes();
	
		m_bBlah=true;
	endconstructor;
	
	
	export destructor()
		CMainController.Get().RemoveClickProcRef(SetPos);
	enddestructor;
	
	proc bool OnChangeBehaviorType()
		OnUpdateAttackTypes();
		return true;
	endproc;
	
	proc bool OnShip()
		if(m_pxShip^.GetCheckMark() == true)then
			m_pxShipLand^.SetChecked(0);
			m_pxShipLand^.SetDisabled(true);
		else
			m_pxShipLand^.SetDisabled(false);
		endif;
		return true;
	endproc;
	
	proc bool OnShipLand()
		if(m_pxShipLand^.GetCheckMark() == true)then
			m_pxShip^.SetChecked(0);
			m_pxShip^.SetDisabled(true);
		else
			m_pxShip^.SetDisabled(false);
		endif;
		return true;
	endproc;
	
	proc void FillAttackBehavior(array string p_asBehavior)
		var int i;
		var int iC = p_asBehavior.NumEntries();		
		for(i = 0)cond(i < iC)iter(i++)do
			m_pxAttackBehavior^.AddItem(p_asBehavior[i]);
		endfor;
	endproc;
		
	proc bool SetPos()
		var vec3 vPos = CClientWrap.GetScapeMgr().GetPickPoint();
		var string sTmp = vPos.ToString();
		sTmp.TrimLeft("[");	sTmp.TrimRight("]");
		
		if(m_bBlah==true)then
			m_pxPosition^.SetText(sTmp);
			m_bBlah=false;
		elseif(m_bBlah==false)then
			m_pxSpawnPosition^.SetText(sTmp);
			m_bBlah=true;
		endif;
			
		return true;
	endproc;
	
	proc bool OnUpdateAttackTypes()
		var int		iPlayer = m_pxPlayer^.GetValueInt();
		var string	sAttackBehavior = m_pxAttackBehavior^.GetText();
		var string	sTribe;
		var string	sTribes;
		var array string	asTribes;
		
		var ^CLevelInfo pxLevelInfo = ^(CLevelEditorWrap.GetClient().GetLevelInfo());
		var ^CPropDB pxDB = ^(pxLevelInfo^.GetGenericData());
		var ^CPropDB.CNode pxBaseNode = ^((pxDB^)["PlayerSettings/Player_" + iPlayer.ToString() + "/Restrictions/Base"]);

		pxBaseNode^.GetValue("Tribes", sTribes);
		sTribes.Split(asTribes, ":", true);
		if(asTribes.NumEntries() > 0)then //take first Tribe of playerslot
			sTribe = asTribes[0];
		endif;
		
		var CPropDB	xDB;
		var string	sPropDBPath = CClientWrap.GetUrsRelPath() + "/Data/Base/Scripts/Ai/settings/" + sTribe + "/" + sAttackBehavior + ".txt";
		if(xDB.Load(sPropDBPath))then
			var ^CPropDB.CNode pxRoot = ^(xDB.GetRoot());
			if(pxRoot!=null)then
				var int i;
				var int iC = pxRoot^.NumSubs();				
				m_pxAttackType^.Clear();
				for(i = 0)cond(i < iC)iter(i++)do
					var string sItem = pxRoot^.Get(i).Name();					
					m_pxAttackType^.AddItem(sItem);
				endfor;
				m_pxAttackType^.AddItem("PyramidAttack");
			endif;
		endif;
		
		return true;
	endproc;
	

	///OnInit
	export proc void OnInit(ref CAttribs p_rxParams)
		m_pxObjSel^.OnInit(p_rxParams);
		m_pxPlayer^.SetValue(p_rxParams.GetValueInt("player_id"));
		m_pxAttackBehavior^.SetText(p_rxParams.GetValue("attack_behavior"));
		m_pxPosition^.SetText(p_rxParams.GetValue("position_edit"));
		m_pxSpawnPosition^.SetText(p_rxParams.GetValue("spawn_position"));
		m_pxAttackWithAll^.SetChecked(p_rxParams.GetValueInt("attack_with_all"));
		m_pxIgnoreLocations^.SetChecked(p_rxParams.GetValueInt("ignore_locations"));
		m_pxAttackOnTheWay^.SetChecked(p_rxParams.GetValueInt("all_the_way"));
		m_pxAttackType^.SetText(p_rxParams.GetValue("attack_type"));
		m_pxTargetObj^.SetChecked(p_rxParams.GetValueInt("target_obj"));
		m_pxShip^.SetChecked(p_rxParams.GetValueInt("ship"));
		m_pxShipLand^.SetChecked(p_rxParams.GetValueInt("ship_land"));	
	endproc;


	///OnFinish
	export proc void OnFinish(ref CAttribs po_rxParams)
		//OnUpdateAttackTypes();		
		m_pxObjSel^.OnFinish(po_rxParams);
		po_rxParams.SetValue("player_id",m_pxPlayer^.GetValueInt());
		var int iA = 0;
		
		po_rxParams.SetValue("infantry", 0);
		po_rxParams.SetValue("cavalry", 0);
		po_rxParams.SetValue("machines", 0);
		po_rxParams.SetValue("ships", 0);
		po_rxParams.SetValue("shortrange", 0);
		po_rxParams.SetValue("longrange", 0);
		po_rxParams.SetValue("custom_attack", 1);
		
		iA = 0;
		if(m_pxAttackOnTheWay^.GetCheckMark())then iA = 1; endif;
		po_rxParams.SetValue("all_the_way", iA);
		iA = 0;
		if(m_pxAttackWithAll^.GetCheckMark())then iA = 1; endif;
			if(m_pxAttackType^.GetText()=="AttackOutpost"||m_pxAttackType^.GetText()=="RessourceOutpost")then
				po_rxParams.SetValue("attack_with_all", 1);
			endif;
			po_rxParams.SetValue("attack_with_all", iA);
		iA = 0;
		if(m_pxIgnoreLocations^.GetCheckMark())then iA = 1; endif;
		po_rxParams.SetValue("ignore_locations", iA);
		if(m_pxTargetObj^.GetCheckMark())then iA = 1; endif;
		po_rxParams.SetValue("target_obj", iA);
		iA = 0;
		if(m_pxShip^.GetCheckMark())then iA = 1; endif;
		po_rxParams.SetValue("ship", iA);				
		iA = 0;
		if(m_pxShipLand^.GetCheckMark())then iA = 1; endif;
		po_rxParams.SetValue("ship_land", iA);			
		
		po_rxParams.SetValue("attack_type", m_pxAttackType^.GetText());
		po_rxParams.SetValue("attack_behavior", m_pxAttackBehavior^.GetText());
		po_rxParams.SetValue("position_edit", m_pxPosition^.GetText());
		po_rxParams.SetValue("spawn_position", m_pxSpawnPosition^.GetText());
		
	endproc;

endclass;



/**
	class CActionAddToGroupPages
*/
class CActionAddToGroupPages inherit CActionPages

	class CGroupItem inherit CItemData
		export var CClntHndl m_xGroupHndl;
	endclass;

	var array CGroupItem	m_axItems;

	var ^CActionObjSelector	m_pxObjSel;
	var ^CDropList			m_pxGroups;
	var ^CCheckBox			m_pxObjDis;
	var ^CObjSelectionList	m_pxSelectionList;

	export constructor(CGuid p_xGuid)
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_ADGR");

		m_pxObjSel = cast<CActionObjSelector>(m_apxPages[0]^.GetControl("ObjSel"));
		m_pxGroups = cast<CDropList>(m_apxPages[0]^.GetControl("Drop_Groups"));

		m_pxObjDis			= cast<CCheckBox>(m_apxPages[0]^.GetControl("selector_enabled"));
		m_pxObjDis^.m_xOnStateChange = OnEnableObj;

		m_pxSelectionList	= cast<CObjSelectionList>(m_apxPages[0]^.GetControl("SelectionList"));

		FillGroupList();
		m_pxObjSel^.Init(p_xGuid);
	endconstructor;

	proc bool OnEnableObj()
		if(m_pxObjDis^.GetCheckMark())then
			m_pxObjSel^.SetDisabled(false);
			return true;
		else
			m_pxObjSel^.SetDisabled(true);
			return true;
		endif;
	endproc;

	export proc void OnInit(ref CAttribs p_rxParams)
		m_pxObjSel^.OnInit(p_rxParams);

		var CGuid xG;
		xG.FromString(p_rxParams.GetValue("group"));
		var ^CObj pxO=CLevelEditorWrap.GetObjMgr().GetObj(xG);
		if(pxO!=null)then
			m_pxGroups^.SetText(pxO^.GetName());
		endif;
		m_pxObjDis^.SetChecked(p_rxParams.GetValueInt("selector_enabled"));
		m_pxObjSel^.SetDisabled(!m_pxObjDis^.GetCheckMark());
		m_pxSelectionList^.OnInit(p_rxParams, "add_to_group_units");
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		m_pxObjSel^.OnFinish(po_rxParams);
		var int iSel = m_pxGroups^.GetSelectedItem();
		if(iSel>=0)then
			var ^CGroupItem pxGI = cast<CGroupItem>(m_pxGroups^.GetItemData(iSel));
			if(pxGI!=null)then
				var ^CObj pxO = pxGI^.m_xGroupHndl.GetObj();
				if(pxO!=null)then
					po_rxParams.SetValue("group", pxO^.GetGuid().ToString());
				endif;
			endif;
		endif;
		po_rxParams.SetValue("selector_enabled", m_pxObjDis^.GetChecked());
		m_pxSelectionList^.OnFinish(po_rxParams, "add_to_group_units");
	endproc;

	proc void FillGroupList()
		var CObjQueryCln xQ;
		xQ.SetType("GROU");
		var CObjList xL;
		xQ.Execute(xL);

		var int i, iC=xL.NumEntries();
		for(i=0) cond(i<iC) iter(++i) do
			var ^CObj pxO = xL[i].GetObj();
			if(pxO!=null)then
				var ^CGroupItem pxGI = ^(m_axItems.NewEntryRef());
				pxGI^.m_xGroupHndl = xL[i];
				m_pxGroups^.AddItem(pxO^.GetName(), pxGI);
			endif;
		endfor;
	endproc;
endclass;


/**
	class CActionRemoveFromGroupPages
*/
// By AyCe!
class CActionRemoveFromGroupPages inherit CActionPages

	class CGroupItem inherit CItemData
		export var CClntHndl m_xGroupHndl;
	endclass;

	var array CGroupItem	m_axItems;

	var ^CActionObjSelector	m_pxObjSel;
	var ^CDropList			m_pxGroups;
	var ^CCheckBox			m_pxObjDis;
	var ^CObjSelectionList	m_pxSelectionList;

	export constructor(CGuid p_xGuid)
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_RMGR");

		m_pxObjSel = cast<CActionObjSelector>(m_apxPages[0]^.GetControl("ObjSel"));
		m_pxGroups = cast<CDropList>(m_apxPages[0]^.GetControl("Drop_Groups"));

		m_pxObjDis			= cast<CCheckBox>(m_apxPages[0]^.GetControl("selector_enabled"));
		m_pxObjDis^.m_xOnStateChange = OnEnableObj;

		m_pxSelectionList	= cast<CObjSelectionList>(m_apxPages[0]^.GetControl("SelectionList"));

		FillGroupList();
		m_pxObjSel^.Init(p_xGuid);
	endconstructor;

	proc bool OnEnableObj()
		if(m_pxObjDis^.GetCheckMark())then
			m_pxObjSel^.SetDisabled(false);
			return true;
		else
			m_pxObjSel^.SetDisabled(true);
			return true;
		endif;
	endproc;

	export proc void OnInit(ref CAttribs p_rxParams)
		m_pxObjSel^.OnInit(p_rxParams);

		var CGuid xG;
		xG.FromString(p_rxParams.GetValue("group"));
		var ^CObj pxO=CLevelEditorWrap.GetObjMgr().GetObj(xG);
		if(pxO!=null)then
			m_pxGroups^.SetText(pxO^.GetName());
		endif;
		m_pxObjDis^.SetChecked(p_rxParams.GetValueInt("selector_enabled"));
		m_pxObjSel^.SetDisabled(!m_pxObjDis^.GetCheckMark());
		m_pxSelectionList^.OnInit(p_rxParams, "remove_from_group_units");
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		m_pxObjSel^.OnFinish(po_rxParams);
		var int iSel = m_pxGroups^.GetSelectedItem();
		if(iSel>=0)then
			var ^CGroupItem pxGI = cast<CGroupItem>(m_pxGroups^.GetItemData(iSel));
			if(pxGI!=null)then
				var ^CObj pxO = pxGI^.m_xGroupHndl.GetObj();
				if(pxO!=null)then
					po_rxParams.SetValue("group", pxO^.GetGuid().ToString());
				endif;
			endif;
		endif;
		po_rxParams.SetValue("selector_enabled", m_pxObjDis^.GetChecked());
		m_pxSelectionList^.OnFinish(po_rxParams, "remove_from_group_units");
	endproc;

	proc void FillGroupList()
		var CObjQueryCln xQ;
		xQ.SetType("GROU");
		var CObjList xL;
		xQ.Execute(xL);

		var int i, iC=xL.NumEntries();
		for(i=0) cond(i<iC) iter(++i) do
			var ^CObj pxO = xL[i].GetObj();
			if(pxO!=null)then
				var ^CGroupItem pxGI = ^(m_axItems.NewEntryRef());
				pxGI^.m_xGroupHndl = xL[i];
				m_pxGroups^.AddItem(pxO^.GetName(), pxGI);
			endif;
		endfor;
	endproc;
endclass;

class CActionTransportMountingPages inherit CActionPages

	var ^CRadioButton				m_pxMount, m_pxUnmount;
	var ^CActionObjSelector	m_pxObjects, m_pxSubjects;
	var ^CCheckBox					m_pxObjectsDis, m_pxSubjectsDis;

	var ^CObjSelectionList		m_pxSelectionListObject, m_pxSelectionListSubject;

	
	export constructor(CGuid p_xGuid)
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_TRSP");

		m_pxMount = cast<CRadioButton>(m_apxPages[0]^.GetControl("Radio_Mount"));
		m_pxUnmount = cast<CRadioButton>(m_apxPages[0]^.GetControl("Radio_Unmount"));
		m_pxObjects = cast<CActionObjSelector>(m_apxPages[0]^.GetControl("Objects"));
		m_pxSubjects = cast<CActionObjSelector>(m_apxPages[0]^.GetControl("Subjects"));
		m_pxObjectsDis = cast<CCheckBox>(m_apxPages[0]^.GetControl("Object_Disabled"));
		m_pxSubjectsDis = cast<CCheckBox>(m_apxPages[0]^.GetControl("Subject_Disabled"));
		m_pxObjectsDis^.SetChecked(1);
		m_pxSubjectsDis^.SetChecked(1);
		m_pxSelectionListObject = cast<CObjSelectionList>(m_apxPages[0]^.GetControl("SelectionListObject"));
		m_pxSelectionListSubject = cast<CObjSelectionList>(m_apxPages[0]^.GetControl("SelectionListSubject"));

		m_pxMount^.m_xOnChange = OnChangeMount;
		m_pxObjectsDis^.m_xOnStateChange = OnEnableObj;
		m_pxSubjectsDis^.m_xOnStateChange = OnEnableSub;

		m_pxMount^.SetSelected(true);
		m_pxObjects^.Init(p_xGuid);
		m_pxSubjects^.Init(p_xGuid, "sub_");
	endconstructor;

	proc bool OnEnableObj()
		if(m_pxObjectsDis^.GetCheckMark())then
			m_pxObjects^.SetDisabled(false);
			return true;
		else
			m_pxObjects^.SetDisabled(true);
			return true;
		endif;
	endproc;

	proc bool OnEnableSub()
		if(m_pxSubjectsDis^.GetCheckMark())then
			m_pxSubjects^.SetDisabled(false);
			return true;
		else
			m_pxSubjects^.SetDisabled(true);
			return true;
		endif;
	endproc;

	proc bool OnChangeMount()
		if(m_pxMount^.GetSelected())then
			m_pxSubjects^.SetDisabled(false);
		else
			m_pxSubjects^.SetDisabled(true);
		endif;
		return true;
	endproc;

	export proc void OnInit(ref CAttribs p_rxParams)
		m_pxObjects^.OnInit(p_rxParams);
		m_pxSubjects^.OnInit(p_rxParams);

		m_pxObjectsDis^.SetChecked(p_rxParams.GetValueInt("enable_objsel"));
		m_pxSubjectsDis^.SetChecked(p_rxParams.GetValueInt("enable_subsel"));

		m_pxObjects^.SetDisabled(p_rxParams.GetValueInt("enable_objsel")!=1);
		m_pxSubjects^.SetDisabled(p_rxParams.GetValueInt("enable_subsel")!=1);

		m_pxSelectionListObject^.OnInit(p_rxParams, "objects_units");
		m_pxSelectionListSubject^.OnInit(p_rxParams, "subjects_units");
		
		if(p_rxParams.GetValueInt("mount")==1)then
			m_pxMount^.SetSelected(true);
		else
			m_pxUnmount^.SetSelected(true);
		endif;
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		m_pxObjects^.OnFinish(po_rxParams);
		m_pxSubjects^.OnFinish(po_rxParams);
		po_rxParams.SetValue("enable_objsel",m_pxObjectsDis^.GetChecked());
		po_rxParams.SetValue("enable_subsel",m_pxSubjectsDis^.GetChecked());
		m_pxSelectionListObject^.OnFinish(po_rxParams, "objects_units");
		m_pxSelectionListSubject^.OnFinish(po_rxParams, "subjects_units");
		var int iMount = 0;
		if(m_pxMount^.GetSelected())then iMount=1; endif;
		po_rxParams.SetValue("mount", iMount);
	endproc;
endclass;

class CActionMusicPages inherit CActionPages

	var ^CCheckBox 	m_pxLoop;
	var ^CDirList	m_pxList;
	var string		m_sBasePath;

	export constructor(CGuid p_xGuid)
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_MUSI");
		
		m_sBasePath = CLevelEditorWrap.GetUrsRelPath()+"/Data/Base/Audio/";
		m_sBasePath.Replace("\\", "/");
		m_pxList = cast<CDirList>(m_apxPages[0]^.GetControl("DirList"));
		m_pxList^.SetBasePath(m_sBasePath);
		m_pxLoop=cast<CCheckBox>(m_apxPages[0]^.GetControl("Chk_Loop"));
	endconstructor;

	export proc void OnInit(ref CAttribs p_rxParams)
		var string sPath,sFile;
		var string sRelPath = p_rxParams.GetValue("musicfile");
		var int iP = sRelPath.FindRev('/');
		if(iP>=0)then
			sPath=sRelPath.Left(iP);
			sFile=sRelPath.Mid(iP+1);
		else
			sFile=sRelPath;
		endif;
		m_pxList^.SetPath(m_sBasePath+sPath);
		var int iIdx=m_pxList^.FindItem(sFile);
		if(iIdx>=0)then
			m_pxList^.Select(iIdx);
		endif;
		m_pxLoop^.SetChecked(p_rxParams.GetValueInt("loop"));
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		var string sPath = m_pxList^.GetSelectedItemPath();
		sPath.Replace(m_sBasePath,"");
		po_rxParams.SetValue("musicfile",sPath);
		var int iLoop=0;
		if(m_pxLoop^.GetCheckMark())then iLoop=1; endif;
		po_rxParams.SetValue("loop", iLoop);
	endproc;
endclass;

class CActionInfoBarPages inherit CActionPages
	
	var ^CEdit 	m_pxText;
	var ^CList	m_pxList;
	
	export constructor(CGuid p_xGuid)
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_INBA");
		
		m_pxText = cast<CEdit>(m_apxPages[0]^.GetControl("Edit_Text"));
		m_pxList = cast<CList>(m_apxPages[0]^.GetControl("List_Vars"));
		
		m_pxList^.m_xOnLBtnDblClick = OnListDblClick;
		FillList();
	endconstructor;

	export proc void OnInit(ref CAttribs p_rxParams)
		m_pxText^.SetText(p_rxParams.GetValue("text"));
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		po_rxParams.SetValue("text", m_pxText^.GetText());
	endproc;
	
	proc void FillList()
		var ^CLevelInfo pxLevelInfo=^(CLevelEditorWrap.GetClient().GetLevelInfo());
		var ^CPropDB.CNode pxNode = pxLevelInfo^.GetGenericData().FindNode("Variables", false);
		if(pxNode!=null)then
			var int i, iC = pxNode^.NumSubs();
			for(i=0) cond(i<iC) iter(++i) do
				var ^CPropDB.CNode pxSub = ^(pxNode^.Get(i));
				m_pxList^.AddItem(pxSub^.Name());
			endfor;
		endif;
		
		var ^CPropDB pxDB = new CPropDB();
		if(pxDB^.Load(CClientWrap.GetUrsRelPath()+"/Data/Base/Scripts/Server/settings/ProfileVariables.txt"))then
			pxNode = ^(pxDB^.GetRoot());
		endif;
		if(pxNode!=null)then
			var int i, iC = pxNode^.NumSubs();
			for(i=0) cond(i<iC) iter(++i) do
				var ^CPropDB.CNode pxSub = ^(pxNode^.Get(i));
				m_pxList^.AddItem(pxSub^.Name());
			endfor;
		endif;		
		delete pxDB;
	endproc;
	
	proc bool OnListDblClick()
		var string sT = m_pxList^.GetSelectedItemAsString();
		m_pxText^.SetText(m_pxText^.GetText()+"$("+sT+")");
		return false;
	endproc;
endclass;


class CActionQuickSavePages inherit CActionPages

	var ^CEdit		m_pxSaveName;
	
	export constructor(CGuid p_xGuid)
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_QUSA");
		
		m_pxSaveName = cast<CEdit>(m_apxPages[0]^.GetControl("Edit_SaveName"));
	endconstructor;

	export proc void OnInit(ref CAttribs p_rxParams)
		m_pxSaveName^.SetText(p_rxParams.GetValue("savename"));
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		po_rxParams.SetValue("savename", m_pxSaveName^.GetText());
	endproc;
endclass;

class CActionMoveRegionPages inherit CActionPages
	
	class CRgnItemData inherit CItemData
		export var CGuid m_xGuid;
	endclass;
	
	var ^CDropList 	m_pxRegions;
	var ^CEdit		m_pxPos;
	//var ^CEdit		m_pxScale;
	
	var array CRgnItemData m_axItems;
	
	export constructor(CGuid p_xGuid)
		CMainController.Get().AddClickProcRef(SetPos);
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_MRGN");
		
		m_pxRegions=cast<CDropList>(m_apxPages[0]^.GetControl("Drop_Rgn"));
		m_pxPos=cast<CEdit>(m_apxPages[0]^.GetControl("Edit_Pos"));
		//m_pxScale=cast<CEdit>(m_apxPages[0]^.GetControl("Edit_Scale"));
		m_pxRegions^.m_xOnChange = OnSelectRegion;
		FillList();
	endconstructor;
	
	export destructor()
		CMainController.Get().RemoveClickProcRef(SetPos);
	enddestructor;

	export proc void OnInit(ref CAttribs p_rxParams)
		m_pxRegions^.m_xOnChange.Clear();
		FillList();
		
		var CGuid xG; xG.FromString(p_rxParams.GetValue("rgn_guid"));
		var int i, iC = m_pxRegions^.NumItems();
		for(i=0) cond(i<iC) iter(++i) do
			var ^CRgnItemData pxID = cast<CRgnItemData>(m_pxRegions^.GetItemData(i));
			if(pxID^.m_xGuid == xG)then
				m_pxRegions^.Select(i);
				break;
			endif;
		endfor;
		
		m_pxPos^.SetText(p_rxParams.GetValue("pos"));
		//m_pxScale^.SetText(p_rxParams.GetValue("scale");
		
		m_pxRegions^.m_xOnChange = OnSelectRegion;
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		var int iSel = m_pxRegions^.GetSelectedItem();
		if(iSel>=0)then
			var ^CRgnItemData pxID = cast<CRgnItemData>(m_pxRegions^.GetItemData(iSel));
			po_rxParams.SetValue("rgn_guid", pxID^.m_xGuid.ToString());
			po_rxParams.SetValue("pos", m_pxPos^.GetText());
			//po_rxParams.SetValue("scale", m_pxScale^.GetText());
		endif;
	endproc;
	
	proc bool SetPos()
		var vec3 vPos = CClientWrap.GetScapeMgr().GetPickPoint();
		var string sTmp = vPos.ToString();
		sTmp.TrimLeft("[");	sTmp.TrimRight("]");
		m_pxPos^.SetText(sTmp);
		return true;
	endproc;
	
	proc void FillList()
		m_axItems=0;
		var ^CRegionMgrClient pxRM = CLevelEditorWrap.GetRegionMgr();
		if(pxRM!=null)then
			var int i, iC = pxRM^.NumRegions();
			for(i=0) cond(i<iC) iter(++i) do
				var ^CRegionBase pxRgn = pxRM^[i];
				
				var ^CRgnItemData pxID = ^(m_axItems.NewEntryRef());
				pxID^.m_xGuid = pxRgn^.GetGUID();
				m_pxRegions^.AddItem(pxRgn^.GetName(), pxID);
			endfor;
		endif;
	endproc;
	
	proc bool OnSelectRegion()
		var int iSel = m_pxRegions^.GetSelectedItem();
		if(iSel>=0)then
			var ^CRgnItemData pxID = cast<CRgnItemData>(m_pxRegions^.GetItemData(iSel));
			if(pxID!=null)then
				var ^CRegionBase pxRgn = CLevelEditorWrap.GetRegionMgr()^.GetRegion(pxID^.m_xGuid);
				if(pxRgn!=null)then
					var vec3 vP = pxRgn^.GetPos();
					var string sTmp = vP.ToString();
					sTmp.TrimLeft("[");	sTmp.TrimRight("]");
					m_pxPos^.SetText(sTmp);
				endif;
			endif;
		endif;	
		return true;
	endproc;
endclass;

class CActionSetNeutralForAnimalsPages inherit CActionPages

	var ^CSpinCtrlNumber m_pxOwner;
	var ^CCheckBox		 m_pxNeutral;
	var ^CCheckBox		 m_pxOtherWiseNeutralToo;

	export constructor(CGuid p_xGuid)
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_SNFA");
		
		m_pxOwner=cast<CSpinCtrlNumber>(m_apxPages[0]^.GetControl("Spin_Owner"));
		m_pxNeutral=cast<CCheckBox>(m_apxPages[0]^.GetControl("Check_Neutral"));
		m_pxOtherWiseNeutralToo=cast<CCheckBox>(m_apxPages[0]^.GetControl("Check_OtherWiseNeutralToo"));
	endconstructor;

	export proc void OnInit(ref CAttribs p_rxParams)
		m_pxOwner^.SetValue(p_rxParams.GetValueInt("player"));
		var int iValue=p_rxParams.GetValueInt("neutral");
		if(iValue==0)then
			m_pxNeutral^.SetChecked(0);
			m_pxOtherWiseNeutralToo^.SetChecked(0);
		elseif(iValue==1)then
			m_pxNeutral^.SetChecked(1);
			m_pxOtherWiseNeutralToo^.SetChecked(0);
		elseif(iValue==2)then
			m_pxNeutral^.SetChecked(0);
			m_pxOtherWiseNeutralToo^.SetChecked(1);
		else
			m_pxNeutral^.SetChecked(1);
			m_pxOtherWiseNeutralToo^.SetChecked(1);
		endif;				
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		po_rxParams.SetValue("player", m_pxOwner^.GetValueInt());
		var int iCheck = 0;
		if(m_pxNeutral^.GetCheckMark())then iCheck=1; endif;
		if(m_pxOtherWiseNeutralToo^.GetCheckMark())then iCheck+=2; endif;
		po_rxParams.SetValue("neutral", iCheck);		
	endproc;
endclass;

class CActionPlayerCapsPages inherit CActionPages

	var ^CSpinCtrlNumber m_pxPlayer;
	var ^CSpinCtrlNumber m_pxWood, m_pxFood, m_pxStone;

	export constructor(CGuid p_xGuid)
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_PLCP");
		
		m_pxPlayer = cast<CSpinCtrlNumber>(m_apxPages[0]^.GetControl("Spin_Owner"));
		m_pxFood = cast<CSpinCtrlNumber>(m_apxPages[0]^.GetControl("Spin_Food"));
		m_pxWood = cast<CSpinCtrlNumber>(m_apxPages[0]^.GetControl("Spin_Wood"));
		m_pxStone = cast<CSpinCtrlNumber>(m_apxPages[0]^.GetControl("Spin_Stone"));
	endconstructor;

	export proc void OnInit(ref CAttribs p_rxParams)
		m_pxPlayer^.SetValue(p_rxParams.GetValueInt("player"));
		m_pxFood^.SetValue(p_rxParams.GetValueInt("food"));
		m_pxWood^.SetValue(p_rxParams.GetValueInt("wood"));
		m_pxStone^.SetValue(p_rxParams.GetValueInt("stone"));
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		po_rxParams.SetValue("player", m_pxPlayer^.GetValueInt());
		po_rxParams.SetValue("food", m_pxFood^.GetValueInt());
		po_rxParams.SetValue("wood", m_pxWood^.GetValueInt());
		po_rxParams.SetValue("stone", m_pxStone^.GetValueInt());
	endproc;
endclass;

class CActionActivateRegionPages inherit CActionPages

	var ^CTreeCtrl		m_pxTree;
	var ^CRadioButton 	m_pxOn, m_pxOff;
	var array int		m_aiRegionData;
	

	export constructor(CGuid p_xGuid)
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_ARGN");
		
		m_pxTree = cast<CTreeCtrl>(m_apxPages[0]^.GetControl("Rgn"));
		m_pxOn = cast<CRadioButton>(m_apxPages[0]^.GetControl("On"));
		m_pxOff = cast<CRadioButton>(m_apxPages[0]^.GetControl("Off"));
		
		FillTree();
	endconstructor;
	
	export destructor()
		ClearTree();
	enddestructor;

	proc void FillTree()
		ClearTree();
		var ^CRegionMgrClient pxRM=CClientWrap.GetRegionMgr();
		var CRegionMgrClient.CNode xRoot = pxRM^.GetHierarchyRoot();
		var ^CRegionBase.TNodeData pxRootData = xRoot.GetData();
		var ^CRegionData pxRD=new CRegionData(xRoot);
		var int iRootIdx = m_pxTree^.AddItem(0, "Root");
		pxRD^.m_iNodeIdx = iRootIdx;
		pxRD^.m_bVisible = true;
		m_pxTree^.SetItemData(iRootIdx, pxRD);
		FillTreeRec(xRoot, iRootIdx);
	endproc;
	
	proc void ClearTree()
		var int i, iC = m_aiRegionData.NumEntries();
		for(i=0) cond(i<iC) iter(++i) do
			delete m_pxTree^.GetItemData(m_aiRegionData[i]);
		endfor;
		m_aiRegionData=0;
	endproc;
	
	proc void FillTreeRec(CRegionMgrClient.CNode p_xNode, int p_iNode)
		var ^CRegionMgrClient pxRM=CClientWrap.GetRegionMgr();	
		var int i, iC = p_xNode.NumChildren();	
		for(i=0) cond(i<iC) iter(++i) do
			var CRegionMgrClient.CNode xChildNode = p_xNode.GetChild(i);
			var ^CRegionBase.TNodeData pxData = xChildNode.GetData();
			if(pxData==null)then continue; endif;			
			var ^CRegionData pxNewRD = new CRegionData(xChildNode);
			var int iChildIdx=m_pxTree^.AddItem(p_iNode,pxData^.GetName(), pxNewRD);
			m_aiRegionData.AddEntry(iChildIdx);
			pxNewRD^.m_iNodeIdx=iChildIdx;
			FillTreeRec(xChildNode,iChildIdx);			
		endfor;	
		
		begin UpdateNodeRegions;
			var ^CRegionBase.TNodeData pxNodeData = p_xNode.GetData();
			var int iR,iRC=pxNodeData^.NumRegions();
			for(iR=0)cond(iR<iRC)iter(iR++)do					
				var CGuid xRegionGuid=pxNodeData^.GetRegionGuid(iR);
				var ^CRegionBase pxRegion=pxRM^.GetRegion(xRegionGuid);
				if(pxRegion==null)then 
					continue; 
				endif;
				var ^CRegionData pxNewRD=new CRegionData(p_xNode,xRegionGuid);
				var int iIdx=m_pxTree^.AddItem(p_iNode, ">>> " + pxRegion^.GetName(),pxNewRD);	
				m_aiRegionData.AddEntry(iIdx);
				pxNewRD^.m_iNodeIdx = iIdx;
				m_pxTree^.SetItemDisabled(iIdx, !pxRegion^.GetEnable(), false);
				//?? pxNewRD^.m_bVisible = p_pxParent^.m_bVisible;	
				
				var int iS,iSC=pxRegion^.NumSubs();					
				for(iS=0)cond(iS<iSC)iter(iS++)do
					var ^CSubRegion pxSub=(pxRegion^)[iS];
					var int iSubRgnIdx =m_pxTree^.AddItem(iIdx,iS.ToString(),new CRegionData(p_xNode, xRegionGuid, iS));
					m_aiRegionData.AddEntry(iSubRgnIdx);
					var ^CRegionData pxNewRD = cast<CRegionData>(m_pxTree^.GetItemData(iSubRgnIdx));
					pxNewRD^.m_iNodeIdx = iSubRgnIdx;
					//?? pxNewRD^.m_bVisible = p_pxParent^.m_bVisible;						
					m_pxTree^.SetItemDisabled(iSubRgnIdx, !pxSub^.GetEnable(), false);
				endfor;			
			endfor;
		end UpdateNodeRegions;
	endproc;

	export proc void OnInit(ref CAttribs p_rxParams)
		var CGuid xG; xG.FromString(p_rxParams.GetValue("rgn_guid"));
		var int iSubIdx = p_rxParams.GetValueInt("sub_idx");
		var bool bOn = p_rxParams.GetValueInt("dest_state")==1;
		
		var int iCur=-1;
		m_pxTree^.StartIterate();
		while(m_pxTree^.Iterate(iCur))do	
			var ^CRegionData pxRD=cast<CRegionData>(m_pxTree^.GetItemData(iCur));
			if(pxRD!=null)then
				if(pxRD^.GetBaseRegion() == xG)then
					if(iSubIdx<0)then
						m_pxTree^.Select(iCur);
						m_pxTree^.EnsureVisible(iCur);
						break;
					else
						var int iSub = m_pxTree^.GetChildItem(iCur, iSubIdx);
						if(iSub>0)then
							m_pxTree^.Select(iSub);
							m_pxTree^.EnsureVisible(iSub);
							break;
						endif;
					endif;
				endif;
			endif;
		endwhile;
		if(bOn)then
			m_pxOn^.SetSelected(true);
		else
			m_pxOff^.SetSelected(true);
		endif;
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		var int iSel = m_pxTree^.GetSelectedItem();
		if(iSel>0)then
			var ^CRegionData pxRD = cast<CRegionData>(m_pxTree^.GetItemData(iSel));
			if(pxRD!=null)then
				var CGuid xG = pxRD^.GetBaseRegion();
				var int iSubIdx = -1;
				if(pxRD^.IsSubType())then
					iSubIdx = pxRD^.GetSubRegionID();
				endif;
				po_rxParams.SetValue("rgn_guid", xG.ToString());
				po_rxParams.SetValue("sub_idx", iSubIdx);
				if(m_pxOn^.GetSelected())then
					po_rxParams.SetValue("dest_state", 1);
				else
					po_rxParams.SetValue("dest_state", 0);
				endif;
			endif;
		endif;
	endproc;
endclass;

/*

	ActionView - Template


class CAction<Name>Pages inherit CActionPages
	export constructor(CGuid p_xGuid)
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_<FourCC>");
	endconstructor;

	export proc void OnInit(ref CAttribs p_rxParams)
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
	endproc;
endclass;
*/

//----------------------------------------------------------
// Class:	CActionNewsTicker
//----------------------------------------------------------
class CActionNewsTicker inherit CActionPages
	
	var ^CList			m_pxMessage;
	var ^CDropList		m_pxPlayer;
	var ^CEdit			m_pxHour;
	var ^CEdit			m_pxMinute;
	var ^CEdit			m_pxSecond;
	var ^CList 			m_pxType;
	var ^CEdit			m_pxPos;
	var ^CList			m_pxSpecialEvent;
	
	var ^CWindow		m_pxSpecialEventContainer;
	//sdpecial event containers	
	var ^CTreeCtrl		m_pxHelpTree;
	
	class CMessageItemData inherit CItemData
		export var string m_sKey;
		export constructor(string p_sValue)
			m_sKey=p_sValue;
		endconstructor;
	endclass;


	export constructor()
		CMainController.Get().AddClickProcRef(SetPos);
		m_apxPages=1;
		var ^CWindow pxPage=new CWindow;
		pxPage^.InitFromResource("Trigger/ViewActionCreate","Action_NWTK");
		m_apxPages[0]=pxPage;
		
		m_pxMessage=cast<CList>(pxPage^.GetControl("MessageList"));
		m_pxPlayer=cast<CDropList>(pxPage^.GetControl("PlayerID"));
		m_pxHour=cast<CEdit>(pxPage^.GetControl("Edit_Hours"));
		m_pxMinute=cast<CEdit>(pxPage^.GetControl("Edit_Min"));
		m_pxSecond=cast<CEdit>(pxPage^.GetControl("Edit_Sec"));
		m_pxType=cast<CList>(pxPage^.GetControl("TypeList"));
		m_pxPos=cast<CEdit>(pxPage^.GetControl("Edit_Pos"));
		m_pxSpecialEvent=cast<CList>(pxPage^.GetControl("SpecialEventList"));
		//m_pxSpecialEventContainer=pxPage^.GetControl("SpecialParamsContainer");
		
		
		begin load_keys;		
			var int i,iC=CLocalizer.Get().NumKeys();
			for(i=0)cond(i<iC)iter(i++)do
				var string sKey;
				if(CLocalizer.Get().GetKey(i,sKey))then
//					if(sKey.Left(7)=="_NTMSG_")then
					if(sKey.Find("_NT_")!=-1)then
						m_pxMessage^.AddItem(CLocalizer.Get().Translate(sKey),new CMessageItemData(sKey));
					endif;
				endif;
			endfor;
			m_pxMessage^.QSort();	
		end load_keys;			
		/*
		var string sNewsTikerLMF=CClientWrap.GetUrsRelPath()+"/Data/Base/Texts/newsticker.lmf";
		var CSourceFileLineSplitter xLS;
		var int iLine=0;
		if(xLS.Open(sNewsTikerLMF))then
			var string sLine;
			while(xLS.GetLine(iLine,sLine))do
				var array string asTokens;
				sLine.Split(asTokens,";",true);
				if(asTokens.NumEntries()>0)then
					var string sKey=asTokens[0];
					sKey.TrimLeft("\"");
					sKey.TrimRight("\"");
					if(sKey.Left(7)=="_NTMSG_")then
						m_pxMessage^.AddItem(CLocalizer.Get().Translate(sKey),new CMessageItemData(sKey));
					endif;
				endif;				
				iLine++;
			endwhile;
		endif;;
		xLS.Close();		
		*/
		
		m_pxPlayer^.AddItem("All");
		var int i;
		for (i=0) cond(i<8) iter(++i) do
			m_pxPlayer^.AddItem(i.ToString());
		endfor;	
		
		m_pxType^.AddItem("ATTACK");
		m_pxType^.AddItem("ECONOMY");
		m_pxType^.AddItem("DIPLOMACY");
		m_pxType^.AddItem("STORY");
		m_pxType^.AddItem("INFO");
		m_pxType^.AddItem("SYSTEM");
		
		m_pxSpecialEvent^.AddItem("kein");
		m_pxSpecialEvent^.AddItem("showhelp");
		m_pxSpecialEvent^.m_xOnSelect=OnSelectSpecialEvent;
		
		m_pxHelpTree=new CTreeCtrl;
		BuildIndex();
	endconstructor;
	
	export destructor()
		CMainController.Get().RemoveClickProcRef(SetPos);
		m_pxHelpTree^.RemoveFromParent();
		delete m_pxHelpTree;
		var int i,iC=m_pxMessage^.NumItems();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CItemData pxWalk=m_pxMessage^.GetItemData(i);
			delete pxWalk;
		endfor;
	enddestructor;


	export proc void OnInit(ref CAttribs p_rxParams)
		var string sMsgKey=p_rxParams.GetValue("message");
		var int i,iC=m_pxMessage^.NumItems();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CMessageItemData pxWalk=cast<CMessageItemData>(m_pxMessage^.GetItemData(i));
			if(pxWalk^.m_sKey==sMsgKey)then
				m_pxMessage^.Select(i);
				break;
			endif;
		endfor;		
		
		var int iPlayerID = p_rxParams.GetValueInt("player_id");
		m_pxPlayer^.Select(iPlayerID+1);
		
		var int  iDuration = p_rxParams.GetValueInt("duration");
		var int iMinutes = iDuration / 60;
		var int iHours 	 = iMinutes  / 60;
		var int iM		 = iMinutes - iHours*60;
		var int iS 		 = iDuration - iMinutes*60;
		m_pxHour^.SetText(iHours.ToString());
		m_pxMinute^.SetText(iM.ToString());
		m_pxSecond^.SetText(iS.ToString());
		
		
		m_pxType^.Select(p_rxParams.GetValueInt("type"));
		
		var string sPos=p_rxParams.GetValue("position");
		m_pxPos^.SetText(sPos);
		
		
		var string sSpecialEvent=p_rxParams.GetValue("special_event");
		m_pxSpecialEvent^.Select(0);
		var string sEventType;
		var string sEventParam;
		// "-event {showhelp}"
		// "-event {showhelp path}"
		if(!sSpecialEvent.IsEmpty())then
			var int iOpenBrace=sSpecialEvent.Find("{");
			var int iCloseBrace=sSpecialEvent.Find("}");
			if(iOpenBrace!=-1 && iCloseBrace!=-1)then
				sSpecialEvent=sSpecialEvent.Mid(iOpenBrace+1,iCloseBrace-iOpenBrace-1);
				var array string asTokens;
				sSpecialEvent.Split(asTokens," ",true);
				if(asTokens.NumEntries()>0)then				
					sEventType=asTokens[0];
					if(asTokens.NumEntries()>1)then
						sEventParam=asTokens[1];						
					endif;
				endif;
			endif;
		endif;
		var int iEventTypeIdx=m_pxSpecialEvent^.FindItem(sEventType);
		if(iEventTypeIdx!=-1)then
			m_pxSpecialEvent^.Select(iEventTypeIdx);
			
			if(sEventType=="showhelp")then
				if(!sEventParam.IsEmpty())then
					m_pxHelpTree^.StartIterate();
					var int iCur = 0;
					repeat
						m_pxHelpTree^.Iterate(iCur);
						if(iCur <= 1)then break; endif;
						var ^CIndexListData pxID = cast<CIndexListData>(m_pxHelpTree^.GetItemData(iCur));
						if(pxID!=null)then
							if(pxID^.m_sSEMLFile == sEventParam)then
								m_pxHelpTree^.Select(iCur);
								m_pxHelpTree^.EnsureVisible(iCur);
								break;
							endif;
						endif;
					until ( iCur <= 0 ) endrepeat;	
				endif;
			endif;
		endif;		
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		var string sMsg;
		var int iSel=m_pxMessage^.GetSelectedItem();
		if(iSel!=-1)then
			var ^CMessageItemData pxWalk=cast<CMessageItemData>(m_pxMessage^.GetItemData(iSel));
			sMsg=pxWalk^.m_sKey;			
		endif;
		po_rxParams.SetValue("message",sMsg);

		var string sPlayerID=m_pxPlayer^.GetSelectedItemAsString();
		var int iPlayerID=-1;
		if(sPlayerID!="All")then
			iPlayerID=sPlayerID.ToInt();
		endif;
		po_rxParams.SetValue("player_id", iPlayerID);
		
		var int 	iH		= m_pxHour^.GetText().ToInt();
		var int 	iM		= m_pxMinute^.GetText().ToInt();
		var int 	iS		= m_pxSecond^.GetText().ToInt();
		po_rxParams.SetValue("duration",((iH*60+iM)*60+iS).ToReal());
		
		po_rxParams.SetValue("type",m_pxType^.GetSelectedItem());
		
		var vec3 vPos;
		vPos.FromString(m_pxPos^.GetText());
		po_rxParams.SetValue("position", vPos.ToString());
		
		var string sSpecialEvent;
		var string sEventType=m_pxSpecialEvent^.GetSelectedItemAsString();
		if(sEventType=="showhelp")then			
			sSpecialEvent="-event {showhelp";
			var int iSel = m_pxHelpTree^.GetSelectedItem();
			if(iSel>0)then
				var ^CIndexListData pxID = cast<CIndexListData>(m_pxHelpTree^.GetItemData(iSel));
				if(pxID!=null)then
					sSpecialEvent+=" "+pxID^.m_sSEMLFile;
				endif;
			endif;
			sSpecialEvent+="}";
		endif;
		po_rxParams.SetValue("special_event",sSpecialEvent);
	endproc;
	
	proc bool SetPos()		
		var vec3 vPos = CClientWrap.GetScapeMgr().GetPickPoint();
		var string sTmp = vPos.ToString();
		sTmp.TrimLeft("[");	sTmp.TrimRight("]");
		m_pxPos^.SetText(sTmp);
		return true;
	endproc;
	
	proc bool OnSelectSpecialEvent()
		m_pxHelpTree^.RemoveFromParent();
		var string sSpecialEvent=m_pxSpecialEvent^.GetSelectedItemAsString();
		if(sSpecialEvent=="showhelp")then
			m_apxPages[0]^.AddChildWithLayout(m_pxHelpTree,"SpecialParamsContainer");
		endif;
		return true;
	endproc;
	
	proc void BuildIndex()
		m_sHelpPath = CClientWrap.GetUrsRelPath()+"/Data/Base/Texts/Help/";
		var string sIndexFile=m_sHelpPath+"index.txt";
		var CPropDB xDB;
		if(!xDB.Load(sIndexFile))then KLog.LogError("CHelpMenu","Internal: index file not found!"); return; endif;
		BuildIndexRec(xDB.GetRoot(),null);
	endproc;

	proc void BuildIndexRec(ref CPropDB.CNode p_rxPDBNode,^CActionNewsTicker.CIndexListData p_pxTreeItem)
		var int i,iC=p_rxPDBNode.NumSubs();
		for(i=0) cond(i<iC) iter(i++) do
			var ^CPropDB.CNode pxSub=^(p_rxPDBNode.Get(i));
			if(pxSub^.NumSubs()>0)then
				var string sName=pxSub^.Name();
				var string sText=sName;
				pxSub^.GetValue("text",sText);
				sText=CLocalizer.Get().Translate(sText);
				var ^CIndexListData pxID=^(m_axIndexItemData.NewEntryRef());
				pxID^.m_sName=sName;
				pxID^.m_sName.MakeLower();
				var int iParentID=0;
				if(p_pxTreeItem!=null)then
					iParentID=p_pxTreeItem^.m_iItemID;
				endif;
				pxSub^.GetValue("helpfile",pxID^.m_sSEMLFile);
				//pxID^.m_sSEMLFile.MakeLower();
				pxID^.m_iItemID=m_pxHelpTree^.AddItem(iParentID,sText,pxID);
				
				BuildIndexRec(pxSub^,pxID);
			endif;
		endfor;
	endproc;

	proc void BuildIndexRec(string p_sBaseFile,ref CPropDB.CNode p_rxPDBNode,^CActionNewsTicker.CIndexListData p_pxTreeItem)
		var string sName=p_rxPDBNode.Name();
		var string sTopic=+p_rxPDBNode.Value();
		if(sName!="Root")then
			sName.TrimRight();
			var int iParentID=p_pxTreeItem^.m_iItemID;
			var ^CIndexListData pxID=^(m_axIndexItemData.NewEntryRef());
			pxID^.m_sName=sTopic;
			pxID^.m_sName.MakeLower();
			pxID^.m_sSEMLFile=p_sBaseFile+"#"+sTopic;
			pxID^.m_sSEMLFile.MakeLower();
			//KLog.LogWarn("CHP","N:"+pxID^.m_sName+",S:"+pxID^.m_sSEMLFile);
			pxID^.m_iItemID=m_pxHelpTree^.AddItem(iParentID,sName,pxID);
			p_pxTreeItem=pxID;
		endif;
		var int i,iC=p_rxPDBNode.NumSubs();
		for(i=0) cond(i<iC) iter(i++) do
			BuildIndexRec(p_sBaseFile,p_rxPDBNode.Get(i),p_pxTreeItem);
		endfor;
	endproc;

	
	class CIndexListData inherit CItemData
		export var int 		m_iItemID;
		export var string 	m_sName;
		export var string	m_sSEMLFile;
	endclass;

	var array CIndexListData m_axIndexItemData;
	var string m_sHelpPath;
endclass;


class CActionUIFeedbackFramePages inherit CActionPages

	var ^CList m_pxFrameList;
	var ^CRadioButton m_pxEnableButton;
	var ^CRadioButton m_pxDisableButton;

	export constructor()
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_UIFF");
		
		m_pxFrameList=cast<CList>(m_apxPages[0]^.GetControl("FrameList"));
		m_pxEnableButton=cast<CRadioButton>(m_apxPages[0]^.GetControl("Activate"));
		m_pxDisableButton=cast<CRadioButton>(m_apxPages[0]^.GetControl("Deactivate"));
		Fill();
		
	endconstructor;

	export proc void OnInit(ref CAttribs p_rxParams)
		var string sFrameName=p_rxParams.GetValue("framename");
		var bool bActivate=p_rxParams.GetValueBool("activate");
		var int iIDX=m_pxFrameList^.FindItem(sFrameName);
		if(iIDX!=-1)then
			m_pxFrameList^.Select(iIDX);
		endif;
		m_pxEnableButton^.SetSelected(bActivate);
		m_pxDisableButton^.SetSelected(!bActivate);		
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		po_rxParams.SetValue("framename",m_pxFrameList^.GetSelectedItemAsString());
		po_rxParams.SetValue("activate", m_pxEnableButton^.GetSelected());
	endproc;
	
	proc void Fill()
		m_pxFrameList^.Clear();
		var ^CLevelInfo pxLevelInfo=^(CLevelEditorWrap.GetClient().GetLevelInfo());
		var ^CPropDB.CNode pxFFNode=^((pxLevelInfo^.GetGenericData())["FeedbackFrames"]);
		var int i,iC=pxFFNode^.NumSubs();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CPropDB.CNode pxWalk=^(pxFFNode^.Get(i));
			m_pxFrameList^.AddItem(pxWalk^.Name());			
		endfor;		
	endproc;
endclass;

class CActionScreenRegionPages inherit CActionPages

	var ^CList m_pxRegionsList;
	var ^CRadioButton m_pxEnableButton;
	var ^CRadioButton m_pxDisableButton;

	export constructor()
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_SCRE");
		
		m_pxRegionsList=cast<CList>(m_apxPages[0]^.GetControl("RegionsList"));
		m_pxEnableButton=cast<CRadioButton>(m_apxPages[0]^.GetControl("Activate"));
		m_pxDisableButton=cast<CRadioButton>(m_apxPages[0]^.GetControl("Deactivate"));
		Fill();
		
	endconstructor;

	export proc void OnInit(ref CAttribs p_rxParams)
		var string sRegionName=p_rxParams.GetValue("regionname");
		var bool bActivate=p_rxParams.GetValueBool("activate");
		var int iIDX=m_pxRegionsList^.FindItem(sRegionName);
		if(iIDX!=-1)then
			m_pxRegionsList^.Select(iIDX);
		endif;
		m_pxEnableButton^.SetSelected(bActivate);
		m_pxDisableButton^.SetSelected(!bActivate);		
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		po_rxParams.SetValue("regionname",m_pxRegionsList^.GetSelectedItemAsString());
		po_rxParams.SetValue("activate", m_pxEnableButton^.GetSelected());
	endproc;
	
	proc void Fill()
		m_pxRegionsList^.Clear();
		var ^CLevelInfo pxLevelInfo=^(CLevelEditorWrap.GetClient().GetLevelInfo());
		var ^CPropDB.CNode pxSRNode=^((pxLevelInfo^.GetGenericData())["ScreenRegions"]);
		var int i,iC=pxSRNode^.NumSubs();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CPropDB.CNode pxWalk=^(pxSRNode^.Get(i));
			m_pxRegionsList^.AddItem(pxWalk^.Name());			
		endfor;		
	endproc;
endclass;


class CActionQuestionMarkPages inherit CActionPages

	var ^CList m_pxQuestionMarkList;
	var ^CList m_pxStateList;
	var ^CList m_pxToolTipList;
	var ^CStaticCtrlEx m_pxToolTip;
	var ^CEdit m_pxPicture;
	var ^CEdit m_pxName;
	
	class CQuestMarkItemData inherit CItemData
		export var CGuid m_xGUID;
		
		export constructor(CGuid p_xGUID)
			m_xGUID=p_xGUID;
		endconstructor;
	endclass;

	export constructor()
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_QMRK");
		
		m_pxQuestionMarkList=cast<CList>(m_apxPages[0]^.GetControl("QuestionMarkList"));
		m_pxStateList=cast<CList>(m_apxPages[0]^.GetControl("StateList"));
		m_pxToolTipList=cast<CList>(m_apxPages[0]^.GetControl("ToolTipList"));
		m_pxPicture=cast<CEdit>(m_apxPages[0]^.GetControl("PictureEdit"));
		m_pxName=cast<CEdit>(m_apxPages[0]^.GetControl("NameEdit"));
		m_pxToolTip=cast<CStaticCtrlEx>(m_apxPages[0]^.GetControl("ToolTip"));
		
		var CObjQueryCln xOQ;
		xOQ.SetType("QMRK");
		var CObjList xQuestMarks;
		xOQ.Execute(xQuestMarks);
		var int i,iC=xQuestMarks.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CObj pxWalk=xQuestMarks[i].GetObj();
			if(pxWalk==null)then continue; endif;
			m_pxQuestionMarkList^.AddItem(pxWalk^.GetName(),new CQuestMarkItemData(pxWalk^.GetGuid()));
		endfor;
		
		m_pxStateList^.AddItem("STATE_INVISIBLE");
		m_pxStateList^.AddItem("QM_STATE_RED");
		m_pxStateList^.AddItem("QM_STATE_GREEN");
		m_pxStateList^.AddItem("QM_STATE_YELLOW");
		m_pxStateList^.AddItem("EC_STATE_YELLOW");
		
		iC=CLocalizer.Get().NumKeys();
		for(i=0)cond(i<iC)iter(i++)do
			var string sKey;
			if(CLocalizer.Get().GetKey(i,sKey))then
				if(sKey.Left(5)=="_TTQ_")then
					m_pxToolTipList^.AddItem(sKey);
				endif;
			endif;
		endfor;

		// Fix by AyCe
		CSDKLocalizationMgr.Get().CustomQuestmarks(m_pxToolTipList);
		// Fix end

		m_pxToolTipList^.QSort();
		
		/*
		var string sQuestionsLMF=CClientWrap.GetUrsRelPath()+"/Data/Base/Texts/questions.lmf";
		var CSourceFileLineSplitter xLS;
		var int iLine=0;
		if(xLS.Open(sQuestionsLMF))then
			var string sLine;
			while(xLS.GetLine(iLine,sLine))do
				var array string asTokens;
				sLine.Split(asTokens,";",true);
				if(asTokens.NumEntries()>0)then
					var string sKey=asTokens[0];
					sKey.TrimLeft("\"");
					sKey.TrimRight("\"");
					if(sKey.Left(5)=="_TTQ_")then
						m_pxToolTipList^.AddItem(sKey);
					endif;
				endif;				
				iLine++;
			endwhile;
		endif;;
		xLS.Close();	
		*/
		m_pxToolTipList^.m_xOnSelect=OnSelectToolTip;
		OnSelectToolTip();
	endconstructor;
	
	export destructor()
		var int i,iC=m_pxQuestionMarkList^.NumItems();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CItemData pxWalk=m_pxQuestionMarkList^.GetItemData(i);
			delete pxWalk;
		endfor;
	enddestructor;

	export proc void OnInit(ref CAttribs p_rxParams)
		var CGuid xGuid;
		xGuid.FromString(p_rxParams.GetValue("questionmark"));
		
		var ^CObj pxQuestionObj=CClientWrap.GetObjMgr().GetObj(xGuid);
		if(pxQuestionObj==null)then return; endif;
		
		var int iIDX=m_pxQuestionMarkList^.FindItem(pxQuestionObj^.GetName());
		if(iIDX!=-1)then
			m_pxQuestionMarkList^.Select(iIDX);
		endif;
				
		iIDX=m_pxStateList^.FindItem(p_rxParams.GetValue("questionstate"));
		if(iIDX!=-1)then
			m_pxStateList^.Select(iIDX);
		endif;
		iIDX=m_pxToolTipList^.FindItem(p_rxParams.GetValue("questiontooltip"));
		if(iIDX!=-1)then
			m_pxToolTipList^.Select(iIDX);
		endif;
		m_pxPicture^.SetText(p_rxParams.GetValue("questionpicture"));
		m_pxName^.SetText(p_rxParams.GetValue("questionname"));
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		var string sGuid;
		var int idx=m_pxQuestionMarkList^.GetSelectedItem();
		if(idx!=-1)then
			var ^CQuestMarkItemData pxData=cast<CQuestMarkItemData>(m_pxQuestionMarkList^.GetItemData(idx));
			sGuid=pxData^.m_xGUID.ToString();
		endif;
		po_rxParams.SetValue("questionmark",sGuid);
		po_rxParams.SetValue("questionstate", m_pxStateList^.GetSelectedItemAsString());
		po_rxParams.SetValue("questiontooltip", m_pxToolTipList^.GetSelectedItemAsString());
		po_rxParams.SetValue("questionpicture", m_pxPicture^.GetText());
		po_rxParams.SetValue("questionname", m_pxName^.GetText());
	endproc;
	
	proc bool OnSelectToolTip()
		var string sTTKey=m_pxToolTipList^.GetSelectedItemAsString();
		var string sToolTipText=CLocalizer.Get().Translate(sTTKey);
		// Fix by AyCe
		if(sToolTipText==sTTKey)then
			sToolTipText = CSDKLocalizationMgr.Get().GetHelper(sTTKey);
		endif;
		// Fix end
		m_pxToolTip^.SetText(sToolTipText);
		return true;
	endproc;
	
endclass;

class CActionTimerPages inherit CActionPages
	
	var ^CEdit 			m_pxTimerID;
	var ^CRadioButton	m_pxCreateRB;
	var ^CRadioButton	m_pxPauseRB;
	var ^CRadioButton	m_pxUnpauseRB;
	var ^CRadioButton	m_pxKillRB;
	var ^CEdit			m_pxHour;
	var ^CEdit			m_pxMinute;
	var ^CEdit			m_pxSecond;
	var ^CCheckBox		m_pxRepeat;
	var ^CCheckBox		m_pxShow;
	var ^CEdit			m_pxTooltip;
	
	var ^CWindow m_pxCreateControls;
	
	
	export constructor()
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		if(!m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_TIMR"))then
			KLog.LogError("CActionTimerPages","CActionTimerPages Inif failed");
			return;
		endif;
		
		
		m_pxTimerID=cast<CEdit>(m_apxPages[0]^.GetControl("TimerID"));
		m_pxCreateRB=cast<CRadioButton>(m_apxPages[0]^.GetControl("CreateRB"));
		m_pxPauseRB=cast<CRadioButton>(m_apxPages[0]^.GetControl("PauseRB"));
		m_pxUnpauseRB=cast<CRadioButton>(m_apxPages[0]^.GetControl("UnpauseRB"));
		m_pxKillRB=cast<CRadioButton>(m_apxPages[0]^.GetControl("KillRB"));
		m_pxCreateControls=m_apxPages[0]^.GetControl("CreateControls");
		m_pxHour=cast<CEdit>(m_pxCreateControls^.GetControl("Edit_Hours"));
		m_pxMinute=cast<CEdit>(m_pxCreateControls^.GetControl("Edit_Min"));
		m_pxSecond=cast<CEdit>(m_pxCreateControls^.GetControl("Edit_Sec"));
		m_pxRepeat=cast<CCheckBox>(m_pxCreateControls^.GetControl("Repeat"));
		m_pxShow=cast<CCheckBox>(m_pxCreateControls^.GetControl("Show"));
		m_pxTooltip=cast<CEdit>(m_pxCreateControls^.GetControl("Edit_Tooltip"));
		
		m_pxCreateRB^.m_xOnChange=OnChangeState;
		m_pxPauseRB^.m_xOnChange=OnChangeState;
		m_pxUnpauseRB^.m_xOnChange=OnChangeState;
		m_pxKillRB^.m_xOnChange=OnChangeState;
	endconstructor;
	
	export destructor()		
	enddestructor;
	
	proc bool OnChangeState()	
		m_pxCreateControls^.SetVisible(m_pxCreateRB^.GetSelected());		
		return true;
	endproc;

	export proc void OnInit(ref CAttribs p_rxParams)
		var int iID=p_rxParams.GetValueInt("timer_id");
		var string sEvent=p_rxParams.GetValue("event");
		var int iDuration=p_rxParams.GetValueInt("duration");
		var bool bRepeat=p_rxParams.GetValueBool("repeat");
		var bool bShow=p_rxParams.GetValueBool("show");
		var string sTooltip=p_rxParams.GetValue("tooltip");
		
		m_pxTimerID^.SetText(iID.ToString());
		if(sEvent=="kill")then
			m_pxKillRB^.SetSelected(true);
		elseif(sEvent=="unpause")then
			m_pxUnpauseRB^.SetSelected(true);
		elseif(sEvent=="pause")then
			m_pxPauseRB^.SetSelected(true);
		else
			m_pxCreateRB^.SetSelected(true);
		endif;

		var int iMinutes = iDuration / 60;
		var int iHours 	 = iMinutes  / 60;

		var int iM		 = iMinutes - iHours*60;
		var int iS 		 = iDuration - iMinutes*60;

		m_pxHour^.SetText(iHours.ToString());
		m_pxMinute^.SetText(iM.ToString());
		m_pxSecond^.SetText(iS.ToString());
		if(bRepeat)then
			m_pxRepeat^.SetChecked(1);
		else
			m_pxRepeat^.SetChecked(0);
		endif;
		if(bShow)then
			m_pxShow^.SetChecked(1);
		else
			m_pxShow^.SetChecked(0);
		endif;
		
		m_pxTooltip^.SetText(sTooltip);
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		po_rxParams.SetValue("timer_id",m_pxTimerID^.GetText().ToString());
		var string sEvent="create";
		if(m_pxKillRB^.GetSelected())then
			sEvent="kill";
		elseif(m_pxUnpauseRB^.GetSelected())then
			sEvent="unpause";
		elseif(m_pxPauseRB^.GetSelected())then
			sEvent="pause";
		endif;
		po_rxParams.SetValue("event",sEvent);
		
		var int 	iH		= m_pxHour^.GetText().ToInt();
		var int 	iM		= m_pxMinute^.GetText().ToInt();
		var int 	iS		= m_pxSecond^.GetText().ToInt();
		po_rxParams.SetValue("duration",((iH*60+iM)*60+iS).ToReal());
		
		var int iShow=0;
		var int iRepeat=0;
		if(m_pxShow^.GetCheckMark())then iShow=1; endif;
		if(m_pxRepeat^.GetCheckMark())then iRepeat=1; endif;
		
		po_rxParams.SetValue("show", iShow);
		po_rxParams.SetValue("repeat", iRepeat);
		po_rxParams.SetValue("tooltip", m_pxTooltip^.GetText());
	endproc;
	
endclass;

class CActionEffectPages inherit CActionPages
	
	var ^CTreeCtrl2 		m_pxEffectTree;	
	var ^CEdit 				m_pxPos;
	var ^CEdit 				m_pxRot;
	var ^CSpinCtrlNumber	m_pxLoopValue;
	var ^CCheckBox			m_pxUseObjQuery;
	var ^CActionObjSelector	m_pxObjSelector;
		
	var CPropDB 			m_xParticleData;
	
	export constructor(CGuid p_xGuid)
		m_apxPages=1;
		m_apxPages[0]=new CWindow;
		if(!m_apxPages[0]^.InitFromResource("Trigger/ViewActionCreate","Action_EFCT"))then
			KLog.LogError("CActionEffectPages","CActionEffectPages Inif failed");
			return;
		endif;		
		var string sPath=CClientWrap..GetUrsRelPath()+"/Data/Base/Scripts/Game/sequencer/particles.txt";
        if(!m_xParticleData.Load(sPath))then        
            KLog.LogError("CActionEffectPages","can't load particle data file '"+sPath+"'");            
        endif;		
		m_pxEffectTree=cast<CTreeCtrl2>(m_apxPages[0]^.GetControl("EffectTree"));
		m_pxPos=cast<CEdit>(m_apxPages[0]^.GetControl("Pos"));
		m_pxRot=cast<CEdit>(m_apxPages[0]^.GetControl("Rot"));
		m_pxLoopValue=cast<CSpinCtrlNumber>(m_apxPages[0]^.GetControl("Loop"));	
		m_pxUseObjQuery=cast<CCheckBox>(m_apxPages[0]^.GetControl("UseObjSel"));	
		m_pxUseObjQuery^.m_xOnStateChange=OnChangeUseObjQuery;
		m_pxObjSelector=cast<CActionObjSelector>(m_apxPages[0]^.GetControl("ObjSel"));	
		m_pxObjSelector^.Init(p_xGuid);
		
		FillTreeRec(null,^(m_xParticleData.GetRoot()));
		OnChangeUseObjQuery();
	endconstructor;
	
	export destructor()		
	enddestructor;
	
	proc bool OnChangeUseObjQuery()
		if(m_pxUseObjQuery^.GetCheckMark())then
			m_pxObjSelector^.SetDisabled(false);
			m_pxPos^.SetDisabled(true);
			m_pxRot^.SetDisabled(true);
		else
			m_pxObjSelector^.SetDisabled(true);
			m_pxPos^.SetDisabled(false);
			m_pxRot^.SetDisabled(false);
		endif;
		return true;
	endproc;
	
	proc void FillTreeRec(^CTreeCtrl2.CNode p_pxParent,^CPropDB.CNode p_pxNode)		
		if(p_pxNode==null)then
			return;
		endif;
		var int i,iC=p_pxNode^.NumSubs();
		if(iC==1)then
			var ^CPropDB.CNode pxTmp=^(p_pxNode^.Get(0));
			if(pxTmp^.Name()=="length")then
				return;
			endif;
		endif;
		for(i=0)cond(i<iC)iter(i++)do
			var ^CPropDB.CNode pxWalk=^(p_pxNode^.Get(i));
			var ^CTreeCtrl2.CNode pxNode=m_pxEffectTree^.AddItem(p_pxParent,pxWalk^.Name());
			FillTreeRec(pxNode,pxWalk);
		endfor;
	endproc;
	
	export proc void OnInit(ref CAttribs p_rxParams)
		var string sEffectPath=p_rxParams.GetValue("effect_path");
		SelectEffectPath(sEffectPath);
		
		m_pxPos^.SetText(p_rxParams.GetValue("pos"));
		m_pxRot^.SetText(p_rxParams.GetValue("rot"));
		m_pxLoopValue^.SetValue(p_rxParams.GetValueInt("loop_value"));	
		if(p_rxParams.GetValueBool("use_objquery"))then
			m_pxUseObjQuery^.SetChecked(1);
		else
			m_pxUseObjQuery^.SetChecked(0);
		endif;		
		m_pxObjSelector^.OnInit(p_rxParams);	
	endproc;

	export proc void OnFinish(ref CAttribs po_rxParams)
		var string sEffectPath;
		GetSelectedEffectPath(m_pxEffectTree^.GetSelectedItem(),sEffectPath);
			
		po_rxParams.SetValue("effect_path",sEffectPath);
		po_rxParams.SetValue("pos",m_pxPos^.GetText());
		po_rxParams.SetValue("rot",m_pxRot^.GetText());
		po_rxParams.SetValue("loop_value",m_pxLoopValue^.GetValueInt());
		po_rxParams.SetValue("use_objquery",m_pxUseObjQuery^.GetCheckMark());
		m_pxObjSelector^.OnFinish(po_rxParams);	
	endproc;
	
	proc void SelectEffectPath(string p_sEffectPath)
		var ^CTreeCtrl2.CNode pxCur=m_pxEffectTree^.GetRootItem();
		if(pxCur==null)then return; endif;
		var array string asTokens;
		p_sEffectPath.Split(asTokens,"/",true);
		var int i,iC=asTokens.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var string sToken=asTokens[i];
			var ^CTreeCtrl2.CNode pxNext=null;
			var int j,jC=pxCur^.NumChildren();
			for(j=0)cond(j<jC)iter(j++)do
				var ^CTreeCtrl2.CNode pxChild=^(pxCur^.Child(j));
				if(pxChild^.GetText()==sToken)then
					pxNext=pxChild;
					break;
				endif;						
			endfor;
			if(pxNext==null)then
				break;					
			endif;
			pxCur=pxNext;
		endfor;
		m_pxEffectTree^.Select(pxCur);
		m_pxEffectTree^.EnsureVisible(pxCur);
	endproc;
	
	proc void GetSelectedEffectPath(^CTreeCtrl2.CNode p_pxNode,ref string po_rsPath)
		if(p_pxNode==null)then
			return;
		endif;
		po_rsPath=m_pxEffectTree^.GetItemText(p_pxNode)+"/"+po_rsPath;
		var ^CTreeCtrl2.CNode pxParent=p_pxNode^.GetParent();
		GetSelectedEffectPath(pxParent,po_rsPath);
	endproc;	
	
endclass;
