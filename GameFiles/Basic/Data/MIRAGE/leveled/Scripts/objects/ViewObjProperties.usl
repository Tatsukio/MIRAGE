class CViewObjProperties inherit CEnhancedFrameWindow

	var ^CTabCtrl 									m_pxTabCtrl;

	var ^COPGeneralProperties				m_pxGeneralProperties;
	var ^COPInventoryProperties			m_pxInventoryProperties;
	var ^COPInfoObjectProperties		m_pxInfoObjectProperties;
	var ^COPResourceProperties			m_pxResourceProperties;
	var ^COPBuildingProperties			m_pxBuildingProperties;
	var ^COPAnimalProperties				m_pxAnimalProperties;
	var ^COPNestProperties					m_pxNestProperties;
	var ^CViewSPPropertiesA					m_pxStartingPointProperties1;
//	var ^CViewSPPropertiesB					m_pxStartingPointProperties2;
	var ^CViewSPPropertiesC					m_pxStartingPointProperties3;
	var ^COPLightProperties					m_pxLightProperties;
	var ^COPLinkProperties					m_pxLinkProperties;
	var ^CPassengerPropertyPage			m_pxPassengerPropertyPage;
	var ^CTTFilterPropertyPage			m_pxTTFilterPropertyPage;
	var ^COPItemProperties					m_pxItemProps;
	var ^COPItemSpawnProperties			m_pxItemSpawnProps;
	var ^COPFountainProperties			m_pxFountainProps;
	var ^COPLakeOfDamageProperties	m_pxLakeOfDamageProps;
	var ^COPLakeOfLavaProperties		m_pxLakeOfLavaProps;
	var CFourCC											m_xLastSelectedType;
	var ^CRegionProperties					m_pxRegionProperties;
	var ^CMoveObjects								m_pxMoveObjects;
	
	export constructor()

		var ^CDesktop pxDesktop = CClientWrap.GetDesktop();

		if(!InitFromResource("objects/ViewObjProperties","ObjProperties"))then
			CClientWrap.LogInfo("Error","CViewObjProperties: InitFromResource failed");
			return;
		endif;

		m_pxGeneralProperties = new COPGeneralProperties();
		m_pxInventoryProperties = new COPInventoryProperties();
		m_pxInfoObjectProperties = new COPInfoObjectProperties();
		m_pxResourceProperties = new COPResourceProperties();
		m_pxStartingPointProperties1 = new CViewSPPropertiesA();
//		m_pxStartingPointProperties2 = new CViewSPPropertiesB();
		m_pxStartingPointProperties3 = new CViewSPPropertiesC();
		m_pxBuildingProperties = new COPBuildingProperties();
		m_pxLightProperties = new COPLightProperties();
		m_pxLinkProperties = new COPLinkProperties();
		m_pxAnimalProperties = new COPAnimalProperties();
		m_pxNestProperties = new COPNestProperties();
		m_pxPassengerPropertyPage= new CPassengerPropertyPage();
		m_pxTTFilterPropertyPage= new CTTFilterPropertyPage();
		m_pxItemProps = new COPItemProperties();
		m_pxItemSpawnProps = new COPItemSpawnProperties;
		m_pxFountainProps = new COPFountainProperties();
		m_pxLakeOfDamageProps = new COPLakeOfDamageProperties();
		m_pxLakeOfLavaProps = new COPLakeOfLavaProperties();
		m_pxRegionProperties = new CRegionProperties();
		m_pxMoveObjects = new CMoveObjects();
		m_pxStartingPointProperties1^.m_xOnDemandUpdate = SoftUpdateTabs;
		m_pxGeneralProperties^.m_xOnDemandUpdate = SoftUpdateTabs;
		m_pxTabCtrl = cast<CTabCtrl>(GetControl("TabCtrlCategories"));
		m_pxTabCtrl^.AddTab(" General ",m_pxGeneralProperties,false);
//		m_pxTabCtrl^.AddTab(" Moving ",m_pxMoveObjects,false);
		SetDisabled(true);
		LoadPosition("ObjProperties");
	endconstructor;
	
	export destructor()
		m_pxTabCtrl^.RemoveAllTabs();
		m_pxInventoryProperties^.Destroy();
		m_pxInfoObjectProperties^.Destroy();
		m_pxResourceProperties^.Destroy();
		m_pxStartingPointProperties1^.Destroy();
		m_pxStartingPointProperties3^.Destroy();
		m_pxBuildingProperties^.Destroy();
		m_pxLightProperties^.Destroy();
		m_pxLinkProperties^.Destroy();
		m_pxAnimalProperties^.Destroy();
		m_pxNestProperties^.Destroy();
		m_pxPassengerPropertyPage^.Destroy();
		m_pxTTFilterPropertyPage^.Destroy();
		m_pxItemProps^.Destroy();
		m_pxItemSpawnProps^.Destroy();
		m_pxGeneralProperties^.Destroy();
		m_pxFountainProps^.Destroy();
		m_pxLakeOfDamageProps^.Destroy();
		m_pxLakeOfLavaProps^.Destroy();
		m_pxRegionProperties^.Destroy();
		m_pxMoveObjects^.Destroy();
	enddestructor;

	export proc bool ClearTabs()
		m_pxGeneralProperties^.Clear();
		m_pxInfoObjectProperties^.Clear();
		m_pxResourceProperties^.Clear();
		m_pxBuildingProperties^.Clear();
		m_pxAnimalProperties^.Clear();
		m_pxNestProperties^.Clear();
		m_pxStartingPointProperties1^.Clear();
//		m_pxStartingPointProperties2^.Clear();
		m_pxStartingPointProperties3^.Clear();
		m_pxLightProperties^.Clear();
		m_pxLinkProperties^.Clear();
		m_pxItemSpawnProps^.Clear();
		m_pxFountainProps^.Clear();
		m_pxLakeOfDamageProps^.Clear();
		m_pxLakeOfLavaProps^.Clear();
		m_pxRegionProperties^.Clear();
		m_pxMoveObjects^.Clear();
		return(true);
	endproc;

	export proc bool SoftUpdateTabs(bool p_bNotSelfUpdate)
		KLog.LogSpam("StartLocation","SoftUpdateTabs("+p_bNotSelfUpdate.ToString()+")");
		var CFourCC xObjType;
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		if(pxSel==null)then return(false);endif;
		var int i,iC=pxSel^.NumEntries();
		if(iC==0)then return(false);endif;
		xObjType=(pxSel^)[0].GetObj()^.GetType();
		if(iC>1)then
			for(i=1)cond(i<iC)iter(i++)do
				var CClntHndl xObj=(pxSel^)[i];
				var CFourCC xType=xObj.GetObj()^.GetType();
				if(xType!=xObjType)then
					xObjType="DIFF";
					break;
				endif;
			endfor;
		endif;
		m_pxGeneralProperties^.Update(p_bNotSelfUpdate);
		if(xObjType!="SLOC")then
			m_pxTTFilterPropertyPage^.Update();
		endif;
		if(xObjType=="DIFF")then
		elseif(xObjType=="CHTR")then
			m_pxAnimalProperties^.Update();
		elseif(xObjType=="BLDG")then
			m_pxAnimalProperties^.Update();
			m_pxBuildingProperties^.Update();
		elseif(xObjType=="ANML")then
			m_pxAnimalProperties^.Update();
			m_pxPassengerPropertyPage^.Update();
		elseif(xObjType=="VHCL")then
			m_pxAnimalProperties^.Update();
			m_pxPassengerPropertyPage^.Update();
		elseif(xObjType=="SHIP")then
			m_pxAnimalProperties^.Update();
			m_pxPassengerPropertyPage^.Update();
		elseif(xObjType=="NEST")then
			m_pxNestProperties^.Update();
			m_pxRegionProperties^.Update();
		elseif(xObjType=="INFO")then
			m_pxInfoObjectProperties^.Update();
		elseif(xObjType=="SLOC")then
			m_pxStartingPointProperties1^.Update();
//			m_pxStartingPointProperties2^.Update();
			m_pxStartingPointProperties3^.Update();
		elseif(xObjType=="STON" || xObjType=="FOOD" || xObjType=="FRUI" || xObjType=="WOOD")then
			m_pxResourceProperties^.Update();
		elseif(xObjType=="LGHT")then
			m_pxLightProperties^.Update();
		elseif(xObjType == "ITEM")then
			m_pxItemProps^.Update();
		elseif(xObjType=="ITSP")then
			m_pxItemSpawnProps^.Update();
		elseif(xObjType=="FNTN")then
			m_pxFountainProps^.Update();
		elseif(xObjType=="DMGL")then
			m_pxLakeOfDamageProps^.Update();
		elseif(xObjType=="LAVA")then
			m_pxLakeOfLavaProps^.Update();
		endif;
		m_pxMoveObjects^.Update();
		return(true);
	endproc;

	export proc bool UpdateTabs()
//		m_pxTabCtrl^.RemoveAllTabs();
		var CFourCC xObjType;
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		if(pxSel==null)then
			m_pxTabCtrl^.RemoveAllTabs();
			return(false);
		endif;
		var int i,iC=pxSel^.NumEntries();
		if(iC==0)then
			m_pxTabCtrl^.RemoveAllTabs();
			return(false);
		endif;
		if((pxSel^)[0].GetObj()==null)then
			m_pxTabCtrl^.RemoveAllTabs();
			return(false);
		endif;
		xObjType=(pxSel^)[0].GetObj()^.GetType();
		if(iC>1)then
			for(i=1)cond(i<iC)iter(i++)do
				var CClntHndl xObj=(pxSel^)[i];
				if(xObj.GetObj()==null)then return(false);endif;
				var CFourCC xType=xObj.GetObj()^.GetType();
				if(xType!=xObjType)then
					xObjType="DIFF";
					break;
				endif;
			endfor;
		endif;
		var bool bNew=false;
		if(!(m_xLastSelectedType==xObjType))then
			m_pxTabCtrl^.RemoveAllTabs();
			bNew=true;
		endif;
		if(bNew)then
			m_pxTabCtrl^.AddTab(" General ",m_pxGeneralProperties,false);
			m_pxTabCtrl^.AddTab(" Links ",m_pxLinkProperties,false);
		endif;
		m_pxGeneralProperties^.Update(true);
		m_pxLinkProperties^.Update(true);
		if(xObjType!="SLOC")then
			if(bNew)then
				m_pxTabCtrl^.AddTab(" TTFilter ",m_pxTTFilterPropertyPage,false);
			endif;
			m_pxTTFilterPropertyPage^.Update();
		endif;
		if(xObjType=="DIFF")then
		elseif(xObjType=="CHTR")then
			if(bNew)then
				m_pxTabCtrl^.AddTab(" Character ",m_pxAnimalProperties,false);
			endif;
			m_pxAnimalProperties^.Update();
		elseif(xObjType=="BLDG")then
			if(bNew)then
				m_pxTabCtrl^.AddTab(" Building ",m_pxAnimalProperties,false);
				m_pxTabCtrl^.AddTab(" Gate ",m_pxBuildingProperties,false);
			endif;
			m_pxAnimalProperties^.Update();
			m_pxBuildingProperties^.Update();
		elseif(xObjType=="ANML")then
			if(bNew)then
				m_pxTabCtrl^.AddTab(" Animal ",m_pxAnimalProperties,false);
				m_pxTabCtrl^.AddTab(" Passenger ",m_pxPassengerPropertyPage,false);
			endif;
			m_pxAnimalProperties^.Update();
			m_pxPassengerPropertyPage^.Update();
		elseif(xObjType=="VHCL")then
			if(bNew)then
				m_pxTabCtrl^.AddTab(" Vehicle ",m_pxAnimalProperties,false);
				m_pxTabCtrl^.AddTab(" Passenger ",m_pxPassengerPropertyPage,false);
			endif;
			m_pxAnimalProperties^.Update();
			m_pxPassengerPropertyPage^.Update();
		elseif(xObjType=="SHIP")then
			if(bNew)then
				m_pxTabCtrl^.AddTab(" Ship ",m_pxAnimalProperties,false);
				m_pxTabCtrl^.AddTab(" Passenger ",m_pxPassengerPropertyPage,false);
			endif;
			m_pxAnimalProperties^.Update();
			m_pxPassengerPropertyPage^.Update();
		elseif(xObjType=="NEST")then
			if(bNew)then
				m_pxTabCtrl^.AddTab(" Nest ",m_pxNestProperties,false);
				m_pxTabCtrl^.AddTab(" Nest++ ",m_pxRegionProperties,false);
			endif;
			m_pxNestProperties^.Update();
			m_pxRegionProperties^.Update();
		elseif(xObjType=="INFO")then
			if(bNew)then
				m_pxTabCtrl^.AddTab(" InfoObject ",m_pxInfoObjectProperties,false);
			endif;
			m_pxInfoObjectProperties^.Update();
		elseif(xObjType=="SLOC")then
			if(bNew)then
				m_pxTabCtrl^.AddTab(" StartingPoint1 ",m_pxStartingPointProperties1,false);
				m_pxTabCtrl^.AddTab(" StartingPoint2 ",m_pxStartingPointProperties3,false);
			endif;
//			m_pxTabCtrl^.AddTab(" StartingPoint2 ",m_pxStartingPointProperties2);
			m_pxStartingPointProperties1^.Update();
//			m_pxStartingPointProperties2^.Update();
			m_pxStartingPointProperties3^.Update();
		elseif(xObjType=="ITSP")then
			if(bNew)then
				m_pxTabCtrl^.AddTab(" Items ",m_pxItemSpawnProps,false);
			endif;
			m_pxItemSpawnProps^.Update();
		elseif(xObjType=="STON" || xObjType=="FOOD" || xObjType=="FRUI" || xObjType=="WOOD")then
			if(bNew)then
				m_pxTabCtrl^.AddTab(" Resource ",m_pxResourceProperties,false);
			endif;
			m_pxResourceProperties^.Update();
		elseif(xObjType=="LGHT")then
			if(bNew)then
				m_pxTabCtrl^.AddTab(" Light ",m_pxLightProperties,false);
			endif;
			m_pxLightProperties^.Clear();
			m_pxLightProperties^.Update();
		elseif(xObjType == "ITEM")then
			if(bNew)then
				m_pxTabCtrl^.AddTab(" Item ", m_pxItemProps,false);
			endif;
			m_pxItemProps^.Update();
		elseif(xObjType == "FNTN")then
			if(bNew)then
				m_pxTabCtrl^.AddTab(" Fountain ", m_pxFountainProps, false);
			endif;
			m_pxFountainProps^.Update();
		elseif(xObjType=="DMGL")then
			if(bNew)then
				m_pxTabCtrl^.AddTab(" Lake'O'Dmg ", m_pxLakeOfDamageProps, false);
			endif;
			m_pxLakeOfDamageProps^.Update();
		elseif(xObjType=="LAVA")then
			if(bNew)then
				m_pxTabCtrl^.AddTab(" Lake'O'Lava ", m_pxLakeOfLavaProps, false);
			endif;
			m_pxLakeOfLavaProps^.Update();
		endif;
		if(bNew)then
			m_pxTabCtrl^.AddTab(" Moving ",m_pxMoveObjects,false);
		endif;
		m_pxMoveObjects^.Update();
		if(m_xLastSelectedType==xObjType)then
			//Suit TabCtrl sucks!
		endif;
		m_xLastSelectedType=xObjType;
		return(true);
	endproc;

	export proc bool Clear();
		ClearTabs();
		return(true);
	endproc;

	export proc bool Update();
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		var int iNumSel=pxSel^.NumEntries();
		if(iNumSel==0)then
			SetDisabled(true);
			ClearTabs();
			return true;
		elseif(iNumSel>0)then
			SetDisabled(false);
			UpdateTabs();
		endif;
		return(true);
	endproc;

endclass;

class COPGeneralProperties inherit CFrameWindow

	var ^CEdit				m_pxNameEdit;
	var ^CCheckBox			m_pxVisible;
	var ^CCheckBox			m_pxConstructible;
	var ^CCheckBox			m_pxDestructible;
	var ^CCheckBox			m_pxSelectable;
	var ^CCheckBox			m_pxHitable;
	var ^CCheckBox			m_pxDismantable;
	var ^CCheckBox			m_pxBlocker;
	var ^CCheckBox			m_pxParticle;
	var ^CCheckBox			m_pxCameraBlocker;
	var ^CCheckBox			m_pxDisableShadowCast;
	var ^CCheckBox			m_pxDisableShadowReceive;

	var ^CDropList			m_pxType,m_pxTribe;
	var array ^CRadioButton	m_apxOwner;

	export var procref<bool,bool> m_xOnDemandUpdate;

	export constructor()
		var ^CDesktop pxDesktop = CClientWrap.GetDesktop();
		if(!InitFromResource("objects/ViewObjProperties","GeneralProperties"))then
			CClientWrap.LogInfo("Error","COPGeneralProperties: InitFromResource failed");
			return;
		endif;

		m_pxNameEdit=cast<CEdit>(GetControl("GeneralFlags/NameEdit"));
		m_pxNameEdit^.m_xOnUpdate=OnChangeName;
		m_pxNameEdit^.SetReadOnly(false);
		m_pxVisible=cast<CCheckBox>(GetControl("GeneralFlags/FlagVisible"));
		m_pxVisible^.m_xOnStateChange=OnChangeVisible;
		m_pxConstructible=cast<CCheckBox>(GetControl("GeneralFlags/FlagConstructible"));
		m_pxConstructible^.m_xOnStateChange=OnChangeConstructible;
		m_pxDestructible=cast<CCheckBox>(GetControl("GeneralFlags/FlagDestructible"));
		m_pxDestructible^.m_xOnStateChange=OnChangeDestructible;
		m_pxSelectable=cast<CCheckBox>(GetControl("GeneralFlags/FlagSelectable"));
		m_pxSelectable^.m_xOnStateChange=OnChangeSelectable;
		m_pxHitable=cast<CCheckBox>(GetControl("GeneralFlags/FlagHitable"));
		m_pxHitable^.m_xOnStateChange=OnChangeHitable;
		m_pxDismantable=cast<CCheckBox>(GetControl("GeneralFlags/FlagDismantable"));
		m_pxDismantable^.m_xOnStateChange=OnChangeDismantable;
		m_pxBlocker=cast<CCheckBox>(GetControl("GeneralFlags/FlagBlocker"));
//		m_pxBlocker^.m_xOnStateChange=OnChangeBlocker;
		m_pxParticle=cast<CCheckBox>(GetControl("GeneralFlags/FlagParticle"));
		m_pxParticle^.m_xOnStateChange=OnChangeParticle;
		m_pxCameraBlocker=cast<CCheckBox>(GetControl("GeneralFlags/FlagCameraBlocker"));
		m_pxCameraBlocker^.m_xOnStateChange=OnCameraBlocker;
		m_pxDisableShadowCast=cast<CCheckBox>(GetControl("GeneralFlags/FlagDisableShadowCast"));
		m_pxDisableShadowCast^.m_xOnStateChange=OnDisableShadowCast;
		m_pxDisableShadowReceive=cast<CCheckBox>(GetControl("GeneralFlags/FlagDisableShadowReceive"));
		m_pxDisableShadowReceive^.m_xOnStateChange=OnDisableShadowReceive;

		

		m_pxType=cast<CDropList>(GetControl("GeneralFlags2/TypeDroplist"));
		m_pxType^.AddItem("None");
		m_pxType^.AddItem(CLocalizer.Get().Translate("_ViewObjProperties_DL_Character"));
		m_pxType^.AddItem(CLocalizer.Get().Translate("_ViewObjProperties_DL_Building"));
		m_pxType^.AddItem(CLocalizer.Get().Translate("_ViewObjProperties_DL_Vegetation"));
		m_pxType^.AddItem(CLocalizer.Get().Translate("_ViewObjProperties_DL_Tree"));
		m_pxType^.AddItem(CLocalizer.Get().Translate("_ViewObjProperties_DL_Animal"));
		m_pxType^.AddItem(CLocalizer.Get().Translate("_ViewObjProperties_DL_Region"));
		m_pxType^.AddItem(CLocalizer.Get().Translate("_ViewObjProperties_DL_Light"));
		m_pxType^.AddItem(CLocalizer.Get().Translate("_ViewObjProperties_DL_Item"));
		m_pxType^.Select(0);
		m_pxType^.m_xOnChange=OnChangeType;

		m_pxTribe=cast<CDropList>(GetControl("GeneralFlags2/TribeDroplist"));
		m_pxTribe^.AddItem("None");
		m_pxTribe^.AddItem("World");
		m_pxTribe^.AddItem("Hu");
		m_pxTribe^.AddItem("Aje");
		m_pxTribe^.AddItem("Ninigi");
		m_pxTribe^.AddItem("Special");
		m_pxTribe^.AddItem("SEAS");
		m_pxTribe^.m_xOnChange=OnChangeTribe;

		m_apxOwner=9;

		var int i;
		for(i=0)cond(i<m_apxOwner.NumEntries())iter(i++)do
			m_apxOwner[i]=cast<CRadioButton>(GetControl("GeneralFlags2/RadioButton"+i.ToString()));
			m_apxOwner[i]^.m_xOnChange=OnChangeOwner;
		endfor;

		m_xOnDemandUpdate = OnDemandUpdate;

	endconstructor;

	proc bool OnDemandUpdate(bool p_b)
		return true;
	endproc;

	export proc void Update(bool p_bNotSelfUpdate)
		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		var ^CObj pxObj=(pxSel^)[0].GetObj();

		//Name
		if(pxSel^.NumEntries()==1)then
			m_pxNameEdit^.SetDisabled(false);
			m_pxNameEdit^.SetText(pxObj^.GetName());
		else
			m_pxNameEdit^.SetDisabled(true);
			m_pxNameEdit^.SetText(pxSel^.NumEntries().ToString()+" Objects selected.");
		endif;

		var int iConstructible, iDeconstructible, iVisible, iDestructible, iHitable, iSelectable, iPFBlocker,iParticle,iCameraBlocker;
		var int iDisableShadowCast,iDisableShadowReceive;
		
		iConstructible=iDeconstructible=iVisible=iDestructible=iHitable=iSelectable=iPFBlocker=iParticle=iCameraBlocker=0;
		iDisableShadowCast=iDisableShadowReceive=0;
		
		if(pxObj^.IsConstructible())then iConstructible = 1; endif;
		if(pxObj^.IsDeconstructible())then iDeconstructible = 1; endif;
		if(pxObj^.GetVisibleMask()!=0h)then iVisible = 1; endif;
		if(pxObj^.IsDestructible())then iDestructible = 1; endif;
		if(pxObj^.IsHitable())then iHitable = 1; endif;
		if(pxObj^.IsSelectable())then iSelectable = 1; endif;
		if(pxObj^.IsPFBlocker())then iPFBlocker = 1; endif;
		if(!pxObj^.GetNoParticles())then iParticle = 1; endif;
		if(IsCameraBlocker(pxObj))then iCameraBlocker = 1; endif;
		if(pxObj^.IsDisableShadowCast())then iDisableShadowCast=1; endif;
		if(pxObj^.IsDisableShadowReceive())then iDisableShadowReceive=1; endif;
		
		var int i,iC=pxSel^.NumEntries();
		for(i=1)cond(i<iC)iter(i++)do
			pxObj=(pxSel^)[i].GetObj();

			if(iConstructible < 2)then
				if(( pxObj^.IsConstructible()  &&  iConstructible == 0)  ||
					(!pxObj^.IsConstructible()  &&  iConstructible == 1))then
					iConstructible = 2;
				endif;
			endif;

			if(iDeconstructible < 2)then
				if(( pxObj^.IsDeconstructible()  &&  iDeconstructible == 0)  ||
					(!pxObj^.IsDeconstructible()  &&  iDeconstructible == 1))then
					iDeconstructible = 2;
				endif;
			endif;

			if(iVisible < 2)then
				if(( (pxObj^.GetVisibleMask()!=0h)  &&  iVisible == 0)  ||
					(!(pxObj^.GetVisibleMask()!=0h)  &&  iVisible == 1))then
					iVisible = 2;
				endif;
			endif;

			if(iDestructible < 2)then
				if(( pxObj^.IsDestructible()  &&  iDestructible == 0)  ||
					(!pxObj^.IsDestructible()  &&  iDestructible == 1))then
					iDestructible = 2;
				endif;
			endif;

			if(iHitable < 2)then
				if(( pxObj^.IsHitable()  &&  iHitable == 0)  ||
					(!pxObj^.IsHitable()  &&  iHitable == 1))then
					iHitable = 2;
				endif;
			endif;

			if(iSelectable < 2)then
				if(( pxObj^.IsSelectable()  &&  iSelectable == 0)  ||
					(!pxObj^.IsSelectable()  &&  iSelectable == 1))then
					iSelectable = 2;
				endif;
			endif;

			if(iDisableShadowCast < 2)then
				if( (pxObj^.IsDisableShadowCast() && iDisableShadowCast == 0) ||
					(!pxObj^.IsDisableShadowCast() && iDisableShadowCast == 1) )then
						iDisableShadowCast=2;
				endif;
			endif;

			if(iDisableShadowReceive < 2)then
				if( (pxObj^.IsDisableShadowReceive() && iDisableShadowReceive == 0) ||
					(!pxObj^.IsDisableShadowReceive() && iDisableShadowReceive == 1) )then
						iDisableShadowReceive=2;
				endif;
			endif;
			
			if(iPFBlocker < 2)then
				if(( pxObj^.IsPFBlocker()  &&  iPFBlocker == 0)  ||
					(!pxObj^.IsPFBlocker()  &&  iPFBlocker == 1))then
					iPFBlocker = 2;
				endif;
			endif;
			

		endfor;

		if(iConstructible!=m_pxConstructible^.GetChecked())then
			m_pxConstructible^.SetTristate(iConstructible > 1);
			m_pxConstructible^.SetChecked(iConstructible);
		endif;

		if(iDestructible!=m_pxDestructible^.GetChecked())then
			m_pxDestructible^.SetTristate(iDestructible > 1);
			m_pxDestructible^.SetChecked(iDestructible);
		endif;

		if(iVisible!=m_pxVisible^.GetChecked())then
			m_pxVisible^.SetTristate(iVisible > 1);
			m_pxVisible^.SetChecked(iVisible);
		endif;

		if(iDeconstructible!=m_pxDismantable^.GetChecked())then
			m_pxDismantable^.SetTristate(iDeconstructible > 1);
			m_pxDismantable^.SetChecked(iDeconstructible);
		endif;

		if(iHitable!=m_pxHitable^.GetChecked())then
			m_pxHitable^.SetTristate(iHitable > 1);
			m_pxHitable^.SetChecked(iHitable);
		endif;

		if(iSelectable!=m_pxSelectable^.GetChecked())then
			m_pxSelectable^.SetTristate(iSelectable > 1);
			m_pxSelectable^.SetChecked(iSelectable);
		endif;

		if(iPFBlocker!=m_pxBlocker^.GetChecked())then
			m_pxBlocker^.SetTristate(iPFBlocker > 1);
			m_pxBlocker^.SetChecked(iPFBlocker);
		endif;
		m_pxBlocker^.m_xOnStateChange=OnChangeBlocker;
		
		if(iParticle!=m_pxParticle^.GetChecked())then
			m_pxParticle^.SetTristate(iParticle>1);
			m_pxParticle^.SetChecked(iParticle);
		endif;
		
		if(iDisableShadowCast!=m_pxDisableShadowCast^.GetChecked())then
			m_pxDisableShadowCast^.SetTristate(iDisableShadowCast > 1);
			m_pxDisableShadowCast^.SetChecked(iDisableShadowCast);
		endif;

		if(iDisableShadowReceive!=m_pxDisableShadowReceive^.GetChecked())then
			m_pxDisableShadowReceive^.SetTristate(iDisableShadowReceive > 1);
			m_pxDisableShadowReceive^.SetChecked(iDisableShadowReceive);
		endif;
			
		if(iCameraBlocker!=m_pxCameraBlocker^.GetChecked())then
			m_pxCameraBlocker^.SetTristate(iCameraBlocker>1);
			m_pxCameraBlocker^.SetChecked(iCameraBlocker);
		endif;
		
		//Type
		var CFourCC xType=pxObj^.GetType();
		if(xType=="CHTR")then
			m_pxType^.SetText("Character");
		elseif(xType=="BLDG")then
			m_pxType^.SetText("Building");
		elseif(xType=="VGTN")then
			m_pxType^.SetText("Vegetation");
		elseif(xType=="TREE")then
			m_pxType^.SetText("Tree");
		elseif(xType=="ANML")then
			m_pxType^.SetText("Animal");
		elseif(xType=="REGN")then
			m_pxType^.SetText("Region");
		elseif(xType=="LGHT")then
			m_pxType^.SetText("Light");
		elseif(xType=="ITEM")then
			m_pxType^.SetText("Item");
		else
			m_pxType^.SetText("None");
		endif;

		var ^CAttribs pxAttribs=pxObj^.GetAttribs();
		if(pxAttribs!=null)then
			var string sTribe=pxAttribs^.GetValue("tribe");
			if(sTribe.IsEmpty())then
				sTribe="None";
			endif;
			m_pxTribe^.SetText(sTribe);
		endif;
		m_pxTribe^.SetDisabled(pxAttribs==null);

		//Owner
		//CClientWrap.LogWarning("Info","Owner: "+pxObj^.GetOwner().ToString());
		var int iOwner = pxObj^.GetOwner();
		if(p_bNotSelfUpdate && iOwner >= -1 && iOwner < 8)then
			if(!m_apxOwner[pxObj^.GetOwner()+1]^.GetSelected())then
				m_apxOwner[pxObj^.GetOwner()+1]^.SetSelected(true);
			endif;
		endif;

	endproc;

	export proc void Clear()
		m_pxNameEdit^.SetText(" ");
		m_pxVisible^.SetChecked(0);
		m_pxConstructible^.SetChecked(0);
		m_pxDestructible^.SetChecked(0);
		m_pxSelectable^.SetChecked(0);
		m_pxHitable^.SetChecked(0);
		m_pxDismantable^.SetChecked(0);
		m_pxBlocker^.m_xOnStateChange.Clear();
		m_pxBlocker^.SetChecked(0);
		m_pxParticle^.SetChecked(0);
		m_pxCameraBlocker^.SetChecked(0);
		m_pxDisableShadowCast^.SetChecked(0);
		m_pxDisableShadowReceive^.SetChecked(0);
		m_pxType^.SetText("None");
		var int i;
		for(i=0)cond(i<m_apxOwner.NumEntries())iter(i++)do
			m_apxOwner[i]^.SetSelected(false);
		endfor;
	endproc;

	//Name EditControl
	proc bool OnChangeName()
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		var int i,iC=pxSel^.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xObj=(pxSel^)[i];
			xObj.GetObj()^.SetName(m_pxNameEdit^.GetText());
		endfor;
		return(true);
	endproc;

	proc bool OnChangeVisible()
		if(m_pxVisible^.GetChecked()==2)then return false; endif;
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		var int i,iC=pxSel^.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xObj=(pxSel^)[i];
			xObj.GetObj()^.SetVisible(m_pxVisible^.GetCheckMark());
		endfor;
		m_xOnDemandUpdate.Call(true);
		return(true);
	endproc;

	proc bool OnChangeConstructible()
		if(m_pxConstructible^.GetChecked()==2)then return false; endif;
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		var int i,iC=pxSel^.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xObj=(pxSel^)[i];
			xObj.GetObj()^.SetConstructible(m_pxConstructible^.GetCheckMark());
		endfor;
		m_xOnDemandUpdate.Call(true);
		return(true);
	endproc;

	proc bool OnChangeDestructible()
		if(m_pxDestructible^.GetChecked()==2)then return false; endif;
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		var int i,iC=pxSel^.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xObj=(pxSel^)[i];
			xObj.GetObj()^.SetDestructible(m_pxDestructible^.GetCheckMark());
		endfor;
		m_xOnDemandUpdate.Call(true);
		return(true);
	endproc;

	proc bool OnChangeSelectable()
		if(m_pxSelectable^.GetChecked()==2)then return false; endif;
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		var int i,iC=pxSel^.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xObj=(pxSel^)[i];
			xObj.GetObj()^.SetSelectable(m_pxSelectable^.GetCheckMark());
		endfor;
		m_xOnDemandUpdate.Call(true);
		return(true);
	endproc;

	proc bool OnChangeHitable()
		if(m_pxHitable^.GetChecked()==2)then return false; endif;
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		var int i,iC=pxSel^.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xObj=(pxSel^)[i];
			xObj.GetObj()^.SetHitable(m_pxHitable^.GetCheckMark());
		endfor;
		m_xOnDemandUpdate.Call(true);
		return(true);
	endproc;

	proc bool OnChangeDismantable()
		if(m_pxDismantable^.GetChecked()==2)then return false; endif;
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		var int i,iC=pxSel^.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xObj=(pxSel^)[i];
			xObj.GetObj()^.SetDeconstructible(m_pxDismantable^.GetCheckMark());
		endfor;
		m_xOnDemandUpdate.Call(true);
		return(true);
	endproc;

	proc bool OnChangeBlocker()
		if(m_pxBlocker^.GetChecked()==2)then return false; endif;
		var CClntHndl xInvalid;
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		var int i,iC=pxSel^.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xObj=(pxSel^)[i];
			CEvt_ObjLECommand.Send(xObj, "SetPFBBlocking", xInvalid, {0.0f, 0.0f, 0.0f}, m_pxBlocker^.GetCheckMark().ToString());
//			CEvt_GenericLongStringEvent.Send("UnblockObject\t"+m_pxBlocker^.GetCheckMark().ToString()+"\t"+xObj.GetObj()^.GetGuid().ToString());
			// RT#13585 -> use of method not allowed in USL
			// xObj.GetObj()^.SetPFBlocker(m_pxBlocker^.GetCheckMark());
		endfor;
//		m_xOnDemandUpdate.Call(true);
		return(true);
	endproc;
	
	proc bool OnChangeParticle()
		if(m_pxParticle^.GetChecked()==2)then return false; endif;
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		var int i,iC=pxSel^.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xObj=(pxSel^)[i];
			xObj.GetObj()^.SetNoParticles(!m_pxParticle^.GetCheckMark());
		endfor;
		m_xOnDemandUpdate.Call(true);
		return(true);
	endproc;
	
	proc bool OnDisableShadowCast()
		if(m_pxDisableShadowCast^.GetChecked()==2)then return false; endif;
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		var int i,iC=pxSel^.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xObj=(pxSel^)[i];
			xObj.GetObj()^.SetDisableShadowCast(m_pxDisableShadowCast^.GetCheckMark());
		endfor;
		m_xOnDemandUpdate.Call(true);
		return true;
	endproc;

	proc bool OnDisableShadowReceive()
		if(m_pxDisableShadowReceive^.GetChecked()==2)then return false; endif;
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		var int i,iC=pxSel^.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xObj=(pxSel^)[i];
			xObj.GetObj()^.SetDisableShadowReceive(m_pxDisableShadowReceive^.GetCheckMark());
		endfor;
		m_xOnDemandUpdate.Call(true);
		return true;
	endproc;

	proc bool OnCameraBlocker()
		if(m_pxCameraBlocker^.GetChecked()==2)then return false; endif;
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		var int i,iC=pxSel^.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xObj=(pxSel^)[i];
			var ^CAttribs pxAttr = pxSel^[i].GetObj()^.GetAttribs();
			if(pxAttr!=null)then
				pxAttr^.SetValue("IsCameraBlocker",m_pxCameraBlocker^.GetChecked());
				CEvt_UpdateAttribs.Send(pxSel^[i].GetObj()^.GetGuid());
			endif;
		endfor;
		m_xOnDemandUpdate.Call(true);
		return true;
	endproc;
	
	proc bool IsCameraBlocker(^CObj p_pxObj)
		if(p_pxObj!=null)then
			var ^CAttribs pxAttr=p_pxObj^.GetAttribs();
			if(pxAttr!=null)then
				var bool bReturn=pxAttr^.GetValueBool("IsCameraBlocker");
				return(bReturn);
			endif;	
		endif;
		return(false);
	endproc;
	
	
	proc bool OnChangeOwner()
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		var int i,j,iC=pxSel^.NumEntries();
		var int iOwner=(-1);
		for(j=0)cond(j<m_apxOwner.NumEntries())iter(j++)do
			if(m_apxOwner[j]^.GetSelected())then
				iOwner=j-1;
				for(i=0)cond(i<iC)iter(i++)do
					var CClntHndl xObj=(pxSel^)[i];
					CEvt_SetOwner.Send(xObj.GetObj()^.GetGuid(),iOwner);
				endfor;
			endif;
		endfor;
		m_xOnDemandUpdate.Call(false);
		return(true);
	endproc;

	proc bool OnChangeType()

		return(true);
	endproc;

	proc bool OnChangeTribe()
		var string sTribe=m_pxTribe^.GetText();
		if(sTribe=="None")then
			sTribe.Empty();
		endif;

		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		var int i,iC=pxSel^.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CObj pxObj=(pxSel^)[i].GetObj();
			if(pxObj!=null)then
				var ^CAttribs pxAttribs=pxObj^.GetAttribs();
				if(pxAttribs!=null)then
					pxAttribs^.SetValue("tribe",sTribe);
					CEvt_UpdateAttribs.Send(pxObj^.GetGuid());
				endif;
			endif;
		endfor;
		return true;
	endproc;

endclass;

class COPCharacterProperties inherit CFrameWindow

	var ^CSpinCtrlNumber			m_pxHitpoints;
	var ^CSpinCtrlNumber			m_pxMaxHitpoints;
	var ^CStaticCtrl				m_pxPercentHitpoints;

	var ^CSpinCtrlNumber			m_pxLevel;
	var ^CDropList					m_pxCaste;
	var ^CSpinCtrlNumber			m_pxExperience;

	var ^CStaticCtrl				m_pxSkill1Static;
	var ^CStaticCtrl				m_pxSkill2Static;

	var ^CDropList					m_pxSkill1;
	var ^CDropList					m_pxSkill2;

	var	^CToggleButton				m_pxSkill1Neg2;
	var	^CToggleButton				m_pxSkill1Neg1;
	var	^CToggleButton				m_pxSkill1Pos1;
	var	^CToggleButton				m_pxSkill1Pos2;

	var	^CToggleButton				m_pxSkill2Neg2;
	var	^CToggleButton				m_pxSkill2Neg1;
	var	^CToggleButton				m_pxSkill2Pos1;
	var	^CToggleButton				m_pxSkill2Pos2;

	var	^CStaticCtrl				m_pxSkill1Info;
	var	^CStaticCtrl				m_pxSkill2Info;

	var	^CCheckBox					m_pxCheckBoxRandom1;
	var	^CCheckBox					m_pxCheckBoxRandom2;

	export constructor()
		var ^CDesktop pxDesktop = CClientWrap.GetDesktop();
		if(!InitFromResource("objects/ViewObjProperties","CharacterProperties"))then
			CLevelEditorWrap.LogInfo("Info","COPCharacterProperties: InitFromResource failed");
			return;
		endif;

		m_pxHitpoints=cast<CSpinCtrlNumber>(GetControl("GroupHitpoints/SpinCtrlActualHitpoints"));
		m_pxHitpoints^.SetLimits(0,10000,1);
		m_pxHitpoints^.m_xOnChange=OnHitpointsChange;
		m_pxMaxHitpoints=cast<CSpinCtrlNumber>(GetControl("GroupHitpoints/SpinCtrlMaxHitpoints"));
		m_pxMaxHitpoints^.m_xOnChange=OnMaxHitpointsChange;
		m_pxMaxHitpoints^.SetLimits(0,10000,1);
		m_pxPercentHitpoints=cast<CStaticCtrl>(GetControl("GroupHitpoints/StaticPercentHitpoints2"));

		m_pxLevel=cast<CSpinCtrlNumber>(GetControl("GroupStats/SpinCtrlLevel"));
		m_pxLevel^.SetLimits(1,5,1);
		m_pxLevel^.m_xOnChange=OnLevelChange;
		m_pxCaste=cast<CDropList>(GetControl("GroupStats/DropListCaste"));
		m_pxCaste^.AddItem("Res");
		m_pxCaste^.AddItem("Nat");
		m_pxCaste^.AddItem("Tec");
		m_pxCaste^.m_xOnChange=OnCasteChange;

		m_pxExperience=cast<CSpinCtrlNumber>(GetControl("GroupStats/SpinCtrlExperience"));
		m_pxExperience^.m_xOnChange=OnExperienceChange;
		m_pxExperience^.SetLimits(0,10000,1);

		m_pxSkill1Static=cast<CStaticCtrl>(GetControl("GroupFirstSkill/StaticSkill"));
		m_pxSkill2Static=cast<CStaticCtrl>(GetControl("GroupSecondSkill/StaticSkill"));

		m_pxSkill1=cast<CDropList>(GetControl("GroupFirstSkill/DropListSkill"));
		m_pxSkill1^.AddItem("None");
		m_pxSkill1^.AddItem("Intelligence");
		m_pxSkill1^.AddItem("Strength");
		m_pxSkill1^.AddItem("Diligence");
		m_pxSkill1^.m_xOnChange=OnSkillChange1;

		m_pxSkill2=cast<CDropList>(GetControl("GroupSecondSkill/DropListSkill"));
		m_pxSkill2^.AddItem("None");
		m_pxSkill2^.AddItem("Intelligence");
		m_pxSkill2^.AddItem("Strength");
		m_pxSkill2^.AddItem("Diligence");
		m_pxSkill2^.m_xOnChange=OnSkillChange2;

		m_pxSkill1Neg2=cast<CToggleButton>(GetControl("GroupFirstSkill/Neg2Button"));
		m_pxSkill1Neg2^.m_xOnClick=OnSkillChange1;
		m_pxSkill1Neg1=cast<CToggleButton>(GetControl("GroupFirstSkill/Neg1Button"));
		m_pxSkill1Neg1^.m_xOnClick=OnSkillChange1;
		m_pxSkill1Pos1=cast<CToggleButton>(GetControl("GroupFirstSkill/Pos1Button"));
		m_pxSkill1Pos1^.m_xOnClick=OnSkillChange1;
		m_pxSkill1Pos2=cast<CToggleButton>(GetControl("GroupFirstSkill/Pos2Button"));
		m_pxSkill1Pos2^.m_xOnClick=OnSkillChange1;

		m_pxSkill2Neg2=cast<CToggleButton>(GetControl("GroupSecondSkill/Neg2Button"));
		m_pxSkill2Neg2^.m_xOnClick=OnSkillChange2;
		m_pxSkill2Neg1=cast<CToggleButton>(GetControl("GroupSecondSkill/Neg1Button"));
		m_pxSkill2Neg1^.m_xOnClick=OnSkillChange2;
		m_pxSkill2Pos1=cast<CToggleButton>(GetControl("GroupSecondSkill/Pos1Button"));
		m_pxSkill2Pos1^.m_xOnClick=OnSkillChange2;
		m_pxSkill2Pos2=cast<CToggleButton>(GetControl("GroupSecondSkill/Pos2Button"));
		m_pxSkill2Pos2^.m_xOnClick=OnSkillChange2;

		m_pxSkill1Neg2^.SetGrouped(true);
		m_pxSkill1Neg1^.SetGrouped(true);
		m_pxSkill1Pos1^.SetGrouped(true);
		m_pxSkill1Pos2^.SetGrouped(true);

		m_pxSkill2Neg2^.SetGrouped(true);
		m_pxSkill2Neg1^.SetGrouped(true);
		m_pxSkill2Pos1^.SetGrouped(true);
		m_pxSkill2Pos2^.SetGrouped(true);

		m_pxSkill1Info=cast<CStaticCtrl>(GetControl("GroupFirstSkill/StaticCurrent"));
		m_pxSkill2Info=cast<CStaticCtrl>(GetControl("GroupSecondSkill/StaticCurrent"));

		m_pxCheckBoxRandom1=cast<CCheckBox>(GetControl("GroupFirstSkill/CheckBoxRandom"));
		m_pxCheckBoxRandom1^.m_xOnStateChange=OnChangeRandom1;

		m_pxCheckBoxRandom2=cast<CCheckBox>(GetControl("GroupSecondSkill/CheckBoxRandom"));
		m_pxCheckBoxRandom2^.m_xOnStateChange=OnChangeRandom2;


	endconstructor;

	export proc void Update()
		m_pxHitpoints^.m_xOnChange.Clear();
		m_pxMaxHitpoints^.m_xOnChange.Clear();
		m_pxLevel^.m_xOnChange.Clear();
		m_pxExperience^.m_xOnChange.Clear();

		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		var	^CObj			pxObj=(pxSel^)[0].GetObj();

		var int i,iValue,iC=pxSel^.NumEntries();

		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xTemp=(pxSel^)[i];
			var ^CObj pxObj=xTemp.GetObj();
			if(pxObj!=null)then
				var ^CAttribs pxAttribs=pxObj^.GetAttribs();
				if(pxAttribs!=null)then
					if(pxAttribs^.ContainsKey("hitpoints"))then
						iValue=pxAttribs^.GetValueInt("hitpoints");
						m_pxHitpoints^.SetValue(iValue);
					endif;
					if(pxAttribs^.ContainsKey("maxhitpoints"))then
						iValue=pxAttribs^.GetValueInt("maxhitpoints");
						m_pxMaxHitpoints^.SetValue(iValue);
					endif;
					if(pxAttribs^.ContainsKey("level"))then
						iValue=pxAttribs^.GetValueInt("level");
						m_pxLevel^.SetValue(iValue+1);
					endif;
					if(pxAttribs^.ContainsKey("experience"))then
						iValue=pxAttribs^.GetValueInt("experience");
						m_pxExperience^.SetValue(iValue);
					endif;
				endif;
			endif;
		endfor;

		var ^CAttribs pxAttribs=pxObj^.GetAttribs();
		if(pxAttribs!=null)then
			var int iTempHP=pxAttribs^.GetValueInt("hitpoints");
			var int iTempMHP=pxAttribs^.GetValueInt("maxhitpoints");
			if(iTempHP!=0 && iTempMHP!=0)then
				var int iPercent=(iTempHP.ToReal()/((iTempMHP.ToReal()/100.0f))).ToInt();
				m_pxPercentHitpoints^.SetText(iPercent.ToString()+"%");
			endif;
		endif;

		m_pxHitpoints^.m_xOnChange=OnHitpointsChange;
		m_pxMaxHitpoints^.m_xOnChange=OnMaxHitpointsChange;
		m_pxLevel^.m_xOnChange=OnLevelChange;
		m_pxExperience^.m_xOnChange=OnExperienceChange;
	endproc;

	export proc bool Clear();
		return(true);
	endproc;

	export proc bool OnHitpointsChange();

		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		var	^CObj			pxObj=(pxSel^)[0].GetObj();

		var int i,iValue,iC=pxSel^.NumEntries();

		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xTemp=(pxSel^)[i];
			var ^CObj pxObj=xTemp.GetObj();
			if(pxObj!=null)then
				var ^CAttribs pxAttribs=pxObj^.GetAttribs();
				if(pxAttribs!=null)then
					if(!(m_pxHitpoints^.GetValueInt()>m_pxMaxHitpoints^.GetValueInt()))then
						pxAttribs^.SetValue("hitpoints",m_pxHitpoints^.GetValueInt());
						CEvt_UpdateAttribs.Send(pxObj^.GetGuid());
					endif;
				endif;
			endif;
		endfor;
		Update();
		return(true);
	endproc;

	export proc bool OnLevelChange()

		var int iLevel = m_pxLevel^.GetValueInt()-1;
		var CClntHndl xInvalid;

		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		CEvt_ObjLECommand.Send(pxSel^,"LE_SetLevel",xInvalid,{0.0,0.0,0.0},iLevel.ToString());
		
		var real fHitpoints = m_pxHitpoints^.GetValueFloat();
		var real fMaxHitpoints = m_pxMaxHitpoints^.GetValueFloat();
		var real fRatio = 1.0;
		if(fMaxHitpoints!=0.0)then
			fRatio = fHitpoints / fMaxHitpoints;
		endif;

		UpdateHitpointsAndLevel(iLevel, fRatio);

		Update();
		return(true);
	endproc;

	export proc void UpdateHitpointsAndLevel(int p_iLevel, real p_fRatio)
		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());

		var int i,iC = pxSel^.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CObj pxObj = pxSel^[i].GetObj();
			if(pxObj==null)then continue; endif;
			var ^CAttribs pxAttr = pxObj^.GetAttribs();
			if(pxAttr==null)then continue; endif;
			pxAttr^.SetValue("level", p_iLevel);
			CEvt_UpdateAttribs.Send(pxObj^.GetGuid());
			var int iLevel = p_iLevel+1;
			var string sObjPath = pxAttr^.GetValue("ObjPath");
			var string sTribe = pxAttr^.GetValue("tribe");
			var string sClassName = pxObj^.GetClassName();
			
			var string sFilterPath = "/Filters/"+sTribe+"/Upgrades/"+sClassName+"/Lvl"+iLevel.ToString()+"_Bonus";
			
			var CTechTreeDef xTTDef;
			xTTDef.EnableFilter(sFilterPath);
			var CTechTree xTT=CLevelEditorWrap.GetClient().GetTechTreeMgr().GetTechTree(xTTDef);
			
			var ^CTechTree.CNode pxObjNode = xTT.FindNode(sObjPath);
			if(pxObjNode==null)then continue; endif;
			
			var int iMaxHitpoints = pxObjNode^.GetSubValueI("hitpoints");
			
			m_pxMaxHitpoints^.SetValue(iMaxHitpoints);
			m_pxHitpoints^.SetValue((iMaxHitpoints.ToReal()*p_fRatio + 0.5).ToInt());
			
		endfor;
		
	endproc;


	export proc bool OnMaxHitpointsChange();

		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		var	^CObj			pxObj=(pxSel^)[0].GetObj();

		var int i,iValue,iC=pxSel^.NumEntries();

		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xTemp=(pxSel^)[i];
			var ^CObj pxObj=xTemp.GetObj();
			if(pxObj!=null)then
				var ^CAttribs pxAttribs=pxObj^.GetAttribs();
				if(pxAttribs!=null)then
					pxAttribs^.SetValue("maxhitpoints",m_pxMaxHitpoints^.GetValueInt());
					CEvt_UpdateAttribs.Send(pxObj^.GetGuid());
				endif;
			endif;
		endfor;
		Update();
		return(true);
	endproc;

	export proc bool OnExperienceChange();
		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		var	^CObj			pxObj=(pxSel^)[0].GetObj();

		var int i,iValue,iC=pxSel^.NumEntries();

		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xTemp=(pxSel^)[i];
			var ^CObj pxObj=xTemp.GetObj();
			if(pxObj!=null)then
				var ^CAttribs pxAttribs=pxObj^.GetAttribs();
				if(pxAttribs!=null)then
					pxAttribs^.SetValue("experience",m_pxExperience^.GetValueInt());
					CEvt_UpdateAttribs.Send(pxObj^.GetGuid());
				endif;
			endif;
		endfor;
		Update();
		return(true);
	endproc;

	export proc bool OnCasteChange();
		return(true);
	endproc;

	export proc bool OnSkillChange1();
		var string s="Kein Skill";
		m_pxSkill1Pos2^.SetDisabled(false);;
		m_pxSkill1Pos1^.SetDisabled(false);
		m_pxSkill1Neg1^.SetDisabled(false);
		m_pxSkill1Neg2^.SetDisabled(false);
		if(m_pxSkill1^.GetSelectedItemAsString()=="Intelligence")then
			if(m_pxSkill1Pos2^.GetToggleButtonState())then
				s="Genial";
			elseif(m_pxSkill1Pos1^.GetToggleButtonState())then
				s="Intelligent";
			elseif(m_pxSkill1Neg1^.GetToggleButtonState())then
				s="Dumm";
			elseif(m_pxSkill1Neg2^.GetToggleButtonState())then
				s="Strohdumm";
			endif;
		elseif(m_pxSkill1^.GetSelectedItemAsString()=="Strength")then
			if(m_pxSkill1Pos2^.GetToggleButtonState())then
				s="Bärenstark";
			elseif(m_pxSkill1Pos1^.GetToggleButtonState())then
				s="Kräftig";
			elseif(m_pxSkill1Neg1^.GetToggleButtonState())then
				s="Schwach";
			elseif(m_pxSkill1Neg2^.GetToggleButtonState())then
				s="Sehr Schwach";
			endif;
		elseif(m_pxSkill1^.GetSelectedItemAsString()=="Diligence")then
			if(m_pxSkill1Pos2^.GetToggleButtonState())then
				s="Unermüdlich";
			elseif(m_pxSkill1Pos1^.GetToggleButtonState())then
				s="Fleißig";
			elseif(m_pxSkill1Neg1^.GetToggleButtonState())then
				s="Faul";
			elseif(m_pxSkill1Neg2^.GetToggleButtonState())then
				s="Stinkfaul";
			endif;
		elseif(m_pxSkill1^.GetSelectedItemAsString()=="None")then
			s="Kein Skill";
			m_pxSkill1Pos2^.SetDisabled(true);
			m_pxSkill1Pos1^.SetDisabled(true);
			m_pxSkill1Neg1^.SetDisabled(true);
			m_pxSkill1Neg2^.SetDisabled(true);
		endif;
		m_pxSkill1Info^.SetText(s);
		return(true);
	endproc;

	export proc bool OnSkillChange2();
		var string s="Kein Skill";
		m_pxSkill2Pos2^.SetDisabled(false);
		m_pxSkill2Pos1^.SetDisabled(false);
		m_pxSkill2Neg1^.SetDisabled(false);
		m_pxSkill2Neg2^.SetDisabled(false);
		if(m_pxSkill2^.GetSelectedItemAsString()=="Intelligence")then
			if(m_pxSkill2Pos2^.GetToggleButtonState())then
				s="Genial";
			elseif(m_pxSkill2Pos1^.GetToggleButtonState())then
				s="Intelligent";
			elseif(m_pxSkill2Neg1^.GetToggleButtonState())then
				s="Dumm";
			elseif(m_pxSkill2Neg2^.GetToggleButtonState())then
				s="Strohdumm";
			endif;
		elseif(m_pxSkill2^.GetSelectedItemAsString()=="Strength")then
			if(m_pxSkill2Pos2^.GetToggleButtonState())then
				s="Bärenstark";
			elseif(m_pxSkill2Pos1^.GetToggleButtonState())then
				s="Kräftig";
			elseif(m_pxSkill2Neg1^.GetToggleButtonState())then
				s="Schwach";
			elseif(m_pxSkill2Neg2^.GetToggleButtonState())then
				s="Sehr Schwach";
			endif;
		elseif(m_pxSkill2^.GetSelectedItemAsString()=="Diligence")then
			if(m_pxSkill2Pos2^.GetToggleButtonState())then
				s="Unermüdlich";
			elseif(m_pxSkill2Pos1^.GetToggleButtonState())then
				s="Fleißig";
			elseif(m_pxSkill2Neg1^.GetToggleButtonState())then
				s="Faul";
			elseif(m_pxSkill2Neg2^.GetToggleButtonState())then
				s="Stinkfaul";
			endif;
		elseif(m_pxSkill2^.GetSelectedItemAsString()=="None")then
			s="Kein Skill";
			m_pxSkill2Pos2^.SetDisabled(true);;
			m_pxSkill2Pos1^.SetDisabled(true);
			m_pxSkill2Neg1^.SetDisabled(true);
			m_pxSkill2Neg2^.SetDisabled(true);
		endif;
		m_pxSkill2Info^.SetText(s);
		return(true);
	endproc;

	export proc bool OnChangeRandom1();
		m_pxSkill1^.SetDisabled(m_pxCheckBoxRandom1^.GetCheckMark());
		m_pxSkill1Pos2^.SetDisabled(m_pxCheckBoxRandom1^.GetCheckMark());
		m_pxSkill1Pos1^.SetDisabled(m_pxCheckBoxRandom1^.GetCheckMark());
		m_pxSkill1Neg1^.SetDisabled(m_pxCheckBoxRandom1^.GetCheckMark());
		m_pxSkill1Neg2^.SetDisabled(m_pxCheckBoxRandom1^.GetCheckMark());
		m_pxSkill1Info^.SetDisabled(m_pxCheckBoxRandom1^.GetCheckMark());
		m_pxSkill1Static^.SetDisabled(m_pxCheckBoxRandom1^.GetCheckMark());
		return(true);
	endproc;

	export proc bool OnChangeRandom2();
		m_pxSkill2^.SetDisabled(m_pxCheckBoxRandom2^.GetCheckMark());
		m_pxSkill2Pos2^.SetDisabled(m_pxCheckBoxRandom2^.GetCheckMark());
		m_pxSkill2Pos1^.SetDisabled(m_pxCheckBoxRandom2^.GetCheckMark());
		m_pxSkill2Neg1^.SetDisabled(m_pxCheckBoxRandom2^.GetCheckMark());
		m_pxSkill2Neg2^.SetDisabled(m_pxCheckBoxRandom2^.GetCheckMark());
		m_pxSkill2Info^.SetDisabled(m_pxCheckBoxRandom2^.GetCheckMark());
		m_pxSkill2Static^.SetDisabled(m_pxCheckBoxRandom2^.GetCheckMark());
		return(true);
	endproc;


endclass;


class COPInventoryProperties inherit CFrameWindow
	export constructor()
		var ^CDesktop pxDesktop = CClientWrap.GetDesktop();
		if(!InitFromResource("objects/ViewObjProperties","InventoryProperties"))then
			CClientWrap.LogInfo("Error","COPInventoryProperties: InitFromResource failed");
			return;
		endif;
	endconstructor;
endclass;

class COPItemProperties inherit CFrameWindow

	var ^CEdit 	m_pxEdit;

	export constructor()
		var ^CDesktop pxDesktop = CClientWrap.GetDesktop();
		if(!InitFromResource("objects/ViewObjProperties","ItemProperties"))then
			CClientWrap.LogInfo("Error","COPItemProperties: InitFromResource failed");
			return;
		endif;

		m_pxEdit = cast<CEdit>(GetControl("Edit_ItemData"));
		m_pxEdit^.m_xOnUpdate = OnUpdateData;
	endconstructor;

	export proc void Update()
		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		var	^CObj			pxObj=(pxSel^)[0].GetObj();

		var int i,iC=pxSel^.NumEntries();
		var string sValue;

		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xTemp=(pxSel^)[i];
			var ^CObj pxObj=xTemp.GetObj();
			if(pxObj!=null && pxObj^.GetType()=="ITEM")then
				var ^CAttribs pxAttribs=pxObj^.GetAttribs();
				if(pxAttribs!=null)then
					if(pxAttribs^.ContainsKey("item_data"))then
						sValue=pxAttribs^.GetValue("item_data");
						m_pxEdit^.SetText(sValue);
					endif;
				endif;
			endif;
		endfor;
	endproc;

	proc bool OnUpdateData()
		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		var	^CObj			pxObj=(pxSel^)[0].GetObj();

		var int i,iC=pxSel^.NumEntries();
		var string sValue;

		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xTemp=(pxSel^)[i];
			var ^CObj pxObj=xTemp.GetObj();
			if(pxObj!=null)then
				var ^CAttribs pxAttribs=pxObj^.GetAttribs();
				if(pxAttribs!=null)then
					if(pxAttribs^.ContainsKey("item_data"))then
						pxAttribs^.SetValue("item_data", m_pxEdit^.GetText());
						return true;
					endif;
				endif;
			endif;
		endfor;
		return false;
	endproc;
endclass;

class COPInfoObjectProperties inherit CFrameWindow

	var	^CEdit					m_pxInfoEdit;
	var	^CButton				m_pxUpdateButton;

	export constructor()
		var ^CDesktop pxDesktop = CClientWrap.GetDesktop();
		if(!InitFromResource("objects/ViewObjProperties","InfoObjectProperties"))then
			CClientWrap.LogInfo("Error","COPInfoObjectProperties: InitFromResource failed");
			return;
		endif;

		m_pxInfoEdit=cast<CEdit>(GetControl("GroupBoxInfo/EditInfo"));
		m_pxInfoEdit^.m_xOnUpdate=OnUpdateInfo;
		m_pxUpdateButton=cast<CButton>(GetControl("GroupBoxInfo/ButtonUpdate"));
		m_pxUpdateButton^.m_xOnClick=OnUpdateInfo;

	endconstructor;

	export proc void Update()

		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		var	^CObj			pxObj=(pxSel^)[0].GetObj();

		var int i,iC=pxSel^.NumEntries();
		var string sValue;

		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xTemp=(pxSel^)[i];
			var ^CObj pxObj=xTemp.GetObj();
			if(pxObj!=null)then
				var ^CAttribs pxAttribs=pxObj^.GetAttribs();
				if(pxAttribs!=null)then
					if(pxAttribs^.ContainsKey("info"))then
						sValue=pxAttribs^.GetValue("info");
						m_pxInfoEdit^.SetText(sValue);
					endif;
				endif;
			endif;
		endfor;
	endproc;

	export proc void Clear()

	endproc;


	export proc bool OnUpdateInfo()
		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());

		var int i,iValue,iC=pxSel^.NumEntries();

		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xTemp=(pxSel^)[i];
			var ^CObj pxObj=xTemp.GetObj();
			var ^CAttribs pxAttribs=pxObj^.GetAttribs();
			if(pxAttribs==null)then pxAttribs=pxObj^.InitAttribs();endif;
			pxAttribs^.SetValue("info",m_pxInfoEdit^.GetText());
			CEvt_UpdateAttribs.Send(pxObj^.GetGuid());
			pxObj^.SetDebugText(m_pxInfoEdit^.GetText(),{0.0,-4.0,4.0});
		endfor;
		return(true);
	endproc;

endclass;


class CViewSPPropertiesA inherit CFrameWindow

	export var procref<bool,bool> m_xOnDemandUpdate;

	export constructor()
		if(!InitFromResource("objects/ViewObjProperties","ViewSPPropertiesA"))then
			CLevelEditorWrap.LogError("UI.CViewSPProperties","InitFromResource failed");
			return;
		endif;

		m_xOnDemandUpdate = OnDemandUpdate;

		var ^CDropList pxDropList1 = cast<CDropList>(GetControl("GroupGeneral/DropList_Tribe"));
		pxDropList1^.AddItem("Hu");
		pxDropList1^.AddItem("Aje");
		pxDropList1^.AddItem("Ninigi");
		pxDropList1^.AddItem("Random");


		var ^CCheckBox pxCheckBoxInclude = cast<CCheckBox>(GetControl("GroupGeneral/CheckBox_Include_Building"));
		var ^CCheckBox pxCheckBoxIgnore = cast<CCheckBox>(GetControl("GroupGeneral/CheckBox_Ignore_PointBuy"));

		var ^CDropList pxDropList2 = cast<CDropList>(GetControl("GroupGeneral/DropList_Player"));
		pxDropList2^.AddItem("human");
		
		pxDropList2^.AddItem("ai_Schnecke");
		pxDropList2^.AddItem("ai_Schnecke_easy");
		pxDropList2^.AddItem("ai_Schnecke_medium");
		pxDropList2^.AddItem("ai_Schnecke_hard");
		
		pxDropList2^.AddItem("ai_Giraffe");
		pxDropList2^.AddItem("ai_Giraffe_easy");
		pxDropList2^.AddItem("ai_Giraffe_medium");
		pxDropList2^.AddItem("ai_Giraffe_hard");
		
		pxDropList2^.AddItem("ai_Dodo");
		pxDropList2^.AddItem("ai_Dodo_easy");
		pxDropList2^.AddItem("ai_Dodo_medium");
		pxDropList2^.AddItem("ai_Dodo_hard");
		
		pxDropList2^.AddItem("ai_Mikrobe");
		pxDropList2^.AddItem("ai_random");
		pxDropList2^.AddItem("invalid");

		pxDropList1^.m_xOnChange = OnChangeTribe;
		pxCheckBoxInclude^.m_xOnStateChange = OnCheckInclude;
		pxCheckBoxIgnore^.m_xOnStateChange = OnIgnorePointBuy;
		pxDropList2^.m_xOnChange = OnChangePlayer;

		Update();

	endconstructor;

	proc bool OnDemandUpdate(bool p_b)
		return true;
	endproc;

	export destructor()
	enddestructor;

	proc bool OnChangeTribe()
		/*
		KLog.LogSpam("StartLocation","OnChangeTribe(");

		var ^CDropList pxDropList = cast<CDropList>(GetControl("GroupGeneral/DropList_Tribe"));
		var ^CLevelInfoClient pxLevelInfo=^(CLevelEditorWrap.GetClient().GetLevelInfo());

		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		var int i,iValue,iC=pxSel^.NumEntries();
		if(iC>0)then
			var ^CObj pxSelObj = pxSel^[0].GetObj();
			if(pxSelObj!=null)then
				var ^CLevelInfo.CPlayerSlot pxPSlot = pxLevelInfo^.GetOwnerPlayerSlot(pxSelObj^.GetOwner());
				if(pxPSlot!=null)then
					for(i=0)cond(i<pxLevelInfo^.m_xTribeList.NumEntries())iter(i++)do
						if(pxLevelInfo^.m_xTribeList[i]==pxDropList^.GetSelectedItemAsString())then
							pxPSlot^.SetTribe(i);
							break;
						endif;
					endfor;
				endif;
			endif;
		endif;

		m_xOnDemandUpdate.Call(true);
		*/
		return true;
	endproc;

	proc bool OnChangePlayer()

		KLog.LogSpam("StartLocation","OnChangePlayer()");

		var ^CDropList pxDropList = cast<CDropList>(GetControl("GroupGeneral/DropList_Player"));
		var ^CLevelInfoClient pxLevelInfo=^(CLevelEditorWrap.GetClient().GetLevelInfo());

		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		var int i,iValue,iC=pxSel^.NumEntries();
		if(iC>0)then
			var ^CObj pxSelObj = pxSel^[0].GetObj();
			if(pxSelObj!=null)then
				var ^CLevelInfo.CPlayerSlot pxPSlot = pxLevelInfo^.GetOwnerPlayerSlot(pxSelObj^.GetOwner());
				if(pxPSlot!=null)then
					pxPSlot^.SetType(pxDropList^.GetSelectedItemAsString());
				endif;
			endif;
		endif;

		m_xOnDemandUpdate.Call(true);
		return true;
	endproc;

	proc bool OnCheckInclude()

		KLog.LogSpam("StartLocation","OnCheckInclude()");

		var ^CCheckBox pxCheckBoxInclude = cast<CCheckBox>(GetControl("GroupGeneral/CheckBox_Include_Building"));
		var ^CObjSelection pxSel = ^(CClientWrap.GetSelection());
		var int i;
		for(i=0)cond(i<pxSel^.NumEntries())iter(i++)do
			if(pxSel^[i].IsValid() && pxSel^[i].GetObj()^.GetType()=="SLOC")then
				var ^CAttribs pxAttr = pxSel^[i].GetObj()^.GetAttribs();
				if(pxAttr!=null)then
					pxAttr^.SetValue("include_building",pxCheckBoxInclude^.GetChecked());
					CEvt_UpdateAttribs.Send(pxSel^[i].GetObj()^.GetGuid());
				endif;
			endif;
		endfor;
		m_xOnDemandUpdate.Call(true);
		return true;
	endproc;

	proc bool OnIgnorePointBuy()
		var ^CCheckBox pxCheckBoxIgnore = cast<CCheckBox>(GetControl("GroupGeneral/CheckBox_Ignore_PointBuy"));
		var ^CObjSelection pxSel = ^(CClientWrap.GetSelection());
		var int i;
		for(i=0)cond(i<pxSel^.NumEntries())iter(i++)do
			if(pxSel^[i].IsValid() && pxSel^[i].GetObj()^.GetType()=="SLOC")then
				var ^CAttribs pxAttr = pxSel^[i].GetObj()^.GetAttribs();
				if(pxAttr!=null)then
					pxAttr^.SetValue("ignore_pointbuy",pxCheckBoxIgnore^.GetChecked());
					CEvt_UpdateAttribs.Send(pxSel^[i].GetObj()^.GetGuid());
				endif;
			endif;
		endfor;
		return true;
	endproc;

	export proc bool Clear()
		return true;
	endproc;

	export proc bool Update()

		KLog.LogSpam("StartLocation","Update()");

		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());

		var ^CLevelInfoClient pxLevelInfo=^(CLevelEditorWrap.GetClient().GetLevelInfo());

		var ^CDropList pxDropListTribe = cast<CDropList>(GetControl("GroupGeneral/DropList_Tribe"));
		var ^CDropList pxDropListPlayer = cast<CDropList>(GetControl("GroupGeneral/DropList_Player"));

		var int i,iValue,iC=pxSel^.NumEntries();
		if(iC>0)then
			var ^CObj pxSelObj = pxSel^[0].GetObj();
			if(pxSelObj!=null)then
				var ^CLevelInfo.CPlayerSlot pxPSlot = pxLevelInfo^.GetOwnerPlayerSlot(pxSelObj^.GetOwner());
				if(pxPSlot!=null)then
					pxDropListTribe^.Select(pxDropListTribe^.FindItem(pxPSlot^.GetTribe()));
					pxDropListPlayer^.Select(pxDropListPlayer^.FindItem(pxPSlot^.GetType()));
					pxDropListTribe^.SetDisabled(false);
					pxDropListPlayer^.SetDisabled(false);
				else
					pxDropListTribe^.SetDisabled(true);
					pxDropListPlayer^.SetDisabled(true);
				endif;
			endif;
		endif;

		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xTemp=(pxSel^)[i];
			var ^CObj pxObj=xTemp.GetObj();
			if(pxObj!=null)then
				var ^CAttribs pxAttribs=pxObj^.GetAttribs();
				if(pxAttribs!=null)then
					if(pxAttribs^.ContainsKey("include_building"))then
						iValue=pxAttribs^.GetValueInt("include_building");
						var ^CCheckBox pxCheckBoxInclude = cast<CCheckBox>(GetControl("GroupGeneral/CheckBox_Include_Building"));
						if(iValue!=pxCheckBoxInclude^.GetChecked())then
							pxCheckBoxInclude^.SetChecked(iValue);
						endif;
					endif;
					if(pxAttribs^.ContainsKey("ignore_pointbuy"))then
						iValue=pxAttribs^.GetValueInt("ignore_pointbuy");
						var ^CCheckBox pxCheckBoxIgnore = cast<CCheckBox>(GetControl("GroupGeneral/CheckBox_Ignore_PointBuy"));
						if(iValue!=pxCheckBoxIgnore^.GetChecked())then
							pxCheckBoxIgnore^.SetChecked(iValue);
						endif;
					endif;
				endif;
			endif;
		endfor;

		return true;
	endproc;

endclass;

class COPResourceProperties inherit CFrameWindow

	var	^CEdit					m_pxValueEdit;
	var	^CButton				m_pxUpdateButton;

	export constructor()
		if(!InitFromResource("objects/ViewObjProperties","ResourceProperties"))then
			CClientWrap.LogInfo("Error","COPResourceProperties: InitFromResource failed");
			return;
		endif;

		m_pxValueEdit=cast<CEdit>(GetControl("GroupBoxResource/EditValue"));
		m_pxValueEdit^.m_xOnUpdate=OnUpdateValue;
		m_pxUpdateButton=cast<CButton>(GetControl("GroupBoxResource/ButtonUpdate"));
		m_pxUpdateButton^.m_xOnClick=OnUpdateValue;

	endconstructor;

	export destructor()
	enddestructor;

	export proc bool Clear()
		return true;
	endproc;

	export proc bool Update()

		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		var	^CObj			pxObj=(pxSel^)[0].GetObj();

		var int i,iValue,iC=pxSel^.NumEntries();

		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xTemp=(pxSel^)[i];
			var ^CObj pxObj=xTemp.GetObj();
			if(pxObj!=null)then
				var ^CAttribs pxAttribs=pxObj^.GetAttribs();
				if(pxAttribs!=null)then
					if(pxAttribs^.ContainsKey("value"))then
						iValue=pxAttribs^.GetValueInt("value");
						m_pxValueEdit^.SetText(iValue.ToString());
					endif;
				endif;
			endif;
		endfor;
		return true;
	endproc;

	export proc bool OnUpdateValue()
		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());

		var int i,iValue,iC=pxSel^.NumEntries();

		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xTemp=(pxSel^)[i];
			var ^CObj pxObj=xTemp.GetObj();
			var ^CAttribs pxAttribs=pxObj^.GetAttribs();
			if(pxAttribs==null)then pxAttribs=pxObj^.InitAttribs();endif;
			pxAttribs^.SetValue("value",m_pxValueEdit^.GetText().ToInt());
			pxAttribs^.SetValue("hitpoints",m_pxValueEdit^.GetText().ToInt());
			pxAttribs^.SetValue("maxhitpoints",m_pxValueEdit^.GetText().ToInt());
			CEvt_UpdateAttribs.Send(pxObj^.GetGuid());
		endfor;
		return(true);
	endproc;

endclass;

class COPFountainProperties inherit CFrameWindow

	var	^CSpinCtrlNumber		m_pxMaxAmount, m_pxRefillDur;

	export constructor()
		if(!InitFromResource("objects/ViewObjProperties","FountainProperties"))then
			CClientWrap.LogInfo("Error","COPFountainProperties: InitFromResource failed");
			return;
		endif;

		m_pxMaxAmount=cast<CSpinCtrlNumber>(GetControl("GroupBoxFountain/MaxAmount"));
		m_pxRefillDur=cast<CSpinCtrlNumber>(GetControl("GroupBoxFountain/RefillDur"));

		m_pxMaxAmount^.m_xOnChange = OnUpdateMaxAmount;
		m_pxRefillDur^.m_xOnChange = OnUpdateRefillDur;
	endconstructor;

	export destructor()
	enddestructor;

	export proc bool Clear()
		return true;
	endproc;
	
	proc bool OnUpdateMaxAmount()
		var int iVal = m_pxMaxAmount^.GetValueInt();
		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		var	^CObj			pxObj=(pxSel^)[0].GetObj();

		var int i,iC=pxSel^.NumEntries();

		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xTemp=(pxSel^)[i];
			var ^CObj pxObj=xTemp.GetObj();
			if(pxObj!=null)then
				var ^CAttribs pxAttribs=pxObj^.GetAttribs();
				if(pxAttribs!=null)then
					if(pxAttribs^.ContainsKey("maxhitpoints"))then
						pxAttribs^.SetValue("maxhitpoints", iVal);	
						pxAttribs^.SetValue("hitpoints", iVal);	
					endif;
				endif;
			endif;
			CEvt_UpdateAttribs.Send(pxObj^.GetGuid());
		endfor;
		return true;
	endproc;
	
	proc bool OnUpdateRefillDur()
		var int iVal = m_pxRefillDur^.GetValueInt();
		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		var	^CObj			pxObj=(pxSel^)[0].GetObj();

		var int i,iC=pxSel^.NumEntries();

		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xTemp=(pxSel^)[i];
			var ^CObj pxObj=xTemp.GetObj();
			if(pxObj!=null)then
				var ^CAttribs pxAttribs=pxObj^.GetAttribs();
				if(pxAttribs!=null)then
					if(pxAttribs^.ContainsKey("refill_dur"))then
						pxAttribs^.SetValue("refill_dur", iVal);	
					endif;
				endif;
			endif;
			CEvt_UpdateAttribs.Send(pxObj^.GetGuid());
		endfor;
		return true;
	endproc;

	export proc bool Update()

		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		var	^CObj			pxObj=(pxSel^)[0].GetObj();

		var int i,iValue,iC=pxSel^.NumEntries();

		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xTemp=(pxSel^)[i];
			var ^CObj pxObj=xTemp.GetObj();
			if(pxObj!=null)then
				var ^CAttribs pxAttribs=pxObj^.GetAttribs();
				if(pxAttribs!=null)then
					if(pxAttribs^.ContainsKey("maxhitpoints"))then
						iValue=pxAttribs^.GetValueInt("maxhitpoints");
						m_pxMaxAmount^.SetValue(iValue);
					endif;
					if(pxAttribs^.ContainsKey("refill_dur"))then
						iValue=pxAttribs^.GetValueInt("refill_dur");
						m_pxRefillDur^.SetValue(iValue);
					endif;
				endif;
			endif;
		endfor;
		return true;
	endproc;

endclass;

class COPLakeOfDamageProperties inherit CFrameWindow

	var	^CSpinCtrlNumber		m_pxDamage;
	var	^CEdit					m_pxRegion;
	var	^CList					m_pxTypes;

	export constructor()
		if(!InitFromResource("objects/ViewObjProperties","LakeOfDamageProperties"))then
			CClientWrap.LogInfo("Error","COPLakeOfDamageProperties: InitFromResource failed");
			return;
		endif;

		m_pxDamage=cast<CSpinCtrlNumber>(GetControl("GroupBoxLakeOfDamage/Damage"));
		m_pxRegion=cast<CEdit>(GetControl("GroupBoxLakeOfDamage/Region"));
		m_pxTypes=cast<CList>(GetControl("GroupBoxLakeOfDamage/Types"));

		m_pxDamage^.m_xOnChange = OnUpdateDamage;
		m_pxRegion^.m_xOnChange = OnUpdateRegion;
		m_pxTypes^.m_xOnSelect = OnUpdateTypes;

		m_pxTypes^.AddItem("CHTR");
		m_pxTypes^.AddItem("ANML");
		m_pxTypes^.AddItem("VHCL");
		m_pxTypes^.AddItem("BLDG");
		m_pxTypes^.AddItem("SHIP");

		m_pxTypes^.AllowMultiSelection(true);
		m_pxTypes^.AllowScrollBar(true);
		
	endconstructor;

	export destructor()
	enddestructor;

	export proc bool Clear()
		return true;
	endproc;
	
	proc bool OnUpdateDamage()
		var int iVal = m_pxDamage^.GetValueInt();
		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());

		var int i,iC=pxSel^.NumEntries();

		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xTemp=(pxSel^)[i];
			var ^CObj pxObj=xTemp.GetObj();
			if(pxObj!=null)then
				var ^CAttribs pxAttribs=pxObj^.GetAttribs();
				if(pxAttribs!=null)then
					if(pxAttribs^.ContainsKey("damage_per_tick"))then
						pxAttribs^.SetValue("damage_per_tick", iVal);	
					endif;
				endif;
			endif;
			CEvt_UpdateAttribs.Send(pxObj^.GetGuid());
		endfor;
		return true;
	endproc;
	
	proc bool OnUpdateRegion()
		var string sVal = m_pxRegion^.GetText();
		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());

		var int i,iC=pxSel^.NumEntries();

		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xTemp=(pxSel^)[i];
			var ^CObj pxObj=xTemp.GetObj();
			if(pxObj!=null)then
				var ^CAttribs pxAttribs=pxObj^.GetAttribs();
				if(pxAttribs!=null)then
					if(pxAttribs^.ContainsKey("region_name"))then
						pxAttribs^.SetValue("region_name", sVal);
					endif;
				endif;
			endif;
			CEvt_UpdateAttribs.Send(pxObj^.GetGuid());
		endfor;
		return true;
	endproc;
	
	proc bool OnUpdateTypes()
		var int i,iC=m_pxTypes^.NumItems();
		var string sTypes="";
		for(i=0)cond(i<iC)iter(i++)do
			if(m_pxTypes^.IsItemSelected(i))then
				sTypes+="|"+m_pxTypes^.GetItem(i);
			endif;
		endfor;
		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());

		iC=pxSel^.NumEntries();

		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xTemp=(pxSel^)[i];
			var ^CObj pxObj=xTemp.GetObj();
			if(pxObj!=null)then
				var ^CAttribs pxAttribs=pxObj^.GetAttribs();
				if(pxAttribs!=null)then
					if(pxAttribs^.ContainsKey("damage_types"))then
						pxAttribs^.SetValue("damage_types", sTypes);	
					endif;
				endif;
			endif;
			CEvt_UpdateAttribs.Send(pxObj^.GetGuid());
		endfor;
		return true;
	endproc;
	
	export proc bool Update()

		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		var	^CObj			pxObj=(pxSel^)[0].GetObj();

		var int i,iValue,iC=pxSel^.NumEntries();
		var string sValue="";

		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xTemp=(pxSel^)[i];
			var ^CObj pxObj=xTemp.GetObj();
			if(pxObj!=null)then
				var ^CAttribs pxAttribs=pxObj^.GetAttribs();
				if(pxAttribs!=null)then
					if(pxAttribs^.ContainsKey("damage_per_tick"))then
						iValue=pxAttribs^.GetValueInt("damage_per_tick");
						m_pxDamage^.SetValue(iValue);
					endif;
					if(pxAttribs^.ContainsKey("region_name"))then
						sValue=pxAttribs^.GetValue("region_name");
						m_pxRegion^.SetText(sValue);
					endif;
					sValue="";
					if(pxAttribs^.ContainsKey("damage_types"))then
						sValue=pxAttribs^.GetValue("damage_types");
						var int j,iJ=m_pxTypes^.NumItems();
						for(i=0)cond(i<iC)iter(i++)do
							if(sValue.Find(m_pxTypes^.GetItem(j))!=-1)then
								m_pxTypes^.Select(j,false);
							else
								m_pxTypes^.UnSelect(j);
							endif;
						endfor;
					endif;
				endif;
			endif;
		endfor;
		return true;
	endproc;

endclass;

class COPBuildingProperties inherit CFrameWindow

	var ^CButton			m_pxGateState;

	export constructor()

		if(!InitFromResource("objects/ViewObjProperties","BuildingProperties"))then
			CClientWrap.LogInfo("Error","COPbuildingProperties: InitFromResource failed");
			return;
		endif;

		m_pxGateState=cast<CButton>(GetControl("GroupGate/State"));
		m_pxGateState^.m_xOnClick=OnGateStateChanged;

	endconstructor;

	export destructor()
	enddestructor;

	export proc bool Clear()
		return true;
	endproc;

	export proc bool Update()

		m_pxGateState^.m_xOnClick.Clear();
		
		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		var	^CObj			pxObj;

		var int i,iValue,iC=pxSel^.NumEntries();

		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xTemp=(pxSel^)[i];
			var ^CObj pxObj=xTemp.GetObj();
			if(pxObj!=null)then
				var ^CAttribs pxAttribs=pxObj^.GetAttribs();
				if(pxAttribs!=null)then
					if(pxAttribs^.ContainsKey("GateState"))then
						iValue=pxAttribs^.GetValueInt("GateState");
						if(iValue==0)then
							m_pxGateState^.SetDisabled(false);
							m_pxGateState^.SetText("open");
						elseif(iValue==1)then
							m_pxGateState^.SetDisabled(false);
							m_pxGateState^.SetText("closed");
						elseif(iValue==2)then
							m_pxGateState^.SetDisabled(false);
							m_pxGateState^.SetText("auto");
						else
							m_pxGateState^.SetText("auto");
							m_pxGateState^.SetDisabled(false);
						endif;
					endif;
				endif;
			endif;
		endfor;
		m_pxGateState^.m_xOnClick=OnGateStateChanged;
		return true;
	endproc;

	proc bool OnGateStateChanged()
		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		var	^CObj			pxObj=(pxSel^)[0].GetObj();
		
		var int iGateState=-1;
		var string sGateState=m_pxGateState^.GetText();
		if(sGateState=="open") 			then iGateState=0;
		elseif(sGateState=="closed")	then iGateState=1;
		elseif(sGateState=="auto")		then iGateState=2;
		endif;
		
		if(iGateState==-1)then return false; endif;
		iGateState++;
		if(iGateState>2)then iGateState=0; endif;

		if(iGateState==0)then
			m_pxGateState^.SetText("open");
		elseif(iGateState==1)then
			m_pxGateState^.SetText("closed");
		elseif(iGateState==2)then
			m_pxGateState^.SetText("auto");
		endif;

		var CClntHndl xInvalid;
		CEvt_ObjLECommand.Send(pxSel^,"LE_SetGateState",xInvalid,{0.0,0.0,0.0},iGateState.ToString());
		return true;
	endproc;

endclass;

class COPAnimalProperties inherit CFrameWindow

	var ^CSpinCtrlNumber			m_pxLevel;
	var ^CSpinCtrlNumber			m_pxHitpoints;
	var ^CSpinCtrlNumber			m_pxMaxHitpoints;
	var ^CStaticCtrl				m_pxPercentHitpoints;

	export constructor()
		if(!InitFromResource("objects/ViewObjProperties","AnimalProperties"))then
			CClientWrap.LogInfo("Error","COPAnimalProperties: InitFromResource failed");
			return;
		endif;

		m_pxLevel=cast<CSpinCtrlNumber>(GetControl("GroupHitpoints/SpinCtrlLevel"));
		m_pxLevel^.SetLimits(1,5,1);
		m_pxLevel^.m_xOnChange=OnLevelChange;
		m_pxHitpoints=cast<CSpinCtrlNumber>(GetControl("GroupHitpoints/SpinCtrlActualHitpoints"));
		m_pxHitpoints^.SetLimits(0,500000,1);
		m_pxHitpoints^.m_xOnChange=OnHitpointsChange;
		m_pxMaxHitpoints=cast<CSpinCtrlNumber>(GetControl("GroupHitpoints/SpinCtrlMaxHitpoints"));
		m_pxMaxHitpoints^.m_xOnChange=OnMaxHitpointsChange;
		m_pxMaxHitpoints^.SetLimits(0,500000,1);
		m_pxPercentHitpoints=cast<CStaticCtrl>(GetControl("GroupHitpoints/StaticPercentHitpoints2"));

	endconstructor;

	export destructor()
	enddestructor;

	export proc bool Clear()
		return true;
	endproc;

	export proc bool Update()

		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		var	^CObj			pxObj=(pxSel^)[0].GetObj();

		var int i,iC=pxSel^.NumEntries();

		m_pxLevel^.m_xOnChange.Clear();
		m_pxHitpoints^.m_xOnChange.Clear();
		m_pxMaxHitpoints^.m_xOnChange.Clear();

		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xTemp=(pxSel^)[i];
			var ^CObj pxObj=xTemp.GetObj();
			if(pxObj!=null)then
				var ^CAttribs pxAttribs=pxObj^.GetAttribs();
				if(pxAttribs!=null)then
					var int iHitpoints, iMaxHitpoints, iLevel;
					if(pxAttribs^.ContainsKey("hitpoints"))then
						iHitpoints=pxAttribs^.GetValueInt("hitpoints");
					endif;
					if(pxAttribs^.ContainsKey("maxhitpoints"))then
						iMaxHitpoints=pxAttribs^.GetValueInt("maxhitpoints");
					endif;
					if(pxAttribs^.ContainsKey("level"))then
						iLevel=pxAttribs^.GetValueInt("level");
					endif;

					var real fRatio = 1.0;
					if(iMaxHitpoints!=0)then
						fRatio = iHitpoints.ToReal() / iMaxHitpoints.ToReal();
					endif;
					
					m_pxLevel^.SetValue(iLevel+1);
					m_pxHitpoints^.SetValue(iHitpoints);
					m_pxMaxHitpoints^.SetValue(iMaxHitpoints);
					//UpdateHitpointsAndLevel(iLevel, fRatio);
				
				endif;
			endif;
		endfor;

		m_pxLevel^.m_xOnChange=OnLevelChange;
		m_pxHitpoints^.m_xOnChange=OnHitpointsChange;
		m_pxMaxHitpoints^.m_xOnChange=OnMaxHitpointsChange;

		var ^CAttribs pxAttribs=pxObj^.GetAttribs();
		if(pxAttribs!=null)then
			var int iTempHP=pxAttribs^.GetValueInt("hitpoints");
			var int iTempMHP=pxAttribs^.GetValueInt("maxhitpoints");
			if(iTempHP!=0 && iTempMHP!=0)then
				var int iPercent=(iTempHP.ToReal()/((iTempMHP.ToReal()/100.0f))).ToInt();
				m_pxPercentHitpoints^.SetText(iPercent.ToString()+"%");
			endif;
		endif;

		return true;
	endproc;


	export proc bool OnLevelChange()

		var int iLevel = m_pxLevel^.GetValueInt()-1;
		var CClntHndl xInvalid;

		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		CEvt_ObjLECommand.Send(pxSel^,"LE_SetLevel",xInvalid,{0.0,0.0,0.0},iLevel.ToString());
		
		var real fHitpoints = m_pxHitpoints^.GetValueFloat();
		var real fMaxHitpoints = m_pxMaxHitpoints^.GetValueFloat();
		var real fRatio = 1.0;
		if(fMaxHitpoints!=0.0)then
			fRatio = fHitpoints / fMaxHitpoints;
		endif;

		UpdateHitpointsAndLevel(iLevel, fRatio);

		Update();
		return(true);
	endproc;

	export proc void UpdateHitpointsAndLevel(int p_iLevel, real p_fRatio)
		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());

		var int i,iC = pxSel^.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CObj pxObj = pxSel^[i].GetObj();
			if(pxObj==null)then continue; endif;
			var ^CAttribs pxAttr = pxObj^.GetAttribs();
			if(pxAttr==null)then continue; endif;
			pxAttr^.SetValue("level", p_iLevel);
			CEvt_UpdateAttribs.Send(pxObj^.GetGuid());
			var int iLevel = p_iLevel+1;
			var string sObjPath = pxAttr^.GetValue("ObjPath");
			var string sTribe = pxAttr^.GetValue("tribe");
			var string sClassName = pxObj^.GetClassName();
			
			var string sFilterPath = "/Filters/"+sTribe+"/Upgrades/"+sClassName+"/Lvl"+iLevel.ToString()+"_Bonus";
			
			var CTechTreeDef xTTDef;
			xTTDef.EnableFilter(sFilterPath);
			var CTechTree xTT=CLevelEditorWrap.GetClient().GetTechTreeMgr().GetTechTree(xTTDef);
			
			var ^CTechTree.CNode pxObjNode = xTT.FindNode(sObjPath);
			if(pxObjNode==null)then continue; endif;
			
			var int iMaxHitpoints = pxObjNode^.GetSubValueI("hitpoints");
			
			m_pxMaxHitpoints^.SetValue(iMaxHitpoints);
			m_pxHitpoints^.SetValue((iMaxHitpoints.ToReal()*p_fRatio + 0.5).ToInt());
			
		endfor;
		
	endproc;

	export proc bool OnHitpointsChange();

		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		var	^CObj			pxObj=(pxSel^)[0].GetObj();

		var int i,iValue,iC=pxSel^.NumEntries();

		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xTemp=(pxSel^)[i];
			var ^CObj pxObj=xTemp.GetObj();
			if(pxObj!=null)then
				var ^CAttribs pxAttribs=pxObj^.GetAttribs();
				if(pxAttribs!=null)then
					if(!(m_pxHitpoints^.GetValueInt()>m_pxMaxHitpoints^.GetValueInt()))then
						pxAttribs^.SetValue("hitpoints",m_pxHitpoints^.GetValueInt());
						CEvt_UpdateAttribs.Send(pxObj^.GetGuid());
					endif;
				endif;
			endif;
		endfor;
		Update();
		return(true);
	endproc;

	export proc bool OnMaxHitpointsChange();

		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		var	^CObj			pxObj=(pxSel^)[0].GetObj();

		var int i,iValue,iC=pxSel^.NumEntries();

		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xTemp=(pxSel^)[i];
			var ^CObj pxObj=xTemp.GetObj();
			if(pxObj!=null)then
				var ^CAttribs pxAttribs=pxObj^.GetAttribs();
				if(pxAttribs!=null)then
					pxAttribs^.SetValue("maxhitpoints",m_pxMaxHitpoints^.GetValueInt());
					CEvt_UpdateAttribs.Send(pxObj^.GetGuid());
				endif;
			endif;
		endfor;
		Update();
		return(true);
	endproc;

endclass;

class COPNestProperties inherit CFrameWindow

	class CANMLData inherit CItemData
		export var CClntHndl m_xObj;

		export proc ^COPNestProperties.CANMLData Clone()
			var ^COPNestProperties.CANMLData pxD=new COPNestProperties.CANMLData();
			pxD^.m_xObj = m_xObj;
			return pxD;
		endproc;
	endclass;

	class CSelectAnimalWindow inherit CWindow

		var ^CList		m_pxList;
		var ^CButton	m_pxOK, m_pxCancel;
		var ^CList		m_pxSelectedObjects; // will hold the selected object after OK was pushed

		export constructor( ^CList p_pxSelObjects)
			if(!InitFromResource("objects/ViewObjProperties","SelectAnimalWindow"))then
				CClientWrap.LogError("Error","CSelectAnimalWindow: InitFromResource failed");
				return;
			endif;
			m_pxList=cast<CList>(GetControl("List_Animals"));
			m_pxOK=cast<CButton>(GetControl("Btn_OK"));
			m_pxCancel=cast<CButton>(GetControl("Btn_Cancel"));
			m_pxSelectedObjects = p_pxSelObjects;
			m_pxList^.AllowMultiSelection(true);
			m_pxList^.AllowScrollBar(true);
			m_pxOK^.m_xOnClick = OnOK;
			m_pxCancel^.m_xOnClick = OnCancel;
		endconstructor;

		destructor()
			CWindowMgr.Get().ReleaseModal(this);
		enddestructor;

		export proc void FillList( string p_sClass )
			var ^CList pxObjList = CEnhancedMenu.Get().GetObjFinder()^.GetObjList();
			var int i, iC = pxObjList^.NumItems();
			for(i=0)cond(i<iC)iter(++i)do
				var string sName = pxObjList^.GetItem(i);
				if(m_pxSelectedObjects^.FindItem(sName)>=0)then continue; endif;
				if(sName.Find(p_sClass) >= 0)then
					var ^CFinderItem pxItem = cast<CFinderItem>(pxObjList^.GetItemData(i));
//					if(pxItem!=null)then
					if(pxItem==null)then continue; endif;
					var CClntHndl xObjHndl=pxItem^.GetHndl();
					var ^CObj pxObj=xObjHndl.GetObj();
					if(pxObj==null)then continue; endif;
					if(pxObj^.GetType()=="ANML")then
						if(pxItem^.GetType()==CFinderItem.TYPE_OBJECT)then
							var ^COPNestProperties.CANMLData pxD = new COPNestProperties.CANMLData();
							pxD^.m_xObj = (cast<CFinderItemObject>(pxItem))^.GetHndl();
							m_pxList^.AddItem(sName, pxD);
						endif;
					endif;
				endif;
			endfor;
		endproc;

		proc bool OnOK()
			var int i;
			m_pxList^.StartIterateSelectedItems(i);
			var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
			if(pxSel^.NumEntries()==0)then return(false);endif;
			var ^CObj pxObj = (pxSel^)[0].GetObj();
			if(pxObj==null)then return false; endif;
			while(m_pxList^.IterateSelectedItems(i))do
				if(m_pxSelectedObjects^.FindItem(m_pxList^.GetItem(i))>=0)then continue; endif;
				var ^COPNestProperties.CANMLData pxD = cast<COPNestProperties.CANMLData>(m_pxList^.GetItemData(i));
				if(pxD!=null)then
					m_pxSelectedObjects^.AddItem(m_pxList^.GetItem(i), pxD^.Clone());
					//CEvt_GamePlayCommand.Send(pxObj^.GetHandle(), "AddAnimal", pxD^.m_xObj, {0.0f, 0.0f,0.0f}, "");
				endif;
			endwhile;
			ClearList();
			if(m_pxSelectedObjects^.NumItems() > 0)then
				var int iP = m_pxSelectedObjects^.GetSelectedItem();
				if(iP>=0)then m_pxSelectedObjects^.UnSelect(iP); endif;
				m_pxSelectedObjects^.Select(0);
			endif;
			Destroy();
			return true;
		endproc;

		proc bool OnCancel()
			ClearList();
			Destroy();
			return true;
		endproc;

		proc void ClearList()
			var int i, iC = m_pxList^.NumItems();
			for(i=0)cond(i<iC)iter(++i)do
				delete m_pxList^.GetItemData(i);
			endfor;
		endproc;

	endclass;

	class CTimeTable
		class CEntry
			export var int	m_iID;
			export var int	m_iStartTime;
			export var int	m_iEndTime;
		endclass;

		var array CEntry	m_axEntries;

		export proc void Clear()
			m_axEntries=0;
		endproc;

		export proc void GetData(int p_iID,ref int po_riStartTime,ref int po_riEndTime)
			var int i,iC=m_axEntries.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				if(m_axEntries[i].m_iID==p_iID)then
					po_riStartTime=m_axEntries[i].m_iStartTime;
					po_riEndTime=m_axEntries[i].m_iEndTime;
					return;
				endif;
			endfor;
			po_riStartTime=-1;
			po_riEndTime=-1;
		endproc;

		export proc void SetData(int p_iID,int p_iStartTime,int p_iEndTime)
			var int i,iC=m_axEntries.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				if(m_axEntries[i].m_iID==p_iID)then
					m_axEntries[i].m_iStartTime=p_iStartTime;
					m_axEntries[i].m_iEndTime=p_iEndTime;
					return;
				endif;
			endfor;
			var int iIdx=m_axEntries.NewEntry();
			m_axEntries[iIdx].m_iID=p_iID;
			m_axEntries[iIdx].m_iStartTime=p_iStartTime;
			m_axEntries[iIdx].m_iEndTime=p_iEndTime;
		endproc;

		export proc void ClearData(int p_iID)
			var int i,iC=m_axEntries.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				if(m_axEntries[i].m_iID==p_iID)then
					m_axEntries.DeleteEntry(i);
					return;
				endif;
			endfor;
		endproc;

		export proc void FromString(string p_sData)
			Clear();
			var array string asEntries;
			p_sData.Split(asEntries,"\n",true);
			var int i,iC=asEntries.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				var array string asTiles;
				asEntries[i].Split(asTiles,"\t",true);
				if(asTiles.NumEntries()<3)then continue; endif;
				SetData(asTiles[0].ToInt(),asTiles[1].ToInt(),asTiles[2].ToInt());
			endfor;
		endproc;

		export proc string ToString()
			var string sRet;
			var int i,iC=m_axEntries.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				sRet+=	m_axEntries[i].m_iID.ToString()+"\t"+
						m_axEntries[i].m_iStartTime.ToString()+"\t"+
						m_axEntries[i].m_iEndTime.ToString()+"\n";
			endfor;
			return sRet;
		endproc;
	endclass;

	var ^CObj						m_pxNest;
	var ^CSpinCtrlNumber			m_pxHitpoints;
	var ^CSpinCtrlNumber			m_pxMaxHitpoints;
	var ^CDropList						m_pxSpawnType; // Tierart
	var ^CSpinCtrlNumber			m_pxSpawnAmount;// Wie viele Tiere insgesammt nachproduziert werden, bis das Nest "leer" ist
	var ^CSpinCtrlNumber			m_pxSpawnMax; // Wenn diese Zahl erreicht ist, werden keine neuen Tiere mehr produziert.
	var ^CSpinCtrlNumber			m_pxSpawnRate; // Die Geschwindigkeit, mit der die Zahl der Tiere bis zur max. Zahl aufgefüllt wird
	var ^CSpinCtrlNumber			m_pxAdvanceTime;// Vorlaufzeit, simuliert die Population, als wenn die angegebene Zeit vergangen waere
	var ^CList								m_pxAnimals; // list of preplaces animals belonging to this nest
	var ^CButton							m_pxAddANML, m_pxRemANML;
	var CTimeTable						m_xHotspotsTimeTable;
	var ^CDropList						m_pxHotspots;
	var ^CSpinCtrlNumber			m_pxHotspotStartTime,m_pxHotspotEndTime;
	var ^CCheckBox						m_pxAutoSetAT; // Henry: set the advance time automatic for the nest (based upon growup duration and spawn max
	var ^CButton							m_pxAutoSetSR; // Henry: reset to default spawn rate (from tt)
	var ^CButton							m_pxInfiniteEggs; // Henry: reset to infinite eggs (-1)
	var ^CButton							m_pxNestReset; // Henry: set nest values to normal state
	var bool									m_bAutoSetAT;
	var bool									m_bChange;

	export constructor()
		if(!InitFromResource("objects/ViewObjProperties","NestProperties"))then
			CClientWrap.LogError("Error","COPNestProperties: InitFromResource failed");
			return;
		endif;
		m_bAutoSetAT=false;
		m_bChange=false;
		m_pxHitpoints=cast<CSpinCtrlNumber>(GetControl("GroupHitpoints/SpinCtrlActualHitpoints"));
		m_pxHitpoints^.SetLimits(0,10000,1);
		m_pxMaxHitpoints=cast<CSpinCtrlNumber>(GetControl("GroupHitpoints/SpinCtrlMaxHitpoints"));
		m_pxMaxHitpoints^.SetLimits(0,10000,1);

		m_pxSpawnType=cast<CDropList>(GetControl("GroupSpawn/SpawnType"));
		m_pxSpawnAmount=cast<CSpinCtrlNumber>(GetControl("GroupSpawn/SpawnAmount"));
		m_pxSpawnAmount^.SetLimits(-1,1000,1);
		m_pxSpawnMax=cast<CSpinCtrlNumber>(GetControl("GroupSpawn/SpawnMax"));
		m_pxSpawnMax^.SetLimits(1,50,1);
		m_pxSpawnRate=cast<CSpinCtrlNumber>(GetControl("GroupSpawn/SpawnRate"));
		m_pxSpawnRate^.SetDecimals(1);
		m_pxSpawnRate^.SetLimits(0.0f,10000.0f,1.0f);
		m_pxAdvanceTime=cast<CSpinCtrlNumber>(GetControl("GroupSpawn/AdvanceTime"));
		m_pxAdvanceTime^.SetDecimals(1);
		m_pxAdvanceTime^.SetLimits(0.0f,10000.0f,1.0f);
		m_pxAutoSetAT=cast<CCheckBox>(GetControl("GroupSpawn/AutoSetAT"));
		m_pxAutoSetSR=cast<CButton>(GetControl("GroupSpawn/AutoSetSR"));
		m_pxInfiniteEggs=cast<CButton>(GetControl("GroupSpawn/SpawnReset"));
		m_pxNestReset=cast<CButton>(GetControl("GroupSpawn/NestReset"));
//		m_pxAutoSetAT^.m_xOnStateChange=OnAutoSetAT;
		m_pxAnimals=cast<CList>(GetControl("GroupAnimals/List_Animals"));
		m_pxAddANML=cast<CButton>(GetControl("GroupAnimals/Btn_Add"));
		m_pxRemANML=cast<CButton>(GetControl("GroupAnimals/Btn_Rem"));
		m_pxAddANML^.m_xOnClick = OnAdd;
		m_pxRemANML^.m_xOnClick = OnRem;
		m_pxHotspots=cast<CDropList>(GetControl("GroupHotspots/Hotspots"));
		m_pxHotspotStartTime=cast<CSpinCtrlNumber>(GetControl("GroupHotspots/StartTime"));
		m_pxHotspotEndTime=cast<CSpinCtrlNumber>(GetControl("GroupHotspots/EndTime"));
	endconstructor;

	export destructor()
	enddestructor;

	export proc bool Clear()
		m_bChange=false;
		m_bAutoSetAT=false;
		m_pxAutoSetAT^.SetChecked(0);
		return true;
	endproc;

	proc bool OnAdd()
		var ^COPNestProperties.CSelectAnimalWindow pxWindow = new COPNestProperties.CSelectAnimalWindow(m_pxAnimals);
		CClientWrap.GetDesktop()^.AddChild(pxWindow);
		pxWindow^.FillList(m_pxSpawnType^.GetText());
		pxWindow^.SetVisible(true);
		CWindowMgr.Get().BringWindowToTop(pxWindow,true);
		CWindowMgr.Get().SetModal(pxWindow);
		return true;
	endproc;

	proc bool OnRem()
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		if(pxSel^.NumEntries()==0)then return(false);endif;
		var	^CObj pxObj = (pxSel^)[0].GetObj();
		if(pxObj==null)then return false; endif;
		var array int aiDel;
		var int iSel = m_pxAnimals^.GetSelectedItem();
		if(iSel >= 0)then
			var ^COPNestProperties.CANMLData pxD = cast<COPNestProperties.CANMLData>(m_pxAnimals^.GetItemData(iSel));
			delete pxD;
			m_pxAnimals^.SetItemData(iSel, null);
			m_pxAnimals^.DeleteItem(iSel);
		endif;
		if(m_pxAnimals^.NumItems() > 0)then
			m_pxAnimals^.Select(0);
		endif;

		return true;
	endproc;

	proc void WriteANMLToAttribs(^CAttribs p_pxAttr)
		var int i, iC = m_pxAnimals^.NumItems();
		var string sGuids;
		for(i=0)cond(i<iC)iter(++i)do
			var ^COPNestProperties.CANMLData pxD = cast<COPNestProperties.CANMLData>(m_pxAnimals^.GetItemData(i));
			if(pxD!=null)then
				var ^CObj pxObj = pxD^.m_xObj.GetObj();
				if(pxObj!=null)then
					var string sG = pxObj^.GetGuid().ToString();
					if(sGuids.GetLength()+sG.GetLength()+2>255)then break; endif;
					sGuids +=  sG + "\n";
				endif;
			endif;
		endfor;
		p_pxAttr^.SetValue("preplace_anmls", sGuids);
	endproc;

	proc void ClearAnimalList()
		var int i, iC=m_pxAnimals^.NumItems();
		for(i=0)cond(i<iC)iter(++i)do
			if(m_pxAnimals^.GetItemData(i)!=null)then
				delete m_pxAnimals^.GetItemData(i);
			endif;
		endfor;
		m_pxAnimals^.Clear();
	endproc;

	proc void ReadANMLFromAttribs(^CAttribs p_pxAttr)
		ClearAnimalList();
		var string sGuids = p_pxAttr^.GetValue("preplace_anmls");
		var array string asToks;
		sGuids.Split(asToks, "\n", true);
		var CGuid xG;
		var int i,iC = asToks.NumEntries();
		for(i=0)cond(i<iC)iter(++i)do
			xG.FromString(asToks[i]);
			var ^CObj pxObj = CClientWrap.GetObjMgr().GetObj(xG);
			if(pxObj!=null)then
				var ^COPNestProperties.CANMLData pxD = new COPNestProperties.CANMLData();
				pxD^.m_xObj = pxObj^.GetHandle();
				m_pxAnimals^.AddItem(pxObj^.GetName(), pxD);
			endif;
		endfor;
	endproc;

	proc string GetTerrainSetting()
		var bitset dwSetting=CLevelEditorWrap.GetScapeMgr().GetTerrainSetting();
		if(dwSetting==00000b)then
			return "Northland";
		elseif(dwSetting==00001b)then
			return "Savanna";
		elseif(dwSetting==00010b)then
			return "Jungle";
		elseif(dwSetting==00011b)then
			return "Icewaste";
		elseif(dwSetting==00100b)then
			return "Ashvalley";
		elseif(dwSetting==00101b)then
			return "Test";
		elseif(dwSetting==00110b)then
			return "Cave1";
		elseif(dwSetting==00111b)then
			return "Cave2";
		elseif(dwSetting==01000b)then
			return "Cave3";
		endif;
		return "";
	endproc;

	export proc bool Update()
		m_pxNest=null;
		m_pxHitpoints^.m_xOnChange.Clear();
		m_pxMaxHitpoints^.m_xOnChange.Clear();
		m_pxAnimals^.m_xOnSelect.Clear();
		m_pxSpawnType^.m_xOnChange.Clear();
		m_pxHotspots^.m_xOnChange.Clear();
		m_pxHotspotStartTime^.m_xOnChange.Clear();
		m_pxHotspotEndTime^.m_xOnChange.Clear();
		m_xHotspotsTimeTable.Clear();
		m_bChange=false;
		m_bAutoSetAT=false;
		m_pxAutoSetAT^.SetChecked(0);
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		if(pxSel^.NumEntries()==1)then
			var ^CObj pxObj=(pxSel^)[0].GetObj();
			if(pxObj!=null)then
				if(pxObj^.GetType()=="NEST")then
					m_pxNest=pxObj;
				endif;
			endif;
		endif;
		SetDisabled(m_pxNest==null);
		if(m_pxNest!=null)then
			m_pxSpawnType^.Clear();
			var string sClass = m_pxNest^.GetClassName();
			var string sSetting=GetTerrainSetting();
			if(sClass.Find("Nest_Armoured_Dinosaur")>=0)then
				//if(sSetting=="Savanna")then
					// savanna
					m_pxSpawnType^.AddItem("Achelousaurus");
				//endif;
				//world
				m_pxSpawnType^.AddItem("Ankylosaurus");
				//if(sSetting=="Jungle")then
					// jungle
					m_pxSpawnType^.AddItem("Euoplocephalus");
				//endif;
				m_pxSpawnType^.AddItem("Kentrosaurus");
				//if(sSetting=="Ashvalley")then
					// ashvalley
					m_pxSpawnType^.AddItem("Panoplosaurus");
				//endif;
				//if(sSetting=="Savanna")then
					// savanna
					m_pxSpawnType^.AddItem("Pentaceratops");
				//endif;
				//if(sSetting=="Ashvalley")then
					// ashvalley
					m_pxSpawnType^.AddItem("Polakanthus");
				//endif;
				m_pxSpawnType^.AddItem("Stegosaurus");
				//if(sSetting=="Ashvalley")then
					// ashvalley
					m_pxSpawnType^.AddItem("Stygimoloch");
				//endif;
				//if(sSetting=="Savanna")then
					// savanna
					m_pxSpawnType^.AddItem("Styracosaurus");
				//endif;
				m_pxSpawnType^.AddItem("Triceratops");
				
			elseif(sClass.Find("Nest_HC_Cititzen")>=0)then
				//world
				m_pxSpawnType^.AddItem("hc_citizen_01_animal");
				m_pxSpawnType^.AddItem("hc_guard_01_animal");
				m_pxSpawnType^.AddItem("hc_worker_01_animal");
			elseif(sClass.Find("Nest_Small_Carnivores")>=0)then
				//if(sSetting=="Jungle")then
					// jungle
					m_pxSpawnType^.AddItem("Deinonychus");
				//endif;
				//world
				m_pxSpawnType^.AddItem("Dilophosaurus");
				m_pxSpawnType^.AddItem("Gallimimus");
				//if(sSetting=="Ashvalley")then
				// ashvalley
					m_pxSpawnType^.AddItem("Heterodontosaurus");
				//endif;
				//if(sSetting=="Jungle")then
					// jungle
					m_pxSpawnType^.AddItem("Oviraptor");
					m_pxSpawnType^.AddItem("Psittacosaurus");
				//endif;
				m_pxSpawnType^.AddItem("Velociraptor");
			elseif(sClass.Find("Nest_Big_Carnivores")>=0)then
				//world
				m_pxSpawnType^.AddItem("Allosaurus");
				m_pxSpawnType^.AddItem("Atroxosaurus");
				m_pxSpawnType^.AddItem("Baryonyx");
				//if(sSetting=="Savanna")then
					// savanna
					m_pxSpawnType^.AddItem("Carcharodontosaurus");
				//endif;
				//if(sSetting=="Ashvalley")then
					// ashvalley
					m_pxSpawnType^.AddItem("Carnotaurus");
					m_pxSpawnType^.AddItem("Ceratosaurus");
				//endif;
				//if(sSetting=="Northland")then
				// northland
					m_pxSpawnType^.AddItem("Gigantosaurus");
				//endif;
				m_pxSpawnType^.AddItem("Spinosaurus");
				//if(sSetting=="Jungle")then
				// jungle
					m_pxSpawnType^.AddItem("Tarbosaurus");
				//endif;
//				m_pxSpawnType^.AddItem("arena_atroxosaurus");
			elseif(sClass.Find("Nest_Small_Birds") >= 0)then
				//if(sSetting=="Jungle")then
					// jungle
					m_pxSpawnType^.AddItem("Archaeopteryx");
				//endif;
				//world
//				m_pxSpawnType^.AddItem("Sordes");

			elseif(sClass.Find("Nest_Birds") >= 0)then
				//if(sSetting=="Ashvalley")then
					// ashvalley
//					m_pxSpawnType^.AddItem("Ornithocheirus");
				//endif;
				//world
				m_pxSpawnType^.AddItem("Pteranodon");
				//if(sSetting=="Icewaste")then
					// icewaste
//					m_pxSpawnType^.AddItem("Quetzalcoatlus");
				//endif;
			elseif(sClass.Find("Nest_Hadrosaurs")>=0)then
				//if(sSetting=="Jungle")then
					// jungle
					m_pxSpawnType^.AddItem("Corythosaurus");
				//endif;
				//if(sSetting=="Icewaste")then
				// icewaste
					m_pxSpawnType^.AddItem("Edmontosaurus");
				//endif
				//world
				m_pxSpawnType^.AddItem("Iguanodon");
				//if(sSetting=="Northland")then
					// northland
					m_pxSpawnType^.AddItem("Lambeosaurus");
				//endif;
				//if(sSetting=="Savanna")then
					// savanna
					m_pxSpawnType^.AddItem("Maiasauria");
				//endif;
				m_pxSpawnType^.AddItem("Parasaurolophus");
				//if(sSetting=="Northland")then
					// northland
					m_pxSpawnType^.AddItem("Tsintaosaurus");
				//endif;
			elseif(sClass.Find("Nest_Saurpods")>=0)then
				//if(sSetting=="Savanna")then
					// savanna
					m_pxSpawnType^.AddItem("Amargasaurus");
				//endif;
				//if(sSetting=="Jungle")then
					// jungle
					m_pxSpawnType^.AddItem("Apatosaurus");
				//endif;
				//world
				m_pxSpawnType^.AddItem("Brachiosaurus");
				//if(sSetting=="Savanna")then
					// savanna
					m_pxSpawnType^.AddItem("Diplodocus");
				//endif;
				m_pxSpawnType^.AddItem("Saltasaurus");
			elseif(sClass.Find("Nest_Mammal_Cave") >= 0)then
				//world
				m_pxSpawnType^.AddItem("Eusmilus");
				m_pxSpawnType^.AddItem("Gigantopithecus");
				m_pxSpawnType^.AddItem("Lemur");
				m_pxSpawnType^.AddItem("Mammoth");
				m_pxSpawnType^.AddItem("Megaloceros");
//				m_pxSpawnType^.AddItem("Samurai_Squirrel");
				m_pxSpawnType^.AddItem("Sloth");
				m_pxSpawnType^.AddItem("Smilodon");
				m_pxSpawnType^.AddItem("Wild_Boar");
				m_pxSpawnType^.AddItem("Woolly_Rhino");
			elseif(sClass.Find("ice_mammal_cave")>=0)then
				//world
				m_pxSpawnType^.AddItem("Eusmilus");
				m_pxSpawnType^.AddItem("Gigantopithecus");
				m_pxSpawnType^.AddItem("Lemur");
				m_pxSpawnType^.AddItem("Mammoth");
				m_pxSpawnType^.AddItem("Megaloceros");
				m_pxSpawnType^.AddItem("Sloth");
				m_pxSpawnType^.AddItem("Smilodon");
				m_pxSpawnType^.AddItem("Wild_Boar");
				m_pxSpawnType^.AddItem("Woolly_Rhino");
			elseif(sClass.Find("Nest_Swimmer")>=0)then
				//if(sSetting=="Icewaste")then
					// icewaste
					m_pxSpawnType^.AddItem("Bothriolepis");
					m_pxSpawnType^.AddItem("Dunkleosteus");
					m_pxSpawnType^.AddItem("Henodus");
				//endif;
				m_pxSpawnType^.AddItem("Kronosaurus");
				m_pxSpawnType^.AddItem("Macrolemys");
				//if(sSetting=="Jungle")then
					// jungle
					m_pxSpawnType^.AddItem("Mosasaurus");
				//endif;
				m_pxSpawnType^.AddItem("Muraenosaurus");
				m_pxSpawnType^.AddItem("Placohelys");
				m_pxSpawnType^.AddItem("Nothosaurus");
				//if(sSetting=="Icewaste")then
					// icewaste
					m_pxSpawnType^.AddItem("Liopleurodon");
				//endif;
			endif;

			/*
			nicht zugeordnete Tiere
			world:
			??? Tristychius

			icewaste:
			??? Bothriolepis
			??? Henodus

			jungle:
			??? Dimorphodon
			??? Iberomesornis

			northland:
			??? Anurognathus
			??? Ctenurella
			??? Hypsidoris
			*/

			var ^CAttribs pxAttribs=m_pxNest^.GetAttribs();
			if(pxAttribs!=null)then
				m_pxHitpoints^.SetValue(pxAttribs^.GetValueInt("hitpoints"));
				m_pxMaxHitpoints^.SetValue(pxAttribs^.GetValueInt("maxhitpoints"));

				var int iP = m_pxSpawnType^.FindItem(pxAttribs^.GetValue("spawn_type"));
				if(iP>=0)then m_pxSpawnType^.Select(iP); endif;
				OnChangeSpawnType();
				m_pxSpawnAmount^.SetValue(pxAttribs^.GetValueInt("spawn_amount"));

				m_pxSpawnMax^.SetValue(pxAttribs^.GetValueInt("spawn_max"));
				m_pxSpawnRate^.SetValue(pxAttribs^.GetValueFloat("spawn_rate"));
				m_pxAdvanceTime^.SetValue(pxAttribs^.GetValueFloat("advance_time"));
				ReadANMLFromAttribs(pxAttribs);

				m_pxHitpoints^.m_xOnChange=OnChangeHitpoints;
				m_pxMaxHitpoints^.m_xOnChange=OnChangeMaxHitpoints;
				m_pxSpawnType^.m_xOnChange=OnChangeSpawnType;
				m_pxSpawnAmount^.m_xOnChange=OnChangeSpawnAmount;
				m_pxSpawnMax^.m_xOnChange=OnChangeSpawnMax;
				m_pxSpawnRate^.m_xOnChange=OnChangeSpawnRate;
				m_pxAdvanceTime^.m_xOnChange=OnChangeAdvanceTime;
				m_pxAutoSetAT^.m_xOnStateChange=OnAutoSetAT;
				m_pxAutoSetSR^.m_xOnClick=OnAutoSetSR;
				m_pxInfiniteEggs^.m_xOnClick=OnSpawnReset;
				m_pxNestReset^.m_xOnClick=OnNestReset;
				m_pxAnimals^.m_xOnSelect=OnChangeAnimals;
				m_bChange=true;
				m_xHotspotsTimeTable.FromString(pxAttribs^.GetValue("hotspot_timetable"));

				begin FillHotspots;
					var string sHotSpotArea=m_pxNest^.GetName()+"_HotspotArea";
					var ^CRegionMgrClient pxRMgr=CClientWrap.GetRegionMgr();
					var ^CRegionBase pxRgn=pxRMgr^.GetRegion(sHotSpotArea);
					m_pxHotspots^.Clear();
					m_pxHotspots^.SetDisabled(pxRgn==null);
					if(pxRgn!=null)then
						var int i,iC=pxRgn^.NumSubs();
						for(i=0)cond(i<iC)iter(i++)do
							m_pxHotspots^.AddItem(i.ToString());
						endfor;
					endif;
					OnChangeHotspot();
				end FillHotspots;

				m_pxHotspots^.m_xOnChange=OnChangeHotspot;
				m_pxHotspotStartTime^.m_xOnChange=OnChangeHotspotTime;
				m_pxHotspotEndTime^.m_xOnChange=OnChangeHotspotTime;
			endif;
		endif;
		return true;
	endproc;

	proc bool OnChangeHotspot()
		m_pxHotspotStartTime^.m_xOnChange.Clear();
		m_pxHotspotEndTime^.m_xOnChange.Clear();

		m_pxHotspotStartTime^.SetDisabled(m_pxHotspots^.GetDisabled());
		m_pxHotspotEndTime^.SetDisabled(m_pxHotspots^.GetDisabled());

		if(m_pxNest!=null)then
			var int iStart,iEnd;
			m_xHotspotsTimeTable.GetData(m_pxHotspots^.GetText().ToInt(),iStart,iEnd);
			m_pxHotspotStartTime^.SetValue(iStart);
			m_pxHotspotEndTime^.SetValue(iEnd);
		endif;

		m_pxHotspotStartTime^.m_xOnChange=OnChangeHotspotTime;
		m_pxHotspotEndTime^.m_xOnChange=OnChangeHotspotTime;

		return true;
	endproc;

	proc bool OnChangeHotspotTime()
		if(m_pxNest!=null)then
			m_xHotspotsTimeTable.SetData(m_pxHotspots^.GetText().ToInt(),m_pxHotspotStartTime^.GetValueInt(),m_pxHotspotEndTime^.GetValueInt());
			var ^CAttribs pxAttribs=m_pxNest^.GetAttribs();
			if(pxAttribs!=null)then
				pxAttribs^.SetValue("hotspot_timetable",m_xHotspotsTimeTable.ToString());
				CEvt_UpdateAttribs.Send(m_pxNest^.GetGuid());
			endif;
		endif;
		return true;
	endproc;

	export proc bool OnChangeAnimals()
		if(m_pxNest!=null)then
			var ^CAttribs pxA = m_pxNest^.GetAttribs();
			if(pxA!=null)then
				WriteANMLToAttribs(pxA);
				CEvt_UpdateAttribs.Send(m_pxNest^.GetGuid());
			endif;
		endif;
		return true;
	endproc;

	export proc bool OnChangeHitpoints();
		if(m_pxNest!=null)then
			var ^CAttribs pxAttribs=m_pxNest^.GetAttribs();
			var int iHP=m_pxHitpoints^.GetValueInt();
			pxAttribs^.SetValue("hitpoints",iHP);
			CEvt_UpdateAttribs.Send(m_pxNest^.GetGuid());
		endif;
		return(true);
	endproc;

	export proc bool OnChangeMaxHitpoints();
		if(m_pxNest!=null)then
			var ^CAttribs pxAttribs=m_pxNest^.GetAttribs();
			var int iMaxHP=m_pxMaxHitpoints^.GetValueInt();
			pxAttribs^.SetValue("maxhitpoints",iMaxHP);
			m_pxHitpoints^.SetLimits(0,iMaxHP,1);
			CEvt_UpdateAttribs.Send(m_pxNest^.GetGuid());
		endif;
		return(true);
	endproc;

	export proc bool OnChangeSpawnType();
		if(m_pxNest!=null)then
			var ^CAttribs pxAttribs=m_pxNest^.GetAttribs();
			var string sType=m_pxSpawnType^.GetText();
			if(sType.IsEmpty())then return false; endif;
			begin;
				var CTechTreeDef xTTDef;
				var ^CTechTreeMgr pxTTMgr=^(CLevelEditorWrap.GetClient().GetTechTreeMgr());
				var CTechTree xTT=pxTTMgr^.GetTechTree(xTTDef);
				var real fGrowUp=xTT.GetValueR("/Objects/World/ANML/"+sType+"/growup_duration",0.0f);
				m_pxSpawnType^.SetToolTipText(sType+" grows up in "+fGrowUp.ToString());
				if(m_bChange)then
//					var real fDefaultSpawnRate=xTT.GetValueR("/Objects/World/ANML/"+sType+"/spawn_rate",0.0f);
					var real fDefaultSpawnRate=Math.Clamp(xTT.GetValueR("/Objects/World/ANML/"+sType+"/spawn_rate",0.0f), 0.0f,10000.0f);
					m_pxSpawnRate^.SetValue(fDefaultSpawnRate);
					OnChangeSpawnRate();
				endif;
			end;
			// Henry: for making my job easier...
			UpdateAdvanceTimeAuto();
			pxAttribs^.SetValue("spawn_type",sType);
			CEvt_UpdateAttribs.Send(m_pxNest^.GetGuid());
		endif;
		return(true);
	endproc;

	export proc bool OnChangeSpawnAmount();
		if(m_pxNest!=null)then
			var ^CAttribs pxAttribs=m_pxNest^.GetAttribs();
			var int iSA=m_pxSpawnAmount^.GetValueInt();
			pxAttribs^.SetValue("spawn_amount",iSA);
			CEvt_UpdateAttribs.Send(m_pxNest^.GetGuid());
		endif;
		return(true);
	endproc;

	export proc bool OnChangeSpawnMax();
		if(m_pxNest!=null)then
			var ^CAttribs pxAttribs=m_pxNest^.GetAttribs();
			var int iSMax=m_pxSpawnMax^.GetValueInt();
			// Henry: for making my job easier...
			UpdateAdvanceTimeAuto();
			pxAttribs^.SetValue("spawn_max",iSMax);
			CEvt_UpdateAttribs.Send(m_pxNest^.GetGuid());
		endif;
		return(true);
	endproc;

	export proc bool OnChangeSpawnRate();
		if(m_pxNest!=null)then
			var ^CAttribs pxAttribs=m_pxNest^.GetAttribs();
			var real fSR=m_pxSpawnRate^.GetValueFloat();
			pxAttribs^.SetValue("spawn_rate",fSR);
			CEvt_UpdateAttribs.Send(m_pxNest^.GetGuid());
		endif;
		return(true);
	endproc;

	export proc bool OnChangeAdvanceTime();
		if(m_pxNest!=null)then
			var ^CAttribs pxAttribs=m_pxNest^.GetAttribs();
			var real fAT=m_pxAdvanceTime^.GetValueFloat();
			pxAttribs^.SetValue("advance_time",fAT);
			CEvt_UpdateAttribs.Send(m_pxNest^.GetGuid());
		endif;
		return(true);
	endproc;

	export proc bool UpdateAdvanceTimeAuto();
		if(!m_bAutoSetAT)then return true; endif;
		if(m_pxNest!=null)then
			var ^CAttribs pxAttribs=m_pxNest^.GetAttribs();
			var string sType=m_pxSpawnType^.GetText();
			var real fGrowUp;
			if(sType.IsEmpty())then return false; endif;
			begin TTDataCollection;
				var CTechTreeDef xTTDef;
				var ^CTechTreeMgr pxTTMgr=^(CLevelEditorWrap.GetClient().GetTechTreeMgr());
				var CTechTree xTT=pxTTMgr^.GetTechTree(xTTDef);
				fGrowUp=xTT.GetValueR("/Objects/World/ANML/"+sType+"/growup_duration",0.0f);
			end TTDataCollection;
			var real fSMax=m_pxSpawnMax^.GetValueInt().ToReal();
			var real fAutoAT=Math.Clamp(fSMax*fGrowUp, 0.0f,10000.0f);
			m_pxAdvanceTime^.SetValue(fAutoAT);
			pxAttribs^.SetValue("advance_time",fAutoAT);
		endif;
		return true;
	endproc;

	export proc bool OnAutoSetAT();
		m_bAutoSetAT=m_pxAutoSetAT^.GetCheckMark();
		if(m_bAutoSetAT)then
			UpdateAdvanceTimeAuto();
		endif;
		return true;
	endproc;

	export proc bool OnAutoSetSR();
		OnChangeSpawnType();
		return true;
	endproc;

	export proc bool OnSpawnReset();
		if(m_pxNest!=null)then
			var ^CAttribs pxAttribs=m_pxNest^.GetAttribs();
			m_pxSpawnAmount^.SetValue(-1);
			pxAttribs^.SetValue("spawn_amount",-1);
			CEvt_UpdateAttribs.Send(m_pxNest^.GetGuid());
		endif;
		return(true);
	endproc;

	export proc bool OnNestReset();
		if(m_pxNest!=null)then
			m_bAutoSetAT=true;
			m_pxAutoSetAT^.SetChecked(1);
			OnChangeSpawnType();
			var ^CAttribs pxAttribs=m_pxNest^.GetAttribs();
			m_pxSpawnAmount^.SetValue(-1);
			pxAttribs^.SetValue("spawn_amount",-1);
			CEvt_UpdateAttribs.Send(m_pxNest^.GetGuid());
		endif;
		return(true);
	endproc;

endclass;

class COPLinkProperties inherit CFrameWindow

	class COLI inherit CItemData
		var CClntHndl m_xHndl;
		export constructor(ref CClntHndl p_rxHndl)
			m_xHndl=p_rxHndl;
		endconstructor;
		export proc CClntHndl GetHndl();
			return(m_xHndl);
		endproc;
	endclass;
	
	var ^CDropList			m_pxLinks;
	var ^CEdit				m_pxPosition;
	var ^CEdit				m_pxRotation;
//	var ^CButton			m_pxLinkToLink;
	var ^CButton			m_pxMoveToScapeLevel;
	var ^CButton			m_pxResetRot;
	var ^CButton			m_pxMoveToLink;
	var ^CButton			m_pxMoveToObject;
	var ^CButton			m_pxDeleteRallyPoint;
	var ^CList				m_pxObjectList;

	export constructor()
		if(!InitFromResource("objects/ViewObjProperties","LinkProperties"))then
			CClientWrap.LogInfo("Error","COPLinkProperties: InitFromResource failed");
			return;
		endif;

		m_pxLinks=cast<CDropList>(GetControl("GroupBoxMain/LinkDropList"));
		m_pxLinks^.m_xOnChange=OnSelectLink;

		m_pxPosition=cast<CEdit>(GetControl("GroupBoxMain/WorldPosEdit"));
		m_pxRotation=cast<CEdit>(GetControl("GroupBoxMain/WorldRotEdit"));

//		m_pxLinkToLink=cast<CButton>(GetControl("GroupBoxMain/LinkObject"));
//		m_pxLinkToLink^.m_xOnClick=OnLinkToLink;
// Henry: cut from srf file:
//							LayoutBox {
//								style = 'prop'
//								scale = '0.12'
//								LinkObject {
//									type = 'CButton'
//									caption = 'Link to Link'
//									disabled = '1'
//								}
//							}
		
		m_pxMoveToScapeLevel=cast<CButton>(GetControl("GroupBoxMain/MoveToScapeLevel"));
		m_pxMoveToScapeLevel^.m_xOnClick=OnMoveToScape;
		
		m_pxResetRot=cast<CButton>(GetControl("GroupBoxMain/ResetRot"));
		m_pxResetRot^.m_xOnClick=OnResetRot;
		
		m_pxMoveToLink=cast<CButton>(GetControl("GroupBoxMain/MoveToLink"));
		m_pxMoveToLink^.m_xOnClick=OnMoveToLink;
		
		m_pxMoveToObject=cast<CButton>(GetControl("GroupBoxMain/MoveToObject"));
		m_pxMoveToObject^.m_xOnClick=OnMoveToObject;
		
		m_pxDeleteRallyPoint=cast<CButton>(GetControl("GroupBoxMain/DeleteRallyPoint"));
		m_pxDeleteRallyPoint^.m_xOnClick=OnDeleteRallyPoint;
		
		m_pxObjectList=cast<CList>(GetControl("GroupBoxMain/ObjectList"));
		m_pxObjectList^.AllowMultiSelection(true);
		m_pxObjectList^.AllowScrollBar(true);
		m_pxObjectList^.AllowScrollBarHor(true);
		m_pxObjectList^.m_xOnLBtnDblClick = JumpToObj;
	endconstructor;

	export destructor()
	enddestructor;

	export proc bool Clear()
		return true;
	endproc;

	export proc bool Update(bool p_bParam)
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		if(pxSel^.NumEntries()==0)then return(false);endif;
		var ^CObj pxObj=(pxSel^)[0].GetObj();
		m_pxLinks^.Clear();
		if(pxObj!=null)then
			if(pxObj^.GetNumLinks()!=0)then
				var int i;
				for(i=0)cond(i<pxObj^.GetNumLinks())iter(i++)do
					var CFourCC xLink;
					var vec3 vPos;
					var Quat qRotation;
					pxObj^.GetLinkDesc(i,vPos,qRotation,xLink);
					m_pxLinks^.AddItem(xLink.AsString());
					m_pxPosition^.SetText(vPos.ToString());
					m_pxRotation^.SetText(qRotation.ToString());
				endfor;
			endif;
			m_pxObjectList^.Clear();
			var ^CObjMgr pxObjMgr=^(CClientWrap.GetObjMgr());
			var int i,iC=pxObjMgr^.NumObjects();
			for(i=0)cond(i<iC)iter(i++)do
				var ^CObj pxObj=pxObjMgr^.GetObjByID(i);
				if(pxObj==null)then continue; endif;
				m_pxObjectList^.AddItem(pxObj^.GetName(), new COLI(pxObj^.GetHandle()));
			endfor;
			if(m_pxObjectList^.NumItems()>1)then
				m_pxObjectList^.QSort();
			endif;
//			if(CEnhancedMenu.Get().GetObjFinder()^.GetList()!=null)then
//				if(CEnhancedMenu.Get().GetObjFinder()^.GetList()^.NumItems()!=0)then
//					var int i;
//					for(i=0)cond(i<CEnhancedMenu.Get().GetObjFinder()^.GetList()^.NumItems())iter(i++)do
//						var ^CFinderItem pxItem=cast<CFinderItem>(CEnhancedMenu.Get().GetObjFinder()^.GetList()^.GetItemData(i));
//						if(pxItem==null)then continue; endif;
////						if(pxItem^.GetType()!=CFinderItem.TYPE_OBJECT)then continue; endif;
//						var CClntHndl xSub=(cast<CFinderItemObject>(pxItem))^.GetHndl();
//						if(!xSub.IsValid())then continue; endif;
//						m_pxObjectList^.AddItem(xSub.GetObj()^.GetName(), new COLI(xSub));
////						m_pxObjectList^.AddItem(CEnhancedMenu.Get().GetObjFinder()^.GetList()^.GetItem(i));
//						/*
//						var ^CFinderItem pxTempItem=cast<CFinderItem>(CEnhancedMenu.Get().GetObjFinder()^.GetList()^.GetItemData(i));
//						var ^CObj pxTempObj=pxTempItem^.GetHndl().GetObj();
//						if(pxTempObj==pxObj)then
//							m_pxObjectList^.DeleteItem(m_pxObjectList^.NumItems()-1);
//						endif;
//						*/
//					endfor;
//					m_pxObjectList^.QSort();
//				endif;
//			endif;
		endif;
		return(true);
	endproc;

	export proc bool OnDeleteRallyPoint()
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		var int iOI,iNumSel;
		iNumSel=pxSel^.NumEntries();
		if(iNumSel<1)then return(false);endif;
		for(iOI=0)cond(iOI<iNumSel)iter(iOI++)do
			var ^CObj pxObj=(pxSel^)[iOI].GetObj();
			if(pxObj!=null)then
				var ^CAttribs pxAttribs=pxObj^.GetAttribs();
				if(pxAttribs!=null)then
					var CFourCC xLink = "Ex_1";
					var vec3 vPos=pxObj^.GetPos();
					var Quat qRot;
					pxObj^.GetLinkPosRotWorld(xLink,vPos,qRot);
					pxAttribs^.SetValue("RallyPoint", vPos.ToString());
					CEvt_UpdateAttribs.Send(pxObj^.GetGuid());
				endif;
			endif;
		endfor;
		return true;
	endproc;

	export proc bool OnLinkToLink()
		//ToDo
		return true;
	endproc;

	export proc bool OnMoveToLink()
		var CFourCC xLink;
		var vec3 vPos;
		var Quat qRotation;
		if(m_pxLinks^.GetSelectedItem()<0)then return false; endif;
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		if(pxSel^.NumEntries()<1)then return false ;endif;
		var	^CObj pxSO=(pxSel^)[0].GetObj();
		if(pxSO==null)then return false; endif;
		pxSO^.GetLinkDesc(m_pxLinks^.GetSelectedItem(),vPos,qRotation,xLink);
		var mat4 mTransform;
		pxSO^.GetRot().ToMat4U(mTransform);
		mTransform.TranslateQ(pxSO^.GetPos().GetX(),pxSO^.GetPos().GetY(),pxSO^.GetPos().GetZ());
		mTransform.VecMult(vPos,vPos);
		qRotation*=pxSO^.GetRot();
		var int k,kC=m_pxObjectList^.NumItems();
		for(k=0)cond(k<kC)iter(k++)do
			if(!m_pxObjectList^.IsItemSelected(k))then continue; endif;
			var ^COLI pxTemp=cast<COLI>(m_pxObjectList^.GetItemData(k));
			var ^CObj pxObj=pxTemp^.GetHndl().GetObj();
			if(pxObj!=null)then
				CEvt_SetPos.Send(pxObj^.GetGuid(),vPos);
				CEvt_SetRot.Send(pxObj^.GetGuid(),qRotation);
			endif;
		endfor;
		return true;
	endproc;

	export proc bool OnSelectLink()
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		if(pxSel^.NumEntries()==0)then return(false);endif;
		var ^CObj pxObj=(pxSel^)[0].GetObj();
		if(pxObj!=null)then
			var CFourCC xLink;
			var vec3 vPos;
			var Quat qRotation;
			if(m_pxLinks^.GetSelectedItem()!=(-1))then
				pxObj^.GetLinkDesc(m_pxLinks^.GetSelectedItem(),vPos,qRotation,xLink);
				m_pxPosition^.SetText(vPos.ToString());
				m_pxRotation^.SetText(qRotation.ToString());
			endif;
		endif;
		return true;
	endproc;
	
	export proc bool OnMoveToScape()
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		var int i,iC=pxSel^.NumEntries();
		var real fWater=CClientWrap.GetScapeMgr().GetSeaLevel();
		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xObj=(pxSel^)[i];
			var ^CObj pxObj=xObj.GetObj();
			if(pxObj==null)then continue; endif;
			var vec3 vPos=pxObj^.GetPos();
			var real fHeight=CClientWrap.GetScapeMgr().GetHeight(vPos.GetX(), vPos.GetY());
			vPos.SetZ(Math.Max(fHeight,fWater));
			CEvt_SetPos.Send(pxObj^.GetGuid(),vPos);
		endfor;
		return true;
	endproc
	
	export proc bool OnResetRot()
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		var int i,iC=pxSel^.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xObj=(pxSel^)[i];
			var ^CObj pxObj=xObj.GetObj();
			if(pxObj==null)then continue; endif;
			var Quat qRot=pxObj^.GetRot();
			qRot.SetXYZW(0.0f,0.0f,0.0f,1.0f);
			CEvt_SetRot.Send(pxObj^.GetGuid(),qRot);
		endfor;
		return true;
	endproc
	
	proc bool JumpToObj()
		var int iSel=m_pxObjectList^.GetSelectedItem();
		if(iSel!=-1)then
			if(m_pxObjectList^.GetItemData(iSel)==null)then
				return(false);
			endif;
			var ^COLI pxItem=cast<COLI>(m_pxObjectList^.GetItemData(iSel));
			if(pxItem!=null)then
				var CClntHndl xSub=pxItem^.GetHndl();
				if(xSub.IsValid())then
					CMainController.Get().SetCameraTarget(xSub.GetObj()^.GetPos());
				endif;
			endif;
		endif;
		return(true);
	endproc;

	export proc bool OnMoveToObject()
		var vec3 vPos;
		var Quat qRotation;
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		if(pxSel^.NumEntries()<1)then return false ;endif;
		var ^CObj pxSO=(pxSel^)[0].GetObj();
		if(pxSO==null)then return false; endif;
		vPos=pxSO^.GetPos();
		qRotation=pxSO^.GetRot();
		var int k,kC=m_pxObjectList^.NumItems();
		for(k=0)cond(k<kC)iter(k++)do
			if(!m_pxObjectList^.IsItemSelected(k))then continue; endif;
			var ^COLI pxTemp=cast<COLI>(m_pxObjectList^.GetItemData(k));
			var ^CObj pxObj=pxTemp^.GetHndl().GetObj();
			if(pxObj!=null)then
				CEvt_SetPos.Send(pxObj^.GetGuid(),vPos);
				CEvt_SetRot.Send(pxObj^.GetGuid(),qRotation);
			endif;
		endfor;
		return true;
	endproc;

endclass;

class COPLightProperties inherit CFrameWindow

	var ^CDropList				m_pxType;
	var ^CSpinCtrlNumber	m_pxRange;
	var ^CSpinCtrlNumber	m_pxAtConst;
	var ^CSpinCtrlNumber	m_pxAtLinear;
	var ^CSpinCtrlNumber	m_pxAtSquared;
	var ^CSpinCtrlNumber	m_pxInnerCone;
	var ^CSpinCtrlNumber	m_pxOuterCone;

	var ^CSpinCtrlNumber	m_pxDiffuseRed;
	var ^CSpinCtrlNumber	m_pxDiffuseGreen;
	var ^CSpinCtrlNumber	m_pxDiffuseBlue;

	var ^CSpinCtrlNumber	m_pxAmbientRed;
	var ^CSpinCtrlNumber	m_pxAmbientGreen;
	var ^CSpinCtrlNumber	m_pxAmbientBlue;

	var ^CSpinCtrlNumber	m_pxSpecularRed;
	var ^CSpinCtrlNumber	m_pxSpecularGreen;
	var ^CSpinCtrlNumber	m_pxSpecularBlue;

	var color				m_xDiffuseColor;
	var color				m_xAmbientColor;
	var color				m_xSpecularColor;

	export constructor()
		if(!InitFromResource("objects/ViewObjProperties","LightProperties"))then
			CClientWrap.LogInfo("Error","COPLightProperties: InitFromResource failed");
			return;
		endif;

		m_pxType=cast<CDropList>(GetControl("GroupBoxMain/TypeDropList"));
		m_pxType^.AddItem("Positional");
		m_pxType^.AddItem("Spot");
		m_pxType^.AddItem("Directional");
		m_pxType^.m_xOnChange=OnSelectType;

		m_pxRange=cast<CSpinCtrlNumber>(GetControl("GroupBoxMain/RangeSpinCtrl"));
		m_pxRange^.SetLimits(0,1000,1);
		m_pxRange^.m_xOnChange=OnRangeChange;

		m_pxAtConst=cast<CSpinCtrlNumber>(GetControl("GroupBoxMain/At_ConstSpinCtrl"));
		m_pxAtConst^.SetDecimals(2);
		m_pxAtConst^.SetLimits(0.0,1.0,0.01);
		m_pxAtConst^.m_xOnChange=OnAtConstChange;

		m_pxAtLinear=cast<CSpinCtrlNumber>(GetControl("GroupBoxMain/At_LinearSpinCtrl"));
		m_pxAtLinear^.SetDecimals(2);
		m_pxAtLinear^.SetLimits(0.0,1.0,0.01);
		m_pxAtLinear^.m_xOnChange=OnAtLinearChange;

		m_pxAtSquared=cast<CSpinCtrlNumber>(GetControl("GroupBoxMain/At_SquaredSpinCtrl"));
		m_pxAtSquared^.SetDecimals(2);
		m_pxAtSquared^.SetLimits(0.0,1.0,0.01);
		m_pxAtSquared^.m_xOnChange=OnAtSquaredChange;

		m_pxInnerCone=cast<CSpinCtrlNumber>(GetControl("GroupBoxMain/InnerConeSpinCtrl"));
		m_pxInnerCone^.SetDecimals(2);
		m_pxInnerCone^.SetLimits(0.0,1.0,0.01);
		m_pxInnerCone^.m_xOnChange=OnInnerCone;

		m_pxOuterCone=cast<CSpinCtrlNumber>(GetControl("GroupBoxMain/OuterConeSpinCtrl"));
		m_pxOuterCone^.SetDecimals(2);
		m_pxOuterCone^.SetLimits(0.0,1.0,0.01);
		m_pxOuterCone^.m_xOnChange=OnOuterCone;

		//Diffuse
		m_pxDiffuseRed=cast<CSpinCtrlNumber>(GetControl("GroupBoxMain/GroupBoxDiffuse/Red"));
		m_pxDiffuseRed^.SetLimits(0,255,1);
		m_pxDiffuseRed^.m_xOnChange = OnChangeDiffuseRed;
		m_pxDiffuseGreen=cast<CSpinCtrlNumber>(GetControl("GroupBoxMain/GroupBoxDiffuse/Green"));
		m_pxDiffuseGreen^.SetLimits(0,255,1);
		m_pxDiffuseGreen^.m_xOnChange = OnChangeDiffuseGreen;
		m_pxDiffuseBlue=cast<CSpinCtrlNumber>(GetControl("GroupBoxMain/GroupBoxDiffuse/Blue"));
		m_pxDiffuseBlue^.SetLimits(0,255,1);
		m_pxDiffuseBlue^.m_xOnChange = OnChangeDiffuseBlue;

		//Ambient
		m_pxAmbientRed=cast<CSpinCtrlNumber>(GetControl("GroupBoxMain/GroupBoxAmbient/Red"));
		m_pxAmbientRed^.SetLimits(0,255,1);
		m_pxAmbientRed^.m_xOnChange = OnChangeAmbientRed;
		m_pxAmbientGreen=cast<CSpinCtrlNumber>(GetControl("GroupBoxMain/GroupBoxAmbient/Green"));
		m_pxAmbientGreen^.SetLimits(0,255,1);
		m_pxAmbientGreen^.m_xOnChange = OnChangeAmbientGreen;
		m_pxAmbientBlue=cast<CSpinCtrlNumber>(GetControl("GroupBoxMain/GroupBoxAmbient/Blue"));
		m_pxAmbientBlue^.SetLimits(0,255,1);
		m_pxAmbientBlue^.m_xOnChange = OnChangeAmbientBlue;

		//Specular
		m_pxSpecularRed=cast<CSpinCtrlNumber>(GetControl("GroupBoxMain/GroupBoxSpecular/Red"));
		m_pxSpecularRed^.SetLimits(0,255,1);
		m_pxSpecularRed^.m_xOnChange = OnChangeSpecularRed;
		m_pxSpecularGreen=cast<CSpinCtrlNumber>(GetControl("GroupBoxMain/GroupBoxSpecular/Green"));
		m_pxSpecularGreen^.SetLimits(0,255,1);
		m_pxSpecularGreen^.m_xOnChange = OnChangeSpecularGreen;
		m_pxSpecularBlue=cast<CSpinCtrlNumber>(GetControl("GroupBoxMain/GroupBoxSpecular/Blue"));
		m_pxSpecularBlue^.SetLimits(0,255,1);
		m_pxSpecularBlue^.m_xOnChange = OnChangeSpecularBlue;

	endconstructor;

	export destructor()
	enddestructor;

	export proc bool Clear()
		m_pxType^.m_xOnChange.Clear();
		m_pxRange^.m_xOnChange.Clear();
		m_pxAtConst^.m_xOnChange.Clear();
		m_pxAtLinear^.m_xOnChange.Clear();
		m_pxAtSquared^.m_xOnChange.Clear();
		m_pxInnerCone^.m_xOnChange.Clear();
		m_pxOuterCone^.m_xOnChange.Clear();
		m_pxDiffuseRed^.m_xOnChange.Clear();
		m_pxDiffuseGreen^.m_xOnChange.Clear();
		m_pxDiffuseBlue^.m_xOnChange.Clear();
		m_pxAmbientRed^.m_xOnChange.Clear();
		m_pxAmbientGreen^.m_xOnChange.Clear();
		m_pxAmbientBlue^.m_xOnChange.Clear();
		m_pxSpecularRed^.m_xOnChange.Clear();
		m_pxSpecularGreen^.m_xOnChange.Clear();
		m_pxSpecularBlue^.m_xOnChange.Clear();

		m_pxType^.Select(0);
		m_pxRange^.SetValue(0);
		m_pxAtConst^.SetValue(0.0f);
		m_pxAtLinear^.SetValue(0.0f);
		m_pxAtSquared^.SetValue(0.0f);
		m_pxInnerCone^.SetValue(0.0f);
		m_pxOuterCone^.SetValue(0.0f);

		m_pxDiffuseRed^.SetValue(0);
		m_pxDiffuseGreen^.SetValue(0);
		m_pxDiffuseBlue^.SetValue(0);

		m_pxAmbientRed^.SetValue(0);
		m_pxAmbientGreen^.SetValue(0);
		m_pxAmbientBlue^.SetValue(0);

		m_pxSpecularRed^.SetValue(0);
		m_pxSpecularGreen^.SetValue(0);
		m_pxSpecularBlue^.SetValue(0);

		m_xDiffuseColor={{ 0,0,0,255 }};
		m_xAmbientColor={{ 0,0,0,255 }};
		m_xSpecularColor={{ 0,0,0,255 }};

		//Restore procrefs
		m_pxType^.m_xOnChange=OnSelectType;
		m_pxRange^.m_xOnChange=OnRangeChange;
		m_pxAtConst^.m_xOnChange=OnAtConstChange;
		m_pxAtLinear^.m_xOnChange=OnAtLinearChange;
		m_pxAtSquared^.m_xOnChange=OnAtSquaredChange;
		m_pxInnerCone^.m_xOnChange=OnInnerCone;
		m_pxOuterCone^.m_xOnChange=OnOuterCone;
		m_pxDiffuseRed^.m_xOnChange = OnChangeDiffuseRed;
		m_pxDiffuseGreen^.m_xOnChange = OnChangeDiffuseGreen;
		m_pxDiffuseBlue^.m_xOnChange = OnChangeDiffuseBlue;
		m_pxAmbientRed^.m_xOnChange = OnChangeAmbientRed;
		m_pxAmbientGreen^.m_xOnChange = OnChangeAmbientGreen;
		m_pxAmbientBlue^.m_xOnChange = OnChangeAmbientBlue;
		m_pxSpecularRed^.m_xOnChange = OnChangeSpecularRed;
		m_pxSpecularGreen^.m_xOnChange = OnChangeSpecularGreen;
		m_pxSpecularBlue^.m_xOnChange = OnChangeSpecularBlue;

		return true;
	endproc;

	export proc bool Update()
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		if(pxSel^.NumEntries()==0)then return (false);endif;
		var ^CObj pxObj=(pxSel^)[0].GetObj();
		if(pxObj!=null)then
			var ^CAttribs pxAttribs=pxObj^.GetAttribs();
			if(pxAttribs!=null)then
				if(pxAttribs^.ContainsKey("diffuse"))then
					var string sValue=pxAttribs^.GetValue("diffuse");
					var array string asValues;
					sValue.Split(asValues," ",true);
					m_pxDiffuseRed^.SetValue(asValues[0].ToInt());
					m_pxDiffuseGreen^.SetValue(asValues[1].ToInt());
					m_pxDiffuseBlue^.SetValue(asValues[2].ToInt());
				endif;
				if(pxAttribs^.ContainsKey("ambient"))then
					var string sValue=pxAttribs^.GetValue("ambient");
					var array string asValues;
					sValue.Split(asValues," ",true);
					m_pxAmbientRed^.SetValue(asValues[0].ToInt());
					m_pxAmbientGreen^.SetValue(asValues[1].ToInt());
					m_pxAmbientBlue^.SetValue(asValues[2].ToInt());
				endif;
				if(pxAttribs^.ContainsKey("specular"))then
					var string sValue=pxAttribs^.GetValue("specular");
					var array string asValues;
					sValue.Split(asValues," ",true);
					m_pxSpecularRed^.SetValue(asValues[0].ToInt());
					m_pxSpecularGreen^.SetValue(asValues[1].ToInt());
					m_pxSpecularBlue^.SetValue(asValues[2].ToInt());
				endif;
				if(pxAttribs^.ContainsKey("type"))then
					var string sValue=pxAttribs^.GetValue("type");
					if(sValue=="pos")then
						m_pxType^.Select(m_pxType^.FindItem("Positional"));
					elseif(sValue=="spot")then
						m_pxType^.Select(m_pxType^.FindItem("Spot"));
					elseif(sValue=="dir")then
						m_pxType^.Select(m_pxType^.FindItem("Directional"));
					endif;
				endif;
				if(pxAttribs^.ContainsKey("range"))then
					var int iValue=pxAttribs^.GetValueInt("range");
					m_pxRange^.SetValue(iValue);
				endif;
				if(pxAttribs^.ContainsKey("inner_cone"))then
					var real fValue=pxAttribs^.GetValueFloat("inner_cone");
					m_pxInnerCone^.SetValue(fValue);
				endif;
				if(pxAttribs^.ContainsKey("outer_cone"))then
					var real fValue=pxAttribs^.GetValueFloat("outer_cone");
					m_pxOuterCone^.SetValue(fValue);
				endif;
				if(pxAttribs^.ContainsKey("attenuation_const"))then
					var real fValue=pxAttribs^.GetValueFloat("attenuation_const");
					m_pxAtConst^.SetValue(fValue);
				endif;
				if(pxAttribs^.ContainsKey("attenuation_linear"))then
					var real fValue=pxAttribs^.GetValueFloat("attenuation_linear");
					m_pxAtLinear^.SetValue(fValue);
				endif;
				if(pxAttribs^.ContainsKey("attenuation_squared"))then
					var real fValue=pxAttribs^.GetValueFloat("attenuation_squared");
					m_pxAtSquared^.SetValue(fValue);
				endif;
				m_xDiffuseColor.SetRed(m_pxDiffuseRed^.GetValueInt());
				m_xDiffuseColor.SetGreen(m_pxDiffuseGreen^.GetValueInt());
				m_xDiffuseColor.SetBlue(m_pxDiffuseBlue^.GetValueInt());

				m_xAmbientColor.SetRed(m_pxAmbientRed^.GetValueInt());
				m_xAmbientColor.SetGreen(m_pxAmbientGreen^.GetValueInt());
				m_xAmbientColor.SetBlue(m_pxAmbientBlue^.GetValueInt());

				m_xSpecularColor.SetRed(m_pxSpecularRed^.GetValueInt());
				m_xSpecularColor.SetGreen(m_pxSpecularGreen^.GetValueInt());
				m_xSpecularColor.SetBlue(m_pxSpecularBlue^.GetValueInt());
			endif;
		endif;

		return(true);
	endproc;

	export proc bool OnInnerCone()
		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		var	^CObj			pxObj=(pxSel^)[0].GetObj();
		if(pxSel^.NumEntries()==0)then return (false);endif;
		var int i,iValue,iC=pxSel^.NumEntries();

		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xTemp=(pxSel^)[i];
			var ^CObj pxObj=xTemp.GetObj();
			if(pxObj!=null)then
				var ^CAttribs pxAttribs=pxObj^.GetAttribs();
				if(pxAttribs!=null)then
					pxAttribs^.SetValue("inner_cone",m_pxInnerCone^.GetValueFloat());
					CEvt_UpdateAttribs.Send(pxObj^.GetGuid());
				endif;
			endif;
		endfor;
		Update();
		return(true);
	endproc;

	export proc bool OnOuterCone()
		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		var	^CObj			pxObj=(pxSel^)[0].GetObj();

		var int i,iValue,iC=pxSel^.NumEntries();

		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xTemp=(pxSel^)[i];
			var ^CObj pxObj=xTemp.GetObj();
			if(pxObj!=null)then
				var ^CAttribs pxAttribs=pxObj^.GetAttribs();
				if(pxAttribs!=null)then
					pxAttribs^.SetValue("outer_cone",m_pxInnerCone^.GetValueFloat());
					CEvt_UpdateAttribs.Send(pxObj^.GetGuid());
				endif;
			endif;
		endfor;
		Update();
		return(true);
	endproc;

	export proc bool OnAtConstChange()
		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		var	^CObj			pxObj=(pxSel^)[0].GetObj();
		if(pxSel^.NumEntries()==0)then return (false);endif;
		var int i,iValue,iC=pxSel^.NumEntries();

		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xTemp=(pxSel^)[i];
			var ^CObj pxObj=xTemp.GetObj();
			if(pxObj!=null)then
				var ^CAttribs pxAttribs=pxObj^.GetAttribs();
				if(pxAttribs!=null)then
					pxAttribs^.SetValue("attenuation_const",m_pxAtConst^.GetValueFloat());
					CEvt_UpdateAttribs.Send(pxObj^.GetGuid());
				endif;
			endif;
		endfor;
		Update();
		return(true);
	endproc;

	export proc bool OnAtLinearChange()
		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		var	^CObj			pxObj=(pxSel^)[0].GetObj();
		if(pxSel^.NumEntries()==0)then return (false);endif;
		var int i,iValue,iC=pxSel^.NumEntries();

		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xTemp=(pxSel^)[i];
			var ^CObj pxObj=xTemp.GetObj();
			if(pxObj!=null)then
				var ^CAttribs pxAttribs=pxObj^.GetAttribs();
				if(pxAttribs!=null)then
					pxAttribs^.SetValue("attenuation_linear",m_pxAtLinear^.GetValueFloat());
					CEvt_UpdateAttribs.Send(pxObj^.GetGuid());
				endif;
			endif;
		endfor;
		Update();
		return(true);
	endproc;

	export proc bool OnAtSquaredChange()
		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		var	^CObj			pxObj=(pxSel^)[0].GetObj();
		if(pxSel^.NumEntries()==0)then return (false);endif;
		var int i,iValue,iC=pxSel^.NumEntries();

		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xTemp=(pxSel^)[i];
			var ^CObj pxObj=xTemp.GetObj();
			if(pxObj!=null)then
				var ^CAttribs pxAttribs=pxObj^.GetAttribs();
				if(pxAttribs!=null)then
					pxAttribs^.SetValue("attenuation_squared",m_pxAtSquared^.GetValueFloat());
					CEvt_UpdateAttribs.Send(pxObj^.GetGuid());
				endif;
			endif;
		endfor;
		Update();
		return(true);
	endproc;

	export proc bool OnRangeChange()
		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		if(pxSel^.NumEntries()==0)then return (false);endif;
		var	^CObj			pxObj=(pxSel^)[0].GetObj();

		var int i,iValue,iC=pxSel^.NumEntries();

		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xTemp=(pxSel^)[i];
			var ^CObj pxObj=xTemp.GetObj();
			if(pxObj!=null)then
				var ^CAttribs pxAttribs=pxObj^.GetAttribs();
				if(pxAttribs!=null)then
					pxAttribs^.SetValue("range",m_pxRange^.GetValueInt());
					CEvt_UpdateAttribs.Send(pxObj^.GetGuid());
				endif;
			endif;
		endfor;
		Update();
		return(true);
	endproc;

	export proc bool OnSelectType()
		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		if(pxSel^.NumEntries()==0)then return(false);endif;
		var	^CObj			pxObj=(pxSel^)[0].GetObj();

		var int i,iValue,iC=pxSel^.NumEntries();

		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xTemp=(pxSel^)[i];
			var ^CObj pxObj=xTemp.GetObj();
			if(pxObj!=null)then
				var ^CAttribs pxAttribs=pxObj^.GetAttribs();
				if(pxAttribs!=null)then
					if(m_pxType^.GetSelectedItem()!=(-1))then
						if(m_pxType^.GetSelectedItemAsString()=="Positional")then
							pxAttribs^.SetValue("type","pos");
						elseif(m_pxType^.GetSelectedItemAsString()=="Spot")then
							pxAttribs^.SetValue("type","spot");
						elseif(m_pxType^.GetSelectedItemAsString()=="Directional")then
							pxAttribs^.SetValue("type","dir");
						endif;
						CEvt_UpdateAttribs.Send(pxObj^.GetGuid());
					endif;
				endif;
			endif;
		endfor;

		Update();

		return(true);
	endproc;

	proc bool OnChangeDiffuseRed()
		var ^CPane pxColor=cast<CPane>(GetControl("GroupBoxMain/GroupBoxDiffuse/ColorButton/Color"));
		m_xDiffuseColor.SetRed(m_pxDiffuseRed^.GetValueInt());
		pxColor^.SetColor(m_xDiffuseColor);

		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		if(pxSel^.NumEntries()==0)then return (false);endif;
		var	^CObj			pxObj=(pxSel^)[0].GetObj();
		if(pxObj!=null)then
			var ^CAttribs pxAttribs=pxObj^.GetAttribs();
			if(pxAttribs!=null)then
				pxAttribs^.SetValue("diffuse",m_xDiffuseColor.ToString());
				CEvt_UpdateAttribs.Send(pxObj^.GetGuid());
			endif;
		endif;
		return(true);
	endproc;

	proc bool OnChangeDiffuseGreen()
		var ^CPane pxColor=cast<CPane>(GetControl("GroupBoxMain/GroupBoxDiffuse/ColorButton/Color"));
		m_xDiffuseColor.SetGreen(m_pxDiffuseGreen^.GetValueInt());
		pxColor^.SetColor(m_xDiffuseColor);

		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		if(pxSel^.NumEntries()==0)then return (false);endif;
		var	^CObj			pxObj=(pxSel^)[0].GetObj();
		if(pxObj!=null)then
			var ^CAttribs pxAttribs=pxObj^.GetAttribs();
			if(pxAttribs!=null)then
				pxAttribs^.SetValue("diffuse",m_xDiffuseColor.ToString());
				CEvt_UpdateAttribs.Send(pxObj^.GetGuid());
			endif;
		endif;
		return(true);
	endproc;

	proc bool OnChangeDiffuseBlue()
		var ^CPane pxColor=cast<CPane>(GetControl("GroupBoxMain/GroupBoxDiffuse/ColorButton/Color"));
		m_xDiffuseColor.SetBlue(m_pxDiffuseBlue^.GetValueInt());
		pxColor^.SetColor(m_xDiffuseColor);

		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		if(pxSel^.NumEntries()==0)then return (false);endif;
		var	^CObj			pxObj=(pxSel^)[0].GetObj();
		if(pxObj!=null)then
			var ^CAttribs pxAttribs=pxObj^.GetAttribs();
			if(pxAttribs!=null)then
				pxAttribs^.SetValue("diffuse",m_xDiffuseColor.ToString());
				CEvt_UpdateAttribs.Send(pxObj^.GetGuid());
			endif;
		endif;
		return(true);
	endproc;



	proc bool OnChangeAmbientRed()
		var ^CPane pxColor=cast<CPane>(GetControl("GroupBoxMain/GroupBoxAmbient/ColorButton/Color"));
		m_xAmbientColor.SetRed(m_pxAmbientRed^.GetValueInt());
		pxColor^.SetColor(m_xAmbientColor);

		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		if(pxSel^.NumEntries()==0)then return (false);endif;
		var	^CObj			pxObj=(pxSel^)[0].GetObj();
		if(pxObj!=null)then
			var ^CAttribs pxAttribs=pxObj^.GetAttribs();
			if(pxAttribs!=null)then
				pxAttribs^.SetValue("ambient",m_xAmbientColor.ToString());
				CEvt_UpdateAttribs.Send(pxObj^.GetGuid());
			endif;
		endif;
		return(true);
	endproc;

	proc bool OnChangeAmbientGreen()
		var ^CPane pxColor=cast<CPane>(GetControl("GroupBoxMain/GroupBoxAmbient/ColorButton/Color"));
		m_xAmbientColor.SetGreen(m_pxAmbientGreen^.GetValueInt());
		pxColor^.SetColor(m_xAmbientColor);

		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		if(pxSel^.NumEntries()==0)then return (false);endif;
		var	^CObj			pxObj=(pxSel^)[0].GetObj();
		if(pxObj!=null)then
			var ^CAttribs pxAttribs=pxObj^.GetAttribs();
			if(pxAttribs!=null)then
				pxAttribs^.SetValue("ambient",m_xAmbientColor.ToString());
				CEvt_UpdateAttribs.Send(pxObj^.GetGuid());
			endif;
		endif;
		return(true);
	endproc;

	proc bool OnChangeAmbientBlue()
		var ^CPane pxColor=cast<CPane>(GetControl("GroupBoxMain/GroupBoxAmbient/ColorButton/Color"));
		m_xAmbientColor.SetBlue(m_pxAmbientBlue^.GetValueInt());
		pxColor^.SetColor(m_xAmbientColor);

		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		if(pxSel^.NumEntries()==0)then return (false);endif;
		var	^CObj			pxObj=(pxSel^)[0].GetObj();
		if(pxObj!=null)then
			var ^CAttribs pxAttribs=pxObj^.GetAttribs();
			if(pxAttribs!=null)then
				pxAttribs^.SetValue("ambient",m_xAmbientColor.ToString());
				CEvt_UpdateAttribs.Send(pxObj^.GetGuid());
			endif;
		endif;
		return(true);
	endproc;



	proc bool OnChangeSpecularRed()
		var ^CPane pxColor=cast<CPane>(GetControl("GroupBoxMain/GroupBoxSpecular/ColorButton/Color"));
		m_xSpecularColor.SetRed(m_pxSpecularRed^.GetValueInt());
		pxColor^.SetColor(m_xSpecularColor);

		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		if(pxSel^.NumEntries()==0)then return (false);endif;
		var	^CObj			pxObj=(pxSel^)[0].GetObj();
		if(pxObj!=null)then
			var ^CAttribs pxAttribs=pxObj^.GetAttribs();
			if(pxAttribs!=null)then
				pxAttribs^.SetValue("specular",m_xSpecularColor.ToString());
				CEvt_UpdateAttribs.Send(pxObj^.GetGuid());
			endif;
		endif;
		return(true);
	endproc;

	proc bool OnChangeSpecularGreen()
		var ^CPane pxColor=cast<CPane>(GetControl("GroupBoxMain/GroupBoxSpecular/ColorButton/Color"));
		m_xSpecularColor.SetGreen(m_pxSpecularGreen^.GetValueInt());
		pxColor^.SetColor(m_xSpecularColor);
		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		if(pxSel^.NumEntries()==0)then return (false);endif;
		var	^CObj			pxObj=(pxSel^)[0].GetObj();
		if(pxObj!=null)then
			var ^CAttribs pxAttribs=pxObj^.GetAttribs();
			if(pxAttribs!=null)then
				pxAttribs^.SetValue("specular",m_xSpecularColor.ToString());
				CEvt_UpdateAttribs.Send(pxObj^.GetGuid());
			endif;
		endif;
		return(true);
	endproc;

	proc bool OnChangeSpecularBlue()
		var ^CPane pxColor=cast<CPane>(GetControl("GroupBoxMain/GroupBoxSpecular/ColorButton/Color"));
		m_xSpecularColor.SetBlue(m_pxSpecularBlue^.GetValueInt());
		pxColor^.SetColor(m_xSpecularColor);
		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		if(pxSel^.NumEntries()==0)then return (false);endif;
		var	^CObj			pxObj=(pxSel^)[0].GetObj();
		if(pxObj!=null)then
			var ^CAttribs pxAttribs=pxObj^.GetAttribs();
			if(pxAttribs!=null)then
				pxAttribs^.SetValue("specular",m_xSpecularColor.ToString());
				CEvt_UpdateAttribs.Send(pxObj^.GetGuid());
			endif;
		endif;
		return(true);
	endproc;

endclass;

class CViewSPPropertiesC inherit CFrameWindow

	var ^CCheckBox	m_pxIsSequence;
	var ^CEdit		m_pxFileNameEdit;
	var ^CButton	m_pxFileOpen;


	export constructor()
		if(!InitFromResource("objects/ViewObjProperties","ViewSPPropertiesC"))then
			CClientWrap.LogInfo("Error","CViewSPPropertiesC: InitFromResource failed");
			return;
		endif;

		m_pxIsSequence=cast<CCheckBox>(GetControl("GroupBoxMain/SequenceCheckBox"));
		m_pxIsSequence^.m_xOnStateChange=OnIsSequence;

		m_pxFileOpen=cast<CButton>(GetControl("GroupBoxMain/FileOpen"));
		m_pxFileOpen^.m_xOnClick=OnFileOpen;

		m_pxFileNameEdit=cast<CEdit>(GetControl("GroupBoxMain/FileNameEdit"));
		m_pxFileNameEdit^.m_xOnChange=OnUpdateFileName;

	endconstructor;

	destructor()
	enddestructor;

	proc bool OnFileOpen();
		var ^CEnhancedLoadSaveDialog pxOpenSequence = new CEnhancedLoadSaveDialog(0,"");
		pxOpenSequence^.SetUniqueSettingName("SeqEditorLoadSaveDlg");
		pxOpenSequence^.ClearFilters();
		pxOpenSequence^.AddFilter("Sequence Files","*.seq");
		CClientWrap.GetDesktop()^.AddChild(pxOpenSequence);
		pxOpenSequence^.m_xReturnFileString=OnFileOpenEnd;
		CWindowMgr.Get().BringWindowToTop(pxOpenSequence,true);
		CWindowMgr.Get().SetModal(pxOpenSequence);
		return(true);
	endproc;

	proc bool OnFileOpenEnd(string p_sFileString)
		m_pxFileNameEdit^.SetText(p_sFileString);
		return true;
	endproc

	proc bool OnUpdateFileName()
		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		var	^CObj			pxObj=(pxSel^)[0].GetObj();

		var int i,iValue,iC=pxSel^.NumEntries();

		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xTemp=(pxSel^)[i];
			var ^CObj pxObj=xTemp.GetObj();
			if(pxObj!=null)then
				var ^CAttribs pxAttribs=pxObj^.GetAttribs();
				if(pxAttribs!=null)then
					var string sFilename=m_pxFileNameEdit^.GetText();
					var int iIndex=sFilename.Find("/Data/Base/Sequences/seq_files");
					if(iIndex!=(-1))then
						sFilename.Delete(0,iIndex+21);
						pxAttribs^.SetValue("seq_filename",sFilename);
						CEvt_UpdateAttribs.Send(pxObj^.GetGuid());
					endif;
				endif;
			endif;
		endfor;
		Update();
		return true;
	endproc;

	proc bool OnIsSequence();
		if(!m_pxIsSequence^.GetCheckMark())then
			m_pxFileNameEdit^.SetDisabled(true);
			m_pxFileOpen^.SetDisabled(true);
			SetSequence(0);
		else
			m_pxFileNameEdit^.SetDisabled(false);
			m_pxFileOpen^.SetDisabled(false);
			SetSequence(1);
		endif;
		return(true);
	endproc;

	proc bool SetSequence(int p_iParam)

		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		var	^CObj			pxObj=(pxSel^)[0].GetObj();

		var int i,iValue,iC=pxSel^.NumEntries();

		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xTemp=(pxSel^)[i];
			var ^CObj pxObj=xTemp.GetObj();
			if(pxObj!=null)then
				var ^CAttribs pxAttribs=pxObj^.GetAttribs();
				if(pxAttribs!=null)then
					pxAttribs^.SetValue("is_sequence",p_iParam);
					CEvt_UpdateAttribs.Send(pxObj^.GetGuid());
				endif;
			endif;
		endfor;
		return true;
	endproc;


	export proc bool Update();

		var ^CObjSelection	pxSel=^(CClientWrap.GetSelection());
		var	^CObj			pxObj=(pxSel^)[0].GetObj();

		var int i,iC=pxSel^.NumEntries();
		var string sValue;

		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xTemp=(pxSel^)[i];
			var ^CObj pxObj=xTemp.GetObj();
			if(pxObj!=null)then
				var ^CAttribs pxAttribs=pxObj^.GetAttribs();
				if(pxAttribs!=null)then
					if(pxAttribs^.ContainsKey("is_sequence"))then
						if(pxAttribs^.GetValueInt("is_sequence")==0)then
							m_pxIsSequence^.SetChecked(0);
							m_pxFileNameEdit^.SetDisabled(true);
							m_pxFileOpen^.SetDisabled(true);
						else
							m_pxIsSequence^.SetChecked(1);
							m_pxFileNameEdit^.SetDisabled(false);
							m_pxFileOpen^.SetDisabled(false);
						endif;
					endif;
					if(pxAttribs^.ContainsKey("seq_filename"))then
						sValue=pxAttribs^.GetValue("seq_filename");
						m_pxFileNameEdit^.SetText(sValue);
					endif;
				endif;
			endif;
		endfor;
		return(true);
	endproc;

	export proc bool Clear();
		return(true);
	endproc;
endclass;

class CPassengerPropertyPage inherit CFrameWindow

	var ^CList						m_pxPassengers;
	var ^CButton					m_pxApply,m_pxReset, m_pxRem;

	export constructor()
		if(!InitFromResource("objects/ViewObjProperties","PassengerPropertyPage"))then
			CClientWrap.LogInfo("Error","CPassengerPropertyPage: InitFromResource failed");
			return;
		endif;

		m_pxPassengers=cast<CList>(GetControl("ListPassenger"));

		m_pxApply=cast<CButton>(GetControl("ButtonAdd"));
		m_pxApply^.m_xOnClick=OnApply;
		
		m_pxRem=cast<CButton>(GetControl("ButtonRem"));
		m_pxRem^.m_xOnClick=OnRem;

		m_pxReset=cast<CButton>(GetControl("ButtonReset"));
		m_pxReset^.m_xOnClick=Update;
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool Update()
		InvalidateContent();
		return true;
	endproc;
	
	proc void OnUpdateContent()
		super.OnUpdateContent();
		if(m_pxPassengers==null)then return; endif;
		m_pxPassengers^.Clear();
		m_pxPassengers^.AddItem("None");
		var ^CViewObjFinder pxFinder=CEnhancedMenu.Get().GetObjFinder();
		if(pxFinder!=null)then
			var ^CList pxList=pxFinder^.GetObjList();
			if(pxList!=null)then
				var int i,iC=pxList^.NumItems();
				for(i=0)cond(i<iC)iter(i++)do
					var ^CFinderItemObject pxItem=cast<CFinderItemObject>(pxList^.GetItemData(i));
					if(pxItem==null)then continue; endif;
					var CClntHndl xObjHndl=pxItem^.GetHndl();
					var ^CObj pxObj=xObjHndl.GetObj();
					if(pxObj==null)then continue; endif;
					if(pxObj^.GetType()=="CHTR")then
						m_pxPassengers^.AddItem(pxObj^.GetName());
					endif;
				endfor;
			endif;
		endif;
		if(m_pxPassengers^.NumItems()>1)then
			m_pxPassengers^.QSort();
		endif;
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		if(pxSel^.NumEntries()!=1)then return; endif;
		var ^CObj pxObj=(pxSel^)[0].GetObj();
		if(pxObj==null)then return; endif;
		var ^CAttribs pxAttribs=pxObj^.GetAttribs();
		if(pxAttribs==null)then return; endif;
		begin Select;
			var string sGuids=pxAttribs^.GetValue("passenger_guids");
			var array string asTokens;
			sGuids.Split(asTokens,"\n",true);
			var int i,iC=asTokens.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				var CGuid xGuid;
				xGuid.FromString(asTokens[i]);
				var ^CObj pxWalk=CObjHelper.GetObjByGuid(xGuid).GetObj();
				if(pxWalk==null)then continue; endif;
				var int iIdx=m_pxPassengers^.FindItem(pxWalk^.GetName());
				if(iIdx!=-1)then
					m_pxPassengers^.Select(iIdx,false);
				endif;
			endfor;
		end Select;
	endproc;

	proc bool OnApply()
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		if(pxSel^.NumEntries()!=1)then return false; endif;
		var ^CObj pxObj=(pxSel^)[0].GetObj();
		if(pxObj==null)then return false; endif;
		var string sGuids;
		var int iSelIdx;
		m_pxPassengers^.StartIterateSelectedItems(iSelIdx);
		while(m_pxPassengers^.IterateSelectedItems(iSelIdx))do
			var ^CObj pxObj=CClientWrap.GetObjMgr().FindObjByName(m_pxPassengers^.GetItem(iSelIdx));
			if(pxObj==null)then continue; endif;
			sGuids+=pxObj^.GetGuid().ToString()+"\n";
		endwhile;
		var CClntHndl xInvalid;
		CEvt_ObjLECommand.Send(pxSel^,"LE_AddPassengers",xInvalid,{0.0,0.0,0.0},sGuids);
		return true;
	endproc;
	
	proc bool OnRem()
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		if(pxSel^.NumEntries()!=1)then return false; endif;
		var ^CObj pxObj=(pxSel^)[0].GetObj();
		if(pxObj==null)then return false; endif;
		var string sGuids;
		var int iSelIdx;
		m_pxPassengers^.StartIterateSelectedItems(iSelIdx);
		while(m_pxPassengers^.IterateSelectedItems(iSelIdx))do
			var ^CObj pxObj=CClientWrap.GetObjMgr().FindObjByName(m_pxPassengers^.GetItem(iSelIdx));
			if(pxObj==null)then continue; endif;
			sGuids+=pxObj^.GetGuid().ToString()+"\n";
		endwhile;
		var CClntHndl xInvalid;
		CEvt_ObjLECommand.Send(pxSel^,"LE_RemPassengers",xInvalid,{0.0,0.0,0.0},sGuids);
		return true;
	endproc;
endclass;

class CTTFilterPropertyPage inherit CFrameWindow

	var bool			m_bFilterInitialized;
	var ^CTreeCtrl		m_pxFilter;
	var ^CButton		m_pxApply,m_pxReset;

	var CBitmapPtr		m_pxDefBitmap,m_pxSelBitmap;

	export constructor()
		if(!InitFromResource("objects/ViewObjProperties","TTFilterPropertyPage"))then
			CClientWrap.LogInfo("Error","CTTFilterPropertyPage: InitFromResource failed");
			return;
		endif;

		m_pxDefBitmap=CBitmapPtr.Create("treedefaultimg.tga");
		m_pxSelBitmap=CBitmapPtr.Create("check.tga");

		m_pxFilter=cast<CTreeCtrl>(GetControl("TreeFilter"));
		m_pxFilter^.m_xOnLBtnDblClick=OnToggleFilter;
//		m_pxFilter^.AllowMultiSelection(true);

		m_pxApply=cast<CButton>(GetControl("ButtonApply"));
		m_pxApply^.m_xOnClick=OnApply;

		m_pxReset=cast<CButton>(GetControl("ButtonReset"));
		m_pxReset^.m_xOnClick=Update;

		FillFilterTree();
	endconstructor;

	export proc bool OnActivate()
		Update();
		return super.OnActivate();
	endproc;

	export proc bool OnActivateIndirect()
		Update();
		return super.OnActivateIndirect();
	endproc;

	export proc bool Update()
		FillFilterTree();
		begin;
			m_pxFilter^.StartIterate();
			var int iItem=0;
			while(m_pxFilter^.Iterate(iItem))do
				m_pxFilter^.SetItemBitmap(iItem,m_pxDefBitmap);
			endwhile;
		end;

		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		var int i,iC=pxSel^.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CObj pxObj=(pxSel^)[i].GetObj();
			if(pxObj==null)then continue; endif;
			var ^CTechTreeDef pxTTDef=pxObj^.GetTechTreeDef();
			if(pxTTDef==null)then continue; endif;
			var int j,ijC=pxTTDef^.NumEntries();
			for(j=0)cond(j<ijC)iter(j++)do
				var array string asParts;
				pxTTDef^.GetFilter(j).Split(asParts,"/",true);
				var bool bFound=true;
				var int iRootIdx=0;
				var int k,ikC=asParts.NumEntries();
				for(k=0)cond(k<ikC)iter(k++)do
					var int iWalkIdx=FindItem(iRootIdx,asParts[k]);
					if(iWalkIdx==0)then
						bFound=false;
						continue;
					endif;
					iRootIdx=iWalkIdx;
				endfor;
				if(bFound)then
					m_pxFilter^.SetItemBitmap(iRootIdx,m_pxSelBitmap);
				endif;
			endfor;
		endfor;

		return true;
	endproc;

	proc int FindItem(int p_iParent,string p_sText)
		var int iL,iLC=m_pxFilter^.ItemNumChildren(p_iParent);
		for(iL=0)cond(iL<iLC)iter(iL++)do
			var int iIdx=m_pxFilter^.GetChildItem(p_iParent,iL);
			if(m_pxFilter^.GetItemText(iIdx)==p_sText)then
				return iIdx;
			endif;
		endfor;
		return 0;
	endproc;

	proc bool OnToggleFilter()
		var int iSelItem=m_pxFilter^.GetSelectedItem();
		if(iSelItem==0)then return true; endif;
		var CBitmapPtr pxBitmap=m_pxDefBitmap;
		if((m_pxFilter^.ItemNumChildren(iSelItem)==0) && (m_pxFilter^.GetItemBitmap(iSelItem)==m_pxDefBitmap))then
			pxBitmap=m_pxSelBitmap;
		endif;
		m_pxFilter^.SetItemBitmap(iSelItem,pxBitmap);
		return true;
	endproc;

	proc bool OnApply()
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		if(pxSel==null)then return false; endif;

		var string sPathes;
		var int iItem=0;
		m_pxFilter^.StartIterate();
		while(m_pxFilter^.Iterate(iItem))do
			if(m_pxFilter^.ItemNumChildren(iItem)!=0)then continue; endif;
			if(m_pxFilter^.GetItemBitmap(iItem)==m_pxDefBitmap)then continue; endif;

			var string sPath=m_pxFilter^.GetItemText(iItem);
			var int iRootIdx=m_pxFilter^.GetParentItem(iItem);
			while(iRootIdx!=0)do
				sPath=m_pxFilter^.GetItemText(iRootIdx)+"/"+sPath;
				iRootIdx=m_pxFilter^.GetParentItem(iRootIdx);
			endwhile;
			sPathes+=sPath+"\n";
		endwhile;
		var CClntHndl xInvalid;
		CEvt_ObjLECommand.Send(pxSel^,"LE_SetTTFilters",xInvalid,{0.0,0.0,0.0},sPathes);
		return true;
	endproc;

	proc void FillFilterTree()
		if(m_bFilterInitialized)then return; endif;
		m_pxFilter^.Clear();
		var ^CTechTreeMgr pxTTMgr=^(CLevelEditorWrap.GetClient().GetTechTreeMgr());
		var int i,iC=pxTTMgr^.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var string sPath=pxTTMgr^.GetFilterPath(i);
			if(sPath.Find("_RemoveMe")==-1)then
				var array string asParts;
				sPath.Split(asParts,"/",true);
				var int iRootIdx=0;
				var int i,iC=asParts.NumEntries();
				for(i=0)cond(i<iC)iter(i++)do
					var int iWalkIdx=FindItem(iRootIdx,asParts[i]);
					if(iWalkIdx==0)then
						iWalkIdx=m_pxFilter^.AddItem(iRootIdx,asParts[i],m_pxDefBitmap);
						m_bFilterInitialized=true;
					endif;
					iRootIdx=iWalkIdx;
				endfor;
			endif;
		endfor;
	endproc;

endclass;


class COPItemSpawnProperties inherit CFrameWindow

	class CItemMenu inherit CFrameWindow

		var ^CList					m_pxItemList;
		var ^CButton				m_pxCancelBtn;
		var ^CButton				m_pxAddBtn;
		var ^COPItemSpawnProperties	m_pxOwner;

		export constructor(^COPItemSpawnProperties p_pxOwner)
			if(!InitFromResource("objects/ViewObjProperties","ItemMenu"))then
				CLevelEditorWrap.LogError("UI.ItemMenu","InitFromResource failed");
				return;
			endif;
			m_pxOwner=p_pxOwner;

			m_pxItemList=cast<CList>(GetControl("ItemList"));
			m_pxAddBtn=cast<CButton>(GetControl("Add"));
			m_pxCancelBtn=cast<CButton>(GetControl("Cancel"));

			m_pxItemList^.m_xOnLBtnDblClick=OnAdd;
			m_pxAddBtn^.m_xOnClick=OnAdd;
			m_pxCancelBtn^.m_xOnClick=OnCancel;

			var array string asItemPool;
			var ^CLevelInfo pxLevelInfo=^(CLevelEditorWrap.GetClient().GetLevelInfo());
			var ^CPropDB.CNode pxItemPool=(pxLevelInfo^.GetGenericData())["Items"].Get("Pool");
			if(pxItemPool!=null)then
				var int i,iC=pxItemPool^.NumSubs();
				for(i=0)cond(i<iC)iter(i++)do
					var string sItem=(pxItemPool^)[i].Name();
					asItemPool.AddEntry(sItem);
				endfor;
			endif;

			begin exclude_useditems;
				if(m_pxOwner^.m_pxItemSpawnAttribs!=null)then
					var string sUsedItems=m_pxOwner^.m_pxItemSpawnAttribs^.GetValue("spawn_items");
					var array string asUsedItems;
					sUsedItems.Split(asUsedItems,"|",false);
					var int i,iC=asUsedItems.NumEntries();
					for(i=0)cond(i<iC)iter(i++)do
						asItemPool.Exclude(asUsedItems[i]);
					endfor;
				endif;
			end exclude_useditems;

			begin exclude_uniqueitems;
				var CObjQueryCln xOQ;
				xOQ.SetType("ITSP");
				var CObjList xObjects;
				xOQ.Execute(xObjects);
				var int i,iC=xObjects.NumEntries();
				for(i=0)cond(i<iC)iter(i++)do
					var ^CObj pxWalk=xObjects[i].GetObj();
					if(pxWalk==null)then continue; endif;
					var ^CAttribs pxAttribs=pxWalk^.GetAttribs();
					if(pxAttribs==null)then continue; endif;
					var string sUsedItems=pxAttribs^.GetValue("spawn_items");
					var bool bGenerateAlways=pxAttribs^.GetValueBool("generate_always");
					var array string asUsedItems;
					sUsedItems.Split(asUsedItems,"|",false);
					if(bGenerateAlways && asUsedItems.NumEntries()==1)then
						asItemPool.Exclude(asUsedItems[0]);
					endif;
				endfor;
			end exclude_uniqueitems;


			var int i,iC=asItemPool.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				m_pxItemList^.AddItem(asItemPool[i]);
			endfor;

			CWindowMgr.Get().AddTopLevelWindow(this);
			CWindowMgr.Get().SetModal(this);
		endconstructor;

		proc bool OnAdd()
			var string sItems;
			var int i,iC=m_pxItemList^.NumItems();
			for(i=0)cond(i<iC)iter(i++)do
				if(m_pxItemList^.IsItemSelected(i))then
					sItems+=(m_pxItemList^.GetItem(i)+"|");
				endif;
			endfor;
			m_pxOwner^.AddItems(sItems,true);
			OnCancel();
			return true;
		endproc;

		proc bool OnCancel()
			CWindowMgr.Get().ReleaseModal(this);
			Destroy();
			return true;
		endproc;

	endclass;

	var ^CButton	m_pxAddItem;
	var ^CButton	m_pxDelItem;
	var ^CList		m_pxItemPool;
	var ^CCheckBox	m_pxGenerateAlways;
	var ^CCheckBox	m_pxRandomItem;
	var ^CObj		m_pxItemSpawn;
	export var ^CAttribs 	m_pxItemSpawnAttribs;

	export constructor()
		if(!InitFromResource("objects/ViewObjProperties","ItemSpawnProperties"))then
			CLevelEditorWrap.LogError("UI.ItemSpawnProperties","InitFromResource failed");
			return;
		endif;
		m_pxAddItem=cast<CButton>(GetControl("AddItem"));
		m_pxDelItem=cast<CButton>(GetControl("DelItem"));
		m_pxItemPool=cast<CList>(GetControl("ItemPool"));
		m_pxGenerateAlways=cast<CCheckBox>(GetControl("GenerateAlways"));
		m_pxRandomItem=cast<CCheckBox>(GetControl("RandomItem"));
	endconstructor;

	export proc void Update()
		m_pxItemPool^.m_xOnSelect.Clear();
		m_pxAddItem^.m_xOnClick.Clear();
		m_pxDelItem^.m_xOnClick.Clear();
		m_pxGenerateAlways^.m_xOnStateChange.Clear();
		m_pxRandomItem^.m_xOnStateChange.Clear();
		m_pxItemPool^.Clear();

		m_pxItemSpawn=null;
		m_pxItemSpawnAttribs=null;
		SetDisabled(true);
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		if(pxSel^.NumEntries()==1)then
			m_pxItemSpawn=(pxSel^)[0].GetObj();
		endif;
		if(m_pxItemSpawn==null)then
			return;
		endif;
		m_pxItemSpawnAttribs=m_pxItemSpawn^.GetAttribs();
		if(m_pxItemSpawnAttribs==null)then
			return;
		endif;
		SetDisabled(false);
		m_pxGenerateAlways^.SetChecked(0);
		m_pxRandomItem^.SetChecked(0);
		var string sSpawnItems=m_pxItemSpawnAttribs^.GetValue("spawn_items");
		var bool bGeneratewAlways=m_pxItemSpawnAttribs^.GetValueBool("generate_always");
		var bool bRandomItem=m_pxItemSpawnAttribs^.GetValueBool("random_item");
		if(bGeneratewAlways)then
			m_pxGenerateAlways^.SetChecked(1);
		endif;
		if(bRandomItem)then
			m_pxRandomItem^.SetChecked(1);
		endif;
		m_pxDelItem^.SetDisabled(true);
		AddItems(sSpawnItems,false);
		OnSelectItem();

		m_pxItemPool^.m_xOnSelect=OnSelectItem;
		m_pxAddItem^.m_xOnClick=OnAddItem;
		m_pxDelItem^.m_xOnClick=OnDelItem;
		m_pxGenerateAlways^.m_xOnStateChange=OnChangeGenerateAlways;
		m_pxRandomItem^.m_xOnStateChange=OnChangeRandomItem;
	endproc;

	proc bool OnSelectItem()
		m_pxDelItem^.SetDisabled(m_pxItemPool^.GetNumberOfSelectedItems()==0);
		return true;
	endproc;

	proc bool OnAddItem()
		new CItemMenu(this);
		return true;
	endproc;

	proc bool OnDelItem()
		var int i;
		for(i=0)cond(i<m_pxItemPool^.NumItems())iter(i++)do
			if(m_pxItemPool^.IsItemSelected(i))then
				m_pxItemPool^.DeleteItem(i);
				i--;
			endif;
		endfor;
		SetSpawnItems();
		return true;
	endproc;

	proc bool OnChangeGenerateAlways()
		m_pxItemSpawnAttribs^.SetValue("generate_always",m_pxGenerateAlways^.GetChecked()==1);
		CEvt_UpdateAttribs.Send(m_pxItemSpawn^.GetGuid());
		return true;
	endproc;

	proc bool OnChangeRandomItem()
		m_pxItemSpawnAttribs^.SetValue("random_item",m_pxRandomItem^.GetChecked()==1);
		CEvt_UpdateAttribs.Send(m_pxItemSpawn^.GetGuid());
		return true;
	endproc;

	export proc void AddItems(string p_sItems,bool p_bUpdateObj)
		var array string asItems;
		p_sItems.Split(asItems,"|",false);
		var int i,iC=asItems.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			m_pxItemPool^.AddItem(asItems[i]);
		endfor;
		if(p_bUpdateObj)then
			SetSpawnItems();
		endif;
	endproc;

	proc void SetSpawnItems()
		var string sItems;
		var int i,iC=m_pxItemPool^.NumItems();
		for(i=0)cond(i<iC)iter(i++)do
			sItems+=(m_pxItemPool^.GetItem(i)+"|");
		endfor;
		m_pxItemSpawnAttribs^.SetValue("spawn_items",sItems);
		CEvt_UpdateAttribs.Send(m_pxItemSpawn^.GetGuid());
	endproc;

	export proc void Clear()
	endproc;

endclass;
	
class CRegionProperties inherit CFrameWindow
	
	class CAreasItem inherit CItemData
		
		var CClntHndl m_xHndl;
		
		export constructor(ref CClntHndl p_rxHndl)
			m_xHndl=p_rxHndl;
		endconstructor;
		
		export proc CClntHndl GetHndl();
			return(m_xHndl);
		endproc;
		
	endclass;
	
	var ^CObj									m_pxEggHolder;
	var CObjList							m_xSubjects;
	var ^CDropList						m_pxRegion; // droplist of the 3 region class to clone
	var ^CDropList						m_pxAngle; // rotation angle list (0, 90°, 180°, 270°)
	var ^CDropList						m_pxAxis; // axis for the regions to be flipped around (none or x/y axis)
	var ^CList								m_pxNestList; // list of nests to copy from
	var ^CButton							m_pxClearSelection; // clear m_pxNestList
	var ^CButton							m_pxCopySimple; // make duplicates of the subregions belonging to the selected region class (action/safe/hotspot)
	var ^CButton							m_pxCloneFlipRotateMove; // clone the subregions, rotate them by the selected angle and move them to the subjects' own position
	var ^CButton							m_pxTransferAttribs; // clone the important nest properties (spawn type, eggs number, etc)
	var ^CButton							m_pxDeleteSubs; // clear all subs of own selected region class
	var ^CButton							m_pxStoreTmpPos; // save current position temporarily for later region shifting
	var ^CButton							m_pxTranslatePos; // translate/shift all regions to the current position (old position needs to be saved beforehand)
	var ^CCheckBox						m_pxCopyColor; // also copy color of the selected region
	var ^CCheckBox						m_pxCopyEnable; // also copy enable/disable states for the new subregions
	var ^CCheckBox						m_pxClearFirst; // delete previous subregions of subjects before cloning
	var ^CCheckBox						m_pxSetNoRespawn; // change the value of the "no_respawn" attribute, to enable or disable possible nest recreation
	
	export constructor()
		if(!InitFromResource("objects/ViewObjProperties","RegionProperties"))then
			CClientWrap.LogError("Error","CRegionProperties: InitFromResource failed");
			return;
		endif;
		m_pxRegion=cast<CDropList>(GetControl("GroupBoxMain/RegionDroplist"));
		m_pxRegion^.AddItem("Action-area");
		m_pxRegion^.AddItem("Safe-area");
		m_pxRegion^.AddItem("Hotspot-area");
		m_pxRegion^.AddItem("Tolerance-area");
		m_pxRegion^.AddItem("Action&Safe");
		m_pxRegion^.AddItem("Action&Tolerance");
		m_pxRegion^.AddItem("Act&Saf&Tol");
		m_pxRegion^.AddItem("All");
		m_pxRegion^.m_xOnChange=OnChangeAreaClass;
		m_pxAngle=cast<CDropList>(GetControl("GroupBoxMain/AngleDroplist"));
		m_pxAngle^.AddItem("None");
		m_pxAngle^.AddItem("90 Degree");
		m_pxAngle^.AddItem("180 Degree");
		m_pxAngle^.AddItem("270 Degree");
		m_pxAngle^.m_xOnChange=OnChangeRotAngle;
		m_pxAxis=cast<CDropList>(GetControl("GroupBoxMain/AxisDroplist"));
		m_pxAxis^.AddItem("None");
		m_pxAxis^.AddItem("Horizontal");
		m_pxAxis^.AddItem("Vertical");
		m_pxAxis^.m_xOnChange=OnChangeFlipAxis;
		m_pxCopyColor=cast<CCheckBox>(GetControl("GroupBoxMain/CopyColor"));
		m_pxCopyColor^.m_xOnStateChange=OnCopyColor;
		m_pxCopyEnable=cast<CCheckBox>(GetControl("GroupBoxMain/CopyEnable"));
		m_pxCopyEnable^.m_xOnStateChange=OnCopyEnable;
		m_pxClearFirst=cast<CCheckBox>(GetControl("GroupBoxMain/ClearFirst"));
		m_pxClearFirst^.m_xOnStateChange=OnClearFirst;
		m_pxSetNoRespawn=cast<CCheckBox>(GetControl("GroupBoxMain/SetNoRespawn"));
		m_pxSetNoRespawn^.m_xOnStateChange=OnSetNoRespawn;
		m_pxClearSelection=cast<CButton>(GetControl("GroupBoxMain/ClearSelection"));
		m_pxClearSelection^.m_xOnClick = OnClearSelection;
		m_pxCopySimple=cast<CButton>(GetControl("GroupBoxMain/CopySimple"));
		m_pxCopySimple^.m_xOnClick = OnCopySimple;
		m_pxCloneFlipRotateMove=cast<CButton>(GetControl("GroupBoxMain/CloneFlipRotateMove"));
		m_pxCloneFlipRotateMove^.m_xOnClick = OnCloneFlipRotateMove;
		m_pxTransferAttribs=cast<CButton>(GetControl("GroupBoxMain/TransferAttribs"));
		m_pxTransferAttribs^.m_xOnClick = OnTransferAttribs;
		m_pxDeleteSubs=cast<CButton>(GetControl("GroupBoxMain/DeleteSubs"));
		m_pxDeleteSubs^.m_xOnClick = OnDeleteSubs;
		m_pxStoreTmpPos=cast<CButton>(GetControl("GroupBoxMain/StoreTmpPos"));
		m_pxStoreTmpPos^.m_xOnClick = OnStoreTmpPos;
		m_pxTranslatePos=cast<CButton>(GetControl("GroupBoxMain/TranslatePos"));
		m_pxTranslatePos^.m_xOnClick = OnTranslatePos;
		m_pxNestList=cast<CList>(GetControl("GroupBoxMain/NestList"));
		m_pxNestList^.AllowMultiSelection(true);
		m_pxNestList^.AllowScrollBar(true);
		m_pxNestList^.AllowScrollBarHor(true);
		m_pxNestList^.m_xOnLBtnDblClick = JumpToNest;
		m_pxNestList^.m_xOnSelect = OnSelectNest;
		m_pxNestList^.Clear();
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool Clear()
//		m_pxCopyColor^.SetChecked(0);
//		m_pxCopyEnable^.SetChecked(0);
//		m_pxClearFirst^.SetChecked(0);
		m_pxSetNoRespawn^.m_xOnStateChange.Clear();
		m_pxSetNoRespawn^.SetChecked(0);
//		m_pxRegion^.Select(0);
//		m_pxAngle^.Select(0);
//		m_pxAxis^.Select(0);
		m_pxRegion^.SetDisabled(true);
		m_pxAngle^.SetDisabled(true);
		m_pxAxis^.SetDisabled(true);
		m_pxClearSelection^.m_xOnClick.Clear();
		m_pxCopySimple^.m_xOnClick.Clear();
		m_pxCloneFlipRotateMove^.m_xOnClick.Clear();
		m_pxTransferAttribs^.m_xOnClick.Clear();
		m_pxDeleteSubs^.m_xOnClick.Clear();
		m_pxStoreTmpPos^.m_xOnClick.Clear();
		m_pxTranslatePos^.m_xOnClick.Clear();
		m_pxNestList^.m_xOnSelect.Clear();
		m_pxNestList^.m_xOnLBtnDblClick.Clear();
		m_xSubjects.Clear();
		m_pxNestList^.RemoveSelection();
		m_pxNestList^.Clear();
		m_pxNestList^.AllowMultiSelection(true);
		m_pxNestList^.AllowScrollBar(false);
		m_pxNestList^.AllowScrollBarHor(false);
		return(true);
	endproc;
	
	export proc bool Update()
		m_pxEggHolder=null;
		m_pxSetNoRespawn^.m_xOnStateChange.Clear();
		m_pxClearSelection^.m_xOnClick.Clear();
		m_pxCopySimple^.m_xOnClick.Clear();
		m_pxCloneFlipRotateMove^.m_xOnClick.Clear();
		m_pxTransferAttribs^.m_xOnClick.Clear();
		m_pxDeleteSubs^.m_xOnClick.Clear();
		m_pxStoreTmpPos^.m_xOnClick.Clear();
		m_pxTranslatePos^.m_xOnClick.Clear();
		m_pxNestList^.m_xOnSelect.Clear();
		m_pxNestList^.m_xOnLBtnDblClick.Clear();
		m_xSubjects.Clear();
		m_pxNestList^.AllowMultiSelection(true);
		m_pxNestList^.RemoveSelection();
		m_pxNestList^.Clear();
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		if(pxSel^.NumEntries()==1)then
			var ^CObj pxObj=(pxSel^)[0].GetObj();
			if(pxObj!=null)then
				if(pxObj^.GetType()=="NEST")then
					m_pxEggHolder=pxObj;
				endif;
			endif;
		endif;
		m_pxSetNoRespawn^.SetChecked(0);
//		m_pxRegion^.Select(0);
//		m_pxAngle^.Select(0);
//		m_pxAxis^.Select(0);
		m_pxRegion^.SetDisabled(m_pxEggHolder==null);
		m_pxAngle^.SetDisabled(m_pxEggHolder==null);
		m_pxAxis^.SetDisabled(m_pxEggHolder==null);
		SetDisabled(m_pxEggHolder==null);
		if(m_pxEggHolder!=null)then
			m_pxRegion^.m_xOnChange=OnChangeAreaClass;
			m_pxAngle^.m_xOnChange=OnChangeRotAngle;
			m_pxAxis^.m_xOnChange=OnChangeFlipAxis;
			m_pxCopyColor^.m_xOnStateChange=OnCopyColor;
			m_pxCopyEnable^.m_xOnStateChange=OnCopyEnable;
			m_pxClearFirst^.m_xOnStateChange=OnClearFirst;
			m_pxSetNoRespawn^.m_xOnStateChange=OnSetNoRespawn;
			m_pxClearSelection^.m_xOnClick = OnClearSelection;
			m_pxCopySimple^.m_xOnClick = OnCopySimple;
			m_pxCloneFlipRotateMove^.m_xOnClick = OnCloneFlipRotateMove;
			m_pxTransferAttribs^.m_xOnClick = OnTransferAttribs;
			m_pxDeleteSubs^.m_xOnClick = OnDeleteSubs;
			m_pxStoreTmpPos^.m_xOnClick = OnStoreTmpPos;
			m_pxTranslatePos^.m_xOnClick = OnTranslatePos;
			m_pxNestList^.m_xOnSelect = OnSelectNest;
			m_pxNestList^.m_xOnLBtnDblClick = JumpToNest;
			m_pxNestList^.AllowScrollBar(true);
			m_pxNestList^.AllowScrollBarHor(true);
			FillNestsList(m_pxEggHolder^.GetName());
			var ^CAttribs pxAttribs=m_pxEggHolder^.GetAttribs();
			if(pxAttribs!=null)then
				var bool bNR=pxAttribs^.GetValueBool("no_respawn");
				if(bNR)then
					m_pxSetNoRespawn^.SetChecked(1);
				endif;
			endif;
			m_pxSetNoRespawn^.SetDisabled(pxAttribs==null);
		endif;
		return(true);
	endproc;
	
	export proc void FillNestsList(string p_sMainNest)
//		var ^CList pxObjList = CEnhancedMenu.Get().GetObjFinder()^.GetObjList();
//		if(pxObjList^.NumItems()>1)then
//			pxObjList^.QSort();
//		endif;
//		var int i, iC = pxObjList^.NumItems();
//		for(i=0)cond(i<iC)iter(++i)do
//			var string sName=pxObjList^.GetItem(i);
//			if(p_sMainNest==sName)then continue; endif;
//			var ^CFinderItem pxItem=cast<CFinderItem>(pxObjList^.GetItemData(i));
//			if(pxItem!=null)then
//				if(pxItem^.GetType()!=CFinderItem.TYPE_OBJECT)then continue; endif;
//				var CClntHndl xSub=(cast<CFinderItemObject>(pxItem))^.GetHndl();
//				if(!xSub.IsValid()||xSub.GetObj()^.GetType()!="NEST")then continue; endif;
//				m_xSubjects.Include(xSub);
//				m_pxNestList^.AddItem(sName);
//			endif;
//		endfor;
		var CObjQueryCln xOQ;
		xOQ.SetType("NEST");
		var CObjList xObjects;
		xOQ.Exclude(m_pxEggHolder^.GetHandle());
		xOQ.Execute(xObjects);
		var int i,iC=xObjects.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(xObjects[i].IsValid())then
				m_pxNestList^.AddItem(xObjects[i].GetObj()^.GetName(),new CAreasItem(xObjects[i]));
			endif;
		endfor;
		m_pxNestList^.QSort();
		iC=m_pxNestList^.NumItems();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CAreasItem pxItem=cast<CAreasItem>(m_pxNestList^.GetItemData(i));
			if(pxItem!=null)then
				var CClntHndl xSub=pxItem^.GetHndl();
				m_xSubjects.Include(xSub);
			else
				m_pxNestList^.DeleteItem(i); i--; iC--;
			endif
		endfor;
		m_pxNestList^.RemoveSelection();
	endproc;
	
	proc bool OnChangeAreaClass()
		return(true);
	endproc;
	
	proc bool OnChangeRotAngle()
		return(true);
	endproc;
	
	proc bool OnChangeFlipAxis()
		return(true);
	endproc;
	
	proc bool OnCopyColor()
		return(true);
	endproc;
	
	proc bool OnCopyEnable()
		return(true);
	endproc;
	
	proc bool OnClearFirst()
		return(true);
	endproc;
	
	proc bool OnSetNoRespawn()
		if(m_pxEggHolder!=null)then
			var ^CAttribs pxAttribs=m_pxEggHolder^.GetAttribs();
			if(pxAttribs!=null)then
				var int iValue=0;
				if(m_pxSetNoRespawn^.GetCheckMark())then iValue=1; endif;
				pxAttribs^.SetValue("no_respawn",iValue);
				CEvt_UpdateAttribs.Send(m_pxEggHolder^.GetGuid());
			endif;
		endif;
		return(true);
	endproc;
	
	proc bool OnSelectNest()
		return(true);
	endproc;
	
	proc bool JumpToNest()
		var int iSelNest=m_pxNestList^.GetSelectedItem();
		if(iSelNest!=-1)then
			if(m_pxNestList^.GetItemData(iSelNest)==null)then
				return(false);
			endif;
			var ^CAreasItem pxItem=cast<CAreasItem>(m_pxNestList^.GetItemData(iSelNest));
			if(pxItem!=null)then
				var CClntHndl xSub=pxItem^.GetHndl();
				if(xSub.IsValid())then
					CMainController.Get().SetCameraTarget(xSub.GetObj()^.GetPos());
				endif;
			endif;
		endif;
		return(true);
	endproc;

	proc bool OnClearSelection()
		m_pxNestList^.RemoveSelection();
		return(true);
	endproc;
	
	proc bool OnDeleteSubs()
		if(m_pxEggHolder!=null)then
			var CClntHndl xObj=m_pxEggHolder^.GetHandle(), xInvalid;
			CEvt_ObjLECommand.Send(xObj, "ClearSubs", xInvalid, {0.0f, 0.0f, 0.0f}, m_pxRegion^.GetSelectedItem().ToString());
		endif;
		return(true);
	endproc;
	
	proc bool OnTransferAttribs()
		if(m_pxEggHolder!=null)then
			var CClntHndl xObj=m_pxEggHolder^.GetHandle();
			var int iVisible=0, iHitable=0, iSelectable=0;
			if(m_pxEggHolder^.GetVisibleMask()!=0h)then iVisible = 1; endif;
			if(m_pxEggHolder^.IsHitable())then iHitable = 1; endif;
			if(m_pxEggHolder^.IsSelectable())then iSelectable = 1; endif;
			var string sMiscParams=iVisible.ToString()+":"+iHitable.ToString()+":"+iSelectable.ToString();
			var int k,kC=m_xSubjects.NumEntries();
			for(k=0)cond(k<kC)iter(k++)do
				if(!m_pxNestList^.IsItemSelected(k))then continue; endif;
				CEvt_ObjLECommand.Send(m_xSubjects[k], "TransferAttribs", xObj, {0.0f, 0.0f, 0.0f}, sMiscParams);
			endfor;
		endif;
		return(true);
	endproc;
	
	proc bool OnCopySimple()
		if(m_pxEggHolder!=null)then
			var CClntHndl xObj=m_pxEggHolder^.GetHandle();
			var int k,kC=m_xSubjects.NumEntries();
			for(k=0)cond(k<kC)iter(k++)do
				if(!m_pxNestList^.IsItemSelected(k))then continue; endif;
				CEvt_ObjLECommand.Send(m_xSubjects[k], "SimpleRegionCopy", xObj, {0.0f, 0.0f, 0.0f}, m_pxCopyColor^.GetChecked().ToString()+":"+m_pxCopyEnable^.GetChecked().ToString()+":"+m_pxClearFirst^.GetChecked().ToString()+":"+m_pxRegion^.GetSelectedItem().ToString());
			endfor;
		endif;
		return(true);
	endproc;
	
	proc bool OnCloneFlipRotateMove()
		if(m_pxEggHolder!=null)then
			var CClntHndl xObj=m_pxEggHolder^.GetHandle(), xSub;
			var int k,kC=m_xSubjects.NumEntries();
			for(k=0)cond(k<kC)iter(k++)do
				if(!m_pxNestList^.IsItemSelected(k))then continue; endif;
				CEvt_ObjLECommand.Send(m_xSubjects[k], "CloneFlipRotatetMove", xObj, {0.0f, 0.0f, 0.0f}, m_pxCopyColor^.GetChecked().ToString()+":"+m_pxCopyEnable^.GetChecked().ToString()+":"+m_pxClearFirst^.GetChecked().ToString()+":"+m_pxRegion^.GetSelectedItem().ToString()+":"+m_pxAngle^.GetSelectedItem().ToString()+":"+m_pxAxis^.GetSelectedItem().ToString());
			endfor;
		endif;
		return(true);
	endproc;
	
	proc bool OnStoreTmpPos()
		if(m_pxEggHolder!=null)then
			var CClntHndl xObj=m_pxEggHolder^.GetHandle(), xInvalid;
			CEvt_ObjLECommand.Send(xObj, "StoreTmpPos", xInvalid, m_pxEggHolder^.GetPos(), "");
		endif;
//		if(m_pxEggHolder!=null)then
//			var ^CAttribs pxAttribs=m_pxEggHolder^.GetAttribs();
//			if(pxAttribs!=null)then
//				pxAttribs^.SetValue("temp_pos",m_pxEggHolder^.GetPos().ToString());
//				CEvt_UpdateAttribs.Send(m_pxEggHolder^.GetGuid());
//			endif
//		endif;
		return(true);
	endproc;
	
	proc bool OnTranslatePos()
		if(m_pxEggHolder!=null)then
			var CClntHndl xObj=m_pxEggHolder^.GetHandle(), xInvalid;
			CEvt_ObjLECommand.Send(xObj, "TranslatePos", xInvalid, m_pxEggHolder^.GetPos(), "");
		endif;
//		var ^CRegionMgrClient pxRMgr=CClientWrap.GetRegionMgr();
//		if(m_pxEggHolder!=null&&pxRMgr!=null)then
//			var ^CAttribs pxA=m_pxEggHolder^.GetAttribs();
//			if(pxA!=null)then
//				var vec3 vTmp, vMe=m_pxEggHolder^.GetPos();
//				vTmp.FromString(pxA^.GetValue("temp_pos"));
//				CMirageSDKMgr.Debug("vMe X: "+vMe.GetX().ToString());
//				CMirageSDKMgr.Debug("vTmp X: "+vTmp.GetX().ToString());
//				var vec3 vOffset;
//				vOffset.SetXYZ(vMe.GetX()-vTmp.GetX(),vMe.GetY()-vTmp.GetY(),0.0f);
//				CMirageSDKMgr.Debug("offset: "+vOffset.ToString());
//				var array string asRegions;
//				asRegions.AddEntry(pxA^.GetValue("action_guid"));
//				asRegions.AddEntry(pxA^.GetValue("safe_guid"));
//				asRegions.AddEntry(pxA^.GetValue("hotspot_guid"));
//				var int i, iC = asRegions.NumEntries();
//				for(i=0)cond(i<iC)iter(i++)do
//					if(asRegions[i]!="")then
//						var CGuid xG;
//						xG.FromString(asRegions[i]);
//						if(!xG.IsNull())then
//							var ^CRegionBase pxR = pxRMgr^.GetRegion(xG);
//							if(pxR!=null)then
//								pxR^.Translate(vOffset);
//							endif;
//						endif;
//					endif;
//				endfor;
//				pxA^.SetValue("temp_pos",vMe.ToString());
//				CEvt_UpdateAttribs.Send(m_pxEggHolder^.GetGuid());
//			endif;
//		endif;
		return(true);
	endproc;
	
endclass;
	
class CMoveObjects inherit CFrameWindow

	class CObjMov inherit CItemData
		
		var CClntHndl m_xHndl;
		
		export constructor(ref CClntHndl p_rxHndl)
			m_xHndl=p_rxHndl;
		endconstructor;
		
		export proc CClntHndl GetHndl();
			return(m_xHndl);
		endproc;
		
	endclass;
	
	var ^CEdit		m_pxPosEdit;
	var ^CButton	m_pxMoveButton;
	var string		m_sGoalPos;
	var ^CEdit		m_pxRotEdit;
	var ^CButton	m_pxRotButton;
	var string		m_sGoalRot;
	var ^CList		m_pxObjectList;
	
	export constructor()
		var ^CDesktop pxDesktop = CClientWrap.GetDesktop();
		if(!InitFromResource("objects/ViewObjProperties","MoveObjects"))then
			CClientWrap.LogInfo("Error","CMoveObjects: InitFromResource failed");
			return;
		endif;
		m_pxPosEdit=cast<CEdit>(GetControl("GroupBoxMain/AbsPosEdit"));
		m_pxPosEdit^.m_xOnUpdate=OnSetGoal;
		m_pxPosEdit^.SetReadOnly(false);
		m_pxMoveButton=cast<CButton>(GetControl("GroupBoxMain/MoveToNewPos"));
		m_pxMoveButton^.m_xOnClick=OnMoveObject;
		m_pxRotEdit=cast<CEdit>(GetControl("GroupBoxMain/AbsRotEdit"));
		m_pxRotEdit^.m_xOnUpdate=OnSetRot;
		m_pxRotEdit^.SetReadOnly(false);
		m_pxRotButton=cast<CButton>(GetControl("GroupBoxMain/SetNewRotation"));
		m_pxRotButton^.m_xOnClick=OnSetNewRotation;
		m_pxObjectList=cast<CList>(GetControl("GroupBoxMain/ObjectList"));
		m_pxObjectList^.AllowMultiSelection(false);
		m_pxObjectList^.AllowScrollBar(true);
		m_pxObjectList^.AllowScrollBarHor(true);
		m_pxObjectList^.m_xOnSelect = CopyPosNRot;
		m_pxObjectList^.m_xOnLBtnDblClick = JumpToObj;
	endconstructor;
	
	export proc void Update()
		m_pxPosEdit^.SetText("");
		m_sGoalPos="[0.0 0.0 0.0]";
		m_pxRotEdit^.SetText("");
		m_sGoalRot="[0.0 0.0 0.0]";
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		var ^CObj pxObj=(pxSel^)[0].GetObj();
		m_pxObjectList^.Clear();
		var ^CObjMgr pxObjMgr=^(CClientWrap.GetObjMgr());
		var int i,iC=pxObjMgr^.NumObjects();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CObj pxObj=pxObjMgr^.GetObjByID(i);
			if(pxObj==null)then continue; endif;
			m_pxObjectList^.AddItem(pxObj^.GetName(), new CObjMov(pxObj^.GetHandle()));
		endfor;
		if(m_pxObjectList^.NumItems()>1)then
			m_pxObjectList^.QSort();
		endif;
		//Name
		if(pxSel^.NumEntries()==1)then
			m_pxPosEdit^.SetDisabled(false);
			m_pxPosEdit^.SetText(pxObj^.GetPos().ToString());
			m_sGoalPos=pxObj^.GetPos().ToString();
			m_pxMoveButton^.SetDisabled(false);
			m_pxRotEdit^.SetDisabled(false);
			var vec3 vTmp;
			pxObj^.GetRot().ToVec3(vTmp);
			m_pxRotEdit^.SetText(vTmp.ToString());
			m_sGoalRot=vTmp.ToString();
			m_pxRotButton^.SetDisabled(false);
		else
			m_pxPosEdit^.SetDisabled(true);
			m_pxPosEdit^.SetText("");
			m_sGoalPos="[0.0 0.0 0.0]";
			m_pxMoveButton^.SetDisabled(true);
			m_pxRotEdit^.SetDisabled(true);
			m_pxRotEdit^.SetText("");
			m_sGoalRot="[0.0 0.0 0.0]";
			m_pxRotButton^.SetDisabled(true);
		endif;
	endproc;
	
	export proc void Clear()
		m_pxPosEdit^.SetText("");
		m_sGoalPos="[0.0 0.0 0.0]";
		m_pxRotEdit^.SetText("");
		m_sGoalRot="[0.0 0.0 0.0]";
	endproc;
	
	proc bool OnSetGoal()
		m_sGoalPos=m_pxPosEdit^.GetText();
		return(true);
	endproc;
	
	proc bool OnMoveObject()
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		if(pxSel^.NumEntries()==1)then
			var vec3 vPos;
			vPos.FromString(m_sGoalPos);
			pxSel^.SetPos(vPos);
			pxSel^.UpdatePos();
		endif;
		return(true);
	endproc;
	
	proc bool CopyPosNRot()
		var int iSel=m_pxObjectList^.GetSelectedItem();
		if(iSel!=-1)then
			if(m_pxObjectList^.GetItemData(iSel)==null)then
				return(false);
			endif;
			var ^CObjMov pxItem=cast<CObjMov>(m_pxObjectList^.GetItemData(iSel));
			if(pxItem!=null)then
				var CClntHndl xSub=pxItem^.GetHndl();
				if(xSub.IsValid())then
					m_sGoalPos=xSub.GetObj()^.GetPos().ToString();
					m_pxPosEdit^.SetText(m_sGoalPos);
					var vec3 vTmp;
					xSub.GetObj()^.GetRot().ToVec3(vTmp);
					m_sGoalRot=vTmp.ToString();
					m_pxRotEdit^.SetText(m_sGoalRot);
				endif;
			endif;
		endif;
		return(true);
	endproc;
	
	proc bool OnSetRot()
		m_sGoalRot=m_pxRotEdit^.GetText();
		return(true);
	endproc;
	
	proc bool OnSetNewRotation()
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		if(pxSel^.NumEntries()==1)then
			var CClntHndl xObj=(pxSel^)[0];
			var ^CObj pxObj=xObj.GetObj();
			if(pxObj==null)then return false; endif;
			var vec3 vRot;
			vRot.FromString(m_sGoalRot);
			var Quat qRot;
			qRot.FromVec3(vRot);
			CEvt_SetRot.Send(pxObj^.GetGuid(),qRot);
		endif;
		return(true);
	endproc;
	
	proc bool JumpToObj()
		var int iSel=m_pxObjectList^.GetSelectedItem();
		if(iSel!=-1)then
			if(m_pxObjectList^.GetItemData(iSel)==null)then
				return(false);
			endif;
			var ^CObjMov pxItem=cast<CObjMov>(m_pxObjectList^.GetItemData(iSel));
			if(pxItem!=null)then
				var CClntHndl xSub=pxItem^.GetHndl();
				if(xSub.IsValid())then
					CMainController.Get().SetCameraTarget(xSub.GetObj()^.GetPos());
				endif;
			endif;
		endif;
		return(true);
	endproc;
	
endclass;

class COPLakeOfLavaProperties inherit CFrameWindow

	var ^CSpinCtrlNumber		m_pxDamage;
	var ^CSpinCtrlNumber		m_pxHeight;
	var ^CCheckBox					m_pxInstaKill;
	var ^CEdit							m_pxRegion;

	export constructor()
		if(!InitFromResource("objects/ViewObjProperties","LakeOfLavaProperties"))then
			CClientWrap.LogInfo("Error","COPLakeOfLavaProperties: InitFromResource failed");
			return;
		endif;
		m_pxDamage=cast<CSpinCtrlNumber>(GetControl("GroupBoxLakeOfLava/Damage"));
		m_pxHeight=cast<CSpinCtrlNumber>(GetControl("GroupBoxLakeOfLava/Height"));
		m_pxHeight^.SetDecimals(2);
		m_pxHeight^.SetLimits(0.0,20.0,1.0);
		m_pxHeight^.SetEditable(true);
		m_pxInstaKill=cast<CCheckBox>(GetControl("GroupBoxLakeOfLava/InstaKill"));
		m_pxRegion=cast<CEdit>(GetControl("GroupBoxLakeOfLava/Region"));
		m_pxDamage^.m_xOnChange = OnUpdateDamage;
		m_pxHeight^.m_xOnChange = OnUpdateHeight;
		m_pxRegion^.m_xOnChange = OnUpdateRegion;
		m_pxInstaKill^.m_xOnStateChange = OnUpdateInstaKill;
	endconstructor;

	export destructor()
	enddestructor;

	export proc bool Clear()
		return true;
	endproc;
	
	proc bool OnUpdateDamage()
		var int iVal = m_pxDamage^.GetValueInt();
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		var int i,iC=pxSel^.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xTemp=(pxSel^)[i];
			var ^CObj pxObj=xTemp.GetObj();
			if(pxObj!=null)then
				var ^CAttribs pxAttribs=pxObj^.GetAttribs();
				if(pxAttribs!=null)then
					if(pxAttribs^.ContainsKey("damage_per_tick"))then
						pxAttribs^.SetValue("damage_per_tick", iVal);
					endif;
				endif;
			endif;
			CEvt_UpdateAttribs.Send(pxObj^.GetGuid());
		endfor;
		return true;
	endproc;
	
	proc bool OnUpdateHeight()
		var int iVal = m_pxHeight^.GetValueInt();
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		var int i,iC=pxSel^.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xTemp=(pxSel^)[i];
			var ^CObj pxObj=xTemp.GetObj();
			if(pxObj!=null)then
				var ^CAttribs pxAttribs=pxObj^.GetAttribs();
				if(pxAttribs!=null)then
					if(pxAttribs^.ContainsKey("height"))then
						pxAttribs^.SetValue("height", iVal);
					endif;
				endif;
			endif;
			CEvt_UpdateAttribs.Send(pxObj^.GetGuid());
		endfor;
		return true;
	endproc;
	
	proc bool OnUpdateInstaKill()
		var int iVal = m_pxInstaKill^.GetChecked();
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		var int i,iC=pxSel^.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xTemp=(pxSel^)[i];
			var ^CObj pxObj=xTemp.GetObj();
			if(pxObj!=null)then
				var ^CAttribs pxAttribs=pxObj^.GetAttribs();
				if(pxAttribs!=null)then
					if(pxAttribs^.ContainsKey("insta_kill"))then
						pxAttribs^.SetValue("insta_kill", iVal==1);
					endif;
				endif;
			endif;
			CEvt_UpdateAttribs.Send(pxObj^.GetGuid());
		endfor;
		return true;
	endproc;
	
	proc bool OnUpdateRegion()
		var string sVal = m_pxRegion^.GetText();
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		var int i,iC=pxSel^.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xTemp=(pxSel^)[i];
			var ^CObj pxObj=xTemp.GetObj();
			if(pxObj!=null)then
				var ^CAttribs pxAttribs=pxObj^.GetAttribs();
				if(pxAttribs!=null)then
					if(pxAttribs^.ContainsKey("region_name"))then
						pxAttribs^.SetValue("region_name", sVal);
					endif;
				endif;
			endif;
			CEvt_UpdateAttribs.Send(pxObj^.GetGuid());
		endfor;
		return true;
	endproc;
	
	export proc bool Update()
		m_pxInstaKill^.m_xOnStateChange.Clear();
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		var ^CObj pxObj=(pxSel^)[0].GetObj();
		var int i,iValue,iC=pxSel^.NumEntries();
		var real fValue;
		var string sValue="";
		for(i=0)cond(i<iC)iter(i++)do
			var CClntHndl xTemp=(pxSel^)[i];
			var ^CObj pxObj=xTemp.GetObj();
			if(pxObj!=null)then
				var ^CAttribs pxAttribs=pxObj^.GetAttribs();
				if(pxAttribs!=null)then
					if(pxAttribs^.ContainsKey("damage_per_tick"))then
						iValue=pxAttribs^.GetValueInt("damage_per_tick");
						m_pxDamage^.SetValue(iValue);
					endif;
					if(pxAttribs^.ContainsKey("height"))then
						fValue=pxAttribs^.GetValueFloat("height");
						m_pxHeight^.SetValue(fValue);
					endif;
					if(pxAttribs^.ContainsKey("region_name"))then
						sValue=pxAttribs^.GetValue("region_name");
						m_pxRegion^.SetText(sValue);
					endif;
					sValue="";
					m_pxInstaKill^.SetChecked(0);
					var bool bInstaKill=pxAttribs^.GetValueBool("insta_kill");
					if(bInstaKill)then
						m_pxInstaKill^.SetChecked(1);
					endif;
					m_pxInstaKill^.m_xOnStateChange=OnUpdateInstaKill;
				endif;
			endif;
		endfor;
		return true;
	endproc;
	
endclass;
