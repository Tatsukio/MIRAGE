class Math2

	export static proc real CalcRotAngle(Quat p_qOldRot, Quat p_qNewRot)
		var Quat qOldRot = p_qOldRot; qOldRot.Conjugate();
		var Quat qNewRot = p_qNewRot;
		var Quat qDelta = qNewRot * qOldRot;
		var real fRadZ = 2.0f * Math.ATan2(qDelta.GetZ(), qDelta.GetW());
		return fRadZ;
	endproc;
	
	export static proc vec3 RotateAroundZAxis(vec3 p_vObjPos, vec3 p_vZAxisPos, real p_fRadAngle)
		if (p_vObjPos == p_vZAxisPos) then
			return p_vZAxisPos;
		endif;
		var vec3 vNewPos = p_vObjPos;
		var real fNewX = (p_vObjPos.GetX() - p_vZAxisPos.GetX()) * Math.Cos(p_fRadAngle) - (p_vObjPos.GetY() - p_vZAxisPos.GetY()) * Math.Sin(p_fRadAngle) + p_vZAxisPos.GetX();
		var real fNewY = (p_vObjPos.GetX() - p_vZAxisPos.GetX()) * Math.Sin(p_fRadAngle) + (p_vObjPos.GetY() - p_vZAxisPos.GetY()) * Math.Cos(p_fRadAngle) + p_vZAxisPos.GetY();
		vNewPos.SetX(fNewX);
		vNewPos.SetY(fNewY);
		return vNewPos;
	endproc;
	
	export static proc real DegToRad(real p_fDeg)
		return p_fDeg*Math.Pi()/180.0;
	endproc;
	
	export static proc real RadToDeg(real p_fRad)
		return p_fRad * 180.0/Math.Pi();
	endproc;

endclass;
