//	CMirageClnMgr.
//	CMirageClnMgr.Debug("");
//	CMirageClnMgr.Debug("xxxx: '"+xxxx+"'");
//	CMirageClnMgr.Debug("xxxx: '"+(xxxxxx).ToString()+"'");
//	CMirageClnMgr.Get().
//	CMirageSDKMgr.Debug("");

class CMirageClnMgr

	export const string VERSION = "2.6.7";
//	export const string BUILD = "";
	export const string BUILD = " build 05";
	export const string UPDATE = "20";
	export const string URL = "http://www.para-welt.com/mirage/?version=";
	export const string ALL4ONE = "Hu:Aje:Ninigi:SEAS:";
	export const string MODNAME = "MIRAGE";
	export const int EPOCH6 = 19881014;
	static var ^CMirageClnMgr ms_pxMgrClnInstance;
	var bool m_bIsSupplyOn;
	var bool m_bSupChecked;
	var bool m_bResLimitChecked;
	var bool m_bResUnlimited;
	var bool m_bManaEnabledChecked;
	export var bool m_bManaEnabled;
	var bool m_bPhantomModeChecked;
	var bool m_bPhantomMode;
	var bool m_bGameTimeChecked;
	var int m_iGameTime;
	var bool m_bDiploLockedChecked;
	var bool m_bDiploLocked;
	var bool m_bDwnLvlSwitchChecked;
	var int m_iDwnLvlSwitch;
	var bool m_bMaxEpochChecked;
	var int m_iMaxEpoch;
	var bool m_bBldgMaxCapacityChecked;
	var bool m_bBldgMaxCapacity;
	var bool m_bTechtreeStealChecked;
	var bool m_bTechtreeSteal;
	var bool m_bAllyBuildupChecked;
	var bool m_bAllyBuildup;
	var bool m_bAlienCommandsChecked;
	var bool m_bAlienCommands;
	var bool m_bIsPlayingSequence;
	var bool m_bAbandon;
	var bool m_bBloodAndGore;
	var bool m_bACHidden;
	var array int m_aiIsPaused;
	var ^CPropDB.CNode m_pxSupply;
	var ^CPropDB.CNode m_pxCommands;
	var ^CPropDB.CNode m_pxDieAck;
	var array string			m_asClasses;
	var array string			m_asValidNames;
	var string						m_sPlayerTribe;
	var string						m_sFocusClass;
	var string						m_sSpecialFocus;
	var bool							m_bFocusBldg;
	export var CObjList		m_xSelection;
	var array string			m_asMinorLocalUpgrades;
	var array string			m_asCancableActions;
	var array string			m_asNoToDisable;
	static var CClntHndl	ms_xGPCE;
	var array bool				m_abFeedbacks;
	var array string			m_asValidNPCs;
	var array string			m_asBuildings;
	var array string			m_asCrashRPGChars;
	var array string			m_asPlayerNames;
	var array int					m_aiCasualties;
	const int FEEDBACK_TYPES = 16;
	export static var int ms_iSDK;
	
	export const int FB_ATTACKS=0;
	export const int FB_BUILDINGS=1;
	export const int FB_IMPROVEMENT=2;
	export const int FB_MAPPING=3;
	export const int FB_FULLSTORAGE=4;
	export const int FB_DEFICIT=5;
	export const int FB_POPULATION=6;
	export const int FB_EPOCHDONE=7;
	export const int FB_EPOCHSTART=8;
	export const int FB_DIMENSION=9;
	export const int FB_MULTIPLAYER=10;
	export const int FB_QUEST=11;
	export const int FB_DEATH=12;
	export const int FB_TREASURES=13;
	export const int FB_ENDSCREEN=14;
	export const int FB_ECONOMY=15;
	
	export static proc ref CMirageClnMgr Get()
		if(ms_pxMgrClnInstance==null)then
			ms_pxMgrClnInstance=new CMirageClnMgr();
		endif;
		return ms_pxMgrClnInstance^;
	endproc;
	
	export static proc void ShutStatic()
		delete ms_pxMgrClnInstance;
	endproc;
	
	export static proc void Kill()
		if(ms_pxMgrClnInstance!=null)then
			delete ms_pxMgrClnInstance;
			ms_pxMgrClnInstance=null;
		endif;
	endproc;
	
	export proc bool Purify()
		CMirageClnMgr.ms_xGPCE.Invalidate();
		m_bSupChecked = false;
		m_bIsSupplyOn = false;
		m_bResLimitChecked = false;
		m_bResUnlimited = false;
		m_bManaEnabledChecked = false;
		m_bManaEnabled = false;
		m_bPhantomModeChecked = false;
		m_bPhantomMode = false;
		m_iGameTime = 0;
		m_bGameTimeChecked = false;
		m_bDiploLockedChecked = false;
		m_bIsPlayingSequence = false;
		m_bDwnLvlSwitchChecked = false;
		m_bMaxEpochChecked = false;
		m_bBldgMaxCapacityChecked = false;
		m_bTechtreeStealChecked = false;
		m_bAllyBuildupChecked = false;
		m_bAlienCommandsChecked = false;
		m_bIsPlayingSequence = false;
		m_bAbandon = false;
		m_aiIsPaused = 0;
		m_xSelection.Clear();
		m_sPlayerTribe = "";
		m_sFocusClass = "";
		m_sSpecialFocus = "";
		m_bFocusBldg = false;
		m_asClasses = 0;
		m_asValidNames = 0;
//		m_asPlayerNames = 0;
//		m_asPlayerNames = 8;
		m_aiCasualties = 0;
		m_aiCasualties = 8;
		return true;
	endproc;
	
	constructor()
		CMirageClnMgr.ms_iSDK=0;
		var ^CPropDB pxSupplies = new CPropDB;
		pxSupplies^.Load(CClientWrap.GetUrsRelPath() + "/Data/Base/Scripts/Server/settings/unit_supplies.txt");
		m_pxSupply = ^((pxSupplies^).GetRoot());
		var ^CPropDB pxDieAck = new CPropDB;
		if(pxDieAck^.Load(CClientWrap.GetUrsRelPath() + "/Data/Base/Scripts/Server/settings/die_acks.txt"))then
			m_pxDieAck = ^((pxDieAck^).GetRoot());
		else
			m_pxDieAck = null;
		endif;
		m_abFeedbacks=FEEDBACK_TYPES;
		m_bSupChecked = false;
		m_bResLimitChecked = false;
		m_bManaEnabledChecked = false;
		m_bPhantomModeChecked = false;
		m_bGameTimeChecked = false;
		m_bDiploLockedChecked = false;
		m_bDwnLvlSwitchChecked = false;
		m_bMaxEpochChecked = false;
		m_bBldgMaxCapacityChecked = false;
		m_bTechtreeStealChecked = false;
		m_bAllyBuildupChecked = false;
		m_bAlienCommandsChecked = false;
		m_bIsPlayingSequence = false;
		m_bAbandon = false;
		m_aiIsPaused = 0;
		m_xSelection.Clear();
		m_sPlayerTribe = "";
		m_sFocusClass = "";
		m_sSpecialFocus = "";
		m_bFocusBldg = false;
		m_asClasses = 0;
		m_asValidNames = 0;
		m_asPlayerNames = 8;
		m_aiCasualties = 8;
		m_asMinorLocalUpgrades.AddEntry("Actions/Aje/Upgrades/aje_resource_collector/liberator");
		m_asMinorLocalUpgrades.AddEntry("Actions/Ninigi/Upgrades/ninigi_fireplace/Explode");
		m_asMinorLocalUpgrades.AddEntry("Actions/SEAS/Upgrades/seas_barracks/barracks_reactor_core");
		m_asMinorLocalUpgrades.AddEntry("Actions/SEAS/Upgrades/seas_carrier/improved_weaponry");
		m_asMinorLocalUpgrades.AddEntry("Actions/SEAS/Upgrades/seas_carrier/carrier_reactor_core");
		m_asMinorLocalUpgrades.AddEntry("Actions/SEAS/Upgrades/seas_fortress/fortress_reactor_core");
		m_asMinorLocalUpgrades.AddEntry("Actions/SEAS/Upgrades/seas_fortress/planetary_upgrade");
		m_asMinorLocalUpgrades.AddEntry("Actions/SEAS/Upgrades/seas_garage/garage_reactor_core");
		m_asMinorLocalUpgrades.AddEntry("Actions/SEAS/Upgrades/seas_helicopter/fighter_mode");
		m_asMinorLocalUpgrades.AddEntry("Actions/SEAS/Upgrades/seas_helicopter/assault_mode");
		m_asMinorLocalUpgrades.AddEntry("Actions/SEAS/Upgrades/seas_laboratory/laboratory_reactor_core");
		m_asMinorLocalUpgrades.AddEntry("Actions/SEAS/Upgrades/seas_jail_part_01/jail_part_01_reactor_core");
		m_asMinorLocalUpgrades.AddEntry("Actions/SEAS/Upgrades/seas_jail_part_02/jail_part_02_reactor_core");
		m_asMinorLocalUpgrades.AddEntry("Actions/SEAS/Upgrades/seas_headquarters/headquarters_reactor_core");
		m_asMinorLocalUpgrades.AddEntry("Actions/Special/Upgrades/babbage_s0/mechanization");
		m_asCancableActions.AddEntry("Actions/Aje/Moves/BLDG/BuildDown");
		m_asCancableActions.AddEntry("Actions/Ninigi/Upgrades/ninigi_fireplace/Explode");
		m_asCancableActions.AddEntry("Actions/Special/Upgrades/babbage_s0/mechanization");
		m_asNoToDisable.AddEntry("Actions/Aje/Moves/BLDG/BuildDown");
		m_asNoToDisable.AddEntry("Actions/Ninigi/Upgrades/ninigi_fireplace/Explode");
		m_asNoToDisable.AddEntry("Actions/Special/Upgrades/babbage_s0/mechanization");
//		m_asNoToDisable.AddEntry("Actions/SEAS/Upgrades/seas_helicopter/fighter_mode");
//		m_asNoToDisable.AddEntry("Actions/SEAS/Upgrades/seas_helicopter/assault_mode");
		CMirageClnMgr.ms_xGPCE.Invalidate();
		Initialization();
	endconstructor;
	
	destructor()
		m_bSupChecked = false;
		m_bResLimitChecked = false;
		m_bManaEnabledChecked = false;
		m_bPhantomModeChecked = false;
		m_bGameTimeChecked = false;
		m_bDiploLockedChecked = false;
		m_bDwnLvlSwitchChecked = false;
		m_bMaxEpochChecked = false;
		m_bBldgMaxCapacityChecked = false;
		m_bTechtreeStealChecked = false;
		m_bAllyBuildupChecked = false;
		m_bAlienCommandsChecked = false;
		m_bIsPlayingSequence = false;
		m_bAbandon = false;
		m_aiIsPaused = 0;
		m_xSelection.Clear();
		m_sPlayerTribe = "";
		m_sFocusClass = "";
		m_sSpecialFocus = "";
		m_bFocusBldg = false;
		m_asClasses = 0;
		m_asValidNames = 0;
		m_asPlayerNames = 0;
		m_aiCasualties = 0;
		CMirageClnMgr.ms_xGPCE.Invalidate();
		ShutStatic();
	enddestructor;
	
	export proc void Initialization()
		var CConfig xConf;
		m_bBloodAndGore=xConf.GetSetB("Client/GameplayOptions/BloodEffect",false);
		m_bACHidden=xConf.GetSetB("Client/GameplayOptions/HideACInGame",false);
		m_abFeedbacks[FB_ATTACKS]=xConf.GetSetB("Client/SoundFeedbacks/EnemyAttacks",false);
		m_abFeedbacks[FB_BUILDINGS]=xConf.GetSetB("Client/SoundFeedbacks/BuildingReady",false);
		m_abFeedbacks[FB_IMPROVEMENT]=xConf.GetSetB("Client/SoundFeedbacks/ImprovementReady",false);
		m_abFeedbacks[FB_MAPPING]=xConf.GetSetB("Client/SoundFeedbacks/Mapping",false);
		m_abFeedbacks[FB_FULLSTORAGE]=xConf.GetSetB("Client/SoundFeedbacks/StorageFull",false);
		m_abFeedbacks[FB_DEFICIT]=xConf.GetSetB("Client/SoundFeedbacks/ResourcesNeeded",false);
		m_abFeedbacks[FB_POPULATION]=xConf.GetSetB("Client/SoundFeedbacks/Population",false);
		m_abFeedbacks[FB_EPOCHDONE]=xConf.GetSetB("Client/SoundFeedbacks/EpochFinished",false);
		m_abFeedbacks[FB_EPOCHSTART]=xConf.GetSetB("Client/SoundFeedbacks/EpochWarning",false);
		m_abFeedbacks[FB_DIMENSION]=xConf.GetSetB("Client/SoundFeedbacks/Warpgates",false);
		m_abFeedbacks[FB_MULTIPLAYER]=xConf.GetSetB("Client/SoundFeedbacks/MultiplayerRelated",false);
		m_abFeedbacks[FB_QUEST]=xConf.GetSetB("Client/SoundFeedbacks/QuestRelated",false);
		m_abFeedbacks[FB_DEATH]=xConf.GetSetB("Client/SoundFeedbacks/DieAcks",false);
		m_abFeedbacks[FB_TREASURES]=xConf.GetSetB("Client/SoundFeedbacks/ArtifactsRelated",false);
		m_abFeedbacks[FB_ENDSCREEN]=xConf.GetSetB("Client/SoundFeedbacks/Endscreen",false);
		m_abFeedbacks[FB_ECONOMY]=xConf.GetSetB("Client/SoundFeedbacks/EconomyRelated",false);
		var ^CPropDB pxHeroes = new CPropDB, pxBldgs = new CPropDB, pxCrashRPG = new CPropDB;
		if(pxHeroes^.Load(CClientWrap.GetUrsRelPath()+"/Data/Base/Scripts/Server/settings/NPCList.txt"))then
			var ^CPropDB.CNode pxRoot = ^(pxHeroes^.GetRoot());
			var int i, iC = pxRoot^.NumSubs();
			for(i=0)cond(i<iC)iter(i++)do
				m_asValidNPCs.AddEntry((pxRoot^)[i].Name());
			endfor;
		endif;
		if(pxHeroes^.Load(CClientWrap.GetUrsRelPath()+"/Data/Base/Scripts/Server/settings/CrashRPGList.txt"))then
			var ^CPropDB.CNode pxRoot = ^(pxHeroes^.GetRoot());
			var int i, iC = pxRoot^.NumSubs();
			for(i=0)cond(i<iC)iter(i++)do
				m_asCrashRPGChars.AddEntry((pxRoot^)[i].Name());
			endfor;
		endif;
		if(pxBldgs^.Load(CClientWrap.GetUrsRelPath()+"/Data/Base/Scripts/Server/settings/BuildingList.txt"))then
			var ^CPropDB.CNode pxRoot = ^(pxBldgs^.GetRoot());
			var int i, iC = pxRoot^.NumSubs();
			for(i=0)cond(i<iC)iter(i++)do
				m_asBuildings.AddEntry((pxRoot^)[i].Name());
			endfor;
		endif;
	endproc;
	
	export proc void SetFeedback(int p_iType,bool p_bOn)
		m_abFeedbacks[p_iType]=p_bOn;
	endproc;
	
	export proc int GetSupply(string p_sCllsNm)
		var int iSuppCount = m_pxSupply^.GetValueI(p_sCllsNm, 0);
		return iSuppCount;
	endproc;

	export proc bool IsSupplyOn()
		if(!m_bSupChecked)then
			var ^CLevelInfoClient pxLevelInfo = ^(CGameWrap.GetClient().GetLevelInfo());
			if(pxLevelInfo != null)then
				var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
				var ^CPropDB.CNode pxCSNode=^((pxGenericDB^)["ClientSettings"]);
				var ^CPropDB.CNode pxSupply=^(pxCSNode^.Get("UseSupply"));
				if(pxSupply==null)then
					var CConfig xConf;
					m_bIsSupplyOn = xConf.GetSetB("Server/GameplayOptions/UseSupply",false);
				else
					var int iSupply = pxCSNode^.GetValueI("UseSupply");
					m_bIsSupplyOn = iSupply==1;
					m_bSupChecked = true;
				endif;
			else
				m_bIsSupplyOn = false;
			endif;
		endif;
		return m_bIsSupplyOn;
	endproc;
	
	export proc bool IsResUnlimited()
		if(!m_bResLimitChecked)then
			var ^CLevelInfoClient pxLevelInfo = ^(CGameWrap.GetClient().GetLevelInfo());
			if(pxLevelInfo != null)then
				var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
				var ^CPropDB.CNode pxCSNode=^((pxGenericDB^)["ClientSettings"]);
				var ^CPropDB.CNode pxResi=^(pxCSNode^.Get("ResourcesUnlimited"));
//				var ^CPropDB.CNode pxTime=^(pxCSNode^.Get("GameTimer"));
				if(pxResi==null)then
					var CConfig xConf;
					m_bResUnlimited = xConf.GetSetB("Server/GameplayOptions/ResourcesUnlimited",false);
					//m_bResUnlimited = xConf.GetSetB("Server/GameplayOptions/ResourcesUnlimited",true);
				else
					var int iResUnlimited = pxCSNode^.GetValueI("ResourcesUnlimited");
					m_bResUnlimited = iResUnlimited==1;
					m_bResLimitChecked = true;
				endif;
			else
				m_bResUnlimited = false;
			endif;
		endif;
		return m_bResUnlimited;
	endproc;
	
	export proc bool PhantomMode()
		if(!m_bPhantomModeChecked)then
			var ^CLevelInfoClient pxLevelInfo = ^(CGameWrap.GetClient().GetLevelInfo());
			if(pxLevelInfo != null)then
				var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
				var ^CPropDB.CNode pxCSNode=^((pxGenericDB^)["ClientSettings"]);
				var ^CPropDB.CNode pxPhantomMode=^(pxCSNode^.Get("PhantomMode"));
				if(pxPhantomMode==null)then
					var CConfig xConf;
					m_bPhantomMode = xConf.GetSetI("Server/GameplayOptions/PhantomMode",0)>0;
				else
					var int iPhantomMode = pxCSNode^.GetValueI("ResourcesUnlimited");
					m_bPhantomMode = iPhantomMode>0;
					m_bPhantomModeChecked = true;
				endif;
			else
				m_bPhantomMode = false;
			endif;
		endif;
		return m_bPhantomMode;
	endproc;
	
	export proc bool IsMinorLocalUpgrade(string p_sAction)
		return (m_asMinorLocalUpgrades.FindEntry(p_sAction))!=-1;
	endproc;
	
	export proc bool IsCancableAction(string p_sAction)
		return (m_asCancableActions.FindEntry(p_sAction))!=-1;
	endproc;
	
	export proc bool ShouldNotBeDisabled(string p_sAction)
		return (m_asNoToDisable.FindEntry(p_sAction))!=-1;
	endproc;
	
	export proc bool ManaEnabled()
		if(!m_bManaEnabledChecked)then
			var ^CLevelInfoClient pxLevelInfo = ^(CGameWrap.GetClient().GetLevelInfo());
			if(pxLevelInfo != null)then
				var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
				var ^CPropDB.CNode pxCSNode=^((pxGenericDB^)["ClientSettings"]);
				var ^CPropDB.CNode pxManaEnabled=^(pxCSNode^.Get("ManaEnabled"));
				if(pxManaEnabled==null)then
					var CConfig xConf;
					m_bManaEnabled = xConf.GetSetB("Server/GameplayOptions/ManaEnabled",false);
				else
					var int iManaEnabled = pxCSNode^.GetValueI("ManaEnabled");
					m_bManaEnabled = iManaEnabled==1;
					m_bManaEnabledChecked=true;
				endif;
			else
				m_bManaEnabled = false;
			endif;
		endif;
		return m_bManaEnabled;
	endproc;
	
	export proc bool DiploLocked()
		if(!m_bDiploLockedChecked)then
			var ^CLevelInfoClient pxLevelInfo = ^(CGameWrap.GetClient().GetLevelInfo());
			if(pxLevelInfo!=null)then
				var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
				var ^CPropDB.CNode pxCSNode=^((pxGenericDB^)["ClientSettings"]);
				if(pxCSNode==null)then
					return false;
				endif;
				var ^CPropDB.CNode pxDiploLocked=^(pxCSNode^.Get("DiploLocked"));
				if(pxDiploLocked==null)then
					var CConfig xConf;
					m_bDiploLocked = xConf.GetSetB("Server/GameplayOptions/DiploLocked",false);
				else
					var int iDiploLocked = pxCSNode^.GetValueI("DiploLocked");
					m_bDiploLocked = iDiploLocked==1;
					m_bDiploLockedChecked=true;
				endif;
			else
				m_bDiploLocked = false;
			endif;
		endif;
		return m_bDiploLocked;
	endproc;
	
	export proc void UnlockDiplo()
		m_bDiploLocked=false;
	endproc;
	
	export proc int DwnLvlSwitch()
		if(!m_bDwnLvlSwitchChecked)then
			var ^CLevelInfoClient pxLevelInfo = ^(CGameWrap.GetClient().GetLevelInfo());
			if(pxLevelInfo!=null)then
				var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
				var ^CPropDB.CNode pxCSNode=^((pxGenericDB^)["ClientSettings"]);
				if(pxCSNode==null)then
					return 0;
				endif;
				var ^CPropDB.CNode pxDwnLvlSwitch=^(pxCSNode^.Get("DwnLvlSwitch"));
				if(pxDwnLvlSwitch==null)then
					var CConfig xConf;
					m_iDwnLvlSwitch = xConf.GetSetI("Server/GameplayOptions/DwnLvlSwitch",0);
				else
					m_iDwnLvlSwitch = pxCSNode^.GetValueI("DwnLvlSwitch");
					m_bDwnLvlSwitchChecked=true;
				endif;
			else
				m_iDwnLvlSwitch = 0;
			endif;
		endif;
		return m_iDwnLvlSwitch;
	endproc;
	
	export proc int MaxEpoch()
		if(!m_bMaxEpochChecked)then
			var ^CLevelInfoClient pxLevelInfo = ^(CGameWrap.GetClient().GetLevelInfo());
			if(pxLevelInfo!=null)then
				var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
				var ^CPropDB.CNode pxCSNode=^((pxGenericDB^)["ClientSettings"]);
				if(pxCSNode==null)then
					return 0;
				endif;
				var ^CPropDB.CNode pxMaxEpoch=^(pxCSNode^.Get("MaxEpoch"));
				if(pxMaxEpoch==null)then
					var CConfig xConf;
					m_iMaxEpoch = xConf.GetSetI("Server/GameplayOptions/MaxEpoch",0);
				else
					m_iMaxEpoch = pxCSNode^.GetValueI("MaxEpoch");
					m_bMaxEpochChecked=true;
				endif;
			else
				m_iMaxEpoch = 0;
			endif;
		endif;
		return m_iMaxEpoch;
	endproc;
	
	export proc bool CheckBldgMaxCapacity()
		if(!m_bBldgMaxCapacityChecked)then
			var ^CLevelInfoClient pxLevelInfo = ^(CGameWrap.GetClient().GetLevelInfo());
			if(pxLevelInfo!=null)then
				var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
				var ^CPropDB.CNode pxCSNode=^((pxGenericDB^)["ClientSettings"]);
				if(pxCSNode==null)then
					return false;
				endif;
				var ^CPropDB.CNode pxBldgMaxCapacity=^(pxCSNode^.Get("BldgMaxCapacity"));
				if(pxBldgMaxCapacity==null)then
					var CConfig xConf;
					m_bBldgMaxCapacity = xConf.GetSetB("Server/GameplayOptions/BldgMaxCapacity",false);
				else
					var int iBldgMaxCapacity = pxCSNode^.GetValueI("BldgMaxCapacity");
					m_bBldgMaxCapacity = iBldgMaxCapacity==1;
					m_bBldgMaxCapacityChecked=true;
				endif;
			else
				m_bBldgMaxCapacity = false;
			endif;
		endif;
		return m_bBldgMaxCapacity;
	endproc;
	
	export proc bool CheckTechtreeSteal()
		if(!m_bTechtreeStealChecked)then
			var ^CLevelInfoClient pxLevelInfo = ^(CGameWrap.GetClient().GetLevelInfo());
			if(pxLevelInfo!=null)then
				var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
				var ^CPropDB.CNode pxCSNode=^((pxGenericDB^)["ClientSettings"]);
				if(pxCSNode==null)then
					return false;
				endif;
				var ^CPropDB.CNode pxTechtreeSteal=^(pxCSNode^.Get("TechtreeSteal"));
				if(pxTechtreeSteal==null)then
					var CConfig xConf;
					m_bTechtreeSteal = xConf.GetSetB("Server/GameplayOptions/TechtreeSteal",false);
				else
					var int iTechtreeSteal = pxCSNode^.GetValueI("TechtreeSteal");
					m_bTechtreeSteal = iTechtreeSteal==1;
					m_bTechtreeStealChecked=true;
				endif;
			else
				m_bTechtreeSteal = false;
			endif;
		endif;
		return m_bTechtreeSteal;
	endproc;
	
	export proc bool CheckAllyBuildup()
		if(!m_bAllyBuildupChecked)then
			var ^CLevelInfoClient pxLevelInfo = ^(CGameWrap.GetClient().GetLevelInfo());
			if(pxLevelInfo!=null)then
				var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
				var ^CPropDB.CNode pxCSNode=^((pxGenericDB^)["ClientSettings"]);
				if(pxCSNode==null)then
					return false;
				endif;
				var ^CPropDB.CNode pxAllyBuildup=^(pxCSNode^.Get("AllyBuildup"));
				if(pxAllyBuildup==null)then
					var CConfig xConf;
					m_bAllyBuildup = xConf.GetSetB("Server/GameplayOptions/AllyBuildup",true);
				else
					var int iAllyBuildup = pxCSNode^.GetValueI("AllyBuildup");
					m_bAllyBuildup = iAllyBuildup==1;
					m_bAllyBuildupChecked=true;
				endif;
			else
				m_bAllyBuildup = false;
			endif;
		endif;
		return m_bAllyBuildup;
	endproc;
	
	export proc bool CheckAlienCommands()
		if(!m_bAlienCommands)then
			var ^CLevelInfoClient pxLevelInfo = ^(CGameWrap.GetClient().GetLevelInfo());
			if(pxLevelInfo!=null)then
				var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
				var ^CPropDB.CNode pxCSNode=^((pxGenericDB^)["ClientSettings"]);
				if(pxCSNode==null)then
					return false;
				endif;
				var ^CPropDB.CNode pxAlienCommands=^(pxCSNode^.Get("AlienCommands"));
				if(pxAlienCommands==null)then
					var CConfig xConf;
					m_bAlienCommands = xConf.GetSetB("Server/AllowAlienCommands",false);
				else
					var int iAlienCommands = pxCSNode^.GetValueI("AlienCommands");
					m_bAlienCommands = iAlienCommands==1;
					m_bAlienCommandsChecked=true;
				endif;
			else
				m_bAlienCommands = false;
			endif;
		endif;
		return m_bAlienCommands;
	endproc;
	
	export proc int GetSpan()
		if(!m_bGameTimeChecked)then
			var ^CLevelInfoClient pxLevelInfo = ^(CGameWrap.GetClient().GetLevelInfo());
			if(pxLevelInfo!=null)then
				var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
				var ^CPropDB.CNode pxBaseNode=^((pxGenericDB^)["Base"]);
				var ^CPropDB.CNode pxCSNode=^((pxGenericDB^)["ClientSettings"]);
				if(pxBaseNode!=null&&pxCSNode!=null)then
//					var ^CPropDB.CNode pxTime=^(pxBaseNode^.Get("Test"));
					var ^CPropDB.CNode pxTime=pxCSNode^.FindNode("TimerIniated",false);
					if(pxTime==null)then
						m_iGameTime=0;
//						var int i, iC=pxCSNode^.NumSubs();
//						for(i=0)cond(i<iC)iter(i++)do
//							var string sNode=(pxCSNode^)[i].Name();
//						endfor;
					else
						var int iInited = pxCSNode^.GetValueI("TimerIniated");
						m_iGameTime = pxBaseNode^.GetValueR("PlayedTime",0.0).ToInt();
						m_bGameTimeChecked = iInited==1;
//						m_bGameTimeChecked=true;
					endif;
				else
					m_iGameTime=0;
				endif;
			endif;
		endif;
		return m_iGameTime;
	endproc;
	
	export proc void SetACHidden(bool p_bOn)
		m_bACHidden=p_bOn;
	endproc;
	
	export proc void SetMoreBlood(bool p_bOn)
		m_bBloodAndGore=p_bOn;
	endproc;
	
	export proc bool IsACHidden()
		return m_bACHidden;
	endproc;
	
	export proc bool MoreBlood()
		return m_bBloodAndGore;
	endproc;
	
	export proc bool GetFeedback(string p_sType)
		if(m_bIsPlayingSequence)then return false; endif;
		if(m_aiIsPaused.NumEntries()>0)then return false; endif;
		var CConfig xConf;
		var bool bPlayFeedback = xConf.GetSetB("Client/SoundFeedbacks/"+p_sType,true);
		return bPlayFeedback;
	endproc;
	
	export proc bool GetFeedback(int p_iType)
		if(m_bIsPlayingSequence)then return false; endif;
		if(m_aiIsPaused.NumEntries()>0)then return false; endif;
		return m_abFeedbacks[p_iType];
	endproc;
	
	export static proc bool ValidateName(ref string po_rsClass, CClntHndl p_xHandle)
		if(!p_xHandle.IsValid())then return false; endif;
		var ^CObj pxObj = p_xHandle.GetObj();
		if(pxObj==null)then return false; endif;
		po_rsClass = pxObj^.GetClassName();
		if(po_rsClass=="aje_catapult_rex"||po_rsClass=="aje_resource_collector"||po_rsClass=="ninigi_seismosaurus"||po_rsClass=="seas_helicopter")then return true; endif;
		var ^CAttribs pxAttr = pxObj^.GetAttribs();
		if(pxAttr!=null)then
			var string sFlag = pxAttr^.GetValue("ObjFlag");
			if(sFlag!="")then
				po_rsClass = sFlag;
			endif;
		endif;
		return true;
	endproc;
	
	export static proc bool ValidateName(ref string po_rsClass, ^CObj p_pxObj)
		if(p_pxObj==null)then return false; endif;
		po_rsClass = p_pxObj^.GetClassName();
		if(po_rsClass=="aje_catapult_rex"||po_rsClass=="aje_resource_collector"||po_rsClass=="ninigi_seismosaurus"||po_rsClass=="seas_helicopter")then return true; endif;
		var ^CAttribs pxAttr = p_pxObj^.GetAttribs();
		if(pxAttr!=null)then
			var string sFlag = pxAttr^.GetValue("ObjFlag");
			if(sFlag!="")then
				po_rsClass = sFlag;
			endif;
		endif;
		return true;
	endproc;
	
	export static proc bool ValidateNameInfo(^CObj p_pxObj, ref bool p_rbSpec)
		if(p_pxObj==null)then return false; endif;
		var string sClass = p_pxObj^.GetClassName();
		var ^CAttribs pxAttr = p_pxObj^.GetAttribs();
		if(pxAttr!=null)then
			var string sFlag = pxAttr^.GetValue("ObjFlag");
			if(sFlag!="")then
				sClass = sFlag;
			endif;
		endif;
		p_rbSpec=sClass=="ninigi_seismosaurus";
		return true;
	endproc;
	
	export static proc bool IsCustomMap(^CLevelInfo p_pxLevelInfo)
		var string sName = "";
		if(p_pxLevelInfo==null)then return false; endif;
		var ^CPropDB.CNode pxBaseNode=^((p_pxLevelInfo^.GetGenericData())["Base"]);
		if(pxBaseNode!=null)then
			sName=pxBaseNode^.GetValueS("LevelName");
		endif;
		if(sName.Find("BfPW - Highland")!=-1||sName.Find("BfPW - HL")!=-1||sName.Find("BfPW - Holy City")!=-1||sName=="_CU_MP_4_ASS_CREED"||sName=="_CU_MP_6_CRASH_RPG"||sName=="_CU_MP_6_BFPW_HIGHLAND")then
			return true;
		endif;
		return false;
	endproc;
	
	export static proc bool IsWinReason(string p_sReason)
		var ^CPropDB pxWinReasons = new CPropDB();
		if(!pxWinReasons^.Load(CClientWrap.GetUrsRelPath() + "/Data/Base/Scripts/Game/misc/win_reasons.txt"))then return false; endif;
		//var ^CPropDB.CNode pxReasons = ^(pxWinReasons^.GetRoot());
		//if(pxReasons^.NumSubs() < 1)then return false; endif;
		if(pxWinReasons^.FindNode(p_sReason, false) != null)then return true; endif;
		return false;
	endproc;
	
	export static proc bool AllowRetry(^CLevelInfo p_pxLevelInfo)
		var string sName = "";
		if(p_pxLevelInfo==null)then return true; endif;
		var ^CPropDB.CNode pxBaseNode=^((p_pxLevelInfo^.GetGenericData())["Base"]);
		if(pxBaseNode!=null)then
			sName=pxBaseNode^.GetValueS("LevelName");
		endif;
		if(sName=="_CU_MP_6_CRASH_RPG")then
			return false;
		endif;
		return true;
	endproc;
	
	export static proc bool HostDifficulty(^CLevelInfo p_pxLevelInfo)
		var string sName = "";
		if(p_pxLevelInfo==null)then return false; endif;
		var ^CPropDB.CNode pxBaseNode=^((p_pxLevelInfo^.GetGenericData())["Base"]);
		if(pxBaseNode!=null)then
			sName=pxBaseNode^.GetValueS("LevelName");
		endif;
		if(sName=="_CU_MP_6_CRASH_RPG")then
			return true;
		endif;
		return false;
	endproc;
	
	export proc bool IsOkAndReadyForAction(string p_sTTName, CClntHndl p_xHandle, ref bool p_rbLocked, bool p_bMultiSelection)
		if(!p_xHandle.IsValid())then return false; endif;
		var ^CObj pxActor = p_xHandle.GetObj();
		if(pxActor==null)then return false; endif;
		var ^CAttribs pxAttr = pxActor^.GetAttribs();
		if(pxAttr==null)then return false; endif;
		if(pxAttr^.GetValueBool("is_locked"))then
			p_rbLocked=p_bMultiSelection;
			return false;
		else
			p_rbLocked=false;
		endif;
		// Henry: if having the ability itself
		var CTechTree xObjTT;
		var ^CTechTree.CNode pxOwnNode;
//		if(!pxActor^.HasTechTree())then return false; endif;
		xObjTT = pxActor^.GetTechTree();
		pxOwnNode = xObjTT.FindNode(p_sTTName);
		if(pxOwnNode==null)then return false; endif;
		// Henry: if action is visible and not disabled...
		if(!pxOwnNode^.IsVisible())then return false; endif;
		if(pxOwnNode^.GetSubValueI("visibility", 0)!=1)then return false; endif;
		if(pxOwnNode^.GetSubValueI("disabled", 0)==1)then return false; endif;
		var ^CTechTree.CNode pxLocations = pxOwnNode^.GetSub("locations");
		if(pxLocations != null)then
			var bool bFound = false;
			var int i, iC = pxLocations^.NumSubs();
			for(i=0)cond(i<iC)iter(++i)do
				var ^CTechTree.CNode pxLocation = pxLocations^.GetSub(i);
				if(pxLocation==null)then
					continue;
				endif;
				var string sVal = pxLocation^.GetValue();
				var int iPos = sVal.FindRev('/');
				if(iPos != -1)then
					sVal = sVal.Mid(iPos + 1);
					if(sVal==pxActor^.GetClassName()||pxActor^.GetType()==sVal)then
						var ^CTechTree.CNode pxLocalFlags=pxLocation^.GetSub("localflags");
						if(pxLocalFlags!=null)then
							var int j,iJC=pxLocalFlags^.NumSubs();
							for(j=0)cond(j<iJC)iter(j++)do
								var string sFlag=pxLocalFlags^.GetSub(j)^.GetName();
								if(pxLocalFlags^.GetSub(j)^.GetValueI()==1&&sFlag==pxAttr^.GetValue("ObjFlag"))then
									bFound = true;
									break;
								endif;
							endfor;
						else
							bFound = true;
							break;
						endif;
					endif;
				endif;
			endfor;
			if(!bFound)then return false; endif;
		endif;
		// Henry: having a cooldown of that ability
		var string sSpecial = pxAttr^.GetValue("SpecialActionNames");
		if(!sSpecial.IsEmpty())then
			var array string asActions;
			sSpecial.Split(asActions, "\n", true);
			var int i, iC = asActions.NumEntries();
			for(i=0)cond(i<iC)iter(++i)do
				if(p_sTTName.Find(asActions[i])!=-1)then
					return false;
				endif;
			endfor;
		endif;
		// Henry: have a local upgrade...
		var string sLocalUpgrade = pxAttr^.GetValue("LocalUpgrade");
		if(sLocalUpgrade.IsEmpty()== false && !IsMinorLocalUpgrade(sLocalUpgrade))then
			return false;
		endif;
		// Henry: preparing to execute action
		var string sPrepare = pxAttr^.GetValue("PrepareActionNames");
		if(!sPrepare.IsEmpty())then
			var array string asActions;
			sPrepare.Split(asActions, "\n", true);
			var int i, iC = asActions.NumEntries();
			for(i=0)cond(i<iC)iter(++i)do
				if(p_sTTName.Find(asActions[i])!=-1)then
					return false;
				endif;
			endfor;
		endif;
		// Henry: passed through every filter, hurray :)
		return true;
	endproc;
	
	export proc bool IsOkAndReadyForAction(string p_sTTName, CClntHndl p_xHandle)
		if(!p_xHandle.IsValid())then return false; endif;
		var ^CObj pxActor = p_xHandle.GetObj();
		if(pxActor==null)then return false; endif;
		var ^CAttribs pxAttr = pxActor^.GetAttribs();
		if(pxAttr==null)then return false; endif;
		// Henry: if having the ability itself
		var CTechTree xObjTT;
		var ^CTechTree.CNode pxOwnNode;
		xObjTT = pxActor^.GetTechTree();
		pxOwnNode = xObjTT.FindNode(p_sTTName);
		if(pxOwnNode==null)then return false; endif;
		// Henry: if action is visible and not disabled...
		if(!pxOwnNode^.IsVisible())then return false; endif;
		if(pxOwnNode^.GetSubValueI("visibility", 0)!=1)then return false; endif;
		if(pxOwnNode^.GetSubValueI("disabled", 0)==1)then return false; endif;
		var ^CTechTree.CNode pxLocations = pxOwnNode^.GetSub("locations");
		if(pxLocations != null)then
			var bool bFound = false;
			var int i, iC = pxLocations^.NumSubs();
			for(i=0)cond(i<iC)iter(++i)do
				var ^CTechTree.CNode pxLocation = pxLocations^.GetSub(i);
				if(pxLocation==null)then
					continue;
				endif;
				var string sVal = pxLocation^.GetValue();
				var int iPos = sVal.FindRev('/');
				if(iPos != -1)then
					sVal = sVal.Mid(iPos + 1);
					if(sVal==pxActor^.GetClassName()||pxActor^.GetType()==sVal)then
						var ^CTechTree.CNode pxLocalFlags=pxLocation^.GetSub("localflags");
						if(pxLocalFlags!=null)then
							var int j,iJC=pxLocalFlags^.NumSubs();
							for(j=0)cond(j<iJC)iter(j++)do
								var string sFlag=pxLocalFlags^.GetSub(j)^.GetName();
								if(pxLocalFlags^.GetSub(j)^.GetValueI()==1&&sFlag==pxAttr^.GetValue("ObjFlag"))then
									bFound = true;
									break;
								endif;
							endfor;
						else
							bFound = true;
							break;
						endif;
					endif;
				endif;
			endfor;
			if(!bFound)then return false; endif;
		endif;
		// Henry: having a cooldown of that ability
		var string sSpecial = pxAttr^.GetValue("SpecialActionNames");
		if(!sSpecial.IsEmpty())then
			var array string asActions;
			sSpecial.Split(asActions, "\n", true);
			var int i, iC = asActions.NumEntries();
			for(i=0)cond(i<iC)iter(++i)do
				if(p_sTTName.Find(asActions[i])!=-1)then
					return false;
				endif;
			endfor;
		endif;
		// Henry: have a local upgrade...
		var string sLocalUpgrade = pxAttr^.GetValue("LocalUpgrade");
		if(sLocalUpgrade.IsEmpty()== false && !IsMinorLocalUpgrade(sLocalUpgrade))then
			return false;
		endif;
		// Henry: preparing to execute action
		var string sPrepare = pxAttr^.GetValue("PrepareActionNames");
		if(!sPrepare.IsEmpty())then
			var array string asActions;
			sPrepare.Split(asActions, "\n", true);
			var int i, iC = asActions.NumEntries();
			for(i=0)cond(i<iC)iter(++i)do
				if(p_sTTName.Find(asActions[i])!=-1)then
					return false;
				endif;
			endfor;
		endif;
		// Henry: passed through every filter, hurray :)
		return true;
	endproc;
	
	export proc bool ChangeFocus()
		var bool bUpdate = false;
		var bool bKeep = true;
		if(InterListChange())then
			m_xSelection = CClientWrap.GetSelection();
			m_sFocusClass = "";
			m_sSpecialFocus = "";
			m_bFocusBldg = false;
			m_asClasses = 0;
			m_asValidNames = 0;
			bUpdate = true;
			bKeep = false;
		elseif(m_xSelection.NumEntries()<=0)then
			m_xSelection = CClientWrap.GetSelection();
			m_sFocusClass = "";
			m_sSpecialFocus = "";
			m_bFocusBldg = false;
			m_asClasses = 0;
			bUpdate = true;
			bKeep = false;
		elseif(!CClientWrap.GetSelection().IsEqual(m_xSelection))then
			m_xSelection = CClientWrap.GetSelection();
			var int i, iC = m_asClasses.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				if(!HaveObjOfClass(m_xSelection, m_asClasses[i]))then
					m_asClasses.DeleteEntry(i); i--; iC--;
				endif;
			endfor;
			if(m_asClasses.FindEntry(m_sFocusClass)==-1||m_sFocusClass=="")then
				bKeep = false;
			endif;
			bUpdate = true;
		endif;
		if(bUpdate)then
			var int i, iC = m_xSelection.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				var string sClass;
				if(!CMirageClnMgr.ValidateName(sClass, m_xSelection[i]))then continue; endif;
				m_asValidNames.AddEntry(sClass);
				if(m_asClasses.FindEntry(sClass)!=-1)then
					continue;
				else
					m_asClasses.AddEntry(sClass);
				endif;
			endfor;
			if(m_asClasses.NumEntries()>0 && !bKeep)then
				m_sFocusClass = m_asClasses[0];
				m_sSpecialFocus=GetSpecialFocus(m_sFocusClass);
			endif;
		endif;
		return true;
	endproc;
	
	export proc bool InterListChange()
		var int i, iC = m_xSelection.NumEntries();
		if(m_asValidNames.NumEntries()!=iC)then return true; endif;
		for(i=0)cond(i<iC)iter(i++)do
			var string sClass;
			if(!CMirageClnMgr.ValidateName(sClass, m_xSelection[i]))then return true; endif;
			if(m_asValidNames[i]!=sClass)then
				return true;
			endif;
		endfor;
		return false;
	endproc;
	
	export proc string GetFocusClass()
		return m_sFocusClass;
	endproc;
	
	export proc string GetSpecialFocus()
		return m_sSpecialFocus;
	endproc;
	
	export proc string GetFocusClass(ref string p_rsSpecial, ref bool p_rbBldg)
		p_rsSpecial=m_sSpecialFocus;
		p_rbBldg=m_bFocusBldg;
		return m_sFocusClass;
	endproc;
	
	export proc bool SetFocusFW()
		var bool bUpdate = ChangeFocus();
		//if(!bUpdate)then
			//return false;
		//endif;
		var int iNum = m_asClasses.NumEntries();
		if(iNum <= 0)then return false; endif;
		var int iPos = m_asClasses.FindEntry(m_sFocusClass);
		if(iPos==-1)then return false; endif;
		iPos++;
		if(iPos >= iNum)then
			iPos = 0;
		endif;
		m_sFocusClass = m_asClasses[iPos];
		var bool bPrev=m_bFocusBldg;
		var string sPrev=m_sSpecialFocus;
		m_sSpecialFocus=GetSpecialFocus(m_sFocusClass);
		var bool bRelevant=m_sSpecialFocus!=sPrev||m_bFocusBldg!=bPrev||m_bFocusBldg;
		if(CUIStateMgr.Get().GetInGameScreen()!=null)then
			CUIStateMgr.Get().GetInGameScreen()^.OnChangeFocus(bRelevant);
//			CUIStateMgr.Get().GetInGameScreen()^.OnChangeSelection();
		endif;
		return true;
	endproc;
	
	export proc bool SetFocusBW()
		var bool bUpdate = ChangeFocus();
		//if(!bUpdate)then
			//return false;
		//endif;
		var int iNum = m_asClasses.NumEntries();
		if(iNum <= 0)then return false; endif;
		var int iPos = m_asClasses.FindEntry(m_sFocusClass);
		if(iPos==-1)then return false; endif;
		iPos--;
		if(iPos < 0)then
			iPos = iNum - 1;
		endif;
		m_sFocusClass = m_asClasses[iPos];
		var bool bPrev=m_bFocusBldg;
		var string sPrev=m_sSpecialFocus;
		m_sSpecialFocus=GetSpecialFocus(m_sFocusClass);
		var bool bRelevant=m_sSpecialFocus!=sPrev||m_bFocusBldg!=bPrev||m_bFocusBldg;
		if(CUIStateMgr.Get().GetInGameScreen()!=null)then
			CUIStateMgr.Get().GetInGameScreen()^.OnChangeFocus(bRelevant);
//			CUIStateMgr.Get().GetInGameScreen()^.OnChangeSelection();
		endif;
		return true;
	endproc;
	
	proc string GetSpecialFocus(string p_sFocus)
		//Kr1s1m: TechtreeSteal is now always on. Foreign tribe active and passive specials always work.
		//Kr1s1m: Server setting still prevents placing foreign tribe buildings when TechtreeSteal is disabled.
		//if(!CheckTechtreeSteal())then
			//if(!p_sFocus.IsEmpty())then
				//m_bFocusBldg=m_asBuildings.FindEntry(p_sFocus)!=-1;
			//endif;
			//return m_sPlayerTribe;
		//endif;
		var string sSpecial;
		if(p_sFocus.IsEmpty())then return sSpecial; endif;
		if(p_sFocus.Left(4)=="aje_")then
			sSpecial="Aje";
		elseif(p_sFocus.Left(3)=="hu_")then
			sSpecial="Hu";
		elseif(p_sFocus.Left(7)=="ninigi_")then
			sSpecial="Ninigi";
		elseif(p_sFocus.Left(5)=="seas_")then
			sSpecial="SEAS";
		elseif(m_asCrashRPGChars.FindEntry(p_sFocus)!=-1)then
			sSpecial="World";
		elseif(m_asValidNPCs.FindEntry(p_sFocus)!=-1)then
			sSpecial=m_sPlayerTribe;
		endif;
		m_bFocusBldg=m_asBuildings.FindEntry(p_sFocus)!=-1;
		return sSpecial;
	endproc;
	
	export proc bool HaveObjOfClass(CObjList p_xList, string p_sClass)
		if(p_xList.NumEntries()<=0)then return false; endif;
		var int i, iC = p_xList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var string sClass;
			if(!CMirageClnMgr.ValidateName(sClass, p_xList[i]))then continue; endif;
			if(sClass==p_sClass)then
				return true;
			endif;
		endfor;
		return false;
	endproc;
	
	export proc CObjList GetFocusList(CObjList p_xList, bool p_bBldg)
		if(p_bBldg&&!m_bFocusBldg)then
			return p_xList;
		else
			return GetFocusList(p_xList);
		endif;
	endproc;
	
	export proc CObjList GetFocusList(CObjList p_xList)
//		if(true)then return p_xList; endif;
		//Henry: will later on continue...
		var bool bUpdate = ChangeFocus();
		if(m_sFocusClass=="")then return p_xList; endif;
		var CObjList xFilteredList;
		var int i,iC = p_xList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var string sClass;
			if(!CMirageClnMgr.ValidateName(sClass, p_xList[i]))then continue; endif;
			if(sClass==m_sFocusClass)then
				xFilteredList.AddEntry(p_xList[i]);
			endif;
		endfor;
		return xFilteredList;
	endproc;
	
	//Henry: thanks to AyCe
	export proc bool GetLevelInfo(^CLevelInfo p_pxInfo, ref string po_rsAuthor, ref string po_rsVersion)
		po_rsAuthor = "";
		po_rsVersion = "";
		var ^CPropDB.CNode pxBaseNode=^((p_pxInfo^.GetGenericData())["Base"]);
		if(pxBaseNode==null||pxBaseNode^.NumSubs()==0)then
			var ^CGameAttribs pxAttribs=^(p_pxInfo^.GetAttribs());
			po_rsAuthor = pxAttribs^.GetValue("Author");
			po_rsVersion = pxAttribs^.GetValue("Edit_Version");
		else
			po_rsAuthor = pxBaseNode^.GetValueS("Author","");
			po_rsVersion = pxBaseNode^.GetValueS("Edit_Version","");
		endif;
		return true;
	endproc;
	
	export proc bool GetServerIP(ref string p_rsIP)
//		var string sFile = CClientWrap.GetUrsRelPath() + "/Data/Base/Scripts/Game/misc/ip.txt";
		var string sFile = CSettings.GetAppTempDir() + "paraworld_ip.txt";
		if(!Filesystem.FileExists(sFile))then return false; endif;
		var Filesystem.CFile xFile;
		xFile.OpenRead(sFile);
		p_rsIP=xFile.GetLn();
		xFile.Close();
		return true;
	endproc;
	
	export proc void SetSequence(bool p_bPlaying)
		m_bIsPlayingSequence = p_bPlaying;
	endproc;
	
	export proc bool GetSequence()
		return m_bIsPlayingSequence;
	endproc;
	
	export proc void SetPaused(int p_iPlayer, bool p_bPaused)
		if(p_bPaused)then
			if(m_aiIsPaused.FindEntry(p_iPlayer)==-1)then
				m_aiIsPaused.AddEntry(p_iPlayer);
			endif;
		elseif(m_aiIsPaused.NumEntries()>0)then
			if(m_aiIsPaused.FindEntry(p_iPlayer)!=-1)then
				m_aiIsPaused.RemEntry(p_iPlayer);
			endif;
		endif;
	endproc;
	
	//export proc void PlayDieAck(int p_iIndexVoice, vec3 p_vPos)
	export proc void PlayDieAck(int p_iIndexVoice, int p_iIndexUI)
		if(m_bAbandon||m_bIsPlayingSequence||!m_abFeedbacks[FB_DEATH])then return; endif;
//		var CConfig xConf;
//		if(!xConf.GetSetB("Client/SoundFeedbacks/Death",true))then return; endif;
		if(m_pxDieAck==null||(p_iIndexVoice < 0 && p_iIndexUI < 0))then return; endif;
		var string sVoiceEvent, sUIEvent = "";
		var ^CPropDB.CNode pxVoiceEvent = ^(m_pxDieAck^.Get(p_iIndexVoice));
		if(pxVoiceEvent!=null)then
			sVoiceEvent = pxVoiceEvent^.Name();
		endif;
		if(p_iIndexUI > -1)then
			var ^CPropDB.CNode pxUIEvent = ^(m_pxDieAck^.Get(p_iIndexUI));
			if(pxUIEvent!=null)then
				sUIEvent = pxUIEvent^.Name();
			endif;
		endif;
//		if(sVoiceEvent != "")then
//			CGameInputController.ms_xUISoundMgr.InvokeFeedbackSoundEvent(sVoiceEvent,CSoundMgrCln.SOUND_VOLTRACK_SPEECH_ACK,-1);
//		else
//			CGameInputController.ms_xUISoundMgr.InvokeFeedbackSoundEvent(sUIEvent,CSoundMgrCln.SOUND_VOLTRACK_GLOBAL);
//		endif;
		if(sUIEvent != "")then
			CGameInputController.ms_xUISoundMgr.PlayFeedbackSoundEvent(sUIEvent,"",CSoundMgrCln.SOUND_VOLTRACK_GLOBAL);
		endif;
		if(sVoiceEvent != "")then
		//elseif(sVoiceEvent != "")then
			CGameInputController.ms_xUISoundMgr.PlayFeedbackSoundEvent(sVoiceEvent,"",CSoundMgrCln.SOUND_VOLTRACK_SPEECH_ACK);
		endif;
		//CGameWrap.GetSoundEventMgrClient().Play3DSound(sEvent,p_vPos);
		//endif;
	endproc;
	
	export proc void Abandon()
		m_bAbandon = true;
	endproc;
	
	export static proc string EffectName(int p_iIndex)
		var string sEffect = "";
		switch(p_iIndex)
			case(0)do sEffect = "CNiBigBert"; endcase;
			case(1)do sEffect = "CHitObjNiExpB"; endcase;
			case(2)do sEffect = "CHitObjSeExpB"; endcase;
			case(3)do sEffect = "CHitLanAshExpB"; endcase;
			case(4)do sEffect = "CMineExplo"; endcase;
			case(5)do sEffect = "CFxCraterB"; endcase;
			case(6)do sEffect = "CVehicleExplosion"; endcase;
			case(7)do sEffect = "CShadowCloneBanish"; endcase;
			case(8)do sEffect = "CHitObjAjExpB"; endcase;
			case(9)do sEffect = "CExploMineTrapSmall"; endcase;
			case(10)do sEffect = "CExploMineTrapBig"; endcase;
			case default do endcase;
		endswitch;
		return sEffect;
	endproc;
	
	export static proc int GetReactorActionNumber(^CAttribs p_pxAttr, ref int p_riProgress)
		if(p_pxAttr==null)then return 0; endif;
		var int iNum = 0;
		var string sQueue=p_pxAttr^.GetValue("ReactorProdQueue");
		if(!sQueue.IsEmpty())then
			var array string asToks;
			sQueue.Split(asToks, ":", true);
			iNum = asToks.NumEntries();
		endif;
		p_riProgress = p_pxAttr^.GetValueInt("ReactorCurProcess");
		return iNum;
	endproc;
	
	export static proc int GetReactorInfo(^CAttribs p_pxAttr, ref int p_riProgress, ref string p_rsCurObject, int p_iNodeUID)
		if(p_pxAttr==null)then return 0; endif;
		var int iNum = 0;
		var string sQueue=p_pxAttr^.GetValue("ReactorProdQueue");
		if(!sQueue.IsEmpty())then
			var array string asToks;
			sQueue.Split(asToks, ":", true);
			var int i, iC = asToks.NumEntries();
			for(i=0)cond(i<iC)iter(++i)do
				if(asToks[i].ToInt()==p_iNodeUID)then
					++iNum;
				endif;
			endfor;
		endif;
		p_riProgress = p_pxAttr^.GetValueInt("ReactorCurProcess");
		p_rsCurObject = p_pxAttr^.GetValue("ReactorCurProcessObj");
		return iNum;
	endproc;
	
	export static proc void JoinStringArrays(ref array string po_rasA,ref array string p_rasB)
		var int i,iC=p_rasB.NumEntries(),iA=po_rasA.NumEntries();
		po_rasA+=iC;
		for(i=0) cond(i<iC) iter(i++) do
			po_rasA[iA+i]=p_rasB[i];
		endfor;
	endproc;
	
	export static proc void JoinStringArrays(ref array string po_rasA,ref array string p_rasB, ref int p_riIndex)
		var int i,iC=p_rasB.NumEntries(),iA=p_riIndex=po_rasA.NumEntries();
		po_rasA+=iC;
		for(i=0) cond(i<iC) iter(i++) do
			po_rasA[iA+i]=p_rasB[i];
		endfor;
	endproc;
	
	export proc CClntHndl GetGPCE()
		if(!CMirageClnMgr.ms_xGPCE.IsValid())then
			var CClntHndl xInv;
			var ^CPlayer pxPlayer = ^(CGameWrap.GetClient().GetPlayer());
			if(pxPlayer==null)then return xInv; endif;
			m_sPlayerTribe=pxPlayer^.GetPlayerSlot()^.GetTribe();
			var ^CAttribs pxAttribs = pxPlayer^.GetAttribs();
			if(pxAttribs==null)then return xInv; endif;
			var string sGuid = pxAttribs^.GetValue("gpce_own");
			if(sGuid.IsEmpty())then return xInv; endif;
			var CGuid xG;
			xG.FromString(sGuid);
			var ^CObj pxGPCE = CClientWrap.GetObjMgr().GetObj(xG);
			if(pxGPCE==null)then return xInv; endif;
			CMirageClnMgr.ms_xGPCE = pxGPCE^.GetHandle();
		endif;
		return CMirageClnMgr.ms_xGPCE;
	endproc;
	
	class CPropDBSorter
	
		export var string m_sName;
		export var string m_sValue1;
		export var string m_sValue2;
	
		export proc bool op_Equal(ref CMirageClnMgr.CPropDBSorter p_rxOther)
			return (m_sValue1==p_rxOther.m_sValue1);
		endproc;
	
		export proc bool op_Greater(ref CMirageClnMgr.CPropDBSorter p_rxOther)
			return m_sValue1>p_rxOther.m_sValue1;
		endproc;
	
	endclass;
	
	export static proc void SortPropDBHotkey()
		var array CMirageClnMgr.CPropDBSorter axSortArray;
		var ^CPropDB pxOriginal = new CPropDB, pxNew = new CPropDB;
//		if(pxOriginal^.Load(CClientWrap.GetUrsRelPath()+"/Data/Base/Scripts/Server/settings/unsorted_hotkeys.txt"))then
		if(pxOriginal^.Load("C:/unsorted_hotkeys.txt"))then
			var ^CPropDB.CNode pxRoot = ^(pxOriginal^.GetRoot());
			var int i, iC = pxRoot^.NumSubs();
			for(i=0)cond(i<iC)iter(i++)do
				var ^CPropDB.CNode pxOld=^(pxRoot^.Get(i));
				if(pxOld!=null)then
					var string sV1=pxOld^.GetValueS("Action",""), sV2=pxOld^.GetValueS("Shortcut","");
					if(sV1.IsEmpty()||sV2.IsEmpty())then CMirageClnMgr.Debug("a value or more empty"); continue; endif;
					var CMirageClnMgr.CPropDBSorter xTemp;
					xTemp.m_sValue1=sV1;
					var int iIdx=axSortArray.FindEntry(xTemp);
					if(iIdx==-1)then
						var ^CMirageClnMgr.CPropDBSorter pxSorter=^(axSortArray.NewEntryRef());
						pxSorter^.m_sValue1=sV1;
						pxSorter^.m_sValue2=sV2;
					endif;
				endif;
			endfor;
//			axSortArray.QSort();
			iC=axSortArray.NumEntries();
			if(iC>0)then
				var ^CPropDB.CNode pxNewRoot = ^(pxNew^.GetRoot());
				for(i=0)cond(i<iC)iter(i++)do
					var string sBase="";
					if(i<10)then
						sBase="00";
					elseif(i<100)then
						sBase="0";
					endif;
					var string sName="ActionMenu_"+sBase+i.ToString();
					var ^CPropDB.CNode pxNode=pxNewRoot^.FindNode(sName,true);
					if(pxNode!=null)then
						pxNode^.AddValue("Action",axSortArray[i].m_sValue1);
						pxNode^.AddValue("Shortcut",axSortArray[i].m_sValue2);
					endif;
				endfor;
				pxNew^.Save("C:/sorted_hotkeys.txt");
			endif;
		endif;
	endproc;
	
	export static proc void ShortcutMaker()
		var int iIdx=0;
		var array string asTribes;
//		asTribes.AddEntry("Aje");
//		asTribes.AddEntry("Hu");
//		asTribes.AddEntry("Ninigi");
//		asTribes.AddEntry("SEAS");
//		asTribes.AddEntry("Special");
		asTribes.AddEntry("World");
		var ^CPropDB pxOriginal = new CPropDB, pxNew = new CPropDB;
		if(pxOriginal^.Load(CClientWrap.GetUrsRelPath()+"/Data/Base/Scripts/Server/settings/new_sc_source.txt"))then
			var ^CPropDB.CNode pxRoot = ^(pxOriginal^.GetRoot());
			var ^CPropDB.CNode pxNewRoot = ^(pxNew^.GetRoot());
			if(pxRoot==null)then return; endif;
			var ^CPropDB.CNode pxActions = ^(pxRoot^.FindNode("StartTT/Actions",false));
			if(pxActions==null)then return; endif;
			var int i, iC = pxActions^.NumSubs();
			for(i=0)cond(i<iC)iter(i++)do
				var ^CPropDB.CNode pxTribe=^(pxActions^.Get(i));
				if(pxTribe!=null)then
					if(asTribes.FindEntry(pxTribe^.Name())==-1)then continue; endif;
					var int j, iJ = pxTribe^.NumSubs();
					for(j=0)cond(j<iJ)iter(j++)do
						var ^CPropDB.CNode pxSection=^(pxTribe^.Get(j));
						if(pxSection!=null)then
							var int k, iK = pxSection^.NumSubs();
							for(k=0)cond(k<iK)iter(k++)do
								var ^CPropDB.CNode pxType=^(pxSection^.Get(k));
								if(pxType!=null)then
									var int m, iM = pxType^.NumSubs();
									for(m=0)cond(m<iM)iter(m++)do
										var ^CPropDB.CNode pxNode=^(pxType^.Get(m));
										if(pxNode!=null)then
											var string sName=pxNode^.Name();
											var string sCode=pxNode^.GetValueS("code","");
											if(sCode!=""&&pxNode^.Find("code")!=-1)then
//												sCode.Replace("xxxxx",sName);
//												pxNode^.SetValue("code",sCode);
												var string sBase="";
												if(iIdx<10)then
													sBase="00";
												elseif(iIdx<100)then
													sBase="0";
												endif;
												var string sHotkey="ActionMenu_"+sBase+iIdx.ToString();
												var ^CPropDB.CNode pxNewNode=pxNewRoot^.FindNode(sHotkey,true);
												if(pxNewNode!=null)then
													pxNewNode^.AddValue("Action",sCode);
													pxNewNode^.AddValue("Shortcut","XYZ");
													iIdx++;
												endif;
											endif;
										endif;
									endfor;
								endif;
							endfor;
						endif;
					endfor;
				endif;
			endfor;
			pxNew^.Save("C:/new_hotkeys.txt");
		endif;
	endproc;
	
	export static proc bool AllowMap(^CMapInfoList.CMapInfo p_pxMapInfo, int p_iPlayers)
		return true;
//		if(p_pxMapInfo==null)then return false; endif;
//		if(p_pxMapInfo^.GetMapName()!="_CU_MP_6_CRASH_RPG")then return true; endif;
//		return p_iPlayers>=3;
//		var ^CLevelInfo pxLevelInfo = ^(p_pxMapInfo^.GetLevelInfo());
//		if(pxLevelInfo==null)then return false; endif;
//		var int iMinPlayers = (pxCLInfo^.GetGenericData())["ClientSettings"].GetValueI("MinPlayers",1);
//		return p_iPlayers>=iMinPlayers;
	endproc;
	
	export static proc void SetSDK(int p_iState)
		CMirageClnMgr.ms_iSDK=p_iState;
	endproc;
	
	export static proc void StartSDK()
		StartSDK("",true,true);
	endproc;
	
	export static proc void StartSDK(string p_sFile, bool p_bSkipDump, bool p_bStart)
		CClientWrap.SwitchClientShell();
		if(!p_bSkipDump)then
			Debug("");
			Debug("height: "+CClientWrap.GetScapeMgr().GetMapHeight().ToString()+" | width: "+CClientWrap.GetScapeMgr().GetMapWidth().ToString());
			var string sSetting;
			var bitset dwSetting=CClientWrap.GetScapeMgr().GetTerrainSetting();
			if(dwSetting==0000b)then
				sSetting = "Northland";
			elseif(dwSetting==0001b)then
				sSetting = "Savanna";
			elseif(dwSetting==0010b)then
				sSetting = "Jungle";
			elseif(dwSetting==0011b)then
				sSetting = "Icewaste";
			elseif(dwSetting==0100b)then
				sSetting = "Ashvalley";
			elseif(dwSetting==0101b)then
				sSetting = "Test";
			elseif(dwSetting==0110b)then
				sSetting = "Cave1";
			elseif(dwSetting==0111b)then
				sSetting = "Cave2";
			elseif(dwSetting==01000b)then
				sSetting = "Cave3";
			else
				sSetting="unknown: "+CClientWrap.GetScapeMgr().GetTerrainSetting().ToString();
			endif;
			Debug("levelsetting is: "+sSetting);
			Debug("");
		endif;
		var bool bMakeRegionDB=p_sFile!="";
		var ^CRegionMgrClient pxRM=CClientWrap.GetRegionMgr();
		if(pxRM!=null)then
			var int i,iC=pxRM^.NumRegions();
			if(!p_bSkipDump)then
				for(i=0)cond(i<iC)iter(i++)do
					var ^CRegionBase pxRB=pxRM^.GetRegion(i);
					Debug(i.ToString()+"'s region name is: "+pxRB^.GetName()+" | guid is: "+pxRB^.GetGUID().ToString());
				endfor;
			endif;
			if(bMakeRegionDB)then
				var ^CPropDB pxRegions = new CPropDB;
				var ^CPropDB.CNode pxRoot = ^(pxRegions^.GetRoot());
				for(i=0)cond(i<iC)iter(i++)do
					var ^CRegionBase pxRB=pxRM^.GetRegion(i);
					var string sName="region_"+i.ToString();
					var ^CPropDB.CNode pxNode=^(pxRoot^.AddValue(sName,pxRB^.GetGUID().ToString()));
					if(pxNode!=null)then
						pxNode^.AddValue("name",pxRB^.GetName().ToString());
						pxNode^.AddValue("description",pxRB^.GetDescription());
						pxNode^.AddValue("color",pxRB^.GetColor().ToString());
						pxNode^.AddValue("enabled",pxRB^.GetEnable().ToString());
						pxNode^.AddValue("numsubs",pxRB^.NumSubs().ToString());
						pxNode^.AddValue("guid",pxRB^.GetGUID().ToString());
					endif;
				endfor;
				pxRegions^.Save("C:/"+p_sFile+"_region_source.txt");
			endif;
		endif;
		if(!p_bStart)then return; endif;
		if(Windows.MessageBox("Trying to start SDK internally","Do you want to continue for sure?",050004h)==6)then
			CEvt_AbandonGame.Send();
			CGameWrap.StartLevelEditor();
			CUIStateMgr.Get().SetState(CUIStateMgr.STATE_INGAME);
		endif;
	endproc;
	
	export static proc void JumpToObj(string p_sName)
		var ^CObj pxObj=CClientWrap.GetObjMgr().FindObjByName(p_sName);
		if(pxObj!=null)then
			var vec3 vPos=pxObj^.GetPos();
			CMultiCameraController.Get().SetCameraTarget(vPos,true);
			CMultiCameraController.Get().SnapOnGround();
		endif;
	endproc;
	
	export static proc void JumpToPos(string p_sPos)
		var vec3 vPos;
		vPos.FromString(p_sPos);
		CMultiCameraController.Get().SetCameraTarget(vPos,true);
		CMultiCameraController.Get().SnapOnGround();
	endproc;
	
	export proc string GetPlayerName(int p_iID)
		if(p_iID==-1)then return CLocalizer.Get().Translate("_MIRAGE_UI_World"); endif;
		if(p_iID<0||p_iID>7)then return ""; endif;
		return m_asPlayerNames[p_iID];
	endproc;
	
	export proc void SetPlayerName(int p_iID, string p_sName)
		if(p_iID<0||p_iID>7)then return; endif;
		m_asPlayerNames[p_iID]=p_sName;
	endproc;
	
	export proc bool IsDead(int p_iID, int p_iOwn)
		if(p_iID<0||p_iID>7)then return false; endif;
		return m_aiCasualties[p_iID]==1||m_aiCasualties[p_iOwn]==1;
	endproc;
	
	export proc void SetDead(int p_iID)
		if(p_iID<0||p_iID>7)then return; endif;
		m_aiCasualties[p_iID]=1;
	endproc;
	/*
	export static proc void CreateObjectDB()
		var int iIdx=0;
		var ^CPropDB pxOriginal = new CPropDB, pxOld = new CPropDB, pxNew = new CPropDB;
		if(!pxOld^.Load(CClientWrap.GetUrsRelPath()+"/Data/Base/Scripts/Server/settings/Techtree/_AI_ObjectData.txt"))then return; endif;
		if(pxOriginal^.Load("C:/objects.txt"))then
			var ^CPropDB.CNode pxRoot = ^(pxOriginal^.GetRoot());
			var ^CPropDB.CNode pxOldRoot = ^(pxOld^.GetRoot());
			var ^CPropDB.CNode pxNewRoot = ^(pxNew^.GetRoot());
			var ^CPropDB.CNode pxWork = ^(pxNewRoot^.FindNode("Objects",true));
			if(pxRoot==null)then return; endif;
			var ^CPropDB.CNode pxObjects = ^(pxRoot^.FindNode("Objects",false));
			if(pxObjects==null)then return; endif;
			var ^CPropDB.CNode pxOldNode = ^(pxOldRoot^.FindNode("Objects",false));
			if(pxOldNode==null)then return; endif;
			var int i, iC = pxObjects^.NumSubs();
			for(i=0)cond(i<iC)iter(i++)do
				var ^CPropDB.CNode pxTribe=^(pxObjects^.Get(i));
				if(pxTribe!=null)then
					var string sTribe=pxTribe^.Name();
					var int j, iJ = pxTribe^.NumSubs();
					for(j=0)cond(j<iJ)iter(j++)do
						var ^CPropDB.CNode pxType=^(pxTribe^.Get(j));
						if(pxType!=null)then
							var string sType=pxType^.Name();
							var int k, iK = pxType^.NumSubs();
							for(k=0)cond(k<iK)iter(k++)do
								var ^CPropDB.CNode pxClass=^(pxType^.Get(k));
								if(pxClass!=null)then
									var string sClassName=pxClass^.Name();
									if(pxWork^.Find(sClassName)==-1)then
										var ^CPropDB.CNode pxNewClass = ^(pxWork^.FindNode(sClassName,true));
										var string sDescription=pxClass^.GetValueS("description","");
										var string sTemp=sDescription;
										if(sTemp!="" && sTemp.GetAt(0)=='_')then
											sTemp.Delete(0);
										endif;
										if(sTemp!=sClassName)then
											CMirageClnMgr.Debug("problem at: "+sClassName);
											CMirageClnMgr.Debug("");
										endif;
										var int iSkulls=pxClass^.GetValueI("scalps",0);
										pxNewClass^.AddValue("FourCC",sType);
										pxNewClass^.AddValue("Tribe",sTribe);
										pxNewClass^.AddValue("Description",sDescription);
										var string sTTTitle, sTTText;
										sTTText=CClientWrap.GetUIMgr().GetToopTipText(sDescription, sTTTitle);
										var string sVsChtr=FilterAttrib(sTTText,"vschtr");
										var string sVsAnml=FilterAttrib(sTTText,"vsanml");
										var string sVsVhcl=FilterAttrib(sTTText,"vsvhcl");
										var string sVsShip=FilterAttrib(sTTText,"vsship");
										var string sVsBldg=FilterAttrib(sTTText,"vsbldg");
										if((sVsAnml+sVsChtr+sVsBldg+sVsVhcl+sVsShip).GetLength()>0)then
											pxNewClass^.AddValue("ExtractedBoniFromHelp",1);
											pxNewClass^.AddValue("Boni_CHTR",sVsChtr);
											pxNewClass^.AddValue("Boni_ANML",sVsAnml);
											pxNewClass^.AddValue("Boni_VHCL",sVsVhcl);
											pxNewClass^.AddValue("Boni_SHIP",sVsShip);
											pxNewClass^.AddValue("Boni_BLDG",sVsBldg);
										else
											pxNewClass^.AddValue("ExtractedBoniFromHelp",0);
											pxNewClass^.AddValue("Boni_CHTR",0);
											pxNewClass^.AddValue("Boni_ANML",0);
											pxNewClass^.AddValue("Boni_VHCL",0);
											pxNewClass^.AddValue("Boni_SHIP",0);
											pxNewClass^.AddValue("Boni_BLDG",0);
										endif;
										pxNewClass^.AddValue("Skulls_Lvl0",iSkulls.ToString()+".000000");
										if(sTribe=="Special")then
											pxNewClass^.AddValue("Skulls_Lvl1",(iSkulls+25).ToString()+".000000");
											pxNewClass^.AddValue("Skulls_Lvl2",(iSkulls+50).ToString()+".000000");
											pxNewClass^.AddValue("Skulls_Lvl3",(iSkulls+75).ToString()+".000000");
											pxNewClass^.AddValue("Skulls_Lvl4",(iSkulls+125).ToString()+".000000");
										elseif(sType=="NEST")then
											pxNewClass^.AddValue("Skulls_Lvl1",iSkulls.ToString()+".000000");
											pxNewClass^.AddValue("Skulls_Lvl2",iSkulls.ToString()+".000000");
											pxNewClass^.AddValue("Skulls_Lvl3",iSkulls.ToString()+".000000");
											pxNewClass^.AddValue("Skulls_Lvl4",iSkulls.ToString()+".000000");
										else
											pxNewClass^.AddValue("Skulls_Lvl1",(iSkulls+5).ToString()+".000000");
											pxNewClass^.AddValue("Skulls_Lvl2",(iSkulls+15).ToString()+".000000");
											pxNewClass^.AddValue("Skulls_Lvl3",(iSkulls+25).ToString()+".000000");
											pxNewClass^.AddValue("Skulls_Lvl4",(iSkulls+45).ToString()+".000000");
										endif;
										var ^CPropDB.CNode pxOldClass = ^(pxOldNode^.FindNode(sClassName,false));
										if(pxOldClass!=null)then
											var string sThreat=pxOldClass^.GetValueS("Threat","");
											if(sThreat!="")then
												pxNewClass^.AddValue("Threat",sThreat);
											endif;
											var string sThread=pxOldClass^.GetValueS("Thread","");
											if(sThread!="")then
												pxNewClass^.AddValue("Thread",sThread);
											endif;
										endif;
									endif;
								endif;
							endfor;
						endif;
					endfor;
				endif;
			endfor;
			pxNew^.Save("C:/New_AI_ObjectData.txt");
		endif;
	endproc;
	*/
	static proc string FilterAttrib(string p_sText, string p_sAttrib)
		var string sSearch="/"+p_sAttrib+":";
		var int iPos=p_sText.Find(sSearch);
		if(iPos==-1)then
			return "";
		endif;
		iPos+=sSearch.GetLength();
		var int iEnd=iPos;
		while((iEnd<p_sText.GetLength())&&((p_sText.GetAt(iEnd)!='%')||(p_sText.GetAt(iEnd+1)=='%'))&&(p_sText.GetAt(iEnd)!='/'))do
			iEnd++;
		endwhile
		var string sRes=p_sText.Mid(iPos,iEnd-iPos);
		if(sRes=="++")then
			sRes="2";
		elseif(sRes=="+")then
			sRes="1";
		elseif(sRes=="--")then
			sRes="-2";
		elseif(sRes=="-")then
			sRes="-1";
		endif;
		return sRes;
	endproc;
	
	export static proc string GetMapName(^CLevelInfo p_pxLevelInfo)
		var string sName = "";
		var ^CPropDB.CNode pxBaseNode=^((p_pxLevelInfo^.GetGenericData())["Base"]);
		if(pxBaseNode!=null)then
			sName=pxBaseNode^.GetValueS("LevelName");
		endif;
		return sName;
	endproc;

	export static proc void DumpMapInfo(^CMapInfoList.CMapInfo p_pxMapInfo)
		Debug("", false);
		CMirageClnMgr.Debug("File name: '"+p_pxMapInfo^.GetFile()+"'", false);
		var string sMapName=p_pxMapInfo^.GetMapName();
		var string sDescription=p_pxMapInfo^.GetDescription();
		CMirageClnMgr.Debug("Map name: '"+sMapName+"'", false);
		if(sMapName.Left(1)=="_")then
			CMirageClnMgr.Debug("Name's translation: '"+CLocalizer.Get().Translate(sMapName)+"'", false);
		endif;
		CMirageClnMgr.Debug("Description: '"+sDescription+"'", false);
		if(sDescription.Left(1)=="_")then
			CMirageClnMgr.Debug("Description's translation: '"+CLocalizer.Get().Translate(sDescription)+"'", false);
		endif;
//		CMirageClnMgr.Debug("Map type: '"+p_pxMapInfo^.GetMapType()+"'", false);
		CMirageClnMgr.Debug("Game type: '"+p_pxMapInfo^.GetGameType()+"'", false);
		CMirageClnMgr.Debug("Max players: '"+(p_pxMapInfo^.GetMaxPlayers()).ToString()+"'", false);
		var ^CLevelInfo pxLevelInfo=^(p_pxMapInfo^.GetLevelInfo());
		if(pxLevelInfo!=null)then
			CMirageClnMgr.Debug("Level setting: '"+pxLevelInfo^.GetLevelSetting()+"'", false);
			CMirageClnMgr.Debug("Checksum: '"+pxLevelInfo^.GetLevelCheckSumme()+"'", false);
			var int iW, iH;
			pxLevelInfo^.GetMapSize(iW,iH);
			CMirageClnMgr.Debug("Width: '"+(iW).ToString()+"'", false);
			CMirageClnMgr.Debug("Height: '"+(iH).ToString()+"'", false);
			var ^CPropDB pxGD=^(pxLevelInfo^.GetGenericData());
			if(pxGD!=null)then
				var string sAuthor, sVersion;
				CMirageClnMgr.Get().GetLevelInfo(pxLevelInfo, sAuthor, sVersion);
				CMirageClnMgr.Debug("Author: '"+sAuthor+"'", false);
				CMirageClnMgr.Debug("Version: '"+sVersion+"'", false);
				var int i, iC=p_pxMapInfo^.GetMaxPlayers();
				for(i=0)cond(i<iC)iter(i++)do
					var ^CPropDB.CNode pxPSN = pxGD^.FindNode("PlayerSettings/Player_"+i.ToString(),false);
					if(pxPSN!=null)then
						var string sTribes = (pxLevelInfo^.GetGenericData())["PlayerSettings/Player_"+i.ToString()+"/Restrictions/Base/Tribes"].Value();
						CMirageClnMgr.Debug((i+1).ToString()+". HQ's tribes: '"+sTribes+"'", false);
					endif;
				endfor;
			endif;
		endif;
		Debug("", false);
	endproc;
	
	export static proc bool Debug(string p_sText)
		return Debug(p_sText,true);
	endproc;
	
	export static proc bool Debug(string p_sText, bool p_bTime)
		var string sFile="client_log.txt";
		if(!Filesystem.FileExists(sFile))then return false; endif;
		var Filesystem.CFile xFile;
		xFile.OpenAppend(sFile);
		var string sPrefix;
		if(p_bTime)then
			sPrefix=CTime.CurrentTime().ToString()+": ";
		endif;
		xFile.PrintLn(sPrefix+p_sText);
		xFile.Close();
		return true;
	endproc;
	
endclass;

//		CMirageClnMgr.SortPropDBHotkey();
//		unsorted_hotkeys.txt
//		CMirageClnMgr.TTEdit();
//		CMirageClnMgr.TTGetData();
//		CMirageClnMgr.TTFilterMaker();
//		CMirageClnMgr.CreateObjectDB();
//		.MakeUpper();
//		.MakeLower();