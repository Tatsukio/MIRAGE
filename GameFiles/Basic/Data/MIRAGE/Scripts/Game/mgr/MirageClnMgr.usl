//	CMirageClnMgr.
//	CMirageClnMgr.Debug("");
//	CMirageClnMgr.Debug("xxxx: '"+xxxx+"'");
//	CMirageClnMgr.Debug("xxxx: '"+(xxxxxx).ToString()+"'");
//	CMirageClnMgr.Get().
//	CMirageSDKMgr.Debug("");

class CMirageClnMgr

	export const string VERSION = "2.6.7";
//	export const string BUILD = "";
	export const string BUILD = " build 15";
	export const string UPDATE = "20";
	export const string URL = "http://www.para-welt.com/mirage/?version=";
	export const string ALL4ONE = "Hu:Aje:Ninigi:SEAS:";
	export const string MODNAME = "MIRAGE";
	export const int EPOCH6 = 19881014;
	static var ^CMirageClnMgr ms_pxMgrClnInstance;
	var bool m_bIsSupplyOn;
	var bool m_bSupChecked;
	var bool m_bResLimitChecked;
	var bool m_bResUnlimited;
	var bool m_bManaEnabledChecked;
	export var bool m_bManaEnabled;
	var bool m_bPhantomModeChecked;
	var bool m_bPhantomMode;
	var bool m_bGameTimeChecked;
	var int m_iGameTime;
	var bool m_bDiploLockedChecked;
	var bool m_bDiploLocked;
	var bool m_bDwnLvlSwitchChecked;
	var int m_iDwnLvlSwitch;
	var bool m_bMaxEpochChecked;
	var int m_iMaxEpoch;
	var bool m_bBldgMaxCapacityChecked;
	var bool m_bBldgMaxCapacity;
	var bool m_bTechtreeStealChecked;
	var bool m_bTechtreeSteal;
	var bool m_bAllyBuildupChecked;
	var bool m_bAllyBuildup;
	var bool m_bAlienCommandsChecked;
	var bool m_bAlienCommands;
	var bool m_bIsPlayingSequence;
	var bool m_bAbandon;
	var bool m_bBloodAndGore;
	var bool m_bACHidden;
	var array int m_aiIsPaused;
	var CMapInfoList	m_xCampaignMapList;
	var CMapInfoList	m_xSaveMapList;
	var ^CPropDB.CNode m_pxSupply;
	var ^CPropDB.CNode m_pxCommands;
	var ^CPropDB.CNode m_pxDieAck;
	//Kr1s1m: ====DBs to retrieve and apply custom map mirage and level settings====================
	var ^CPropDB.CNode m_pxCustomMapMirageSettingsDB;
	var ^CPropDB.CNode m_pxCustomMapSettingsDB;
	//============DBs to backup, restore, persist mirage and level settings in User Profile=========
	var ^CPropDB m_pxMirageSettingsBackupDB;
	var ^CPropDB m_pxLevelSettingsBackupDB;
	//==============================================================================================
	var string 					m_sSettingsBackupPath;
	var string					m_sSettingsBackupTemplatePath;
	var array string			m_asClasses;
	var array string			m_asValidNames;
	var string						m_sPlayerTribe;
	var string						m_sFocusClass;
	var string						m_sSpecialFocus;
	var bool							m_bFocusBldg;
	export var CObjList		m_xSelection;
	var array string			m_asMinorLocalUpgrades;
	var array string			m_asCancableActions;
	var array string			m_asNoToDisable;
	static var CClntHndl	ms_xGPCE;
	var array bool				m_abFeedbacks;
	var array string			m_asValidNPCs;
	var array string			m_asBuildings;
	var array string			m_asCrashRPGChars;
	var array string			m_asPlayerNames;
	var array int					m_aiCasualties;
	const int FEEDBACK_TYPES = 16;
	export static var int ms_iSDK;
	
	export const int FB_ATTACKS=0;
	export const int FB_BUILDINGS=1;
	export const int FB_IMPROVEMENT=2;
	export const int FB_MAPPING=3;
	export const int FB_FULLSTORAGE=4;
	export const int FB_DEFICIT=5;
	export const int FB_POPULATION=6;
	export const int FB_EPOCHDONE=7;
	export const int FB_EPOCHSTART=8;
	export const int FB_DIMENSION=9;
	export const int FB_MULTIPLAYER=10;
	export const int FB_QUEST=11;
	export const int FB_DEATH=12;
	export const int FB_TREASURES=13;
	export const int FB_ENDSCREEN=14;
	export const int FB_ECONOMY=15;
	
	export static proc ref CMirageClnMgr Get()
		if(ms_pxMgrClnInstance==null)then
			ms_pxMgrClnInstance=new CMirageClnMgr();
		endif;
		return ms_pxMgrClnInstance^;
	endproc;
	
	export static proc void ShutStatic()
		delete ms_pxMgrClnInstance;
	endproc;
	
	export static proc void Kill()
		if(ms_pxMgrClnInstance!=null)then
			delete ms_pxMgrClnInstance;
			ms_pxMgrClnInstance=null;
		endif;
	endproc;
	
	export proc bool Purify()
		CMirageClnMgr.ms_xGPCE.Invalidate();
		m_bSupChecked = false;
		m_bIsSupplyOn = false;
		m_bResLimitChecked = false;
		m_bResUnlimited = false;
		m_bManaEnabledChecked = false;
		m_bManaEnabled = false;
		m_bPhantomModeChecked = false;
		m_bPhantomMode = false;
		m_iGameTime = 0;
		m_bGameTimeChecked = false;
		m_bDiploLockedChecked = false;
		m_bIsPlayingSequence = false;
		m_bDwnLvlSwitchChecked = false;
		m_bMaxEpochChecked = false;
		m_bBldgMaxCapacityChecked = false;
		m_bTechtreeStealChecked = false;
		m_bAllyBuildupChecked = false;
		m_bAlienCommandsChecked = false;
		m_bIsPlayingSequence = false;
		m_bAbandon = false;
		m_aiIsPaused = 0;
		m_xSelection.Clear();
		m_sPlayerTribe = "";
		m_sFocusClass = "";
		m_sSpecialFocus = "";
		m_bFocusBldg = false;
		m_asClasses = 0;
		m_asValidNames = 0;
//		m_asPlayerNames = 0;
//		m_asPlayerNames = 8;
		m_aiCasualties = 0;
		m_aiCasualties = 8;
		return true;
	endproc;
	
	constructor()
		CMirageClnMgr.ms_iSDK=0;
		var ^CPropDB pxSupplies = new CPropDB;
		pxSupplies^.Load(CClientWrap.GetUrsRelPath() + "/Data/Base/Scripts/Server/settings/unit_supplies.txt");
		m_pxSupply = ^((pxSupplies^).GetRoot());
		var ^CPropDB pxDieAck = new CPropDB;
		if(pxDieAck^.Load(CClientWrap.GetUrsRelPath() + "/Data/Base/Scripts/Server/settings/die_acks.txt"))then
			m_pxDieAck = ^((pxDieAck^).GetRoot());
		else
			m_pxDieAck = null;
		endif;
		
		//Kr1s1m: Custom map mirage settings DB init
		var ^CPropDB pxCustomMapMirageSettingsDB = new CPropDB();
		if(pxCustomMapMirageSettingsDB^.Load(CClientWrap.GetUrsRelPath()+"/Data/Base/Scripts/Game/misc/CustomMapMirageSettings.txt"))then
			m_pxCustomMapMirageSettingsDB = ^((pxCustomMapMirageSettingsDB^).GetRoot());
		else
			m_pxCustomMapMirageSettingsDB = null;
		endif;
		
		//Kr1s1m: Custom map level settings DB init
		var ^CPropDB pxCustomMapSettingsDB = new CPropDB();
		if(pxCustomMapSettingsDB^.Load(CClientWrap.GetUrsRelPath()+"/Data/Base/Scripts/Game/misc/CustomMapSettings.txt"))then
			m_pxCustomMapSettingsDB = ^((pxCustomMapSettingsDB^).GetRoot());
		else
			m_pxCustomMapSettingsDB = null;
		endif;
		
		m_sSettingsBackupTemplatePath=CClientWrap.GetUrsRelPath()+"/Data/MIRAGE/Scripts/Game/misc";
		m_sSettingsBackupPath=CSettings.GetUserSettingsDir();
		m_sSettingsBackupPath+=CMirageClnMgr.MODNAME+"_"+(CMirageClnMgr.VERSION).ToString()+"_Settings_backup";
		if(!Filesystem.DirExists(m_sSettingsBackupPath))then
			Filesystem.MkDir(m_sSettingsBackupPath);
			//KLog.LogSpam("Kr1s1m",  "=========> Mirage/Level settings backup path created. <=========");
		endif;
		
		//Kr1s1m: Mirage settings backup DB init
		m_pxMirageSettingsBackupDB = new CPropDB();
		//Kr1s1m: Attempt to load mirage settings backup db from user settings in Roaming folder...
		if(m_pxMirageSettingsBackupDB^.Load(m_sSettingsBackupPath+"/mirage_settings_backup.txt"))then
			//KLog.LogSpam("Kr1s1m",  "-------------> mirage settings backup db ready <--------------");
		//Kr1s1m: ...and if that fails attempt loading from the db template inside MIRAGE/Scripts/Game/misc
		elseif(m_pxMirageSettingsBackupDB^.Load(m_sSettingsBackupTemplatePath+"/MirageSettingsBackup.txt"))then
			//KLog.LogSpam("Kr1s1m",  "----------> mirage settings backup template loaded <----------");
		else//Kr1s1m: The two loading attempts have failed, so set the value to null to signal that.
			m_pxMirageSettingsBackupDB = null;
		endif;
		
		//Kr1s1m: Level settings backup DB init
		m_pxLevelSettingsBackupDB = new CPropDB();
		if(m_pxLevelSettingsBackupDB^.Load(m_sSettingsBackupPath+"/level_settings_backup.txt"))then
			//KLog.LogSpam("Kr1s1m",  "-------------> level settings backup db ready <--------------");
		elseif(m_pxLevelSettingsBackupDB^.Load(m_sSettingsBackupTemplatePath+"/LevelSettingsBackup.txt"))then
			//KLog.LogSpam("Kr1s1m",  "----------> level settings backup template loaded <----------");
		else
			m_pxLevelSettingsBackupDB = null;
		endif;
		
		m_abFeedbacks=FEEDBACK_TYPES;
		m_bSupChecked = false;
		m_bResLimitChecked = false;
		m_bManaEnabledChecked = false;
		m_bPhantomModeChecked = false;
		m_bGameTimeChecked = false;
		m_bDiploLockedChecked = false;
		m_bDwnLvlSwitchChecked = false;
		m_bMaxEpochChecked = false;
		m_bBldgMaxCapacityChecked = false;
		m_bTechtreeStealChecked = false;
		m_bAllyBuildupChecked = false;
		m_bAlienCommandsChecked = false;
		m_bIsPlayingSequence = false;
		m_bAbandon = false;
		m_aiIsPaused = 0;
		m_xSelection.Clear();
		m_sPlayerTribe = "";
		m_sFocusClass = "";
		m_sSpecialFocus = "";
		m_bFocusBldg = false;
		m_asClasses = 0;
		m_asValidNames = 0;
		m_asPlayerNames = 8;
		m_aiCasualties = 8;
		m_asMinorLocalUpgrades.AddEntry("Actions/Aje/Upgrades/aje_resource_collector/liberator");
		m_asMinorLocalUpgrades.AddEntry("Actions/Ninigi/Upgrades/ninigi_fireplace/Explode");
		m_asMinorLocalUpgrades.AddEntry("Actions/SEAS/Upgrades/seas_barracks/barracks_reactor_core");
		m_asMinorLocalUpgrades.AddEntry("Actions/SEAS/Upgrades/seas_carrier/improved_weaponry");
		m_asMinorLocalUpgrades.AddEntry("Actions/SEAS/Upgrades/seas_carrier/carrier_reactor_core");
		m_asMinorLocalUpgrades.AddEntry("Actions/SEAS/Upgrades/seas_fortress/fortress_reactor_core");
		m_asMinorLocalUpgrades.AddEntry("Actions/SEAS/Upgrades/seas_fortress/planetary_upgrade");
		m_asMinorLocalUpgrades.AddEntry("Actions/SEAS/Upgrades/seas_garage/garage_reactor_core");
		m_asMinorLocalUpgrades.AddEntry("Actions/SEAS/Upgrades/seas_helicopter/fighter_mode");
		m_asMinorLocalUpgrades.AddEntry("Actions/SEAS/Upgrades/seas_helicopter/assault_mode");
		m_asMinorLocalUpgrades.AddEntry("Actions/SEAS/Upgrades/seas_laboratory/laboratory_reactor_core");
		m_asMinorLocalUpgrades.AddEntry("Actions/SEAS/Upgrades/seas_jail_part_01/jail_part_01_reactor_core");
		m_asMinorLocalUpgrades.AddEntry("Actions/SEAS/Upgrades/seas_jail_part_02/jail_part_02_reactor_core");
		m_asMinorLocalUpgrades.AddEntry("Actions/SEAS/Upgrades/seas_headquarters/headquarters_reactor_core");
		m_asMinorLocalUpgrades.AddEntry("Actions/Special/Upgrades/babbage_s0/mechanization");
		m_asCancableActions.AddEntry("Actions/Aje/Moves/BLDG/BuildDown");
		m_asCancableActions.AddEntry("Actions/Ninigi/Upgrades/ninigi_fireplace/Explode");
		m_asCancableActions.AddEntry("Actions/Special/Upgrades/babbage_s0/mechanization");
		m_asNoToDisable.AddEntry("Actions/Aje/Moves/BLDG/BuildDown");
		m_asNoToDisable.AddEntry("Actions/Ninigi/Upgrades/ninigi_fireplace/Explode");
		m_asNoToDisable.AddEntry("Actions/Special/Upgrades/babbage_s0/mechanization");
//		m_asNoToDisable.AddEntry("Actions/SEAS/Upgrades/seas_helicopter/fighter_mode");
//		m_asNoToDisable.AddEntry("Actions/SEAS/Upgrades/seas_helicopter/assault_mode");
		CMirageClnMgr.ms_xGPCE.Invalidate();
		Initialization();
		InitMapLists();
	endconstructor;
	
	destructor()
		m_bSupChecked = false;
		m_bResLimitChecked = false;
		m_bManaEnabledChecked = false;
		m_bPhantomModeChecked = false;
		m_bGameTimeChecked = false;
		m_bDiploLockedChecked = false;
		m_bDwnLvlSwitchChecked = false;
		m_bMaxEpochChecked = false;
		m_bBldgMaxCapacityChecked = false;
		m_bTechtreeStealChecked = false;
		m_bAllyBuildupChecked = false;
		m_bAlienCommandsChecked = false;
		m_bIsPlayingSequence = false;
		m_bAbandon = false;
		m_aiIsPaused = 0;
		m_xSelection.Clear();
		m_sPlayerTribe = "";
		m_sFocusClass = "";
		m_sSpecialFocus = "";
		m_bFocusBldg = false;
		m_asClasses = 0;
		m_asValidNames = 0;
		m_asPlayerNames = 0;
		m_aiCasualties = 0;
		//Kr1s1m:=====Save mirage and level settings backups on disk when CMirageClnMgr dies=====
		m_pxMirageSettingsBackupDB^.Save(m_sSettingsBackupPath+"/mirage_settings_backup.txt");
		m_pxLevelSettingsBackupDB^.Save(m_sSettingsBackupPath+"/level_settings_backup.txt");
		//=======================================================================================
		CMirageClnMgr.ms_xGPCE.Invalidate();
		ShutStatic();
	enddestructor;
	
	export proc void Initialization()
		var CConfig xConf;
		m_bBloodAndGore=xConf.GetSetB("Client/GameplayOptions/BloodEffect",false);
		m_bACHidden=xConf.GetSetB("Client/GameplayOptions/HideACInGame",false);
		m_abFeedbacks[FB_ATTACKS]=xConf.GetSetB("Client/GlobalSoundFeedbacks/EnemyAttacks",true);
		m_abFeedbacks[FB_BUILDINGS]=xConf.GetSetB("Client/GlobalSoundFeedbacks/BuildingReady",true);
		m_abFeedbacks[FB_IMPROVEMENT]=xConf.GetSetB("Client/GlobalSoundFeedbacks/ImprovementReady",true);
		m_abFeedbacks[FB_MAPPING]=xConf.GetSetB("Client/GlobalSoundFeedbacks/Mapping",true);
		m_abFeedbacks[FB_FULLSTORAGE]=xConf.GetSetB("Client/GlobalSoundFeedbacks/StorageFull",true);
		m_abFeedbacks[FB_DEFICIT]=xConf.GetSetB("Client/GlobalSoundFeedbacks/ResourcesNeeded",true);
		m_abFeedbacks[FB_POPULATION]=xConf.GetSetB("Client/GlobalSoundFeedbacks/Population",true);
		m_abFeedbacks[FB_EPOCHDONE]=xConf.GetSetB("Client/GlobalSoundFeedbacks/EpochFinished",true);
		m_abFeedbacks[FB_EPOCHSTART]=xConf.GetSetB("Client/GlobalSoundFeedbacks/EpochWarning",true);
		m_abFeedbacks[FB_DIMENSION]=xConf.GetSetB("Client/GlobalSoundFeedbacks/Warpgates",true);
		m_abFeedbacks[FB_MULTIPLAYER]=xConf.GetSetB("Client/GlobalSoundFeedbacks/MultiplayerRelated",true);
		m_abFeedbacks[FB_QUEST]=xConf.GetSetB("Client/GlobalSoundFeedbacks/QuestRelated",true);
		m_abFeedbacks[FB_DEATH]=xConf.GetSetB("Client/GlobalSoundFeedbacks/DieAcks",true);
		m_abFeedbacks[FB_TREASURES]=xConf.GetSetB("Client/GlobalSoundFeedbacks/ArtifactsRelated",true);
		m_abFeedbacks[FB_ENDSCREEN]=xConf.GetSetB("Client/GlobalSoundFeedbacks/Endscreen",true);
		m_abFeedbacks[FB_ECONOMY]=xConf.GetSetB("Client/GlobalSoundFeedbacks/EconomyRelated",true);
		var ^CPropDB pxHeroes = new CPropDB, pxBldgs = new CPropDB, pxCrashRPG = new CPropDB;
		if(pxHeroes^.Load(CClientWrap.GetUrsRelPath()+"/Data/Base/Scripts/Server/settings/NPCList.txt"))then
			var ^CPropDB.CNode pxRoot = ^(pxHeroes^.GetRoot());
			var int i, iC = pxRoot^.NumSubs();
			for(i=0)cond(i<iC)iter(i++)do
				m_asValidNPCs.AddEntry((pxRoot^)[i].Name());
			endfor;
		endif;
		if(pxHeroes^.Load(CClientWrap.GetUrsRelPath()+"/Data/Base/Scripts/Server/settings/CrashRPGList.txt"))then
			var ^CPropDB.CNode pxRoot = ^(pxHeroes^.GetRoot());
			var int i, iC = pxRoot^.NumSubs();
			for(i=0)cond(i<iC)iter(i++)do
				m_asCrashRPGChars.AddEntry((pxRoot^)[i].Name());
			endfor;
		endif;
		if(pxBldgs^.Load(CClientWrap.GetUrsRelPath()+"/Data/Base/Scripts/Server/settings/BuildingList.txt"))then
			var ^CPropDB.CNode pxRoot = ^(pxBldgs^.GetRoot());
			var int i, iC = pxRoot^.NumSubs();
			for(i=0)cond(i<iC)iter(i++)do
				m_asBuildings.AddEntry((pxRoot^)[i].Name());
			endfor;
		endif;
	endproc;
	
	export proc ^CMapInfoList GetCampaignMapList()
		return ^m_xCampaignMapList;
	endproc;
	
	export proc ^CMapInfoList GetSaveMapList()
		return ^m_xSaveMapList;
	endproc;
	
	export proc void UpdateSaveMapList()
		var string sFilePath=CClientWrap.GetUserProfileList().GetSaveGamePath();
		CGameWrap.GetMapInfoList(sFilePath,m_xSaveMapList,200 * CGameInst.ms_iUIScaleFactor,200 * CGameInst.ms_iUIScaleFactor);
	endproc;
	
	proc void InitMapLists()
		var string sFilePath=CClientWrap.GetUrsRelPath()+"/Data/Base/Maps/Cpn_single_001/";
		CGameWrap.GetMapInfoList(sFilePath,m_xCampaignMapList,200 * CGameInst.ms_iUIScaleFactor,200 * CGameInst.ms_iUIScaleFactor);
		UpdateSaveMapList();
	endproc;
	
	export proc void SetFeedback(int p_iType,bool p_bOn)
		m_abFeedbacks[p_iType]=p_bOn;
	endproc;
	
	export proc int GetSupply(string p_sCllsNm)
		var int iSuppCount = m_pxSupply^.GetValueI(p_sCllsNm, 0);
		return iSuppCount;
	endproc;

	export proc bool IsSupplyOn()
		if(m_bSupChecked)then
			return m_bIsSupplyOn;
		endif;

		m_bSupChecked = TryGetValue("Server/GameplayOptions/", "UseSupply", m_bIsSupplyOn, false);
		return m_bIsSupplyOn;
	endproc;
	
	export proc bool IsResUnlimited()
		if(m_bResLimitChecked)then
			return m_bResUnlimited;
		endif;

		m_bResLimitChecked = TryGetValue("Server/GameplayOptions/", "ResourcesUnlimited", m_bResUnlimited, false);
		return m_bResUnlimited;
	endproc;
	
	export proc bool PhantomMode()
		if(!m_bPhantomModeChecked)then
			var ^CLevelInfoClient pxLevelInfo = ^(CGameWrap.GetClient().GetLevelInfo());
			if(pxLevelInfo != null)then
				var ^CPropDB.CNode pxPhantomMode,pxCSNode=pxLevelInfo^.GetGenericData().FindNode("ClientSettings",false);
				if(pxCSNode!=null)then
					pxPhantomMode=pxCSNode^.Get("PhantomMode");
				endif;
				if(pxPhantomMode==null)then
					var CConfig xConf;
					m_bPhantomMode = xConf.GetSetI("Server/GameplayOptions/PhantomMode",0)>0;
				else
					var int iPhantomMode = pxCSNode^.GetValueI("ResourcesUnlimited");
					m_bPhantomMode = iPhantomMode>0;
					m_bPhantomModeChecked = true;
				endif;
			else
				m_bPhantomMode = false;
			endif;
		endif;
		return m_bPhantomMode;
	endproc;
	
	export proc bool IsMinorLocalUpgrade(string p_sAction)
		return (m_asMinorLocalUpgrades.FindEntry(p_sAction))!=-1;
	endproc;
	
	export proc bool IsCancableAction(string p_sAction)
		return (m_asCancableActions.FindEntry(p_sAction))!=-1;
	endproc;
	
	export proc bool ShouldNotBeDisabled(string p_sAction)
		return (m_asNoToDisable.FindEntry(p_sAction))!=-1;
	endproc;
	
	export proc bool ManaEnabled()
		if(m_bManaEnabledChecked)then
			return m_bManaEnabled;
		endif;

		m_bManaEnabledChecked = TryGetValue("Server/GameplayOptions/", "ManaEnabled", m_bManaEnabled, false);
		return m_bManaEnabled;
	endproc;
	
	export proc bool DiploLocked()
		if(m_bDiploLockedChecked)then
			return m_bDiploLocked;
		endif;

		m_bDiploLockedChecked = TryGetValue("Server/GameplayOptions/", "DiploLocked", m_bDiploLocked, false);
		return m_bDiploLocked;
	endproc;
	
	export proc void UnlockDiplo()
		m_bDiploLocked=false;
	endproc;
	
	export proc int DwnLvlSwitch()
		if(m_bDwnLvlSwitchChecked)then
			return m_iDwnLvlSwitch;
		endif;

		m_bDwnLvlSwitchChecked = TryGetValue("Server/GameplayOptions/", "DwnLvlSwitch", m_iDwnLvlSwitch, 0);
		return m_iDwnLvlSwitch;
	endproc;
	
	export proc int MaxEpoch()
		if(m_bMaxEpochChecked)then
			return m_iMaxEpoch;
		endif;

		m_bMaxEpochChecked = TryGetValue("Server/GameplayOptions/", "MaxEpoch", m_iMaxEpoch, 0);
		return m_iMaxEpoch;
	endproc;
	
	export proc bool CheckBldgMaxCapacity()
		if(m_bBldgMaxCapacityChecked)then
			return m_bBldgMaxCapacity;
		endif;

		m_bBldgMaxCapacityChecked = TryGetValue("Server/GameplayOptions/", "BldgMaxCapacity", m_bBldgMaxCapacity, false);
		return m_bBldgMaxCapacity;
	endproc;
	
	export proc bool CheckTechtreeSteal()
		if(m_bTechtreeStealChecked)then
			return m_bTechtreeSteal;
		endif;

		m_bTechtreeStealChecked = TryGetValue("Server/GameplayOptions/", "TechtreeSteal", m_bTechtreeSteal, false);
		return m_bTechtreeSteal;
	endproc;
	
	export proc bool CheckAllyBuildup()
		if(m_bAllyBuildupChecked)then
			return m_bAllyBuildup;
		endif;

		m_bAllyBuildupChecked = TryGetValue("Server/GameplayOptions/", "AllyBuildup", m_bAllyBuildup, false);
		return m_bAllyBuildup;
	endproc;
	
	export proc bool CheckAlienCommands()
		if(m_bAlienCommandsChecked)then
			return m_bAlienCommands;
		endif;

		m_bAlienCommandsChecked = TryGetValue("Server/", "AllowAlienCommands", m_bAlienCommands, false);
		return m_bAlienCommands;
	endproc;
	
	export proc int GetSpan()
		if(!m_bGameTimeChecked)then
			var ^CLevelInfoClient pxLevelInfo = ^(CGameWrap.GetClient().GetLevelInfo());
			if(pxLevelInfo!=null)then
				var ^CPropDB.CNode pxBaseNode=pxLevelInfo^.GetGenericData().FindNode("Base",false);
				var ^CPropDB.CNode pxCSNode=pxLevelInfo^.GetGenericData().FindNode("ClientSettings",false);
				if(pxBaseNode!=null&&pxCSNode!=null)then
					var ^CPropDB.CNode pxTime=pxCSNode^.FindNode("TimerIniated",false);
					if(pxTime==null)then
						m_iGameTime=0;
					else
						var int iInited = pxCSNode^.GetValueI("TimerIniated");
						m_iGameTime = pxBaseNode^.GetValueR("PlayedTime",0.0).ToInt();
						m_bGameTimeChecked = iInited==1;
					endif;
				else
					m_iGameTime=0;
				endif;
			endif;
		endif;
		return m_iGameTime;
	endproc;
	
	proc ^CPropDB.CNode TryGetNode(string p_sKey)
		if(p_sKey.IsEmpty())then
			KLog.LogError("CMirageClnMgr","Failed to get value from empty key");
			return null;
		endif;

		var ^CLevelInfoClient pxLevelInfo = ^(CGameWrap.GetClient().GetLevelInfo());
		if(pxLevelInfo == null)then
			KLog.LogError("CMirageClnMgr","Failed to get value from key '" + p_sKey + "' - CLevelInfoClient is null");
			return null;
		endif;

		var ^CPropDB pxGenericDB = ^(pxLevelInfo^.GetGenericData());
		if(pxGenericDB == null)then
			KLog.LogError("CMirageClnMgr","Failed to get value from key '" + p_sKey + "' - LevelInfo DB is null");
			return null;
		endif;
		
		var ^CPropDB.CNode pxCSNode = pxGenericDB^.FindNode("ClientSettings",false);
		if(pxCSNode==null)then
			KLog.LogError("CMirageClnMgr","Failed to get value from key '" + p_sKey + "' - ClientSettings is null");
			return null;
		endif;

		var ^CPropDB.CNode pxValueNode = ^(pxCSNode^.Get(p_sKey));
		if(pxValueNode == null)then
			KLog.LogError("CMirageClnMgr","Failed to get value from key '" + p_sKey + "' - ValueNode is null");
			return null;
		endif;

		return pxValueNode;
	endproc;

	proc bool TryGetValue(string p_sSettingsPath, string p_sKey, ref bool p_rbReturnValue, bool p_bFallbackValue)
		p_rbReturnValue = p_bFallbackValue;

		var ^CPropDB.CNode pxValueNode = TryGetNode(p_sKey);
		if(pxValueNode == null)then
			var CConfig xConf;
			var string sSettingsPath = p_sSettingsPath + p_sKey;
			if(xConf.Exists(sSettingsPath))then
				p_rbReturnValue = xConf.GetB(sSettingsPath, p_rbReturnValue);
				KLog.LogWarn("CMirageClnMgr","Using value '" + p_rbReturnValue.ToString() + "' from Settings.cfg " + sSettingsPath );
			else
				KLog.LogWarn("CMirageClnMgr","Using fallback value '" + p_rbReturnValue.ToString() + "'");
			endif;
			return false;
		endif;

		p_rbReturnValue = pxValueNode^.ValueI() == 1;
		KLog.LogInfo("CMirageClnMgr", "Setting '" + p_sKey + "' = '" + p_rbReturnValue.ToString() + "'");
		return true;
	endproc;
	
	proc bool TryGetValue(string p_sSettingsPath, string p_sKey, ref int p_riReturnValue, int p_bFallbackValue)
		p_riReturnValue = p_bFallbackValue;

		var ^CPropDB.CNode pxValueNode = TryGetNode(p_sKey);
		if(pxValueNode == null)then
			var CConfig xConf;
			var string sSettingsPath = p_sSettingsPath + p_sKey;
			if(xConf.Exists(sSettingsPath))then
				p_riReturnValue = xConf.GetI(sSettingsPath, p_riReturnValue);
				KLog.LogWarn("CMirageClnMgr","Using value '" + p_riReturnValue.ToString() + "' from Settings.cfg " + sSettingsPath );
			else
				KLog.LogWarn("CMirageClnMgr","Using fallback value '" + p_riReturnValue.ToString() + "'");
			endif;
			return false;
		endif;

		p_riReturnValue = pxValueNode^.ValueI();
		KLog.LogInfo("CMirageClnMgr", "Setting '" + p_sKey + "' = '" + p_riReturnValue.ToString() + "'");
		return true;
	endproc;
	
	export proc void SetACHidden(bool p_bOn)
		m_bACHidden=p_bOn;
	endproc;
	
	export proc void SetMoreBlood(bool p_bOn)
		m_bBloodAndGore=p_bOn;
	endproc;
	
	export proc bool IsACHidden()
		return m_bACHidden;
	endproc;
	
	export proc bool MoreBlood()
		return m_bBloodAndGore;
	endproc;
	
	export proc bool GetFeedback(string p_sType)
		if(m_bIsPlayingSequence)then return false; endif;
		if(m_aiIsPaused.NumEntries()>0)then return false; endif;
		var CConfig xConf;
		var bool bPlayFeedback = xConf.GetSetB("Client/GlobalSoundFeedbacks/"+p_sType,true);
		return bPlayFeedback;
	endproc;
	
	export proc bool GetFeedback(int p_iType)
		if(m_bIsPlayingSequence)then return false; endif;
		if(m_aiIsPaused.NumEntries()>0)then return false; endif;
		return m_abFeedbacks[p_iType];
	endproc;
	
	export static proc bool ValidateName(ref string po_rsClass, CClntHndl p_xHandle)
		if(!p_xHandle.IsValid())then return false; endif;
		var ^CObj pxObj = p_xHandle.GetObj();
		if(pxObj==null)then return false; endif;
		po_rsClass = pxObj^.GetClassName();
		if(po_rsClass=="aje_catapult_rex"||po_rsClass=="aje_resource_collector"||po_rsClass=="ninigi_seismosaurus"||po_rsClass=="seas_helicopter")then return true; endif;
		var ^CAttribs pxAttr = pxObj^.GetAttribs();
		if(pxAttr!=null)then
			var string sFlag = pxAttr^.GetValue("ObjFlag");
			if(!sFlag.IsEmpty())then
				po_rsClass = sFlag;
			endif;
		endif;
		return true;
	endproc;
	
	export static proc bool ValidateName(ref string po_rsClass, ^CObj p_pxObj)
		if(p_pxObj==null)then return false; endif;
		po_rsClass = p_pxObj^.GetClassName();
		if(po_rsClass=="aje_catapult_rex"||po_rsClass=="aje_resource_collector"||po_rsClass=="ninigi_seismosaurus"||po_rsClass=="seas_helicopter")then return true; endif;
		var ^CAttribs pxAttr = p_pxObj^.GetAttribs();
		if(pxAttr!=null)then
			var string sFlag = pxAttr^.GetValue("ObjFlag");
			if(!sFlag.IsEmpty())then
				po_rsClass = sFlag;
			endif;
		endif;
		return true;
	endproc;
	
	export static proc bool ValidateNameInfo(^CObj p_pxObj, ref bool p_rbSpec)
		if(p_pxObj==null)then return false; endif;
		var string sClass = p_pxObj^.GetClassName();
		var ^CAttribs pxAttr = p_pxObj^.GetAttribs();
		if(pxAttr!=null)then
			var string sFlag = pxAttr^.GetValue("ObjFlag");
			if(!sFlag.IsEmpty())then
				sClass = sFlag;
			endif;
		endif;
		p_rbSpec=sClass=="ninigi_seismosaurus";
		return true;
	endproc;
	
	export static proc bool IsGenericDataLoaded()
		var bool bLoaded=false;
		var ^CLevelInfo pxLevelInfo;
		var int iState = CUIStateMgr.Get().GetState();
		if(iState == CUIStateMgr.STATE_MULTIPLAYERPREGAME || iState == CUIStateMgr.STATE_NEWMULTIPLAYERPREGAME)then
			//In lobby
			pxLevelInfo = ^(CGameWrap.GetClient().GetLevelPreview());
		else
			pxLevelInfo =^(CGameWrap.GetClient().GetLevelInfo());
		endif;
		if(pxLevelInfo==null)then return bLoaded; endif;
		var ^CPropDB pxGenericData=^(pxLevelInfo^.GetGenericData());
		if(pxGenericData==null)then return bLoaded; endif;
		var ^CPropDB.CNode pxRoot=^(pxGenericData^.GetRoot());
		if(pxRoot==null)then return bLoaded; endif;
		if(pxRoot^.NumSubs()>0)then bLoaded=true; endif;
		return bLoaded;
	endproc;
	
	export proc int GetPlayers(string p_sLevelName, int p_iPlayers)
		//KLog.LogSpam("ParaworldFan", "MirageClnMgr:GetPlayers("+p_sLevelName+"), ("+p_iPlayers.ToString()+") begin");
		if(!IsCustomMap(p_sLevelName))then return p_iPlayers; endif;
		return p_iPlayers-GetHiddenPlayers(p_sLevelName);
	endproc;
	
	export proc int GetHiddenPlayers(string p_sLevelName)
		//KLog.LogSpam("ParaworldFan", "MirageClnMgr:GetHiddenPlayers("+p_sLevelName+") begin");
		var int iNumPlayers=0;
		if(m_pxCustomMapSettingsDB==null || p_sLevelName.IsEmpty())then return iNumPlayers; endif;
		p_sLevelName.Replace(" ","_");
		var string sPath="Levels/"+p_sLevelName+"/Custom/Players";
		var int iSlotID,iNumSlots=8;
		for(iSlotID=0)cond(iSlotID<iNumSlots)iter(iSlotID++)do
			var ^CPropDB.CNode pxPlayerNode=m_pxCustomMapSettingsDB^.FindNode(sPath+"/Player_"+iSlotID.ToString()+"/HiddenSlot",false);
			if(pxPlayerNode!=null)then iNumPlayers++; endif;
		endfor;
		//KLog.LogSpam("ParaworldFan","MirageClnMgr:GetHiddenPlayers iNumPlayers="+iNumPlayers.ToString());
		return iNumPlayers;
	endproc;
	
	export proc int GetFakeNumPlayers(string p_sLevelName)
		var int iNumPlayers=0;
		if(m_pxCustomMapSettingsDB==null || p_sLevelName.IsEmpty())then return iNumPlayers; endif;
		p_sLevelName.Replace(" ","_");
		var string sPath="Levels/"+p_sLevelName+"/Custom/Players";
		var int iSlotID,iNumSlots=8;
		for(iSlotID=0)cond(iSlotID<iNumSlots)iter(iSlotID++)do
			var ^CPropDB.CNode pxPlayerNode=m_pxCustomMapSettingsDB^.FindNode(sPath+"/Player_"+iSlotID.ToString(),false);
			if(pxPlayerNode!=null)then iNumPlayers++; endif;
		endfor;
		return iNumPlayers;
	endproc;
	
	export proc bool IsCustomMap(string p_sLevelName)
		if(p_sLevelName.IsEmpty())then return false; endif;
		p_sLevelName.Replace(" ", "_");
		if(m_pxCustomMapSettingsDB!=null)then
			//KLog.LogSpam("Kr1s1m-ALERT", "root node != null");
			var ^CPropDB.CNode pxLevelsNode=m_pxCustomMapSettingsDB^.Get("Levels");
			if(pxLevelsNode!=null)then
				//KLog.LogSpam("Kr1s1m-ALERT", "CMirageClnMgr:IsCustomMap Looking for "+p_sLevelName+" with replaced spaces ...");
				var ^CPropDB.CNode pxLevelNameNode = pxLevelsNode^.Get(p_sLevelName);
				if(pxLevelNameNode!=null)then
					return true;
				endif;
			endif;
		endif;
		if(m_pxCustomMapMirageSettingsDB!=null)then
			//KLog.LogSpam("Kr1s1m-ALERT", "root node != null");
			var ^CPropDB.CNode pxLevelsNode=m_pxCustomMapMirageSettingsDB^.Get("Levels");
			if(pxLevelsNode!=null)then
				//KLog.LogSpam("Kr1s1m-ALERT", "CMirageClnMgr:IsCustomMap Looking for "+p_sLevelName+" with replaced spaces ...");
				var ^CPropDB.CNode pxLevelNameNode = pxLevelsNode^.Get(p_sLevelName);
				if(pxLevelNameNode!=null)then
					return true;
				endif;
			endif;
		endif;
		return false;
	endproc;
	
	export proc bool IsCustomMapSetting(string p_sLevelName, string p_sSetting)
		//KLog.LogSpam("Kr1s1m-ALERT", "MirageClnMgr:IsCustomMapSetting("+p_sLevelName+", "+p_sSetting+") begin");
		if(p_sLevelName.IsEmpty()||p_sSetting.IsEmpty())then return false; endif;
		var bool bCustom = false;
		var ^CPropDB.CNode pxRootNode = null;
		if(p_sSetting == "MirageSettings")then
			pxRootNode = m_pxCustomMapMirageSettingsDB;
			bCustom = true;
		else
			if(p_sSetting == "LevelSettings")then
				bCustom = true;
			endif;
			pxRootNode = m_pxCustomMapSettingsDB;
		endif;
		if(!bCustom && pxRootNode!=null)then
			//KLog.LogSpam("Kr1s1m-ALERT", "root node != null");
			var ^CPropDB.CNode pxLevelsNode=pxRootNode^.Get("Levels");
			if(pxLevelsNode!=null)then
				p_sLevelName.Replace(" ", "_");
				//KLog.LogSpam("Kr1s1m-ALERT", "MirageClnMgr:IsCustomMapSetting Looking for "+p_sLevelName+" with replaced spaces ...");
				var ^CPropDB.CNode pxLevelNameNode = pxLevelsNode^.Get(p_sLevelName);
				if(pxLevelNameNode!=null)then
					//KLog.LogSpam("Kr1s1m-ALERT", "MirageClnMgr:IsCustomMapSetting LevelNameNode "+pxLevelNameNode^.Name()+" matched.");
					var string sPrefix = "Custom/";
					var ^CPropDB.CNode pxCustomSettingNode = pxLevelNameNode^.FindNode(sPrefix+p_sSetting, false);
					if(pxCustomSettingNode!=null)then
					//KLog.LogSpam("Kr1s1m-ALERT", "MirageClnMgr:IsCustomMapSetting Custom Setting "+p_sSetting+" found.");
						var string sValue = pxCustomSettingNode^.Value();
						bCustom = (sValue.IsEmpty() || sValue.ToInt()==1);
					else//Kr1s1m: ...custom setting was not found, so check for modifications in the LevelSettings branches
						var string sCategories="LoadScreen:EndScreen:PointBuy:Diplomacy:Players:";
						var array string asCategories; sCategories.Split(asCategories,":",true);
						var int i,iC=asCategories.NumEntries();
						for(i=0)cond(i<iC)iter(i++)do
							if(asCategories[i]=="Players")then
								var int j,jC=8;
								for(j=0)cond(j<jC)iter(j++)do
									pxCustomSettingNode = pxLevelNameNode^.FindNode(sPrefix+"Players/Player_"+j.ToString()+"/"+p_sSetting, false);
									if(pxCustomSettingNode!=null)then break; endif;
								endfor;
							else
								pxCustomSettingNode = pxLevelNameNode^.FindNode(sPrefix+asCategories[i]+"/"+p_sSetting, false);
							endif;
							if(pxCustomSettingNode==null)then continue; endif;
							var string sValue = pxCustomSettingNode^.Value();
							bCustom = (sValue.IsEmpty() || sValue.ToInt()==1);
							break;
						endfor;
						if(!bCustom)then
							bCustom = pxLevelNameNode^.FindNode("LevelSettings/CheckBox/"+p_sSetting, false)!=null ||
									  pxLevelNameNode^.FindNode("LevelSettings/DropList/"+p_sSetting, false)!=null;
						endif;
					endif;
				endif;
			endif;
		endif;
		//var string sCustom = "non-custom";
		//if(bCustom)then sCustom = "custom"; endif;
		//KLog.LogSpam("Kr1s1m-ALERT", "MirageClnMgr:IsCustomMapSetting Level "+p_sLevelName+" has "+sCustom+" "+p_sSetting);
		//KLog.LogSpam("Kr1s1m-ALERT", "MirageClnMgr:IsCustomMapSetting("+p_sLevelName+", "+p_sSetting+") end");
		return bCustom;
	endproc;
	
	export proc bool IsSlotForced(string p_sMap, int p_iID)
		return (IsCustomMapSetting(p_sMap,"Players/Player_"+p_iID.ToString()+"/AddIfEmpty")||IsCustomMapSetting(p_sMap,"Players/Player_"+p_iID.ToString()+"/HiddenSlot"));
	endproc;
	
	export proc bool GetCustomMapAIDifficulty(string p_sMap, int p_iID, ref int p_riDifficulty)
		if(p_sMap.IsEmpty())then return false; endif;
		var string sDifficulty=GetCustomMapPlayerSetting(p_sMap,p_iID,"Difficulty");
		if(!sDifficulty.IsEmpty())then
			p_riDifficulty=sDifficulty.ToInt();
			return true;
		endif;
		return false;
	endproc;
	
	export proc bool GetCustomMapPlayerHP(string p_sMap, int p_iID, ref int p_riHP)
		if(p_sMap.IsEmpty())then return false; endif;
		if(!GetCustomMapPlayerSettingBool(p_sMap,p_iID,"HP"))then return false; endif;
		var string sHP=GetCustomMapPlayerSetting(p_sMap,p_iID,"HP");
		if(IsCustomMapSetting(p_sMap,"PointBuy/MapDifficulty"))then
			var string sDifficulty;
			var int iCurDifficulty=GetMapDifficulty();
			if(iCurDifficulty==CCampaignMgr.DIFFICULTY_EASY)then
				sDifficulty="HP/Easy";
			elseif(iCurDifficulty==CCampaignMgr.DIFFICULTY_MEDIUM)then
				sDifficulty="HP/Medium";
			elseif(iCurDifficulty==CCampaignMgr.DIFFICULTY_HARD)then
				sDifficulty="HP/Hard";
			endif;
			p_riHP=GetCustomMapPlayerSettingInt(p_sMap,p_iID,sDifficulty);
			if(p_riHP<=0)then p_riHP=100; endif;
			return true;
		else
			p_riHP=sHP.ToInt();
			if(p_riHP<=0)then p_riHP=100; endif;
			return true;
		endif;
	endproc;
	
	export proc bool GetCustomMapPlayerSettingBool(string p_sLevelName, int p_iPlayerID, string p_sKey)
		return IsCustomMapSetting(p_sLevelName,"Players/Player_"+p_iPlayerID.ToString()+"/"+p_sKey);
	endproc;
	
	export proc int GetCustomMapPlayerSettingInt(string p_sLevelName, int p_iPlayerID, string p_sKey)
		return GetCustomMapPlayerSetting(p_sLevelName,p_iPlayerID,p_sKey).ToInt();
	endproc;
	
	export proc string GetCustomMapPlayerSetting(string p_sLevelName, int p_iPlayerID, string p_sKey)
		//KLog.LogSpam("ParaworldFan-ALERT", "MirageClnMgr:GetCustomMapPlayerSetting("+p_sLevelName+", "+p_sKey+") begin");
		var string sValue;
		if(m_pxCustomMapSettingsDB!=null)then
			//KLog.LogSpam("ParaworldFan-ALERT", "root node != null");
			var ^CPropDB.CNode pxLevelsNode=m_pxCustomMapSettingsDB^.Get("Levels");
			if(pxLevelsNode!=null)then
				p_sLevelName.Replace(" ", "_");
				//KLog.LogSpam("ParaworldFan-ALERT", "MirageClnMgr:GetCustomMapPlayerSetting Looking for "+p_sLevelName+" with replaced spaces ...");
				var ^CPropDB.CNode pxLevelNameNode = pxLevelsNode^.Get(p_sLevelName);
				if(pxLevelNameNode!=null)then
					//KLog.LogSpam("ParaworldFan-ALERT", "MirageClnMgr:GetCustomMapPlayerSetting LevelNameNode "+pxLevelNameNode^.Name()+" matched.");
					var ^CPropDB.CNode pxCategoriesNode = pxLevelNameNode^.Get("Custom");
					if(pxCategoriesNode!=null)then
						var ^CPropDB.CNode pxPlayerListNode = pxCategoriesNode^.Get("Players");
						if(pxPlayerListNode!=null)then
							var ^CPropDB.CNode pxPlayerNode = pxPlayerListNode^.Get("Player_"+p_iPlayerID.ToString());
							if(pxPlayerNode!=null)then
								var ^CPropDB.CNode pxPlayerSettingNode = pxPlayerNode^.FindNode(p_sKey, false);
								if(pxPlayerSettingNode!=null)then
									sValue = pxPlayerSettingNode^.Value();
								else
									var ^CPropDB.CNode pxPlayerExceptionListNode = pxPlayerNode^.Get("Exceptions");
									if(pxPlayerExceptionListNode!=null)then
										pxPlayerSettingNode = pxPlayerExceptionListNode^.FindNode(p_sKey, false);
										if(pxPlayerSettingNode!=null)then
											//KLog.LogSpam("ParaworldFan-ALERT", "MirageClnMgr:GetCustomMapPlayerSetting Custom Setting "+p_sKey+" found.");
											sValue = pxPlayerSettingNode^.Value();
										endif;
									endif;
								endif;
							endif;
						endif;
					endif;
				endif;
			endif;
		endif;
		//var string sCustom = "non-custom";
		//if(!sValue.IsEmpty())then sCustom = "custom"; endif;
		//KLog.LogSpam("ParaworldFan-ALERT", "MirageClnMgr:GetCustomMapPlayerSetting Level "+p_sLevelName+" has "+sCustom+" "+p_sKey);
		//KLog.LogSpam("ParaworldFan-ALERT", "MirageClnMgr:GetCustomMapPlayerSetting("+p_sLevelName+", "+p_sKey+") end");
		return sValue;
	endproc;
	
	export proc array string OperateLevelSettingsBackupDB(bool p_bRestore)
		//KLog.LogSpam("Kr1s1m", "MirageClnMgr:OperateLevelSettingsBackupDB begin");
		var array string asRestoreSettingNames;
		//var string sRestore = "backup";
		//if(p_bRestore)then sRestore = "restore"; endif;
		//KLog.LogSpam("Kr1s1m", "Initializing " + sRestore + " operation...");
		if(m_pxLevelSettingsBackupDB==null)then return asRestoreSettingNames; endif; 
		var ^CPropDB.CNode pxLevelSettingsBackupRootNode = ^(m_pxLevelSettingsBackupDB^.GetRoot());
		if(pxLevelSettingsBackupRootNode==null)then return asRestoreSettingNames; endif; 
		var ^CPropDB.CNode pxLevelSettingsBackupNode = pxLevelSettingsBackupRootNode^.Get("LevelSettingsBackup");
		if(pxLevelSettingsBackupNode!=null)then
			var bool bUpdateBackup=false;
			var ^CPropDB.CNode pxMultiplayerNode = pxLevelSettingsBackupNode^.Get("Multiplayer");
			var ^CPropDB.CNode pxServerNode = pxLevelSettingsBackupNode^.Get("Server");
			if(pxMultiplayerNode!=null)then
				var int i, iM=pxMultiplayerNode^.NumSubs();
				for(i=0)cond(i<iM)iter(i++)do
					var ^CPropDB.CNode pxMultiplayerSettingNode = ^(pxMultiplayerNode^.Get(i));
					var string sSettingName = pxMultiplayerSettingNode^.Name();
					var string sValue = pxMultiplayerSettingNode^.Value();
					var string sPath = pxMultiplayerNode^.Name() + "/" + sSettingName;
					var string sConfValue = CClientWrap.GetUserProfileValue(sPath, "");
					if(sValue!=sConfValue)then
						if(p_bRestore)then
							CClientWrap.SetUserProfileValue(sPath, sValue);
							asRestoreSettingNames.AddEntry(sSettingName);
							//KLog.LogSpam("Kr1s1m", "UserProfile value " + sPath + " restored to " + sValue);
							//Kr1s1m: Map some setting name values from their config names to their attrib names...
							if(sSettingName=="ChooseColor")then sSettingName="RandomColor"; endif;
							if(sSettingName=="DisableWarpgate")then sSettingName="DimGateForbidden"; endif;
							if(sSettingName=="DisableFOW")then sSettingName="FOWEnabled"; endif;
							if(sSettingName=="LockDiplomacy")then sSettingName="DiplomacyLocked"; endif;
							CGameWrap.GetGame().SetAttrib(sSettingName, sValue);
							//KLog.LogSpam("Kr1s1m", "CGameWrap.GetGame().SetAttrib("+sSettingName+", "+sValue+")");
						else
							bUpdateBackup=true;
							pxMultiplayerNode^.SetValue(sSettingName, sConfValue);
							//KLog.LogSpam("Kr1s1m", pxLevelSettingsBackupNode^.Name() + "/" + sPath + " set to " + sConfValue);
						endif;
					endif;
				endfor;
			endif;
			if(pxServerNode!=null)then
				var ^CPropDB.CNode pxGameplayOptionsNode = pxServerNode^.Get("GameplayOptions");
				if(pxGameplayOptionsNode!=null)then
					var CConfig xConf;
					var int i, iG=pxGameplayOptionsNode^.NumSubs();//Kr1s1m: Currently only contains DiploLocked value
					for(i=0)cond(i<iG)iter(i++)do
						var ^CPropDB.CNode pxGameplayOptionNode = ^(pxGameplayOptionsNode^.Get(i));
						var string sSettingName = pxGameplayOptionNode^.Name();
						var int iValue = pxGameplayOptionNode^.ValueI();
						var string sPath = pxServerNode^.Name() + "/" + pxGameplayOptionsNode^.Name() + "/" + sSettingName;
						var int iConfValue = xConf.GetSetI(sPath, 0);
						if(iValue!=iConfValue)then
							if(p_bRestore)then
								xConf.SetI(sPath, iValue);
								asRestoreSettingNames.AddEntry(sSettingName);
								//KLog.LogSpam("Kr1s1m", "UserProfile value " + sPath + " restored to " + iValue.ToString());
								CGameWrap.GetGame().SetAttrib(sSettingName, iValue);
								//KLog.LogSpam("Kr1s1m", "CGameWrap.GetGame().SetAttrib("+sSettingName+", "+iValue.ToString()+")");
							else
								bUpdateBackup=true;
								pxGameplayOptionsNode^.SetValue(sSettingName, iConfValue);
								//KLog.LogSpam("Kr1s1m", pxLevelSettingsBackupNode^.Name() + "/" + sPath + " set to " + iConfValue.ToString());
							endif;
						endif;
					endfor; 
				endif;
			endif;
			if(bUpdateBackup)then m_pxLevelSettingsBackupDB^.Save(m_sSettingsBackupPath+"/level_settings_backup.txt"); endif; //Kr1s1m: If level settings backup was updated, save it on disk.
		endif;
		//KLog.LogSpam("Kr1s1m", "MirageClnMgr:OperateLevelSettingsBackupDB end");
		return asRestoreSettingNames;
	endproc;
	
	export proc array string BackupLevelSettings()
		var bool bRestore = false;
		return OperateLevelSettingsBackupDB(bRestore);
	endproc;
	
	export proc array string RestoreLevelSettings()
		var bool bRestore = true;
		return OperateLevelSettingsBackupDB(bRestore);
	endproc;
	
	export proc void OperateMirageServerSettingsBackupDB(bool p_bRestore)
		//KLog.LogSpam("Kr1s1m", "MirageClnMgr:OperateMirageServerSettingsBackupDB begin");
		//var string sRestore = "backup";
		//if(p_bRestore)then sRestore = "restore"; endif;
		//KLog.LogSpam("Kr1s1m", "Initializing " + sRestore + " operation...");
		if(m_pxMirageSettingsBackupDB==null)then return; endif; 
		var ^CPropDB.CNode pxMirageSettingsBackupRootNode = ^(m_pxMirageSettingsBackupDB^.GetRoot());
		if(pxMirageSettingsBackupRootNode==null)then return; endif; 
		var ^CPropDB.CNode pxMirageSettingsBackupNode = pxMirageSettingsBackupRootNode^.Get("MirageSettingsBackup");
		if(pxMirageSettingsBackupNode!=null)then
			var bool bUpdateBackup=false;
			var CConfig xConf;
			var ^CPropDB.CNode pxServerNode = pxMirageSettingsBackupNode^.Get("Server");
			var ^CPropDB.CNode pxGameNode = pxMirageSettingsBackupNode^.Get("Game");
			if(pxServerNode!=null)then
				var ^CPropDB.CNode pxGameplayOptionsNode = pxServerNode^.Get("GameplayOptions");
				if(pxGameplayOptionsNode!=null)then
					var int i, iG=pxGameplayOptionsNode^.NumSubs();
					for(i=0)cond(i<iG)iter(i++)do
						var ^CPropDB.CNode pxGameplayOptionNode = ^(pxGameplayOptionsNode^.Get(i));
						var string sSettingName = pxGameplayOptionNode^.Name();
						var int iValue = pxGameplayOptionNode^.ValueI();
						var string sPath = pxServerNode^.Name() + "/" + pxGameplayOptionsNode^.Name() + "/" + sSettingName;
						var int iConfValue = xConf.GetSetI(sPath, 0);
						if(iValue!=iConfValue)then
							if(p_bRestore)then
								xConf.SetI(sPath, iValue);
								//KLog.LogSpam("Kr1s1m", "UserProfile value " + sPath + " restored to " + iValue.ToString());
								CGameWrap.GetGame().SetAttrib(sSettingName, iValue);
								//KLog.LogSpam("Kr1s1m", "CGameWrap.GetGame().SetAttrib("+sSettingName+", "+iValue.ToString()+")");
							else
								bUpdateBackup=true;
								pxGameplayOptionsNode^.SetValue(sSettingName, iConfValue);
								//KLog.LogSpam("Kr1s1m", pxMirageSettingsBackupNode^.Name() + "/" + sPath + " set to " + iConfValue.ToString());
							endif;
						endif;
					endfor;
				endif;
				var ^CPropDB.CNode pxAllowAlienCommandsNode = pxServerNode^.Get("AllowAlienCommands");
				if(pxAllowAlienCommandsNode!=null)then
					var string sSettingName = pxAllowAlienCommandsNode^.Name();
					var int iValue = pxAllowAlienCommandsNode^.ValueI();
					var string sPath = pxServerNode^.Name() + "/" + sSettingName;
					var int iConfValue = xConf.GetSetI(sPath, 0);
					if(iValue!=iConfValue)then
						if(p_bRestore)then
							xConf.SetI(sPath, iValue);
							//KLog.LogSpam("Kr1s1m", "UserProfile value " + sPath + " restored to " + iValue.ToString());
							CGameWrap.GetGame().SetAttrib(sSettingName, iValue);
							//KLog.LogSpam("Kr1s1m", "CGameWrap.GetGame().SetAttrib("+sSettingName+", "+iValue.ToString()+")");
						else
							bUpdateBackup=true;
							pxServerNode^.SetValue(sSettingName, iConfValue);
							//KLog.LogSpam("Kr1s1m", pxMirageSettingsBackupNode^.Name() + "/" + sPath + " set to " + iConfValue.ToString());
						endif;
					endif;
				endif;
			endif;
			if(pxGameNode!=null)then
				var ^CPropDB.CNode pxMPSettingsNode = pxGameNode^.Get("MPSettings");
				if(pxMPSettingsNode!=null)then
					var int i, iM=pxMPSettingsNode^.NumSubs();
					for(i=0)cond(i<iM)iter(i++)do
						var ^CPropDB.CNode pxMPSettingNode = ^(pxMPSettingsNode^.Get(i));
						var string sSettingName = pxMPSettingNode^.Name();
						var int iValue = pxMPSettingNode^.ValueI();
						var string sPath = pxGameNode^.Name() + "/" + pxMPSettingsNode^.Name() + "/" + sSettingName;
						var int iConfValue = xConf.GetSetI(sPath, 0);
						if(iValue!=iConfValue)then
							if(p_bRestore)then
								xConf.SetI(sPath, iValue);
								//KLog.LogSpam("Kr1s1m", "UserProfile value " + sPath + " restored to " + iValue.ToString());
								CGameWrap.GetGame().SetAttrib(sSettingName, iValue);
								//KLog.LogSpam("Kr1s1m", "CGameWrap.GetGame().SetAttrib("+sSettingName+", "+iValue.ToString()+")");
							else
								bUpdateBackup=true;
								pxMPSettingsNode^.SetValue(sSettingName, iConfValue);
								//KLog.LogSpam("Kr1s1m", pxMirageSettingsBackupNode^.Name() + "/" + sPath + " set to " + iConfValue.ToString());
							endif;
						endif;
					endfor;
				endif;
			endif;
			if(bUpdateBackup)then m_pxMirageSettingsBackupDB^.Save(m_sSettingsBackupPath+"/mirage_settings_backup.txt"); endif; //Kr1s1m: If mirage settings backup was updated, save it on disk.
		endif;
		//KLog.LogSpam("Kr1s1m", "MirageClnMgr:OperateMirageServerSettingsBackupDB end");
	endproc;
	
	export proc void BackupMirageServerSettings()
		var bool bRestore = false;
		OperateMirageServerSettingsBackupDB(bRestore);
	endproc;
	
	export proc void RestoreMirageServerSettings()
		var bool bRestore = true;
		OperateMirageServerSettingsBackupDB(bRestore);
	endproc;
	
	export proc void UpdateCustomMapAttribs(string p_sLevelName)
		//KLog.LogSpam("Kr1s1m", "MirageClnMgr:UpdateCustomMapAttribs("+p_sLevelName+") begin");
		if(m_pxCustomMapMirageSettingsDB==null)then return; endif;
		var ^CPropDB.CNode pxLevelsNode = m_pxCustomMapMirageSettingsDB^.Get("Levels");
		if(pxLevelsNode!=null)then
			p_sLevelName.Replace(" ", "_");
			var ^CPropDB.CNode pxLevelNameNode = pxLevelsNode^.Get(p_sLevelName);
			if(pxLevelNameNode!=null)then
				//KLog.LogSpam("Kr1s1m", pxLevelNameNode^.Name()+" custom map level matched");
				var ^CPropDB.CNode pxMirageSettingsNode = pxLevelNameNode^.Get("MirageSettings");
				if(pxMirageSettingsNode==null)then /*KLog.LogSpam("Kr1s1m", "Mirage settings not found");*/ return; endif;
				var CConfig xConf;
				var int k, kC=pxMirageSettingsNode^.NumSubs();
				for(k=0)cond(k<kC)iter(k++)do//Kr1s1m: Iterate the adjust categories inside the level name node
					var ^CPropDB.CNode pxAdjustCategoryNode = ^(pxMirageSettingsNode^.Get(k));
					//KLog.LogSpam("Kr1s1m", "adjusting "+pxAdjustCategoryNode^.Name()+" mirage settings");
					var int i, iC=pxAdjustCategoryNode^.NumSubs();
					for(i=0)cond(i<iC)iter(i++)do//Kr1s1m: Iterate the setting types inside a given adjust category node
						var ^CPropDB.CNode pxSettingTypeNode = ^(pxAdjustCategoryNode^.Get(i));
						var string sSettingType = pxSettingTypeNode^.Name();
						var int j, jC=pxSettingTypeNode^.NumSubs();
						for(j=0)cond(j<jC)iter(j++)do//Kr1s1m: Iterate the setting nodes inside a given setting type node
							var ^CPropDB.CNode pxSettingNode = ^(pxSettingTypeNode^.Get(j));
							var string sSettingName = pxSettingNode^.Name();
							var int iValue = pxSettingNode^.ValueI();
							var string sPath = "Server/GameplayOptions/";
							//Kr1s1m: Exception for AllowAlienCommands, since we can't put it inside GameplayOptions w/out editing the exe...
							if(sSettingName=="AllowAlienCommands")then sPath="Server/";/*Kr1s1m: ...path hardcoded in exe*/ endif;
							xConf.SetI(sPath+sSettingName, iValue);
							CGameWrap.GetGame().SetAttrib(sSettingName, iValue);
							//KLog.LogSpam("Kr1s1m", "CGameWrap.GetGame().SetAttrib("+sSettingName+", "+iValue.ToString()+")");
						endfor;
					endfor;
				endfor;
			else
				//KLog.LogSpam("Kr1s1m", p_sLevelName+" is not a custom map. Nothing has been updated.");
				return;
			endif;
		endif;
		//KLog.LogSpam("Kr1s1m", "MirageClnMgr:UpdateCustomMapAttribs("+p_sLevelName+") end");
	endproc;
	
	export static proc void UpdateCustomMapBoniTotal(string p_sCurLevel)
		//KLog.LogSpam("Kr1s1m", "MirageClnMgr:UpdateCustomMapBoniTotal begin");
		//KLog.LogSpam("Kr1s1m", "-------> Custom Multiplayer Campaign "+p_sCurLevel+" completed <--------");
		p_sCurLevel.Replace(" ","_");
		p_sCurLevel.MakeLower();
		if(p_sCurLevel=="single_b43")then return; endif; //Kr1s1m: ... single_04, [single_b41, ... , single_b43], single_05 ...
		var ^CPropDB pxUserProfile=^(CClientWrap.GetUserProfile());
		var ^CPropDB.CNode pxMultiplayerCampaignNode=^(pxUserProfile^.GetRoot().Get("MultiplayerCampaign"));
		if(pxMultiplayerCampaignNode!=null)then//Kr1s1m: If MultiplayerCampaign node is now valid, handle boni 
			var ^CPropDB.CNode pxLevelsNode=pxMultiplayerCampaignNode^.Get("Levels");
			if(pxLevelsNode!=null)then
				var int iNumLevels=pxLevelsNode^.NumSubs();
				var int iCurLevelIdx=pxLevelsNode^.Find(p_sCurLevel);
				if(iNumLevels>0 && iCurLevelIdx>-1 && iCurLevelIdx<(iNumLevels-1))then
					var int iNextLevelIdx=iCurLevelIdx+1;
					if(p_sCurLevel=="single_04")then//Kr1s1m: ... single_04, [single_b41, ... , single_b43], single_05 ...
						iNextLevelIdx=pxLevelsNode^.Find("single_05");
					endif;
					var ^CPropDB.CNode pxNextLevelNode=^((pxLevelsNode^)[iNextLevelIdx]);
					var ^CLevelInfo pxLevelInfo=^(CGameWrap.GetClient().GetLevelInfo());
					var ^CGameAttribs pxAttribs=^(pxLevelInfo^.GetAttribs());
					var int iLevelBoni=pxAttribs^.GetValueInt("BoniTotal");
					var int iCurCredits=pxNextLevelNode^.GetValueI("Credits",0);
					if(iLevelBoni>iCurCredits)then
						pxNextLevelNode^.SetValue("Credits",iLevelBoni);
						//KLog.LogSpam("Kr1s1m", "-------> "+pxNextLevelNode^.Name()+" Boni updated to "+iLevelBoni.ToString()+" <--------");
					endif;
					CClientWrap.UpdateUserProfile();
				endif;
			endif;
		endif;
		//KLog.LogSpam("Kr1s1m", "MirageClnMgr:UpdateCustomMapBoniTotal end");
	endproc;
	
	export static proc void ExtractCustomMapPoints(ref array string p_rasCustomLevels, ref array int p_raiCustomPoints)
		//KLog.LogSpam("Kr1s1m", "MirageClnMgr:ExtractCustomMapPoints begin");
		var CPropDB pxMultiplayerCampaignsDB;
		var ^CPropDB pxUserProfile=^(CClientWrap.GetUserProfile());
		var ^CPropDB.CNode pxMultiplayerCampaignNode=^(pxUserProfile^.GetRoot().Get("MultiplayerCampaign"));
		if(pxMultiplayerCampaignNode==null)then//Kr1s1m: If the MultiplayerCampaign node is not present in profile_user.cfg then...
			pxMultiplayerCampaignsDB.Load(CClientWrap.GetUrsRelPath()+"/data/base/scripts/server/settings/MultiplayerCampaigns.txt");
			//Kr1s1m: ...fallback to loading it from the MultiplayerCampaigns.txt config template...
			pxMultiplayerCampaignNode=pxMultiplayerCampaignsDB.GetRoot().Get("MultiplayerCampaign");
			//Kr1s1m: ...and save it inside the user profile for next time
			begin SaveMultiplayerCampaignsTemplateIntoUserProfile;
				if(pxMultiplayerCampaignNode!=null && ^(pxUserProfile^.GetRoot())!=null)then
					var ^CPropDB pxSave=new CPropDB();//Kr1s1m: Init the db to insert and save inside user profile
					var ^CPropDB.CNode pxSaveRoot=^(pxSave^.GetRoot());
					pxSaveRoot^.Name()="Levels";//Kr1s1m: Rename the root of the save db to Levels
					var ^CPropDB.CNode pxLevelsNode=pxMultiplayerCampaignNode^.Get("Levels");
					if(pxLevelsNode!=null)then
						var int i, iL=pxLevelsNode^.NumSubs();
						for(i=0)cond(i<iL)iter(i++)do//Kr1s1m: Iterate the template's level nodes under Levels node...
							//Kr1s1m: ...and insert them under save db root Levels node
							(pxSaveRoot^.Insert(i))^=pxLevelsNode^.Get(i);
						endfor;
						//Kr1s1m: insert the prepared save db inside user profile at new path MultiplayerCampaign/Levels
						(pxUserProfile^)["MultiplayerCampaign/Levels"] = pxSaveRoot^;
						//Kr1s1m: Update user profile cfg file on disk
						CClientWrap.UpdateUserProfile();
						//KLog.LogSpam("Kr1s1m-ALERT", "MultiplayerCampaign tree created in profile_user.cfg");
					endif;
				endif;
			end SaveMultiplayerCampaignsTemplateIntoUserProfile;
		endif;
		//Kr1s1m: If MultiplayerCampaign node is now valid, extract the custom points information from it into arrays
		if(pxMultiplayerCampaignNode!=null)then
			var ^CPropDB.CNode pxLevelsNode=pxMultiplayerCampaignNode^.Get("Levels");
			if(pxLevelsNode!=null)then
				var int i, iL=pxLevelsNode^.NumSubs();
				for(i=0)cond(i<iL)iter(i++)do//Kr1s1m: Iterate the level nodes under Level node
					var ^CPropDB.CNode pxLevelNode = ^(pxLevelsNode^.Get(i));
					if(pxLevelNode!=null)then
						var string sLevelName = pxLevelNode^.Name();
						p_rasCustomLevels.AddEntry(sLevelName); //Kr1s1m: Save the name of the level node
						var int iCredits = pxLevelNode^.GetValueI("Credits");
						var int iMinCredits = pxLevelNode^.GetValueI("MinCredits");
						if(iCredits < iMinCredits)then//Kr1s1m: If min points > boni collected from quests...
							iCredits = iMinCredits;//Kr1s1m: ...prefer min points value.
						endif;
						p_raiCustomPoints.AddEntry(iCredits);//Kr1s1m: Save the greater value between nodes Credits and MinCredits
					endif;
				endfor;
				//KLog.LogSpam("Kr1s1m", "-------> Custom Multiplayer Campaign [PointBuy data] generated <--------");
			endif;
		endif;
		//KLog.LogSpam("Kr1s1m", "CMirageClnMgr:ExtractCustomMapPoints end");
	endproc;
	
	export static proc bool IsWinReason(string p_sReason)
		var ^CPropDB pxWinReasons = new CPropDB();
		if(!pxWinReasons^.Load(CClientWrap.GetUrsRelPath() + "/Data/Base/Scripts/Game/misc/win_reasons.txt"))then return false; endif;
		//var ^CPropDB.CNode pxReasons = ^(pxWinReasons^.GetRoot());
		//if(pxReasons^.NumSubs() < 1)then return false; endif;
		if(pxWinReasons^.FindNode(p_sReason, false) != null)then return true; endif;
		return false;
	endproc;
	
	export static proc bool AllowRetry(^CLevelInfo p_pxLevelInfo)
		var string sName;
		if(p_pxLevelInfo==null)then return true; endif;
		var ^CPropDB.CNode pxBaseNode=p_pxLevelInfo^.GetGenericData().FindNode("Base",false);
		if(pxBaseNode!=null)then
			sName=pxBaseNode^.GetValueS("LevelName");
		endif;
		if(sName=="_CU_MP_6_CRASH_RPG")then
			return false;
		endif;
		return true;
	endproc;
	
	///////
	//	GetHostMapInfo()
	//	This function gets MapInfo of currently selected map
	//	Warning! Do not use this function for non Host Clients
	///////
	export proc ^CMapInfoList.CMapInfo GetHostMapInfo()
		var string sFileName=CClientWrap.GetUserProfileValue("Multiplayer/LastSelectedMap","");
		//Adding MapInfoList
		var ^CMapInfoList pxMapInfoList=CMultiPlayerClientMgr.Get().GetMapInfoList();
		//
		return (pxMapInfoList^.GetMapInfo(sFileName));
	endproc;
	
	export static proc bool HostDifficulty(^CLevelInfo p_pxLevelInfo)
		var string sName;
		if(p_pxLevelInfo==null)then return false; endif;
		var ^CPropDB.CNode pxBaseNode=p_pxLevelInfo^.GetGenericData().FindNode("Base",false);
		if(pxBaseNode!=null)then
			sName=pxBaseNode^.GetValueS("LevelName");
		endif;
		if(sName=="_CU_MP_6_CRASH_RPG")then
			return true;
		endif;
		return false;
	endproc;
	
	export static proc void SetMapDifficulty(int p_iDifficulty)
		var ^CPropDB pxUserProfile=^(CClientWrap.GetUserProfile());
		if(pxUserProfile^.FindNode("Multiplayer/Difficulty",false) == null)then
			pxUserProfile^.FindNode("Multiplayer/Difficulty",true);
			CClientWrap.UpdateUserProfile();
		endif;
		if(p_iDifficulty!=CGameWrap.GetGame().GetAttribInt("LobbyDifficulty"))then
			CGameWrap.GetGame().SetAttrib("LobbyDifficulty",p_iDifficulty);
		endif;
		CClientWrap.SetUserProfileValue("Multiplayer/Difficulty",p_iDifficulty);
	endproc;
	
	export static proc int GetMapDifficulty()
		if(CGameWrap.GetClientID()==CMultiPlayerClientMgr.Get().GetHostID())then
			return CClientWrap.GetUserProfileValueI("Multiplayer/Difficulty",1);
		else
			return CGameWrap.GetGame().GetAttribInt("LobbyDifficulty");
		endif;
	endproc;
	
	export proc bool IsOkAndReadyForAction(string p_sTTName, CClntHndl p_xHandle, ref bool p_rbLocked, bool p_bMultiSelection)
		if(!p_xHandle.IsValid())then return false; endif;
		var ^CObj pxActor = p_xHandle.GetObj();
		if(pxActor==null)then return false; endif;
		var ^CAttribs pxAttr = pxActor^.GetAttribs();
		if(pxAttr==null)then return false; endif;
		if(pxAttr^.GetValueBool("is_locked"))then
			p_rbLocked=p_bMultiSelection;
			return false;
		else
			p_rbLocked=false;
		endif;
		// Henry: if having the ability itself
		var CTechTree xObjTT;
		var ^CTechTree.CNode pxOwnNode;
//		if(!pxActor^.HasTechTree())then return false; endif;
		xObjTT = pxActor^.GetTechTree();
		pxOwnNode = xObjTT.FindNode(p_sTTName);
		if(pxOwnNode==null)then return false; endif;
		// Henry: if action is visible and not disabled...
		if(!pxOwnNode^.IsVisible())then return false; endif;
		if(pxOwnNode^.GetSubValueI("visibility", 0)!=1)then return false; endif;
		if(pxOwnNode^.GetSubValueI("disabled", 0)==1)then return false; endif;
		var ^CTechTree.CNode pxLocations = pxOwnNode^.GetSub("locations");
		if(pxLocations != null)then
			var bool bFound = false;
			var int i, iC = pxLocations^.NumSubs();
			for(i=0)cond(i<iC)iter(++i)do
				var ^CTechTree.CNode pxLocation = pxLocations^.GetSub(i);
				if(pxLocation==null)then
					continue;
				endif;
				var string sVal = pxLocation^.GetValue();
				var int iPos = sVal.FindRev('/');
				if(iPos != -1)then
					sVal = sVal.Mid(iPos + 1);
					if(sVal==pxActor^.GetClassName()||pxActor^.GetType()==sVal)then
						var ^CTechTree.CNode pxLocalFlags=pxLocation^.GetSub("localflags");
						if(pxLocalFlags!=null)then
							var int j,iJC=pxLocalFlags^.NumSubs();
							for(j=0)cond(j<iJC)iter(j++)do
								var string sFlag=pxLocalFlags^.GetSub(j)^.GetName();
								if(pxLocalFlags^.GetSub(j)^.GetValueI()==1&&sFlag==pxAttr^.GetValue("ObjFlag"))then
									bFound = true;
									break;
								endif;
							endfor;
						else
							bFound = true;
							break;
						endif;
					endif;
				endif;
			endfor;
			if(!bFound)then return false; endif;
		endif;
		// Henry: having a cooldown of that ability
		var string sSpecial = pxAttr^.GetValue("SpecialActionNames");
		if(!sSpecial.IsEmpty())then
			var array string asActions;
			sSpecial.Split(asActions, "\n", true);
			var int i, iC = asActions.NumEntries();
			for(i=0)cond(i<iC)iter(++i)do
				if(p_sTTName.Find(asActions[i])!=-1)then
					return false;
				endif;
			endfor;
		endif;
		// Henry: have a local upgrade...
		var string sLocalUpgrade = pxAttr^.GetValue("LocalUpgrade");
		if(sLocalUpgrade.IsEmpty()== false && !IsMinorLocalUpgrade(sLocalUpgrade))then
			return false;
		endif;
		// Henry: preparing to execute action
		var string sPrepare = pxAttr^.GetValue("PrepareActionNames");
		if(!sPrepare.IsEmpty())then
			var array string asActions;
			sPrepare.Split(asActions, "\n", true);
			var int i, iC = asActions.NumEntries();
			for(i=0)cond(i<iC)iter(++i)do
				if(p_sTTName.Find(asActions[i])!=-1)then
					return false;
				endif;
			endfor;
		endif;
		// Henry: passed through every filter, hurray :)
		return true;
	endproc;
	
	export proc bool IsOkAndReadyForAction(string p_sTTName, CClntHndl p_xHandle)
		if(!p_xHandle.IsValid())then return false; endif;
		var ^CObj pxActor = p_xHandle.GetObj();
		if(pxActor==null)then return false; endif;
		var ^CAttribs pxAttr = pxActor^.GetAttribs();
		if(pxAttr==null)then return false; endif;
		// Henry: if having the ability itself
		var CTechTree xObjTT;
		var ^CTechTree.CNode pxOwnNode;
		xObjTT = pxActor^.GetTechTree();
		pxOwnNode = xObjTT.FindNode(p_sTTName);
		if(pxOwnNode==null)then return false; endif;
		// Henry: if action is visible and not disabled...
		if(!pxOwnNode^.IsVisible())then return false; endif;
		if(pxOwnNode^.GetSubValueI("visibility", 0)!=1)then return false; endif;
		if(pxOwnNode^.GetSubValueI("disabled", 0)==1)then return false; endif;
		var ^CTechTree.CNode pxLocations = pxOwnNode^.GetSub("locations");
		if(pxLocations != null)then
			var bool bFound = false;
			var int i, iC = pxLocations^.NumSubs();
			for(i=0)cond(i<iC)iter(++i)do
				var ^CTechTree.CNode pxLocation = pxLocations^.GetSub(i);
				if(pxLocation==null)then
					continue;
				endif;
				var string sVal = pxLocation^.GetValue();
				var int iPos = sVal.FindRev('/');
				if(iPos != -1)then
					sVal = sVal.Mid(iPos + 1);
					if(sVal==pxActor^.GetClassName()||pxActor^.GetType()==sVal)then
						var ^CTechTree.CNode pxLocalFlags=pxLocation^.GetSub("localflags");
						if(pxLocalFlags!=null)then
							var int j,iJC=pxLocalFlags^.NumSubs();
							for(j=0)cond(j<iJC)iter(j++)do
								var string sFlag=pxLocalFlags^.GetSub(j)^.GetName();
								if(pxLocalFlags^.GetSub(j)^.GetValueI()==1&&sFlag==pxAttr^.GetValue("ObjFlag"))then
									bFound = true;
									break;
								endif;
							endfor;
						else
							bFound = true;
							break;
						endif;
					endif;
				endif;
			endfor;
			if(!bFound)then return false; endif;
		endif;
		// Henry: having a cooldown of that ability
		var string sSpecial = pxAttr^.GetValue("SpecialActionNames");
		if(!sSpecial.IsEmpty())then
			var array string asActions;
			sSpecial.Split(asActions, "\n", true);
			var int i, iC = asActions.NumEntries();
			for(i=0)cond(i<iC)iter(++i)do
				if(p_sTTName.Find(asActions[i])!=-1)then
					return false;
				endif;
			endfor;
		endif;
		// Henry: have a local upgrade...
		var string sLocalUpgrade = pxAttr^.GetValue("LocalUpgrade");
		if(sLocalUpgrade.IsEmpty()== false && !IsMinorLocalUpgrade(sLocalUpgrade))then
			return false;
		endif;
		// Henry: preparing to execute action
		var string sPrepare = pxAttr^.GetValue("PrepareActionNames");
		if(!sPrepare.IsEmpty())then
			var array string asActions;
			sPrepare.Split(asActions, "\n", true);
			var int i, iC = asActions.NumEntries();
			for(i=0)cond(i<iC)iter(++i)do
				if(p_sTTName.Find(asActions[i])!=-1)then
					return false;
				endif;
			endfor;
		endif;
		// Henry: passed through every filter, hurray :)
		return true;
	endproc;
	
	export proc bool ChangeFocus()
		var bool bUpdate = false;
		var bool bKeep = true;
		if(InterListChange())then
			m_xSelection = CClientWrap.GetSelection();
			m_sFocusClass = "";
			m_sSpecialFocus = "";
			m_bFocusBldg = false;
			m_asClasses = 0;
			m_asValidNames = 0;
			bUpdate = true;
			bKeep = false;
		elseif(m_xSelection.NumEntries()<=0)then
			m_xSelection = CClientWrap.GetSelection();
			m_sFocusClass = "";
			m_sSpecialFocus = "";
			m_bFocusBldg = false;
			m_asClasses = 0;
			bUpdate = true;
			bKeep = false;
		elseif(!CClientWrap.GetSelection().IsEqual(m_xSelection))then
			m_xSelection = CClientWrap.GetSelection();
			var int i, iC = m_asClasses.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				if(!HaveObjOfClass(m_xSelection, m_asClasses[i]))then
					m_asClasses.DeleteEntry(i); i--; iC--;
				endif;
			endfor;
			if(m_asClasses.FindEntry(m_sFocusClass)==-1||m_sFocusClass=="")then
				bKeep = false;
			endif;
			bUpdate = true;
		endif;
		if(bUpdate)then
			var int i, iC = m_xSelection.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				var string sClass;
				if(!CMirageClnMgr.ValidateName(sClass, m_xSelection[i]))then continue; endif;
				m_asValidNames.AddEntry(sClass);
				if(m_asClasses.FindEntry(sClass)!=-1)then
					continue;
				else
					m_asClasses.AddEntry(sClass);
				endif;
			endfor;
			if(m_asClasses.NumEntries()>0 && !bKeep)then
				m_sFocusClass = m_asClasses[0];
				m_sSpecialFocus=GetSpecialFocus(m_sFocusClass);
			endif;
		endif;
		return true;
	endproc;
	
	export proc bool InterListChange()
		var int i, iC = m_xSelection.NumEntries();
		if(m_asValidNames.NumEntries()!=iC)then return true; endif;
		for(i=0)cond(i<iC)iter(i++)do
			var string sClass;
			if(!CMirageClnMgr.ValidateName(sClass, m_xSelection[i]))then return true; endif;
			if(m_asValidNames[i]!=sClass)then
				return true;
			endif;
		endfor;
		return false;
	endproc;
	
	export proc string GetFocusClass()
		return m_sFocusClass;
	endproc;
	
	export proc string GetSpecialFocus()
		return m_sSpecialFocus;
	endproc;
	
	export proc string GetFocusClass(ref string p_rsSpecial, ref bool p_rbBldg)
		p_rsSpecial=m_sSpecialFocus;
		p_rbBldg=m_bFocusBldg;
		return m_sFocusClass;
	endproc;
	
	export proc bool SetFocusFW()
		var bool bUpdate = ChangeFocus();
		//if(!bUpdate)then
			//return false;
		//endif;
		var int iNum = m_asClasses.NumEntries();
		if(iNum <= 0)then return false; endif;
		var int iPos = m_asClasses.FindEntry(m_sFocusClass);
		if(iPos==-1)then return false; endif;
		iPos++;
		if(iPos >= iNum)then
			iPos = 0;
		endif;
		m_sFocusClass = m_asClasses[iPos];
		var bool bPrev=m_bFocusBldg;
		var string sPrev=m_sSpecialFocus;
		m_sSpecialFocus=GetSpecialFocus(m_sFocusClass);
		var bool bRelevant=m_sSpecialFocus!=sPrev||m_bFocusBldg!=bPrev||m_bFocusBldg;
		if(CUIStateMgr.Get().GetInGameScreen()!=null)then
			CUIStateMgr.Get().GetInGameScreen()^.OnChangeFocus(bRelevant);
//			CUIStateMgr.Get().GetInGameScreen()^.OnChangeSelection();
		endif;
		return true;
	endproc;
	
	export proc bool SetFocusBW()
		var bool bUpdate = ChangeFocus();
		//if(!bUpdate)then
			//return false;
		//endif;
		var int iNum = m_asClasses.NumEntries();
		if(iNum <= 0)then return false; endif;
		var int iPos = m_asClasses.FindEntry(m_sFocusClass);
		if(iPos==-1)then return false; endif;
		iPos--;
		if(iPos < 0)then
			iPos = iNum - 1;
		endif;
		m_sFocusClass = m_asClasses[iPos];
		var bool bPrev=m_bFocusBldg;
		var string sPrev=m_sSpecialFocus;
		m_sSpecialFocus=GetSpecialFocus(m_sFocusClass);
		var bool bRelevant=m_sSpecialFocus!=sPrev||m_bFocusBldg!=bPrev||m_bFocusBldg;
		if(CUIStateMgr.Get().GetInGameScreen()!=null)then
			CUIStateMgr.Get().GetInGameScreen()^.OnChangeFocus(bRelevant);
//			CUIStateMgr.Get().GetInGameScreen()^.OnChangeSelection();
		endif;
		return true;
	endproc;
	
	proc string GetSpecialFocus(string p_sFocus)
		//Kr1s1m: TechtreeSteal is now always on. Foreign tribe active and passive specials always work.
		//Kr1s1m: Server setting still prevents placing foreign tribe buildings when TechtreeSteal is disabled.
		//if(!CheckTechtreeSteal())then
			//if(!p_sFocus.IsEmpty())then
				//m_bFocusBldg=m_asBuildings.FindEntry(p_sFocus)!=-1;
			//endif;
			//return m_sPlayerTribe;
		//endif;
		var string sSpecial;
		if(p_sFocus.IsEmpty())then return sSpecial; endif;
		if(p_sFocus.Left(4)=="aje_")then
			sSpecial="Aje";
		elseif(p_sFocus.Left(3)=="hu_")then
			sSpecial="Hu";
		elseif(p_sFocus.Left(7)=="ninigi_")then
			sSpecial="Ninigi";
		elseif(p_sFocus.Left(5)=="seas_")then
			sSpecial="SEAS";
		elseif(m_asCrashRPGChars.FindEntry(p_sFocus)!=-1)then
			sSpecial="World";
		elseif(m_asValidNPCs.FindEntry(p_sFocus)!=-1)then
			sSpecial=m_sPlayerTribe;
		endif;
		m_bFocusBldg=m_asBuildings.FindEntry(p_sFocus)!=-1;
		return sSpecial;
	endproc;
	
	proc bool HaveObjOfClass(CObjList p_xList, string p_sClass)
		if(p_xList.NumEntries()<=0)then return false; endif;
		var int i, iC = p_xList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var string sClass;
			if(!CMirageClnMgr.ValidateName(sClass, p_xList[i]))then continue; endif;
			if(sClass==p_sClass)then
				return true;
			endif;
		endfor;
		return false;
	endproc;
	
	export proc CObjList GetFocusList(CObjList p_xList, bool p_bBldg)
		if(p_bBldg&&!m_bFocusBldg)then
			return p_xList;
		else
			return GetFocusList(p_xList);
		endif;
	endproc;
	
	export proc CObjList GetFocusList(CObjList p_xList)
//		if(true)then return p_xList; endif;
		//Henry: will later on continue...
		var bool bUpdate = ChangeFocus();
		if(m_sFocusClass=="")then return p_xList; endif;
		var CObjList xFilteredList;
		var int i,iC = p_xList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var string sClass;
			if(!CMirageClnMgr.ValidateName(sClass, p_xList[i]))then continue; endif;
			if(sClass==m_sFocusClass)then
				xFilteredList.AddEntry(p_xList[i]);
			endif;
		endfor;
		return xFilteredList;
	endproc;
	
	//Henry: thanks to AyCe
	export static proc bool GetLevelData(^CLevelInfo p_pxLevelInfo, ref string po_rsAuthor, ref string po_rsVersion)
		po_rsAuthor.Empty();
		po_rsVersion.Empty();
		var ^CPropDB.CNode pxBaseNode=p_pxLevelInfo^.GetGenericData().FindNode("Base",false);
		if(pxBaseNode==null||pxBaseNode^.NumSubs()==0)then
			var ^CGameAttribs pxAttribs=^(p_pxLevelInfo^.GetAttribs());
			po_rsAuthor = pxAttribs^.GetValue("Author");
			po_rsVersion = pxAttribs^.GetValue("Edit_Version");
		else
			po_rsAuthor = pxBaseNode^.GetValueS("Author","");
			po_rsVersion = pxBaseNode^.GetValueS("Edit_Version","");
		endif;
		return true;
	endproc;
	
	export static proc string GetPreviewImageDataFromDB(string p_sLevelName)
		p_sLevelName.Replace(" ", "_");
		p_sLevelName.MakeLower();
		var CPropDB xPreviewImageDB;
		xPreviewImageDB.Load(CClientWrap.GetUrsRelPath()+"/data/base/scripts/game/misc/PreviewImages.txt");
		var string sImagePath;
		var ^CPropDB.CNode pxLevelsNode = xPreviewImageDB.GetRoot().Get("Levels");
		if(pxLevelsNode!=null)then
			var ^CPropDB.CNode pxLevelNode = pxLevelsNode^.Get(p_sLevelName);
			if(pxLevelNode!=null)then
				pxLevelNode^.GetValue("image",sImagePath);
			endif;
		endif;
		return sImagePath;
	endproc;
	
	export static proc bool GetServerIP(ref string p_rsIP)
//		var string sFile = CClientWrap.GetUrsRelPath() + "/Data/Base/Scripts/Game/misc/ip.txt";
		var string sFile = CSettings.GetAppTempDir() + "paraworld_ip.txt";
		if(!Filesystem.FileExists(sFile))then return false; endif;
		var Filesystem.CFile xFile;
		xFile.OpenRead(sFile);
		p_rsIP=xFile.GetLn();
		xFile.Close();
		return true;
	endproc;
	
	export proc void SetSequence(bool p_bPlaying)
		m_bIsPlayingSequence = p_bPlaying;
	endproc;
	
	export proc bool GetSequence()
		return m_bIsPlayingSequence;
	endproc;
	
	export proc void SetPaused(int p_iPlayer, bool p_bPaused)
		if(p_bPaused)then
			if(m_aiIsPaused.FindEntry(p_iPlayer)==-1)then
				m_aiIsPaused.AddEntry(p_iPlayer);
			endif;
		elseif(m_aiIsPaused.NumEntries()>0)then
			if(m_aiIsPaused.FindEntry(p_iPlayer)!=-1)then
				m_aiIsPaused.RemEntry(p_iPlayer);
			endif;
		endif;
	endproc;
	
	//export proc void PlayDieAck(int p_iIndexVoice, vec3 p_vPos)
	export proc void PlayDieAck(int p_iIndexVoice, int p_iIndexUI)
		if(m_bAbandon||m_bIsPlayingSequence||!m_abFeedbacks[FB_DEATH])then return; endif;
//		var CConfig xConf;
//		if(!xConf.GetSetB("Client/GlobalSoundFeedbacks/Death",true))then return; endif;
		if(m_pxDieAck==null||(p_iIndexVoice < 0 && p_iIndexUI < 0))then return; endif;
		var string sVoiceEvent, sUIEvent = "";
		var ^CPropDB.CNode pxVoiceEvent = ^(m_pxDieAck^.Get(p_iIndexVoice));
		if(pxVoiceEvent!=null)then
			sVoiceEvent = pxVoiceEvent^.Name();
		endif;
		if(p_iIndexUI > -1)then
			var ^CPropDB.CNode pxUIEvent = ^(m_pxDieAck^.Get(p_iIndexUI));
			if(pxUIEvent!=null)then
				sUIEvent = pxUIEvent^.Name();
			endif;
		endif;
//		if(!sVoiceEvent.IsEmpty())then
//			CGameInputController.ms_xUISoundMgr.InvokeFeedbackSoundEvent(sVoiceEvent,CSoundMgrCln.SOUND_VOLTRACK_SPEECH_ACK,-1);
//		else
//			CGameInputController.ms_xUISoundMgr.InvokeFeedbackSoundEvent(sUIEvent,CSoundMgrCln.SOUND_VOLTRACK_GLOBAL);
//		endif;
		if(!sUIEvent.IsEmpty())then
			CGameInputController.ms_xUISoundMgr.PlayFeedbackSoundEvent(sUIEvent,"",CSoundMgrCln.SOUND_VOLTRACK_GLOBAL);
		endif;
		if(!sVoiceEvent.IsEmpty())then
		//elseif(!sVoiceEvent.IsEmpty())then
			CGameInputController.ms_xUISoundMgr.PlayFeedbackSoundEvent(sVoiceEvent,"",CSoundMgrCln.SOUND_VOLTRACK_SPEECH_ACK);
		endif;
		//CGameWrap.GetSoundEventMgrClient().Play3DSound(sEvent,p_vPos);
		//endif;
	endproc;
	
	export proc void Abandon()
		m_bAbandon = true;
	endproc;
	
	export static proc string EffectName(int p_iIndex)
		var string sEffect = "";
		switch(p_iIndex)
			case(0)do sEffect = "CNiBigBert"; endcase;
			case(1)do sEffect = "CHitObjNiExpB"; endcase;
			case(2)do sEffect = "CHitObjSeExpB"; endcase;
			case(3)do sEffect = "CHitLanAshExpB"; endcase;
			case(4)do sEffect = "CMineExplo"; endcase;
			case(5)do sEffect = "CFxCraterB"; endcase;
			case(6)do sEffect = "CVehicleExplosion"; endcase;
			case(7)do sEffect = "CShadowCloneBanish"; endcase;
			case(8)do sEffect = "CHitObjAjExpB"; endcase;
			case(9)do sEffect = "CExploMineTrapSmall"; endcase;
			case(10)do sEffect = "CExploMineTrapBig"; endcase;
			case default do endcase;
		endswitch;
		return sEffect;
	endproc;
	
	export static proc int GetReactorActionNumber(^CAttribs p_pxAttr, ref int p_riProgress)
		if(p_pxAttr==null)then return 0; endif;
		var int iNum = 0;
		var string sQueue=p_pxAttr^.GetValue("ReactorProdQueue");
		if(!sQueue.IsEmpty())then
			var array string asToks;
			sQueue.Split(asToks, ":", true);
			iNum = asToks.NumEntries();
		endif;
		p_riProgress = p_pxAttr^.GetValueInt("ReactorCurProcess");
		return iNum;
	endproc;
	
	export static proc int GetReactorInfo(^CAttribs p_pxAttr, ref int p_riProgress, ref string p_rsCurObject, int p_iNodeUID)
		if(p_pxAttr==null)then return 0; endif;
		var int iNum = 0;
		var string sQueue=p_pxAttr^.GetValue("ReactorProdQueue");
		if(!sQueue.IsEmpty())then
			var array string asToks;
			sQueue.Split(asToks, ":", true);
			var int i, iC = asToks.NumEntries();
			for(i=0)cond(i<iC)iter(++i)do
				if(asToks[i].ToInt()==p_iNodeUID)then
					++iNum;
				endif;
			endfor;
		endif;
		p_riProgress = p_pxAttr^.GetValueInt("ReactorCurProcess");
		p_rsCurObject = p_pxAttr^.GetValue("ReactorCurProcessObj");
		return iNum;
	endproc;
	
	export static proc void JoinStringArrays(ref array string po_rasA,ref array string p_rasB)
		var int i,iC=p_rasB.NumEntries(),iA=po_rasA.NumEntries();
		po_rasA+=iC;
		for(i=0) cond(i<iC) iter(i++) do
			po_rasA[iA+i]=p_rasB[i];
		endfor;
	endproc;
	
	export static proc void JoinStringArrays(ref array string po_rasA,ref array string p_rasB, ref int p_riIndex)
		var int i,iC=p_rasB.NumEntries(),iA=p_riIndex=po_rasA.NumEntries();
		po_rasA+=iC;
		for(i=0) cond(i<iC) iter(i++) do
			po_rasA[iA+i]=p_rasB[i];
		endfor;
	endproc;
	
	export proc CClntHndl GetGPCE()
		if(!CMirageClnMgr.ms_xGPCE.IsValid())then
			var CClntHndl xInv;
			var ^CPlayer pxPlayer = ^(CGameWrap.GetClient().GetPlayer());
			if(pxPlayer==null)then return xInv; endif;
			m_sPlayerTribe=pxPlayer^.GetPlayerSlot()^.GetTribe();
			var ^CAttribs pxAttribs = pxPlayer^.GetAttribs();
			if(pxAttribs==null)then return xInv; endif;
			var string sGuid = pxAttribs^.GetValue("gpce_own");
			if(sGuid.IsEmpty())then return xInv; endif;
			var CGuid xG;
			xG.FromString(sGuid);
			var ^CObj pxGPCE = CClientWrap.GetObjMgr().GetObj(xG);
			if(pxGPCE==null)then return xInv; endif;
			CMirageClnMgr.ms_xGPCE = pxGPCE^.GetHandle();
		endif;
		return CMirageClnMgr.ms_xGPCE;
	endproc;
	
	class CPropDBSorter
	
		export var string m_sName;
		export var string m_sValue1;
		export var string m_sValue2;
	
		export proc bool op_Equal(ref CMirageClnMgr.CPropDBSorter p_rxOther)
			return (m_sValue1==p_rxOther.m_sValue1);
		endproc;
	
		export proc bool op_Greater(ref CMirageClnMgr.CPropDBSorter p_rxOther)
			return m_sValue1>p_rxOther.m_sValue1;
		endproc;
	
	endclass;
	
	export static proc void SortPropDBHotkey()
		var array CMirageClnMgr.CPropDBSorter axSortArray;
		var ^CPropDB pxOriginal = new CPropDB, pxNew = new CPropDB;
//		if(pxOriginal^.Load(CClientWrap.GetUrsRelPath()+"/Data/Base/Scripts/Server/settings/unsorted_hotkeys.txt"))then
		if(pxOriginal^.Load("C:/unsorted_hotkeys.txt"))then
			var ^CPropDB.CNode pxRoot = ^(pxOriginal^.GetRoot());
			var int i, iC = pxRoot^.NumSubs();
			for(i=0)cond(i<iC)iter(i++)do
				var ^CPropDB.CNode pxOld=^(pxRoot^.Get(i));
				if(pxOld!=null)then
					var string sV1=pxOld^.GetValueS("Action",""), sV2=pxOld^.GetValueS("Shortcut","");
					if(sV1.IsEmpty()||sV2.IsEmpty())then CMirageClnMgr.Debug("a value or more empty"); continue; endif;
					var CMirageClnMgr.CPropDBSorter xTemp;
					xTemp.m_sValue1=sV1;
					var int iIdx=axSortArray.FindEntry(xTemp);
					if(iIdx==-1)then
						var ^CMirageClnMgr.CPropDBSorter pxSorter=^(axSortArray.NewEntryRef());
						pxSorter^.m_sValue1=sV1;
						pxSorter^.m_sValue2=sV2;
					endif;
				endif;
			endfor;
//			axSortArray.QSort();
			iC=axSortArray.NumEntries();
			if(iC>0)then
				var ^CPropDB.CNode pxNewRoot = ^(pxNew^.GetRoot());
				for(i=0)cond(i<iC)iter(i++)do
					var string sBase="";
					if(i<10)then
						sBase="00";
					elseif(i<100)then
						sBase="0";
					endif;
					var string sName="ActionMenu_"+sBase+i.ToString();
					var ^CPropDB.CNode pxNode=pxNewRoot^.FindNode(sName,true);
					if(pxNode!=null)then
						pxNode^.AddValue("Action",axSortArray[i].m_sValue1);
						pxNode^.AddValue("Shortcut",axSortArray[i].m_sValue2);
					endif;
				endfor;
				pxNew^.Save("C:/sorted_hotkeys.txt");
			endif;
		endif;
	endproc;
	
	export static proc void ShortcutMaker()
		var int iIdx=0;
		var array string asTribes;
//		asTribes.AddEntry("Aje");
//		asTribes.AddEntry("Hu");
//		asTribes.AddEntry("Ninigi");
//		asTribes.AddEntry("SEAS");
//		asTribes.AddEntry("Special");
		asTribes.AddEntry("World");
		var ^CPropDB pxOriginal = new CPropDB, pxNew = new CPropDB;
		if(pxOriginal^.Load(CClientWrap.GetUrsRelPath()+"/Data/Base/Scripts/Server/settings/new_sc_source.txt"))then
			var ^CPropDB.CNode pxRoot = ^(pxOriginal^.GetRoot());
			var ^CPropDB.CNode pxNewRoot = ^(pxNew^.GetRoot());
			if(pxRoot==null)then return; endif;
			var ^CPropDB.CNode pxActions = ^(pxRoot^.FindNode("StartTT/Actions",false));
			if(pxActions==null)then return; endif;
			var int i, iC = pxActions^.NumSubs();
			for(i=0)cond(i<iC)iter(i++)do
				var ^CPropDB.CNode pxTribe=^(pxActions^.Get(i));
				if(pxTribe!=null)then
					if(asTribes.FindEntry(pxTribe^.Name())==-1)then continue; endif;
					var int j, iJ = pxTribe^.NumSubs();
					for(j=0)cond(j<iJ)iter(j++)do
						var ^CPropDB.CNode pxSection=^(pxTribe^.Get(j));
						if(pxSection!=null)then
							var int k, iK = pxSection^.NumSubs();
							for(k=0)cond(k<iK)iter(k++)do
								var ^CPropDB.CNode pxType=^(pxSection^.Get(k));
								if(pxType!=null)then
									var int m, iM = pxType^.NumSubs();
									for(m=0)cond(m<iM)iter(m++)do
										var ^CPropDB.CNode pxNode=^(pxType^.Get(m));
										if(pxNode!=null)then
											var string sName=pxNode^.Name();
											var string sCode=pxNode^.GetValueS("code","");
											if(!sCode.IsEmpty()&&pxNode^.Find("code")!=-1)then
//												sCode.Replace("xxxxx",sName);
//												pxNode^.SetValue("code",sCode);
												var string sBase="";
												if(iIdx<10)then
													sBase="00";
												elseif(iIdx<100)then
													sBase="0";
												endif;
												var string sHotkey="ActionMenu_"+sBase+iIdx.ToString();
												var ^CPropDB.CNode pxNewNode=pxNewRoot^.FindNode(sHotkey,true);
												if(pxNewNode!=null)then
													pxNewNode^.AddValue("Action",sCode);
													pxNewNode^.AddValue("Shortcut","XYZ");
													iIdx++;
												endif;
											endif;
										endif;
									endfor;
								endif;
							endfor;
						endif;
					endfor;
				endif;
			endfor;
			pxNew^.Save("C:/new_hotkeys.txt");
		endif;
	endproc;
	
	export static proc bool AllowMap(^CMapInfoList.CMapInfo p_pxMapInfo, int p_iPlayers)
		return true;
//		if(p_pxMapInfo==null)then return false; endif;
//		if(p_pxMapInfo^.GetMapName()!="_CU_MP_6_CRASH_RPG")then return true; endif;
//		return p_iPlayers>=3;
//		var ^CLevelInfo pxLevelInfo = ^(p_pxMapInfo^.GetLevelInfo());
//		if(pxLevelInfo==null)then return false; endif;
//		var int iMinPlayers = (pxCLInfo^.GetGenericData())["ClientSettings"].GetValueI("MinPlayers",1);
//		return p_iPlayers>=iMinPlayers;
	endproc;
	
	export static proc void SetSDK(int p_iState)
		CMirageClnMgr.ms_iSDK=p_iState;
	endproc;
	
	export static proc void StartSDK()
		StartSDK("",true,true);
	endproc;
	
	export static proc void StartSDK(string p_sFile, bool p_bSkipDump, bool p_bStart)
		CClientWrap.SwitchClientShell();
		if(!p_bSkipDump)then
			Debug("");
			Debug("height: "+CClientWrap.GetScapeMgr().GetMapHeight().ToString()+" | width: "+CClientWrap.GetScapeMgr().GetMapWidth().ToString());
			var string sSetting;
			var bitset dwSetting=CClientWrap.GetScapeMgr().GetTerrainSetting();
			if(dwSetting==0000b)then
				sSetting = "Northland";
			elseif(dwSetting==0001b)then
				sSetting = "Savanna";
			elseif(dwSetting==0010b)then
				sSetting = "Jungle";
			elseif(dwSetting==0011b)then
				sSetting = "Icewaste";
			elseif(dwSetting==0100b)then
				sSetting = "Ashvalley";
			elseif(dwSetting==0101b)then
				sSetting = "Test";
			elseif(dwSetting==0110b)then
				sSetting = "Cave1";
			elseif(dwSetting==0111b)then
				sSetting = "Cave2";
			elseif(dwSetting==01000b)then
				sSetting = "Cave3";
			else
				sSetting="unknown: "+CClientWrap.GetScapeMgr().GetTerrainSetting().ToString();
			endif;
			Debug("levelsetting is: "+sSetting);
			Debug("");
		endif;
		var bool bMakeRegionDB = !p_sFile.IsEmpty();
		var ^CRegionMgrClient pxRM=CClientWrap.GetRegionMgr();
		if(pxRM!=null)then
			var int i,iC=pxRM^.NumRegions();
			if(!p_bSkipDump)then
				for(i=0)cond(i<iC)iter(i++)do
					var ^CRegionBase pxRB=pxRM^.GetRegion(i);
					Debug(i.ToString()+"'s region name is: "+pxRB^.GetName()+" | guid is: "+pxRB^.GetGUID().ToString());
				endfor;
			endif;
			if(bMakeRegionDB)then
				var ^CPropDB pxRegions = new CPropDB;
				var ^CPropDB.CNode pxRoot = ^(pxRegions^.GetRoot());
				for(i=0)cond(i<iC)iter(i++)do
					var ^CRegionBase pxRB=pxRM^.GetRegion(i);
					var string sName="region_"+i.ToString();
					var ^CPropDB.CNode pxNode=^(pxRoot^.AddValue(sName,pxRB^.GetGUID().ToString()));
					if(pxNode!=null)then
						pxNode^.AddValue("name",pxRB^.GetName().ToString());
						pxNode^.AddValue("description",pxRB^.GetDescription());
						pxNode^.AddValue("color",pxRB^.GetColor().ToString());
						pxNode^.AddValue("enabled",pxRB^.GetEnable().ToString());
						pxNode^.AddValue("numsubs",pxRB^.NumSubs().ToString());
						pxNode^.AddValue("guid",pxRB^.GetGUID().ToString());
					endif;
				endfor;
				pxRegions^.Save("C:/"+p_sFile+"_region_source.txt");
			endif;
		endif;
		if(!p_bStart)then return; endif;
		if(Windows.MessageBox("Trying to start SDK internally","Do you want to continue for sure?",050004h)==6)then
			CEvt_AbandonGame.Send();
			CGameWrap.StartLevelEditor();
			CUIStateMgr.Get().SetState(CUIStateMgr.STATE_INGAME);
		endif;
	endproc;
	
	export static proc void JumpToObj(string p_sName)
		var ^CObj pxObj=CClientWrap.GetObjMgr().FindObjByName(p_sName);
		if(pxObj!=null)then
			var vec3 vPos=pxObj^.GetPos();
			CMultiCameraController.Get().SetCameraTarget(vPos,true);
			CMultiCameraController.Get().SnapOnGround();
		endif;
	endproc;
	
	export static proc void JumpToPos(string p_sPos)
		var vec3 vPos;
		vPos.FromString(p_sPos);
		CMultiCameraController.Get().SetCameraTarget(vPos,true);
		CMultiCameraController.Get().SnapOnGround();
	endproc;
	
	export proc string GetPlayerName(int p_iID)
		if(p_iID==-1)then return CLocalizer.Get().Translate("_MIRAGE_UI_World"); endif;
		if(p_iID<0||p_iID>7)then return ""; endif;
		return m_asPlayerNames[p_iID];
	endproc;
	
	export proc void SetPlayerName(int p_iID, string p_sName)
		if(p_iID<0||p_iID>7)then return; endif;
		m_asPlayerNames[p_iID]=p_sName;
	endproc;
	
	export proc bool IsDead(int p_iID, int p_iOwn)
		if(p_iID<0||p_iID>7)then return false; endif;
		return m_aiCasualties[p_iID]==1||m_aiCasualties[p_iOwn]==1;
	endproc;
	
	export proc void SetDead(int p_iID)
		if(p_iID<0||p_iID>7)then return; endif;
		m_aiCasualties[p_iID]=1;
	endproc;
	/*
	export static proc void CreateObjectDB()
		var int iIdx=0;
		var ^CPropDB pxOriginal = new CPropDB, pxOld = new CPropDB, pxNew = new CPropDB;
		if(!pxOld^.Load(CClientWrap.GetUrsRelPath()+"/Data/Base/Scripts/Server/settings/Techtree/_AI_ObjectData.txt"))then return; endif;
		if(pxOriginal^.Load("C:/objects.txt"))then
			var ^CPropDB.CNode pxRoot = ^(pxOriginal^.GetRoot());
			var ^CPropDB.CNode pxOldRoot = ^(pxOld^.GetRoot());
			var ^CPropDB.CNode pxNewRoot = ^(pxNew^.GetRoot());
			var ^CPropDB.CNode pxWork = ^(pxNewRoot^.FindNode("Objects",true));
			if(pxRoot==null)then return; endif;
			var ^CPropDB.CNode pxObjects = ^(pxRoot^.FindNode("Objects",false));
			if(pxObjects==null)then return; endif;
			var ^CPropDB.CNode pxOldNode = ^(pxOldRoot^.FindNode("Objects",false));
			if(pxOldNode==null)then return; endif;
			var int i, iC = pxObjects^.NumSubs();
			for(i=0)cond(i<iC)iter(i++)do
				var ^CPropDB.CNode pxTribe=^(pxObjects^.Get(i));
				if(pxTribe!=null)then
					var string sTribe=pxTribe^.Name();
					var int j, iJ = pxTribe^.NumSubs();
					for(j=0)cond(j<iJ)iter(j++)do
						var ^CPropDB.CNode pxType=^(pxTribe^.Get(j));
						if(pxType!=null)then
							var string sType=pxType^.Name();
							var int k, iK = pxType^.NumSubs();
							for(k=0)cond(k<iK)iter(k++)do
								var ^CPropDB.CNode pxClass=^(pxType^.Get(k));
								if(pxClass!=null)then
									var string sClassName=pxClass^.Name();
									if(pxWork^.Find(sClassName)==-1)then
										var ^CPropDB.CNode pxNewClass = ^(pxWork^.FindNode(sClassName,true));
										var string sDescription=pxClass^.GetValueS("description","");
										var string sTemp=sDescription;
										if(sTemp!="" && sTemp.GetAt(0)=='_')then
											sTemp.Delete(0);
										endif;
										if(sTemp!=sClassName)then
											CMirageClnMgr.Debug("problem at: "+sClassName);
											CMirageClnMgr.Debug("");
										endif;
										var int iSkulls=pxClass^.GetValueI("scalps",0);
										pxNewClass^.AddValue("FourCC",sType);
										pxNewClass^.AddValue("Tribe",sTribe);
										pxNewClass^.AddValue("Description",sDescription);
										var string sTTTitle, sTTText;
										sTTText=CClientWrap.GetUIMgr().GetToopTipText(sDescription, sTTTitle);
										var string sVsChtr=FilterAttrib(sTTText,"vschtr");
										var string sVsAnml=FilterAttrib(sTTText,"vsanml");
										var string sVsVhcl=FilterAttrib(sTTText,"vsvhcl");
										var string sVsShip=FilterAttrib(sTTText,"vsship");
										var string sVsBldg=FilterAttrib(sTTText,"vsbldg");
										if((sVsAnml+sVsChtr+sVsBldg+sVsVhcl+sVsShip).GetLength()>0)then
											pxNewClass^.AddValue("ExtractedBoniFromHelp",1);
											pxNewClass^.AddValue("Boni_CHTR",sVsChtr);
											pxNewClass^.AddValue("Boni_ANML",sVsAnml);
											pxNewClass^.AddValue("Boni_VHCL",sVsVhcl);
											pxNewClass^.AddValue("Boni_SHIP",sVsShip);
											pxNewClass^.AddValue("Boni_BLDG",sVsBldg);
										else
											pxNewClass^.AddValue("ExtractedBoniFromHelp",0);
											pxNewClass^.AddValue("Boni_CHTR",0);
											pxNewClass^.AddValue("Boni_ANML",0);
											pxNewClass^.AddValue("Boni_VHCL",0);
											pxNewClass^.AddValue("Boni_SHIP",0);
											pxNewClass^.AddValue("Boni_BLDG",0);
										endif;
										pxNewClass^.AddValue("Skulls_Lvl0",iSkulls.ToString()+".000000");
										if(sTribe=="Special")then
											pxNewClass^.AddValue("Skulls_Lvl1",(iSkulls+25).ToString()+".000000");
											pxNewClass^.AddValue("Skulls_Lvl2",(iSkulls+50).ToString()+".000000");
											pxNewClass^.AddValue("Skulls_Lvl3",(iSkulls+75).ToString()+".000000");
											pxNewClass^.AddValue("Skulls_Lvl4",(iSkulls+125).ToString()+".000000");
										elseif(sType=="NEST")then
											pxNewClass^.AddValue("Skulls_Lvl1",iSkulls.ToString()+".000000");
											pxNewClass^.AddValue("Skulls_Lvl2",iSkulls.ToString()+".000000");
											pxNewClass^.AddValue("Skulls_Lvl3",iSkulls.ToString()+".000000");
											pxNewClass^.AddValue("Skulls_Lvl4",iSkulls.ToString()+".000000");
										else
											pxNewClass^.AddValue("Skulls_Lvl1",(iSkulls+5).ToString()+".000000");
											pxNewClass^.AddValue("Skulls_Lvl2",(iSkulls+15).ToString()+".000000");
											pxNewClass^.AddValue("Skulls_Lvl3",(iSkulls+25).ToString()+".000000");
											pxNewClass^.AddValue("Skulls_Lvl4",(iSkulls+45).ToString()+".000000");
										endif;
										var ^CPropDB.CNode pxOldClass = ^(pxOldNode^.FindNode(sClassName,false));
										if(pxOldClass!=null)then
											var string sThreat=pxOldClass^.GetValueS("Threat","");
											if(sThreat!="")then
												pxNewClass^.AddValue("Threat",sThreat);
											endif;
											var string sThread=pxOldClass^.GetValueS("Thread","");
											if(sThread!="")then
												pxNewClass^.AddValue("Thread",sThread);
											endif;
										endif;
									endif;
								endif;
							endfor;
						endif;
					endfor;
				endif;
			endfor;
			pxNew^.Save("C:/New_AI_ObjectData.txt");
		endif;
	endproc;
	*/
	static proc string FilterAttrib(string p_sText, string p_sAttrib)
		var string sSearch="/"+p_sAttrib+":";
		var int iPos=p_sText.Find(sSearch);
		if(iPos==-1)then
			return "";
		endif;
		iPos+=sSearch.GetLength();
		var int iEnd=iPos;
		while((iEnd<p_sText.GetLength())&&((p_sText.GetAt(iEnd)!='%')||(p_sText.GetAt(iEnd+1)=='%'))&&(p_sText.GetAt(iEnd)!='/'))do
			iEnd++;
		endwhile
		var string sRes=p_sText.Mid(iPos,iEnd-iPos);
		if(sRes=="++")then
			sRes="2";
		elseif(sRes=="+")then
			sRes="1";
		elseif(sRes=="--")then
			sRes="-2";
		elseif(sRes=="-")then
			sRes="-1";
		endif;
		return sRes;
	endproc;
	
	export proc string GetMapName()
		var string sName;
		if(CGameWrap.GetClientID()==CMultiPlayerClientMgr.Get().GetHostID())then
			sName=CMirageClnMgr.Get().GetHostMapInfo()^.GetMapName();
		else
			var ^CLevelInfo pxLevelInfo=^(CGameWrap.GetClient().GetLevelPreview());
			if(pxLevelInfo==null)then return sName; endif;
			var ^CPropDB.CNode pxBaseNode=pxLevelInfo^.GetGenericData().FindNode("Base",false);
			if(pxBaseNode!=null)then
				sName=pxBaseNode^.GetValueS("LevelName");
			endif;
		endif;
		return sName;
	endproc;

	export static proc void DumpMapInfo(^CMapInfoList.CMapInfo p_pxMapInfo)
		Debug("", false);
		CMirageClnMgr.Debug("File name: '"+p_pxMapInfo^.GetFile()+"'", false);
		var string sMapName=p_pxMapInfo^.GetMapName();
		var string sDescription=p_pxMapInfo^.GetDescription();
		CMirageClnMgr.Debug("Map name: '"+sMapName+"'", false);
		if(sMapName.Left(1)=="_")then
			CMirageClnMgr.Debug("Name's translation: '"+CLocalizer.Get().Translate(sMapName)+"'", false);
		endif;
		CMirageClnMgr.Debug("Description: '"+sDescription+"'", false);
		if(sDescription.Left(1)=="_")then
			CMirageClnMgr.Debug("Description's translation: '"+CLocalizer.Get().Translate(sDescription)+"'", false);
		endif;
//		CMirageClnMgr.Debug("Map type: '"+p_pxMapInfo^.GetMapType()+"'", false);
		CMirageClnMgr.Debug("Game type: '"+p_pxMapInfo^.GetGameType()+"'", false);
		CMirageClnMgr.Debug("Max players: '"+(p_pxMapInfo^.GetMaxPlayers()).ToString()+"'", false);
		var ^CLevelInfo pxLevelInfo=^(p_pxMapInfo^.GetLevelInfo());
		if(pxLevelInfo!=null)then
			CMirageClnMgr.Debug("Level setting: '"+pxLevelInfo^.GetLevelSetting()+"'", false);
			CMirageClnMgr.Debug("Checksum: '"+pxLevelInfo^.GetLevelCheckSumme()+"'", false);
			var int iW, iH;
			pxLevelInfo^.GetMapSize(iW,iH);
			CMirageClnMgr.Debug("Width: '"+(iW).ToString()+"'", false);
			CMirageClnMgr.Debug("Height: '"+(iH).ToString()+"'", false);
			var ^CPropDB pxGD=^(pxLevelInfo^.GetGenericData());
			if(pxGD!=null)then
				var string sAuthor, sVersion;
				CMirageClnMgr.GetLevelData(pxLevelInfo, sAuthor, sVersion);
				CMirageClnMgr.Debug("Author: '"+sAuthor+"'", false);
				CMirageClnMgr.Debug("Version: '"+sVersion+"'", false);
				var int i, iC=p_pxMapInfo^.GetMaxPlayers();
				for(i=0)cond(i<iC)iter(i++)do
					var ^CPropDB.CNode pxPSN = pxGD^.FindNode("PlayerSettings/Player_"+i.ToString(),false);
					if(pxPSN!=null)then
						var string sTribes = (pxLevelInfo^.GetGenericData())["PlayerSettings/Player_"+i.ToString()+"/Restrictions/Base/Tribes"].Value();
						CMirageClnMgr.Debug((i+1).ToString()+". HQ's tribes: '"+sTribes+"'", false);
					endif;
				endfor;
			endif;
		endif;
		Debug("", false);
	endproc;
	
	export static proc bool Debug(string p_sText)
		return Debug(p_sText,true);
	endproc;
	
	export static proc bool Debug(string p_sText, bool p_bTime)
		var string sFile="client_log.txt";
		if(!Filesystem.FileExists(sFile))then return false; endif;
		var Filesystem.CFile xFile;
		xFile.OpenAppend(sFile);
		var string sPrefix;
		if(p_bTime)then
			sPrefix=CTime.CurrentTime().ToString()+": ";
		endif;
		xFile.PrintLn(sPrefix+p_sText);
		xFile.Close();
		return true;
	endproc;
	
endclass;

//		CMirageClnMgr.SortPropDBHotkey();
//		unsorted_hotkeys.txt
//		CMirageClnMgr.TTEdit();
//		CMirageClnMgr.TTGetData();
//		CMirageClnMgr.TTFilterMaker();
//		CMirageClnMgr.CreateObjectDB();
//		.MakeUpper();
//		.MakeLower();