
//-------------------------------------------------------------------------------------------------
class CGameListRow inherit CWindow
	
	var string	m_sGameName;
	var string	m_sMapName;
	var int		m_iNumPlayer;
	var int		m_iMaxPlayer;
	var int		m_iPing;
	var string	m_sGametype;
	var string	m_sIdentifier;
	var string	m_sPassword;
	var int		m_iNumTeams;
	var int		m_iPoints;
	var int		m_iWarpgate;
	var int		m_iDisableFOW;
	var int		m_iLockDiplomacy;
	var int		m_iAllowHandicap;
	var string	m_sGameversion;
	var string	m_sGamemode;
	var string	m_sLevelCheckSum;
	
	var ^CStaticCtrl		m_pxGameNameList;
	var ^CStaticCtrl		m_pxMapName;
	var ^CStaticCtrl		m_pxNumPlayer;
	var ^CStaticCtrl		m_pxPing;
	var ^CStaticCtrl		m_pxGameTypeList;
	var ^CStaticCtrl		m_pxNumTeam;
	var ^CStaticCtrl		m_pxPoints;
	var ^CStaticCtrl		m_pxPasswordIcon;
	var	^CStaticCtrl		m_pxWarpgateIcon;
	
	export constructor()
		InitFromResource("UI/GameListWindow","ContentGameListRow");
		m_pxGameNameList	= cast<CStaticCtrl>(GetControl("GameName"));
		m_pxMapName			= cast<CStaticCtrl>(GetControl("MapName"));
		m_pxNumPlayer		= cast<CStaticCtrl>(GetControl("NumPlayer"));
		m_pxNumTeam			= cast<CStaticCtrl>(GetControl("NumTeam"));
		m_pxGameTypeList	= cast<CStaticCtrl>(GetControl("GameType"));
		m_pxPoints			= cast<CStaticCtrl>(GetControl("Points"));
		m_pxPing			= cast<CStaticCtrl>(GetControl("Ping"));
		m_pxPasswordIcon	= cast<CStaticCtrl>(GetControl("PasswordIcon"));
		m_pxWarpgateIcon	= cast<CStaticCtrl>(GetControl("WarpgateIcon"));
	endconstructor;
	
	export proc string GetPlayerNumberString()
		return m_iNumPlayer.ToString()+"/"+m_iMaxPlayer.ToString();
	endproc;
	
	destructor()
	enddestructor;	
	
	export proc void SetGameName(string p_sGameName)
		if (p_sGameName!="") then
			m_sGameName=p_sGameName;
		else
			m_sGameName="Waiting for players";
		endif;
		m_pxGameNameList^.SetText(m_sGameName);
	endproc;
	
	export proc void SetMapName(string p_sMapName)
		m_sMapName=p_sMapName;
		//m_pxMapName^.SetText(m_sMapName);
		var string sMapName=CLocalizer.Get().Translate(m_sMapName);
		m_pxMapName^.SetText(sMapName);
	endproc;
	
	export proc void SetNumPlayer(int p_iNumPlayer)
		if (p_iNumPlayer!=16) then
			m_iNumPlayer=p_iNumPlayer;
		else
			m_iNumPlayer=0;
		endif;
	endproc;
	
	export proc void SetMaxPlayer(int p_iMaxPlayer)
		if (p_iMaxPlayer!=16) then
			m_iMaxPlayer=p_iMaxPlayer;
		else
			m_iMaxPlayer=8;
		endif;
		m_pxNumPlayer^.SetText(GetPlayerNumberString());			
	endproc;
			
	export proc void SetPing(int p_iPing)
		m_iPing=p_iPing;
		m_pxPing^.SetText(m_iPing.ToString());
	endproc;
	
	export proc void SetGametype(string p_sGametype)
		m_sGametype=p_sGametype;
		if(p_sGametype=="deathmatch") then 
			m_pxGameTypeList^.SetText(CLocalizer.Get().Translate("_GAMETYPE_Abr_Deathmatch"));
		elseif (p_sGametype=="domination") then
			m_pxGameTypeList^.SetText(CLocalizer.Get().Translate("_GAMETYPE_Abr_KingOfTheHill"));
		elseif(p_sGametype=="defender") then
			m_pxGameTypeList^.SetText(CLocalizer.Get().Translate("_GAMETYPE_Abr_Defender"));
		endif;
	endproc;
	
	export proc void SetIdentifier(string p_sIdentifier)
		m_sIdentifier=p_sIdentifier;
	endproc;
	
	export proc void SetPassword(string p_sPassword)
		m_sPassword=p_sPassword;
		if(m_sPassword!="") then
			SetPasswordIcon();
		endif;
	endproc;
	
	export proc void SetPasswordIcon ()
		var string sBitmapPath = CClientWrap.GetUrsRelPath()+"/Data/Base/UI/menue/decoration/server_password.tga";
		m_pxPasswordIcon^.SetBitmap(sBitmapPath);
	endproc;	
	
	export proc void SetNumTeams(int p_iNumTeams)
		if (p_iNumTeams!=16) then
			m_iNumTeams=p_iNumTeams;
		else
			m_iNumTeams=8;
		endif;
		m_pxNumTeam^.SetText(m_iNumTeams.ToString());
	endproc;
	
	export proc void SetPoints(int p_iPoints)
		m_iPoints=p_iPoints;
		m_pxPoints^.SetText(m_iPoints.ToString());
	endproc;
	
	export proc void SetWarpgate(int p_iWarpgate)
		m_iWarpgate=p_iWarpgate;
		if(m_iWarpgate==0) then
			SetWarpgateIcon();
		endif;
	endproc;
	
	export proc void SetWarpgateIcon()
		var string sBitmapPath = CClientWrap.GetUrsRelPath()+"/Data/Base/UI/menue/decoration/server_dimensiongate.tga";
		m_pxWarpgateIcon^.SetBitmap(sBitmapPath);
	endproc;

	export proc void SetDisableFOW(int p_iDisableFOW)
		m_iDisableFOW=p_iDisableFOW;
	endproc;
	
	export proc void SetLockDiplomacy(int p_iLockDiplomacy)
		m_iLockDiplomacy=p_iLockDiplomacy;
	endproc;
	
	export proc void SetAllowHandicap(int p_iAllowHandicap)
		m_iAllowHandicap=p_iAllowHandicap;
	endproc;
	
	export proc void SetGameversion(string p_sGameversion)
		m_sGameversion=p_sGameversion;
	endproc;
	
	export proc string GetGameversion()
		return m_sGameversion;
	endproc;
	
	export proc void SetGamemode(string p_sGamemode)
		m_sGamemode=p_sGamemode;
	endproc;
	
	export proc void SetLevelCheckSum(string p_sLevelCheckSum)
		m_sLevelCheckSum=p_sLevelCheckSum;
	endproc;
	
	export proc string GetLevelCheckSum()
		return m_sLevelCheckSum;
	endproc;
	
	export proc string GetGameName()
		return m_sGameName;
	endproc;
	
	export proc string GetMapName()
		return m_sMapName;
	endproc;
	
	export proc string GetIdentifier()
		return m_sIdentifier;
	endproc;
	
	export proc string GetPassword()
		return m_sPassword;
	endproc;
	
	export proc string GetGamemode()
		return m_sGamemode;
	endproc;
		
	export proc bool NoServerOnline() 
		if(m_sGameName=="default" || m_sIdentifier.Find("NONE")>=0 || m_iMaxPlayer==16 || m_sGameName=="" || m_sGamemode=="closedplaying") then
			return true;
		else
			return false;
		endif;
	endproc;
	
	export proc bool MaxNumPlayerReached()
		if(m_iNumPlayer == m_iMaxPlayer) then
			return true;
		else
			return false;
		endif;
	endproc;
	
endclass;

//-------------------------------------------------------------------------------------------------

class CGameListWindow inherit CMapListWindow
		
	var ^CDesktop			m_pxDesktop;
	var int					m_iButtonState;
	var ^CStaticCtrl		m_pxContentFrame;
	var ^CButton			m_pxBack;
	var ^CButton			m_pxContinue;
	var ^CButton			m_pxRefreshButton;
	var ^CCheckBox			m_pxFilter;	
	var ^CContentFilterList	m_pxFilterList;		
	
	//Join
	var ^CList						m_pxJoinList;	
	export var procref <void>		m_xOnFilterUpdate;
	
	//Host
	
	var ^CButton			m_pxHostButton;
	var ^CButton			m_pxJoinButton;
	
	var ^CTabCtrl			m_pxTabCtrl;
	var ^CLevelSettingsPage m_pxLevelSettingsPage;
	var ^CStaticCtrl 		m_pxContentJoinPage;
	
	var ^CGameInfoWindow 	m_pxGameInfoWindow;	
	
	// var bool				m_bMode; 
	var bool				m_bHost;	

	var string 				m_sSelectedServerAddress;
	var int					m_iTimerID;
	var int					m_iProxyServerTimerID;
	var string				m_sGamePassword;
	var ^CPasswordWindow 	m_pxPasswordWindow;
	var string				m_sIdentifier;
	
	export constructor(^CGameInfoWindow p_pxGameInfoWindow)
		if(!InitFromResource("UI/GameListWindow","GameListWindow")) then
			return;
		endif;		
		//SetSize(650,715);
		SetSize(650 * CGameInst.ms_iUIScaleFactor,520 * CGameInst.ms_iUIScaleFactor);
		
		m_pxDesktop=CClientWrap.GetDesktop();
		m_pxGameInfoWindow=p_pxGameInfoWindow;
		
		m_pxFilterList=cast<CContentFilterList>(GetControl("ContentFilterList"));
		
		m_pxBack=cast<CButton>(GetControl("BackButton"));
		m_pxBack^.m_xOnClick=OnBack;
		m_pxBack^.SetTextAlign(0);
		m_pxBack^.SetTextIndent(5);
		m_pxBack^.SetDisabled(true);
		m_pxContinue=cast<CButton>(GetControl("ContinueButton"));		
		m_pxContinue^.SetTextAlign(0);
		m_pxContinue^.SetTextIndent(5);
		m_pxContinue^.m_xOnClick=OnContinue;
		CMultiPlayerClientMgr.Get().SetHostButton(m_pxContinue);
		
		m_pxRefreshButton=cast<CButton>(GetControl("RefreshButton"));		
		m_pxRefreshButton^.SetVisible(false);
		m_pxRefreshButton^.SetTextAlign(0);
		m_pxRefreshButton^.SetTextIndent(5);
		
		m_pxFilter = cast<CCheckBox>(GetControl("Filters"));
		m_pxFilter^.SetVisible(false);
		
			

		m_pxRefreshButton^.SetVisible(false);
		m_pxFilter^.SetVisible(false);
		
		DisableContinueButton();	
		begin JoinPage;
			m_pxContentJoinPage = new CStaticCtrl;
			m_pxContentJoinPage^.InitFromResource("UI/GameListWindow","ContentJoin");
			m_pxJoinList=cast<CList>(m_pxContentJoinPage^.GetControl("JoinList"));

			//UpdateOpenGameList();
			
			m_pxJoinList^.m_xOnSelect=UpdateGameInfoWindow;
			m_pxJoinList^.m_xOnLBtnDblClick = OnJoinGame;
			
			if(CGameWrap.IsServerExeRunning())then
				CGameWrap.SetWaitingForShutOfServer(true);
				CGameWrap.WaitForServerShut();
			endif;
			
			m_pxRefreshButton^.m_xOnClick=OnRefresh;
			m_pxRefreshButton^.SetVisible(true);
			
			m_pxFilter^.SetVisible(true);
			m_pxFilter^.m_xOnStateChange = OnFilterChange;
			
			
			// make serverbrowsing possible for the user
			CGameWrap.SetWaitingForShutOfServer(false);
			//L KLog.LogSpam("MaSc", "GameListWindow: StartProxyServer()");
			CGameWrap.StartProxyServer();
			m_iTimerID=SetTimer(2000,true);
			m_iProxyServerTimerID=SetTimer(100,true);			
		end JoinPage;
		
		m_pxTabCtrl=cast<CTabCtrl>(GetControl("TabCtrl"));
		m_pxLevelSettingsPage=new CLevelSettingsPage(this,true);		
		if(CMultiPlayerClientMgr.Get().GetSkirmishMode())then
			m_pxTabCtrl^.AddTab(CLocalizer.Get().Translate("_UI_PlLiWind_Tab_Settings"),m_pxLevelSettingsPage,CLocalizer.Get().Translate("_UI_Tab_Settings"));
		else
			m_pxTabCtrl^.AddTab(CLocalizer.Get().Translate("_UI_GamLWind_Tab_HostGame"),m_pxLevelSettingsPage,CLocalizer.Get().Translate("_UI_Tab_Settings"));
		endif;
		if(CGameWrap.IsGameSpyGame())then // server browsing need gamespy
			m_pxTabCtrl^.AddTab(CLocalizer.Get().Translate("_UI_GamLWind_Tab_JoinGame"),m_pxContentJoinPage,CLocalizer.Get().Translate("_UI_Tab_JoinGame"));
		endif;
		m_pxTabCtrl^.SetTabDisabled(1,true);
		m_pxTabCtrl^.m_xOnChangeTab=OnChangeTab;
		
		
		m_iButtonState=0;
		
		if(CGameWrap.IsInternetGame()) then 
			SetCaption(CLocalizer.Get().Translate("_UI_GamLWind_Title_InternetGame"));
		else
			if(CMultiPlayerClientMgr.Get().GetSkirmishMode())then
				SetCaption(CLocalizer.Get().Translate("_UI_GamLWind_Title_Skirmish"));
			else
				SetCaption(CLocalizer.Get().Translate("_UI_GamLWind_Title_LANGame"));
			endif;			
		endif;		
			
		SetStyle(CFrameWindow.WS_FixedPos | CFrameWindow.WS_Caption);
		
		m_sSelectedServerAddress="";
				
		DisableContinueButton();
		CMultiPlayerClientMgr.Get().m_bProxyServerRunning=false;
		UpdateGameInfoWindow();
	endconstructor;
	
	destructor()	
		CMultiPlayerClientMgr.Get().SetHostButton(null);		
		CMultiPlayerClientMgr.Get().m_bProxyServerRunning=false;	
		UnsetTimer(m_iTimerID);
	enddestructor;	
	
	export proc bool UpdateGameInfoWindow()
		if(m_pxGameInfoWindow!=null)then
			var string sLevelCheckSumme;
			var int iCurTab=m_pxTabCtrl^.GetCurrentTab();			
			if(iCurTab!=-1)then
				var ^CWindow pxCurTabWnd=m_pxTabCtrl^.GetTabWindow(iCurTab);
				if(pxCurTabWnd==m_pxLevelSettingsPage)then
					sLevelCheckSumme=m_pxLevelSettingsPage^.GetSelectedLevelCheckSumme();
				elseif(pxCurTabWnd==m_pxContentJoinPage)then
					var int iIdx = m_pxJoinList^.GetSelectedItem();
					if(iIdx!=-1)then
						var ^CGameListRow pxGLR=cast<CGameListRow>(m_pxJoinList^.GetItemWindow(iIdx));
						if(pxGLR!=null)then
							sLevelCheckSumme=pxGLR^.GetLevelCheckSum();	
						endif;
					endif;
				endif;
			endif;			
			
			var int iCredits=0;			
			m_pxGameInfoWindow^.Update(sLevelCheckSumme,iCredits);
		endif;
		return true;
	endproc;
	/*
	proc bool OnSelectJoinListItem()
		//KLog.LogWarn("Manni","Selected list item");
		var int iIdx = m_pxJoinList^.GetSelectedItem();
		ShowSelectedListItem(iIdx);	
		
		var string sLevelCheckSumme;
		if(iIdx!=-1)then
			var ^CGameListRow pxGLR=cast<CGameListRow>(m_pxJoinList^.GetItemWindow(iIdx));
			if(pxGLR!=null)then
				sLevelCheckSumme=pxGLR^.GetLevelCheckSum();			
			endif;
		endif;
		OnSelectMap(sLevelCheckSumme);
		
		return(true);
	endproc;
	*/
	proc bool ShowFilter(bool p_bShowFilter)
		if(p_bShowFilter && CGameWrap.IsInternetGame()) then
			m_pxFilterList^.SetVisible(true);		
		else
			m_pxFilterList^.SetVisible(false);			
		endif;
		return true;
	endproc;
	
	proc bool OnFilterChange()
		if(m_pxFilter^.GetChecked()==1) then
			ShowFilter(true);
			SetSize(650 * CGameInst.ms_iUIScaleFactor,715 * CGameInst.ms_iUIScaleFactor);			
		else
			ShowFilter(false);
			SetSize(650 * CGameInst.ms_iUIScaleFactor,520 * CGameInst.ms_iUIScaleFactor);
		endif;
		return true;
	endproc;
	
	proc void ShowSelectedListItem(int p_iIdx) 
		/*
		if(m_pxJoinList!= null && p_iIdx>=0 && !m_bHost)then
			m_pxSelectedWindow = cast<CGameListRow>(m_pxJoinList^.GetItemWindow(p_iIdx));
			if(m_pxSelectedWindow!=null) then
				var int i,iC = m_pxHostMapList^.NumItems();
				for(i=0)cond(i<iC)iter(i++)do
					//var ^CMapData	pxTmp=cast<CMapData>(m_pxHostMapList^.GetItemData(i));
					var ^CMapListRowHost pxTmp = cast<CMapListRowHost>(m_pxHostMapList^.GetItemWindow(i));
					if(pxTmp == null) then return; endif;
					if(m_pxSelectedWindow^.GetMapName()==pxTmp^.GetMapData()^.GetMapName()) then
						CMultiPlayerClientMgr.Get().SetMapData(pxTmp^.GetMapData());
						CMultiPlayerClientMgr.Get().SetNumPlayers(m_pxSelectedWindow^.GetMaxPlayer());
					endif;
				endfor;
			endif;			
		endif;
		*/
	endproc;
	
	proc bool OnRefresh()
		var ^CContentFilterList pxList=cast<CContentFilterList>(GetControl("ContentFilterList"));
		if(pxList!=null && CGameWrap.IsInternetGame()) then
			pxList^.SendFilter();
		endif;
		UpdateOpenGameList();
		return(true);
	endproc;
	
	proc bool OnFilter()
		return true;
	endproc;
		
	proc void UpdateOpenGameList()
		// get current open game server list	
		begin ServerGet;
		
			var string sSelectedItemIdent;
			var int iSelItem=-1;
			begin SaveSelectedItemIdent;
				iSelItem=m_pxJoinList^.GetSelectedItem();
				if(iSelItem!=-1)then
					var ^CGameListRow pxGLR=cast<CGameListRow>(m_pxJoinList^.GetItemWindow(iSelItem));
					if(pxGLR!=null)then
						sSelectedItemIdent=pxGLR^.GetIdentifier();
					endif;
				endif;				
			end SaveSelectedItemIdent;
			
		
			var int iCntServer=0;
			var array string asServerList;			
			var bool bAddToList = false;
			iCntServer=CGameWrap.GetOpenServerCountGS();
			if ((iCntServer>0))then
				var int i;	
				var ^CLevelInfoClient pxLevelInfo=^(CGameWrap.GetClient().GetLevelPreview());
				for(i=0)cond(i<iCntServer)iter(i++)do
					
					var string sIdentifier = CGameWrap.GetInfoAboutServerGS(i,6);
					asServerList.AddEntry(sIdentifier);
					
					var int j, jC=m_pxJoinList^.NumItems();	
					var ^CGameListRow pxGameListRow;		
					for(j=0)cond(j<jC)iter(j++)do
						var ^CGameListRow pxWindow=cast<CGameListRow>(m_pxJoinList^.GetItemWindow(j));
						if(pxWindow==null) then continue; endif;
						if(pxWindow^.GetIdentifier() != sIdentifier) then continue; endif;
						pxGameListRow=pxWindow;						
						break;
					endfor;
					
					if(pxGameListRow==null) then
						pxGameListRow = new CGameListRow;
						bAddToList=true;
					else
						bAddToList=false;
					endif;
					jC=17;
					for(j=0)cond(j<jC)iter(j++)do	
						var string sTmp = CGameWrap.GetInfoAboutServerGS(i,j);
						if(j==0) then
							pxGameListRow^.SetGameName(sTmp);
						endif;
						if(j==1) then
							pxGameListRow^.SetMapName(sTmp);
						endif;
						if(j==2) then
							pxGameListRow^.SetNumPlayer(sTmp.ToInt());
						endif;
						if(j==3) then
							pxGameListRow^.SetMaxPlayer(sTmp.ToInt());
						endif;
						if(j==4) then
							pxGameListRow^.SetPing(sTmp.ToInt());
						endif;
						if(j==5) then
							pxGameListRow^.SetGametype(sTmp);
						endif;
						if(j==6) then
							pxGameListRow^.SetIdentifier(sTmp);
						endif;
						if(j==7) then 
							pxGameListRow^.SetPassword(sTmp);
						endif;
						if(j==8) then
							pxGameListRow^.SetNumTeams(sTmp.ToInt());
						endif;
						if(j==9) then
							pxGameListRow^.SetPoints(sTmp.ToInt());
						endif;
						if(j==10) then
							pxGameListRow^.SetWarpgate(sTmp.ToInt());							
						endif;
						if(j==11) then
							pxGameListRow^.SetDisableFOW(sTmp.ToInt());							
						endif;
						if(j==12) then
							pxGameListRow^.SetLockDiplomacy(sTmp.ToInt());
							if(sTmp.ToInt()==0) then
								pxLevelInfo^.SetLockDiplomacy(false);
							else
								pxLevelInfo^.SetLockDiplomacy(true);
							endif;
						endif;
						if(j==13) then 
							pxGameListRow^.SetAllowHandicap(sTmp.ToInt());							
						endif;
						if(j==14) then
							pxGameListRow^.SetGameversion(sTmp);
						endif;
						if(j==15) then
							pxGameListRow^.SetGamemode(sTmp);
						endif;
						if(j==16) then
							pxGameListRow^.SetLevelCheckSum(sTmp);
						endif;
					endfor;

					if(!pxGameListRow^.NoServerOnline()) then 
						if(m_pxJoinList^.NumItems()==1 && m_pxJoinList^.GetItem(0) == CLocalizer.Get().Translate("_UI_GamLWind_Label_nogameserveronline")) then
							m_pxJoinList^.DeleteItem(0);
						endif;
						if(bAddToList) then
							if(!pxGameListRow^.NoServerOnline()) then
								m_pxJoinList^.AddItem("",pxGameListRow);
								bAddToList=false;
							endif;
						endif;			
						EnableContinueButton();
					endif;
				endfor;
				
				if(m_pxJoinList^.NumItems()>0 && m_pxJoinList^.GetItem(0) != CLocalizer.Get().Translate("_UI_GamLWind_Label_nogameserveronline")) then 
					var int iC = m_pxJoinList^.NumItems();
					var int j,jC = asServerList.NumEntries();
					for(i=0)cond(i<iC)iter(i++) do
						var int iInServerList=-1;
						var ^CGameListRow pxWindow = cast <CGameListRow>(m_pxJoinList^.GetItemWindow(i));
						if(pxWindow==null) then continue; endif;
						iInServerList=asServerList.FindEntry(pxWindow^.GetIdentifier());
						if(iInServerList==-1 || pxWindow^.GetGamemode()=="closedplaying") then
							m_pxJoinList^.DeleteChild(m_pxJoinList^.GetItemWindow(i));
							m_pxJoinList^.DeleteItem(i);
							i--;
							iC--;
						endif;
						if(m_pxJoinList^.NumItems()==0) then
							m_pxJoinList^.AddItem(CLocalizer.Get().Translate("_UI_GamLWind_Label_nogameserveronline"));
						endif;
					endfor;
				endif;
				asServerList=0;				
				begin RestoreSelectedItem;
					if(!sSelectedItemIdent.IsEmpty())then
						var int i,iC=m_pxJoinList^.NumItems();
						var bool bSelected=false;
						for(i=0)cond(i<iC)iter(i++)do
							var ^CGameListRow pxGLR=cast<CGameListRow>(m_pxJoinList^.GetItemWindow(i));
							if(pxGLR==null)then continue; endif;
							if(pxGLR^.GetIdentifier()==sSelectedItemIdent)then
								m_pxJoinList^.Select(i);
								bSelected=true;
								break;
							endif;
						endfor;
						if(!bSelected && m_pxJoinList^.NumItems()>0) then
							var ^CGameListRow pxGLR=cast<CGameListRow>(m_pxJoinList^.GetItemWindow(0));
							if(pxGLR!=null) then
								m_pxJoinList^.Select(0);
							endif;
						endif;
					endif;					
				end RestoreSelectedItem;
			else
				if(m_pxJoinList^.NumItems()==0) then
					m_pxJoinList^.AddItem(CLocalizer.Get().Translate("_UI_GamLWind_Label_nogameserveronline"));
					bAddToList=false;
					if(m_bHost==false) then												
						DisableContinueButton();
					endif;
				endif;
				
				if(m_pxJoinList^.NumItems()>0 && m_pxJoinList^.GetItem(0) == CLocalizer.Get().Translate("_UI_GamLWind_Label_nogameserveronline")) then
					if(m_bHost==false) then						
						DisableContinueButton();
					endif;
				endif;
				if(m_pxJoinList^.NumItems()>0 && m_pxJoinList^.GetItem(0) != CLocalizer.Get().Translate("_UI_GamLWind_Label_nogameserveronline")) then
					var int i, iC = m_pxJoinList^.NumItems();
					for(i=0)cond(i<iC)iter(i++)do
						m_pxJoinList^.DeleteChild(m_pxJoinList^.GetItemWindow(0));
						m_pxJoinList^.DeleteItem(0);
					endfor;
					m_pxJoinList^.AddItem(CLocalizer.Get().Translate("_UI_GamLWind_Label_nogameserveronline"));
					if(m_bHost==false) then						
						DisableContinueButton();
					endif;
				endif;
			endif;
			UpdateGameInfoWindow();
		end ServerGet;
	endproc;
	

	export proc bool Init(int p_iState)
	/*
		if(m_pxHostMapList!=null)then
			m_pxHostMapList^.ShowSelection(false);
		endif;
	*/
		return(true);
	endproc;
	
	proc bool OnChangeTab(int p_iTab)
		if(p_iTab==0)then
			OnHost();
			SetSize(650 * CGameInst.ms_iUIScaleFactor,520 * CGameInst.ms_iUIScaleFactor);
		else
			OnJoin();
			if(m_pxFilter^.GetVisible() && m_pxFilter^.GetChecked()==1)then
				SetSize(650 * CGameInst.ms_iUIScaleFactor,715 * CGameInst.ms_iUIScaleFactor);			
			endif;
		endif;
		UpdateGameInfoWindow();
		return true;
	endproc;

	export proc bool OnHost()
		OnContentHost();		
		//m_pxHostMapList^.ShowSelection(false);
		m_pxRefreshButton^.SetVisible(false);	
		ShowFilter(false);
		m_pxFilter^.SetVisible(false);
		if(CMultiPlayerClientMgr.Get().m_bProxyServerRunning==true)then  // Todo variable an Game.usl überreichen oder MultiPlayerClientMgr ... 			
			EnableContinueButton();
		endif;
		m_bHost=true;	
		//OnSelectMap();
		return(true);
	endproc;
	
	proc bool OnJoin()		
		OnContentJoin();		
		m_bHost=false;
		m_pxRefreshButton^.SetVisible(true);
		if(CGameWrap.IsInternetGame()) then	
			m_pxFilter^.SetVisible(true);
		endif;
		if(m_pxFilter^.GetChecked()==1) then 
			ShowFilter(true);
		endif;
		return(true);
	endproc;

	proc bool OnBack()
		//m_pxGameInfoWindow^.SetPlayerListState(true);
		if(CMultiPlayerClientMgr.Get().GetSkirmishMode())then
			CUIStateMgr.Get().SetState(CUIStateMgr.STATE_MAINMENU);
		else
			CUIStateMgr.Get().SetState(CUIStateMgr.STATE_MULTIPLAYERSELECT);
		endif;
		
		CGameWrap.StopServerBrowsingGS();
		CGameWrap.ShutProxyServer();
		
		if(m_pxJoinList^.NumItems()>0 && m_pxJoinList^.GetItem(0) == CLocalizer.Get().Translate("_UI_GamLWind_Label_nogameserveronline")) then 
			m_pxJoinList^.DeleteItem(0);			
		else
			var int i,iC=m_pxJoinList^.NumItems();
			for(i=0)cond(i<iC)iter(i++)do			
				m_pxJoinList^.DeleteChild(m_pxJoinList^.GetItemWindow(0));
				m_pxJoinList^.DeleteItem(0);			
			endfor;
		endif;								
		return(true);
	endproc;
	
	proc bool OnContinue()
		//if(m_bMode)then   //LAN only and Internet only games ???
		
		// differ between Host and Join-Button -> technically the buttons are the same, 
		// but they differ in function
		if(m_bHost==true)then			
			
			// shut the proxy then start our HostServerApp
			CGameWrap.ShutProxyServer();
//			CGameWrap.SetWaitingForShutOfServer(true);
			CGameWrap.SetRequestStartHostServer(true);
			
			OnCheckForServer();
		else
			OnJoinGame();
		endif;
										
		return(true);
	endproc;
	
	
	proc bool OnCheckForServer()
		CGameWrap.StopFindServers();
		CGameWrap.m_xOnServerFound.Clear();
		if(!CClientWrap.HasServer())then
			CUIStateMgr.Get().InvalidateLoadScreenInfo();
			if(CMultiPlayerClientMgr.Get().GetSkirmishMode())then
				CUIStateMgr.Get().ShowLoadingScreen("StartingServer",CUIStateMgr.STATE_NEWMULTIPLAYERLOBBY);
			else
				CUIStateMgr.Get().ShowLoadingScreen("StartingNetworkServer",CUIStateMgr.STATE_NEWMULTIPLAYERLOBBY);
			endif;
		else						
			OnStartGame();
		endif;
		return(true);
	endproc;
	
	export proc bool OnJoinGame()				
		// extract the ident string
		var int iSelected=m_pxJoinList^.GetSelectedItem();
		if(iSelected==-1)then
			return(true);
		endif;
		var ^CGameListRow pxWindow = cast<CGameListRow>( m_pxJoinList^.GetItemWindow(iSelected));
		if(pxWindow!= null /*&& !pxWindow^.MaxNumPlayerReached()*/) then
			var string sTmpIdentifier = pxWindow^.GetIdentifier();					
			var int iFirst=sTmpIdentifier.FindRev('{');
			var int iLast=sTmpIdentifier.FindRev('}');				
			m_sSelectedServerAddress=sTmpIdentifier.Mid(iFirst+1,iLast-(iFirst+1));
			
			var string sClientVersion = CVersionInfo.GetCompatibleVersionsString();
			var string sServerVersion = pxWindow^.GetGameversion();
			
			if(sClientVersion!=sServerVersion) then
				CMessageBox.MsgBox_OK(CLocalizer.Get().Translate("_UI_MPlLobby_Msgbox_ DifferentVersions"),CLocalizer.Get().Translate("_UI_MPlLobby_Msgbox_ DifferentVersions"),CMessageBox.SMB_ICONEXCLAMATION,OnOkMsgBox_CallBack);
				return(true);
			endif;
			
			if (pxWindow^.GetPassword() != "") then
				var string sTitle = pxWindow^.GetGameName();
				m_pxPasswordWindow = CreatePasswordWindow(sTitle);
				m_sGamePassword = pxWindow^.GetPassword();
				m_pxPasswordWindow^.m_xOnOk = OnCheckPassword;
			else
				CGameWrap.StopServerBrowsingGS();
				CGameWrap.JoinToGameServerGS(m_sSelectedServerAddress);	
				CUIStateMgr.Get().SetState(CUIStateMgr.STATE_JOINTOMULTIPLAYERGAME);
			endif;
		endif;
		return(true);
	endproc;
	
	proc ^CPasswordWindow CreatePasswordWindow(string p_sTitle)
		var ^CPasswordWindow pxTmp = new CPasswordWindow(p_sTitle);
		CClientWrap.GetDesktop()^.AddChild(pxTmp);
		return pxTmp;
	endproc;
		
	proc void OnCheckPassword()
		var string sEnteredPassword = m_pxPasswordWindow^.GetPassword();
		if(sEnteredPassword == m_sGamePassword) then
			CGameWrap.StopServerBrowsingGS();
			CGameWrap.JoinToGameServerGS(m_sSelectedServerAddress);	
			CUIStateMgr.Get().SetState(CUIStateMgr.STATE_JOINTOMULTIPLAYERGAME);
		else
			//CreateQuestionWindow("Wrong password");
			CMessageBox.MsgBox_OK(CLocalizer.Get().Translate("_UI_MPlLobby_Msgbox_WrongPassword"),CLocalizer.Get().Translate("_UI_MPlLobby_Msgbox_WrongPassword"),CMessageBox.SMB_ICONEXCLAMATION,OnOkMsgBox_CallBack);
		endif;
	endproc;
	
	proc void OnOkMsgBox_CallBack(int p_iResult)
		var bitset dwResult = Math.IntToBitset(p_iResult);
		CGameWrap.StartServerBrowsingGS();
	endproc;
		
	export proc bool OnStartGame()
		var string sName;
		var ^CUserProfileList pxList=^(CClientWrap.GetUserProfileList());
		if(pxList!=null)then
			sName=pxList^.GetCurrentProfile()^.GetUserName();
			if(sName=="")then
				sName=Windows.GetUserName();
				CSettings.Set("Game/PlayerName",sName);
			endif;
		endif;		
		CUIStateMgr.Get().SetState(CUIStateMgr.STATE_NEWMULTIPLAYERPREGAME,"");
		return(true);
	endproc;
	
	proc bool OnTimer(int p_iTimerID)
		if(m_iTimerID==p_iTimerID) then
			UpdateOpenGameList();
		elseif(p_iTimerID==m_iProxyServerTimerID)then
			var bool bIsProxyServerRunning = CMultiPlayerClientMgr.Get().m_bProxyServerRunning;
			if(bIsProxyServerRunning)then
				m_pxTabCtrl^.SetTabDisabled(1,false);
				m_pxBack^.SetDisabled(!bIsProxyServerRunning);
				UnsetTimer(m_iProxyServerTimerID);
				m_iProxyServerTimerID=-1;
			endif;
		endif;
		return true;
	endproc;

	proc bool OnContentHost()		
		if(CMultiPlayerClientMgr.Get().GetSkirmishMode())then
			m_pxContinue^.SetText(CLocalizer.Get().Translate("_UI_GamLWind_Button_Continue"));
			m_pxContinue^.SetToolTipText(CLocalizer.Get().Translate("_UI_GamLWind_Button_Continue_TT"));
		else
			m_pxContinue^.SetText(CLocalizer.Get().Translate("_UI_GamLWind_Button_Host"));
			m_pxContinue^.SetToolTipText(CLocalizer.Get().Translate("_UI_GamLWind_Button_Continue_TT"));
		endif;
		CGameWrap.StopServerBrowsingGS();
		//ReloadHostMapList();
		return(true);
	endproc;
	
	proc bool OnContentJoin()
		CGameWrap.StartServerBrowsingGS();  // starts proxy who starts serverbrowsing
		OnTimer(m_iTimerID);		
		m_pxContinue^.SetText(CLocalizer.Get().Translate("_UI_GamLWind_Button_Join"));
		m_pxContinue^.SetToolTipText(CLocalizer.Get().Translate("_UI_GamLWind_Button_JoinGame_TT"));
		m_pxContinue^.SetTextAlign(0);
		m_pxContinue^.SetTextIndent(5);
		DisableContinueButton();
		return(true);
	endproc;
		
	///////////////
	
	
	export proc void DisableContinueButton()		
		m_pxContinue^.SetDisabled(true);
	endproc;
	
	export proc void EnableContinueButton()		
		m_pxContinue^.SetDisabled(false);
	endproc;
	
	
endclass;

//Contains all information about the map
class CMapData inherit CItemData

	var string			m_sFileName;
	var string			m_sMapName;
	var string			m_sMapType;
	var string			m_sDescription;
	var int				m_iPlayers;
	var CBitmapPtr		m_pxImage;
	var bool			m_bDeathmatch;
	var bool			m_bDomination;
	var bool			m_bDefender;
	var bool			m_bDimGate;
	var CGameTimeSpan 	m_xPlayedTime;
	var string			m_sLevelCheckSum;
	//...to be continued
	
	export constructor()
	endconstructor;

	export destructor()
	enddestructor;

	//Map type (single or multiplayer)
	export proc string GetMapType();
		return(m_sMapType);
	endproc;
	export proc bool SetMapType(string p_sMapType);
		m_sMapType=p_sMapType;
		return(true);
	endproc;

	//Map filename
	export proc string GetFileName();
		return(m_sFileName);
	endproc;
	export proc bool SetFileName(string p_sFileName);
		m_sFileName=p_sFileName;
		return(true);
	endproc;
	
	//Map description
	export proc string GetDescription();
		return(m_sDescription);
	endproc;
	export proc bool SetDescription(string p_sDescription);
		m_sDescription=p_sDescription;
		return(true);
	endproc;
	
	//Name of map
	export proc string GetMapName();
		return(m_sMapName);
	endproc;
	export proc bool SetMapName(string p_sMapName);
		m_sMapName=p_sMapName;
		return(true);
	endproc;
	
	//Image of map
	export proc CBitmapPtr GetImage();
		return(m_pxImage);
	endproc;
	export proc bool SetImage(CBitmapPtr p_pxImage);
		m_pxImage=p_pxImage;
		return(true);
	endproc;
	
	//Number of max players
	export proc int GetPlayers();
		return(m_iPlayers);
	endproc;
	export proc bool SetPlayers(int p_iPlayers);
		m_iPlayers=p_iPlayers;
		return(true);
	endproc;
	
	//Available gametypes
	export proc bool GetGameType(int p_iGametype);
		if(p_iGametype==0)then
			return(m_bDeathmatch);
		elseif(p_iGametype==1)then
			return(m_bDomination);
		elseif(p_iGametype==2)then	
			return(m_bDefender);
		endif;
		return(true);
	endproc;
	
	export proc bool SetGameType(string p_sGameType);
		if(p_sGameType.Find("Deathmatch")!=(-1))then
			m_bDeathmatch=true;
		endif;
		if(p_sGameType.Find("KingOfTheHill")!=(-1))then
			m_bDomination=true;
		endif;
		if(p_sGameType.Find("Domination")!=(-1))then
			m_bDomination=true;
		endif;
		if(p_sGameType.Find("Defender")!=(-1))then
			m_bDefender=true;
		endif;
		return(true);
	endproc;
	
	export proc bool GetDimGate()
		return m_bDimGate;
	endproc;
	
	export proc void SetDimGate(bool p_bAllow)
		m_bDimGate=p_bAllow;
	endproc;
	
	export proc void SetPlayedTime(CGameTimeSpan p_xPlayedTime)
		m_xPlayedTime=p_xPlayedTime;
	endproc;
	
	export proc CGameTimeSpan GetPlayedTime()
		return m_xPlayedTime;
	endproc;
	
	// checksum of corresponding mapinfo
	export proc string GetLevelCheckSumme()
		return m_sLevelCheckSum;
	endproc;
	
	export proc void SetLevelCheckSumme(string p_sCHKSUM)
		m_sLevelCheckSum = p_sCHKSUM;
	endproc;
		
endclass;


class CMapListFilter

	export var int m_iPlayers;
	export var int m_iTeams;
	export var int m_iGameType; //0=Deathmatch,1=Koth,2=Defender
	
	export constructor()
		m_iPlayers	= 0;
		m_iTeams	= 0;
		m_iGameType	= 0;
	endconstructor;

endclass;

class CContentFilterList inherit CStaticCtrlEx
	
	var ^CDropList		m_pxDLMapList;
	var ^CDropList		m_pxDLGameType;
	var ^CDropList		m_pxDLMaxPlayer;
	var ^CDropList		m_pxDLTeams;
	var ^CStaticCtrl	m_pxStaticExcludeEnabledWarpgates;
	var ^CStaticCtrl	m_pxStaticExcludePrivateGames;
	var ^CStaticCtrl	m_pxStaticExcludeFullGames;
	var ^CCheckBox		m_pxCBExcludePrivateGames;
	var ^CCheckBox		m_pxCBExludeFullGames;
	var ^CCheckBox		m_pxCBExcludeEnabledWarpgate;
	var ^CEdit			m_pxEDGameName;
	var ^CButton		m_pxBtnClearFilters;
	
	var CMapListFilter	m_xMapFilter;
	
	var string			m_sMap;
	var string			m_sGameName;
	var int				m_iGameType;
	var int				m_iMaxPlayer;
	var int				m_iTeams;
	var int				m_iDisabledWarpgate;
	var int				m_iPrivateGames;
	var int				m_iFullGames;
	var string			m_sFilter;
	
	
	export constructor()
		InitFromResource("UI/GameListWindow","ContentFilterList");
		
		m_pxStaticExcludeEnabledWarpgates = cast<CStaticCtrl>(GetControl("StaticExcludeEnabledWarpgates"));
		m_pxStaticExcludeEnabledWarpgates^.SetTextIndent(7);
		
		m_pxStaticExcludePrivateGames = cast<CStaticCtrl>(GetControl("StaticExcludePrivateGames"));
		m_pxStaticExcludePrivateGames^.SetTextIndent(7);
		
		var ^CStaticCtrl pxTmp = cast<CStaticCtrl>(GetControl("PasswordIcon"));
		var string sBitmapPath = CClientWrap.GetUrsRelPath()+"/Data/Base/UI/menue/decoration/server_password.tga";
		pxTmp^.SetBitmap(sBitmapPath);
		
		var ^CStaticCtrl pxTmpWarpgate = cast<CStaticCtrl>(GetControl("WarpgateIcon"));
		var string sBitmapPathWarpgate = CClientWrap.GetUrsRelPath()+"/Data/Base/UI/menue/decoration/server_dimensiongate.tga";
		pxTmpWarpgate^.SetBitmap(sBitmapPathWarpgate);
		
		
		m_pxStaticExcludeFullGames = cast<CStaticCtrl>(GetControl("StaticExcludeFullGames"));
		m_pxStaticExcludeFullGames^.SetTextIndent(7);
		
		m_pxDLMapList = cast<CDropList>(GetControl("DLMapName"));
		var int i,iC=CMultiPlayerClientMgr.Get().GetNumMaps();
		
		if(m_pxDLMapList^.NumItems()>0) then
			m_pxDLMapList^.Select(0);
		endif;
		m_pxDLMapList^.m_xOnChange=OnChangeMap;
		
		m_pxDLGameType = cast<CDropList>(GetControl("DLGameType"));
		m_pxDLGameType^.AddItem(CLocalizer.Get().Translate("_GAMETYPE_Deathmatch"));
		m_pxDLGameType^.AddItem(CLocalizer.Get().Translate("_GAMETYPE_KingOfTheHill"));
		m_pxDLGameType^.AddItem(CLocalizer.Get().Translate("_GAMETYPE_Defender"));
		//m_pxDLGameType^.AddItem(CLocalizer.Get().Translate("_GAMETYPE_AllTypes"));
		m_pxDLGameType^.m_xOnChange.Clear();
		m_pxDLGameType^.Select(0);
		m_pxDLGameType^.m_xOnChange=OnChangeGameType;
		
		m_pxDLMaxPlayer = cast<CDropList>(GetControl("DLMaxPlayer"));
		m_pxDLMaxPlayer^.AddItem("---");
		for(i=2)cond(i<9)iter(i++)do
			m_pxDLMaxPlayer^.AddItem((i).ToString());
		endfor;
		m_pxDLMaxPlayer^.m_xOnChange.Clear();
		m_pxDLMaxPlayer^.Select(0);
		m_pxDLMaxPlayer^.m_xOnChange=OnChangeMaxPlayer;
		
		m_pxDLTeams = cast<CDropList>(GetControl("DLTeams"));
		m_pxDLTeams^.AddItem("---");
		for(i=2)cond(i<9)iter(i++)do
			m_pxDLTeams^.AddItem((i).ToString());
		endfor;
		m_pxDLTeams^.m_xOnChange.Clear();
		m_pxDLTeams^.Select(0);
		m_pxDLTeams^.m_xOnChange=OnChangeTeams;
		
		m_pxCBExcludePrivateGames = cast<CCheckBox>(GetControl("ExcludePrivateGames"));
		m_pxCBExcludePrivateGames^.m_xOnStateChange=OnExcludePrivateGamesChange;
		
		m_pxCBExludeFullGames = cast<CCheckBox>(GetControl("ExcludeFullGames"));
		m_pxCBExludeFullGames^.m_xOnStateChange=OnExludeFullGames;
		
		m_pxCBExcludeEnabledWarpgate = cast<CCheckBox>(GetControl("ExcludeDisabledWarpGates"));
		m_pxCBExcludeEnabledWarpgate^.m_xOnStateChange=OnExcludeEnabledWarpgate;
		
		m_pxEDGameName = cast<CEdit>(GetControl("EDGameName"));
		m_pxEDGameName^.m_xOnChange=OnChangeGameName;
		
		m_pxBtnClearFilters = cast<CButton>(GetControl("BtnClearFilters"));
		m_pxBtnClearFilters^.SetText(CLocalizer.Get().Translate("_UI_GamLWind_Button_ClearFilters"));
		m_pxBtnClearFilters^.SetTextIndent(5);
		m_pxBtnClearFilters^.m_xOnClick = OnClearFilter;
		
		m_sMap="all";
		m_sGameName="nonameforBeulchensgame";
		m_iGameType=-1;
		m_iMaxPlayer=-1;
		m_iTeams=-1;
		m_iDisabledWarpgate=-1;
		m_iPrivateGames=0;
		m_iFullGames=0;
		ReloadMapList();
		m_sFilter="";
		SetServerFilter();
	endconstructor;
	
	destructor()
	enddestructor;
	
	export proc void SendFilter()
		CGameWrap.SetServerFilter(m_sFilter);
	endproc;
	
	proc bool OnClearFilter()
		m_sMap="all";
		m_sGameName="nonameforBeulchensgame";
		m_iGameType=-1;
		m_iMaxPlayer=-1;
		m_iTeams=-1;
		m_iDisabledWarpgate=-1;
		m_iPrivateGames=0;
		m_iFullGames=0;
		
		
		m_pxCBExcludePrivateGames^.SetChecked(m_iPrivateGames);
		m_pxCBExcludePrivateGames^.m_xOnStateChange.Clear();
		
		m_pxCBExludeFullGames^.SetChecked(m_iFullGames);
		m_pxCBExludeFullGames^..m_xOnStateChange.Clear();
		
		m_pxCBExcludeEnabledWarpgate^.SetChecked(m_iDisabledWarpgate);
		m_pxCBExcludeEnabledWarpgate^..m_xOnStateChange.Clear();
		
		if (m_pxDLMapList^.NumItems() > 0) then
			m_pxDLMapList^.m_xOnChange.Clear();
			m_pxDLMapList^.Select(0);
		endif;
		if(m_pxDLGameType^.NumItems() > 0) then
			m_pxDLGameType^.m_xOnChange.Clear();
			m_pxDLGameType^.Select(4);
		endif;
		if(m_pxDLMaxPlayer^.NumItems() > 0) then
			m_pxDLMaxPlayer^.m_xOnChange.Clear();
			m_pxDLMaxPlayer^.Select(0);
		endif;
		
		if(m_pxDLTeams^.NumItems() > 0) then
			m_pxDLTeams^.m_xOnChange.Clear();
			m_pxDLTeams^.Select(0);
		endif;
		
		m_pxEDGameName^.m_xOnChange.Clear();
		m_pxEDGameName^.SetText("");
		SetServerFilter();
		
		m_pxDLMapList^.m_xOnChange=OnChangeMap;
		m_pxDLGameType^.m_xOnChange=OnChangeGameType;
		m_pxDLMaxPlayer^.m_xOnChange=OnChangeMaxPlayer;
		m_pxDLTeams^.m_xOnChange=OnChangeTeams;
		m_pxCBExcludePrivateGames^.m_xOnStateChange=OnExcludePrivateGamesChange;
		m_pxCBExludeFullGames^.m_xOnStateChange=OnExludeFullGames;
		m_pxCBExcludeEnabledWarpgate^.m_xOnStateChange=OnExcludeEnabledWarpgate;
		m_pxEDGameName^.m_xOnChange=OnChangeGameName;
		
		return true;
	endproc;
	
	export proc bool OnChangeGameType()
		m_iGameType=m_pxDLGameType^.GetSelectedItem();
		m_xMapFilter.m_iGameType=m_iGameType;
		SetServerFilter();
		ReloadMapList();
		return true;
	endproc;
	
	export proc bool OnChangeMaxPlayer()
		if(m_pxDLMaxPlayer^.GetSelectedItem()==0) then
			m_iMaxPlayer=-1;
		else
			m_iMaxPlayer=m_pxDLMaxPlayer^.GetSelectedItemAsString().ToInt();
		endif;
		var int iTeams = m_pxDLTeams^.GetSelectedItemAsString().ToInt();
		if(m_iMaxPlayer<iTeams) then
			m_iTeams=m_iMaxPlayer;
			if(m_pxDLMaxPlayer^.GetSelectedItem()==0) then
				m_pxDLTeams^.Select(0);
			else
				m_pxDLTeams^.Select(m_pxDLTeams^.FindItem(m_pxDLMaxPlayer^.GetSelectedItemAsString()));
			endif;
			m_xMapFilter.m_iTeams=m_iTeams;
		endif;
		m_xMapFilter.m_iPlayers=m_iMaxPlayer;
		SetServerFilter();
		ReloadMapList();
		return true;
	endproc;
	
	export proc bool OnChangeTeams()
		if(m_pxDLTeams^.GetSelectedItem()==0) then
			m_iTeams=-1;
		else
			m_iTeams=m_pxDLTeams^.GetSelectedItemAsString().ToInt();
		endif;
		var int iMaxPlayer = m_pxDLMaxPlayer^.GetSelectedItemAsString().ToInt();
		if(iMaxPlayer<m_iTeams) then 
			m_iMaxPlayer=m_iTeams;
			if(m_pxDLTeams^.GetSelectedItem()==0) then
				m_pxDLMaxPlayer^.Select(0);
			else
				m_pxDLMaxPlayer^.Select(m_pxDLMaxPlayer^.FindItem(m_pxDLTeams^.GetSelectedItemAsString()));
			endif;
			m_xMapFilter.m_iPlayers=m_iMaxPlayer;
		endif;
		m_xMapFilter.m_iTeams=m_iTeams;
		SetServerFilter();
		ReloadMapList();
		return true;
	endproc;
	
	export proc bool OnExcludePrivateGamesChange()
		m_iPrivateGames=m_pxCBExcludePrivateGames^.GetChecked();
		SetServerFilter();
		return true;
	endproc;
	
	export proc bool OnExludeFullGames()
		m_iFullGames=m_pxCBExludeFullGames^.GetChecked();
		SetServerFilter();
		return true;
	endproc;
	
	export proc bool OnExcludeEnabledWarpgate()
		m_iDisabledWarpgate=m_pxCBExcludeEnabledWarpgate^.GetChecked();
		SetServerFilter();
		return true;
	endproc;
	
	export proc bool OnChangeGameName()
		m_sGameName=m_pxEDGameName^.GetText();
		SetServerFilter();
		return true;
	endproc;
	
	export proc bool OnChangeMap()
		if(m_pxDLMapList^.GetSelectedItem()==0) then
			m_sMap="all";
		else
			//m_sMap=m_pxDLMapList^.GetSelectedItemAsString();
			var ^CMapData pxData = cast <CMapData>(m_pxDLMapList^.GetItemData(m_pxDLMapList^.GetSelectedItem()));
			if(pxData!=null) then
				m_sMap = pxData^.GetMapName();
			endif;
		endif;
		SetServerFilter();
		return true;
	endproc;
	
	export proc void SetServerFilter() 
		/*	Filter order:
			1) Map
			2) exclude full games
			3) Gametype (4 = all game types)
			4) MaxPlayer
			5) Teams
			6) exclude warpgate games
			7) exclude private games
			8) Gamename
		*/
		m_sFilter="";
		m_sFilter=m_sMap+"|"+m_iFullGames.ToString()+"|"+m_iGameType.ToString()+"|"+m_iMaxPlayer.ToString()+"|"+m_iTeams.ToString()+"|"+m_iDisabledWarpgate.ToString()+"|"+m_iPrivateGames.ToString()+"|"+m_sGameName;
	endproc;
	
	proc bool FilterList()
		m_pxDLMapList^.m_xOnChange.Clear();
		var int i,iC=m_pxDLMapList^.NumItems();		
		for(i=0)cond(i<iC)iter(i++)do
			var ^CMapData pxTmp=(cast<CMapData>(m_pxDLMapList^.GetItemData(i)));
			if(pxTmp!=null)then				
				if(pxTmp^.GetPlayers() < m_xMapFilter.m_iPlayers)then
					m_pxDLMapList^.DeleteItem(i);
					i--;iC--;
					continue;
				endif;
				
				if(pxTmp^.GetPlayers() < m_xMapFilter.m_iTeams) then
					m_pxDLMapList^.DeleteItem(i);
					i--;iC--;
					continue;
				endif;					

				if(!(pxTmp^.GetGameType(m_xMapFilter.m_iGameType))) then
					m_pxDLMapList^.DeleteItem(i);
					i--;iC--;
					continue;
				endif;	
			endif;
		endfor;	
		m_pxDLMapList^.m_xOnChange=OnChangeMap;
		return(true);
	endproc;
	
	proc void ReloadMapList()		
		m_pxDLMapList^.m_xOnChange.Clear();
		var int j,jC=m_pxDLMapList^.NumItems();
		for(j=0)cond(j<jC)iter(j++)do
			m_pxDLMapList^.DeleteItem(j);
			j--;
			jC--;
		endfor;
		m_pxDLMapList^.Clear();
		
		m_pxDLMapList^.AddItem(CLocalizer.Get().Translate("_UI_MPlLobby_Maplist_AllMaps"));
		var int i,iC=CMultiPlayerClientMgr.Get().GetNumMaps();		
		for(i=0)cond(i<iC)iter(i++)do
			var ^CMapData pxData = CMultiPlayerClientMgr.Get().GetMapEntry(i);
			if(pxData == null) then continue; endif;
			var string sMapName=CLocalizer.Get().Translate(pxData^.GetMapName());			
			m_pxDLMapList^.AddItem(sMapName,pxData);			
		endfor;	
		if(m_iGameType<3) then
			FilterList();
		endif;
		m_pxDLMapList^.m_xOnChange=OnChangeMap;
	endproc;	
endclass;
