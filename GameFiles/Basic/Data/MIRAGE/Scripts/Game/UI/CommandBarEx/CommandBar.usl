// Valid Categories are
//
// --> PROD		= Produce/Invent
// --> TRAD 	= Trade
// --> SLOT		= Slots
// --> BUIL		= Build
// --> STNC		= Stances
// --> SPEC		= Special
// --> ACTN		= ActionButton (appearance and action is defined through command)
// --> TRAP		= For the traps of dragonclan. Needed because dc has too many buildings (cc 30-31) to give each one an appropriate hotkey

// MenuBtn : 53 x 59
// ActBtn  : 45 x 59
// InfoWnd : 209 x 197
// Flyout  : XXX x 138
// Flyout  : Abstand der Karten :  3px ... nach oben 9px .... nach links: 8px
// Flyout  : KartenSize: 37 x 36

class CInvoke
	export const int OBJCHG=0;
	export const int PLYRCHG=1;
	export const int PYRAMIDCHG=2;
endclass;

class CProgressButton inherit CCmdBarButton
	
	class CLocationFlags
		export var array string m_asLocationFlags;
	endclass;
	
	var ^CStaticCtrl m_pxQueueCnt;
	var ^CProgressBar m_pxProgress;

	var CClntHndl m_xSelObj;
	var string m_sResultTT;
	var bool m_bSpecial;

	var int m_iSpecialTimer;
	var real m_fDuration;
	//var real m_fPassed; //that doesn't work, SUIT timers are not that exact
	var CGameTime m_xStartTime;
	var ^CCardBitmap m_pxFlashBitmap;
	var string m_sBitmap;
	var int m_iLevel;

/*	export var procref<bool>	m_xOnDoAction;
	export var procref<bool>	m_xOnCancelAction;
*/
//	export constructor(CClntHndl p_xSelObj, string p_sTTPath)
	export constructor(CObjList p_xObjects, CClntHndl p_xSelObj, string p_sTTPath)
		m_sResultTT=p_sTTPath;
		m_bSpecial=false;
		if(m_sResultTT.Find("/Moves/")>=0)then
			m_bSpecial=true;
//		elseif(m_sResultTT.Find("/Upgrades/babbage_s0/mechanization")>=0)then
//			m_bSpecial=true;
		endif;
		var int iIdx=0;
		if(IsProcessing(p_xObjects, iIdx))then
			if(iIdx!=-1)then
				m_xSelObj=p_xObjects[iIdx];
			else
				m_xSelObj=p_xSelObj;
			endif;
		else
			m_xSelObj=p_xSelObj;
		endif;
		m_pxQueueCnt=new CStaticCtrl();
		m_pxProgress=new CProgressBar();
		m_pxProgress^.SetVertical(true);
		AddChild(m_pxProgress);
		m_pxQueueCnt^.SetVisible(true);
		m_pxQueueCnt^.SetTextColor({{255, 255, 255, 255}});
		m_pxProgress^.AddChild(m_pxQueueCnt);
		m_pxProgress^.SetAlwaysOnTop(false);
		m_pxProgress^.SetTransparent(true);
		m_pxProgress^.SetPos(0,0);
		m_pxProgress^.SetVisible(false);
		SetIgnoreDoubleClick(true);
/*		m_xOnClick=OnClick;
		m_xOnRightClick=OnRightClick;
		m_xOnDoubleClick=OnClick;
*/		m_iSpecialTimer=-1;
		m_pxFlashBitmap=null;
	endconstructor;

	destructor()
		if(m_pxQueueCnt!=null)then m_pxQueueCnt^.Destroy(); endif;
		if(m_pxProgress!=null)then m_pxProgress^.Destroy(); endif;
		CGameWrap.GetSubscriptionMgr().UnsubscribeObjChanges(this);
		m_pxFlashBitmap=null;
		UnsetTimer(m_iSpecialTimer);
	enddestructor;

	export proc void SetBitmaps(^CCardBitmap p_pxIdle,^CCardBitmap p_pxDown,^CCardBitmap p_pxHovered,^CCardBitmap p_pxDisabled, ^CCardBitmap p_pxFlash)
		super.SetBitmap(p_pxIdle^.GetBitmap(), p_pxDown^.GetBitmap(), p_pxHovered^.GetBitmap(),p_pxDisabled^.GetBitmap());
		SetFlashBitmap(p_pxFlash);
	endproc;

	export proc void SetFlashBitmap(^CCardBitmap p_pxFlashBmp)
		m_pxFlashBitmap=p_pxFlashBmp;
	endproc;

	export proc void Initialize(string p_sIcon, int p_iLvl)
		if(m_iSpecialTimer!=-1)then
			UnsetTimer(m_iSpecialTimer);
		endif;
		m_iSpecialTimer=-1;
		m_sBitmap=p_sIcon;
		m_iLevel=p_iLvl;
		if(p_sIcon.IsEmpty())then
			m_sBitmap="_dummy";
		endif;
		var string sLevelLayerA="";
		var string sLevelLayerB="";
		if(p_iLvl > 0)then
			sLevelLayerA=", layer menucmd_lvl"+p_iLvl.ToString()+"_ovl";
			sLevelLayerB=", blend menucmd_lvl"+p_iLvl.ToString()+"_ovl 30";
		endif;
		m_pxProgress^.SetBitmaps(CGameInst.GetBitmapMgr().GetBlendBitmap("2, layer menucmd_back, layer "+m_sBitmap+sLevelLayerA)^.GetBitmap(),CGameInst.GetBitmapMgr().GetBlendBitmap("2, layer menucmd_back, gamma 2.0, blend "+m_sBitmap+" 30"+sLevelLayerB)^.GetBitmap());
		CGameWrap.GetSubscriptionMgr().UnsubscribeObjChanges(this);
		var CTechTree xTT;
		var ^CPlayer pxPlayer=^(CGameWrap.GetClient().GetPlayer());
		if(pxPlayer!=null)then
			xTT=pxPlayer^.GetPlayerTechTree();
		endif;
		var array string asLocationClasses;
		var array CLocationFlags axLocationFlags;
		var ^CTechTree.CNode pxLocNode=xTT.FindNode(m_sResultTT+"/locations");
		if(pxLocNode!=null)then
			var int iL=pxLocNode^.NumSubs();
			asLocationClasses=iL;
			axLocationFlags=iL;
			var int i, iC=pxLocNode^.NumSubs();
			for(i=0)cond(i<iC)iter(++i)do
				var ^CTechTree.CNode pxLocation=pxLocNode^.GetSub(i);
				if(pxLocation!=null)then
					var array string asToks;
					pxLocation^.GetValue().Split(asToks, "/", true);
					var int iIdx=asToks.NumEntries()-1;
					if(iIdx>=0)then
						asLocationClasses[i]=asToks[iIdx];
						var ^CTechTree.CNode pxLocalFlags=pxLocation^.GetSub("localflags");
						if(pxLocalFlags!=null)then
							var int j,iJC=pxLocalFlags^.NumSubs();
							for(j=0)cond(j<iJC)iter(j++)do
								if(pxLocalFlags^.GetSub(j)^.GetValueI()==1)then
									axLocationFlags[i].m_asLocationFlags.AddEntry(pxLocalFlags^.GetSub(j)^.GetName());
								endif;
							endfor;
						endif;
					endif;
				endif;
			endfor;
		endif;
		var CObjList xLO=CGameWrap.GetSelection();
		var bool bFoundProcessing=false;
		var real fHighestProgress=0.0f;
		var bool bBldg;
		var CObjList xL=CMirageClnMgr.Get().GetFocusList(xLO,true);
		var int i, iC=xL.NumEntries();
		for(i=0)cond(i<iC)iter(++i)do
			var ^CObj pxO=xL[i].GetObj();
			if(pxO==null)then continue; endif;
			var bool bClassMatch=false;
			var int j,jC=asLocationClasses.NumEntries();
			for(j=0)cond(j<jC)iter(++j)do
				bClassMatch=(pxO^.GetClassName()==asLocationClasses[j]);
				if(!bClassMatch)then
					bClassMatch=(pxO^.GetType()==asLocationClasses[j]);
				endif;
				if(bClassMatch&&axLocationFlags[j].m_asLocationFlags.NumEntries()!=0)then
					var ^CAttribs pxAttr=pxO^.GetAttribs();
					if(pxAttr==null||pxAttr^.GetValue("ObjFlag")=="")then bClassMatch=false; continue; endif;
					bClassMatch=axLocationFlags[j].m_asLocationFlags.FindEntry(pxAttr^.GetValue("ObjFlag"))!=-1;
				endif;
				if(bClassMatch)then
					break;
				endif;
			endfor;
			if(!bClassMatch)then continue; endif;
			var ^CAttribs pxAttr=pxO^.GetAttribs();
			if(pxAttr!=null)then
				var int iNodeUID=0;
				var ^CPlayer pxPlayer=^(CGameWrap.GetClient().GetPlayer());
				if(pxPlayer!=null)then
					var ^CTechTree.CNode pxNode=pxPlayer^.GetPlayerTechTree().FindNode(m_sResultTT);
					if(pxNode!=null)then
						iNodeUID=pxNode^.GetHashValue();
					endif;
				endif;
				var bool bGefunden=false;
				var string sSpecial=pxAttr^.GetValue("SpecialActionCounters");
				if(!sSpecial.IsEmpty() && m_bSpecial)then
					var array string asActions, asToks;
					sSpecial.Split(asActions, "\n", true);
					var int i, iC=asActions.NumEntries();
					for(i=0) cond(i<iC) iter(++i) do
						asToks=0;
						asActions[i].Split(asToks, "|", true);
						if(asToks.NumEntries()!=3)then continue; endif;
						if(asToks[0].ToInt()==iNodeUID)then
							bGefunden=true;
							if(m_iSpecialTimer==-1)then
								m_xStartTime.FromString(asToks[1]);
								m_iSpecialTimer=SetTimer(1000, true);
								m_pxProgress^.SetVisible(true);
								m_pxQueueCnt^.SetText("");
								var real fPassed=(CTimeMgr.Get().GetTime()-m_xStartTime).GetSecondsF();
								m_fDuration=asToks[2].ToReal();
								SetProgress(fPassed/(m_fDuration*0.01f));
								var string sLevelLayerA="";
								var string sLevelLayerB="";
								var real fProgress=0.0f;
								if(m_fDuration>0.0f)then
									fProgress=fPassed/(m_fDuration*0.01f);
								endif;
								var int iBase=45;
								var int iBase2=10;
								iBase+=((100.0-fProgress)*0.55).ToInt();
								iBase2+=((100.0-fProgress)*0.2).ToInt();
								if(m_iLevel > 0)then
									sLevelLayerA=", layer menucmd_lvl"+m_iLevel.ToString()+"_ovl "+iBase.ToString();
									sLevelLayerB=", blend menucmd_lvl"+m_iLevel.ToString()+"_ovl "+iBase2.ToString();
								endif;
								m_pxProgress^.SetBitmaps(CGameInst.GetBitmapMgr().GetBlendBitmap("2, layer menucmd_back, gamma 2.0, blend "+m_sBitmap+" "+iBase.ToString()+sLevelLayerA)^.GetBitmap(), CGameInst.GetBitmapMgr().GetBlendBitmap("2, layer menucmd_back, gamma 2.0, blend "+m_sBitmap+" "+iBase2.ToString()+sLevelLayerB)^.GetBitmap());
							endif;
						endif;
					endfor;
				endif;
				if(!bGefunden)then
					var string sProdQueue=pxAttr^.GetValue("ProdQueue");
					var array string asToks;
					sProdQueue.Split(asToks, ":", true);
					var int iCnt=0;
					var int i, iC=asToks.NumEntries();
					for(i=0) cond(i<iC) iter(++i) do
						if(asToks[i].ToInt()==iNodeUID)then
							++iCnt;
						endif;
					endfor;
					var int iReactorProgress=0;
					var string sReactorObj="";
					iCnt += CMirageClnMgr.GetReactorInfo(pxAttr, iReactorProgress, sReactorObj, iNodeUID);
					if((pxAttr^.GetValue("CurProcessObj")==m_sResultTT||sReactorObj==m_sResultTT) && iCnt==0)then
						++iCnt;
					endif;
					if(iCnt>1)then
						m_pxQueueCnt^.SetText(iCnt.ToString());
					else
						m_pxQueueCnt^.SetText("");
					endif;
					var bool bOwnCPO=m_sResultTT==pxAttr^.GetValue("CurProcessObj");
					if(bOwnCPO||m_sResultTT==sReactorObj)then
						bFoundProcessing=true;
						var real fProgressSum;
						if(bOwnCPO)then
							fProgressSum=pxAttr^.GetValueInt("CurProcess").ToReal();
						else
							fProgressSum=iReactorProgress.ToReal();
						endif;
						if(fProgressSum>fHighestProgress)then
							fHighestProgress=fProgressSum;
						endif;
						m_pxProgress^.SetVisible(true);
						SetProgress(fHighestProgress);
					elseif(iCnt>0 && !bFoundProcessing)then
						m_pxProgress^.SetVisible(true);
						SetProgress(0.0f);
					elseif(!bFoundProcessing)then
						m_pxProgress^.SetVisible(false);
						SetProgress(0.0f);
					endif;
				endif;
			endif;
		endfor;
		if(m_xSelObj.IsValid())then
			CGameWrap.GetSubscriptionMgr().SubscribeObjChanges(this,m_xSelObj,CSubscriptionMgr.CT_ObjAttribs, "ActionMenuProgress");
			var ^CObj pxO=m_xSelObj.GetObj();
		endif;
	endproc;

	export proc bool IsProcessing()
		var ^CObj pxO=m_xSelObj.GetObj();
		if(pxO!=null)then
			var ^CAttribs pxA=pxO^.GetAttribs();
			if(pxA!=null)then
				var string sProcObj=pxA^.GetValue("CurProcessObj");
				var string sProdQueue=pxA^.GetValue("ProdQueue");
				var real fProc=pxA^.GetValueInt("CurProcess").ToReal();
				if(sProcObj==m_sResultTT && fProc>0.0f)then  return true; endif;
				var array string asToks;
				sProdQueue.Split(asToks, ":", true);
				var int iIdx=0;
				var ^CPlayer pxPlayer=^(CGameWrap.GetClient().GetPlayer());
				if(pxPlayer!=null)then
					var ^CTechTree.CNode pxNode=pxPlayer^.GetPlayerTechTree().FindNode(m_sResultTT);
					if(pxNode!=null)then
						iIdx=pxNode^.GetHashValue();
					endif;
				endif;
				var int iCnt=0;
				var int i, iC=asToks.NumEntries();
				for(i=0) cond(i<iC) iter(++i) do
					if(asToks[i].ToInt()==iIdx)then ++iCnt; endif;
				endfor;
				return iCnt>0;
			endif;
		endif;
		return false;
	endproc;
	
	export proc bool IsProcessing(CObjList p_xObjects)
		var int i=0;
		return IsProcessing(p_xObjects, i);
	endproc;
	
	export proc bool IsProcessing(CObjList p_xObjects, ref int p_riIdx)
		var int iC=p_xObjects.NumEntries();
		var int iCnt, iIdx=0;
		var ^CPlayer pxPlayer=^(CGameWrap.GetClient().GetPlayer());
		var ^CTechTree.CNode pxNode;
		if(pxPlayer!=null)then
			pxNode=pxPlayer^.GetPlayerTechTree().FindNode(m_sResultTT);
			if(pxNode!=null)then
				iIdx=pxNode^.GetHashValue();
			endif;
		endif;
		for(p_riIdx=0)cond(p_riIdx<iC)iter(++p_riIdx)do
			if(!p_xObjects[p_riIdx].IsValid())then continue; endif;
			var ^CObj pxO=p_xObjects[p_riIdx].GetObj();
			if(pxO!=null)then
				var ^CAttribs pxA=pxO^.GetAttribs();
				if(pxA!=null)then
					var string sProcObj=pxA^.GetValue("CurProcessObj");
					var string sProdQueue=pxA^.GetValue("ProdQueue");
					var real fProc=pxA^.GetValueInt("CurProcess").ToReal();
					var int iReactorProgress=0;
					var string sReactorObj="";
					iCnt += CMirageClnMgr.GetReactorInfo(pxA, iReactorProgress, sReactorObj, iIdx);
					if((sProcObj==m_sResultTT && fProc>0.0f)||(sReactorObj==m_sResultTT && iReactorProgress.ToReal()>0.0f))then
						return true;
					endif;
					if(iIdx==0)then continue; endif;
					var array string asToks;
					sProdQueue.Split(asToks, ":", true);
					var int ij, iJC=asToks.NumEntries();
					for(ij=0) cond(ij<iJC) iter(++ij) do
						if(asToks[ij].ToInt()==iIdx)then ++iCnt; endif;
					endfor;
				endif;
			endif;
		endfor;
		p_riIdx=-1;
		return iCnt>0;
	endproc;

	export proc void SetSize(int p_iW, int p_iH)
		//ScaleFactor
		super.SetSize(p_iW*CGameInst.ms_iUIScaleFactor, p_iH*CGameInst.ms_iUIScaleFactor);
		m_pxProgress^.SetSize(p_iW*CGameInst.ms_iUIScaleFactor, p_iH*CGameInst.ms_iUIScaleFactor);
		m_pxQueueCnt^.SetSize(p_iW*CGameInst.ms_iUIScaleFactor, p_iH*CGameInst.ms_iUIScaleFactor);
	endproc;

	export proc void SetProgress(real p_fP)
		m_pxProgress^.SetProgress(p_fP);
	endproc;

	proc bool OnTimer(int p_iID)
		if(m_iSpecialTimer==p_iID)then
			var real fPassed=(CTimeMgr.Get().GetTime()-m_xStartTime).GetSecondsF();
			var real fProgress=fPassed/(m_fDuration*0.01f);
			if(fProgress>=100.0f)then
				SetProgress(0.0f);
				m_pxProgress^.SetVisible(false);
				UnsetTimer(m_iSpecialTimer);
				m_iSpecialTimer=-1;
				return true;
			else
				var string sLevelLayerA="";
				var string sLevelLayerB="";
				var int iBase=45;
				var int iBase2=10;
				iBase+=((100.0-fProgress)*0.55).ToInt();
				iBase2+=((100.0-fProgress)*0.2).ToInt();
				if(m_iLevel > 0)then
					sLevelLayerA=", layer menucmd_lvl"+m_iLevel.ToString()+"_ovl "+iBase.ToString();
					sLevelLayerB=", blend menucmd_lvl"+m_iLevel.ToString()+"_ovl "+iBase2.ToString();
				endif;
				m_pxProgress^.SetBitmaps(CGameInst.GetBitmapMgr().GetBlendBitmap("2, layer menucmd_back, gamma 2.0, blend "+m_sBitmap+" "+iBase.ToString()+sLevelLayerA)^.GetBitmap(), CGameInst.GetBitmapMgr().GetBlendBitmap("2, layer menucmd_back, gamma 2.0, blend "+m_sBitmap+" "+iBase2.ToString()+sLevelLayerB)^.GetBitmap());
				SetProgress(fProgress);
				return false;
			endif;
		endif;
		return false;
	endproc;
	
	export proc bool HandleMessage(ref CEvtPointer p_rxEvt)
		if(p_rxEvt.GetClass()==CSubscriptionMgr.GetEvtClass_ObjChange())then
			var CClntHndl xObjHandle;
			var bitset dwTypes, dwAttribGroups;
			if(CSubscriptionMgr.EvtGetData_ObjChange(p_rxEvt,xObjHandle,dwTypes,dwAttribGroups))then
				if((dwTypes & CSubscriptionMgr.CT_ObjAttribs) != 0d)then
					if(!xObjHandle.IsValid())then return false; endif;
					if(!(xObjHandle==m_xSelObj))then return false; endif;
					var ^CObj pxO=xObjHandle.GetObj();
					if(pxO==null)then return false; endif;
					var ^CAttribs pxAttr=pxO^.GetAttribs();
					if(pxAttr!=null)then
						var int iNodeUID=0;
						var ^CPlayer pxPlayer=^(CGameWrap.GetClient().GetPlayer());
						if(pxPlayer!=null)then
							var ^CTechTree.CNode pxNode=pxPlayer^.GetPlayerTechTree().FindNode(m_sResultTT);
							if(pxNode!=null)then
								iNodeUID=pxNode^.GetHashValue();
							endif;
						endif;
						var string sSpecial=pxAttr^.GetValue("SpecialActionCounters");
						var bool bGefunden=false;
						if(!sSpecial.IsEmpty() && m_bSpecial)then
							var array string asActions, asToks;
							sSpecial.Split(asActions, "\n", true);
							var int i, iC=asActions.NumEntries();
							for(i=0) cond(i<iC) iter(++i) do
								asToks=0;
								asActions[i].Split(asToks, "|", true);
								if(asToks.NumEntries()!=3)then continue; endif;
								if(asToks[0].ToInt()==iNodeUID)then
									bGefunden=true;
									if(m_iSpecialTimer==-1)then
										m_xStartTime.FromString(asToks[1]);
										m_iSpecialTimer=SetTimer(1000, true);
										m_pxProgress^.SetVisible(true);
										m_pxQueueCnt^.SetText("");
										var real fPassed=(CTimeMgr.Get().GetTime()-m_xStartTime).GetSecondsF();
										m_fDuration=asToks[2].ToReal();
										SetProgress(fPassed/(m_fDuration*0.01f));
									endif;
								endif;
							endfor;
						endif;
						if(!bGefunden)then
							var string sProdQueue=pxAttr^.GetValue("ProdQueue");
							var array string asToks;
							sProdQueue.Split(asToks, ":", true);
							var int iCnt=0;
							var int i, iC=asToks.NumEntries();
							for(i=0) cond(i<iC) iter(++i) do
								if(asToks[i].ToInt()==iNodeUID)then ++iCnt; endif;
							endfor;
							var int iReactorProgress=0;
							var string sReactorObj="";
							iCnt += CMirageClnMgr.GetReactorInfo(pxAttr, iReactorProgress, sReactorObj, iNodeUID);
							if((pxAttr^.GetValue("CurProcessObj")==m_sResultTT||sReactorObj==m_sResultTT) && iCnt==0)then
								++iCnt;
							endif;
							if(iCnt>1)then
								m_pxQueueCnt^.SetText(iCnt.ToString());
							else
								m_pxQueueCnt^.SetText("");
							endif;
							if(m_sResultTT==pxAttr^.GetValue("CurProcessObj")||m_sResultTT==sReactorObj)then
								m_pxProgress^.SetVisible(true);
								SetProgress(Math.Max(pxAttr^.GetValueInt("CurProcess").ToReal(), iReactorProgress.ToReal()));
							elseif(iCnt>0)then
								m_pxProgress^.SetVisible(true);
								SetProgress(0.0f);
							else
								m_pxProgress^.SetVisible(false);
								SetProgress(0.0f);
							endif;
						endif;
					endif;
				endif;
			endif;
			return true;
		endif;
		return false;
	endproc;
endclass;

class CActionMenu
	export const int MENU_NONE			= 0;
	export const int MENU_BUILDING		= 1;
	export const int MENU_UNIT 			= 2;

	const bitset FLAG_CAN_FIGHT			= 0000001h;
	const bitset FLAG_CAN_MOVE			= 0000002h;
	const bitset FLAG_HOLD_UNITS		= 0000004h;
	const bitset FLAG_DISMOUNT_NO_SEC	= 0000008h;
	const bitset FLAG_GATE				= 0000010h;
	const bitset FLAG_SHOW_STANCES		= 0000020h;
	const bitset FLAG_SHOW_TRADE		= 0000040h;
	const bitset FLAG_SHOW_RALLY		= 0000080h;
	const bitset FLAG_SHOW_LEVEL_UP		= 0000100h;
	const bitset FLAG_CAN_LEVEL_UP		= 0000200h;
	const bitset FLAG_CAN_PRODUCE		= 0000400h;
	const bitset FLAG_CAN_BUILD			= 0000800h;
	const bitset FLAG_HAS_SPECIAL_ACT	= 0001000h;
	const bitset FLAG_SHOW_KILLBTN		= 0002000h;
	const bitset FLAG_CAN_HARVEST		= 0004000h;
	const bitset FLAG_CAN_EAT			= 0008000h;
	const bitset FLAG_CAN_FISH			= 0100000h;
	const bitset FLAG_CAN_HUNT			= 0200000h;
	const bitset FLAG_CAN_TRAPS			= 0400000h;
	const bitset FLAG_MOUNTABLE			= 0800000h;

	const bitset FLAG_HIDE_RALLY		= 0010000h;
	const bitset FLAG_HIDE_WALK			= 0020000h;
	const bitset FLAG_HIDE_REPAIR		= 0040000h;
	const bitset FLAG_HIDE_TRANSPORT	= 0080000h;

	var int m_iPOS_X;
	var int m_iMENUBTN_WIDTH;
	var int m_iACTBTN_WIDTH;
	
	var int m_iType;
	var ^CCommandBar m_pxParent;
	var array CCmdButton m_axButtons;
	var array CCmdButton m_axCmdButtons;
	var CFourCC m_xLastFlyout;
	var bitset m_dwFlags;
	var CClntHndl m_xSelObj;
	var string m_sCurName;
	var string m_sCurType;

	export constructor(^CCommandBar p_pxParent)
		m_pxParent=p_pxParent;
		m_dwFlags=0b;
		m_sCurName="";
		m_sCurType="";
		m_iPOS_X = 209 * CGameInst.ms_iUIScaleFactor;
		m_iMENUBTN_WIDTH = 53 * CGameInst.ms_iUIScaleFactor;
		m_iACTBTN_WIDTH = 45 * CGameInst.ms_iUIScaleFactor;
	endconstructor;

	export destructor()
		m_axCmdButtons=0;
		m_axButtons=0;
		m_sCurName="";
		m_sCurType="";
	enddestructor;

	export proc void SetSelObj()
		var CObjList xSel=m_pxParent^.m_xCurSelection;
		m_xSelObj.Invalidate();
		if(xSel.NumEntries()>0)then
			m_xSelObj=xSel[0];
			if(!xSel[0].IsValid())then return; endif;
			if(xSel[0].GetObj()==null)then return; endif;
			m_sCurName=xSel[0].GetObj()^.GetClassName();
			m_sCurType=xSel[0].GetObj()^.GetType().AsString();
		endif;
	endproc;

	export proc ^CCmdButton FindMatchingMenuBtn(string p_sCat)
		var int i, iC=m_axButtons.NumEntries();
		for(i=0) cond(i<iC) iter(++i) do
			if(m_axButtons[i].GetCategory()==p_sCat)then
				return ^m_axButtons[i];
			endif;
		endfor;
		return null;
	endproc;

	export proc ^CCmdButton FindActionButton(string p_sAction)
		var int	i, iC=m_axButtons.NumEntries();
		for(i=0) cond(i<iC) iter(++i) do
			if(m_axButtons[i].GetType ()==CCmdButton.TYPE_ACTION && m_axButtons[i].GetCommand()==p_sAction)then
				return(^m_axButtons[i]);
			endif;
		endfor;
		return(null);
	endproc;

	export proc ^CCmdButton GetMenuButton(CFourCC p_xCat)
		var int i,iC=m_axButtons.NumEntries();
		for(i=0) cond(i<iC) iter(++i) do
			if(m_axButtons[i].GetCategory()==p_xCat.AsString())then
				return ^(m_axButtons[i]);
			endif;
		endfor;
		return null;
	endproc;

	export proc void ToggleAccelerators(bool p_bEnable)
		var int i, iC=m_axButtons.NumEntries();
		for(i=0)cond(i<iC)iter(++i)do
			if(m_axButtons[i].GetType ()==CCmdButton.TYPE_MENU||m_axButtons[i].GetType()==CCmdButton.TYPE_ACTION)then
//				(^m_axButtons[i])^.ShowAccelerator(p_bEnable);
				m_axButtons[i].ShowAccelerator(p_bEnable);
			endif;
		endfor;
	endproc;

	export proc ^CCmdButton FindCmdbarButton(string p_sAction)
		var int i, iC=m_axButtons.NumEntries();
		for(i=0) cond(i<iC) iter(++i) do
			if((m_axButtons[i].GetType ()==CCmdButton.TYPE_ACTION||m_axButtons[i].GetType ()==CCmdButton.TYPE_MENU) && m_axButtons[i].GetCommand()==p_sAction)then
				return(^m_axButtons[i]);
			endif;
		endfor;
		return(null);
	endproc;

	export proc bool FindCmdbarButtons(string p_sKey, ref array ^CCmdButton p_rapxButtons)
		p_rapxButtons=0;
		if(p_sKey=="")then return false; endif;
		var int i, iCnt=0, iC=m_axButtons.NumEntries();
		for(i=0)cond(i<iC)iter(++i)do
			if((m_axButtons[i].GetType()==CCmdButton.TYPE_ACTION||m_axButtons[i].GetType()==CCmdButton.TYPE_MENU)&&m_axButtons[i].GetHotKey()==p_sKey)then
				iCnt++;
				p_rapxButtons.AddEntry(^m_axButtons[i]);
			endif;
		endfor;
		return iCnt>0;
	endproc;

	proc bool CanLevelUp(^CObj p_pxObj)
		if(p_pxObj==null)then return false; endif;
		var int iNumScalps=0;
		var ^CPlayer pxPlayer=^(CGameWrap.GetClient().GetPlayer());
		if(pxPlayer!=null)then
			var ^CAttribs pxPlA=pxPlayer^.GetAttribs();
			var ^CAttribs pxObjA=p_pxObj^.GetAttribs();
			if(pxPlA!=null && pxObjA!=null)then
				if(!pxObjA^.GetValue("passenger_guids").IsEmpty())then
					var array string asToks;
					pxObjA^.GetValue("passenger_guids").Split(asToks, "\n", true);
					var int iCpt=pxObjA^.GetValueInt("captain");
					if(iCpt>=0 && iCpt<asToks.NumEntries())then
						//var CGuid xG; xG.FromString(asToks[iCpt]);
						//p_pxObj=CGameWrap.GetObjMgr().GetObj(xG);
						if(p_pxObj!=null)  then
							pxObjA=p_pxObj^.GetAttribs();
						endif;
					endif;
				endif;
				iNumScalps=pxPlA^.GetValueInt("iron");
//				var int iNextLevel=(pxObjA^.GetValueInt("level")+1);
//				var int iCost=pxPlA^.GetValueInt("foodcost_lvl_"+iNextLevel.ToString());
//				if(iNextLevel>=5)then return false; endif;
//				var bool bPyr=m_pxParent^.CheckCharacterConditions(iNextLevel, false);
//				return (iCost<=iNumScalps)&&bPyr;
				var int i, iNextLevel=(pxObjA^.GetValueInt("level")+1);
				if(iNextLevel>=5)then return false; endif;
				for(i=iNextLevel)cond(i<5)iter(i++)do
					var int iCost=pxPlA^.GetValueInt("foodcost_lvl_"+i.ToString());
					var bool bPyr=m_pxParent^.CheckCharacterConditions(i, false);
					if(iCost<=iNumScalps&&bPyr)then
						return true;
					endif;
				endfor;
			endif;
		endif;
		return false;
	endproc;

	export proc void ValidateLevelUpBtn()
		if((m_dwFlags&FLAG_SHOW_LEVEL_UP)!=0b)then
			var CObjList xSel=CClientWrap.GetSelection();
			var int iNumScalps=0;
			var ^CPlayer pxPlayer=^(CGameWrap.GetClient().GetPlayer());
			if(pxPlayer!=null)then
				var ^CAttribs pxPlA=pxPlayer^.GetAttribs();
				if(pxPlA!=null)then
					iNumScalps=pxPlA^.GetValueInt("iron");
				endif;
			endif;
			if(iNumScalps<10)then return; endif;
			var bool bOn=false;
			var int i, iC=xSel.NumEntries();
			for(i=0) cond(i<iC) iter(++i) do
				if(CanLevelUp(xSel[i].GetObj()))then
					if((m_dwFlags&FLAG_CAN_LEVEL_UP)!=0b)then return; endif;
					m_dwFlags|=FLAG_CAN_LEVEL_UP;
					bOn=true;
					break;
				endif;
			endfor;
			if(!bOn)then
				if((m_dwFlags&FLAG_CAN_LEVEL_UP)==0b)then return; endif;
				m_dwFlags&=~FLAG_CAN_LEVEL_UP;
			endif;
			i=m_axButtons.NumEntries()-1;
			for(i=i) cond(i>=0) iter(--i) do
				if(m_axButtons[i].GetType()==CCmdButton.TYPE_ACTION)then
					if(m_axButtons[i].GetCommand()=="levelup")then
						m_axButtons[i].SetDisabled((m_dwFlags&FLAG_CAN_LEVEL_UP)==0b);
						if((m_dwFlags&FLAG_CAN_LEVEL_UP)==0b)then
							m_axButtons[i].SetToolTipText("Level up \nNot enough Skulls or no free Slot.");
						endif;
					endif;
				endif;
			endfor;
		endif;
	endproc;

	export proc void InvalidateFlags()
		m_dwFlags=0b;
	endproc;

	proc ^CCmdButton GetButton(int p_iID)
		if(m_axButtons.NumEntries()>p_iID)then
			return ^m_axButtons[p_iID];
		else
			return ^(m_axButtons.NewEntryRef());
		endif;
	endproc;
	
	proc bool HaveTribeBuildMenu(string p_sClass)
		if(p_sClass.Find("aje_") != -1 || p_sClass == "hu_worker" || p_sClass == "ninigi_worker" || p_sClass == "seas_worker" || p_sClass == "tesla_s0" || p_sClass == "Barry_s0" || p_sClass == "Harry_s0" || p_sClass == "Larry_s0") then
			return true;
		else
			return false;
		endif;
	endproc;
	
	proc string GetMenuFromTribe(string p_sTribe)
		var string sMenu = "BLD";
		if(p_sTribe == "Hu")then
			sMenu += "H";
		elseif(p_sTribe == "Aje")then
			sMenu += "A";
		elseif(p_sTribe == "Ninigi")then
			sMenu += "N";
		elseif(p_sTribe == "SEAS")then
			sMenu += "S";
		else
			sMenu += "X";
		endif;
		return sMenu;
	endproc;
	
	export proc void UpdateMenu(bool p_bSelChg)
		var CObjList xSel=m_pxParent^.m_xCurSelection;
		var CObjList xSelEx=m_pxParent^.m_xOldSelection;
		if((xSel.NumEntries()==0)&&(xSelEx.NumEntries()==0))then
			m_axButtons=0;
			return;
		endif;

		var CObjList xTemp;
		var bool bIsCurrentlyBuild=true; //m_pxParent^.IsBuildingBuild();
		m_pxParent^.PreprocessObjects(xSelEx, xTemp, bIsCurrentlyBuild);
		var CFourCC xSelected="NONE";
		if(!p_bSelChg)then
			var int i, iC=m_axButtons.NumEntries();
			for(i=0) cond(i<iC) iter(++i)do
				if(m_axButtons[i].GetSelected())then
					xSelected=m_axButtons[i].GetCategory();
					break;
				endif;
			endfor;
		endif;
		
		var string sClass			= "";
		var bool bMultiSel			= xSel.NumEntries() > 1;
		var bool bMultiSelEx		= xSelEx.NumEntries() > 1;
		
		var bitset dwSelectedTribes = 0b;
		var bitset dwHU				= 01b;
		var bitset dwAJE			= 010b;
		var bitset dwNINIGI			= 0100b;
		var bitset dwSEAS			= 01000b;
		var bitset dwWORLD			= 010000b;
		var bitset dwSPECIAL		= 0100000b;
		
		//if(m_dwFlags==0b)then //for some reason its not 0 sometimes now and cause bldg menu hiding after any update
		if(true)then
			//TODO: xSel does not count units of the same type, but different tribes so it wont work if you select different tribe taslows
			var int i, iC=xSel.NumEntries();
			for(i=0) cond(i<iC) iter(++i) do
				if(!xSel[i].IsValid())then xSel.DeleteEntry(i--); --iC; continue; endif;
				
				var ^CObj pxO=xSel[i].GetObj();
				var ^CAttribs pxA=pxO^.GetAttribs();
				var CFourCC sObjType=pxO^.GetType();
				var string sCN=pxO^.GetClassName();
				var int iOwner = pxO^.GetOwner();
				if(pxA==null)then xSel.DeleteEntry(i--); --iC; continue; endif;
				if(!pxA^.GetValue("transporter_guid").IsEmpty())then continue; endif;
				if(!CGameInst.CanBeControlled(iOwner))then xSel.DeleteEntry(i--); --iC; continue; endif;
				if(sCN == "aje_torpedo_turtle" || sCN == "aje_gallimimus" || sCN == "aje_tracker_dino" || sCN == "hu_kennel_smilodon" || sCN == "ninigi_dilophosaurus" || sCN == "seas_stygimoloch" || sCN == "ninigi_mineship_mine" || sCN == "mrg_sprt")then continue; endif;
				
				if(sObjType == "CHTR" && HaveTribeBuildMenu(sCN))then
					var string sTribe=pxA^.GetValue("tribe");
					if((sTribe == "Special"))then
						var ^CLevelInfoClient pxLevelInfo=^(CGameWrap.GetClient().GetLevelInfo());
						if(pxLevelInfo!=null)then
							var ^CLevelInfo.CPlayerSlot pxRealOwnerSlot=pxLevelInfo^.GetOwnerPlayerSlot(pxO^.GetOwner());
							if(pxRealOwnerSlot!=null)then
								sTribe = pxRealOwnerSlot^.GetTribe();
							endif;
						endif;
					endif;
					if(sTribe == "Hu")then
						dwSelectedTribes |= dwHU;
					elseif(sTribe == "Aje")then
						dwSelectedTribes |= dwAJE;
					elseif(sTribe == "Ninigi")then
						dwSelectedTribes |= dwNINIGI;
					elseif(sTribe == "SEAS")then
						dwSelectedTribes |= dwSEAS;
					elseif(sTribe == "World")then
						dwSelectedTribes |= dwWORLD;
					elseif(sTribe == "Special")then
						dwSelectedTribes |= dwSPECIAL;
					else
						dwSelectedTribes |= dwHU;
					endif;
				endif;
				
				if(sClass.IsEmpty())then
					sClass=sCN;
				elseif(sClass!=sCN)then
					sClass="diff";
				endif;
				
				if((m_dwFlags&FLAG_CAN_MOVE)==0b)then
					if(sObjType !="BLDG" || (pxA^.GetValueInt("MovingBuilding")>0))then
						m_dwFlags |= FLAG_CAN_MOVE;
					endif;
				endif;
				if((m_dwFlags&FLAG_CAN_HARVEST)==0b)then
					var CTechTree xTechTree=pxO^.GetTechTree();
					var ^CTechTree.CNode pxTTNode=xTechTree.FindNode(m_pxParent^.GetObjPath(pxO));
					if(pxTTNode!=null)then
						if(pxTTNode^.GetSubValueI("can_harvest",0)!=0 && (sObjType == "ANML" || sObjType == "CHTR" || sObjType == "VHCL"))then
							m_dwFlags |= FLAG_CAN_HARVEST;
						endif;
					endif;
				endif;
				if((m_dwFlags&FLAG_CAN_EAT)==0b)then
//					if(pxO^.GetType()=="ANML" && sClass!="aje_kennel_deino" && sClass!="aje_tracker_dino" && sClass!="aje_velociraptor" && sClass!="hu_kennel_smilodon" && sClass!="ninigi_dilophosaurus" && sClass!="seas_stygimoloch" && sClass!="aje_pteranodon")then
					if(pxA^.GetValueInt("Herbivore")==1||pxA^.GetValueInt("Carnivore")==1)then
						m_dwFlags |= FLAG_CAN_EAT;
					endif;
				endif;
				if((m_dwFlags&FLAG_CAN_FISH)==0b)then
					if(sClass=="aje_floating_harbour"||sClass=="hu_fishing_boat"||sClass=="ninigi_fishing_boat"||sClass=="seas_carrier")then
						m_dwFlags |= FLAG_CAN_FISH;
					endif;
				endif;
				if((m_dwFlags&FLAG_HOLD_UNITS)==0b)then
					var array string asToks;
					var int iMaxPassengers=0;
					iMaxPassengers=pxA^.GetValueInt("max_passengers");
					pxA^.GetValue("passenger_guids").Split(asToks, "\n", true);
					if((asToks.NumEntries()>0 && sCN.Find("harbour")<0)||(iMaxPassengers > 0))then
						m_dwFlags |= FLAG_HOLD_UNITS;
					endif;
					if(sObjType =="BLDG")then
						m_dwFlags |= FLAG_DISMOUNT_NO_SEC;
					endif;
				endif;
				if((m_dwFlags&FLAG_MOUNTABLE)==0b)then
					var array string asToks;
					var int iMaxPassengers=0;
					iMaxPassengers=pxA^.GetValueInt("max_passengers");
					pxA^.GetValue("passenger_guids").Split(asToks, "\n", true);
					if((iMaxPassengers-asToks.NumEntries())>0)then
						m_dwFlags |= FLAG_MOUNTABLE;
					endif;
				endif;
				var bool bFight=pxA^.GetValueBool("can_attack");
				var bool bAttckBldg=pxA^.GetValueBool("AttackBuilding");
				if((m_dwFlags&FLAG_CAN_FIGHT)==0b)then
					if(pxA^.GetValueInt("damage")>0 && (sObjType != "BLDG" || bAttckBldg) && !bIsCurrentlyBuild && bFight)then
						if(bAttckBldg && (sCN.Find("bunker")>=0 || sCN.Find("fortress")>=0))then
							if((m_dwFlags&FLAG_HOLD_UNITS)!=0b)then
								m_dwFlags |= FLAG_CAN_FIGHT;
								m_dwFlags |= FLAG_CAN_HUNT;
							endif;
						else
							m_dwFlags |= FLAG_CAN_FIGHT;
							m_dwFlags |= FLAG_CAN_HUNT;
						endif;
					endif;
				endif;
				if((m_dwFlags&FLAG_SHOW_STANCES)==0b)then
					if (bFight && (sObjType != "BLDG" || bAttckBldg || sCN =="seas_carrier") && (sCN != "aje_resource_collector" || pxA^.GetValueInt("damage")>0) && sCN !="aje_shaman" && sCN !="hu_druid" && sCN !="ninigi_monk" && sCN !="seas_medic")then
						m_dwFlags |= FLAG_SHOW_STANCES;
					endif;
				endif;
				if((m_dwFlags&FLAG_SHOW_LEVEL_UP)==0b)then
					//by Henry: fix for seas carrier to have levelup button
					if((sObjType != "BLDG" || sCN == "aje_floating_harbour" || sCN =="seas_carrier") && sCN !="ninigi_water_turret")then
						m_dwFlags |= FLAG_SHOW_LEVEL_UP;
					endif;
				endif;
				if((m_dwFlags&FLAG_SHOW_LEVEL_UP)!=0b && (m_dwFlags&FLAG_CAN_LEVEL_UP)==0b)then
					if(CanLevelUp(pxO))then
						m_dwFlags |= FLAG_CAN_LEVEL_UP;
					endif;
				endif;
				if((m_dwFlags&FLAG_GATE)==0b)then
					var CTechTree xTT=pxO^.GetTechTree();
					var ^CTechTree.CNode pxTTNode=xTT.FindNode(m_pxParent^.GetObjPath(pxO));
					if(pxTTNode!=null && pxTTNode^.GetSubValueI("gate",0)==1)then
						m_dwFlags |= FLAG_GATE;
					endif;
				endif;
				if((m_dwFlags&FLAG_SHOW_RALLY)==0b)then
					if(pxA^.GetValueInt("IsRallySite")>0)then
						m_dwFlags |= FLAG_SHOW_RALLY;
					endif;
				endif;
				if((m_dwFlags&FLAG_SHOW_KILLBTN)==0b)then
					if(sObjType == "BLDG" || !CGameInst.ms_bDisableDelete)then
						m_dwFlags |= FLAG_SHOW_KILLBTN;
					endif;
				endif;
			endfor;
			var bool bCanProduce, bCanBuild, bHasSpecialAct, bBuildTraps;
			m_pxParent^.AvailableMenuButtons(xSel, bCanProduce, bCanBuild, bHasSpecialAct, bBuildTraps);
			if(bCanProduce)then m_dwFlags |= FLAG_CAN_PRODUCE; endif;
			if(bCanBuild && !bIsCurrentlyBuild)then m_dwFlags |= FLAG_CAN_BUILD; endif;
			if(bBuildTraps && !bIsCurrentlyBuild)then m_dwFlags |= FLAG_CAN_TRAPS; endif;
			if(bHasSpecialAct && !bIsCurrentlyBuild)then m_dwFlags |= FLAG_HAS_SPECIAL_ACT; endif;
//			m_axButtons=0;
//			m_axButtons.SetArraySize(0);
			while(m_axButtons.NumEntries()>0)do
				m_axButtons.DeleteEntry(0);
			endwhile;
		endif;
		
		/*
		// hide rarely used buttons on multiselection
		if(bMultiSel)then
			var bitset dwFlag=m_dwFlags;
			var int iCnt=0;
			for(iCnt=0) cond(dwFlag!=0b) iter(++iCnt) do
				dwFlag &= (dwFlag.ToInt()-1).ToBitset();
			endfor;
			//L KLog.LogInfo("DaHo", "iCnt="+iCnt.ToString());
			if(sClass=="diff" && iCnt >= 11)then
				// m_dwFlags |= FLAG_HIDE_RALLY|FLAG_HIDE_WALK|FLAG_HIDE_REPAIR;
				while(iCnt >= 12)do
					if((m_dwFlags & FLAG_SHOW_RALLY)==FLAG_SHOW_RALLY)then
						m_dwFlags &= ~FLAG_SHOW_RALLY;
						--iCnt;
						//continue;
					elseif((m_dwFlags&FLAG_CAN_TRAPS)==FLAG_CAN_TRAPS)then
						m_dwFlags &= ~FLAG_CAN_TRAPS;
						--iCnt;
						//continue;
					elseif((m_dwFlags&FLAG_CAN_BUILD)==FLAG_CAN_BUILD)then
						m_dwFlags &= ~FLAG_CAN_BUILD;
						--iCnt;
						//continue;
					elseif((m_dwFlags & FLAG_SHOW_STANCES)==FLAG_SHOW_STANCES)then
						m_dwFlags &= ~FLAG_SHOW_STANCES;
						--iCnt;
						//continue;
					else
						m_dwFlags |= FLAG_HIDE_WALK | FLAG_HIDE_REPAIR;
						iCnt -= 2;
						//continue;
					endif;
				endwhile;
			endif;
		endif;
		*/
		
		//	Wenn wir mehrere Einheiten (nicht nur verschiedene Einheitstypen wie bMultiSel nur unterscheidet) haben, dann werden
		//	die Slots nicht mehr angezeigt, wohl aber der Dismount all button
		if(bMultiSelEx)then
			m_dwFlags |= FLAG_HIDE_TRANSPORT;
		endif;
		var int iYPos=CClientWrap.GetDesktop()^.GetHeight()-59*CGameInst.ms_iUIScaleFactor;
		if(xSel.NumEntries()==0)then
			m_axButtons=0;
			m_iType=MENU_NONE;
			var ^CCmdButton pxBtn=^(m_axButtons.NewEntryRef());
			pxBtn^.Initialize("NONE", CCmdButton.TYPE_END_PIECE, m_pxParent, "", "");
			pxBtn^.SetPos(m_iPOS_X, iYPos);
			return;
		endif;
		var string sTribe="Invalid";
		var ^CPlayer pxPlayer=^(CGameWrap.GetClient().GetPlayer());
		if(pxPlayer!=null)then
			sTribe=pxPlayer^.GetPlayerSlot()^.GetTribe();
		endif;
		m_iType=MENU_UNIT;
		var ^CCmdButton pxBtn;
		var int iXPos=m_iPOS_X;
		var int iNumMenuBtns=0;
		// >> Menu Buttons <<
		pxBtn=GetButton(iNumMenuBtns++);
		pxBtn^.Initialize("NONE", CCmdButton.TYPE_LEFT_SPACER, m_pxParent, "", "");
		pxBtn^.SetPos(iXPos, iYPos);
		iXPos += 7*CGameInst.ms_iUIScaleFactor;
		if(((m_dwFlags&FLAG_CAN_PRODUCE)!=0b)/*&&((m_dwFlags&FLAG_CAN_BUILD)==0b)&&((m_dwFlags&FLAG_CAN_TRAPS)==0b)*/)then
			pxBtn=GetButton(iNumMenuBtns++);
			pxBtn^.Initialize("PROD", CCmdButton.TYPE_MENU, m_pxParent, "produce", "");
			pxBtn^.SetPos(iXPos, iYPos);
			iXPos += m_iMENUBTN_WIDTH;
			var string sTTTitle;
			var string sTTText=CClientWrap.GetUIMgr().GetToopTipText("cb_produce",sTTTitle);
			pxBtn^.SetToolTipText(sTTTitle+" \n"+sTTText);
		endif;
		if((m_dwFlags&FLAG_CAN_BUILD)!=0b)then
		
			var string sIcon = "build";
			var bool bOneMenu = false;
			var string sTTTitle;
			var string sTTText=CClientWrap.GetUIMgr().GetToopTipText("cb_build",sTTTitle);
			
			if(dwSelectedTribes == dwHU || dwSelectedTribes == dwAJE || dwSelectedTribes == dwNINIGI || dwSelectedTribes == dwSEAS || dwSelectedTribes == dwWORLD)then
				bOneMenu = true;
			endif;

			if((dwSelectedTribes&dwHU)!=0b)then
				var string sAdd = "";
				if(!bOneMenu)then
					sAdd = "_hu";
				endif;
				pxBtn=GetButton(iNumMenuBtns++);
				pxBtn^.Initialize("BLDH", CCmdButton.TYPE_MENU, m_pxParent, sIcon+sAdd, "");
				pxBtn^.SetPos(iXPos, iYPos);
				iXPos += m_iMENUBTN_WIDTH;
				pxBtn^.SetToolTipText(sTTTitle+" \n"+sTTText);
			endif;
			if((dwSelectedTribes&dwAJE)!=0b)then
				var string sAdd = "";
				if(!bOneMenu)then
					sAdd = "_aje";
				endif;
				pxBtn=GetButton(iNumMenuBtns++);
				pxBtn^.Initialize("BLDA", CCmdButton.TYPE_MENU, m_pxParent, sIcon+sAdd, "");
				pxBtn^.SetPos(iXPos, iYPos);
				iXPos += m_iMENUBTN_WIDTH;
				pxBtn^.SetToolTipText(sTTTitle+" \n"+sTTText);
			endif;
			if((dwSelectedTribes&dwNINIGI)!=0b)then
				var string sAdd = "";
				if(!bOneMenu)then
					sAdd = "_ninigi";
				endif;
				pxBtn=GetButton(iNumMenuBtns++);
				pxBtn^.Initialize("BLDN", CCmdButton.TYPE_MENU, m_pxParent, sIcon+sAdd, "");
				pxBtn^.SetPos(iXPos, iYPos);
				iXPos += m_iMENUBTN_WIDTH;
				pxBtn^.SetToolTipText(sTTTitle+" \n"+sTTText);
			endif;
			if((dwSelectedTribes&dwSEAS)!=0b)then
				var string sAdd = "";
				if(!bOneMenu)then
					sAdd = "_seas";
				endif;
				pxBtn=GetButton(iNumMenuBtns++);
				pxBtn^.Initialize("BLDS", CCmdButton.TYPE_MENU, m_pxParent, sIcon+sAdd, "");
				pxBtn^.SetPos(iXPos, iYPos);
				iXPos += m_iMENUBTN_WIDTH;
				pxBtn^.SetToolTipText(sTTTitle+" \n"+sTTText);
			endif;
		endif;
		if((m_dwFlags&FLAG_CAN_TRAPS)!=0b)then
			pxBtn=GetButton(iNumMenuBtns++);
			pxBtn^.Initialize("TRAP", CCmdButton.TYPE_MENU, m_pxParent, "traps", "");
			pxBtn^.SetPos(iXPos, iYPos);
			iXPos += m_iMENUBTN_WIDTH;
			var string sTTTitle;
			var string sTTText=CClientWrap.GetUIMgr().GetToopTipText("cb_traps",sTTTitle);
			pxBtn^.SetToolTipText(sTTTitle+" \n"+sTTText);
		endif;
		if((m_dwFlags&FLAG_SHOW_STANCES)!=0b)then
			pxBtn=GetButton(iNumMenuBtns++);
			pxBtn^.Initialize("STNC", CCmdButton.TYPE_MENU, m_pxParent, "stance", "");
			pxBtn^.SetPos(iXPos, iYPos);
			iXPos += m_iMENUBTN_WIDTH;
			var string sTTTitle;
			var string sTTText=CClientWrap.GetUIMgr().GetToopTipText("cb_set_stance",sTTTitle);
			pxBtn^.SetToolTipText(sTTTitle+" \n"+sTTText);
		endif;
		if((m_dwFlags&FLAG_HAS_SPECIAL_ACT)!=0b)then
			pxBtn=GetButton(iNumMenuBtns++);
			pxBtn^.Initialize("SPEC", CCmdButton.TYPE_MENU, m_pxParent, "special", "");
			pxBtn^.SetPos(iXPos, iYPos);
			iXPos += m_iMENUBTN_WIDTH;
			var string sTTTitle;
			var string sTTText=CClientWrap.GetUIMgr().GetToopTipText("cb_specials",sTTTitle);
			pxBtn^.SetToolTipText(sTTTitle+" \n"+sTTText);
		endif;
		if(((m_dwFlags&FLAG_HOLD_UNITS) != 0b) && ((m_dwFlags&FLAG_HIDE_TRANSPORT)==0b))then
			pxBtn=GetButton(iNumMenuBtns++);
			pxBtn^.Initialize("SLOT", CCmdButton.TYPE_MENU, m_pxParent, "slots", "");
			pxBtn^.SetPos(iXPos, iYPos);
			iXPos += m_iMENUBTN_WIDTH;
			var string sTTTitle;
			var string sTTText=CClientWrap.GetUIMgr().GetToopTipText("cb_unload",sTTTitle);
			pxBtn^.SetToolTipText(sTTTitle+" \n"+sTTText);
		endif;
		// Henry: no more a feature...
//		if((m_dwFlags&FLAG_SHOW_TRADE)!=0b)then
//			pxBtn=GetButton(iNumMenuBtns++);
//			pxBtn^.Initialize("TRAD", CCmdButton.TYPE_MENU, m_pxParent, "trade", "");
//			pxBtn^.SetPos(iXPos, iYPos);
//			iXPos += m_iMENUBTN_WIDTH;
//
//			var string sTTTitle;
//			var string sTTText=CClientWrap.GetUIMgr().GetToopTipText("cb_trade",sTTTitle);
//			pxBtn^.SetToolTipText(sTTTitle+" \n"+sTTText);
//		endif;
		if(iNumMenuBtns>=2)then
			pxBtn=GetButton(iNumMenuBtns++);
			pxBtn^.Initialize("NONE", CCmdButton.TYPE_MENU, m_pxParent, "", "");
			pxBtn^.SetPos(iXPos, iYPos);
			pxBtn^.SetDisabled(true);
			iXPos += m_iMENUBTN_WIDTH;
		endif;
		// >> Action Buttons <<
		var int iAddActButtons=0;
		if((m_dwFlags&FLAG_SHOW_RALLY)!=0b && (m_dwFlags&FLAG_HIDE_RALLY)==0b)then
			pxBtn=GetButton(iNumMenuBtns+(iAddActButtons++));
			pxBtn^.Initialize("ACTN", CCmdButton.TYPE_ACTION, m_pxParent, "rallye", "/RallyPoint");
			pxBtn^.SetPos(iXPos, iYPos);
			iXPos += m_iACTBTN_WIDTH;
			var string sTTTitle;
			var string sTTText=CClientWrap.GetUIMgr().GetToopTipText("cb_set_rallypoint",sTTTitle);
			pxBtn^.SetToolTipText(sTTTitle+" \n"+sTTText);
		endif;
		if((m_dwFlags&FLAG_CAN_FIGHT)!=0b)then
			pxBtn=GetButton(iNumMenuBtns+(iAddActButtons++));
			pxBtn^.Initialize("ACTN", CCmdButton.TYPE_ACTION, m_pxParent, "attack","/Actions/"+sTribe+"/Moves/CHTR/Attack");
			pxBtn^.SetPos(iXPos, iYPos);
			iXPos += m_iACTBTN_WIDTH;
			var string sTTTitle;
			var string sTTText=CClientWrap.GetUIMgr().GetToopTipText("cb_attack",sTTTitle);
			pxBtn^.SetToolTipText(sTTTitle+" \n"+sTTText);
		endif;
		if((m_dwFlags&FLAG_CAN_FIGHT)!=0b && (m_dwFlags&FLAG_CAN_MOVE)!=0b)then
			pxBtn=GetButton(iNumMenuBtns+(iAddActButtons++));
			pxBtn^.Initialize("ACTN",CCmdButton.TYPE_ACTION,m_pxParent,"agrwalk","/Actions/"+sTribe+"/Moves/CHTR/AggressiveTarget");
			pxBtn^.SetPos(iXPos, iYPos);
			iXPos += m_iACTBTN_WIDTH;
			var string sTTTitle;
			var string sTTText=CClientWrap.GetUIMgr().GetToopTipText("cb_agressive_walk",sTTTitle);
			pxBtn^.SetToolTipText(sTTTitle+" \n"+sTTText);
		endif;
		if((m_dwFlags&FLAG_CAN_MOVE)!=0b && (m_dwFlags&FLAG_HIDE_WALK)==0b)then
			pxBtn=GetButton(iNumMenuBtns+(iAddActButtons++));
			pxBtn^.Initialize("ACTN", CCmdButton.TYPE_ACTION, m_pxParent, "walkto","/Actions/"+sTribe+"/Moves/CHTR/Walk");
			pxBtn^.SetPos(iXPos, iYPos);
			iXPos += m_iACTBTN_WIDTH;
			var string sTTTitle;
			var string sTTText=CClientWrap.GetUIMgr().GetToopTipText("cb_walk",sTTTitle);
			pxBtn^.SetToolTipText(sTTTitle+" \n"+sTTText);
		endif;
		if((m_dwFlags&FLAG_HOLD_UNITS)!=0b)then
			pxBtn=GetButton(iNumMenuBtns+(iAddActButtons++));
			var string sCmd="/DismountAll";
			if((m_dwFlags&FLAG_DISMOUNT_NO_SEC)!=0b)then
				sCmd += " /NoSecInp";
			endif;
			pxBtn^.Initialize("ACTN", CCmdButton.TYPE_ACTION, m_pxParent, "disemb", sCmd);
			pxBtn^.SetPos(iXPos, iYPos);
			iXPos += m_iACTBTN_WIDTH;
			var string sTTTitle;
			var string sTTText=CClientWrap.GetUIMgr().GetToopTipText("cb_dismount_all",sTTTitle);
			pxBtn^.SetToolTipText(sTTTitle+" \n"+sTTText);
		endif;
		if((m_dwFlags&FLAG_CAN_BUILD)!=0b && (m_dwFlags&FLAG_HIDE_REPAIR)==0b)then
			pxBtn=GetButton(iNumMenuBtns+(iAddActButtons++));
			pxBtn^.Initialize("ACTN", CCmdButton.TYPE_ACTION, m_pxParent, "repair", "/Repair");
			pxBtn^.SetPos(iXPos, iYPos);
			iXPos += m_iACTBTN_WIDTH;
			var string sTTTitle;
			var string sTTText=CClientWrap.GetUIMgr().GetToopTipText("cb_repair",sTTTitle);
			pxBtn^.SetToolTipText(sTTTitle+" \n"+sTTText);
		endif;
		if((m_dwFlags&FLAG_CAN_MOVE)!=0b||(m_dwFlags&FLAG_CAN_FIGHT)!=0b)then
			pxBtn=GetButton(iNumMenuBtns+(iAddActButtons++));
			pxBtn^.Initialize("ACTN", CCmdButton.TYPE_ACTION, m_pxParent, "stop","/Actions/"+sTribe+"/Moves/CHTR/Stop");
			pxBtn^.SetPos(iXPos, iYPos);
			iXPos += m_iACTBTN_WIDTH;
			var string sTTTitle;
			var string sTTText=CClientWrap.GetUIMgr().GetToopTipText("cb_stop",sTTTitle);
			pxBtn^.SetToolTipText(sTTTitle+" \n"+sTTText);
		endif;
		if((m_dwFlags&FLAG_GATE)!=0b)then
			pxBtn=GetButton(iNumMenuBtns+(iAddActButtons++));
			pxBtn^.Initialize("ACTN", CCmdButton.TYPE_ACTION, m_pxParent, "gtopen", "/Actions/"+sTribe+"/Moves/BLDG/Open");
			pxBtn^.SetPos(iXPos, iYPos);
			iXPos += m_iACTBTN_WIDTH;
			var string sTTTitle;
			var string sTTText=CClientWrap.GetUIMgr().GetToopTipText("cb_gate_open",sTTTitle);
			pxBtn^.SetToolTipText(sTTTitle+" \n"+sTTText);
			pxBtn=GetButton(iNumMenuBtns+(iAddActButtons++));
			pxBtn^.Initialize("ACTN", CCmdButton.TYPE_ACTION, m_pxParent, "gtclose", "/Actions/"+sTribe+"/Moves/BLDG/Close");
			pxBtn^.SetPos(iXPos, iYPos);
			iXPos += m_iACTBTN_WIDTH;
			sTTTitle.Empty();
			sTTText=CClientWrap.GetUIMgr().GetToopTipText("cb_gate_close",sTTTitle);
			pxBtn^.SetToolTipText(sTTTitle+" \n"+sTTText);
			pxBtn=GetButton(iNumMenuBtns+(iAddActButtons++));
			pxBtn^.Initialize("ACTN", CCmdButton.TYPE_ACTION, m_pxParent, "gtauto", "/Actions/"+sTribe+"/Moves/BLDG/Auto");
			pxBtn^.SetPos(iXPos, iYPos);
			iXPos += m_iACTBTN_WIDTH;
			sTTTitle.Empty();
			sTTText=CClientWrap.GetUIMgr().GetToopTipText("cb_gate_auto",sTTTitle);
			pxBtn^.SetToolTipText(sTTTitle+" \n"+sTTText);
		endif;
		if((m_dwFlags&FLAG_SHOW_LEVEL_UP)!=0b)then
			pxBtn=GetButton(iNumMenuBtns+(iAddActButtons++));
			pxBtn^.Initialize("ACTN", CCmdButton.TYPE_ACTION, m_pxParent, "levelup", "/LevelUp");
			pxBtn^.SetPos(iXPos, iYPos);
			iXPos += m_iACTBTN_WIDTH;
			pxBtn^.SetDisabled((m_dwFlags&FLAG_CAN_LEVEL_UP)==0b);
			var string sTTTitle;
			var string sTTText=CClientWrap.GetUIMgr().GetToopTipText("cb_level_up",sTTTitle);
			if((m_dwFlags&FLAG_CAN_LEVEL_UP)==0b)then
				sTTText+=" \n"+CLocalizer.Get().Translate("_ObjCommandBar_NoLevelUp");
			endif;
			var string sToolTipAdd;
			var ^CObj pxObj=m_xSelObj.GetObj();
			if(pxObj!=null)then
				var int iCurLevel=-1;
				var ^CAttribs pxAttribs=pxObj^.GetAttribs();
				if(pxAttribs!=null)then
					iCurLevel=pxAttribs^.GetValueInt("level");
				endif;
				if(iCurLevel>=0 && iCurLevel<4)then
					var ^CAttribs pxPlayerAttr=CGameWrap.GetClient().GetPlayer().GetAttribs();
					if(pxPlayerAttr!=null)then
						var int iScalpsAvailable=pxPlayerAttr^.GetValueInt("iron");
						var int iScalpsNeeded=pxPlayerAttr^.GetValueInt("foodcost_lvl_"+(iCurLevel+1).ToString());
						sToolTipAdd="%/food:0/stone:0/wood:0/skulls:"+iScalpsNeeded.ToString();
						if(iScalpsNeeded>iScalpsAvailable)then
							sToolTipAdd+=":NA";
						endif;
						sToolTipAdd+="%";
					endif;
				endif;
			endif;
			sTTText+=sToolTipAdd;
			pxBtn^.SetToolTipText(sTTTitle+" \n"+sTTText);
		endif;
		if((m_dwFlags&FLAG_CAN_HARVEST) != 0b)then
			pxBtn=GetButton(iNumMenuBtns+(iAddActButtons++));
			pxBtn^.Initialize("ACTN", CCmdButton.TYPE_ACTION, m_pxParent, "deforest", "/Actions/"+sTribe+"/Moves/CHTR/Deforest");
			pxBtn^.SetPos(iXPos, iYPos);
			iXPos += m_iACTBTN_WIDTH;
			var string sTTTitle;
			var string sTTText=CClientWrap.GetUIMgr().GetToopTipText("cb_deforest",sTTTitle);
			pxBtn^.SetToolTipText(sTTTitle+" \n"+sTTText);
		endif;
		if((m_dwFlags&FLAG_CAN_EAT)!=0b)then
			pxBtn=GetButton(iNumMenuBtns+(iAddActButtons++));
			pxBtn^.Initialize("ACTN", CCmdButton.TYPE_ACTION, m_pxParent, "restaurant", "/Actions/"+sTribe+"/Moves/ANML/EatSomethingFast");
			pxBtn^.SetPos(iXPos, iYPos);
			iXPos += m_iACTBTN_WIDTH;
			var string sTTTitle;
			var string sTTText=CClientWrap.GetUIMgr().GetToopTipText("cb_restaurant",sTTTitle);
			pxBtn^.SetToolTipText(sTTTitle+" \n"+sTTText);
		endif;
		
		if((m_dwFlags&FLAG_MOUNTABLE)!=0b)then
			pxBtn=GetButton(iNumMenuBtns+(iAddActButtons++));
			pxBtn^.Initialize("ACTN", CCmdButton.TYPE_ACTION, m_pxParent, "mount_unit", "/Actions/"+sTribe+"/Moves/ANML/MountThatUnit");
			pxBtn^.SetPos(iXPos, iYPos);
			iXPos += m_iACTBTN_WIDTH;
			var string sTTTitle;
			var string sTTText=CClientWrap.GetUIMgr().GetToopTipText("cb_mount_unit",sTTTitle);
			pxBtn^.SetToolTipText(sTTTitle+" \n"+sTTText);
		endif;
		
		if((m_dwFlags&FLAG_CAN_HUNT)!=0b)then
			pxBtn=GetButton(iNumMenuBtns+(iAddActButtons++));
			pxBtn^.Initialize("ACTN", CCmdButton.TYPE_ACTION, m_pxParent, "hunt", "/Actions/"+sTribe+"/Moves/CHTR/HuntAnimals");
			pxBtn^.SetPos(iXPos, iYPos);
			iXPos += m_iACTBTN_WIDTH;
			var string sTTTitle;
			var string sTTText=CClientWrap.GetUIMgr().GetToopTipText("cb_hunt",sTTTitle);
			pxBtn^.SetToolTipText(sTTTitle+" \n"+sTTText);
		endif;
		if((m_dwFlags&FLAG_CAN_FISH)!=0b)then
			pxBtn=GetButton(iNumMenuBtns+(iAddActButtons++));
			pxBtn^.Initialize("ACTN", CCmdButton.TYPE_ACTION, m_pxParent, "fish", "/Actions/"+sTribe+"/Moves/SHIP/FishSomewhere");
			pxBtn^.SetPos(iXPos, iYPos);
			iXPos += m_iACTBTN_WIDTH;
			var string sTTTitle;
			var string sTTText=CClientWrap.GetUIMgr().GetToopTipText("cb_fish",sTTTitle);
			pxBtn^.SetToolTipText(sTTTitle+" \n"+sTTText);
		endif;
		if(true)then
			pxBtn=GetButton(iNumMenuBtns+(iAddActButtons++));
			pxBtn^.Initialize("ACTN", CCmdButton.TYPE_ACTION, m_pxParent, "toggle_locked", "/Actions/"+sTribe+"/Moves/ANML/ToggleLocked");
			pxBtn^.SetPos(iXPos, iYPos);
			iXPos += m_iACTBTN_WIDTH;
			var string sTTTitle;
			var string sTTText=CClientWrap.GetUIMgr().GetToopTipText("cb_toggle_locked",sTTTitle);
			pxBtn^.SetToolTipText(sTTTitle+" \n"+sTTText);
		endif;
		
		if((m_dwFlags&FLAG_SHOW_KILLBTN)!=0b)then
			if(iNumMenuBtns>=3)then
				pxBtn=GetButton(iNumMenuBtns+(iAddActButtons++));
				pxBtn^.Initialize("NONE", CCmdButton.TYPE_MENU, m_pxParent, "", "");
				pxBtn^.SetPos(iXPos, iYPos);
				pxBtn^.SetDisabled(true);
				iXPos += m_iMENUBTN_WIDTH;
			endif;
			pxBtn=GetButton(iNumMenuBtns+(iAddActButtons++));
			pxBtn^.Initialize("ACTN", CCmdButton.TYPE_ACTION, m_pxParent, "kill", "/Kill");
			pxBtn^.SetPos(iXPos, iYPos);
			pxBtn^.SetDisabled(CGameInst.ms_bDisableDelete);
			iXPos += m_iACTBTN_WIDTH;
			var string sTTTitle;
			var string sTTText=CClientWrap.GetUIMgr().GetToopTipText("cb_kill",sTTTitle);
			pxBtn^.SetToolTipText(sTTTitle+" \n"+sTTText);
		endif;
		if(iAddActButtons==0 && iNumMenuBtns>=2)then
			if(m_axButtons.NumEntries()>1)then
				//m_axButtons=0;
				pxBtn=^(m_axButtons[m_axButtons.NumEntries()-1]);
				//iXPos=212;
				pxBtn^.Initialize("NONE", CCmdButton.TYPE_END_PIECE, m_pxParent, "", "");
				pxBtn^.SetPos(iXPos-m_iMENUBTN_WIDTH, iYPos);
				return;
			endif;
		endif;
		pxBtn=GetButton(iNumMenuBtns+(iAddActButtons++));
		pxBtn^.Initialize("NONE", CCmdButton.TYPE_END_PIECE, m_pxParent, "", "");
		pxBtn^.SetPos(iXPos, iYPos);
		iXPos += m_iACTBTN_WIDTH;
		var int i, iC=m_axButtons.NumEntries();
		for(i=0) cond(i<iC) iter(++i)do
			var string sCommand=m_axButtons[i].GetCommand();
			if(sCommand != "gtopen" && sCommand != "gtclose" && sCommand != "gtauto")then
				m_axButtons[i].SetButtonSelected(xSelected.AsString()==m_axButtons[i].GetCategory());
			endif;
		endfor;
	endproc;

	export proc void ValidateCommands()
		var int i, iC=m_axCmdButtons.NumEntries();
		for(i=0) cond(i<iC) iter(++i) do
			m_axCmdButtons[i].Validate();
		endfor;
	endproc;

	export proc CClntHndl GetSelObj()
		return m_xSelObj;
	endproc;

//	proc	int	GetSubPassengerCount(^CObj p_pxPassenger)
//		KLog.LogInfo("DaHo", "GetSubPassengerCount()");
//		if(p_pxPassenger==null)then return(0); endif;
//
//		var	^CAttribs		pxAttribs 		= p_pxPassenger^.GetAttribs();
//		if(pxAttribs== null)then return(0); endif;
//
//		var	string			sPassengerGuids	= pxAttribs^.GetValue("passenger_guids");
//		if(sPassengerGuids.IsEmpty())then return(0); endif;
//
//		var	array string	asPassengerGuid;
//		sPassengerGuids.Split(asPassengerGuid, "\n", true);
//
//		var	int				i, iC=asPassengerGuid.NumEntries();
//		var	int				iCount	= 0;
//
//		for(i=0)cond(i<iC)iter(++i)do
//			var	CGuid	xGuid;
//
//			xGuid.FromString(asPassengerGuid[i]);
//			var	^CObj	pxObj=CGameWrap.GetObjMgr().GetObj(xGuid);
//			if(pxObj==null)then continue; endif;
//			iCount += 1;
//			iCount += GetSubPassengerCount(pxObj);
//		endfor;
//		return(iCount);
//	endproc;

	proc int AddSubPassenger(^CObj p_pxPassenger, string p_sSubCat, CFourCC p_xCurFlyout, ref int p_riPasIdx)
		if(p_pxPassenger==null)then return(0); endif;
		var ^CAttribs pxAttribs=p_pxPassenger^.GetAttribs();
		if(pxAttribs==null)then return(0); endif;
		var string sPassengerGuids=pxAttribs^.GetValue("passenger_guids");
		if(sPassengerGuids.IsEmpty())then return(0); endif;
		var array string asPassengerGuid;
		sPassengerGuids.Split(asPassengerGuid, "\n", true);
		var int i, iC=asPassengerGuid.NumEntries();
		var int iCount=0;
		if(iC==0)then return(0); endif;
		for(i=0)cond(i<iC)iter(++i)do
			var CGuid xGuid;
			xGuid.FromString(asPassengerGuid[i]);
			var ^CObj pxObj=CGameWrap.GetObjMgr().GetObj(xGuid);
			if(pxObj==null)then continue; endif;
			var ^CCmdButton pxBtn=^(m_axCmdButtons.NewEntryRef());
			var string sCmd="/Unboard|"+p_sSubCat+"|"+pxObj^.GetGuid().ToString();
			pxBtn^.Initialize(p_xCurFlyout.AsString(), CCmdButton.TYPE_MENUCMD, m_pxParent, sCmd, m_pxParent^.GetObjPath(pxObj), p_riPasIdx++);
			var string sTTTitle, sTTText, sTTID=CHelpMenu.GetObjHelpitemKey(pxObj);
			sTTText=CClientWrap.GetUIMgr().GetToopTipText(sTTID, sTTTitle);
			var int iSupply=CMirageClnMgr.Get().GetSupply(pxObj^.GetClassName());
			if(iSupply==1)then
				sTTText += "/spplcnt: "+iSupply.ToString()+CLocalizer.Get().Translate("_MIRAGE_Supply_1");
			elseif(iSupply>1)then
				sTTText += "/spplcnt: "+iSupply.ToString()+CLocalizer.Get().Translate("_MIRAGE_Supply_2");
			endif;
			var string sTooltip=sTTTitle;
			if(pxObj^.GetType()=="CHTR"||pxObj^.GetType()=="ANML"||pxObj^.GetType()=="VHCL")then
				var ^CAttribs pxAttr=pxObj^.GetAttribs();
				if(pxAttr!=null)then
					sTooltip += " \n"+CUIMgr.GetLocalizedNewstickerMsg("_UI_CommandBar_Level\t"+(pxAttr^.GetValueInt("level")+1).ToString());
				endif;
			endif;
			pxBtn^.SetToolTipText(sTooltip);
			pxBtn^.SetDisabled(true);
			iCount++;
		endfor;
		return(iCount);
	endproc;

	export proc void InitMenuCommands(CObjList p_xSelection, CFourCC p_xCurFlyout)
		m_axCmdButtons=0;
		m_pxParent^.GetFlyoutWindow()^.Clear();
		var array int aiMapNextID;
		var array string asMapSubCat;
		aiMapNextID=4;
		asMapSubCat=4;
		asMapSubCat[0]="ATR";
		asMapSubCat[1]="VTR";
		asMapSubCat[2]="STR";
		asMapSubCat[3]="BTR";
		var int iTrspCnt=0;
		//var int iCurTrspID=-1;
		if(p_xSelection.NumEntries()<=0)then return; endif;
		if(p_xCurFlyout=="SLOT")then
			var int iObjID, iNumObjs=p_xSelection.NumEntries();
			for(iObjID=0) cond(iObjID<iNumObjs) iter(++iObjID)do
				var ^CObj pxObj=p_xSelection[iObjID].GetObj();
				if(pxObj!=null)then
					var CFourCC xType=pxObj^.GetType();
					if(xType=="CHTR"||xType=="FGHT")then continue; endif;
					var string sSubCat=xType.AsString().GetAt(0)+"TR";
					var int iMapIdx=asMapSubCat.FindEntry(sSubCat);
					var int iID=-1;
					if(iMapIdx>=0)then
						iID=aiMapNextID[iMapIdx]++;
					else
						continue;
					endif;
					sSubCat += iID.ToString();
					var int iPasIdx=0;
					var ^CAttribs pxA=pxObj^.GetAttribs();
					if(pxA==null)then continue; endif;
					var string sPasGuids=pxA^.GetValue("passenger_guids");
					//----< DaHo - Leere Platze anzeigen >--- Die untere Zeile wieder einkommentieren
//					if(sPasGuids.IsEmpty())then continue; endif;
					//----------------------------------------
					var array string asToks;
					sPasGuids.Split(asToks, "\n", true);
					if(++iTrspCnt>=CFlyout.MAX_CATEGORIES)then return; endif;
					//----< DaHo - Leere Platze anzeigen >---
					var CTechTree xTT=pxObj^.GetTechTree();
					var string sTT = pxA^.GetValue("ObjPath");
					var ^CTechTree.CNode pxN = xTT.FindNode(sTT+"/max_passengers");
					var int iCM = 0;
					if(pxN != null)then
						iCM=pxN^.GetValueI();
					endif;
					//by Henry: removed because bunker upgrade has been boosted
/*
					if(pxObj^.GetClassName().Find("bunker") != -1)then
						iCM=4;
					endif;
*/
					//----------------------------------------
					var int i, iC=asToks.NumEntries();
					var int iAdditional=0; //Einheiten in Einheiten in Einheiten
					//----< DaHo - Leere Platze anzeigen >---
					//----------------------------------------
					for(i=0) cond(i<iC) iter(++i) do
						var CGuid xG; xG.FromString(asToks[i]);
						var ^CObj pxPas=CGameWrap.GetObjMgr().GetObj(xG);
						if(pxPas==null)then continue; endif;
						var ^CCmdButton pxBtn=^(m_axCmdButtons.NewEntryRef());
						var string sCmd="/Unboard|"+sSubCat+"|"+pxPas^.GetGuid().ToString();
						pxBtn^.Initialize(p_xCurFlyout.AsString(), CCmdButton.TYPE_MENUCMD, m_pxParent, sCmd, m_pxParent^.GetObjPath(pxPas), iPasIdx++);
						var string sTTTitle, sTTText, sTTID=CHelpMenu.GetObjHelpitemKey(pxPas);
						sTTText=CClientWrap.GetUIMgr().GetToopTipText(sTTID, sTTTitle);
						var int iSupply=CMirageClnMgr.Get().GetSupply(pxPas^.GetClassName());
						if(iSupply==1)then
							sTTText += "/spplcnt: "+iSupply.ToString()+CLocalizer.Get().Translate("_MIRAGE_Supply_1");
						elseif(iSupply>1)then
							sTTText += "/spplcnt: "+iSupply.ToString()+CLocalizer.Get().Translate("_MIRAGE_Supply_2");
						endif;
						var string sTooltip=sTTTitle;
						if(pxPas^.GetType()=="CHTR"||pxPas^.GetType()=="ANML"||pxPas^.GetType()=="VHCL")then
							var ^CAttribs pxAttr=pxPas^.GetAttribs();
							if(pxAttr!=null)then
								sTooltip += "  \n"+CUIMgr.GetLocalizedNewstickerMsg("_UI_CommandBar_Level\t"+(pxAttr^.GetValueInt("level")+1).ToString());
							endif;
						endif;
						pxBtn^.SetToolTipText(sTooltip);
						iAdditional += AddSubPassenger(pxPas, sSubCat, p_xCurFlyout, iPasIdx);
					endfor;
//L					KLog.LogInfo("DaHo", "Additonal="+iAdditional.ToString());
					if(iCM > 0)then
						iCM=iCM - (iC+iAdditional);
					endif;
					//----< DaHo - Leere Platze anzeigen >---
					for(i=0)cond(i<iCM)iter(++i) do
						var ^CCmdButton pxBtn=^(m_axCmdButtons.NewEntryRef());
						var string sCmd="/Unboard|"+sSubCat+"|none";
						pxBtn^.Initialize(p_xCurFlyout.AsString(), CCmdButton.TYPE_MENUCMD, m_pxParent, sCmd, "/", iPasIdx++);
						pxBtn^.SetDisabled(true);
					endfor;
					//----------------------------------------
				endif;
			endfor;
		elseif(p_xCurFlyout=="BLDH"||p_xCurFlyout=="BLDA"||p_xCurFlyout=="BLDN"||p_xCurFlyout=="BLDS")then
			m_pxParent^.GetFlyoutWindow()^.SetCategory(0, "UNIT");
			m_pxParent^.GetFlyoutWindow()^.SetCategory(1, "ECON");
			m_pxParent^.GetFlyoutWindow()^.SetCategory(2, "COMB");
			m_pxParent^.GetFlyoutWindow()^.SetCategory(3, "DEFE");
		elseif(p_xCurFlyout=="TRAP")then
			m_pxParent^.GetFlyoutWindow()^.SetCategory(0, "DEFE");
		elseif(p_xCurFlyout=="PROD")then
			if(m_sCurName=="aje_cook_house")then
				m_pxParent^.GetFlyoutWindow()^.SetCategory(0, "UPGR");
				m_pxParent^.GetFlyoutWindow()^.SetCategory(1, "UNIT");
				m_pxParent^.GetFlyoutWindow()^.SetCategory(2, "ENTY");
			elseif(m_sCurName=="hu_small_animal_farm")then
				m_pxParent^.GetFlyoutWindow()^.SetCategory(0, "UPGR");
				m_pxParent^.GetFlyoutWindow()^.SetCategory(1, "UNIT");
				m_pxParent^.GetFlyoutWindow()^.SetCategory(2, "ENTY");
//			elseif(m_sCurName=="seas_fortress")then
//				m_pxParent^.GetFlyoutWindow()^.SetCategory(0, "UNIT");
//				m_pxParent^.GetFlyoutWindow()^.SetCategory(1, "CAVA");
//				m_pxParent^.GetFlyoutWindow()^.SetCategory(2, "ENTY");
			elseif(m_sCurName=="seas_garage")then
				m_pxParent^.GetFlyoutWindow()^.SetCategory(0, "UPGR");
				m_pxParent^.GetFlyoutWindow()^.SetCategory(1, "UNIT");
				m_pxParent^.GetFlyoutWindow()^.SetCategory(2, "ENTY");
			elseif(m_sCurName=="seas_laboratory")then
				m_pxParent^.GetFlyoutWindow()^.SetCategory(0, "EXTE");
				m_pxParent^.GetFlyoutWindow()^.SetCategory(1, "RESE");
			elseif(m_sCurName.Left(4)=="aje_")then
				if(m_sCurName=="aje_weapons_builder")then
					m_pxParent^.GetFlyoutWindow()^.SetCategory(0, "UPGR");
					m_pxParent^.GetFlyoutWindow()^.SetCategory(1, "EXTE");
					m_pxParent^.GetFlyoutWindow()^.SetCategory(2, "UNIT");
				elseif(m_sCurType=="BLDG")then
					m_pxParent^.GetFlyoutWindow()^.SetCategory(0, "UMGR");
					m_pxParent^.GetFlyoutWindow()^.SetCategory(1, "UPGR");
					m_pxParent^.GetFlyoutWindow()^.SetCategory(2, "UNIT");
				else
					m_pxParent^.GetFlyoutWindow()^.SetCategory(0, "UMGR");
					m_pxParent^.GetFlyoutWindow()^.SetCategory(1, "CONV");
					m_pxParent^.GetFlyoutWindow()^.SetCategory(2, "UPGR");
					m_pxParent^.GetFlyoutWindow()^.SetCategory(3, "UNIT");
					m_pxParent^.GetFlyoutWindow()^.SetCategory(4, "UFOC");
				endif;
			else
				m_pxParent^.GetFlyoutWindow()^.SetCategory(0, "UPGR");
				m_pxParent^.GetFlyoutWindow()^.SetCategory(1, "UNIT");
			endif;
		elseif(p_xCurFlyout=="SPEC")then
			if(m_sCurType=="BLDG")then
				m_pxParent^.GetFlyoutWindow()^.SetCategory(0, "UPGR");
				m_pxParent^.GetFlyoutWindow()^.SetCategory(1, "EXTE");
			else
				m_pxParent^.GetFlyoutWindow()^.SetCategory(0, "HERO");
				m_pxParent^.GetFlyoutWindow()^.SetCategory(1, "HFOC");
				m_pxParent^.GetFlyoutWindow()^.SetCategory(2, "UNIT");
				m_pxParent^.GetFlyoutWindow()^.SetCategory(3, "UFOC");
			endif;
		endif;
		var array string asCats;
		asCats=1;
		asCats[0]=p_xCurFlyout.AsString();
		var CObjList xSel=m_pxParent^.m_xCurSelection;
		/*if(p_xCurFlyout=="PROD" && xSel.NumEntries()>0)then
			var CClntHndl xObj=xSel[0];
		//	xSel.Clear();
			//xSel.Include(xObj);
			m_xSelObj=xSel[0];
		else
			m_xSelObj.Invalidate();
		endif;
		*/
		/*m_xSelObj.Invalidate();
		if(xSel.NumEntries()>0)then
			m_xSelObj=xSel[0];
		endif;*/
		var ^CObj pxO;
		if(xSel.NumEntries()>0)then pxO=xSel[0].GetObj(); endif;
		if(pxO==null)then return; endif;
		var CTechTree xTT=pxO^.GetTechTree();
		var string sLocalUpgrade;
		var ^CAttribs pxA=pxO^.GetAttribs();
		if(pxA!=null)then
			sLocalUpgrade=pxA^.GetValue("LocalUpgrade");
		endif;
		m_pxParent^.GetFlyoutWindow()^.SetLocalUpgrade(sLocalUpgrade);
		var array string asNodes;
		var array int aiLocIdx;
		var array bool abDeny;
		if(m_pxParent^.GetAvailableActions(xSel, ^asNodes, ^aiLocIdx, asCats, ^abDeny))then
			var int i,iC=asNodes.NumEntries();
			for(i=0)cond(i<iC)iter(++i)do
//				var ^CTechTree.CNode pxAction=xTT.FindNode(asNodes[i]);
				var CTechTree xNewTT=xTT;
				var CClntHndl xUseless;
				var ^CTechTree.CNode pxAction=m_pxParent^.FindNodeAtFocus(asNodes[i], xNewTT, xUseless);
				if(pxAction==null)then continue; endif;
				var ^CTechTree.CNode pxLocs=pxAction^.GetSub("locations");
				if(pxLocs==null)then
					continue;
				endif;
				var ^CTechTree.CNode pxLocation=pxLocs^.GetSub(aiLocIdx[i]);
				if(pxLocation!=null)then
					var ^CTechTree.CNode pxUI=pxLocation^.GetSub("uiposition");
					if(pxUI==null)then continue; endif;
					var string sSubCat=pxUI^.GetSubValue("subcat", "");
					var ^CCmdButton pxBtn=^(m_axCmdButtons.NewEntryRef());
					pxBtn^.Initialize(p_xCurFlyout.AsString(), CCmdButton.TYPE_MENUCMD, m_pxParent, sSubCat, asNodes[i], aiLocIdx[i], xNewTT);
					pxBtn^.SetDeny(abDeny[i]);
				endif;
			endfor;
		endif;
		m_pxParent^.GetFlyoutWindow()^.Sort();
	endproc;
	
endclass;

class CCommandBar inherit CWindow
	
	export static var bool ms_bNewCommandSystem;
	export static var bool ms_bSUB; // Henry: Skip Unfinished Buildings
	const 		int					X_POS=209;
	const 		bitset			UPDATE_ACTIONMENU_SEL = 01b;
	const 		bitset			UPDATE_ACTIONMENU_NONSEL = 010b;
	const 		bitset			UPDATE_LEVELUPBUTTONS = 0100b;
	const 		bitset			UPDATE_FLYOUT = 01000b;
	const 		bitset			UPDATE_ACTIONMENU_BUILDINGBUILD = 010000b;

	var 		bitset			m_dwUpdateFlags;

	var			bool			m_bCmdBarAccelActive;
	var			int				m_iRow;
	var			int				m_iCol;

	var			^CInGameScreen	m_pxIScreen;
	var			^CDesktop		m_pxDesktop;
	var			^CObjMgr		m_pxObjMgr;
	export var	string			m_sTribe;
	export var	string			m_sSpecialFocus;
	export var	CObjList		m_xCurSelection;
	export var	CObjList		m_xOldSelection;
	export var	CTechTree		m_xCurTechTree;
	var 		CFourCC			m_xCurMode;
	var 		CFourCC			m_xCurFlyout;

	var 		^CActionMenu	m_pxActionMenu;
	var 		^CFlyout		m_pxFlyout;
	var 		^CPlayer		m_pxPlayer;

	var array 	string			m_asResName;
	var array 	int				m_aiResValue;
	var array string m_asValidActs;
	var int m_iExtPyraUpdate;
	var bool m_bSkipOldTraps;
	
	export constructor()
		var CConfig xConf;
		CCommandBar.ms_bNewCommandSystem=xConf.GetSetB("Client/GameplayOptions/NewCommandSystem",true);
		CCommandBar.ms_bSUB=xConf.GetSetB("Client/GameplayOptions/SkipUnfinishedBuildings",false);
		m_bSkipOldTraps=xConf.GetSetB("Client/GameplayOptions/SkipOldTraps",true);
		SetVisible(false);
		m_asValidActs=0;
		m_asValidActs.AddEntry("gtopen");
		m_asValidActs.AddEntry("gtclose");
		m_asValidActs.AddEntry("gtauto");
		m_asValidActs.AddEntry("fish");
		m_asValidActs.AddEntry("hunt");
		m_asValidActs.AddEntry("deforest");
		m_asValidActs.AddEntry("attack");
		m_asValidActs.AddEntry("agrwalk");
		m_asValidActs.AddEntry("walkto");
		m_asValidActs.AddEntry("disemb");
		m_asValidActs.AddEntry("repair");
		m_asValidActs.AddEntry("stop");
		m_asValidActs.AddEntry("levelup");
		m_asValidActs.AddEntry("restaurant");
		m_asValidActs.AddEntry("produce");
		m_asValidActs.AddEntry("build");
		m_asValidActs.AddEntry("stance");
		m_asValidActs.AddEntry("slots");
		m_asValidActs.AddEntry("special");
		m_asValidActs.AddEntry("rallye");
		m_asValidActs.AddEntry("traps");
		m_asValidActs.AddEntry("mount_unit");
		m_asValidActs.AddEntry("toggle_locked");
		m_sSpecialFocus=CMirageClnMgr.Get().GetSpecialFocus();
	endconstructor;
	
	export destructor()
		delete m_pxActionMenu;
		m_asValidActs=0;
		if(m_pxFlyout!=null)then m_pxFlyout^.Destroy(); endif;
	enddestructor;
	
	export proc bool IsAccelActive()
		return(m_bCmdBarAccelActive);
	endproc;
	
	export proc int GetAccelRow()
		return(m_iRow);
	endproc;
	
	export proc string GetCurFlyout()
		return m_xCurFlyout.AsString();
	endproc;
	
	export proc string GetCode(string p_sPath, ref bool p_rbPersonal, ref string p_rsTribe)
		var ^CTechTree.CNode pxNode=m_xCurTechTree.FindNode(p_sPath);
		if(pxNode!=null)then
			p_rbPersonal=(pxNode^.GetSubValueI("personal", 0)==1);
			var string sCode=pxNode^.GetSubValue("code", "");
			var int iPos=sCode.FindRev('_');
			if(iPos!=-1)then
				p_rsTribe=sCode.Mid(iPos+1);
			endif;
			return sCode;
		endif;
		return "";
	endproc;
	
	export proc CTechTree GetCurTechTree()
		return m_xCurTechTree;
	endproc;
	
	export proc string GetCode(CTechTree p_xTT, string p_sPath, ref bool p_rbPersonal, ref string p_rsTribe)
		var ^CTechTree.CNode pxNode=p_xTT.FindNode(p_sPath);
		if(pxNode!=null)then
			p_rbPersonal=(pxNode^.GetSubValueI("personal", 0)==1);
			var string sCode=pxNode^.GetSubValue("code", "");
			var int iPos=sCode.FindRev('_');
			if(iPos!=-1)then
				p_rsTribe=sCode.Mid(iPos+1);
			endif;
			return sCode;
		endif;
		return "";
	endproc;
	
	export proc bool ValidAction(string p_sAct)
		return m_asValidActs.FindEntry(p_sAct)!=-1;
	endproc;
	
	export proc void Init(^CDesktop p_pxDesktop, ^CInGameScreen p_pxScreen, string p_sTribe)
		delete m_pxActionMenu;

		if(m_pxFlyout != null)then
			m_pxFlyout^.Destroy();
		endif;
		m_pxIScreen	= p_pxScreen;
		m_pxDesktop	= p_pxDesktop;
		m_sTribe	= p_sTribe;
		m_xCurMode	= "NONE";

		m_xCurSelection.Clear();
		m_xOldSelection.Clear();
		m_pxActionMenu 	= new CActionMenu(this);
		m_pxFlyout 		= new CFlyout();

		m_pxFlyout^.m_pxCommandBar=this;

		m_pxIScreen^.AddChild(m_pxFlyout);

		m_pxFlyout^.SetTransparent(true);
		m_pxFlyout^.SetVisible(false);
		m_pxFlyout^.SetActiveFlyout(false);
		m_pxFlyout^.SetBackground(true);
		m_pxFlyout^.SetSuitAlpha(true);
		m_pxFlyout^.SetSize(600*CGameInst.ms_iUIScaleFactor, 138*CGameInst.ms_iUIScaleFactor);
		m_pxFlyout^.SetPos(X_POS*CGameInst.ms_iUIScaleFactor, CClientWrap.GetDesktop()^.GetHeight()-197*CGameInst.ms_iUIScaleFactor);

		m_xCurFlyout	= "NONE";

		var ^CPlayer pxPlayer=^(CGameWrap.GetClient().GetPlayer());
		if(pxPlayer!=null)then
			m_xCurTechTree=pxPlayer^.GetPlayerTechTree();
		endif;

		m_asResName=4;
		m_asResName[0]="food";
		m_asResName[1]="wood";
		m_asResName[2]="stone";
		m_asResName[3]="iron";
		m_aiResValue=4;

		InitCommandBarAccelerators();

		//L KLog.LogInfo("CaOr","CmdBar init");

		m_pxPlayer=^(CGameWrap.GetClient().GetPlayer());
	endproc;
	
	proc void InitCommandBarAccelerators()
		var CConfig xConf;
		m_bCmdBarAccelActive=xConf.GetSetB("Client/GameplayOptions/ShowAccelerators",true);
		m_iRow=-1;
		m_iCol=-1;
		var array string asKeys;
		asKeys=CShortcutMgr.Get().GetAccelKeys();
		var int i, iC=asKeys.NumEntries();
		if(iC>50)then iC=50; endif;
		var string sReference="";
		// Henry: if only SEK made the accelerators procref with a usable parameter...
		for(i=0)cond(i<iC)iter(i++)do
//			sReference="CmdBar_Accel_"+asKeys[i];
			sReference="CmdBar_Accel_"+i.ToString();
			switch(i)
				case(0) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_00); endcase;
				case(1) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_01); endcase;
				case(2) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_02); endcase;
				case(3) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_03); endcase;
				case(4) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_04); endcase;
				case(5) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_05); endcase;
				case(6) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_06); endcase;
				case(7) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_07); endcase;
				case(8) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_08); endcase;
				case(9) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_09); endcase;
				case(10) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_10); endcase;
				case(11) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_11); endcase;
				case(12) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_12); endcase;
				case(13) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_13); endcase;
				case(14) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_14); endcase;
				case(15) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_15); endcase;
				case(16) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_16); endcase;
				case(17) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_17); endcase;
				case(18) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_18); endcase;
				case(19) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_19); endcase;
				case(20) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_20); endcase;
				case(21) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_21); endcase;
				case(22) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_22); endcase;
				case(23) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_23); endcase;
				case(24) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_24); endcase;
				case(25) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_25); endcase;
				case(26) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_26); endcase;
				case(27) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_27); endcase;
				case(28) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_28); endcase;
				case(29) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_29); endcase;
				case(30) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_30); endcase;
				case(31) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_31); endcase;
				case(32) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_32); endcase;
				case(33) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_33); endcase;
				case(34) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_34); endcase;
				case(35) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_35); endcase;
				case(36) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_36); endcase;
				case(37) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_37); endcase;
				case(38) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_38); endcase;
				case(39) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_39); endcase;
				case(40) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_40); endcase;
				case(41) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_41); endcase;
				case(42) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_42); endcase;
				case(43) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_43); endcase;
				case(44) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_44); endcase;
				case(45) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_45); endcase;
				case(46) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_46); endcase;
				case(47) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_47); endcase;
				case(48) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_48); endcase;
				case(49) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_49); endcase;
				case default do endcase;
			endswitch;
			sReference="CmdBar_Accel_Shift_"+i.ToString();
			switch(i)
				case(0) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_00); endcase;
				case(1) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_01); endcase;
				case(2) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_02); endcase;
				case(3) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_03); endcase;
				case(4) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_04); endcase;
				case(5) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_05); endcase;
				case(6) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_06); endcase;
				case(7) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_07); endcase;
				case(8) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_08); endcase;
				case(9) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_09); endcase;
				case(10) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_10); endcase;
				case(11) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_11); endcase;
				case(12) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_12); endcase;
				case(13) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_13); endcase;
				case(14) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_14); endcase;
				case(15) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_15); endcase;
				case(16) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_16); endcase;
				case(17) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_17); endcase;
				case(18) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_18); endcase;
				case(19) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_19); endcase;
				case(20) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_20); endcase;
				case(21) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_21); endcase;
				case(22) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_22); endcase;
				case(23) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_23); endcase;
				case(24) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_24); endcase;
				case(25) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_25); endcase;
				case(26) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_26); endcase;
				case(27) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_27); endcase;
				case(28) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_28); endcase;
				case(29) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_29); endcase;
				case(30) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_30); endcase;
				case(31) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_31); endcase;
				case(32) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_32); endcase;
				case(33) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_33); endcase;
				case(34) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_34); endcase;
				case(35) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_35); endcase;
				case(36) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_36); endcase;
				case(37) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_37); endcase;
				case(38) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_38); endcase;
				case(39) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_39); endcase;
				case(40) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_40); endcase;
				case(41) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_41); endcase;
				case(42) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_42); endcase;
				case(43) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_43); endcase;
				case(44) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_44); endcase;
				case(45) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_45); endcase;
				case(46) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_46); endcase;
				case(47) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_47); endcase;
				case(48) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_48); endcase;
				case(49) do m_pxDesktop^.SetCmd(sReference, CmdBarAccel_Shift_49); endcase;
				case default do endcase;
			endswitch;
			var string sRefNone=asKeys[i]+",NONE,"+sReference;
			var string sRefShift=asKeys[i]+",SHIFT,"+sReference;
			m_pxDesktop^.AddAccelerator(sRefNone);
			m_pxDesktop^.AddAccelerator(sRefShift);
		endfor;
		m_pxDesktop^.SetCmd("CmdBar_Accel_Abort", Accel_Abort);
		m_pxDesktop^.SetCmd("StornoLast", StornoLast);
		m_pxDesktop^.SetCmd("StornoAll", StornoAll);
		m_pxDesktop^.SetCmd("StornoEveryone", StornoEveryone);
	endproc;
	
	export proc bool CmdBarAccel_00();
		var string sIndex="CmdBar_Accel_0";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
		
	export proc bool CmdBarAccel_01();
		var string sIndex="CmdBar_Accel_1";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_02();
		var string sIndex="CmdBar_Accel_2";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_03();
		var string sIndex="CmdBar_Accel_3";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_04();
		var string sIndex="CmdBar_Accel_4";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_05();
		var string sIndex="CmdBar_Accel_5";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_06();
		var string sIndex="CmdBar_Accel_6";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_07();
		var string sIndex="CmdBar_Accel_7";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_08();
		var string sIndex="CmdBar_Accel_8";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_09();
		var string sIndex="CmdBar_Accel_9";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_10();
		var string sIndex="CmdBar_Accel_10";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_11();
		var string sIndex="CmdBar_Accel_11";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_12();
		var string sIndex="CmdBar_Accel_12";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_13();
		var string sIndex="CmdBar_Accel_13";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_14();
		var string sIndex="CmdBar_Accel_14";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_15();
		var string sIndex="CmdBar_Accel_15";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_16();
		var string sIndex="CmdBar_Accel_16";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_17();
		var string sIndex="CmdBar_Accel_17";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_18();
		var string sIndex="CmdBar_Accel_18";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_19();
		var string sIndex="CmdBar_Accel_19";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_20();
		var string sIndex="CmdBar_Accel_20";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_21();
		var string sIndex="CmdBar_Accel_21";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_22();
		var string sIndex="CmdBar_Accel_22";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_23();
		var string sIndex="CmdBar_Accel_23";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_24();
		var string sIndex="CmdBar_Accel_24";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_25();
		var string sIndex="CmdBar_Accel_25";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_26();
		var string sIndex="CmdBar_Accel_26";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_27();
		var string sIndex="CmdBar_Accel_27";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_28();
		var string sIndex="CmdBar_Accel_28";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_29();
		var string sIndex="CmdBar_Accel_29";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_30();
		var string sIndex="CmdBar_Accel_30";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_31();
		var string sIndex="CmdBar_Accel_31";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_32();
		var string sIndex="CmdBar_Accel_32";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_33();
		var string sIndex="CmdBar_Accel_33";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_34();
		var string sIndex="CmdBar_Accel_34";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_35();
		var string sIndex="CmdBar_Accel_35";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_36();
		var string sIndex="CmdBar_Accel_36";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_37();
		var string sIndex="CmdBar_Accel_37";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_38();
		var string sIndex="CmdBar_Accel_38";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_39();
		var string sIndex="CmdBar_Accel_39";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_40();
		var string sIndex="CmdBar_Accel_40";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_41();
		var string sIndex="CmdBar_Accel_41";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_42();
		var string sIndex="CmdBar_Accel_42";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_43();
		var string sIndex="CmdBar_Accel_43";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_44();
		var string sIndex="CmdBar_Accel_44";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_45();
		var string sIndex="CmdBar_Accel_45";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_46();
		var string sIndex="CmdBar_Accel_46";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_47();
		var string sIndex="CmdBar_Accel_47";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_48();
		var string sIndex="CmdBar_Accel_48";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_49();
		var string sIndex="CmdBar_Accel_49";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_00();
		var string sIndex="CmdBar_Accel_Shift_0";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
		
	export proc bool CmdBarAccel_Shift_01();
		var string sIndex="CmdBar_Accel_Shift_1";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_02();
		var string sIndex="CmdBar_Accel_Shift_2";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_03();
		var string sIndex="CmdBar_Accel_Shift_3";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_04();
		var string sIndex="CmdBar_Accel_Shift_4";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_05();
		var string sIndex="CmdBar_Accel_Shift_5";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_06();
		var string sIndex="CmdBar_Accel_Shift_6";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_07();
		var string sIndex="CmdBar_Accel_Shift_7";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_08();
		var string sIndex="CmdBar_Accel_Shift_8";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_09();
		var string sIndex="CmdBar_Accel_Shift_9";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_10();
		var string sIndex="CmdBar_Accel_Shift_10";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_11();
		var string sIndex="CmdBar_Accel_Shift_11";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_12();
		var string sIndex="CmdBar_Accel_Shift_12";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_13();
		var string sIndex="CmdBar_Accel_Shift_13";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_14();
		var string sIndex="CmdBar_Accel_Shift_14";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_15();
		var string sIndex="CmdBar_Accel_Shift_15";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_16();
		var string sIndex="CmdBar_Accel_Shift_16";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_17();
		var string sIndex="CmdBar_Accel_Shift_17";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_18();
		var string sIndex="CmdBar_Accel_Shift_18";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_19();
		var string sIndex="CmdBar_Accel_Shift_19";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_20();
		var string sIndex="CmdBar_Accel_Shift_20";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_21();
		var string sIndex="CmdBar_Accel_Shift_21";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_22();
		var string sIndex="CmdBar_Accel_Shift_22";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_23();
		var string sIndex="CmdBar_Accel_Shift_23";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_24();
		var string sIndex="CmdBar_Accel_Shift_24";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_25();
		var string sIndex="CmdBar_Accel_Shift_25";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_26();
		var string sIndex="CmdBar_Accel_Shift_26";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_27();
		var string sIndex="CmdBar_Accel_Shift_27";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_28();
		var string sIndex="CmdBar_Accel_Shift_28";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_29();
		var string sIndex="CmdBar_Accel_Shift_29";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_30();
		var string sIndex="CmdBar_Accel_Shift_30";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_31();
		var string sIndex="CmdBar_Accel_Shift_31";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_32();
		var string sIndex="CmdBar_Accel_Shift_32";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_33();
		var string sIndex="CmdBar_Accel_Shift_33";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_34();
		var string sIndex="CmdBar_Accel_Shift_34";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_35();
		var string sIndex="CmdBar_Accel_Shift_35";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_36();
		var string sIndex="CmdBar_Accel_Shift_36";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_37();
		var string sIndex="CmdBar_Accel_Shift_37";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_38();
		var string sIndex="CmdBar_Accel_Shift_38";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_39();
		var string sIndex="CmdBar_Accel_Shift_39";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_40();
		var string sIndex="CmdBar_Accel_Shift_40";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_41();
		var string sIndex="CmdBar_Accel_Shift_41";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_42();
		var string sIndex="CmdBar_Accel_Shift_42";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_43();
		var string sIndex="CmdBar_Accel_Shift_43";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_44();
		var string sIndex="CmdBar_Accel_Shift_44";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_45();
		var string sIndex="CmdBar_Accel_Shift_45";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_46();
		var string sIndex="CmdBar_Accel_Shift_46";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_47();
		var string sIndex="CmdBar_Accel_Shift_47";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_48();
		var string sIndex="CmdBar_Accel_Shift_48";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	export proc bool CmdBarAccel_Shift_49();
		var string sIndex="CmdBar_Accel_Shift_49";
		var string sKey=m_pxDesktop^.GetAnAccerleratorFromCmd(sIndex);
		var int i=sKey.Find(",");
		if(i<0)then return false; endif;
//		var string sFlag=sKey.Mid(i+1);
		sKey=sKey.Left(i);
		sKey.MakeUpper();
//		return CmdBarAccel(sKey, sFlag);
		return CmdBarAccel(sKey);
	endproc;
	
	proc void Update(bitset p_dwFlag)
		InvalidateContent();
		m_dwUpdateFlags |= p_dwFlag;
	endproc;

	export proc void OnUpdateContent()
		var bool bSelChangeDone=false;
//		bCBAActive=m_bCmdBarAccelActive;
		var int iRow=m_iRow, iCol=m_iCol;
		m_pxActionMenu^.SetSelObj();
		if((m_dwUpdateFlags&UPDATE_ACTIONMENU_SEL) != 0b)then
			m_pxActionMenu^.UpdateMenu(true);
			OpenFlyout();
			bSelChangeDone=true;
		endif;
		if(!bSelChangeDone && (m_dwUpdateFlags&UPDATE_ACTIONMENU_NONSEL) != 0b)then
			m_pxActionMenu^.UpdateMenu(false);
		endif;
		if((m_dwUpdateFlags&UPDATE_LEVELUPBUTTONS) != 0b)then
			m_pxActionMenu^.ValidateLevelUpBtn();
		endif;
		if((m_dwUpdateFlags&UPDATE_FLYOUT) != 0b)then
			m_pxActionMenu^.InitMenuCommands(m_xCurSelection, m_xCurFlyout);
			// m_pxFlyout^.UpdateCommands();
		endif;
		m_iRow=iRow;
		m_iCol=iCol;
		UpdateFlyout(false);
		m_dwUpdateFlags=0b;
		CWindowMgr.Get().BringWindowToTop(CClientWrap.GetDesktop(),true);
	endproc;

	export proc bool IsBuildingBuild()
		return((m_dwUpdateFlags&UPDATE_ACTIONMENU_BUILDINGBUILD)==UPDATE_ACTIONMENU_BUILDINGBUILD);
	endproc;
	
	export proc bool CmdBarAccel(string p_sKey)
//	export proc bool CmdBarAccel(string p_sKey, string p_sFlag)
		if(m_xCurSelection.NumEntries()==0||p_sKey==""||!m_bCmdBarAccelActive)then
			return false;
		endif;
		var array ^CCmdButton apxBttns;
		var string sCommand="";
		var bool bNONE=false,bFound=false;
		if(m_xCurFlyout!="NONE")then
			bFound=m_pxFlyout^.GetCommandButtons(p_sKey,apxBttns);
			bNONE=!bFound;
		else
			bNONE=true;
			sCommand="";
		endif;
		if(bNONE)then
			bFound=m_pxActionMenu^.FindCmdbarButtons(p_sKey,apxBttns);
		endif;
//		if(pxBtn!=null&&!pxBtn^.GetDisabled()&&!pxBtn^.IsDenied()&&pxBtn^.GetVisible())then
//			pxBtn^.OnClick();
//		endif;
		var int i,iC=apxBttns.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(apxBttns[i]!=null&&!apxBttns[i]^.GetDisabled()&&!apxBttns[i]^.IsDenied()&&apxBttns[i]^.GetVisible())then
				apxBttns[i]^.OnClick();
			endif;
		endfor;
		UpdateFlyout(false);
		return true;
	endproc;
	
	export proc bool Accel_Abort()
		if(CMainController.Get().GetPlacer().GetActive())then
			CMainController.Get().GetPlacer().SetActive(false);
			return true;
		endif;
		if(CMainController.Get().GetSecInputCtrl().GetTTPath()!="")then
			CMainController.Get().ResetSecondaryInputController();
			return true;
		endif;
		if(GetCurFlyout()!="NONE")then
			var ^CCmdButton pxBtn=m_pxActionMenu^.GetMenuButton(m_xCurFlyout);
			if(pxBtn!=null)then
				pxBtn^.SetButtonSelected(false);
			endif;
			m_pxFlyout^.SetActiveFlyout(false);
			m_pxFlyout^.SetVisible(false);
			m_pxFlyout^.SetFlyoutCategory(m_xCurFlyout);
			m_xCurFlyout="NONE";
		endif;
		CWindowMgr.Get().BringWindowToTop(CClientWrap.GetDesktop(),true);
//		if(m_pxFlyout != null)then
//			m_pxFlyout^.UpdateCommands();
//		else
//		endif;
		return(true);
	endproc;
	
	export proc bool StornoLast()
		var CObjList xCurFocus;
		var CClntHndl xObject, xInvalid;
		xCurFocus=CMirageClnMgr.Get().GetFocusList(CClientWrap.GetSelection());
		var ^CAttribs pxAttr=null;
		var int iMin, iIndex=0;
		var int i, iC=xCurFocus.NumEntries();
		for(i=0)cond(i<iC)iter(++i)do
			if(!xCurFocus[i].IsValid())then xCurFocus.DeleteEntry(i--); --iC; continue; endif;
			pxAttr=xCurFocus[i].GetObj()^.GetAttribs();
			if(pxAttr==null)then xCurFocus.DeleteEntry(i--); --iC; continue; endif;
			var string sProdQueue=pxAttr^.GetValue("ProdQueue");
			var array string asToks;
			sProdQueue.Split(asToks, ":", true);
			var int iProgress=0;
			var int iCount=Math.Max(asToks.NumEntries(),CMirageClnMgr.GetReactorActionNumber(pxAttr, iProgress));
			if(iCount > iMin)then
				iMin=iCount;
				iIndex=i;
			endif;
		endfor;
		if(iMin>0)then
			xObject=xCurFocus[iIndex];
			CEvt_GamePlayCommand.Send(xObject, "StornoLast", xInvalid, {0.0,0.0,0.0}, "");
		endif;
		return(true);
	endproc;
	
	export proc bool StornoAll()
		var CObjList xCurFocus=CMirageClnMgr.Get().GetFocusList(CClientWrap.GetSelection());
		var CClntHndl xObject;
		CEvt_GamePlayCommand.Send(xCurFocus, "StornoAll", xObject, {0.0,0.0,0.0}, "");
		return(true);
	endproc;
	
	export proc bool StornoEveryone()
		var CObjList xSelection=CClientWrap.GetSelection();
		var CClntHndl xObject;
		CEvt_GamePlayCommand.Send(xSelection, "StornoAll", xObject, {0.0,0.0,0.0}, "");
		return(true);
	endproc;
	
	export proc void ToggleAccelerators(bool p_bEnable)
		if(m_bCmdBarAccelActive != p_bEnable)then
			m_bCmdBarAccelActive=p_bEnable;
			m_pxActionMenu^.ToggleAccelerators(p_bEnable);
			if(m_pxFlyout != null)then
				m_pxFlyout^.UpdateCommands();
			endif;
		endif;
	endproc;
	
	export proc void UpdateFlyout(bool p_bEnable)
		if(p_bEnable==false)then
			m_iCol=-1;
			m_iRow=-1;
		endif;
		if(m_pxFlyout != null)then
			m_pxFlyout^.UpdateCommands();
		endif;
	endproc;
	
	class CQueueSelectionSorter

		export var int m_iQueueEntries;
		export var CClntHndl m_xHndl;
		export var bool m_bReady;
		export var bool m_bCPI;
		export var int m_iCurProgress;

		export proc bool op_Greater(ref CCommandBar.CQueueSelectionSorter p_rxOther)
//			if(CCommandBar.ms_bNewCommandSystem&&m_bReady!=p_rxOther.m_bReady)then
			if(m_bReady!=p_rxOther.m_bReady)then
				return p_rxOther.m_bReady;
			elseif(m_iQueueEntries!=p_rxOther.m_iQueueEntries)then
//			if(m_iQueueEntries!=p_rxOther.m_iQueueEntries)then
				return m_iQueueEntries>p_rxOther.m_iQueueEntries;
			else
				return m_iCurProgress<p_rxOther.m_iCurProgress;
			endif;
		endproc;
	endclass;
	
	export static proc CObjList SortByQueue(CObjList p_xList)
		var array CCommandBar.CQueueSelectionSorter axList;
		var bool bCPI=false;
		var int i,iC=p_xList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(!p_xList[i].IsValid())then continue; endif;
			var ^CAttribs pxAttr=p_xList[i].GetObj()^.GetAttribs();
			if(pxAttr==null)then continue; endif;
			// Henry: unfinished buildings shouldn't have pre-production...
//			if(!CCommandBar.ms_bNewCommandSystem&&pxAttr^.GetValue("CurTask")=="BuildUpB")then continue; endif;
//			if(pxAttr^.GetValue("CurTask")!="BuildUpB")then bCPI=true; endif;
			if(pxAttr^.GetValueInt("ReadyForWork")==1)then bCPI=true; endif;
			var ^CCommandBar.CQueueSelectionSorter pxEntry=^(axList.NewEntryRef());
			pxEntry^.m_xHndl=p_xList[i];
//			pxEntry^.m_iQueueEntries=0;
			var int iProgress=0;
			pxEntry^.m_iQueueEntries=CMirageClnMgr.GetReactorActionNumber(pxAttr, iProgress);
			pxEntry^.m_iCurProgress=pxAttr^.GetValueInt("CurProcess")+iProgress;
			var string sQueue=pxAttr^.GetValue("ProdQueue");
//			pxEntry^.m_bReady=(pxAttr^.GetValue("CurTask")!="BuildUpB");
			pxEntry^.m_bReady=(pxAttr^.GetValueInt("ReadyForWork")==1);
//			pxEntry^.m_bReady=true;
			if(!sQueue.IsEmpty())then
				var array string asToks;
				sQueue.Split(asToks, ":", true);
				pxEntry^.m_iQueueEntries += asToks.NumEntries();
			endif;
		endfor;
		axList.QSort();
		var CObjList xSortedList;
		iC=axList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(CCommandBar.ms_bSUB)then
				if(bCPI&&!axList[i].m_bReady)then continue; endif;
			endif;
			xSortedList.Include(axList[i].m_xHndl);
		endfor;
		return xSortedList;
	endproc;

	export static proc CObjList SortRevByQueue(CObjList p_xList)
		var array CCommandBar.CQueueSelectionSorter axList;
//		var bool bCPI=false;
		var int i,iC=p_xList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(!p_xList[i].IsValid())then continue; endif;
			var ^CAttribs pxAttr=p_xList[i].GetObj()^.GetAttribs();
			if(pxAttr==null)then continue; endif;
			// Henry: unfinished buildings shouldn't have pre-production, if there are capable buildings too...
//			if(!CCommandBar.ms_bNewCommandSystem&&pxAttr^.GetValue("CurTask")=="BuildUpB")then continue; endif;
//			if(pxAttr^.GetValue("CurTask")!="BuildUpB")then bCPI=true; endif;
			var ^CCommandBar.CQueueSelectionSorter pxEntry=^(axList.NewEntryRef());
			pxEntry^.m_xHndl=p_xList[i];
			var int iProgress=0;
			pxEntry^.m_iQueueEntries=CMirageClnMgr.GetReactorActionNumber(pxAttr, iProgress);
			pxEntry^.m_iCurProgress=pxAttr^.GetValueInt("CurProcess")+iProgress;
			var string sQueue=pxAttr^.GetValue("ProdQueue");
//			pxEntry^.m_bReady=(pxAttr^.GetValue("CurTask")!="BuildUpB");
			pxEntry^.m_bReady=(pxAttr^.GetValueInt("ReadyForWork")==1);
//			pxEntry^.m_bReady=true;
			if(!sQueue.IsEmpty())then
				var array string asToks;
				sQueue.Split(asToks, ":", true);
				pxEntry^.m_iQueueEntries += asToks.NumEntries();
			endif;
		endfor;
		axList.QSort();
		var CObjList xRevSortedList;
		iC=axList.NumEntries()-1;
		for(i=iC)cond(i>=0)iter(i--)do
//			if(!axList[i].m_bReady)then continue; endif;
			xRevSortedList.Include(axList[i].m_xHndl);
		endfor;
		return xRevSortedList;
	endproc;
	
	export static proc string GetCodesSimple(CObjList p_xList,bool p_bFilter)
		var string sCodes;
//		var bool bCPI=false;
		var int i,iC=p_xList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(!p_xList[i].IsValid())then continue; endif;
			var ^CAttribs pxAttr=p_xList[i].GetObj()^.GetAttribs();
			if(pxAttr==null)then continue; endif;
			// Henry: unfinished buildings shouldn't have pre-production...
//			if(p_bFilter&&!CCommandBar.ms_bNewCommandSystem&&pxAttr^.GetValue("CurTask")=="BuildUpB")then continue; endif;
			var string sCN=pxAttr^.GetValue("coded_name");
			if(sCN=="")then sCN=p_xList[i].GetObj()^.GetName(); endif;
			sCodes+="|"+sCN;
		endfor;
		return sCodes;
	endproc;
	
	export static proc bool IsGlobalUpgrade(string p_sPath, CClntHndl p_xHndl)
		var ^CObj pxObj=p_xHndl.GetObj();
		if(pxObj==null)then return false; endif;
		var CTechTree xTechTree=pxObj^.GetTechTree();
		var ^CTechTree.CNode pxNode=xTechTree.FindNode(p_sPath);
		if(pxNode==null)then return false; endif;
		pxNode=pxNode^.GetSub("results");
		if(pxNode==null)then return false; endif;
		var int i,iC=pxNode^.NumSubs();
		for(i=0)cond(i<iC)iter(i++)do
			var string sPath=pxNode^.GetSubValue(i);
			if(sPath.Left(9)!="/Filters/")then continue; endif;
			var ^CTechTree.CNode pxFlags=pxNode^.GetSub(i)^.GetSub("class");
			if(pxFlags==null)then continue; endif;
			if(pxFlags^.GetValue()=="player")then return true; endif;
		endfor;
		return false;
	endproc;

	export proc void ToggleFlyoutWnd(CFourCC p_xCat)
		if(m_xCurFlyout!=p_xCat)then
			var ^CCmdButton pxBtn=m_pxActionMenu^.GetMenuButton(m_xCurFlyout);
			if(pxBtn!=null)then
				pxBtn^.SetButtonSelected(false);
				m_pxFlyout^.SetActiveFlyout(false);
			endif;
			m_xCurFlyout=p_xCat;
		endif;
		if(m_pxFlyout^.IsActiveFlyout())then
			UpdateFlyout(false);
			m_pxFlyout^.SetVisible(false);
			m_pxFlyout^.SetActiveFlyout(false);
			m_xCurFlyout="NONE";
			m_pxFlyout^.SetFlyoutCategory(m_xCurFlyout);
		else
			if(m_xCurSelection.NumEntries()>0)then
				m_pxFlyout^.HideIcons();
				m_pxFlyout^.SetActiveFlyout(true);
				m_pxFlyout^.SetVisible(true);
				m_pxFlyout^.SetFlyoutCategory(m_xCurFlyout);
				Update(UPDATE_FLYOUT);
			endif;
		endif;
		CWindowMgr.Get().BringWindowToTop(CClientWrap.GetDesktop(),true);
	endproc;

	export proc bool HandleMessage(ref CEvtPointer p_rxEvt)
		if(p_rxEvt.GetClass()==CSubscriptionMgr.GetEvtClass_ObjChange())then
			var CClntHndl xObjHandle;
			var bitset dwTypes, dwAttribGroups;
			if(CSubscriptionMgr.EvtGetData_ObjChange(p_rxEvt,xObjHandle,dwTypes,dwAttribGroups))then
				var bool bRelevantTTChange=false;
				if((dwTypes & CSubscriptionMgr.CT_TechTree) != 0d)then
					var ^CTechTreeDef.TFilterChangeDesc pxTTFD=CSubscriptionMgr.EvtGetData_ObjChangeTTFilterChanges(p_rxEvt);
					if(pxTTFD!=null)then
						var int i,iC=pxTTFD^.GetNumFilters();
						for(i=0) cond(i<iC) iter(i++) do
							var ^CTechTreeDef.TFilterChangeDesc.TFilter pxFilter=^(pxTTFD^.GetFilter(i));
							var string sFilterListName=pxFilter^.GetName();
							if(sFilterListName.Find("RangeEffect")!=-1)then continue; endif;
							bRelevantTTChange=true;
						endfor;
					endif;
				endif;
				var bool bRelevantAttribChange=((dwTypes & CSubscriptionMgr.CT_ObjAttribs) != 0d);
				if(bRelevantTTChange||bRelevantAttribChange)then
					m_pxActionMenu^.InvalidateFlags();
					OnChangeValues(CInvoke.OBJCHG);
					return true;
				endif;
			endif;
		endif;
		return false;
	endproc;

	export proc ^CInGameScreen GetIngameScreen()
		return m_pxIScreen;
	endproc;

	export proc ^CFlyout GetFlyoutWindow()
		return m_pxFlyout;
	endproc;

	export proc ^CActionMenu GetActionMenu()
		return m_pxActionMenu;
	endproc;

	export proc void OnChangeSelection()
		var CObjList xNewSel;
		var bool bIsBuildingBuild=true;
		var string sCurSF=CMirageClnMgr.Get().GetSpecialFocus();
//		xNewSel=CClientWrap.GetSelection();
		xNewSel=CMirageClnMgr.Get().GetFocusList(CClientWrap.GetSelection(),true);
		if((!xNewSel.IsEqual(m_xCurSelection))||(!xNewSel.IsEqualEx(m_xOldSelection))||m_sSpecialFocus!=sCurSF)then
			m_sSpecialFocus=sCurSF;
			CGameWrap.GetSubscriptionMgr().UnsubscribeObjChanges(this);
			m_xOldSelection=xNewSel;
			PreprocessObjects(xNewSel, m_xCurSelection, bIsBuildingBuild);
			var int i, iC=xNewSel.NumEntries();
			for(i=0) cond(i<iC) iter(++i) do
				CGameWrap.GetSubscriptionMgr().SubscribeObjChanges(this,xNewSel[i],CSubscriptionMgr.CT_ObjAttribs|CSubscriptionMgr.CT_TechTree, "ActionMenu ActionMenuProgress");
			endfor;
			if(m_xCurSelection.NumEntries()>0)then
				var ^CObj pxO=GetSelObjPtr(0);
				if(pxO!=null)then
					m_xCurTechTree=pxO^.GetTechTree();
				endif;
			endif;
			m_pxFlyout^.SetVisible(false);
			m_pxFlyout^.SetActiveFlyout(false);
			m_xCurFlyout="NONE";
			m_pxActionMenu^.InvalidateFlags();
			if(bIsBuildingBuild==true)then
				Update(UPDATE_ACTIONMENU_SEL|UPDATE_ACTIONMENU_BUILDINGBUILD);
			else
				Update(UPDATE_ACTIONMENU_SEL);
			endif;
			// RT#16363 - Wir setzen den Placer erst auf Inactive wenn wir keinen Worker mehr haben
			if(m_xCurSelection.NumEntries() <= 0||!CGameInst.ms_xSelectionInfo.Has(CSelectionInfo.WORKER))then
				CMainController.Get().GetPlacer().SetActive(false);
			endif;
		endif;
	endproc;
	
	proc string GetMenuFromTribe(string p_sTribe)
		var string sMenu = "BLD";
		if(p_sTribe == "Hu")then
			sMenu += "H";
		elseif(p_sTribe == "Aje")then
			sMenu += "A";
		elseif(p_sTribe == "Ninigi")then
			sMenu += "N";
		elseif(p_sTribe == "SEAS")then
			sMenu += "S";
		else
			sMenu += "X";
		endif;
		return sMenu;
	endproc;
	
	proc void OpenFlyout()
		var bool bOnlyWorker=true;
		var bool bBuildings=false;
		var bool bMobileHQ=false;
		var int i, iC=m_xCurSelection.NumEntries();
		if(iC==0)then return; endif;
		for(i=0) cond(i<iC) iter(++i) do
			var ^CObj pxO=GetSelObjPtr(i);
			if(pxO==null)then continue; endif;
			if(pxO^.GetClassName().Find("worker")<0)then
				bOnlyWorker=false;
			endif;
			if(pxO^.GetClassName()=="aje_resource_collector")then
				bOnlyWorker=false;
				bMobileHQ=true;
				break;
			endif;
			if(pxO^.GetType()=="BLDG")then
				bOnlyWorker=false;
				bBuildings=true;
				break;
			endif;
		endfor;
		var ^CCmdButton pxBtn=null;
		if(bOnlyWorker)then
			var string sMenu = GetMenuFromTribe(CInfo.GetSelectedUnitTribe());
			m_xCurFlyout = sMenu;
			pxBtn=m_pxActionMenu^.FindMatchingMenuBtn(sMenu);
		elseif(bMobileHQ)then
			m_xCurFlyout = "PROD";
			pxBtn=m_pxActionMenu^.FindMatchingMenuBtn("PROD");
		elseif(bBuildings)then
			m_xCurFlyout = "SLOT";
			pxBtn=m_pxActionMenu^.FindMatchingMenuBtn("SLOT");
			if(pxBtn==null)then
				m_xCurFlyout = "PROD";
				pxBtn=m_pxActionMenu^.FindMatchingMenuBtn("PROD");
			endif;
		else
			m_xCurFlyout = "SPEC";
			pxBtn=m_pxActionMenu^.FindMatchingMenuBtn("SPEC");
			if(pxBtn==null)then
				m_xCurFlyout = "PROD";
				pxBtn=m_pxActionMenu^.FindMatchingMenuBtn("PROD");
			endif;
			if(pxBtn==null)then
				m_xCurFlyout = "SLOT";
				pxBtn=m_pxActionMenu^.FindMatchingMenuBtn("SLOT");
			endif;
		endif;
		if(pxBtn!=null)then
			m_pxFlyout^.SetVisible(false);
			m_pxFlyout^.SetActiveFlyout(false);
			pxBtn^.OnClick();
		else
			m_xCurFlyout= "NONE";
		endif;
		CWindowMgr.Get().BringWindowToTop(CClientWrap.GetDesktop(),true);
	endproc;

	export proc void OnChangeTechTree()
		Update(UPDATE_ACTIONMENU_NONSEL);
		Update(UPDATE_FLYOUT);
	endproc;

	export proc void OnChangeValues(int p_iInvokerID)
		if(m_xCurSelection.NumEntries()>0)then
			var bool bResChg=false;
			if(p_iInvokerID==CInvoke.PLYRCHG)then
				var array int aiChg;
				if(m_pxPlayer==null)then return; endif;
				var ^CAttribs pxA=m_pxPlayer^.GetAttribs();
				if(pxA!=null)then
					var int i, iC=m_asResName.NumEntries();
					var int iVal=0;
					for(i=0) cond(i<iC) iter(++i) do
						iVal=pxA^.GetValueInt(m_asResName[i]);
						if(m_aiResValue[i]!=iVal)then
							aiChg.AddEntry(i);
							m_aiResValue[i]=iVal;
						endif;
					endfor;
				endif;
				var int i,iC=aiChg.NumEntries();
				for(i=0) cond(i<iC) iter(++i) do
					if(iC==1&&m_asResName[aiChg[i]]=="iron")then
						Update(UPDATE_LEVELUPBUTTONS);
					else
						bResChg=true;
					endif;
				endfor;
				if(bResChg&&m_xCurFlyout!="BLDH"&&m_xCurFlyout!="BLDA"&&m_xCurFlyout!="BLDN"&&m_xCurFlyout!="BLDS"&&m_xCurFlyout!="PROD")then
					bResChg=false;
				endif;
			elseif(p_iInvokerID==CInvoke.PYRAMIDCHG)then
				Update(UPDATE_LEVELUPBUTTONS);
				if(m_pxFlyout^.IsActiveFlyout())then
					m_pxActionMenu^.ValidateCommands();
				endif;
			else
				bResChg=true;
			endif;
			//L KLog.LogWarn("CHP",m_xCurFlyout.AsString()+" "+p_iInvokerID.ToString()+" "+bResChg.ToString());
			if(m_xCurFlyout=="NONE")then return; endif;
			if(bResChg)then
				Update(UPDATE_ACTIONMENU_NONSEL);
				Update(UPDATE_FLYOUT);
			endif;
			if(m_pxActionMenu^.FindMatchingMenuBtn(m_xCurFlyout.AsString())==null)then
				if(m_pxFlyout^.IsActiveFlyout())then
					ToggleFlyoutWnd(m_xCurFlyout);
				endif;
			endif;
			//OpenFlyout();
			//m_pxActionMenu^.ValidateCommands();
		endif;
	endproc;

	export proc bool PyraTimer()
		m_iExtPyraUpdate=SetTimer(100,false);
		return(true);
	endproc;
	
	proc bool OnTimer(int p_iID)
		if(p_iID==m_iExtPyraUpdate)then
			OnChangeValues(CInvoke.PYRAMIDCHG);
		endif;
		return true;
	endproc;
	
	export proc void OnScreenTick()
	endproc;

	export proc void AvailableMenuButtons(CObjList p_xSelection, ref bool po_rbProd, ref bool po_rbBuild, ref bool po_rbSpecials, ref bool po_rbTraps)
		po_rbBuild=false;
		var int i, iC=p_xSelection.NumEntries();
		for(i=0) cond(i<iC) iter(++i) do
			var ^CObj pxO=p_xSelection[i].GetObj();
			if(pxO!=null)then
				if(pxO^.GetTechTree().GetValueI(GetObjPath(pxO)+"/can_build", 0)==1)then
					po_rbBuild=true;
					break;
				endif;
			endif;
		endfor;
		var array string asCat;
		asCat=1;
		asCat[0]="PROD";
		po_rbProd=GetAvailableActions(p_xSelection, null, null, asCat, null);
		asCat[0]="SPEC";
		po_rbSpecials=GetAvailableActions(p_xSelection, null, null, asCat, null);
		asCat[0]="TRAP";
		po_rbTraps=GetAvailableActions(p_xSelection, null, null, asCat, null);
	endproc;

	export proc void PreprocessObjects(ref CObjList p_rxOrgList, ref CObjList po_rxSignigicantList, ref bool po_rbIsBuildingBuild)
		var array string asClasses;
		var bool bAlreadyBuilding=false;
		var int iPlayerID=CGameWrap.GetClient().GetPlayerID();
		po_rxSignigicantList.Clear();
		var int i, iC=p_rxOrgList.NumEntries();
		for(i=0)cond(i<iC) iter(++i)do
			var ^CObj pxO=p_rxOrgList[i].GetObj();
			if(pxO!=null)then
				var string sClass=pxO^.GetClassName();
				var ^CAttribs pxAttribs=pxO^.GetAttribs();
				if(pxAttribs!=null)then
					sClass += ":"+pxAttribs^.GetValue("ObjFlag");
				endif;
				var int iIdx=asClasses.FindEntry(sClass);
				var bool bIsBuilding=pxO^.GetType()=="BLDG";
				var int iOwner = pxO^.GetOwner();
				if(CGameInst.CanBeControlled(iOwner))then
					if(iIdx<0)then
						if(bIsBuilding && !bAlreadyBuilding)then
							asClasses.AddEntry(sClass);
							po_rxSignigicantList.Include(p_rxOrgList[i]);
							bAlreadyBuilding=true;
						else
							asClasses.AddEntry(sClass);
							po_rxSignigicantList.Include(p_rxOrgList[i]);
						endif;
					else
						if(po_rxSignigicantList[iIdx].IsValid())then
							var ^CObj pxStored=po_rxSignigicantList[iIdx].GetObj();
							if(pxStored!=null)then
								var ^CAttribs pxStoredAttribs=pxStored^.GetAttribs();
								if(pxStoredAttribs!=null && pxAttribs!=null && pxStoredAttribs^.GetValueInt("level")<pxAttribs^.GetValueInt("level"))then
									po_rxSignigicantList[iIdx]=p_rxOrgList[i];
								endif;
							endif;
						endif;
					endif;
//					if((pxAttribs != null)&&(pxAttribs^.GetValue("CurTask")!="BuildUpB"))then
					if((pxAttribs != null)&&(pxAttribs^.GetValueInt("ReadyForWork")==1))then
						po_rbIsBuildingBuild=false;
					endif;
				endif;
			endif;
		endfor;
	endproc;

	export proc bool GetAvailableActions(ref CObjList p_rxObjects, ^array string p_pasNodes, ^array int p_paiLocIdx, ref array string p_rasCategory, ^array bool p_pabDeny)
	
		if(p_rasCategory.NumEntries()==1 && p_rasCategory[0]=="NONE")then return false; endif;
		
		var CTechTree xTT;
		
		var int i, iC=p_rxObjects.NumEntries();
		
		var string sOwnTribe="";
		var ^CPlayer pxPlayer=^(CGameWrap.GetClient().GetPlayer());
		if(pxPlayer!=null)then
			var ^CLevelInfo.CPlayerSlot pxPlayerSlot=pxPlayer^.GetPlayerSlot();
			if(pxPlayerSlot!=null)then
				sOwnTribe=pxPlayerSlot^.GetTribe();
			endif;
		endif;
		
		for(i=0)cond(i<iC)iter(++i)do
			if(!p_rxObjects[i].IsValid())then continue; endif;
			var ^CObj pxO=p_rxObjects[i].GetObj();
			var string sClass = pxO^.GetClassName();
			var string sType = pxO^.GetType().AsString();
			var string sObjTribe=GetObjTribe(pxO);
			var bool bStances=p_rasCategory.FindEntry("STNC")>=0;

			if((sObjTribe == "Special"))then
				var ^CLevelInfoClient pxLevelInfo=^(CGameWrap.GetClient().GetLevelInfo());
				if(pxLevelInfo!=null)then
					var ^CLevelInfo.CPlayerSlot pxRealOwnerSlot=pxLevelInfo^.GetOwnerPlayerSlot(pxO^.GetOwner());
					if(pxRealOwnerSlot!=null)then
						sObjTribe = pxRealOwnerSlot^.GetTribe();
					endif;
				endif;
			endif;
			
			var bool bHaveTribeBuildMenu = p_rasCategory.FindEntry(GetMenuFromTribe(sObjTribe))>=0;
			var bool bHaveTrapsBuildMenu = p_rasCategory.FindEntry("TRAP")>=0;
			var bool bTraderBuildMenu = (sClass == "Barry_s0" || sClass == "Harry_s0" || sClass == "Larry_s0");
			
			if(sClass == "aje_torpedo_turtle")then continue; endif;
			if(sClass == "mrg_sprt")then continue; endif;
			
			if(sType=="CHTR" && sObjTribe=="Aje" && bHaveTribeBuildMenu && !bTraderBuildMenu)then
				sClass=sObjTribe;
				sClass+="_worker";
				sClass.MakeLower();
			endif;
			
			if(bTraderBuildMenu)then
				sClass=sObjTribe;
				sClass+="_trader";
				sClass.MakeLower();
			endif;
			
			if(sClass=="tesla_s0" && (bHaveTribeBuildMenu || bHaveTrapsBuildMenu))then
				sClass=sObjTribe;
				sClass+="_worker";
				sClass.MakeLower();
			endif;

			var ^CAttribs pxAttr=pxO^.GetAttribs();
			if(p_rasCategory.FindEntry("SPEC")>=0 && pxAttr!=null && pxAttr^.GetValueBool("illusion"))then
				continue;
			endif;
			
			//Kr1s1m: If TT-Stealing is off and obj has a foreign build menu bHideBUIL flag becomes raised
			var bool bHideBUIL = false;
			if(!CMirageClnMgr.Get().CheckTechtreeSteal())then
				if(sObjTribe != sOwnTribe)then
					bHideBUIL = true;
				endif;
			endif;
			
			xTT=pxO^.GetTechTree();
			var array string asJupp;
			asJupp.AddEntry(sClass);
			asJupp.AddEntry(sType);
			var int iA, iAC=2;
			for(iA=0)cond(iA<iAC)iter(++iA)do
				var ^CTTHelper.CLocation pxLocation=CTTHelper.Get()[asJupp[iA]];
				if(pxLocation==null)then continue; endif;
				var bool bHasActionCat=false;
				var int iCatIdx, iNumCatIndices=p_rasCategory.NumEntries();
				for(iCatIdx=0)cond(iCatIdx<iNumCatIndices)iter(++iCatIdx)do
					if(pxLocation^.ContainsCategory(p_rasCategory[iCatIdx]))then
						bHasActionCat=true;
						break;
					endif;
				endfor;
				if(!bHasActionCat)then
					continue;
				endif;
				var string sTribe=GetObjTribe(pxO);
				var int iAction, iNumActions=pxLocation^.m_axActions.NumEntries();
				for(iAction=0)cond(iAction<iNumActions)iter(++iAction)do
					var ^CTTHelper.CActionPath pxActionInfo=^(pxLocation^.m_axActions[iAction]);
					if(p_pasNodes!=null && p_pasNodes^.FindEntry(pxActionInfo^.m_sPath)>=0)then continue; endif;
					if(p_rasCategory.FindEntry(pxActionInfo^.m_sCategory)<0)then continue; endif;
					var bool bVisibleElsewhere=false;
					var CTechTree xNewTT=xTT;
					var string sP=pxActionInfo^.m_sPath;
					var ^CTechTree.CNode pxAction=xNewTT.FindNode(sP);
					if(pxAction==null)then
						if(VisibleForOthers(m_xOldSelection, sP, xNewTT))then
							bVisibleElsewhere=true;
							pxAction=xNewTT.FindNode(sP);
						else
							continue;
						endif;
					endif;
					var int iLevel=0;
					var ^CAttribs pxA=pxO^.GetAttribs();
					if(pxA!=null)then iLevel=pxA^.GetValueInt("level"); endif;
					/*
					if((bSkipMovesNode && pxActionInfo^.m_sPath.Find("Moves")>=0) ||
						(bSkipBuildAndUpgrades && (pxActionInfo^.m_sPath.Find("Build")>=0||pxActionInfo^.m_sPath.Find("Upgrades")>=0)))then
						continue;
					endif;
					*/
					if(bStances)then
						var bool bIgnore=false;
						if(p_pasNodes!=null)then
							var int j, iJC=p_pasNodes^.NumEntries();
							for(j=0) cond(j<iJC) iter(++j) do
								if(p_pasNodes^[j].Find(sP.Mid(sP.FindRev('/')))>=0)then
									bIgnore=true;
									break;
								endif;
							endfor;
							if(bIgnore)then
								if(p_pasNodes^.NumEntries()==3)then return true; endif;
								continue;
							endif;
						else
							return true;
						endif;
					endif;
					var bool bDeny=false;
					/*
					var string sSF=CMirageClnMgr.Get().GetSpecialFocus();
					var ^CTechTree.CNode pxConditions=pxAction^.GetSub("conditions");
					if(sSF!=""&&pxConditions!=null)then
						var ^CTechTree.CNode pxTribe=pxConditions^.GetSub("tribe");
						if(pxTribe!=null)then
							var bool bValidTribe=false;
							var int iTribe, iNumTribes=pxTribe^.NumSubs();
							for(iTribe=0)cond(iTribe<iNumTribes)iter(++iTribe)do
								if(pxTribe^.GetSub(iTribe)^.GetValue()==sSF)then
									bValidTribe=true;
									break;
								endif;
							endfor;
							if(!bValidTribe && !bTesla)then continue; endif;
						endif;
					endif;
					*/
					if(m_bSkipOldTraps&&pxAction^.GetSubValueI("trap", 0)==1)then
						continue;
					elseif(pxAction^.GetSubValueI("visibility", 1)!=1)then
						if(bVisibleElsewhere||VisibleForOthers(m_xOldSelection, sP, xNewTT))then
							pxAction=xNewTT.FindNode(sP);
//						elseif(IsProcessing(pxActionInfo^.m_sPath, pxO))then
						elseif(IsProcessing(pxActionInfo^.m_sPath, m_xOldSelection))then
							bDeny=true;
						else
							continue;
						endif;
					endif;
					var ^CTechTree.CNode pxLocations=pxAction^.GetSub("locations");
					if(pxLocations==null)then continue; endif;
					var int iLocIdx=pxActionInfo^.m_iLocationIdx;
					var ^CTechTree.CNode pxLocNode=pxLocations^.GetSub(iLocIdx);
					var ^CTechTree.CNode pxUIPos=pxLocNode^.GetSub("uiposition");
					if(pxUIPos!=null)then
						var string sCat=pxUIPos^.GetSubValue("cat","");
						//Kr1s1m: if the bHideBUIL flag was raised, skip filling the BUIL action menu
						if(bHideBUIL)then
							if(sCat == "BLDH" || sCat == "BLDA" || sCat == "BLDN" || sCat == "BLDS" || sCat == "TRAP")then continue; endif;
						endif;
						if(p_rasCategory.FindEntry(sCat)<0)then continue; endif;
					endif;
					var ^CTechTree.CNode pxLocalFlags=pxLocNode^.GetSub("localflags");
					if(pxLocalFlags!=null)then
						var ^CTechTree.CNode pxObjFlag=xNewTT.FindNode("/Objects/"+sTribe+"/"+sType+"/"+sClass+"/flags");
						if(pxObjFlag==null)then continue; endif;
						var bool bValidFlag=false;
						var int iFlag, iNumFlags=pxLocalFlags^.NumSubs();
						for(iFlag=0)cond(iFlag<iNumFlags)iter(++iFlag)do
							if(pxLocalFlags^.GetSub(iFlag)^.GetValueI()<=0)then continue; endif;
							var string sFlag=pxLocalFlags^.GetSub(iFlag)^.GetName();
							if(pxObjFlag^.GetSub(sFlag)!=null)then
								bValidFlag=true;
								break;
							endif;
						endfor;
						if(!bValidFlag)then continue; endif;
					endif;
					if(p_pasNodes==null)then return true; endif;
					p_pasNodes^.AddEntry(pxActionInfo^.m_sPath);
					p_pabDeny^.AddEntry(bDeny);
					if(p_paiLocIdx!=null)then
						p_paiLocIdx^.AddEntry(iLocIdx);
					endif;
				endfor;
			endfor;
		endfor;
		if(p_pasNodes!=null)then return p_pasNodes^.NumEntries()>0; endif;
		return false;
	endproc;
	
	export proc bool IsProcessing(string p_sPath, CObjList p_xObjects)
		var int i, iC=p_xObjects.NumEntries();
		for(i=0)cond(i<iC)iter(++i)do
			if(!p_xObjects[i].IsValid())then continue; endif;
			var ^CObj pxO=p_xObjects[i].GetObj();
			if(IsProcessing(p_sPath, pxO))then
				return true;
			endif;
		endfor;
		return false;
	endproc;
	
	export proc bool IsProcessing(string p_sPath, ^CObj p_pxObject)
		if(p_pxObject!=null)then
			var ^CAttribs pxA=p_pxObject^.GetAttribs();
			if(pxA!=null)then
				var string sProcObj=pxA^.GetValue("CurProcessObj");
				var string sProdQueue=pxA^.GetValue("ProdQueue");
				if(sProcObj==p_sPath)then return true; endif;
				var array string asToks;
				sProdQueue.Split(asToks, ":", true);
				var int iIdx=0;
				var ^CPlayer pxPlayer=^(CGameWrap.GetClient().GetPlayer());
				if(pxPlayer!=null)then
					var ^CTechTree.CNode pxNode=pxPlayer^.GetPlayerTechTree().FindNode(p_sPath);
					if(pxNode!=null)then
						iIdx=pxNode^.GetHashValue();
					endif;
				endif;
				var int iCnt=0;
				var int i, iC=asToks.NumEntries();
				for(i=0) cond(i<iC) iter(++i) do
					if(asToks[i].ToInt()==iIdx)then ++iCnt; endif;
				endfor;
				return iCnt>0;
			endif;
		endif;
		return false;
	endproc;
	
	export proc bool VisibleForOthers(CObjList p_xObjects, string p_sPath, ref CTechTree p_rxNewTT)
		var CTechTree xOldTT=p_rxNewTT;
		var int i, iC=p_xObjects.NumEntries();
		for(i=0)cond(i<iC)iter(++i)do
			if(!p_xObjects[i].IsValid())then continue; endif;
			var ^CObj pxO=p_xObjects[i].GetObj();
			var ^CAttribs pxA=pxO^.GetAttribs();
			if(pxA==null)then continue; endif;
			p_rxNewTT=pxO^.GetTechTree();
			var ^CTechTree.CNode pxAction=p_rxNewTT.FindNode(p_sPath);
			if(pxAction==null)then continue; endif;
			if(m_bSkipOldTraps&&pxAction^.GetSubValueI("trap", 0)==1)then continue; endif;
			if(pxAction^.GetSubValueI("visibility", 1)!=1)then continue; endif;
			var ^CTechTree.CNode pxLocations=pxAction^.GetSub("locations");
			if(pxLocations==null)then continue; endif;
			var int iI, iS=pxLocations^.NumSubs();
			if(iS<0)then continue; endif;
			var bool bLocationOK=false;
			for(iI=0)cond(iI<iS)iter(++iI)do
				var ^CTechTree.CNode pxLocation =pxLocations^.GetSub(iI);
				if(pxLocation!=null)then
					var string sVal=pxLocation^.GetValue();
					var int iPos=sVal.FindRev('/');
					if(iPos!=-1)then
						sVal=sVal.Mid(iPos+1);
						if((sVal==pxO^.GetClassName())||(pxO^.GetType()==sVal))then
							var ^CTechTree.CNode pxLocalFlags=pxLocation^.GetSub("localflags");
							if(pxLocalFlags!=null)then
								var bool bValidFlag=false;
								var int iFlag, iNumFlags=pxLocalFlags^.NumSubs();
								for(iFlag=0)cond(iFlag<iNumFlags)iter(++iFlag)do
									if(pxLocalFlags^.GetSub(iFlag)^.GetValueI()>0)then
										var string sFlag=pxLocalFlags^.GetSub(iFlag)^.GetName();
										if(sFlag==pxA^.GetValue("ObjFlag"))then
											bValidFlag=true;
//											break;
										endif;
									endif;
								endfor;
								if(!bValidFlag)then continue; endif;
								bLocationOK=true;
								break;
							endif;
						endif;
					endif;
				endif;
			endfor;
			if(!bLocationOK)then continue; endif;
			return true;
		endfor;
		p_rxNewTT=xOldTT;
		return false;
	endproc;
	
//	export proc bool VisibleForOthers(CObjList p_xObjects, string p_sPath, ref CTechTree p_rxNewTT)
//		var CTechTree xOldTT = p_rxNewTT;
//		var int i, iC = p_xObjects.NumEntries();
//		for(i=0)cond(i<iC)iter(++i)do
//			if(!p_xObjects[i].IsValid())then continue; endif;
//			var ^CObj pxO = p_xObjects[i].GetObj();
//			p_rxNewTT = pxO^.GetTechTree();
//			var ^CTechTree.CNode pxAction = p_rxNewTT.FindNode(p_sPath);
//			if(pxAction==null)then continue; endif;
//			if(pxAction^.GetSubValueI("visibility", 1)==1)then
//				return true;
//			endif;
//		endfor;
//		p_rxNewTT = xOldTT;
//		return false;
//	endproc;
	
	export proc ^CTechTree.CNode FindNodeAtFocus(string p_sPath, ref CTechTree p_rxNewTT, ref CClntHndl p_rxObjHandle)
		var CTechTree xOldTT=p_rxNewTT;
		var int i, iC=m_xOldSelection.NumEntries();
		for(i=0)cond(i<iC)iter(++i)do
//			if(p_sPath==""||p_sPath=="/")then continue; endif;
			if(!m_xOldSelection[i].IsValid())then continue; endif;
			p_rxObjHandle=m_xOldSelection[i];
			var ^CObj pxO=m_xOldSelection[i].GetObj();
			p_rxNewTT=pxO^.GetTechTree();
			var ^CTechTree.CNode pxAction=p_rxNewTT.FindNode(p_sPath);
			if(pxAction==null)then continue; endif;
			var ^CTechTree.CNode pxLocs=pxAction^.GetSub("locations");
			if(pxLocs==null||pxLocs^.NumSubs()<1)then
				if(p_sPath.Find("Actions/")!=-1)then
					continue;
				else
					return pxAction;
				endif;
			endif;
			var bool bConfirmed=false;
			var int j, jC=pxLocs^.NumSubs();
			for(j=0)cond(j<jC)iter(++j)do
				var ^CTechTree.CNode pxLocNode=pxLocs^.GetSub(j);
				if(pxLocNode==null)then continue; endif;
				var ^CTechTree.CNode pxUIPos=pxLocNode^.GetSub("uiposition");
				if(pxUIPos==null)then continue; endif;
				var string sVal = pxLocNode^.GetValue();
				var int iPos = sVal.FindRev('/');
				if(iPos!=-1)then
					sVal = sVal.Mid(iPos+1);
					if(sVal!=pxO^.GetClassName()&&pxO^.GetType()!=sVal)then
						// HACK by Henry...
						if(sVal.Find("_worker")!=-1)then
							if(pxO^.GetClassName()!="tesla_s0"&&!(sVal=="aje_worker"&&pxO^.GetType()=="CHTR"&&GetObjTribe(pxO)=="Aje"))then
								continue;
							endif;
						elseif(sVal.Find("_trader")!=-1)then
							if(pxO^.GetClassName().Find("arry_s0")<0)then
								continue;
							endif;
						else
							continue;
						endif;
						// ENDHACK
					endif;
				endif;
				var ^CTechTree.CNode pxLocalFlags=pxLocNode^.GetSub("localflags");
				if(pxLocalFlags!=null)then
					var ^CTechTree.CNode pxObjFlag=p_rxNewTT.FindNode("/Objects/"+GetObjTribe(pxO)+"/"+pxO^.GetType().AsString()+"/"+pxO^.GetClassName()+"/flags");
					if(pxObjFlag==null)then continue; endif;
					var bool bValidFlag=false;
					var int iFlag, iNumFlags=pxLocalFlags^.NumSubs();
					for(iFlag=0)cond(iFlag<iNumFlags)iter(++iFlag)do
						if(pxLocalFlags^.GetSub(iFlag)^.GetValueI()<=0)then continue; endif;
						var string sFlag=pxLocalFlags^.GetSub(iFlag)^.GetName();
						if(pxObjFlag^.GetSub(sFlag)!=null)then
							bValidFlag=true;
							break;
						endif;
					endfor;
					if(!bValidFlag)then continue; endif;
					bConfirmed=true;
					break;
				else
					bConfirmed=true;
					break;
				endif;
			endfor;
			if(!bConfirmed)then continue; endif;
			return pxAction;
		endfor;
		p_rxObjHandle.Invalidate();
		p_rxNewTT=xOldTT;
		return null;
	endproc;
	
	export proc bool SomeWhereAvailable(string p_sPath)
		var int i, iC=m_xOldSelection.NumEntries();
		for(i=0)cond(i<iC)iter(++i)do
			if(!m_xOldSelection[i].IsValid())then continue; endif;
			var string sLocalUpgrade;
			var ^CObj pxO=m_xOldSelection[i].GetObj();
			var CTechTree xTT=pxO^.GetTechTree();
			var ^CTechTree.CNode pxAction=xTT.FindNode(p_sPath);
			if(pxAction==null)then continue; endif;
			if(!pxAction^.IsVisible())then continue; endif;
			if(m_bSkipOldTraps&&pxAction^.GetSubValueI("trap", 0)==1)then continue; endif;
			if(pxAction^.GetSubValueI("visibility", 1)!=1)then continue; endif;
			if(pxAction^.GetSubValueI("disabled", 0)==1)then continue; endif;
			var ^CAttribs pxA=pxO^.GetAttribs();
			if(pxA!=null)then
				sLocalUpgrade=pxA^.GetValue("LocalUpgrade");
			endif;
			if(sLocalUpgrade.IsEmpty()||sLocalUpgrade==p_sPath||CMirageClnMgr.Get().IsMinorLocalUpgrade(sLocalUpgrade))then
				return true;
			endif;
		endfor;
		return false;
	endproc;
	
	export proc bool GetAvailableActions(^CObj p_pxO, ^array string p_pasNodes, ^array int p_paiLocIdx, ref array string p_rasActTypes, string p_sCategory)
		var bool bCanProduce=false;
		if(p_pxO!=null)then
			var CTechTree xTT=p_pxO^.GetTechTree();
			var ^CTechTree.CNode pxObjNode=xTT.FindNode(GetObjPath(p_pxO));
			var ^CAttribs pxA=p_pxO^.GetAttribs();
			var string sClass=p_pxO^.GetClassName();
			var string sType =p_pxO^.GetType().AsString();
			if(pxA==null)then return false; endif;
			var array ^CTechTree.CNode apxNodes;
			var bool bIsHero=false;
			begin;
				var string sTribe=GetObjTribe(p_pxO);
				// HACK: Let the Heroes build stuff ...
				if(p_sCategory!="SPEC" && sTribe=="Special")then
					var ^CPlayer pxPlayer=^(CGameWrap.GetClient().GetPlayer());
					if(pxPlayer!=null)then
						sTribe=pxPlayer^.GetPlayerSlot()^.GetTribe();
						bIsHero=true;
					endif;
					var ^CLevelInfoClient pxLevelInfo=^(CGameWrap.GetClient().GetLevelInfo());
					if(pxLevelInfo!=null)then
						var ^CLevelInfo.CPlayerSlot pxRealOwnerSlot=pxLevelInfo^.GetOwnerPlayerSlot(p_pxO^.GetOwner());
						if(pxRealOwnerSlot!=null)then
							sTribe=pxRealOwnerSlot^.GetTribe();
						endif;
					endif;
					//if(bIsHero)then KLog.LogSpam("Kr1s1m", "bIsHero = true"); endif;
					//KLog.LogSpam("Kr1s1m", "line 4116: sTribe = "+sTribe);
				endif;
				// ENDHACK
				var int i, iC=p_rasActTypes.NumEntries();
				for(i=0) cond(i<iC) iter(++i) do
					apxNodes.AddEntry(xTT.FindNode("/Actions/"+sTribe+p_rasActTypes[i]));
				endfor;
			end;
			var int i, iC=apxNodes.NumEntries();
			for(i=0) cond(i<iC) iter(++i) do
				var ^CTechTree.CNode pxNode=apxNodes[i];
				if(pxNode!=null)then
					var int iResType, iNumResTypes=pxNode^.NumSubs();
					for(iResType=0) cond(iResType<iNumResTypes) iter(++iResType) do
						var ^CTechTree.CNode pxTypeNode=pxNode^.GetSub(iResType);
						var int iAct, iNumAct=pxTypeNode^.NumSubs();
						for(iAct=0) cond(iAct<iNumAct) iter(++iAct) do
							var ^CTechTree.CNode pxAction=pxTypeNode^.GetSub(iAct);
							if(m_bSkipOldTraps&&pxAction^.GetSubValueI("trap", 0)==1)then continue; endif;
							if(pxAction^.GetSubValueI("visibility")==0)then continue; endif;
							var ^CTechTree.CNode pxLocations=pxAction^.GetSub("locations");
							if(pxLocations!=null)then
								var int iLoc, iNumLocs=pxLocations^.NumSubs();
								for(iLoc=0) cond(iLoc<iNumLocs) iter(++iLoc) do
									var ^CTechTree.CNode pxLocNode=pxLocations^.GetSub(iLoc);
									var ^CTechTree.CNode pxUIPos=pxLocNode^.GetSub("uiposition");
									if(pxUIPos!=null)then
										if(pxUIPos^.GetSubValue("cat")!=p_sCategory)then continue; endif;
									endif;
									var string sVal=pxLocNode^.GetValue();
									var int iP=sVal.FindRev('/');
									if(iP>=0)then
										var string sL=sVal.Mid(iP+1);
										// HACK: Here comes another hack to let the heroes build something ....
										if(sL==sType||sL==sClass||(sL=="CHTR" && bIsHero))then
											var ^CTechTree.CNode pxLocalFlags=pxLocNode^.GetSub("localflags");
											if(pxLocalFlags!=null)then
												var bool bValidFlag=false;
												var int iFlag, iNumFlags=pxLocalFlags^.NumSubs();
												for(iFlag=0) cond(iFlag<iNumFlags) iter(++iFlag) do
													if(pxLocalFlags^.GetSub(iFlag)^.GetValueI()<=0)then continue; endif;
													var string sFlag=pxLocalFlags^.GetSub(iFlag)^.GetName();
													if(sFlag==pxA^.GetValue("ObjFlag"))then
														bValidFlag=true;
														break;
													endif;
												endfor;
												if(!bValidFlag)then continue; endif;
											endif;
											bCanProduce=true;
											if(p_pasNodes!=null)then
												p_pasNodes^.AddEntry(pxAction^.GetAbsPath());
												if(p_paiLocIdx!=null)then
													p_paiLocIdx^.AddEntry(iLoc);
												endif;
											else
												return bCanProduce;
											endif;
										endif;
									endif;
								endfor;
							endif;
						endfor;
					endfor;
				endif;
			endfor;
		endif;
		if(p_pasNodes!=null)then
			return p_pasNodes^.NumEntries()>0;
		endif;
		return false;
	endproc;

	//Henry: needed for 200 supply system
	export proc bool CheckFreeSupplies(string p_sTTPath)
		if(p_sTTPath.IsEmpty())then return false; endif;
		var ^CTechTree.CNode pxTTNode=m_xCurTechTree.FindNode(p_sTTPath);
		if(pxTTNode==null)then return false; endif;
		var ^CTechTree.CNode pxSupply=pxTTNode^.GetSub("supply");
		if(pxSupply==null)then
			return true;
		endif;
		var ^CPlayer pxPlayer=^(CGameWrap.GetClient().GetPlayer());
		if(pxPlayer!=null)then
			var ^CAttribs pxAttribs=pxPlayer^.GetAttribs();
			if(pxAttribs==null)then return false; endif;
			var ^CLevelInfoClient pxLevelInfo=^(CGameWrap.GetClient().GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			if(pxGenericDB==null)then return false; endif;
			var ^CPropDB.CNode pxCharsNode=^((pxGenericDB^)["PlayerSettings/Player_"+pxPlayer^.GetID().ToString()+"/Restrictions/Chars"]);
			var int iRealMaxUnits=200;
			if(pxCharsNode!=null)then
				var ^CPropDB.CNode pxPopNode=pxCharsNode^.Get("Supply");
				if(pxPopNode!=null)then
					iRealMaxUnits=pxPopNode^.GetValueI("Max",200);
				endif;
			endif;
			var int iMaxUnits=Math.Min(pxAttribs^.GetValueInt("max_supply"),iRealMaxUnits);
			var int iDff=pxAttribs^.GetValueInt("ai_level");
			if(iDff==7)then
				iMaxUnits += 30;
			elseif(iDff==8)then
				iMaxUnits += 60;
			elseif(iDff==9)then
				iMaxUnits += 100;
			endif;
			var int iUnits, iVirUnits=0;
			iUnits=pxAttribs^.GetValueInt("supply");
			iVirUnits=pxAttribs^.GetValueInt("virtual_supply");
			var int iSupplyCount=0;
			iSupplyCount=CMirageClnMgr.Get().GetSupply(pxSupply^.GetValue());
			if(iMaxUnits>=(iUnits+iVirUnits+iSupplyCount))then
				return true;
			endif;
		endif;
		return false;
	endproc;

	export proc bool CheckCharacterConditions(int p_iLevel)
		return CheckCharacterConditions(p_iLevel,true);
	endproc;

	export proc bool CheckCharacterConditions(int p_iLevel, bool p_bCheckMaxChars)
		if(m_pxIScreen!=null)then
			var ^CNewPyramid pxPyramid=m_pxIScreen^.GetPyramid();
			if(pxPyramid!=null)then
				var bool bFree=pxPyramid^.HasFreeSlots(p_iLevel);
				var bool bMax= pxPyramid^.MaximumReached();
				return (bFree&&(!bMax||!p_bCheckMaxChars));
			endif;
		endif;
		return false;
	endproc;

	proc int DoNothing()
		return 0;
	endproc;

	export proc bool CheckInventConditions(string p_sPath, ref string p_rsToolTip, string p_sObjTribe)
		var string sToolTip;
		var string sConditionPath=p_sPath+"/conditions";
		var bool bCheckInventObjects=true;
		var int i=0;
		if(m_xCurSelection.NumEntries()>0)then
			var ^CObj pxObj=GetSelObjPtr(i);
			if(pxObj!=null)then
				m_xCurTechTree=pxObj^.GetTechTree();
			endif;
		endif;
		var string sInventObj=m_xCurTechTree.GetValueS(sConditionPath+"/inventobjects/"+i.ToString(),"");
		while(sInventObj!="")do
			if(m_xCurTechTree.GetValueI("Objects/"+p_sObjTribe+"/InventObjects/"+sInventObj+"/invented",0)==1)then
			else
				bCheckInventObjects=false;
				sToolTip += sInventObj+" ";
			endif;
			i++;
			sInventObj=m_xCurTechTree.GetValueS(sConditionPath+"/inventobjects/"+i.ToString(),"");
		endwhile;
		if(i==0||bCheckInventObjects)then
			return true;
		else
			p_rsToolTip+=CLocalizer.Get().Translate("_ObjCommandBar_InventionsNeeded")+"\n"+sToolTip+"\n";
		endif;
		return false;
	endproc;

	export proc bool CheckBuildConditions(string p_sPath, ref string p_rsToolTip, string p_sObjTribe, ref bool p_rbMaxReached, ref int p_riCur, ref int p_riMax)
		var string sToolTip;
		var string sConditionPath=p_sPath+"/conditions";
		var bool bCheckInventObjects=true;
		var int i=0;
		var string sInventObj=m_xCurTechTree.GetValueS(sConditionPath+"/buildobjects/"+i.ToString(),"");
		while(sInventObj!="")do
			if(m_xCurTechTree.GetValueI("Objects/"+p_sObjTribe+"/BuildObjects/"+sInventObj+"/build",0)==1)then
			else
				bCheckInventObjects=false;
				var string sTranslatedObj="unknown ("+sInventObj+")";
				var ^CTechTree.CNode pxTribeObjects=m_xCurTechTree.FindNode("Objects/"+p_sObjTribe);
				if(pxTribeObjects!=null)then
					var ^CTechTree.CNode pxObject=pxTribeObjects^.FindNodeRecursiveByName(sInventObj);
					if(pxObject!=null)then
						CClientWrap.GetUIMgr().GetToopTipText(pxObject^.GetSubValue("description"),sTranslatedObj);
					endif;
				endif;
				sToolTip += sTranslatedObj+", ";
			endif;
			i++;
			sInventObj=m_xCurTechTree.GetValueS(sConditionPath+"/buildobjects/"+i.ToString(),"");
		endwhile;
		p_rbMaxReached = false;
		if(CMirageClnMgr.Get().CheckBldgMaxCapacity())then
			var ^CTechTree.CNode pxAction = m_xCurTechTree.FindNode(p_sPath);
			if(pxAction!=null)then
				var string sResult, sTribe=p_sObjTribe;
				if(p_sPath.Find("Build/BLDG")!=-1||p_sPath.Find("Upgrades")!=-1)then
					sResult=p_sPath.Mid(p_sPath.FindRev('/')+1);
					sResult=pxAction^.GetSubValue("product_name",sResult);
					sTribe=pxAction^.GetSubValue("product_tribe",sTribe);
					p_riCur=GetBuildingCount(sResult);
					p_riMax=m_xCurTechTree.GetValueI("Objects/"+sTribe+"/BLDG/"+sResult+"/max_quantity",-1);
//					if(m_xCurTechTree.GetValueI("Objects/"+sTribe+"/BuildingCount/"+sResult+"/max_reached",0)==1)then
					if((p_riMax>0&&(p_riCur>=p_riMax))||m_xCurTechTree.GetValueI("Objects/"+sTribe+"/BuildingCount/"+sResult+"/max_reached",0)==1)then
						p_rbMaxReached = true;
					endif;
				endif;
			endif;
		endif;
		if(p_rbMaxReached)then
			return false;
		endif;
		if(i==0||bCheckInventObjects)then
			return true;
		else
			sToolTip.TrimRight();
			if(sToolTip.Right(1)==",")then
				sToolTip.Delete(sToolTip.GetLength()-1);
			endif;
			p_rsToolTip+="\\{br}"+CLocalizer.Get().Translate("_ObjCommandBar_BuildingsNeeded")+"\n"+sToolTip+"\n";
		endif;
		return false;
	endproc;
	
	export proc int CheckConditions(string p_sPath, ref string p_rsToolTip)
		var ^CLevelInfoClient pxLevelInfo=^(CGameWrap.GetClient().GetLevelInfo());
		if(pxLevelInfo==null)then return 0; endif;
		var ^CPlayer pxPlayer=^(CGameWrap.GetClient().GetPlayer());
		if(pxPlayer==null)then return 0; endif;
		var ^CAttribs pxPlAttr=pxPlayer^.GetAttribs();
		if(pxPlAttr==null)then return 0; endif;
		var ^CTechTree.CNode pxConditionNode=m_xCurTechTree.FindNode(p_sPath+"/conditions");
		if(pxConditionNode==null)then return 1; endif;
		//var string sConditionPath=;
		//HACK: Tribe Abfrage ausgeschaltet
		var bool bCheckTribe=true;
		var bool bCheckChars=false;
		var bool bCheckResources=false;
		var bool bCheckAction=false;
		var int i=0;
		var array int aiLevels;
		var int iMinLevel=pxConditionNode^.GetSubValueI("level",0);
		i=0;
		bCheckChars=true;
		i=0;
		bCheckResources=true;
		var int iResNumPossible=1000;
		var string sResStr;
		var ^CTechTree.CNode pxResourceNode=m_xCurTechTree.FindNode("Resources/"+m_sTribe);
		var ^CTechTree.CNode pxResourceCostsNode=pxConditionNode^.GetSub("rescosts");
		if(pxResourceCostsNode!=null && pxResourceNode!=null)then
			var string sRes=pxResourceNode^.GetSubValue(i.ToString());
			while(sRes!="")do
				var int iResCost=pxResourceCostsNode^.GetSubValueI(sRes,0);
				//special handling for 'iron' what is 'skulls' now
				if(sRes!="iron")then
					sResStr += "/"+sRes+":"+iResCost.ToString();
				else
					sResStr += "/skulls:"+iResCost.ToString();
				endif;
				var int iResCur=pxPlAttr^.GetValueInt(sRes);
				if(iResCur<iResCost)then
					sResStr += ":NA";
					bCheckResources=false;
					iResNumPossible=0;
				elseif(iResCost>0)then
					var int iNum=iResCur/iResCost;
					if(iNum<iResNumPossible)then iResNumPossible=iNum; endif;
				endif;
				//p_rsToolTip += "   ";
				//if(i==1)then
					//p_rsToolTip += "\n";
				//endif;
				i++;
				sRes=pxResourceNode^.GetSubValue(i.ToString());
			endwhile;
		endif;
//		if(p_sPath.Find("floating_harbour")>=0)then
//			if(m_pxIScreen!=null)then
//				var ^CNewPyramid pxPyramid=m_pxIScreen^.GetPyramid();
//				if(pxPyramid!=null)then
//					var bool bFree=pxPyramid^.HasFreeSlots(0);
//					var ^CPlayer pxPlayer=^(CGameWrap.GetClient().GetPlayer());
//
//					if(pxPlayer!=null)then
//						var ^CAttribs pxAttr=pxPlayer^.GetAttribs();
//						var int iMax,iCount=0;
//						if(pxAttr!=null)then
//							iMax=pxAttr^.GetValueInt("max_units");
//							iCount=pxAttr^.GetValueInt("units")+pxAttr^.GetValueInt("virtual_units");
//						endif;
//						var bool bMax=iCount>=iMax;
//						if(!bFree||bMax)then
//							return 0;
//						endif;
//					endif;
//				endif;
//			endif;
//		endif;
//		var ^CTechTree.CNode pxNode=m_xCurTechTree.FindNode(p_sPath);
//		if(pxNode!=null)then
//			bCheckAction=!(pxNode^.GetSubValueB("disabled",false));
////			bCheckAction=!(pxNode^.GetSubValueI("disabled", 0)==1);
//		endif;
		bCheckAction=SomeWhereAvailable(p_sPath);
		//KLog.LogWarn("CHP","ChRes: "+p_sPath+" "+sResStr+" "+iResNumPossible.ToString());
		if(sResStr.GetLength()>0)then
			p_rsToolTip += "%"+sResStr+"%";
		endif;
		if(bCheckTribe && bCheckChars && bCheckResources && bCheckAction)then
			return iResNumPossible;
		endif;
		return 0;
	endproc;

	export proc void GatherInfo(string p_sPath, ref string p_rsToolTip)
		var string sSupply, sDuration;
		var int iSupply, iDuration=0;
		if(p_sPath.IsEmpty())then return; endif;
		var ^CTechTree.CNode pxTTNode=m_xCurTechTree.FindNode(p_sPath);
		if(pxTTNode==null)then return; endif;
		var ^CTechTree.CNode pxDuration=m_xCurTechTree.FindNode(p_sPath+"/duration");
		var ^CTechTree.CNode pxSupply=m_xCurTechTree.FindNode(p_sPath+"/supply");
		if(pxSupply!=null)then
			iSupply=CMirageClnMgr.Get().GetSupply(pxSupply^.GetValue());
			if(iSupply==1)then
				sSupply += "/spplcnt: "+iSupply.ToString()+CLocalizer.Get().Translate("_MIRAGE_Supply_1");
			elseif(iSupply>1)then
				sSupply += "/spplcnt: "+iSupply.ToString()+CLocalizer.Get().Translate("_MIRAGE_Supply_2");
			endif;
		endif;
		if(pxDuration!=null)then
			iDuration=pxDuration^.GetValueI();
			if(iDuration==1)then
				sDuration += "/tmdrtn: "+iDuration.ToString()+CLocalizer.Get().Translate("_MIRAGE_Duration_1");
			elseif(iDuration>59)then
				var string sTime;
				var int iHours, iMinutes, iSeconds;
				iHours=iDuration/3600;
				if(iHours > 0)then
					iDuration -= iHours * 3600;
					sTime += iHours.ToString()+":";
				endif;
				iSeconds=iDuration%60;
				iDuration -= iSeconds;
				iMinutes=iDuration/60;
				if(iHours > 0 && iMinutes<10)then
					sTime += "0";
				endif;
				sTime += iMinutes.ToString()+":";
				if(iSeconds<10)then
					sTime += "0";
				endif;
				sTime += iSeconds.ToString();
				if(iHours > 0)then
					if(iHours > 1)then
						sDuration += "/tmdrtn: "+sTime+CLocalizer.Get().Translate("_MIRAGE_Duration_6");
					else
						sDuration += "/tmdrtn: "+sTime+CLocalizer.Get().Translate("_MIRAGE_Duration_5");
					endif;
				elseif(iMinutes > 1)then
					sDuration += "/tmdrtn: "+sTime+CLocalizer.Get().Translate("_MIRAGE_Duration_4");
				else
					sDuration += "/tmdrtn: "+sTime+CLocalizer.Get().Translate("_MIRAGE_Duration_3");
				endif;
				iDuration=pxDuration^.GetValueI();
			elseif(iDuration>1)then
				sDuration += "/tmdrtn: "+iDuration.ToString()+CLocalizer.Get().Translate("_MIRAGE_Duration_2");
			endif;
		endif;
		if(iDuration>0)then
			p_rsToolTip += " %"+sDuration+"%";
		endif;
		if(iSupply>0)then
			p_rsToolTip += " %"+sSupply+"%";
		endif;
		return;
	endproc;
	
	export proc void CheckMana(string p_sPath, ref string p_rsToolTip)
		var string sMana;
		var int iReqMana=0;
		var ^CTechTree.CNode pxMana=m_xCurTechTree.FindNode(p_sPath+"/manacosts");
		if(pxMana!=null)then
			if(pxMana^.GetValueI()>0)then
				iReqMana=pxMana^.GetValueI();
				sMana += "/mncsts: "+pxMana^.GetValueI().ToString()+CLocalizer.Get().Translate("_MI_ManaRequirement_2");
			endif;
		endif;
		if(iReqMana>0)then
			p_rsToolTip += " %"+sMana+"%";
		endif;
		return;
	endproc;
	
	proc bool CheckPersonalConditions(^CObj p_pxObj, string p_sPath)
		//check environment
		if(p_pxObj==null)then return false; endif;
		var ^CLevelInfoClient pxLevelInfo=^(CGameWrap.GetClient().GetLevelInfo());
		if(pxLevelInfo==null)then return false; endif;
		var ^CPlayer pxPlayer=^(CGameWrap.GetClient().GetPlayer());
		if(pxPlayer==null)then return false; endif;
		var ^CAttribs pxPlAttr=pxPlayer^.GetAttribs();
		if(pxPlAttr==null)then return false; endif;
		var ^CLevelInfo.CPlayerSlot pxPlSlot=^(pxLevelInfo^.GetOwnerPlayerSlot(p_pxObj^.GetOwner()));
		if(pxPlSlot==null)then return false; endif;
		var ^CAttribs pxAttr=p_pxObj^.GetAttribs();
		if(pxAttr==null)then return false; endif;
		var string sConditionPath=p_sPath+"/conditions";
		var bool bCheckCaste=true;
		var bool bCheckLevel=true;
		var int i;
		//level & caste checks, quite weird
		if(p_pxObj^.GetType()=="CHTR")then
			bCheckCaste=false;
			bCheckLevel=false;
			i=0;
			var string sCharCaste=pxAttr^.GetValue("caste");
			var int iCharLevel=pxAttr^.GetValueInt("level");
			while(m_xCurTechTree.GetValueS(sConditionPath+"/caste/"+i.ToString(),"")!="")do
				var string sCaste=m_xCurTechTree.GetValueS(sConditionPath+"/caste/"+i.ToString(),"");
				if(sCaste==sCharCaste)then
					bCheckCaste=true;
				endif;
				i++;
			endwhile;
			if(i==0)then
				bCheckCaste=true;
			endif;
			i=0;
			var int iMinLevel=m_xCurTechTree.GetValueI(sConditionPath+"/level",0);
			if((iMinLevel-1) <= iCharLevel)then
				bCheckLevel=true;
			endif;
		endif;
		if(bCheckCaste && bCheckLevel)then
		else
			return false;
		endif;
		return true;
	endproc;

	export proc string GetObjPath(^CObj p_pxObj)
		var ^CAttribs pxAttr=p_pxObj^.GetAttribs();
		if(pxAttr!=null)then
			return pxAttr^.GetValue("ObjPath");
		endif;
		return "";
	endproc;

	export proc string GetPlayerObjPath(^CObj p_pxObj)
		var ^CAttribs pxAttr=p_pxObj^.GetAttribs();
		if(pxAttr!=null)then
			var string sObjPath=pxAttr^.GetValue("ObjPath");
			var int iIdx=sObjPath.Find("Objects/");
			if(iIdx!=-1)then
				sObjPath=sObjPath.Mid(iIdx+8);
				iIdx=sObjPath.Find("/");
				if(iIdx!=-1)then
					return "Objects/"+m_sTribe+sObjPath.Mid(iIdx);
				endif;
			endif;
			return sObjPath;
		endif;
		return "";
	endproc;

	export proc string GetObjTribe(^CObj p_pxObj)
		var ^CAttribs pxAttr=p_pxObj^.GetAttribs();
		if(pxAttr!=null)then
			return pxAttr^.GetValue("tribe");
		endif;
		return "";
	endproc;

	export proc string GetObjTribe(^CObj p_pxObj, string p_sAPath, ref string p_rsATribe)
		if(p_sAPath.Find("/Aje/")!=-1)then
			p_rsATribe="Aje";
		elseif(p_sAPath.Find("/Hu/")!=-1)then
			p_rsATribe="Hu";
		elseif(p_sAPath.Find("/Ninigi/")!=-1)then
			p_rsATribe="Ninigi";
		elseif(p_sAPath.Find("/SEAS/")!=-1)then
			p_rsATribe="SEAS";
		elseif(p_sAPath.Find("/Special/")!=-1)then
			p_rsATribe="Special";
		elseif(p_sAPath.Find("/World/")!=-1)then
			p_rsATribe="World";
		endif;
		var ^CAttribs pxAttr=p_pxObj^.GetAttribs();
		if(pxAttr!=null)then
			return pxAttr^.GetValue("tribe");
		endif;
		return "";
	endproc;

	export proc ^CObj GetSelObjPtr(int p_iIndex)
		if((p_iIndex<0)||(p_iIndex>=m_xCurSelection.NumEntries()))then return null;endif;
		return m_xCurSelection[p_iIndex].GetObj();
	endproc
	
	proc int GetBuildingCount(string p_sClass)
		var int iCount=-1;
		var ^CPlayer pxPlayer = ^(CGameWrap.GetClient().GetPlayer());
		if(pxPlayer==null)then return iCount; endif;
		var CObjList xBldg=pxPlayer^.GetBuildings();
		var int i,iC=xBldg.NumEntries();
		iCount=iC;
		for(i=0)cond(i<iC)iter(i++)do
			if(!CompareClass(xBldg[i],p_sClass))then
				iCount-=1;
			endif;
		endfor;
		return iCount;
	endproc;
	
	proc bool CompareClass(CClntHndl p_xHandle, string p_sClass)
		if(!p_xHandle.IsValid())then return false; endif;
		var ^CObj pxObj = p_xHandle.GetObj();
		if(pxObj==null)then return false; endif;
		var string sClass=pxObj^.GetClassName();
		if(sClass=="Virtual_Produce_Unit")then return false; endif;
		var ^CAttribs pxAttr=pxObj^.GetAttribs();
		if(p_sClass.Find("aje_")!=-1&&pxAttr!=null)then
			var string sFlag = pxAttr^.GetValue("ObjFlag");
			if(sFlag!="")then
				return p_sClass==sFlag;
			endif;
		endif;
		return p_sClass==sClass;
	endproc;
	
endclass;

class CTTHelper
	
	static var ^CTTHelper ms_pxInst;
	var array CTTHelper.CLocation m_axList;
	
	export static proc ref CTTHelper Get()
		if(ms_pxInst==null)then
			ms_pxInst=new CTTHelper();
		endif;
		return ms_pxInst^;
	endproc;
	
	export static proc void StaticShut()
		delete ms_pxInst;
		ms_pxInst=null;
	endproc;
	
	class CActionPath
		
		export var int m_iLocationIdx;
		export var string m_sPath;
		export var string m_sCategory;
	
		export proc bool op_Equal(ref CTTHelper.CActionPath p_rxRhs)
			return m_sPath==p_rxRhs.m_sPath;
		endproc;
		
	endclass;
	
	class CLocation
		
		export var string m_sClass;
		export var array CActionPath m_axActions;
		var array string m_asCategories;
		
		export proc bool op_Equal(ref CTTHelper.CLocation p_rxRhs)
			return m_sClass==p_rxRhs.m_sClass;
		endproc;
		
		export proc bool GetActionInfo(int p_iIdx, ^string p_psPath, ^string p_psCat, ^int p_piLocationIdx)
			if(p_iIdx<0||p_iIdx>=m_axActions.NumEntries())then return false; endif;
			var ^CActionPath pxP=^(m_axActions[p_iIdx]);
			if(p_psPath!=null)then p_psPath^=pxP^.m_sPath; endif;
			if(p_psCat!=null)then p_psCat^=pxP^.m_sCategory; endif;
			if(p_piLocationIdx!=null)then p_piLocationIdx^=pxP^.m_iLocationIdx; endif;
			return true;
		endproc;
		
		export proc int NumActions()
			return m_axActions.NumEntries();
		endproc;
		
		export proc bool ContainsAction(string p_sPath)
			var CActionPath xP; xP.m_sPath=p_sPath;
			return m_axActions.FindEntry(xP)>=0;
		endproc;
		
		export proc bool ContainsCategory(string p_sCat)
			return m_asCategories.FindEntry(p_sCat)>=0;
		endproc;
		
		export proc bool AddActionPath(string p_sPath, string p_sCategory, int p_iLocIdx)
			if(ContainsAction(p_sPath))then return false; endif;
			var ^CActionPath pxActInfo=^(m_axActions.NewEntryRef());
			pxActInfo^.m_sPath=p_sPath;
			pxActInfo^.m_sCategory=p_sCategory;
			pxActInfo^.m_iLocationIdx=p_iLocIdx;
			if(m_asCategories.FindEntry(p_sCategory)<0)then
				m_asCategories.AddEntry(p_sCategory);
			endif;
			return true;
		endproc;
		
	endclass;
	
	export proc ^CTTHelper.CLocation op_Index(string p_sLocation)
		var CLocation xL;xL.m_sClass=p_sLocation;
		var int iIdx=m_axList.FindEntry(xL);
		if(iIdx<0)then return null; endif;
		return ^m_axList[iIdx];
	endproc;
	
	export proc void InitFromTT()
		m_axList=0;
		var CTechTree xTT;
		var string sTribe;
		var ^CPlayer pxPlayer=^(CGameWrap.GetClient().GetPlayer());
		var bool bTechtreeSteal=CMirageClnMgr.Get().CheckTechtreeSteal();
		if(/*!bTechtreeSteal&&*/pxPlayer!=null)then
			//xTT=pxPlayer^.GetPlayerTechTree();
			if(pxPlayer^.GetPlayerSlot()!=null)then
				sTribe=pxPlayer^.GetPlayerSlot()^.GetTribe();
			endif;
		endif;
		var CTechTreeDef xTTDef;
		xTT=CTechTreeMgr.Get().GetTechTree(xTTDef);
		var array string asTribes;
		//if(!bTechtreeSteal)then
			//asTribes.AddEntry(sTribe);
			//asTribes.AddEntry("Special");
		//else
		//Kr1s1m: TechtreeSteal is now always on. Foreign tribe active and passive specials always work.
		//Kr1s1m: Server setting still prevents placing foreign tribe buildings when TechtreeSteal is disabled.
		asTribes.AddEntry("Aje");
		asTribes.AddEntry("Hu");
		asTribes.AddEntry("Ninigi");
		asTribes.AddEntry("SEAS");
		asTribes.AddEntry("Special");
		asTribes.AddEntry("World");
		//endif;
		var int iCurTribe, iNumTribes=asTribes.NumEntries();
		for(iCurTribe=0) cond(iCurTribe<iNumTribes) iter(++iCurTribe) do
			var ^CTechTree.CNode pxActions=xTT.FindNode("/Actions/"+asTribes[iCurTribe]);
			if(pxActions==null)then continue; endif;
			var int iCurActCategory, iNumActCategories=pxActions^.NumSubs();
			for(iCurActCategory=0) cond(iCurActCategory<iNumActCategories) iter(++iCurActCategory) do
				var ^CTechTree.CNode pxActionCategories=pxActions^.GetSub(iCurActCategory);
				var int iCurActType, iNumActTypes=pxActionCategories^.NumSubs();
				for(iCurActType=0) cond(iCurActType<iNumActTypes) iter(++iCurActType) do
					var ^CTechTree.CNode pxActType=pxActionCategories^.GetSub(iCurActType);
					var int iAct, iNumActs=pxActType^.NumSubs();
					for(iAct=0) cond(iAct<iNumActs) iter(++iAct) do
						var ^CTechTree.CNode pxA=pxActType^.GetSub(iAct);
						var string sActionPath=pxA^.GetAbsPath();
						var ^CTechTree.CNode pxLocations=pxA^.GetSub("locations");
						if(pxLocations==null)then continue; endif;
						var int iLocIdx, iNumLocs=pxLocations^.NumSubs();
						for(iLocIdx=0) cond(iLocIdx<iNumLocs) iter(++iLocIdx) do
							var ^CTechTree.CNode pxLocNode=pxLocations^.GetSub(iLocIdx);
							var string sLocation=pxLocNode^.GetValue();
							var string sL=sLocation.Mid(sLocation.FindRev('/')+1);
							var ^CTTHelper.CLocation pxLocData=CTTHelper.Get()[sL];
							if(pxLocData==null)then
								pxLocData=^(m_axList.NewEntryRef());
								pxLocData^.m_sClass=sL;
							endif;
							if(pxLocData!=null)then
								var ^CTechTree.CNode pxUIPos=pxLocNode^.GetSub("uiposition");
								if(pxUIPos!=null)then
									pxLocData^.AddActionPath(sActionPath, pxUIPos^.GetSubValue("cat",""), iLocIdx);
								endif;
							endif;
						endfor;
					endfor;
				endfor;
			endfor;
		endfor;
	endproc;
	
endclass;
