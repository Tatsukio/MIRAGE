class CCmdButton
	export const int		TYPE_INVALID			=-1;
	export const int		TYPE_LEFT_SPACER	=+0;
	export const int		TYPE_END_PIECE		=+1;
	export const int		TYPE_FLYOUT_BTN		=+2;
	export const int		TYPE_ACTION_BTN		=+3;
	export const int		TYPE_MENUCMD_BTN	=+4;

	export const int		TYPE_MENU					=+2;
	export const int		TYPE_ACTION				=+3;
	export const int		TYPE_MENUCMD			=+4;

	var ^CCmdBarButton	m_pxButton;
	var ^CStaticCtrl		m_pxStatic;
	var ^CStaticCtrl		m_pxAccelerator;	// can't use CStaticCtrlEx because extended control seems to have a bug which causes flickering of the accelartor description in combination with progress buttons

	var ^CCommandBar		m_pxParent;

	var CFourCC					m_xCategory;

	var int							m_iType;
	var string					m_sCommand;
	var string					m_sAssignedKey;
	var string					m_sSkillTribe;
	var string					m_sTTPath;
	var string					m_sShortName;
	var string					m_sCode;
	var int							m_iLocationIndex;
	var bool						m_bPersonal;

	var string					m_sAdditionalInfo;

	var bool						m_bSelected;
	var bool						m_bDisabled;
	var bool						m_bDeny;

	var string					m_sTooltipKey;
	var string					m_sTooltipTitle;
	var string					m_sTooltipText;

	var int							m_iPositionIndex;
	var int							m_iResNumPossible;

	var ^CCardBitmap		m_pxIdle;
	var ^CCardBitmap		m_pxDown;
	var ^CCardBitmap		m_pxHovered;
	var ^CCardBitmap		m_pxDisabled;
	var ^CCardBitmap		m_pxFlash;

	var bool						m_bSecondaryInputControl;

	export constructor()
		m_xCategory				="****";
		m_iType						=TYPE_INVALID;
		m_iLocationIndex	=-1;
		m_iPositionIndex	=-1;
		m_pxIdle					=null;
		m_pxDown					=null;
		m_pxHovered				=null;
		m_pxDisabled			=null;
		m_pxFlash					=null;
		m_bPersonal				=false;
	endconstructor;

	export destructor()
		if(m_pxAccelerator!=null)then
			if(m_pxButton!=null)then
				m_pxButton^.RemoveChild(m_pxAccelerator);
			endif;
			m_pxAccelerator^.Destroy();
		endif;
		if(m_pxButton!=null)then
			m_pxButton^.Destroy();
		endif;
		if(m_pxStatic!=null)then
			m_pxStatic^.Destroy();
		endif;
		m_pxIdle=null;
		m_pxDown=null;
		m_pxHovered=null;
		m_pxDisabled=null;
		m_pxFlash=null;
	enddestructor;

	export proc int GetType()
		return(m_iType);
	endproc;

	export proc string GetCommand()
		return(m_sCommand);
	endproc;

	export proc string GetHotKey()
		return(m_sAssignedKey);
	endproc;
	
	export proc string GetTTPath()
		return(m_sTTPath);
	endproc;
	
	export proc string GetSkillTribe()
		return(m_sSkillTribe);
	endproc;
	
	export proc string GetShortName()
		return(m_sShortName);
	endproc;
	
	export proc string GetCode()
		return m_sCode;
	endproc;

	export proc void SetShortName(string p_sTTPath)
		var int iP=p_sTTPath.FindRev('/');
		if(iP>=0)then
			m_sShortName=p_sTTPath.Mid(iP+1);
		else
			m_sShortName=="";
		endif;
	endproc;
	
	export proc string GetCategory()
		return(m_xCategory.AsString());
	endproc;

	export proc string GetTooltipKey()
		return(m_sTooltipKey);
	endproc;

	export proc int GetPosIndex()	//	Duplikat für Testzwecke
		return(m_iPositionIndex);
	endproc;

	export proc int GetPositionIndex()
		return(m_iPositionIndex);
	endproc;

	export proc ^CWindow GetActiveControl()
		if(m_pxButton!=null)then
			return(m_pxButton);
		endif;
		return(m_pxStatic);
	endproc;

	export proc void SetToolTipText(string p_sText)		
		if(m_pxButton!=null)then
			m_pxButton^.SetToolTipText(p_sText);
		endif;
	endproc;

	export proc bool GetSelected()	//	Duplikat für Testzwecke
		return(m_bSelected);
	endproc;

	export proc bool IsSelected()
		return(m_bSelected);
	endproc;

	export proc void SetDeny(bool p_bDeny)
		m_bDeny=p_bDeny;
	endproc;

	export proc void Validate()
		if(m_xCategory=="SLOT")then
			return;
		endif;
		var bool bIsSupplyOn=CMirageClnMgr.Get().IsSupplyOn();
//		var CObjList xAll=CClientWrap.GetSelection();
		var CObjList xObjList=CMirageClnMgr.Get().GetFocusList(CClientWrap.GetSelection(),true);
		var ^CObj pxObj=null;
		var CTechTree xObjTT;
		var CClntHndl xObjHandle;
		var ^CTechTree.CNode pxAction=m_pxParent^.FindNodeAtFocus(m_sTTPath, xObjTT, xObjHandle);
		pxObj=xObjHandle.GetObj();
		if(!xObjHandle.IsValid()&& xObjList.NumEntries()> 0)then
			pxObj=xObjList[0].GetObj();
		endif;
		var string sObjTribe=m_pxParent^.m_sTribe;
		var string sTmp;
		if(pxObj==null)then
			return;
		else
			sObjTribe=m_pxParent^.GetObjTribe(pxObj,m_sTTPath,sTmp);
		endif;
//		if(sObjTribe==""||sObjTribe=="Special")then
//			sObjTribe=m_pxParent^.m_sTribe;
		if(sObjTribe=="")then
			sObjTribe=m_pxParent^.m_sTribe;
		elseif(sObjTribe=="Special"&&sTmp!="")then
			sObjTribe=sTmp;
		endif;
		if(pxAction==null)then
			xObjTT=pxObj^.GetTechTree();
		endif;
		if(m_sTooltipTitle.IsEmpty()&&(pxObj!=null)&&(m_sTTPath.IsEmpty()==false))then
			var ^CTechTree.CNode pxNode=xObjTT.FindNode(m_sTTPath+"/locations/"+m_iLocationIndex.ToString()+ "/description");
			if(pxNode!=null)then
				m_sTooltipKey=pxNode^.GetValue();
				var string sTemp=m_sTooltipKey;
				if(sTemp!="" && sTemp.GetAt(0)=='_')then
					sTemp.Delete(0);
				endif;
				m_sTooltipText=CClientWrap.GetUIMgr().GetToopTipText(m_sTooltipKey, m_sTooltipTitle);
/*				m_sTooltipText.Replace("\n", " ");
				m_sTooltipText.TrimLeft();
				m_sTooltipText.TrimRight();
*/
				if(m_sTooltipText.IsEmpty()&&m_sTooltipTitle.IsEmpty())then
					m_sTooltipText=m_sTooltipKey;
				endif;
			endif;
		endif;
		var ^CTechTree.CNode pxResultsNode=xObjTT.FindNode(m_sTTPath+"/results");
		var bool bLevelFree=true;
		if(pxResultsNode!=null)then
			var int iI, iC=pxResultsNode^.NumSubs();
			for(iI=0)cond(iI<iC)iter(++iI)do
				var ^CTechTree.CNode pxResult=pxResultsNode^.GetSub(iI);
				var ^CTechTree.CNode pxResultFlags=pxResult^.GetSub("flags");
				var bool bLevelChecked=false;
				if(pxResultFlags!=null)then
					var int iLevel=pxResultFlags^.GetSubValueI("level")- 1;
					if(!bIsSupplyOn)then
						if(iLevel >=0)then
							bLevelFree=bLevelFree&&m_pxParent^.CheckCharacterConditions(iLevel);
						endif;
					else
						bLevelFree=bLevelFree&&m_pxParent^.CheckFreeSupplies(m_sTTPath);
					endif;
					if(bLevelFree==false)then
						break;
					endif;
					bLevelChecked=true;
				endif;
				if(bLevelFree &&(bLevelChecked==false))then
					var string sValue=pxResult^.GetValue();
					var ^CTechTree.CNode pxObjNode=xObjTT.FindNode(sValue);
					if(pxObjNode!=null)then
						var int iCaptainLevel=pxObjNode^.GetSubValueI("captainlevel",1)-1;
						if(iCaptainLevel >=0)then
							bLevelFree=bLevelFree&&m_pxParent^.CheckCharacterConditions(iCaptainLevel);
							if(!bLevelFree)then
								break;
							endif;
						endif;
					endif;
				endif;
			endfor;
		endif;
		var string sTooltipAdd;
		var bool bInvent=m_pxParent^.CheckInventConditions(m_sTTPath, sTooltipAdd, sObjTribe);
		//var bool bUnitRequirement=m_pxParent^.CheckUnitConditions(m_sTTPath, sTooltipAdd);
		var bool bMax;
		var int iCur, iMax=-1;
		var bool bBuild=m_pxParent^.CheckBuildConditions(m_sTTPath, sTooltipAdd, sObjTribe, bMax, iCur, iMax);
//		if(bMax)then
//			bBuild=true;
//		endif;
		m_iResNumPossible=m_pxParent^.CheckConditions(m_sTTPath,sTooltipAdd);
		m_pxParent^.GatherInfo(m_sTTPath,sTooltipAdd);
		var bool bCheck=m_iResNumPossible>0;
		var bool bAlreadyInventing=false;
		var bool bIsProcessing=false;
		var bool bCanBuildDown=(m_sTTPath.Find("Actions/Aje/Moves/BLDG/BuildDown")!=-1);
		var bool bCheckBuildDown=true;
		var bool bDoNotDisable=CMirageClnMgr.Get().ShouldNotBeDisabled(m_sTTPath);
		var ^CAttribs pxObjAttribs=pxObj^.GetAttribs();
		if(m_xCategory=="PROD"||m_xCategory=="UPGR"||bCanBuildDown||bDoNotDisable)then
			var ^CProgressButton pxButton=cast<CProgressButton>(m_pxButton);
			if(pxButton!=null)then
				bIsProcessing=pxButton^.IsProcessing(m_pxParent^.m_xOldSelection);
			endif;
		endif;
		var string sTooltip=m_sTooltipTitle+"   \n";
		if(bLevelFree==false)then
			sTooltip +=CLocalizer.Get().Translate("_ObjCommandBar_UnitLevelReached")+"\\{br}";
		elseif(bMax)then
			sTooltip+=CLocalizer.Get().Translate("_MI_BuildingMaxReached")+"\\{br}";
		else
//			if(m_sTooltipText.IsEmpty()==false)then
//				sTooltip +=m_sTooltipText+"   \n";
//			endif;
		endif;
		if(iMax>=0)then
			sTooltip+=CLocalizer.Get().Translate("_MI_BuildingQuantity")+iCur.ToString()+"/"+iMax.ToString()+"\\{br}";
		endif;
		if(m_sTooltipText.IsEmpty()==false)then
			sTooltip +=m_sTooltipText+"   \n";
		endif;
		if(bCanBuildDown &&(pxObjAttribs!=null)&&(pxObjAttribs^.GetValue("CurTask")=="BuildUpB"||pxObjAttribs^.GetValueInt("ReadyForWork")==0))then
			bCheckBuildDown=false;
		endif;
		// Der untenstende Block findet heraus ob ein Upgrade schon läuft
		if((m_sTTPath.Find("Upgrades")!=-1)&&(pxObjAttribs!=null))then
			var string sCurProcessObj=pxObjAttribs^.GetValue("CurProcessObj");
			if(sCurProcessObj!=m_sTTPath)then
				var ^CTechTree.CNode pxTTNode=xObjTT.FindNode(m_sTTPath);
				if(pxTTNode!=null)then
					var int iIndex=pxTTNode^.GetHashValue();
					var string sUID=iIndex.ToString();
					var ^CPlayer pxPlayer=^(CGameWrap.GetClient().GetPlayer());
					if(pxPlayer!=null)then
						var ^CAttribs pxPlayerAttribs=pxPlayer^.GetAttribs();
						if(pxPlayerAttribs!=null)then
							var int iPos=m_sTTPath.FindRev('/');
							var string sClass=m_sTTPath.Mid(iPos+1);
							sClass=xObjTT.GetValueS(m_sTTPath+"/full_name",sClass);
							var ^CTechTree.CNode pxSubNode=xObjTT.FindNode(m_sTTPath+"/results/0");
							if(pxSubNode!=null)then
								if(pxSubNode^.GetSubValue("class")=="player")then
									var string sInventions=pxPlayerAttribs^.GetValue("inventions_in_progress");
									if((sInventions.Find(sClass)!=-1)&&(bIsProcessing==false))then
										sTooltipAdd=CLocalizer.Get().Translate("_ObjCommandBar_AlreadyInventing");
										bAlreadyInventing=true;
									endif;
								endif;
							endif;
						endif;
					endif;
				endif;
			endif;
		endif;
		sTooltip +=sTooltipAdd;
		var string sLocation=xObjTT.GetValueS(m_sTTPath+"/locations/"+m_iLocationIndex.ToString(), "");
		var int iMinLevel=xObjTT.GetValueI(m_sTTPath+"/conditions/level", 1)- 1;
		var bool bLevelTooHigh=false;
		if(iMinLevel > 0)then
			bLevelTooHigh=true;
			var string sClass="";
			var string sType="";
			var int iPos=sLocation.FindRev('/');
			//	Hier versuchen wir den Classname oder ObjType rauszufinden, alles was vier Zeichen lang ist, wird als ObjType interpretiert
			if(iPos!=-1)then
				sClass=sLocation.Mid(iPos+1);
				if(sClass.GetLength()==4)then
					sType=sClass;
					sClass="";
				endif;
			endif;
			var int iI, iC=xObjList.NumEntries();
			for(iI=0)cond(iI<iC)iter(++iI)do
				var ^CObj pxObjListObj=xObjList[iI].GetObj();
				if(pxObjListObj==null)then
					continue;
				endif;
				if((sType.IsEmpty()&&(pxObjListObj^.GetClassName()==sClass))||(sClass.IsEmpty()&&(pxObjListObj^.GetType()==sType)))then
					var ^CAttribs pxObjListObjAttribs=pxObjListObj^.GetAttribs();
					if(pxObjListObjAttribs==null)then
						continue;
					endif;
					var int iCurLevel=pxObjListObjAttribs^.GetValueInt("level");
					var string sPassengers=pxObjListObjAttribs^.GetValue("passenger_guids");
					if(sPassengers.IsEmpty()==false)then
						var int iCaptainIdx=pxObjListObjAttribs^.GetValueInt("captain");
						var array string asPassengers;
						sPassengers.Split(asPassengers, "\n", true);
						if((iCaptainIdx >=0)&&(iCaptainIdx<asPassengers.NumEntries()))then
							var CGuid xCaptainGUID;
							xCaptainGUID.FromString(asPassengers[ iCaptainIdx ]);
							var ^CObj pxCaptain=CClientWrap.GetObjMgr().GetObj(xCaptainGUID);
							if(pxCaptain!=null)then
								var ^CAttribs pxCaptainAttribs=pxCaptain^.GetAttribs();
								if(pxCaptainAttribs!=null)then
									iCurLevel=pxCaptainAttribs^.GetValueInt("level");
								endif;
							endif;
						endif;
					endif;
					if(iCurLevel >=iMinLevel)then
						bLevelTooHigh=false;
						break;
					endif;
				endif;
			endfor;
		endif;
		if(bLevelTooHigh)then
			sTooltip +="\n"+CLocalizer.Get().Translate("_ObjCommandBar_RequiresLevel")+(iMinLevel+1).ToString()+ " ";
		endif;
		//Henry: disable action icon(will be gray)if the action has a mana cost and the user doesn't have the needed mana amount
		var bool bEnoughMana=true;
		//var string sManaRequirement="";
		var int iReqMana=0;
		var ^CTechTree.CNode pxMana=xObjTT.FindNode(m_sTTPath+"/manacosts");
		if(CMirageClnMgr.Get().ManaEnabled()&& pxMana!=null)then
			if(pxMana^.GetValueI()>0)then
				iReqMana=pxMana^.GetValueI();
				if(m_pxParent!=null)then
					m_pxParent^.CheckMana(m_sTTPath,sTooltip);
				endif;
				//sManaRequirement=iReqMana.ToString();
				//sTooltip +="\n"+CLocalizer.Get().Translate("_MI_ManaRequirement_1")+sManaRequirement+CLocalizer.Get().Translate("_MI_ManaRequirement_2");
			endif;
		endif;
		if(iReqMana>0)then
			bEnoughMana=false;
			var int iM, iCM=xObjList.NumEntries();
			for(iM=0)cond(iM<iCM)iter(++iM)do
				var ^CObj pxObjListObjM=xObjList[iM].GetObj();
				if(pxObjListObjM==null)then
					continue;
				endif;
				var ^CAttribs pxObjListObjAttribsM=pxObjListObjM^.GetAttribs();
				if(pxObjListObjAttribsM==null)then
					continue;
				endif;
				var int iCurEnergy=pxObjListObjAttribsM^.GetValueInt("energystate");
				if(iCurEnergy>=iReqMana)then
					bEnoughMana=true;
					break;
				endif;
			endfor;
		endif;
		//m_bDisabled=(!bInvent||!bBuild||!bUnitRequirement||!bCheck||!bLevelFree||bAlreadyInventing||bLevelTooHigh||!bCheckBuildDown)&& !bIsProcessing;
		var bool bMoreMana=(!bEnoughMana);
		m_bDisabled=(!bInvent||!bBuild||!bCheck||!bLevelFree||bAlreadyInventing||bLevelTooHigh||!bCheckBuildDown)&& !bIsProcessing;
		if(m_pxButton!=null)then
			if(bMoreMana)then
				//sTooltip +="\n"+CLocalizer.Get().Translate("_MI_ManaRequirement_1")+sManaRequirement+CLocalizer.Get().Translate("_MI_ManaRequirement_2");
				//sTooltip +="\n"+CLocalizer.Get().Translate("_MI_ManaRequirement_3");
				m_pxButton^.SetDisabled(bMoreMana);
				m_pxButton^.SetToolTipText(sTooltip);
				m_pxButton^.GetStaticCtrl().SetTextRaw(m_sTooltipKey);
			else
				m_pxButton^.SetDisabled(m_bDisabled);
				m_pxButton^.SetToolTipText(sTooltip);
				m_pxButton^.GetStaticCtrl().SetTextRaw(m_sTooltipKey);
			endif;
		endif;
	endproc;

	export proc void ShowAccelerator(bool p_bVisible)
		if(m_pxAccelerator!=null)then
			m_pxAccelerator^.SetVisible(p_bVisible);
		endif;
	endproc;

	export proc bool IsProcessing()
		var ^CProgressButton pxButton=cast<CProgressButton>(m_pxButton);
		if(pxButton!=null)then
			return(pxButton^.IsProcessing(m_pxParent^.m_xOldSelection));
		endif;
		return(false);
	endproc;

	export proc void Initialize(string p_sCategory, int p_iType, ^CCommandBar p_pxParent, string p_sCommand, string p_sTTPath)
		var CTechTree xTT=p_pxParent^.GetCurTechTree();
		Initialize(p_sCategory, p_iType, p_pxParent, p_sCommand, p_sTTPath, -1, xTT);
	endproc;

	export proc void Initialize(string p_sCategory, int p_iType, ^CCommandBar p_pxParent, string p_sCommand, string p_sTTPath, int p_iLocationIndex)
		var CTechTree xTT=p_pxParent^.GetCurTechTree();
		Initialize(p_sCategory, p_iType, p_pxParent, p_sCommand, p_sTTPath, p_iLocationIndex, xTT);
	endproc;

	proc ^CObj GetFirstSelectionObject(bool p_bIncludeActionMenu)
		if(p_bIncludeActionMenu &&(m_pxParent!=null)&&(m_pxParent^.GetActionMenu()!=null))then
			var CClntHndl xTemp=m_pxParent^.GetActionMenu()^.GetSelObj();
			if(xTemp.IsValid())then
				return xTemp.GetObj();
//				var CObjList xObjList;
//				xObjList.Include(xTemp);
//				return(xObjList[0].GetObj());
			endif;
		endif;
		//var CObjList xObjList=CClientWrap.GetSelection();
		var CObjList xObjList=CMirageClnMgr.Get().GetFocusList(CClientWrap.GetSelection(),true);
		if(xObjList.NumEntries()> 0)then
			return(xObjList[0].GetObj());
		endif;
		return(null);
	endproc;

	proc string GetTypeAsString(int p_iType)
		if(p_iType==TYPE_INVALID)then
			return("TYPE_INVALID");
		elseif(p_iType==TYPE_END_PIECE)then
			return("TYPE_END_PIECE");
		elseif(p_iType==TYPE_FLYOUT_BTN)then
			return("TYPE_FLYOUT_BTN");
		elseif(p_iType==TYPE_ACTION_BTN)then
			return("TYPE_ACTION_BTN");
		elseif(p_iType==TYPE_MENUCMD_BTN)then
			return("TYPE_MENUCMD_BTN");
		else
			return("!!!UNKNOWN!!!");
		endif;
	endproc;
	
	export proc void Initialize(string p_sCategory, int p_iType, ^CCommandBar p_pxParent, string p_sCommand, string p_sTTPath, int p_iLocationIndex, CTechTree p_xTT)
		if((m_xCategory==p_sCategory)&&
			(p_iType==m_iType)&&
			(p_pxParent==m_pxParent)&&
			(p_sCommand==m_sCommand)&&
			(m_sTTPath==p_sTTPath))then
				return;
		endif;
		if(m_pxButton!=null)then
			var ^CWindow pxParent=m_pxButton^.GetParentWindow();
			if(pxParent!=null)then
				pxParent^.RemoveChild(m_pxButton);
			endif;
		endif;
		if(m_pxStatic!=null)then
			var ^CWindow pxParent=m_pxStatic^.GetParentWindow();
			if(pxParent!=null)then
				pxParent^.RemoveChild(m_pxStatic);
			endif;
		endif;
		SetShortName(p_sTTPath);
		m_xCategory =p_sCategory;
		m_iType =p_iType;
		m_pxParent =p_pxParent;
		m_sCommand =p_sCommand;
		m_sTTPath =p_sTTPath;
		m_sCode=m_pxParent^.GetCode(p_xTT, p_sTTPath, m_bPersonal, m_sSkillTribe);
		if(m_sCode=="")then
			m_sCode=m_sShortName;
		endif;
		m_iLocationIndex=-1;
		if((m_iType==TYPE_LEFT_SPACER)||(m_iType==TYPE_END_PIECE))then
			InitializeSpacer();
		elseif((m_iType==TYPE_FLYOUT_BTN)||(m_iType==TYPE_ACTION_BTN))then
			InitializeMenuOrActionButton();
		elseif((m_iType==TYPE_MENUCMD_BTN))then
			InitializeFlyoutButton(p_sCategory, p_iLocationIndex);
		endif;
	endproc;
	
	proc void InitializeSpacer()
		if(m_pxButton!=null)then
			m_pxButton^.Destroy();
			m_pxButton=null;
		endif;
		if(m_pxStatic==null)then
			m_pxStatic=new CStaticCtrl();
		endif;
		var ^CCardBitmap pxBitmap;
		if(m_iType==TYPE_LEFT_SPACER)then
			pxBitmap=CGameInst.GetBitmapMgr().GetBlendBitmap("22, layer menubtn_back_leftspacer");
			m_pxStatic^.SetSize(7, 59);
		else
			pxBitmap=CGameInst.GetBitmapMgr().GetBlendBitmap("21, layer actbtn_back_endpiece");
			m_pxStatic^.SetSize(45, 59);
		endif;
		m_pxStatic^.SetTransparent(true);
		m_pxStatic^.SetVisible(true);
		m_pxStatic^.SetSuitAlpha(false);
		m_pxStatic^.SetDisabled(false);
		m_pxStatic^.EnableMsgHitTest(false);
		m_pxStatic^.SetBitmap(pxBitmap^.GetBitmap());
		m_pxParent^.GetIngameScreen()^.AddChild(m_pxStatic);
	endproc;
	
	proc void InitializeMenuOrActionButton()
		if(m_pxStatic!=null)then
			m_pxStatic^.Destroy();
			m_pxStatic=null;
		endif;
		if(cast<CProgressButton>(m_pxButton)!=null)then
			m_pxButton^.Destroy();
			m_pxButton=null;
		endif;
		if(m_pxButton==null)then
			m_pxButton=new CCmdBarButton();
		endif;
		var string sBaseDef, sAdd;
		var ^CObj pxObj=GetFirstSelectionObject(true);
		var ^CAttribs pxObjAttribs;
		var CTechTree xObjTT;
		var ^CTechTree.CNode pxOwnNode;
		var bool bSelected=false;
		if(pxObj!=null)then
			pxObjAttribs=pxObj^.GetAttribs();
			xObjTT=pxObj^.GetTechTree();
			pxOwnNode=xObjTT.FindNode(m_sTTPath);
		endif;
		if(m_iType==TYPE_FLYOUT_BTN)then
			sBaseDef ="20, layer menubtn_back_";
			sAdd =", layer menubtn_sym_"+m_sCommand;
			m_pxButton^.SetSize(53, 59);
		else
			sBaseDef ="21, layer actbtn_back_";
			sAdd =", layer actbtn_sym_"+m_sCommand;
			m_pxButton^.SetSize(45, 59);
			if(pxObj!=null)then
				if((pxOwnNode!=null)&&(pxOwnNode^.GetSub("secondarycontroller")!=null))then
					m_bSecondaryInputControl=true;
				elseif((m_sTTPath.Find("/NoSecInp")==-1)&&((m_sTTPath.Find("/DismountAll")!=-1)||(m_sTTPath.Find("/Repair")!=-1)))then
					m_bSecondaryInputControl=true;
				endif;
			endif;
		endif;
		if((m_sCommand=="stance"))then
			if(pxObj!=null)then
				if(pxObjAttribs!=null)then
					sAdd +="_"+pxObjAttribs^.GetValueInt("AggressionState").ToString();
				else
					sAdd="";
				endif;
			else
				sAdd +="_2";
			endif;
		elseif(m_sCommand=="gtopen"||m_sCommand=="gtclose"||m_sCommand=="gtauto")then
			var int iButton=-1;
			if(m_sCommand=="gtopen")then
				iButton=0;
			elseif(m_sCommand=="gtclose")then
				iButton=1;
			elseif(m_sCommand=="gtauto")then
				iButton=2;
			endif;
			if(pxObj!=null)then
//L				KLog.LogInfo("DaHo", "  "+pxObj^.GetName());
				if(pxObjAttribs!=null)then
					var int iGateState=pxObjAttribs^.GetValueInt("GateState");
//L					KLog.LogInfo("DaHo", "  iGateState="+iGateState.ToString());
//L					KLog.LogInfo("DaHo", "  iButton="+iButton.ToString());
					if(iGateState==iButton)then
						bSelected=true;
					endif;
				endif;
			endif;
		elseif(m_sCommand.IsEmpty())then
			sAdd="";
		endif;
		m_pxIdle=CGameInst.GetBitmapMgr().GetBlendBitmap(sBaseDef+"idle"+sAdd);
		m_pxDown=CGameInst.GetBitmapMgr().GetBlendBitmap(sBaseDef+"down"+sAdd);
		m_pxHovered=CGameInst.GetBitmapMgr().GetBlendBitmap(sBaseDef+"hover"+sAdd);
		if(m_iType==TYPE_FLYOUT_BTN)then
			m_pxDisabled=CGameInst.GetBitmapMgr().GetBlendBitmap(sBaseDef+"empty"+sAdd);
		else
			m_pxDisabled=CGameInst.GetBitmapMgr().GetBlendBitmap(sBaseDef+"idle"+sAdd+", saturate 40");
		endif;
		m_pxButton^.SetFrame(false);
		m_pxButton^.SetTransparent(true);
		m_pxButton^.SetVisible(true);
		m_pxButton^.SetSuitAlpha(true);
		m_pxButton^.SetDisabled(false);
		m_pxButton^.SetBackground(true);
		m_pxButton^.EnableMsgHitTest(true);
		m_pxButton^.SetBitmap(m_pxIdle^.GetBitmap(), m_pxDown^.GetBitmap(), m_pxHovered^.GetBitmap(), m_pxDisabled^.GetBitmap());
		m_pxParent^.GetIngameScreen()^.AddChild(m_pxButton);
		m_pxButton^.m_xOnClick=OnClick;
		begin Accelerator;
			if(m_pxAccelerator==null)then
				m_pxAccelerator=new CStaticCtrl();
				m_pxButton^.AddChild(m_pxAccelerator);
				m_pxAccelerator^.SetTextColor({{255, 0, 0, 255}});
				m_pxAccelerator^.SetSize(37*CGameInst.ms_iUIScaleFactor, 36*CGameInst.ms_iUIScaleFactor);
				m_pxAccelerator^.SetText("");
				m_pxAccelerator^.SetPos(20*CGameInst.ms_iUIScaleFactor, -5*CGameInst.ms_iUIScaleFactor);
//				m_pxAccelerator^.SetFontByInt(14);
				ShowAccelerator(m_pxParent^.IsAccelActive());
			endif;
			var string sCode=GetCommand();
			if(CShortcutMgr.Get().FindKeyByAction(sCode, m_sAssignedKey))then
				m_pxAccelerator^.SetText(m_sAssignedKey);
			else
				m_pxAccelerator^.SetText("");
			endif;
			m_pxAccelerator^.OnUpdateContent();
		end Accelerator;
		if(bSelected)then
			SetButtonSelected(true);
		endif;
	endproc;

	proc void InitializeFlyoutButton(string p_sCategory, int p_iLocationIndex)
		if(m_pxStatic!=null)then
			m_pxStatic^.Destroy();
			m_pxStatic=null;
		endif;
		var ^CObj pxObj=GetFirstSelectionObject(false);
		var ^CAttribs pxObjAttribs;
		var CTechTree xObjTT;
		var ^CTechTree.CNode pxOwnNode;
		if(pxObj==null)then return; endif;
		pxObjAttribs=pxObj^.GetAttribs();
		xObjTT=pxObj^.GetTechTree();
//		pxOwnNode=xObjTT.FindNode(m_sTTPath);
		var CClntHndl xValidObj;
		pxOwnNode=m_pxParent^.FindNodeAtFocus(m_sTTPath, xObjTT, xValidObj);
		if(xValidObj.IsValid())then
			pxObj=xValidObj.GetObj();
		endif;
//		if(m_pxButton==null)then
//		else
//		endif;
		if((m_xCategory=="PROD")||(m_xCategory=="SPEC"))then
			if((cast<CProgressButton>(m_pxButton)==null)&&(m_pxButton!=null))then
				m_pxButton^.Destroy();
				m_pxButton=null;
//				m_pxButton=new CProgressButton(pxObj^.GetHandle(), m_sTTPath);
				m_pxButton=new CProgressButton(m_pxParent^.m_xOldSelection, pxObj^.GetHandle(), m_sTTPath);
			elseif(m_pxButton==null)then
//				m_pxButton=new CProgressButton(pxObj^.GetHandle(), m_sTTPath);
				m_pxButton=new CProgressButton(m_pxParent^.m_xOldSelection, pxObj^.GetHandle(), m_sTTPath);
			endif;
		else
			if((cast<CProgressButton>(m_pxButton)!=null))then
				m_pxButton^.Destroy();
				m_pxButton=null;
				m_pxButton=new CCmdBarButton();
			elseif(m_pxButton==null)then
				m_pxButton=new CCmdBarButton();
			endif;
		endif;
//		if(m_pxButton==null)then
//		else
//		endif;
		m_pxButton^.SetFrame(false);
		m_pxButton^.SetSize(37, 36);
		m_pxButton^.SetVisible(true);
		m_pxButton^.SetSuitAlpha(true);
		m_pxButton^.SetTransparent(false);
		m_pxButton^.EnableMsgHitTest(true);
		m_pxButton^.m_xOnClick=OnClick;
		m_pxButton^.m_xOnRightClick=OnRightClick;
		var string
			sBaseDef="2, layer menucmd_back",
			sLayer=", layer menucmd_over_",
			sAdd="",
			sIconPath="",
			sCategory=p_sCategory,
			sSubCategory="";
		if(m_pxAccelerator==null)then
			m_pxAccelerator=new CStaticCtrl();
			m_pxButton^.AddChild(m_pxAccelerator);
			m_pxAccelerator^.SetTextColor({{255, 223, 15, 255}});
			m_pxAccelerator^.SetSize(37*CGameInst.ms_iUIScaleFactor, 36*CGameInst.ms_iUIScaleFactor);
//			m_pxAccelerator^.SetVisible(false);
			//m_pxAccelerator^.SetTextOutline(true);
//			m_pxAccelerator^.SetText("");
			var string sCode=GetCode();
			if(CShortcutMgr.Get().FindKeyByAction(sCode, m_sAssignedKey))then
				m_pxAccelerator^.SetText(m_sAssignedKey);
			else
				m_pxAccelerator^.SetText("");
			endif;
			m_pxAccelerator^.OnUpdateContent();
			m_pxAccelerator^.SetPos(12*CGameInst.ms_iUIScaleFactor, -10*CGameInst.ms_iUIScaleFactor);
			ShowAccelerator(m_pxParent^.IsAccelActive());
		endif;
		if(pxOwnNode==null)then
			return;
		endif;
		if(m_sTTPath.Find("Objects/")!=-1)then
			var array string asTokens;
			m_sCommand.Split(asTokens, "|", true);
			if(asTokens.NumEntries()< 3)then
				return;
			endif;
			m_sCommand=asTokens[0];
			sSubCategory=asTokens[1];
			m_sAdditionalInfo=asTokens[1]+"|"+asTokens[2];
			var CGuid  xGuid;
			xGuid.FromString(asTokens[2]);
			var ^CObj pxPassenger=CGameWrap.GetObjMgr().GetObj(xGuid);
			if(pxPassenger!=null)then
				var CTechTree xPassengerTT=pxPassenger^.GetTechTree();
				sIconPath=xPassengerTT.GetValueS(m_sTTPath+"/description", "");
			endif;
			if(sIconPath!=""&&sIconPath.GetAt(0)=='_')then
				sIconPath.Delete(0);
				if(CGameInst.GetBitmapMgr().BlendSourceExists(sIconPath))then
					sAdd=", layer "+sIconPath;
				endif;
			else
				m_sTTPath.Split(asTokens, "/", true);
				if(asTokens.NumEntries()> 0)then
					sIconPath=asTokens[ asTokens.NumEntries()- 1 ];
					if(CGameInst.GetBitmapMgr().BlendSourceExists(sIconPath))then
						sAdd=", layer "+sIconPath;
					endif;
				endif;
			endif;
			m_iPositionIndex=-1;
		else
			m_bSecondaryInputControl=(pxOwnNode^.GetSubValueI("secondarycontroller", 0)==1);
			var ^CTechTree.CNode pxLocations=pxOwnNode^.GetSub("locations");
			if(pxLocations!=null)then
				var int iI, iS=p_iLocationIndex,
				iC=pxLocations^.NumSubs();
				if(iS<0)then
					iS=0;
				endif;
				for(iI=iS)cond(iI<iC)iter(++iI)do
					var ^CTechTree.CNode pxLocation=pxLocations^.GetSub(iI);
					if(pxLocation==null)then
						continue;
					endif;
					if((p_iLocationIndex >=0)&&(p_iLocationIndex!=iI))then
						continue;
					endif;
					var string sVal=pxLocation^.GetValue();
					var int iPos=sVal.FindRev('/');
					if(iPos!=-1)then
						sVal=sVal.Mid(iPos+1);
						if((p_iLocationIndex<0)&&(sVal!=pxObj^.GetClassName())&&(pxObj^.GetType()!=sVal))then
							continue;
						endif;
					endif;
					sIconPath=pxLocation^.GetSubValue("iconpath", "");
					m_iLocationIndex=iI;
					if(sIconPath.IsEmpty()==false)then
						sAdd=", layer "+sIconPath;
					endif;
					var ^CTechTree.CNode pxUIPosition=pxLocation^.GetSub("uiposition");
					if(pxUIPosition!=null)then
						sCategory=pxUIPosition^.GetSubValue("cat", "");
						sSubCategory=pxUIPosition^.GetSubValue("subcat", "");
						m_iPositionIndex=pxUIPosition^.GetSubValueI("menupos", 0);
						if(m_iPositionIndex!=-1)then
//							if((m_iPositionIndex+1)==10)then
//								m_pxAccelerator^.SetText("0");
//							elseif(m_iPositionIndex+1>10)then // only show 10 accelerator description (problem: different keyboard layouts)
//								m_pxAccelerator^.SetText("");
//							else
//								m_pxAccelerator^.SetText((m_iPositionIndex+1).ToString());
//							endif;
							var string sCode=GetCode();
							if(CShortcutMgr.Get().FindKeyByAction(sCode, m_sAssignedKey))then
								m_pxAccelerator^.SetText(m_sAssignedKey);
								ShowAccelerator(m_pxParent^.IsAccelActive());
							else
								m_pxAccelerator^.SetText("");
							endif;
							m_pxAccelerator^.OnUpdateContent();
						else
							m_pxAccelerator^.SetText("");
							//m_pxAccelerator^.SetTextAlign(2, 2);
							m_pxAccelerator^.OnUpdateContent();
						endif;
					endif;
				endfor;
			endif;
		endif;
		if((sCategory=="SLOT")&&(sSubCategory==""))then
			var array string asTokens;
			m_sCommand.Split(asTokens, "|", true);
			if(asTokens[0]=="/Unboard"&&asTokens[2]=="none")then
				sSubCategory=asTokens[1];
			endif;
		endif;
		if(sCategory=="UPGR")then
			sBaseDef +="_UPGR";
		endif;
		if((CGameInst.GetBitmapMgr().BlendSourceExists(sIconPath)==false)&&(CGameInst.GetBitmapMgr().BlendSourceExists("actmenu_"+sIconPath)==false))then
			sAdd="";
		endif;
		sBaseDef +=sAdd;
		Validate();
		var string sLevelLayer="";
		var ^CTechTree.CNode pxResultsNode=pxOwnNode^.GetSub("results");
		var int iLevel=0;
		if((pxResultsNode!=null)&&(pxResultsNode^.NumSubs()> 0))then
			var ^CTechTree.CNode pxFlags=pxResultsNode^.GetSub(0)^.GetSub("flags");
			if(pxFlags!=null)then
				iLevel=pxFlags^.GetSubValueI("level", 0);
			endif;
			if(iLevel <=0)then
				var ^CTechTree.CNode pxObjNode=xObjTT.FindNode(pxResultsNode^.GetSub(0)^.GetValue());
				if(pxObjNode!=null)then
					iLevel=pxObjNode^.GetSubValueI("captainlevel");
				endif;
			endif;
			if(iLevel > 0)then
				sLevelLayer=", layer menucmd_lvl"+iLevel.ToString()+ "_ovl";
			endif;
		endif;
		sBaseDef +=sLevelLayer;
		m_pxIdle =CGameInst.GetBitmapMgr().GetBlendBitmap(sBaseDef+sLayer+"idle");
		m_pxDown =CGameInst.GetBitmapMgr().GetBlendBitmap(sBaseDef+sLayer+"down");
		m_pxHovered =CGameInst.GetBitmapMgr().GetBlendBitmap(sBaseDef+sLayer+"hover");
		m_pxDisabled =CGameInst.GetBitmapMgr().GetBlendBitmap(sBaseDef+",add -20 -20 -20 0"+sLayer+"idle, saturate 20, add -20 -20 -20 0");
		m_pxFlash =CGameInst.GetBitmapMgr().GetBlendBitmap(sBaseDef+",add +20 +20 +20 0"+sLayer+"idle, saturate 20, add +20 +20 +20 0");
		if(m_pxIdle==null)then return; endif;
		if(m_pxDown==null)then return; endif;
		if(m_pxHovered==null)then return; endif;
		if(m_pxDisabled==null)then return; endif;
		if(m_pxFlash==null)then return; endif;
		if(cast<CProgressButton>(m_pxButton)!=null)then
			cast<CProgressButton>(m_pxButton)^.Initialize(sIconPath, iLevel);
			cast<CProgressButton>(m_pxButton)^.SetBitmaps(m_pxIdle, m_pxDown, m_pxHovered, m_pxDisabled,m_pxFlash);
		else
			m_pxButton^.SetBitmap(m_pxIdle^.GetBitmap(), m_pxDown^.GetBitmap(), m_pxHovered^.GetBitmap(), m_pxDisabled^.GetBitmap());
		endif;
		m_pxParent^.GetFlyoutWindow()^.SetCommand(sCategory, sSubCategory, this);
	endproc;

	proc bool OnRightClick()
		if(!CGameWrap.GetClient().HasValidPlayerSlot())then return false; endif; //spectator
		if((m_xCategory=="BUIL")||(m_xCategory=="PROD")||CMirageClnMgr.Get().IsCancableAction(m_sTTPath))then
//			var CObjList xObjList=CClientWrap.GetSelection();
			var CObjList xObjList=CMirageClnMgr.Get().GetFocusList(CClientWrap.GetSelection());
			var CClntHndl xObj;
			var string sPrefix="";
//			var bool bShifted=false;
//			if((CMainController.Get().GetKeyFlags()&Msg.KM_SHIFT)!=0d)then
//				bShifted=true;
//				sPrefix="S_";
//			endif;
			var bool bShifted=(CMainController.Get().GetKeyFlags()&Msg.KM_SHIFT)!=0d;
			var bool bOldCommandSystem=(CCommandBar.ms_bNewCommandSystem&&bShifted)||(!CCommandBar.ms_bNewCommandSystem&&!bShifted);
	//		if((CMainController.Get().GetKeyFlags()&Msg.KM_SHIFT)!=0d)then
	//			bShifted=true;
	//			sPrefix="S_";
	//		endif;
			if(bOldCommandSystem)then
				sPrefix="S_";
			endif;
			var array string asGuidList;
			if(!m_bPersonal||bOldCommandSystem)then
				CEvt_GamePlayCommand.Send(xObjList, sPrefix+"Cancel", xObj, {0.0,0.0,0.0}, m_sTTPath);
			else
				var CObjList xPersonal=CCommandBar.SortRevByQueue(xObjList);
				if(xPersonal.NumEntries()>0&&xPersonal[0].IsValid())then
					var string sG;
					CEvt_GamePlayCommand.Send(xPersonal[0], "Cancel", xObj, {0.0,0.0,0.0}, m_sTTPath);
				endif;
			endif;
		endif;
		CWindowMgr.Get().BringWindowToTop(CClientWrap.GetDesktop(), true);
		return(true);
	endproc;

	export proc void SetPos(int p_iX, int p_iY)
//L		KLog.LogInfo("DaHo", "CCmdButton::SetPos("+p_iX.ToString()+ ", "+p_iY.ToString()+ ")");
		if(m_pxButton!=null)then
			m_pxButton^.SetPos(p_iX, p_iY);
		elseif(m_pxStatic!=null)then
			m_pxStatic^.SetPos(p_iX, p_iY);
		endif;
	endproc;

	export proc void SetDisabled(bool p_bDisabled)
		m_bDisabled=p_bDisabled;
		if((m_pxButton!=null)&&((cast<CProgressButton>(m_pxButton)==null)||(cast<CProgressButton>(m_pxButton)^.IsProcessing(m_pxParent^.m_xOldSelection)==false)))then
			m_pxButton^.SetDisabled(m_bDisabled);
		endif;
		if(m_pxStatic!=null)then
			m_pxStatic^.SetDisabled(m_bDisabled);
		endif;
		if(m_pxAccelerator!=null)then
			m_pxAccelerator^.SetDisabled(m_bDisabled);
		endif;
	endproc;

	export proc bool IsDisabled()
		return m_bDisabled;
	endproc;

	export proc bool GetDisabled()
		if(m_pxButton!=null)then
			return m_pxButton^.GetDisabled();
		endif;
		return m_bDisabled;
//		return false;
	endproc;

	export proc bool GetVisible()
		if(m_pxButton!=null)then
			return m_pxButton^.GetVisible();
		endif;
		return true;
	endproc;

	export proc bool IsDenied()
		return m_bDeny;
	endproc;

	export proc void SetButtonSelected(bool p_bSelected)
		if(m_pxButton!=null)then
			if(p_bSelected)then
				m_pxButton^.SetBitmap(m_pxDown^.GetBitmap(), m_pxDown^.GetBitmap(), m_pxDown^.GetBitmap(), m_pxDisabled^.GetBitmap());
			else
				m_pxButton^.SetBitmap(m_pxIdle^.GetBitmap(), m_pxDown^.GetBitmap(), m_pxHovered^.GetBitmap(), m_pxDisabled^.GetBitmap());
			endif;
			m_bSelected=p_bSelected;
		endif;
	endproc;

	export proc bool OnDoubleClick()
		return OnClick();
	endproc;

	export proc void SetText(string p_sText)
		if(m_pxButton!=null)then
			m_pxButton^.SetText(p_sText);
		endif;
	endproc;

	proc bool IsSpecialMove(^CTechTree p_pxTT, ref string p_rsCharacter, ref string p_rsAction)
		if(CMirageClnMgr.Get().IsCancableAction(m_sTTPath))then return(false); endif;
		var string sLocTTPath =m_sTTPath+"/locations/"+m_iLocationIndex.ToString();
		var ^CTechTree.CNode pxLocNode =p_pxTT^.FindNode(sLocTTPath);
		if(pxLocNode==null)then return(false); endif;
		var string sLocation =pxLocNode^.GetValue();
		var array string asTTPath;
		var array string asLocation;
		m_sTTPath.Split(asTTPath, "/", true);
		if((asTTPath.NumEntries()< 5)||(asTTPath[2]!="Moves"))then return(false); endif;
		sLocation.Split(asLocation, "/", true);
		if(asLocation.NumEntries()< 4)then return(false); endif;
		var ^CTechTree.CNode pxUINode =pxLocNode^.GetSub("uiposition");
		if(pxUINode==null)then return(false); endif;
		if(pxUINode^.GetSubValue("cat", "")!="SPEC")then return(false); endif;
		p_rsCharacter =asLocation[3];
		p_rsAction=asTTPath[4];
		return(true);
	endproc;

	export proc bool OnClick()
		if(m_iType!=TYPE_FLYOUT_BTN&&!CGameWrap.GetClient().HasValidPlayerSlot())then return false; endif; //spectator
		if(m_bDeny)then return false; endif;
		if((m_sCommand=="kill"||m_sTTPath=="/Kill")&&CGameInst.ms_bDisableDelete)then return false; endif;
		var ^CUTCmdSender pxUTCmdSender=CClientWrap.GetUTCmdSender();
		if((m_sTTPath.IsEmpty()==false)&&(pxUTCmdSender!=null))then
			pxUTCmdSender^.OnClickCmdButton(m_sTTPath);
		endif;
		var CClntHndl xInvalid, xGPCE=CMirageClnMgr.Get().GetGPCE();
		var array string asGuidList;
		CWindowMgr.Get().BringWindowToTop(CClientWrap.GetDesktop(), true);
		if(m_bDisabled)then return(false); endif;
		var string sPrefix="";
		var bool bShifted=(CMainController.Get().GetKeyFlags()&Msg.KM_SHIFT)!=0d;
		var bool bCtrl=(CMainController.Get().GetKeyFlags()&Msg.KM_CONTROL)!=0d;
		var bool bOldCommandSystem=(CCommandBar.ms_bNewCommandSystem&&bShifted)||(!CCommandBar.ms_bNewCommandSystem&&!bShifted);
		var bool bStimpack=m_sTTPath.Find("stimpack")!=-1;
//		if((CMainController.Get().GetKeyFlags()&Msg.KM_SHIFT)!=0d)then
//			bShifted=true;
//			sPrefix="S_";
//		endif;
		if(bCtrl)then
			sPrefix="Q_";
		endif;
		if(bOldCommandSystem)then
			sPrefix+="S_";
		endif;
		var CObjList xAll=CClientWrap.GetSelection();
//		var CObjList xObjList=CMirageClnMgr.Get().GetFocusList(CClientWrap.GetSelection());
		var CObjList xObjList=CMirageClnMgr.Get().GetFocusList(xAll,true);
		if(xObjList.NumEntries()<=0)then return(false); endif;
		var ^CObj pxObj=xObjList[0].GetObj();
		if(pxObj==null)then return(false); endif;
		var bool bGeneral=m_sTTPath.Find("AggroState_")!=-1||m_sTTPath.Find("Stop")!=-1||m_sTTPath.Find("Walk")!=-1||m_sTTPath.Find("Attack")!=-1||m_sTTPath.Find("AggressiveTarget")!=-1||m_sTTPath.Find("/Deforest")!=-1||m_sTTPath.Find("/HuntAnimals")!=-1||m_sTTPath.Find("/Deforest")!=-1||m_sTTPath.Find("/EatSomethingFast")!=-1||m_sTTPath.Find("/ToggleLock")!=-1||m_sTTPath.Find("stimpack")!=-1;
		var string sObjTribe=m_pxParent^.GetObjTribe(pxObj);
		var string sObjPath=m_pxParent^.GetObjPath(pxObj);
		var CTechTree xObjTT=pxObj^.GetTechTree();
		var ^CTechTree.CNode pxOwnNode=xObjTT.FindNode(m_pxParent^.GetObjPath(pxObj));
		if(m_iType==TYPE_ACTION_BTN)then
			if(m_bSecondaryInputControl)then
				CMainController.Get().GetPlacer().Reset();
				CMainController.Get().SetSecondaryInputController(true);
				CMainController.Get().GetSecInputCtrl().SetCommand("Action");
				CMainController.Get().GetSecInputCtrl().SetTTPath(m_sTTPath);
			else
				if(m_sTTPath.Find("/RallyPoint")!=-1)then
					var string sRallyPoint=sObjTribe+"_Rally_Point";
					if(pxOwnNode^.GetSubValueI("coastal")==1)then
						sRallyPoint +="_harbour";
					endif;
					sRallyPoint.MakeLower();
					CMainController.Get().GetPlacer().SetClass("/Objects/"+sObjTribe+"/BLDG/"+sRallyPoint, "");
				elseif(m_sTTPath.Find("/LevelUp")!=-1)then
					var CClntHndl xObj;
					var CObjList xObjListBase=xAll;
//					var CObjList xObjListBase=xObjList;
					var CObjList xObjListSorted;
					while(xObjListBase.NumEntries()> 0)do
						var int iMinHP=999999;
						var int iIndex=-1;
						var int iI, iC=xObjListBase.NumEntries();
						for(iI=0)cond(iI<iC)iter(++iI)do
							var ^CObj pxO=xObjListBase[iI].GetObj();
							if(pxO==null)then continue; endif;
							var ^CAttribs pxA=pxO^.GetAttribs();
							if(pxA==null)then continue; endif;
							var int iHP=pxA^.GetValueInt("hitpoints");
							if(iHP<iMinHP)then
								iIndex=iI;
								iMinHP=iHP;
							endif;
						endfor;
						if(iIndex!=-1)then
							xObjListSorted.Include(xObjListBase[ iIndex ]);
							xObjListBase.DeleteEntry(iIndex);
						endif;
					endwhile;
					CEvt_GamePlayCommand.Send(xObjListSorted , sPrefix+"Action", xObj, {0.0,0.0,0.0}, m_sTTPath);
				else
					if(m_sCommand=="gtopen"||m_sCommand=="gtclose"||m_sCommand=="gtauto")then
						var ^CActionMenu pxActionMnu=m_pxParent^.GetActionMenu();
						if(pxActionMnu!=null)then
							var ^CCmdButton pxOpenBtn=pxActionMnu^.FindActionButton("gtopen");
							var ^CCmdButton pxCloseBtn=pxActionMnu^.FindActionButton("gtclose");
							var ^CCmdButton pxAutoBtn=pxActionMnu^.FindActionButton("gtauto");
							if(pxOpenBtn!=null&&pxCloseBtn!=null&&pxAutoBtn!=null)then
								var int iButton=-1;
								if(m_sCommand=="gtopen")then
									iButton=0;
								elseif(m_sCommand=="gtclose")then
									iButton=1;
								elseif(m_sCommand=="gtauto")then
									iButton=2;
								endif;
								pxOpenBtn^.SetButtonSelected(iButton==0);
								pxCloseBtn^.SetButtonSelected(iButton==1);
								pxAutoBtn^.SetButtonSelected(iButton==2);
							endif;
						endif;
					endif;
					var CClntHndl xObj;
					asGuidList=0;
					if(bGeneral)then
						CEvt_GamePlayCommand.Send(CCommandBar.SortByQueue(xAll), sPrefix+"Action", xObj, {0.0,0.0,0.0}, m_sTTPath);
					else
						CEvt_GamePlayCommand.Send(CCommandBar.SortByQueue(xObjList), sPrefix+"Action", xObj, {0.0,0.0,0.0}, m_sTTPath);
					endif;
				endif;
			endif;
		elseif(m_iType==TYPE_FLYOUT_BTN)then
			m_pxParent^.ToggleFlyoutWnd(m_xCategory);
			SetButtonSelected(m_pxParent^.GetFlyoutWindow()^.GetVisible());
		else
			CMainController.Get().SetSecondaryInputController(false);
			if(m_bSecondaryInputControl)then
				CMainController.Get().GetPlacer().Reset();
				CMainController.Get().SetSecondaryInputController(true);
				CMainController.Get().GetSecInputCtrl().SetCommand("Action");
				CMainController.Get().GetSecInputCtrl().SetTTPath(m_sTTPath);
			else
				if(m_xCategory=="STNC")then
					var string sBaseDef="20, layer menubtn_back_";
					var string sAdd=", layer menubtn_sym_";
					var ^CTechTree.CNode pxNode=xObjTT.FindNode(m_sTTPath+"/locations/"+m_iLocationIndex.ToString()+ "/iconpath");
					if(pxNode!=null)then
						if(pxNode^.GetValue().IsEmpty())then
							sAdd="";
						else
							sAdd +=pxNode^.GetValue();
						endif;
					endif;
					var ^CCmdButton pxBtn=m_pxParent^.GetActionMenu()^.GetMenuButton(m_xCategory);
					if(pxBtn!=null)then
						pxBtn^.m_pxIdle=CGameInst.GetBitmapMgr().GetBlendBitmap(sBaseDef+"idle"+sAdd);
						pxBtn^.m_pxDown=CGameInst.GetBitmapMgr().GetBlendBitmap(sBaseDef+"down"+sAdd);
						pxBtn^.m_pxHovered=CGameInst.GetBitmapMgr().GetBlendBitmap(sBaseDef+"hover"+sAdd);
						pxBtn^.m_pxDisabled=CGameInst.GetBitmapMgr().GetBlendBitmap(sBaseDef+"empty"+sAdd);
						if(pxBtn^.m_pxButton!=null)then
							pxBtn^.m_pxButton^.SetBitmap(pxBtn^.m_pxIdle^.GetBitmap(), pxBtn^.m_pxDown^.GetBitmap(), pxBtn^.m_pxHovered^.GetBitmap(), pxBtn^.m_pxDisabled^.GetBitmap());
						endif;
					endif;
				elseif(m_xCategory=="SLOT")then
					var array string asTokens;
					m_sAdditionalInfo.Split(asTokens, "|", true);
					if((asTokens.NumEntries()>=2)&&(m_sCommand=="/Unboard"))then
						var string sGuid=asTokens[1];
						var char cTransportType=asTokens[0].GetAt(0);
						var int iIndex=asTokens[0].GetAt(3).ToString().ToInt();
						var int iCount=0;
						var int iI, iC=xObjList.NumEntries();
						for(iI=0)cond(iI<iC)iter(++iI)do
							var ^CObj pxO=xObjList[iI].GetObj();
							if(pxO==null)then continue; endif;
							var CFourCC xType=pxO^.GetType();
							if(xType=="CHTR")then continue; endif;
							if(xType.AsString().GetAt(0)!=cTransportType)then continue; endif;
							if(iCount==iIndex)then
								var CGuid xGuid;
								xGuid.FromString(sGuid);
								var ^CObj pxPassenger=CGameWrap.GetObjMgr().GetObj(xGuid);
								if(pxPassenger!=null)then
									CEvt_GamePlayCommand.Send(xObjList[iI], sPrefix+"Action", pxPassenger^.GetHandle(), { 0.0, 0.0, 0.0 }, "/Dismount");
//									CEvt_GamePlayCommand.Send(xObjList[iI], "Action", pxPassenger^.GetHandle(), { 0.0, 0.0, 0.0 }, "/Dismount");
								endif;
								break;
							else
								if(++iCount > iIndex)then break; endif;
							endif;
						endfor;
					endif;
				endif;
				var string sLocation=xObjTT.GetValueS(m_sTTPath+"/locations/"+m_iLocationIndex.ToString(), "");
				if(sLocation.IsEmpty()==false)then
					var array string asTokens;
					var array string asTTPath;
					sLocation.Split(asTokens, "/", true);
					m_sTTPath.Split(asTTPath, "/", true);
					if((asTokens.NumEntries()>=3)&&(asTokens[2]=="CHTR"))then
						var string sClass;
						var int iJ=0;
						var string sResult=xObjTT.GetValueS(m_sTTPath+"/results/"+iJ.ToString(), "");
						while(sResult!="")do
							if(sResult.Left(8)=="/Objects")then
								sClass=sResult.Mid(sResult.FindRev('/')+ 1);
								break;
							endif;
							++iJ;
							sResult=xObjTT.GetValueS(m_sTTPath+"/results/"+iJ.ToString(), "");
						endwhile;
						if(sClass=="")then
							if(xObjList.NumEntries()>0)then
								var int im, iMC=xObjList.NumEntries();
								var bool bLocked=false, bMulti=iMC>1, bAllow;
								for(im=0)cond(im<iMC)iter(++im)do
									bAllow=CMirageClnMgr.Get().IsOkAndReadyForAction(m_sTTPath, xObjList[im], bLocked, bMulti);
									if((!bAllow && !bGeneral) || bLocked)then
										xObjList.DeleteEntry(im--); --iMC; continue;
									endif;
								endfor;
							endif;
							var int iUnits=xObjList.NumEntries();
							if(iUnits<=0)then return false; endif;
							//var bool bCtrl=((p_dwFlags&Msg.KM_CONTROL)!=0d);
							//var bool bShift=((p_dwFlags&Msg.KM_SHIFT)!=0d);
							//var bool bAlt=((p_dwFlags&Msg.KM_ALT)!=0d);
							var CClntHndl xObj;
							if(bStimpack||!m_bPersonal||bOldCommandSystem||xObjList.NumEntries()<2||!xGPCE.IsValid())then
								asGuidList=0;
								if(bGeneral)then
									CEvt_GamePlayCommand.Send(CCommandBar.SortByQueue(xAll), sPrefix+"Action", xObj, { 0.0, 0.0, 0.0 }, m_sTTPath);
								else
									CEvt_GamePlayCommand.Send(CCommandBar.SortByQueue(xObjList), sPrefix+"Action", xObj, { 0.0, 0.0, 0.0 }, m_sTTPath);
								endif;
							else
//								var CObjList xPersonal=CCommandBar.SortByQueue(xObjList);
//								if(xPersonal.NumEntries()>0&&xPersonal[0].IsValid())then
//									var string sG;
//									var CClntHndl xValid=CMirageClnMgr.GetControl(xPersonal[0],sG);
//									CEvt_GamePlayCommand.Send(xValid, "Action", xObj, { 0.0, 0.0, 0.0 }, m_sTTPath+sG);
//								endif;
								var string sGuids;
								if(bGeneral)then
//									sGuids=CCommandBar.GetCodesSimple(xAll,true);
									sGuids=CCommandBar.GetCodesSimple(CCommandBar.SortByQueue(xAll),true);
								else
//									sGuids=CCommandBar.GetCodesSimple(xObjList,true);
									sGuids=CCommandBar.GetCodesSimple(CCommandBar.SortByQueue(xObjList),true);
								endif;
								if(sGuids!="")then
									var CClntHndl xGPCE=CMirageClnMgr.Get().GetGPCE();
									CEvt_GamePlayCommand.Send(xGPCE,sPrefix+"|LA|"+m_sTTPath,xObj,{0.0,0.0,0.0},sGuids);
								endif;
							endif;
							var string sCharacter="", sSpecial="";
							if(IsSpecialMove(^(xObjTT), sCharacter, sSpecial))then
								CGameInputController.ms_xUISoundMgr.PlayFeedbackSoundEvent("voice_"+sCharacter+"_special_"+sSpecial, "", CSoundMgrCln.SOUND_VOLTRACK_GLOBAL);
							endif;
						else
							CMainController.Get().GetPlacer().SetResNumPossible(m_iResNumPossible);
							CMainController.Get().GetPlacer().SetClass(sResult, m_sTTPath);
						endif;
					else
						if(xObjList.NumEntries()>0)then
							var int im, iMC=xObjList.NumEntries();
							var bool bLocked=false, bMulti=iMC>1, bAllow;
							for(im=0)cond(im<iMC)iter(++im)do
								bAllow=CMirageClnMgr.Get().IsOkAndReadyForAction(m_sTTPath, xObjList[im], bLocked, bMulti);
								if((!bAllow && !bGeneral) || bLocked)then
									xObjList.DeleteEntry(im--); --iMC; continue;
								endif;
							endfor;
						endif;
						var int iUnits=xObjList.NumEntries();
						if(iUnits<=0)then return false; endif;
						var CClntHndl xObj;
						if(!m_bPersonal||bOldCommandSystem||xAll.NumEntries()<2||!xGPCE.IsValid())then
							asGuidList=0;
							if(bGeneral)then
								CEvt_GamePlayCommand.Send(CCommandBar.SortByQueue(xAll), sPrefix+"Action", xObj, { 0.0, 0.0, 0.0 }, m_sTTPath);
							else
								CEvt_GamePlayCommand.Send(CCommandBar.SortByQueue(xObjList), sPrefix+"Action", xObj, { 0.0, 0.0, 0.0 }, m_sTTPath);
							endif;
						else
							var string sGuids;
							if(bGeneral)then
//								sGuids=CCommandBar.GetCodesSimple(xAll,true);
								sGuids=CCommandBar.GetCodesSimple(CCommandBar.SortByQueue(xAll),true);
							else
//								sGuids=CCommandBar.GetCodesSimple(xObjList,true);
								sGuids=CCommandBar.GetCodesSimple(CCommandBar.SortByQueue(xObjList),true);
							endif;
							if(sGuids!="")then
								var CClntHndl xGPCE=CMirageClnMgr.Get().GetGPCE();
								CEvt_GamePlayCommand.Send(xGPCE,sPrefix+"|LA|"+m_sTTPath,xObj,{0.0,0.0,0.0},sGuids);
							endif;
						endif;
					endif;
				else
					if(m_sCommand.Find("/Unboard")!=-1)then
						var CGuid xGuid;
						xGuid.FromString(m_sAdditionalInfo);
						var ^CObj pxO=CGameWrap.GetObjMgr().GetObj(xGuid);
						if(pxO!=null)then
						endif;
					else
						var CClntHndl xObj;
						var string sCharacter="", sSpecial="";
						asGuidList=0;
						CEvt_GamePlayCommand.Send(CCommandBar.SortByQueue(xAll), sPrefix+"Action", xObj, { 0.0, 0.0, 0.0 }, m_sTTPath);
						if(IsSpecialMove(^(xObjTT), sCharacter, sSpecial))then
							CGameInputController.ms_xUISoundMgr.PlayFeedbackSoundEvent("voice_"+sCharacter+"_special_"+sSpecial, "", CSoundMgrCln.SOUND_VOLTRACK_GLOBAL);
						endif;
					endif;
				endif;
			endif;
		endif;
		return(true);
	endproc;
	
	proc bool OnTimer(int p_iID)
		CWindowMgr.Get().BringWindowToTop(CClientWrap.GetDesktop(), true);
		return(false);
	endproc;
	
endclass;