/*?
	?group URS.Scripts.Game.UI
	?item CNewPyramid
	?desc class Charactermanagement via CharacterCards, UpdateIcons und InventoryCards
	?prefix CNewPyramid
?*/
class CNewPyramid inherit CAlphaMaskedStaticCtrl

	export const int MODE_SMALL = 0;
	export const int MODE_COLLAPSE = 1;
	var int 					m_iMode;

	///card variables
	var ^CTribeViewLayoutMgr 	m_pxTribeView;
	static var ^CNewPyramid 	ms_pxInst;
	var array ^CPyramidCard		m_apxAddCards;
	var array ^CPyramidCard		m_apxPyCOCards;
	var array ^CPyramidCard		m_apxNormalCards;
	var int						m_iTimer;/* m_iCountInventory;*/
	export static var bool		ms_bDump;
	var int 					m_iTimerCountdown;
	static var array int		ms_aiFoodCostsPerLevel;
	var string					m_sTribe;
	var array string			m_asHuUpgrades;
	var array string			m_asAjeUpgrades;
	var array string			m_asNinigiUpgrades;
	var array string			m_asSEASUpgrades;
	var array string			m_asCurrentTribeUpgrades;
	var bitset					m_dwCurrentUpgrades;
	var ^CDesktop				m_pxDesktop;
	var bool					m_bFettich;
	///dragbox variables
	var rect 					m_xRect;
	var int 					m_iBX, m_iBY, m_iEX, m_iEY, m_iX, m_iY;
	var point					m_xPoint;
	var ^CPyramidFrame 			m_pxFrame;
	var bool 					m_bDragBox;
	var bool 					m_bMouseCaptured;
	var bool					m_bPBMode;
	export static var string	ms_sPBTribe;
	export var ^CPointBuyMenu	m_pxPBOwner;
	var bool					m_bPreviewMode;
	var bool					m_bOnce;
	
	// flag which is true if game is loading
	var bool					m_bIsLoading;
	// pyramid name (time of creation) for debugging purpose
	var string					m_sName;
	static var int				ms_iInstanceCount;
	
	///single player campagne variables
	var CPropDB					m_xCampDB;
	
	var int						m_iSortingMethod;
	static var CPropDB		ms_xCompareDB;
	
	/*update variables
	var ^CUpdateSlot			m_pxCoverUP;
	var int 					m_iXtraState;
	var int 					m_iHu_Chain_Mail_State, m_iDisguise_State, m_iIllusion_State, m_ires_abs_State, m_ires_rel_State, m_iHu_Stone_Axe_State;
	var int 					m_iHu_Wooden_Buckler_State, m_iHu_Sword_State, m_iHu_Metal_Buckler_State, m_iWarcry_State, m_iHu_Battle_Axe_State;
	var int						m_iHu_Wooden_Lance_State, m_iHu_Metal_Lance_State, m_iHealing_State, m_iTracking_State, m_iInsects_State, m_iOracle_State;
	var int						m_iTaming_State, m_iFindTraces_State, m_iHu_Bow_State, m_iHu_CrossBow_State, m_iFindTraps_State, m_iLockpicking_State, m_iFormations_State ;
	var string					m_sIconsPath;
	///inventory variables
	var ^CStaticCtrl			m_pxInvBackGround;*/

	var int										m_iScalpsTimer;
	static var bool						ms_bDisableCache;
	
	///constructor
	export constructor()
		m_sName = "Pyramid "+CTimeMgr.Get().GetTime().ToString();
		ms_iInstanceCount++;
		//L KLog.LogSpam("UI.NewPyramid","CNewPyramid::constructor "+m_sName+" #"+ms_iInstanceCount.ToString());
		m_bPBMode=false;
		SetMessageBlock(false);
		m_bMouseCaptured=false;
		m_bFettich = false;
		m_iTimerCountdown=0;
		m_bOnce=false;
		m_pxFrame = new CPyramidFrame;
		AddChild(m_pxFrame);
		m_pxFrame^.SetTransparent(true);
		m_pxFrame^.SetColor({{255,0,0,255}});
		begin InitLevelInfos;
			var int i;
			ms_aiFoodCostsPerLevel.AddEntry(-1);
			ms_aiFoodCostsPerLevel.AddEntry(-1);
			ms_aiFoodCostsPerLevel.AddEntry(-1);
			ms_aiFoodCostsPerLevel.AddEntry(-1);
			ms_aiFoodCostsPerLevel.AddEntry(-1);
		end InitLevelInfos;
		//wie soll das jemand noch nachvollziehen?!? (vgl. RT#16355)
		//ms_pxInst=this;
		m_pxDesktop=CClientWrap.GetDesktop();
		m_pxTribeView = new CTribeViewLayoutMgr();
		m_pxTribeView^.m_xCurSize = GetSize();

		//pb and ingame pyramid cards scale
		var int l, lC=5;
		for(l=0) cond(l<lC) iter(++l)do
			var ^CTribeViewLayoutMgr.CSingleLevelLayoutInfo pxLayout = ^(m_pxTribeView^.GetSingleLevelLayoutInfo(l));
			if(pxLayout!=null)then
				pxLayout^.m_xMainMargin.SetLeft(pxLayout^.m_xMainMargin.GetLeft() * CGameInst.ms_iUIScaleFactor);
				pxLayout^.m_xMainMargin.SetTop(pxLayout^.m_xMainMargin.GetTop() * CGameInst.ms_iUIScaleFactor);
				pxLayout^.m_xMainMargin.SetRight(pxLayout^.m_xMainMargin.GetRight() * CGameInst.ms_iUIScaleFactor);
				pxLayout^.m_xMainMargin.SetBottom(pxLayout^.m_xMainMargin.GetBottom() * CGameInst.ms_iUIScaleFactor);
					
				pxLayout^.m_xSlotMargin.SetLeft(pxLayout^.m_xSlotMargin.GetLeft() * CGameInst.ms_iUIScaleFactor);
				pxLayout^.m_xSlotMargin.SetTop(pxLayout^.m_xSlotMargin.GetTop() * CGameInst.ms_iUIScaleFactor);
				pxLayout^.m_xSlotMargin.SetRight(pxLayout^.m_xSlotMargin.GetRight() * CGameInst.ms_iUIScaleFactor);
				pxLayout^.m_xSlotMargin.SetBottom(pxLayout^.m_xSlotMargin.GetBottom() * CGameInst.ms_iUIScaleFactor);
					
				pxLayout^.m_xXtraMargin.SetLeft(pxLayout^.m_xXtraMargin.GetLeft() * CGameInst.ms_iUIScaleFactor);
				pxLayout^.m_xXtraMargin.SetTop(pxLayout^.m_xXtraMargin.GetTop() * CGameInst.ms_iUIScaleFactor);
				pxLayout^.m_xXtraMargin.SetRight(pxLayout^.m_xXtraMargin.GetRight() * CGameInst.ms_iUIScaleFactor);
				pxLayout^.m_xXtraMargin.SetBottom(pxLayout^.m_xXtraMargin.GetBottom() * CGameInst.ms_iUIScaleFactor);
					
				pxLayout^.m_xLevelMargin.SetLeft(pxLayout^.m_xLevelMargin.GetLeft() * CGameInst.ms_iUIScaleFactor);
				pxLayout^.m_xLevelMargin.SetTop(pxLayout^.m_xLevelMargin.GetTop() * CGameInst.ms_iUIScaleFactor);
				pxLayout^.m_xLevelMargin.SetRight(pxLayout^.m_xLevelMargin.GetRight() * CGameInst.ms_iUIScaleFactor);
				pxLayout^.m_xLevelMargin.SetBottom(pxLayout^.m_xLevelMargin.GetBottom() * CGameInst.ms_iUIScaleFactor);

				pxLayout^.m_xMainIconSize.SetX(pxLayout^.m_xMainIconSize.GetX() * CGameInst.ms_iUIScaleFactor);
				pxLayout^.m_xMainIconSize.SetY(pxLayout^.m_xMainIconSize.GetY() * CGameInst.ms_iUIScaleFactor);
					
				pxLayout^.m_xXtraIconSize.SetX(pxLayout^.m_xXtraIconSize.GetX() * CGameInst.ms_iUIScaleFactor);
				pxLayout^.m_xXtraIconSize.SetY(pxLayout^.m_xXtraIconSize.GetY() * CGameInst.ms_iUIScaleFactor);
			endif;
		endfor;
		
		m_pxTribeView^.SetModeCollapse();
		m_iMode = MODE_COLLAPSE;
		SetBackground(false);
		SetTransparent(false);
		SetSuitAlpha(false);
		SetBitmap(CClientWrap.GetUrsRelPath()+"/Data/Base/UI/Pyramid_b.tga");
		var int iHeight = m_pxTribeView^.m_xCurSize.GetY();
		var int iWidth = m_pxTribeView^.m_xCurSize.GetX();
		SetPos(0,0);
		SetSize(iHeight * CGameInst.ms_iUIScaleFactor,iWidth * CGameInst.ms_iUIScaleFactor);
		CGameWrap.GetSubscriptionMgr().SubscribeObjChanges(this, CSubscriptionMgr.CT_NewPlayerUnit, "");
		CGameWrap.GetSubscriptionMgr().SubscribeObjChanges(this, CSubscriptionMgr.CT_ObjInventory, "");
		StartTimer();
		var int i, j, iTotalSlots = m_pxTribeView^.TotalSlotCount();
		for(i=0)cond(i<iTotalSlots)iter(i++)do
			SetWindowToSlot(i,GetBackgroundPane(i),false);
		endfor;
		//CGroupMgr.Get().m_xOnUpdateGroup = OnUpdateGroup;
		m_bIsLoading = false;
	endconstructor;
	
	///destructor
	export destructor()
		ms_iInstanceCount--;
		//L KLog.LogSpam("UI.NewPyramid","CNewPyramid::destructor "+m_sName+" #"+ms_iInstanceCount.ToString());
		CGameWrap.GetSubscriptionMgr().UnsubscribeObjChanges(this, CSubscriptionMgr.CT_NewPlayerUnit, "");
		CGameWrap.GetSubscriptionMgr().UnsubscribeObjChanges(this, CSubscriptionMgr.CT_ObjInventory, "");
		var int i, iC;
		// delete additional cards
		while(m_apxAddCards.NumEntries()>0)do
			var ^CPyramidCard pxCard = m_apxAddCards[0];
			System.Assert(pxCard!=null);
			KillCard(m_apxAddCards[0]);
		endwhile;
		m_apxNormalCards = 0;
		// delete visible cards
		iC = m_pxTribeView^.TotalSlotCount();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CPyramidCard pxCard = cast<CPyramidCard>(m_pxTribeView^.GetSlotInfo(i)^.GetWindow());
			if(pxCard!=null)then
				KillCard(pxCard);
			endif;
		endfor;
		UnsetTimer(m_iTimer);
		UnsetTimer(m_iScalpsTimer);
		delete m_pxTribeView;
		if(ms_pxInst==this)then
			ms_pxInst=null;
		endif;
	enddestructor;
	
	export proc int GetPyramidMode()
		return m_iMode;
	endproc;
	
	export proc int TotalSlotCount()
		return m_pxTribeView^.TotalSlotCount();
	endproc;
	
	export proc void SetPointBuyMode(bool p_bEnabled)
		CPyramidRestrictionsMgr.Get().SetAjeBlockedSlot(p_bEnabled && ms_sPBTribe=="Aje");
		UpdateBlockedSlots();
		if(m_bPBMode == p_bEnabled)then return; endif;
		m_bPBMode = p_bEnabled;
		if(m_bPBMode)then
			SetBackground(true);
			SetTransparent(true);
			SetSuitAlpha(true);
			CGameWrap.GetSubscriptionMgr().UnsubscribeObjChanges(this, CSubscriptionMgr.CT_NewPlayerUnit, "");
			CGameWrap.GetSubscriptionMgr().UnsubscribeObjChanges(this, CSubscriptionMgr.CT_ObjInventory, "");
		else
			SetBackground(false);
			SetTransparent(false);
		endif;
	endproc;

	export proc void SetPreviewMode(bool p_bValue)
		m_bPreviewMode = p_bValue;
		var int i, iC = m_pxTribeView^.TotalSlotCount();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CPyramidCard pxCard = cast<CPyramidCard>(m_pxTribeView^.GetSlotInfo(i)^.GetWindow());
			if(pxCard!=null)then
				pxCard^.SetPreviewMode(p_bValue);
			endif;
		endfor;
	endproc;

	export proc bool IsPointBuyMode()
		return m_bPBMode;
	endproc;

	///called when dumping
	export static proc void SetDumpVar(bool p_bB)
		ms_bDump = p_bB;
	endproc;

	///called from outside to get tribeview
	export proc ^CTribeViewLayoutMgr GetTribeViewPtr()
		return m_pxTribeView;
	endproc;

	///called to set background slots for cards
	proc ^CWindow GetBackgroundPane(int p_iIdx)
		var int iLvl = m_pxTribeView^.SlotIndex2Level(p_iIdx);
		var ^CPyrSlot pxPS = new CPyrSlot(iLvl);
		var ^CTribeViewLayoutMgr.CSlotInfo pxSI = m_pxTribeView^.GetSlotInfo(p_iIdx);
		if(pxSI!=null && pxSI^.m_bBlocked)then
			pxPS^.SetBlocked(pxSI^.m_bBlocked,pxSI^.m_bBlockedPerm);
		endif;
		return pxPS;
	endproc;

	///called to match Card with Slot
	proc void SetWindowToSlot(int p_iSlotID,^CWindow p_pxW,bool p_bUsed)
		var ^CTribeViewLayoutMgr.CSlotInfo pxSI=m_pxTribeView^.GetSlotInfo(p_iSlotID);
		var ^CWindow pxWndOld=pxSI^.GetWindow();
		if(pxWndOld!=null)then pxWndOld^.Destroy(); endif;
		pxSI^.m_sName.Empty();
		AddChild(p_pxW);
		pxSI^.SetWindow(p_pxW);
		pxSI^.m_bUsed=p_bUsed;
	endproc;
	
	export proc void UpdateAllBitmaps()
		var int i, iC = m_pxTribeView^.TotalSlotCount();
		for(i=0)cond(i<iC)iter(i++)do
			if(m_pxTribeView^.GetSlotInfo(i)^.m_bUsed == true)then
				var ^CPyramidCard pxChar = GetCard(i);
				if(pxChar!=null)then
					pxChar^.UpdateData();
				endif;
			endif;
		endfor;
	endproc;

	///Get method for Pyramid
	export static proc ref CNewPyramid Get()
		if(ms_pxInst==null)then
			ms_pxInst=new CNewPyramid;
		endif;
		return(ms_pxInst^);
	endproc;

	///Starts timer when one of the alerts is set off
	proc void StartTimer()
		m_iTimer = SetTimer(100, true);
		m_iTimerCountdown=0;
	endproc;

	proc ^CPyramidCard FindPyCOByObjPath(^CObj p_pxO)
		if(p_pxO==null)then return null; endif;
		var ^CAttribs pxAttr1 = p_pxO^.GetAttribs();
		if(pxAttr1==null)then return null; endif;
		var string sFind=pxAttr1^.GetValue("ObjPath");
		if(sFind=="")then return null; endif;
		var int i,iC=m_apxPyCOCards.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CPyramidCard pxCard = m_apxPyCOCards[i];
			if(pxCard!=null)then
				var ^CObj pxObj=pxCard^.GetObj().GetObj();
				if(pxObj!=null)then
					var ^CAttribs pxAttr2 = pxObj^.GetAttribs();
					if(pxAttr2!=null)then
						if(pxAttr1^.GetValue("ObjPath")==pxAttr2^.GetValue("ObjPath"))then
							return pxCard;
						endif;
					endif;
				endif;
			endif;
		endfor;
		return null;
	endproc;

	proc ^CPyramidCard FindPyCOByName(^CObj p_pxO)
		if(p_pxO==null)then return null; endif;
		var ^CAttribs pxAttr1 = p_pxO^.GetAttribs();
		if(pxAttr1==null)then return null; endif;
		var string sNameOfCardToReplace = pxAttr1^.GetValue("clientpyramid_replacecard");
		if(sNameOfCardToReplace.IsEmpty())then return null; endif;
		var int i,iC=m_apxPyCOCards.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CPyramidCard pxCard = m_apxPyCOCards[i];
			if(pxCard!=null)then
				var ^CObj pxObj=pxCard^.GetObj().GetObj();
				if(pxObj!=null)then
					if(sNameOfCardToReplace==pxObj^.GetName())then
						return pxCard;
					endif;
				endif;
			endif;
		endfor;
		return null;
	endproc;
	
	proc ^CPyramidCard FindLPCByName(^CObj p_pxO)
		if(p_pxO==null)then return null; endif;
		var ^CAttribs pxAttr1 = p_pxO^.GetAttribs();
		if(pxAttr1==null)then return null; endif;
		var string sNameOfCardToReplace = pxAttr1^.GetValue("clientpyramid_replacecard");
		if(sNameOfCardToReplace.IsEmpty())then return null; endif;
		var int i,iC=m_apxNormalCards.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CPyramidCard pxCard = m_apxNormalCards[i];
			if(pxCard!=null)then
				var ^CObj pxObj=pxCard^.GetObj().GetObj();
				if(pxObj!=null)then
					if(sNameOfCardToReplace==pxObj^.GetName())then
						return pxCard;
					endif;
				endif;
			endif;
		endfor;
		return null;
	endproc;
	
	proc void CreateCard(int p_iLevel, string p_sCaste, string p_sClassName, CClntHndl p_xObjHandle)
		CreateCard(p_iLevel,p_sCaste,p_sClassName,p_xObjHandle,-1,false);
	endproc;

	///creates new card in tribeview
	proc void CreateCard(int p_iLevel, string p_sCaste, string p_sClassName, CClntHndl p_xObjHandle, int p_iPreferredSlotID, bool p_bInit)
		var ^CObj pxTmpObj=p_xObjHandle.GetObj();
		if(pxTmpObj==null)then return; endif;
		//do not allow dublicates
		if(ObjectHasCard(p_xObjHandle))then
			return;
		endif;
		var int iSlotID = -1;
		if(!p_bInit)then iSlotID = m_pxTribeView^.FindFreeSlot(p_iLevel); endif;
		if(p_iPreferredSlotID>-1)then
			var ^CTribeViewLayoutMgr.CSlotInfo pxSlotInfo = m_pxTribeView^.GetSlotInfo(p_iPreferredSlotID);
			// slot is free and preferred slot is in p_iLevel?
			// yes -> create card in preferred slot
			if(pxSlotInfo!=null && pxSlotInfo^.m_bUsed==false && m_pxTribeView^.SlotIndex2Level(p_iPreferredSlotID)==p_iLevel)then
				iSlotID = p_iPreferredSlotID;
			endif;
		endif;
		//replace PyCO cards with real cards if objpath matches
		var ^CPyramidCard pxPyCOCard = FindPyCOByName(pxTmpObj);
		if(pxPyCOCard!=null)then
			iSlotID=pxPyCOCard^.GetSlotID();
			KillCard(pxPyCOCard);
		endif;
		//Henry: replace launchpads cards with product cards if objpath matches
		var ^CPyramidCard pxLPCard = FindLPCByName(pxTmpObj);
		if(pxLPCard!=null)then
			iSlotID=pxLPCard^.GetSlotID();
			KillCard(pxLPCard);
		endif;
		if(iSlotID>=m_pxTribeView^.TotalSlotCount())then
			iSlotID=-1;
		endif;
		var ^CPyramidCard pxCard = new CPyramidCard(p_xObjHandle);
		pxCard^.InitParent(this);
		pxCard^.SetLevel(p_iLevel);
		pxCard^.SetClass(p_sClassName);
		pxCard^.SetSlotID(iSlotID);
		pxCard^.SetCaste(p_sCaste);
		pxCard^.SetName(pxTmpObj^.GetName());
//		if(pxCard^.GetIsPyCO())then
//			m_apxPyCOCards.AddEntry(pxCard);
//		endif;
		if(iSlotID == -1)then
			pxCard^.SetAdditionalCard(true);
			m_apxAddCards.AddEntry(pxCard);
		else
			pxCard^.SetTribeViewPointer(m_pxTribeView);
			SetWindowToSlot(iSlotID,pxCard,true);
			pxCard^.m_bBitmapChanged = true;
			pxCard^.UpdateData();
			//pxCard^.UpdateBitmaps();
			if(!pxCard^.GetIsPyCO())then
				m_apxNormalCards.AddEntry(pxCard);
			else
				m_apxPyCOCards.AddEntry(pxCard);
			endif;
			var ^CTribeViewLayoutMgr.CSlotInfo pxSI=m_pxTribeView^.GetSlotInfo(iSlotID);
			var ^CObj pxObj=p_xObjHandle.GetObj();
			pxSI^.m_sName=pxObj^.GetName();
			pxSI^.SetAlertCounter(50);
		endif;
		//UpdateXtras();
	endproc;

	export proc void CreateCard(int p_iLevel, string p_sClassName)
		if(!m_bPBMode)then return; endif;
		var int iSlotID = m_pxTribeView^.FindFreeSlot(p_iLevel);
		CreateCardInSlot(iSlotID,p_sClassName,-1);
	endproc;

	export proc void CreateCardInSlot(int p_iSlotID, string p_sClassName,int p_iFixedLevel)
		if(!m_bPBMode)then return; endif;
		var int iLevel = m_pxTribeView^.SlotIndex2Level(p_iSlotID);
		var int iSlotID = p_iSlotID;
		if(iSlotID>=m_pxTribeView^.TotalSlotCount())then
			iSlotID=-1;
		endif;
		var ^CPyramidCard pxCard = new CPyramidCard(p_sClassName,"");
		pxCard^.InitParent(this);
		pxCard^.SetLevel(iLevel);		
		pxCard^.SetSlotID(iSlotID);
		pxCard^.SetFixedLevel(p_iFixedLevel);
		pxCard^.SetPreviewMode(m_bPreviewMode);
		if(p_iFixedLevel>-1)then
			pxCard^.SetToolTipText(CLocalizer.Get().Translate("_UI_AC_PointBuy_Card_Locked"));
		else
			pxCard^.SetToolTipText(CLocalizer.Get().Translate("_UI_AC_PointBuy_Card"));
		endif;
		if(iSlotID == -1)then
			pxCard^.SetAdditionalCard(true);
			m_apxAddCards.AddEntry(pxCard);
		else
			pxCard^.SetTribeViewPointer(m_pxTribeView);
			SetWindowToSlot(iSlotID,pxCard,true);
			pxCard^.m_bBitmapChanged = true;
			if(!m_bOnce)then
				pxCard^.UpdateBitmaps();
				m_bOnce=true;
			endif;
			var ^CTribeViewLayoutMgr.CSlotInfo pxSI=m_pxTribeView^.GetSlotInfo(iSlotID);
		endif;
		//UpdateXtras();
	endproc;

	///Deletes Card from Pyramid
	export proc void KillCard(^CPyramidCard p_pxCard)
		if(p_pxCard == null)then return; endif;
		var int iCardID = p_pxCard^.GetSlotID();
		if(p_pxCard^.GetAdditionalCard())then
			m_apxAddCards.RemEntry(p_pxCard);
		else
			if(iCardID != -1)then
				SetWindowToSlot(iCardID,GetBackgroundPane(iCardID),false);
			endif;
		endif;
		if(p_pxCard^.GetIsPyCO())then
			m_apxPyCOCards.RemEntry(p_pxCard);
		endif;
		if(m_apxNormalCards.FindEntry(p_pxCard)!=-1)then
			m_apxNormalCards.RemEntry(p_pxCard);
		endif;
		p_pxCard^.Destroy();
		if(IsPointBuyMode() && m_pxPBOwner!=null)then
			m_pxPBOwner^.InvalidateContent();
		endif;
		// side effect tryadditionalcards calls killcard sometimes
		//if(m_apxAddCards.NumEntries()>0)then
		//	TryAdditionalCards();
		//endif;
		//UpdateXtras();
	endproc;

	///updates Card in Tribe View
	export proc bool UpdateCardPos(^CPyramidCard p_pxCard)
		if(p_pxCard==null)then return false; endif;
		var int iCardID = p_pxCard^.GetSlotID();;
		if(iCardID == -1)then return false; endif;
		var int iOldLevel = m_pxTribeView^.SlotIndex2Level(p_pxCard^.GetSlotID());
		var int iNewLevel = p_pxCard^.GetLevel();
		if(iOldLevel != iNewLevel)then
			var int iOldSlotID=p_pxCard^.GetSlotID();
			if(iOldSlotID >=0)then
				var int iSlotID = m_pxTribeView^.FindFreeSlot(p_pxCard^.GetLevel());
				if(iSlotID!=-1)then
					SwapSlotsAndCards(iOldSlotID,iSlotID);
					if(m_apxAddCards.NumEntries()>0)then
						TryAdditionalCards();
					endif;
					return true;
				endif;
			endif;
		endif;
		return false;
	endproc;


	///Set additonal cards in pyramid
	export proc void TryAdditionalCards()
		//L KLog.LogSpam("UI.NewPyramid","CNewPyramid::TryAdditionalCards");
		var int i;
		for(i=0)cond(i<m_apxAddCards.NumEntries())iter(i++)do
			var ^CPyramidCard pxCard = m_apxAddCards[i];
			var int iSlotID = m_pxTribeView^.FindFreeSlot(pxCard^.GetLevel());
			if(iSlotID != -1)then
				var ^CObj pxObj=pxCard^.GetObj().GetObj();
				if(pxObj!=null && pxObj^.GetOwner()==CClientWrap.GetClient().GetPlayerID())then
					if(!pxCard^.UpdateUnitCount())then i--; if(i<0)then /*KLog.LogSpam("UI.NewPyramid","CNewPyramid::TryAdditionalCards i<0");*/ i=-1; endif; continue; endif; // warning implicit KillCard if result of UpdateUnitCount is false
					pxCard^.SetAdditionalCard(false);
					pxCard^.SetTribeViewPointer(m_pxTribeView);
					pxCard^.SetSlotID(iSlotID);
					SetWindowToSlot(iSlotID,pxCard,true);
					var ^CTribeViewLayoutMgr.CSlotInfo pxSI=m_pxTribeView^.GetSlotInfo(iSlotID);
					pxSI^.m_sName=pxObj^.GetName();
					pxSI^.SetAlertCounter(50);
					pxCard^.m_bBitmapChanged = true;
					if(!pxCard^.GetIsPyCO())then
						m_apxNormalCards.AddEntry(pxCard);
					else
						m_apxPyCOCards.AddEntry(pxCard);
					endif;
					m_apxAddCards.DeleteEntryUS(i);i--;
					if(i<0)then /*KLog.LogSpam("UI.NewPyramid","CNewPyramid::TryAdditionalCards i<0");*/ i=-1; endif;
					continue;
				else
					m_apxAddCards.DeleteEntryUS(i);i--;
					if(i<0)then /*KLog.LogSpam("UI.NewPyramid","CNewPyramid::TryAdditionalCards i<0");*/ i=-1; endif;
					pxCard^.Destroy();
					continue;
				endif;
			endif;
		endfor;
	endproc;

	///called to swap to cards when possible
	export proc void SwapSlotsAndCards(int p_iSlotA,int p_iSlotB)
		var ^CPyramidCard pxA = GetCard(p_iSlotA);
		var ^CPyramidCard pxB = GetCard(p_iSlotB);
		var bool bUsedA = (pxA!=null);
		var bool bUsedB = (pxB!=null);
		var int iLevelA = m_pxTribeView^.SlotIndex2Level(p_iSlotA);
		var int iLevelB = m_pxTribeView^.SlotIndex2Level(p_iSlotB);
//		if(iLevelA>iLevelB)then return; endif;
		if(iLevelA>iLevelB)then
			if(bUsedA)then
//				if(IsHero(pxA^.GetClass()))then
				if(!pxA^.GetIsPyCO() && IsLevelAcceptable(pxA^.GetClass(),iLevelB,pxA^.GetObjPath()))then
				else
					return;
				endif;
			else
				return;
			endif;
		endif;
		//prevent unfinished buildings from leveling up
		if(iLevelA<iLevelB)then
			var ^CObj pxO = pxA^.GetObj().GetObj();
			if(pxO!=null&&pxO^.GetType()=="BLDG"&&(pxO^.GetAttribs()^.GetValue("CurTask")=="BuildUpB"||pxO^.GetAttribs()^.GetValueInt("ReadyForWork")==0))then
				return;
			endif;
			//prevent PyCO from leveling up
			if(bUsedA && pxA^.GetIsPyCO())then
				return;
			endif;
		endif;
		if((bUsedA!=bUsedB)&&(iLevelA!=iLevelB))then
			if(GetCharactersInLevel(iLevelB)>=CPyramidRestrictionsMgr.Get().GetMaxSlots(iLevelB))then
				return;
			endif;
		endif;
		if((bUsedA == true)&&(bUsedB == true)&&(iLevelA != iLevelB))then
			return;
		endif;
		m_pxTribeView^.SwapSlots(p_iSlotA,p_iSlotB,true);
		pxA = GetCard(p_iSlotA);
		pxB = GetCard(p_iSlotB);
		if(m_pxTribeView^.GetSlotInfo(p_iSlotA)^.m_bUsed == true)then
			pxA^.m_bBitmapChanged = true;
			//pxA^.UpdateBitmaps();
			pxA^.SetSlotID(p_iSlotA);
			pxA^.SetLevel(iLevelA);
			pxA^.SubmitChanges();
		else
			SetWindowToSlot(p_iSlotA,GetBackgroundPane(p_iSlotA),false);
		endif;
		if(m_pxTribeView^.GetSlotInfo(p_iSlotB)^.m_bUsed == true)then
			pxB^.m_bBitmapChanged = true;
			//pxB^.UpdateBitmaps();
			pxB^.SetSlotID(p_iSlotB);
			pxB^.SetLevel(iLevelB);
			pxB^.SubmitChanges();
		else
			SetWindowToSlot(p_iSlotB,GetBackgroundPane(p_iSlotB),false);
		endif;
		//SwapXtra(p_iSlotA, p_iSlotB);
		//SwapInv(p_iSlotA, p_iSlotB);
		//UpdateXtras();
		m_pxTribeView^.Tick();
	endproc;

	///called to swap two cards without any checks
	export proc void SwapSlotsAndCardsFast(int p_iSlotA,int p_iSlotB)
		var ^CPyramidCard pxA = GetCard(p_iSlotA);
		var ^CPyramidCard pxB = GetCard(p_iSlotB);
		var bool bUsedA = (pxA!=null);
		var bool bUsedB = (pxB!=null);
		var int iLevelA = m_pxTribeView^.SlotIndex2Level(p_iSlotA);
		var int iLevelB = m_pxTribeView^.SlotIndex2Level(p_iSlotB);
		m_pxTribeView^.SwapSlots(p_iSlotA,p_iSlotB,true);
		pxA = GetCard(p_iSlotA);
		pxB = GetCard(p_iSlotB);
		if(m_pxTribeView^.GetSlotInfo(p_iSlotA)^.m_bUsed == true)then
			pxA^.SetSlotID(p_iSlotA);
			pxA^.SetLevel(iLevelA);
			pxA^.SubmitChanges();
			pxA^.m_bBitmapChanged = true;
			//pxA^.UpdateBitmaps();
		else
			SetWindowToSlot(p_iSlotA,GetBackgroundPane(p_iSlotA),false);
		endif;
		if(m_pxTribeView^.GetSlotInfo(p_iSlotB)^.m_bUsed == true)then
			pxB^.SetSlotID(p_iSlotB);
			pxB^.SetLevel(iLevelB);
			pxB^.SubmitChanges();
			pxB^.m_bBitmapChanged = true;
			//pxB^.UpdateBitmaps();
		else
			SetWindowToSlot(p_iSlotB,GetBackgroundPane(p_iSlotB),false);
		endif;
		m_pxTribeView^.Tick();
	endproc;

	//called to get charcaters level
	export proc int GetCharactersInLevel(int p_iLevel)
		var int i, iC = m_pxTribeView^.TotalSlotCount();
		var int iCount = 0;
		for(i=0)cond(i<iC)iter(i++)do
			if(m_pxTribeView^.SlotIndex2Level(i)!=p_iLevel)then continue; endif;
			var ^CPyramidCard pxCard = cast<CPyramidCard>(m_pxTribeView^.GetSlotInfo(i)^.GetWindow());
			if(pxCard!=null)then
				iCount++;
			endif;
		endfor;
		return iCount;
	endproc;
	
	/*swaps xtra update slots when cards are swapped
	export proc void SwapXtra(int p_iSlotA, int p_iSlotB)
		var int iLvlA 		= m_pxTribeView^.SlotIndex2Level(p_iSlotA);
		var int iANeedXtra	= GetXtraSlots(iLvlA);
		var int iXtraDiffA 	=  iANeedXtra - m_pxTribeView^.GetSlotInfo(p_iSlotA)^.NumXtra(true);
		var int iLvlB 		= m_pxTribeView^.SlotIndex2Level(p_iSlotB);
		var int iBNeedXtra	= GetXtraSlots(iLvlB);
		var int iXtraDiffB 	= iBNeedXtra - m_pxTribeView^.GetSlotInfo(p_iSlotB)^.NumXtra(true);
		var ^CTribeViewLayoutMgr.CSlotInfo pxSISub = null;
		var ^CTribeViewLayoutMgr.CSlotInfo pxSIAdd = null;
		var int iRemIdx = 0;
		var int iSubDiff, iAddDiff;
		if(iXtraDiffA < 0 )then
			pxSISub	= m_pxTribeView^.GetSlotInfo(p_iSlotA);
			pxSIAdd = m_pxTribeView^.GetSlotInfo(p_iSlotB);
			iRemIdx = iANeedXtra;
			iSubDiff= iXtraDiffA;
			iAddDiff= iXtraDiffB;
		elseif(iXtraDiffB < 0)then
			pxSISub = m_pxTribeView^.GetSlotInfo(p_iSlotB);
			pxSIAdd = m_pxTribeView^.GetSlotInfo(p_iSlotA);
			iRemIdx = iBNeedXtra;
			iSubDiff= iXtraDiffB;
			iAddDiff= iXtraDiffA;
		else
			return;
		endif;
		if(pxSISub==null || pxSIAdd==null)then return; endif;
		while(iSubDiff != 0 && iAddDiff != 0)do
			var int iPos = pxSIAdd^.AddXtra(true, "GreyBitmap");
			var ^CTribeViewLayoutMgr.CIconInfo pxGetXtra=pxSIAdd^.GetXtra(true, iPos);
			if(pxGetXtra!=null)then
				pxGetXtra^.SetWindow(pxSISub^.GetXtra(true, iRemIdx)^.GetWindow());
			else
			endif;
			pxSISub^.RemXtra(true, iRemIdx);
			++iSubDiff;
			--iAddDiff;
		endwhile;
	endproc;*/

	/*swaps xtra inventory slots when cards are swapped
	export proc void SwapInv(int p_iSlotA, int p_iSlotB)
		var ^CTribeViewLayoutMgr.CSlotInfo pxSIA = m_pxTribeView^.GetSlotInfo(p_iSlotA);
		var ^CTribeViewLayoutMgr.CSlotInfo pxSIB = m_pxTribeView^.GetSlotInfo(p_iSlotB);
		var ^CTribeViewLayoutMgr.CSlotInfo pxSIAdd = null;
		var ^CTribeViewLayoutMgr.CSlotInfo pxSISub = null;
		var int iLvlA 		= m_pxTribeView^.SlotIndex2Level(p_iSlotA);
		var int iLvlB 		= m_pxTribeView^.SlotIndex2Level(p_iSlotB);
		var int iNumXtrasA 	= pxSIA^.NumXtra(false);
		var int iNumXtrasB 	= pxSIB^.NumXtra(false);
		if((iLvlA >= 3 && iLvlB >=3) || (iLvlA < 3  && iLvlB < 3))then return; endif;
		if(iLvlA >= 3 )then
			pxSIAdd = pxSIA;
			pxSISub = pxSIB;
		else
			pxSIAdd = pxSIB;
			pxSISub = pxSIA;
		endif;
		var int i, iC = 6;
		for (i=0) cond(i<iC) iter(i++)do
			pxSIAdd^.AddXtra(false, i.ToString());
			pxSIAdd^.GetXtra(false, i)^.SetWindow(pxSISub^.GetXtra(false, 0)^.GetWindow());
			pxSISub^.RemXtra(false, 0);
		endfor;
	endproc;*/

	/*called to get amount of xtra update slots for level
	proc int GetXtraSlots(int p_iLevel)
		var int iXtra;
		if(p_iLevel== 0)then
			iXtra = 2;
		elseif(p_iLevel == 1)then
			iXtra = 2;
		elseif(p_iLevel == 2)then
			iXtra = 3;
		elseif(p_iLevel == 3 || p_iLevel == 4)then
			iXtra = 6;
		endif;
		return (iXtra);
	endproc;*/

	export proc void RefreshAllCards()
		var int i,iC = m_pxTribeView^.TotalSlotCount();
		for(i=0)cond(i<iC)iter(i++)do
			if(m_pxTribeView^.GetSlotInfo(i)^.m_bUsed == true)then
				var ^CPyramidCard pxChar = GetCard(i);
				if(pxChar!=null)then
					pxChar^.UpdateBitmaps();
				endif;
			endif;
		endfor;
	endproc;

	///calls tick
	proc bool OnTimer(int p_iTimerID)
		if(ms_bDump)then
			m_pxTribeView^.DumpLayoutToPic("wuff.tga");
			ms_bDump = false;
		endif;
		if(p_iTimerID == m_iTimer)then
			var CObjList xOL=CClientWrap.GetObjMgr().GetHoveredObjs();
			var CObjList xAddRiders;
			var int i, iC = xOL.NumEntries();
			if(!m_bPBMode)then
				for(i=0)cond(i<iC)iter(i++)do
					var CObjList xRiders;
					var bool bSizeTwo;
					if(CGroupMgr.Get().GetPassengers(xOL[i], xRiders, bSizeTwo))then
						xAddRiders.Include(xRiders);
						if(!bSizeTwo)then
							xAddRiders.AddEntry(xOL[i]);
						endif;
						var int j, iJC = xRiders.NumEntries();
						for(j=0)cond(j<iJC)iter(j++)do
							var bool bGradZwei;
							var CObjList xRiderRiders;
							if(CGroupMgr.Get().GetPassengers(xRiders[j], xRiderRiders, bGradZwei))then
								xAddRiders.Include(xRiderRiders);
							endif;
						endfor;
					endif;
				endfor;
				xOL.Include(xAddRiders);
				iC = m_pxTribeView^.TotalSlotCount();
				for(i=0)cond(i<iC)iter(i++)do
					if(m_pxTribeView^.GetSlotInfo(i)^.m_bUsed == true)then
						var ^CPyramidCard pxChar = GetCard(i);
						if(pxChar!=null)then
							var bool bCanLevel=CanLevel(pxChar, 1);
							pxChar^.SetCanLevel(bCanLevel);
							var CClntHndl xHndl = pxChar^.GetObj();
							if(xOL.FindEntry(xHndl)!=-1)then
								pxChar^.SetHovered(true);
							else
								pxChar^.SetHovered(false);
							endif;
						endif;
					endif;
				endfor;
			endif;
			// Update bitmaps with new hover states
			iC = m_pxTribeView^.TotalSlotCount();
			for(i=0)cond(i<iC)iter(i++)do
				if(m_pxTribeView^.GetSlotInfo(i)^.m_bUsed == true)then
					var ^CPyramidCard pxChar = GetCard(i);
					//if((pxChar!=null) && (pxChar^.IsHovered()!=pxChar^.WasHovered())||(pxChar^.m_bNeedUpdate))then
					if(pxChar!=null)then
						if(pxChar^.UpdateUnitCount() && pxChar^.m_bBitmapChanged)then
							pxChar^.UpdateBitmaps();
						endif;
					endif;
				endif;
			endfor;
			m_iTimerCountdown--;
			if(m_iTimerCountdown<=0)then
				m_iTimerCountdown=20;
			endif;
			if(m_pxTribeView != null)then
				m_pxTribeView^.Tick();
			return(true);
			endif;
		elseif(p_iTimerID == m_iScalpsTimer)then
			ms_bDisableCache=false;
		endif;
		return false;
	endproc;
	
	/*called to make an inventoryitem icon - called from handlemessage and from onloadend
	proc void MakeInvIcon()
		var int i, iC = m_pxTribeView^.TotalSlotCount();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CTribeViewLayoutMgr.CSlotInfo pxSI = m_pxTribeView^.GetSlotInfo(i);
			var ^CPyramidCard pxCard = cast<CPyramidCard>(pxSI^.GetWindow());
			if((pxCard!=null)&&(pxCard^.GetLevel()>=3))then	
				if(pxSI^.m_bUsed==true)then	
					var ^CObj pxObj=pxCard^.GetObj().GetObj();
					var ^CClientInventory pxInv = pxObj^.GetInventory();
					var ^CTribeViewLayoutMgr.CSlotInfo pxSlot = m_pxTribeView^.GetSlotInfo(i);
					if(pxInv!=null)then
						var CObjList xInvList, xCardList;
						
						begin FillObjLists;
							var int j, iK = pxInv^.Count();
							xInvList = iK;
							for(j=0)cond(j<iK)iter(++j)do
								xInvList[j] = pxInv^.GetItem(j);
							endfor;
							iK = pxSlot^.NumXtra(false);
							xCardList = iK;
							for(j=0)cond(j<iK)iter(++j)do
								var ^CTribeViewLayoutMgr.CIconInfo pxIcon = pxSlot^.GetXtra(false, j);
								if(pxIcon != null && pxIcon^.m_bUsed && pxIcon^.GetWindow() != null)then
									var ^CInvCard pxInvCard = cast<CInvCard>(pxIcon^.GetWindow());
									if(pxInvCard!=null)then
										xCardList[j] = pxInvCard^.GetObj();
									endif;
								endif;
							endfor;
						end FillObjLists;
	
						var ^CObjList pxA, pxB;
						var bool bAdd = true;
						
						begin SetListPtr;
							var int iUsed = 0;
							var int j, iL = pxSlot^.NumXtra(false);
							for (j=0) cond(j<iL) iter(++j)do
								if(pxSlot^.GetXtra(false, j)^.m_bUsed)then
									if(cast<CInvCard>(pxSlot^.GetXtra(false, j)^.GetWindow())!= null &&
										cast<CInvCard>(pxSlot^.GetXtra(false, j)^.GetWindow())^.GetObj().IsValid())then
										++iUsed;
									else
										pxSlot^.GetXtra(false, j)^.m_bUsed = false;
									endif;
								endif;
							endfor;
							if(pxInv^.Count() >= iUsed)then
								pxA = ^xInvList;
								pxB = ^xCardList;
							else
								pxA = ^xCardList;
								pxB = ^xInvList;
								bAdd = false;
							endif;
						end SetListPtr;
						
						var int j, iM = pxA^.NumEntries();
						for(j=0) cond(j<iM) iter(++j)do
							if(pxA^[j].IsValid())then		
								if(pxB^.FindEntry(pxA^[j]) < 0)then
									if(bAdd)then	
										var string sItemBitmap = pxA^[j].GetObj()^.GetName();
										var int iP = sItemBitmap.FindRev('_');
										if(iP >= 0)then
											sItemBitmap.Delete(iP, sItemBitmap.GetLength()-iP);
										endif;											
										UpdateInvCard(i, sItemBitmap + ".tga", pxA^[j], pxSlot^.FindFreeXtraSlotR());
										UpdateXtras();
									else
										var CClntHndl xInvalid;
										UpdateInvCard(i, "", xInvalid, j);
									endif;
								endif;
							endif;
						endfor;
					endif;
				endif;
			endif;
		endfor;
	endproc;*/
	
	///called when tech tree changes
	export proc void OnTechtreeChange()
		m_iTimerCountdown=0;
		//UpdateXtras();
	endproc;
	
	//called by CGameInst on start loading
	export proc void OnLoadStart()
		//L KLog.LogSpam("UI.NewPyramid","CNewPyramid::OnLoadStart");
		// set loading flag (used in handle message to prevent card creation during loading)
		m_bIsLoading = true;
		// unsubscribe for object changes during loading (objects may be in an inconsistent state during loading)
		CGameWrap.GetSubscriptionMgr().UnsubscribeObjChanges(this, CSubscriptionMgr.CT_NewPlayerUnit, "");
		CGameWrap.GetSubscriptionMgr().UnsubscribeObjChanges(this, CSubscriptionMgr.CT_ObjInventory, "");
		// delete all entries in client representation of unit pyramid
		Clear();
	endproc;
	
	//called by CGameInst after loading finished
	export proc void OnLoadEnd()
		//L KLog.LogSpam("UI.NewPyramid","CNewPyramid::OnLoadEnd");
		//MakeInvIcon();
		// build up pyramid after loading
		BuildUpPyramid();
		// resubscribe for object changes
		CGameWrap.GetSubscriptionMgr().SubscribeObjChanges(this, CSubscriptionMgr.CT_NewPlayerUnit, "");
		CGameWrap.GetSubscriptionMgr().SubscribeObjChanges(this, CSubscriptionMgr.CT_ObjInventory, "");
		// clear loading flag
		m_bIsLoading = false;
		m_bFettich=true;
		//CheckPyramid();
	endproc;
	
	export proc void RebuildFull()
		Clear();
		BuildUpPyramid();
		UpdateAllBitmaps();	
	endproc;
	
	// requests all units owned by current player and fills pyramid
	export proc void BuildUpPyramid()
		//L KLog.LogSpam("UI.NewPyramid","CNewPyramid::BuildUpPyramid "+m_sName+" #"+ms_iInstanceCount.ToString());
		var CObjQueryCln xQuery;
		xQuery.SetType("ANML");
		xQuery.SetType("BLDG",true);
		xQuery.SetType("CHTR",true);
		xQuery.SetType("VHCL",true);
		xQuery.SetType("SHIP",true);
		xQuery.SetType("PyCO",true);
		xQuery.SetOwner(CClientWrap.GetClient().GetPlayerID());
		var CObjList xObjects;
		xQuery.Execute(xObjects);
		//L KLog.LogSpam("UI.NewPyramid","BuildUpPyramid\n #player units='"+xObjects.NumEntries().ToString()+"'\n");
		var int i;
		for(i=0)cond(i<xObjects.NumEntries())iter(i++)do
			var ^CObj pxObj=xObjects[i].GetObj();
			if(pxObj==null)then continue; endif;
			var string sObjName=pxObj^.GetName();
			var int iObjLevel=-1;
			var int iObjSlotID=-1;
			var ^CAttribs pxAttr = pxObj^.GetAttribs();
			if(pxAttr!=null)then
				if(!pxAttr^.GetValueBool("unit_count") && pxObj^.GetType()!="PyCO")then
					continue;
				endif;
				iObjLevel = pxAttr^.GetValueInt("level");
				iObjSlotID = pxAttr^.GetValueInt("clientpyramid_slotid");
			endif;
			var int iUnitSlot=GetSlotInPyramid(xObjects[i]);
			var int iUnitSlotLevel=m_pxTribeView^.SlotIndex2Level(iUnitSlot);
			var string sCaste, sItem, sClass;

			CreateCard(iObjLevel, sCaste, sClass, xObjects[i],iObjSlotID,true);
		endfor;
		TryAdditionalCards();
	endproc;

	proc bool ObjectHasCard(CClntHndl p_xObjHandle)
		var int i;
		for(i=0)cond(i<m_apxAddCards.NumEntries())iter(i++)do
			var ^CPyramidCard pxChar = m_apxAddCards[i];
			var CClntHndl xHndl = pxChar^.GetObj();
			if(!xHndl.IsValid())then continue; endif;
			if(xHndl==p_xObjHandle)then return true; endif;
		endfor;
		for(i=0)cond(i<m_pxTribeView^.TotalSlotCount())iter(i++)do
			var ^CTribeViewLayoutMgr.CSlotInfo pxSlotInfo=m_pxTribeView^.GetSlotInfo(i);
			if(pxSlotInfo^.m_bUsed == true)then
				var ^CPyramidCard pxChar = GetCard(i);
				var CClntHndl xHndl = pxChar^.GetObj();
				if(!xHndl.IsValid())then continue; endif;
				if(xHndl==p_xObjHandle)then return true; endif;
			endif;
		endfor;
		return false;
	endproc;

	///Handle Message
	export proc bool HandleMessage(ref CEvtPointer p_rxEvt)
		//var string sClass = p_rxEvt.GetClass().ToString();
		if(p_rxEvt.GetClass()==CSubscriptionMgr.GetEvtClass_ObjChange())then
			// if game is loading or pyramid is in PointBuy-Mode, dont care about game obj events, pyramid will be initialized after loading ends
			if(m_bIsLoading || m_bPBMode)then /*KLog.LogSpam("UI.NewPyramid","CNewPyramid::HandleMessage SKIP during loading or point buy "+m_sName);*/ return true; endif;
			var CClntHndl xObjHandle;
			var bitset dwTypes, dwAttribGroups;
			var ^CPyramidCard pxCard;
			if(CSubscriptionMgr.EvtGetData_ObjChange(p_rxEvt,xObjHandle,dwTypes,dwAttribGroups))then
				if((dwTypes & CSubscriptionMgr.CT_NewPlayerUnit) != 0d)then
					var int iLvl, iPrefSlot;
					var string sCaste, sItem, sClass;
					var ^CObj pxObj=xObjHandle.GetObj();
					if(pxObj!=null)then
						var ^CAttribs pxAttribs = pxObj^.GetAttribs();
						if(pxAttribs != null)then
							if(!pxAttribs^.GetValueBool("unit_count") && pxObj^.GetType()!="PyCO")then
								return false;
							else
								iLvl=pxAttribs^.GetValueInt("level");
								sClass=CHelpMenu.GetObjHelpitemKey(pxObj);
								iPrefSlot=pxAttribs^.GetValueInt("clientpyramid_slotid");
							endif;
						endif;
						CreateCard(iLvl, sCaste, sClass, xObjHandle);
					endif;
				endif;
			endif;
			return true;
		endif;
		var int iCount = 0;
		//left mouse down
		if(p_rxEvt.GetClass().ToString()=="sMLDown")then
			//L KLog.LogWarn("UI.NewPyramid","CNewPyramid::LMB Down");
			if(m_bPBMode)then return false; endif;
			var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
			if(!Msg.EventKeyModShift(p_rxEvt))then pxSel^.Clear(); endif;
			m_bDragBox = true;
			m_iBX = p_rxEvt.GetInt16A();
			m_iBY = p_rxEvt.GetInt16B();
			m_xPoint.SetX(m_iBX);
			m_xPoint.SetY(m_iBY);
			var point xRealPos = m_xPoint-GetAbsPos();
			m_iBX = xRealPos.GetX();
			m_iBY = xRealPos.GetY();
			m_xRect.SetLeft(m_iBX);
			m_xRect.SetTop(m_iBY);
			m_xRect.SetRight(m_iBX+1);
			m_xRect.SetBottom(m_iBY+1);
			var int i, iC = m_pxTribeView^.TotalSlotCount();
			var int iHitSlotID = m_pxTribeView^.SlotHitTest(m_xPoint);
			if(iHitSlotID!=-1)then
				if(!Msg.EventKeyModShift(p_rxEvt) && m_pxTribeView^.SlotRectTestCount(m_xRect)>0)then
					for(i=0)cond(i<iC)iter(i++)do
						if(m_pxTribeView^.GetSlotInfo(i)^.m_bUsed==true)then
							var ^CPyramidCard pxCard = GetCard(i);
							if(pxCard!=null)then
								pxCard^.SetSelected(false);
								if(pxSel^.FindEntry(pxCard^.GetObjToSelect()) >= 0)then
									pxSel^.RemEntry(pxCard^.GetObjToSelect());
								endif;
							endif;
						endif;
					endfor;
				endif;
			endif;
			var bool bACHidden = CMirageClnMgr.Get().IsACHidden();
			m_pxFrame^.SetVisible(!bACHidden);
			m_pxFrame^.SetPos(0,0);
			m_pxFrame^.SetSize(2000 * CGameInst.ms_iUIScaleFactor,2000 * CGameInst.ms_iUIScaleFactor);
			m_pxFrame^.SetAlwaysOnTop(true);
			m_pxFrame^.SetRect(m_xRect);
			CWindowMgr.Get().SetCapture(this);
			m_bMouseCaptured=true;
			var ^CUTCmdSender pxUTCmdSender=CClientWrap.GetUTCmdSender();
			if(pxUTCmdSender!=null)then
				pxUTCmdSender^.SelectionChanged(pxSel^,false,true,Msg.EventKeyModControl(p_rxEvt),Msg.EventKeyModShift(p_rxEvt),Msg.EventKeyModAlt(p_rxEvt));				
			endif;
			return true;
		endif;
		//mouse move
		if(p_rxEvt.GetClass().ToString()=="sMMove")then
			if(!m_bDragBox)then return false; endif;
			m_iX = p_rxEvt.GetInt16A();
			m_iY = p_rxEvt.GetInt16B();
			m_xPoint.SetX(m_iX);
			m_xPoint.SetY(m_iY);
			var point xRealPos = m_xPoint-GetAbsPos();
			m_iX = xRealPos.GetX();
			m_iY = xRealPos.GetY();
			var int iMin,iMax;
			iMin=Math.Min(m_iX,m_iBX);
			iMax=Math.Max(m_iX,m_iBX);
			m_xRect.SetLeft(iMin);
			m_xRect.SetRight(iMax);
			iMin=Math.Min(m_iY,m_iBY);
			iMax=Math.Max(m_iY,m_iBY);
			m_xRect.SetTop(iMin);
			m_xRect.SetBottom(iMax);
			m_pxFrame^.SetRect(m_xRect);
			//m_pxFrame^.SetAlwaysOnTop(true);
			return true;
		endif;
		//left mouse up
		if(p_rxEvt.GetClass().ToString()=="sMLUp")then
			m_bDragBox = false;
			var bool bSelectionChanged=false;
			var bool bUseDragBox=false;
			var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
			var int i;
			if(!Msg.EventKeyModShift(p_rxEvt) && ((m_xRect.GetWidth()>1)||(m_xRect.GetHeight()>1)) )then
				bUseDragBox=true;
				var int i, iC = m_pxTribeView^.TotalSlotCount();
				for(i=0)cond(i<iC)iter(i++)do
					if(m_pxTribeView^.GetSlotInfo(i)^.m_bUsed==true)then
						var ^CPyramidCard pxCard = GetCard(i);
						if(pxCard!=null)then
							pxCard^.SetSelected(false);
							var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
							if(pxSel^.FindEntry(pxCard^.GetObjToSelect()) >= 0)then
								pxSel^.RemEntry(pxCard^.GetObjToSelect());
								bSelectionChanged=true;
							endif;
						endif;
					endif;
				endfor;
			endif;
			iCount = m_pxTribeView^.SlotRectTestCount(m_xRect);
			var bool bUnitSelected=false;
			for(i=0)cond(i<iCount)iter(i++)do
				var int iSlotID = m_pxTribeView^.SlotRectTestGetSlot(m_xRect, i);
				var ^CPyramidCard pxChar = GetCard(iSlotID);
				if(pxChar!=null)then
					var ^CObj pxObj = pxChar^.GetObjToSelect().GetObj();
					if(pxObj==null || !pxObj^.IsSelectable())then continue; endif;
					var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
					pxSel^.Include(pxChar^.GetObjToSelect());
					bUnitSelected=true;
					pxChar^.SetSelected(true);
					bSelectionChanged=true;
				endif;
			endfor;
			if(bUnitSelected)then
				CGameInputController.ms_xUISoundMgr.PlayFeedbackSound("selected");
			endif;
			CWindowMgr.Get().ReleaseCapture(this);
			m_bMouseCaptured=false;
			m_pxFrame^.SetVisible(false);
			var ^CUTCmdSender pxUTCmdSender=CClientWrap.GetUTCmdSender();
			if(bSelectionChanged && pxUTCmdSender!=null)then
				pxUTCmdSender^.SelectionChanged(pxSel^,bUseDragBox,true,Msg.EventKeyModControl(p_rxEvt),Msg.EventKeyModShift(p_rxEvt),Msg.EventKeyModAlt(p_rxEvt));
			endif;
			return true;
		endif;
		//right mouse down
		if(p_rxEvt.GetClass().ToString()=="sMRDown")then
			if(IsPointBuyMode() && !m_bPreviewMode)then
				m_iBX = p_rxEvt.GetInt16A();
				m_iBY = p_rxEvt.GetInt16B();
				m_xPoint.SetX(m_iBX);
				m_xPoint.SetY(m_iBY);
				var point xRealPos = m_xPoint-GetAbsPos();
				m_iBX = xRealPos.GetX();
				m_iBY = xRealPos.GetY();
//				var int iHitSlotID=m_pxTribeView^.SlotHitTest(xRealPos);
//				if(iHitSlotID!=-1)then
//					var ^CPyramidCard pxCard=GetCard(iHitSlotID);
//					if(pxCard!=null)then
//						m_pxPBOwner^.DeleteChar(iHitSlotID,pxCard);
//					endif;
//				endif;
				//m_pxFrame^.SetVisible(true);
				//m_pxFrame^.SetAlwaysOnTop(true);
			endif;
			return true;
		endif;
		if(p_rxEvt.GetClass().ToString()=="sMRUp")then
			CWindowMgr.Get().ReleaseCapture(this);
			m_bMouseCaptured=false;
			m_pxFrame^.SetVisible(false);
			return true;
		endif;
		if(p_rxEvt.GetClass().ToString()=="sMRDbl")then
			return true;
		endif;
		return false;
	endproc;
	
	///return food cost to level someone from level p_iFromLevel to level p_iToLevel
	export static proc int GetScalpCost(int p_iFromLevel, int p_iToLevel)
		if(p_iToLevel <= p_iFromLevel)then return 0; endif;
		var int iCost = 0;
		p_iFromLevel++;
		while(p_iFromLevel <= p_iToLevel)do
			iCost += GetScalpCostForLevel(p_iFromLevel);
			p_iFromLevel++;
		endwhile;
		return iCost;
	endproc;
	
	///return food currently available
	export proc int GetScalpsAvailable()
		return CGameWrap.GetClient().GetPlayer().GetAttribs()^.GetValueInt("iron");
	endproc;
	
	///called to get food cost for the level
	export static proc int GetScalpCostForLevel(int p_iLevel)
		if((p_iLevel<0)||(p_iLevel>4))then return 0;endif;
		if(ms_aiFoodCostsPerLevel[p_iLevel]>=0)then return ms_aiFoodCostsPerLevel[p_iLevel];endif;
		var ^CAttribs pxAttr = CGameWrap.GetClient().GetPlayer().GetAttribs();
		if(pxAttr != null)then
			var int iCost = pxAttr^.GetValueInt("foodcost_lvl_"+p_iLevel.ToString());
			if(!ms_bDisableCache)then
				ms_aiFoodCostsPerLevel[p_iLevel]=iCost;
			endif;
			return iCost;
		endif;
		return 0;
	endproc;
	
	///Called to check for enough food for level
	export static proc bool HasEnoughScalpsForLevel(int p_iLevel)
		var ^CAttribs pxAttr = CGameWrap.GetClient().GetPlayer().GetAttribs();
		if(pxAttr != null && (p_iLevel>0 && p_iLevel<5))then
			return (GetScalpCostForLevel(p_iLevel)<=pxAttr^.GetValueInt("iron"));
		endif;
		return false;
	endproc;
	
	///return true if character can be leveled to target level
	export proc bool CanLevel(CClntHndl p_xObjHandle, int p_iDeltaLevel)
		var ^CPyramidCard pxCard = FindCardByHandle(p_xObjHandle);
		return CanLevel(pxCard, p_iDeltaLevel);
	endproc;
	
	///return true if character can be leveled to target level
	export proc bool CanLevel(^CPyramidCard p_pxCard, int p_iDeltaLevel)
		if(p_pxCard == null)then return false; endif;
		var int iLevel = p_pxCard^.GetLevel();
		var int iTargetLevel = iLevel + p_iDeltaLevel;
		if(iLevel == iTargetLevel)then
			return true;
		endif;
		if(iLevel > iTargetLevel)then
			if(iTargetLevel < 0)then
				return false;
			endif;
		else
			if(iTargetLevel > 4)then
				return false;
			endif;
			if(GetScalpsAvailable() < GetScalpCost(iLevel, iTargetLevel))then
				return false;
			endif;
		endif;
		if(m_pxTribeView^.FindFreeSlot(iTargetLevel)< 0)then
			return false;
		endif;
		return true;
	endproc;
	
	///called when char can level
	export proc bool CanLevel(int p_iSlotID, int p_iNewLevel)
		if(p_iNewLevel<0 || p_iNewLevel>4)then return false; endif;
		var int iLevel=m_pxTribeView^.SlotIndex2Level(p_iSlotID);
		if(iLevel>p_iNewLevel)then return false; endif;
		var int iNewSlotID = m_pxTribeView^.FindFreeSlot(p_iNewLevel);
		if(iNewSlotID != -1)then
			return true;
		endif;
		return false;
	endproc;

	///change level of character (if possible)
	export proc void LevXel(CClntHndl p_xObjHandle, int p_iDeltaLevel)
		if(!CanLevel(p_xObjHandle, p_iDeltaLevel))then
			return;
		endif;
		var ^CPyramidCard pxCard = FindCardByHandle(p_xObjHandle);
		if(pxCard == null)then
			//L KLog.LogSpam("UI.Pyramid.Game","Level() : card not found");
			//pxCard^.SetLevel(pxCard^.GetLevel()+p_iDeltaLevel);
			return;
		endif;
		pxCard^.SubmitChanges();
	endproc;

	///delete all cards
	export proc void Clear()
		//L KLog.LogSpam("UI.NewPyramid","CNewPyramid::Clear "+m_sName+" #"+ms_iInstanceCount.ToString()+"\n");
		var int i, iC;
		// delete all additional cards (do this first because KillCard fills up unused slots with additional cards)
		while(m_apxAddCards.NumEntries()>0)do
			var ^CPyramidCard pxCard = m_apxAddCards[0];
			System.Assert(pxCard!=null);
			KillCard(m_apxAddCards[i]);
		endwhile;
		m_apxNormalCards = 0;
		// delete all cards from pyramid
		iC = m_pxTribeView^.TotalSlotCount();
		for(i=0)cond(i<iC)iter(i++)do
			if(m_pxTribeView^.GetSlotInfo(i)^.m_bUsed == true)then
				KillCard(GetCard(i));
			endif;
		endfor;
		//L KLog.LogSpam("UI.NewPyramid","CNewPyramid::Clear done.\n");
	endproc;
	
//	//called to check if free slots available
//	export proc bool HasFreeSlots(int p_iLevel)
//		if(p_iLevel<0 || p_iLevel>4)then return false; endif;
//		var int iNumFree = m_pxTribeView^.NumFreeSlots(p_iLevel);
//		var bool bIsSupplyOn = CMirageClnMgr.Get().IsSupplyOn();
//		if(!bIsSupplyOn)then
//			return iNumFree>0;
//		else
//			return true;
//		endif;
//	endproc;
	
//	//called to check if free slots available
	export proc bool HasFreeSlots(int p_iLevel)
//	export proc bool TestGGG(int p_iLevel)
		if(p_iLevel<0 || p_iLevel>4)then return false; endif;
		var bool bIsSupplyOn = CMirageClnMgr.Get().IsSupplyOn(), bElse = false;
		if(!bIsSupplyOn)then
			var bool bCheckBonus=false;
			var ^CAttribs pxAttr;
			var ^CPlayer pxPlayer=^(CGameWrap.GetClient().GetPlayer());
			if(pxPlayer!=null)then
				pxAttr=pxPlayer^.GetAttribs();
				if(pxAttr!=null)then
					bCheckBonus=true;
				endif;
			endif;
//			var int iNumFree = m_pxTribeView^.NumFreeSlots(p_iLevel);
			var int iNumFree = m_pxTribeView^.NumFreeSlots(p_iLevel)-NumPrePyCO(p_iLevel);
			if(bCheckBonus)then
				var int iCur=pxAttr^.GetValueInt("objects_lvl_"+p_iLevel.ToString())+pxAttr^.GetValueInt("virtual_units_"+p_iLevel.ToString());
				var array int aiMaxUnits;
				aiMaxUnits.AddEntry(25);
				aiMaxUnits.AddEntry(15);
				aiMaxUnits.AddEntry(8);
				aiMaxUnits.AddEntry(3);
				aiMaxUnits.AddEntry(1);
				var int i, iC=aiMaxUnits.NumEntries();
				for(i=0)cond(i<iC)iter(i++)do
					aiMaxUnits[i]+=Math.Max(0,pxAttr^.GetValueInt("ac_bonus_"+p_iLevel.ToString()));
				endfor;
				return iCur<aiMaxUnits[p_iLevel];
			else
				return iNumFree>0;
			endif;
		else
			return true;
		endif;
	endproc;
	
	///called to check if maximum number of character is higher than max_units of player
	export proc bool MaximumReached()
		var ^CPlayer pxPlayer = ^(CGameWrap.GetClient().GetPlayer());
		if(pxPlayer==null)then return false; endif;
		var bool bIsSupplyOn = CMirageClnMgr.Get().IsSupplyOn();
		var ^CAttribs pxAttr = pxPlayer^.GetAttribs();
		var int iMax, iCount = 0;
		if(pxAttr!=null)then
			iMax = pxAttr^.GetValueInt("max_units");
			var int iDff=pxAttr^.GetValueInt("ai_level");
			var int iVirtualUnits=0;
			if(bIsSupplyOn)then
				iMax = pxAttr^.GetValueInt("max_supply");
				iCount = pxAttr^.GetValueInt("supply");
				iCount += pxAttr^.GetValueInt("virtual_supply");
				if(iDff==7)then
					iMax += 30;
				elseif(iDff==8)then
					iMax += 60;
				elseif(iDff==9)then
					iMax += 100;
				endif;
			else
//				iCount = pxAttr^.GetValueInt("units");
				iCount = pxAttr^.GetValueInt("units")-AllPrePyCO();
				var int i, iC = 5;
				for(i=0) cond(i<iC) iter(++i)do
					iCount += pxAttr^.GetValueInt("virtual_units_"+i.ToString());
//					iVirtualUnits+=pxAttr^.GetValueInt("virtual_units_"+i.ToString());
				endfor;
				if(iDff==7)then
					iMax += 9;
				elseif(iDff==8)then
					iMax += 22;
				elseif(iDff==9)then
					iMax += 41;
				endif;
			endif;
		endif;
		return iCount>=iMax;
	endproc;
	
	///find card associated with a given object handle
	export proc ^CPyramidCard FindCardByHandle(CClntHndl p_xHandle)
		var int i, iC = m_pxTribeView^.TotalSlotCount();
		if(p_xHandle.IsValid()==true)then
			for(i=0)cond(i<iC)iter(i++)do
				var ^CTribeViewLayoutMgr.CSlotInfo pxSI = m_pxTribeView^.GetSlotInfo(i);
				if(pxSI^.m_bUsed == true)then
					var ^CPyramidCard pxChar=cast<CPyramidCard>(pxSI^.GetWindow());
					if(pxChar!=null && pxChar^.GetObj() == p_xHandle)then
						return pxChar;
					endif;
				endif;
			endfor;
		endif;
		return null;
	endproc;

	///Sets pyramid to Alert View
	export proc bool CollapsedView()
		m_iMode = MODE_COLLAPSE;
		CGameInputController.ms_xUISoundMgr.PlayFeedbackSoundEvent("ui_pyramid_close","",CSoundMgrCln.SOUND_VOLTRACK_GLOBAL);
		SetBitmap(CClientWrap.GetUrsRelPath()+"/Data/Base/UI/hud/pyramid_closed.tga");
		var bool bACHidden = CMirageClnMgr.Get().IsACHidden();
		SetVisible(!bACHidden);
		SetSize(181 * CGameInst.ms_iUIScaleFactor,548 * CGameInst.ms_iUIScaleFactor);
		SetBitmapAlignment(0);
		m_pxFrame^.SetVisible(false);
		var int i, iC = m_pxTribeView^.TotalSlotCount();
		for(i=0)cond(i<iC) iter (++i)do
			var ^CTribeViewLayoutMgr.CSlotInfo pxSI = m_pxTribeView^.GetSlotInfo(i);
			if(pxSI^.m_bUsed == true)then
				var ^CPyramidCard pxChar = GetCard(i);
				pxChar^.SetDraggable(false);
			endif;
			/*if(pxSI!=null)then
				var int iJ, iNumUps = pxSI^.NumXtra(true);
				for (iJ=0) cond(iJ<iNumUps) iter(++iJ)do
					var ^CUpdateSlot pxUS = cast <CUpdateSlot>(pxSI^.GetXtra(true, iJ)^.GetWindow());
					pxSI^.GetXtra(true, iJ)^.m_bActive=false;
					pxUS^.SetVisible(false);
				endfor;
				var int iNumUpsI = pxSI^.NumXtra(false);
				for (iJ=0) cond(iJ<iNumUpsI) iter(++iJ)do
					var ^CStaticCtrl pxIS = cast <CStaticCtrl>(pxSI^.GetXtra(false, iJ)^.GetWindow());
					pxSI^.GetXtra(false, iJ)^.m_bActive=false;
					pxIS^.SetVisible(false);
				endfor;
			endif;*/
		endfor;
		m_pxTribeView^.SetModeCollapse();
		m_pxTribeView^.Tick();
		return true;
	endproc;

	///Sets pyramid to small view
	export proc bool SmallView()
		m_iMode = MODE_SMALL;
		CGameInputController.ms_xUISoundMgr.PlayFeedbackSoundEvent("ui_pyramid_open","",CSoundMgrCln.SOUND_VOLTRACK_GLOBAL);
		m_pxTribeView^.SetModeSmall();
		SetBitmap(CClientWrap.GetUrsRelPath()+"/Data/Base/UI/hud/pyramid_open.tga");
		var bool bACHidden = CMirageClnMgr.Get().IsACHidden();
		SetVisible(!bACHidden);
		SetSize(181 * CGameInst.ms_iUIScaleFactor,548 * CGameInst.ms_iUIScaleFactor);
		var int i, iC = m_pxTribeView^.TotalSlotCount();
		for(i=0)cond(i<iC) iter (++i)do
			var ^CTribeViewLayoutMgr.CSlotInfo pxSI = m_pxTribeView^.GetSlotInfo(i);
			if(pxSI^.m_bUsed == true)then
				var ^CPyramidCard pxChar = GetCard(i);
				pxChar^.SetDraggable(!m_bPreviewMode);
			endif;
			/*if(pxSI!=null)then
				var int iJ, iNumUps = pxSI^.NumXtra(true);
				for (iJ=0) cond(iJ<iNumUps) iter(++iJ)do
					var ^CUpdateSlot pxUS = cast <CUpdateSlot>(pxSI^.GetXtra(true, iJ)^.GetWindow());
					pxSI^.GetXtra(true, iJ)^.m_bActive=false;
					pxUS^.SetVisible(false);
				endfor;
				var int iNumUpsI = pxSI^.NumXtra(false);
				for (iJ=0) cond(iJ<iNumUpsI) iter(++iJ)do
					var ^CStaticCtrl pxIS = cast <CStaticCtrl>(pxSI^.GetXtra(false, iJ)^.GetWindow());
					pxSI^.GetXtra(false, iJ)^.m_bActive=false;
					pxIS^.SetVisible(false);
				endfor;
			endif;*/
		endfor;
		m_pxTribeView^.Tick();
		return true;
	endproc;

	/*Sets pyramid to full view
	export proc bool LargeView();
		m_pxTribeView^.SetModeFull();
		SetBitmap(CClientWrap.GetUrsRelPath()+"/Data/Base/UI/Pyramid_b.tga");
		SetVisible(true);
		SetSize(470 * CGameInst.ms_iUIScaleFactor,548 * CGameInst.ms_iUIScaleFactor);
		var int i, iC = m_pxTribeView^.TotalSlotCount();
		for(i=0)cond(i<iC) iter (++i)do
			var ^CTribeViewLayoutMgr.CSlotInfo pxSI = m_pxTribeView^.GetSlotInfo(i);
			if(pxSI^.m_bUsed == true)then
				var ^CPyramidCard pxChar = GetCard(i);
				pxChar^.SetDraggable(true);
			endif;
			if(pxSI!=null)then
				var int iJ, iNumUps = pxSI^.NumXtra(true);
				for (iJ=0) cond(iJ<iNumUps) iter(++iJ)do
					var ^CUpdateSlot pxUS = cast <CUpdateSlot>(pxSI^.GetXtra(true, iJ)^.GetWindow());
					pxUS^.SetDraggable(false);
					if(pxSI^.m_bUsed == true)then
						pxSI^.GetXtra(true, iJ)^.m_bActive=false;
						pxUS^.SetVisible(true);
					else
						pxSI^.GetXtra(true, iJ)^.m_bActive=true;
						pxUS^.SetVisible(false);
					endif;
				endfor;
				var int iNumUpsI = pxSI^.NumXtra(false);
				for (iJ=0) cond(iJ<iNumUpsI) iter(++iJ)do
					var ^CStaticCtrl pxIS = cast <CStaticCtrl>(pxSI^.GetXtra(false, iJ)^.GetWindow());
					if(pxSI^.m_bUsed == true)then
						pxSI^.GetXtra(false, iJ)^.m_bActive=false;
						pxIS^.SetVisible(true);
					else
						pxSI^.GetXtra(false, iJ)^.m_bActive=true;
						pxIS^.SetVisible(false);
					endif;
				endfor;
			endif;
		endfor;
		UpdateXtras();
		m_pxTribeView^.Tick();
		return true;
	endproc;*/

	///old update
	export proc bool Update()
		return true;
	endproc;

	///called to update group
	/*proc bool OnUpdateGroup()
		var int i,iC = m_pxTribeView^.TotalSlotCount();
		for(i=0)cond(i<iC) iter (++i)do
			if(m_pxTribeView^.GetSlotInfo(i)^.m_bUsed == true)then
				var int j,iD = CGroupMgr.Get().GetMaxGroupCount();
				//GetCard(i)^.ClearGrouped();
				for(j=1)cond(j<iD) iter (++j)do
					if(CGroupMgr.Get().GetGroupList(j).FindEntry(GetCard(i)^.GetObjToSelect())!=-1)then
						//GetCard(i)^.AddGrouped(j);
					endif;
				endfor;
				if(CGroupMgr.Get().GetGroupList(0).FindEntry(GetCard(i)^.GetObjToSelect())!=-1)then
					//GetCard(i)^.AddGrouped(0);
				endif;
				//GetCard(i)^.UpdateBitmaps();
			endif;
		endfor;
		return true;
	endproc;*/

	///returns all selected cards
	export proc void GetSelection(ref array ^CPyramidCard po_rapxSelection)
		po_rapxSelection=0;
		var int i, iC = m_pxTribeView^.TotalSlotCount();
		for(i=0)cond(i<iC)iter(i++)do
			if(m_pxTribeView^.GetSlotInfo(i)^.m_bUsed == true)then
				var ^CPyramidCard pxChar = GetCard(i);
				if(pxChar^.IsSelected())then
					po_rapxSelection.AddEntry(pxChar);
				endif;
			endif;
		endfor;
	endproc;
	
	// for debugging purpose only
	export proc void CheckPyramid()
		var int i, iC = m_pxTribeView^.TotalSlotCount();
		var int iCountUsedSlots = 0;
		var int iCountBlockedSlots = 0;
		var int iNumFreeSlotsL0 = m_pxTribeView^.NumFreeSlots(0);
		var int iNumFreeSlotsL1 = m_pxTribeView^.NumFreeSlots(1);
		var int iNumFreeSlotsL2 = m_pxTribeView^.NumFreeSlots(2);
		var int iNumFreeSlotsL3 = m_pxTribeView^.NumFreeSlots(3);
		var int iNumFreeSlotsL4 = m_pxTribeView^.NumFreeSlots(4);
		for(i=0)cond(i<iC)iter(i++)do
			var ^CTribeViewLayoutMgr.CSlotInfo pxSlotInfo=m_pxTribeView^.GetSlotInfo(i);
			KLog.LogSpam("UI.NewPyramid","  slotinfo["+i.ToString()+"/"+m_pxTribeView^.SlotIndex2Level(i).ToString()+"] name="+pxSlotInfo^.m_sName+"\n");
			if(pxSlotInfo^.m_bBlocked)then iCountBlockedSlots++; endif;
			if(pxSlotInfo^.m_bUsed == true)then
				iCountUsedSlots++;
				var ^CPyramidCard pxChar = GetCard(i);
				var CClntHndl xHndl = pxChar^.GetObj();
				if(!xHndl.IsValid())then continue; endif;
				var ^CObj pxObj = xHndl.GetObj();
			endif;
		endfor;
		KLog.LogSpam("UI.NewPyramid","CheckPyramid\n used#="+iCountUsedSlots.ToString()
							+"\n blocked#="+iCountBlockedSlots.ToString()
							+"\n free#L4="+iNumFreeSlotsL4.ToString()
							+"\n free#L3="+iNumFreeSlotsL3.ToString()
							+"\n free#L2="+iNumFreeSlotsL2.ToString()
							+"\n free#L1="+iNumFreeSlotsL1.ToString()
							+"\n free#L0="+iNumFreeSlotsL0.ToString()
							+"\n addcards#="+m_apxAddCards.NumEntries().ToString()
							+"\n");
		// check objects owned by player
		var CObjQueryCln xQuery;
		xQuery.SetOwner(CClientWrap.GetClient().GetPlayerID());
		xQuery.SetType("ANML");
		//xQuery.SetType("BLDG",true);
		xQuery.SetType("CHTR",true);
		xQuery.SetType("VHCL",true);
		xQuery.SetType("SHIP",true);
		xQuery.SetType("PyCO",true);
		var CObjList xObjects;
		xQuery.Execute(xObjects);
		for(i=0)cond(i<xObjects.NumEntries())iter(i++)do
			var ^CObj pxObj=xObjects[i].GetObj();
			if(pxObj==null)then continue; endif;
			var string sObjName=pxObj^.GetName();
			var int iObjLevel=-1;
			var int iObjSlotID=-1;
			var ^CAttribs pxAttr = pxObj^.GetAttribs();
			if(pxAttr!=null)then
				iObjLevel = pxAttr^.GetValueInt("level");
				iObjSlotID = pxAttr^.GetValueInt("clientpyramid_slotid");
			endif;
			var int iUnitSlot=GetSlotInPyramid(xObjects[i]);
			var int iUnitSlotLevel=m_pxTribeView^.SlotIndex2Level(iUnitSlot);
			KLog.LogSpam("UI.NewPyramid","-> "+sObjName+" lvl="+iObjLevel.ToString()+" pref_slotid="+iObjSlotID.ToString()+" PyramidSlot=["+iUnitSlot.ToString()+"/"+iUnitSlotLevel.ToString()+"]\n");
			if(iUnitSlot<0)then KLog.LogSpam("UI.NewPyramid","unit has no slot\n"); endif;
		endfor;
		if(xObjects.NumEntries()!=iCountUsedSlots)then KLog.LogSpam("UI.NewPyramid","some units are not in pyramid (used slots="+iCountUsedSlots.ToString()+" total units="+xObjects.NumEntries().ToString()+")\n"); endif;
	endproc;

	proc int GetSlotInPyramid(CClntHndl p_xHndl)
		var int i;
		for(i=0)cond(i < m_pxTribeView^.TotalSlotCount())iter(i++)do
			var ^CTribeViewLayoutMgr.CSlotInfo pxSlotInfo=m_pxTribeView^.GetSlotInfo(i);
			if(pxSlotInfo^.m_bUsed == true)then
				var ^CPyramidCard pxChar = GetCard(i);
				var CClntHndl xHndl = pxChar^.GetObj();
				if(!xHndl.IsValid())then
					continue;
				endif;
				if(xHndl==p_xHndl)then
					return i;
				endif;
			endif;
		endfor;
		return -1;
	endproc;

	///update selected property of cards
	export proc void UpdateSelection()
		//L KLog.LogSpam("UI.NewPyramid","CNewPyramid::UpdateSelection");
		//CheckPyramid();
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		var CObjList xObjsToSelect;
		var int iA, iAC=pxSel^.NumEntries();
		for(iA=0)cond(iA<iAC)iter(iA++)do
			var CClntHndl xHndl = pxSel^[iA];
			var ^CObj pxObj = xHndl.GetObj();
			if(pxObj==null)then continue; endif;
			xObjsToSelect.AddEntry(xHndl);
			if(pxObj^.GetType()=="CHTR")then continue; endif;
			var ^CAttribs pxAttr = pxObj^.GetAttribs();
			if(pxAttr==null)then continue; endif;
			var string sRiderGuid = pxAttr^.GetValue("passenger_guids");
			if(sRiderGuid.IsEmpty())then continue; endif;
			var array string asTok;
			sRiderGuid.Split(asTok,"\n",true);
			var int iB, iBC = asTok.NumEntries();
			for(iB=0)cond(iB<iBC)iter(iB++)do
				var string sDGuid = asTok[iB];
				var CGuid xGuid; xGuid.FromString(sDGuid);
				var ^CObj pxPassenger = CClientWrap.GetObjMgr().GetObj(xGuid);
				if(pxPassenger == null)then continue; endif;
				xObjsToSelect.AddEntry(pxPassenger^.GetHandle());
				if(pxPassenger^.GetType()=="CHTR")then continue; endif;
				var ^CAttribs pxPasAttr = pxPassenger^.GetAttribs();
				if(pxPasAttr==null)then continue; endif;
				var string sPassengerGuids = pxPasAttr^.GetValue("passenger_guids");
				if(sPassengerGuids.IsEmpty())then continue; endif;
				var array string asPasToks;
				sPassengerGuids.Split(asPasToks, "\n", true);
				var int iD, iDC = asPasToks.NumEntries();
				for(iD=0)cond(iD<iDC)iter(iD++)do
					var CGuid xPasGuid; xPasGuid.FromString(asPasToks[iD]);
					var ^CObj pxPassengerPassenger = CClientWrap.GetObjMgr().GetObj(xPasGuid);
					if(pxPassengerPassenger==null)then continue; endif;
					xObjsToSelect.AddEntry(pxPassengerPassenger^.GetHandle());
				endfor;
			endfor;
		endfor;
		var int i, iC = m_pxTribeView^.TotalSlotCount();
		for(i=0)cond(i<iC)iter(i++)do
			if(m_pxTribeView^.GetSlotInfo(i)^.m_bUsed == true)then
				var ^CPyramidCard pxChar = GetCard(i);
				var CClntHndl xHndl = pxChar^.GetObj();
				var string sCurTask;
				var ^CObj pxObj = xHndl.GetObj();
				if(pxObj!=null)then
					var ^CAttribs pxAttribs = pxObj^.GetAttribs();
					if(pxAttribs!=null)then
						sCurTask = pxAttribs^.GetValue("CurTask");
					endif;
				endif;
				if(xObjsToSelect.FindEntry(xHndl)!=-1)then
					pxChar^.SetSelected(true);
					var string sName = pxChar^.GetName();
					m_pxTribeView^.GetSlotInfo(i)^.SetAlertCounter(2000000000);
				else
					pxChar^.SetSelected(false);
					if(sCurTask!="Fight")then
						m_pxTribeView^.GetSlotInfo(i)^.SetAlertCounter(0);
					endif;
				endif;
			endif;
		endfor;
	endproc;

	///called when pyramidcard or inventorycard is dragged
	export proc bool AcceptDropWindow(^CDragWindow p_pxDragWnd , point p_xMousePos)
		// A different drag & drop operation will be executed in pointbuy mdoe
		if(m_bPBMode)then return AcceptDropWindowPB(p_pxDragWnd, p_xMousePos); endif;
		var string sMsg;
		var point xRealPos = p_xMousePos - GetAbsPos();
		if(p_pxDragWnd^.GetIdentifier()!="URSCARD")then return false; endif;
		var point xPos = p_pxDragWnd^.GetOriginalPos();
		var ^CPyramidCard pxCard = cast<CPyramidCard>(p_pxDragWnd^.GetSource());
		//var ^CInvCard pxInventoryCard = cast<CInvCard>(p_pxDragWnd^.GetSource());
		var string sToolTip;
		var bool bReturn=false;
		if(pxCard!=null)then 
			var int iLeft, iRight;
			var int iMainSlotID = m_pxTribeView^.SlotSubHitTest(xRealPos,iLeft,iRight);
			var int iX = xRealPos.GetX();
			var int iY = xRealPos.GetY();
			var int iOldSlotID  = pxCard^.GetSlotID();
			var int iOldLevel = m_pxTribeView^.SlotIndex2Level(iOldSlotID);
			var int iNewSLotID = m_pxTribeView^.SlotHitTest(xRealPos);
			var int iNewLevel = m_pxTribeView^.SlotIndex2Level(iNewSLotID);
			var int iNeedScalps = GetScalpCost(pxCard^.GetLevel(), iNewLevel);
			var int iFixedLevel=pxCard^.GetFixedLevel();
			if(iNewSLotID >= 0)then
				///same level
				var ^CTribeViewLayoutMgr.CSlotInfo pxSI = m_pxTribeView^.GetSlotInfo(iNewSLotID);
				if(!pxSI^.m_bBlocked)then
					if(iNewLevel != iOldLevel)then
						var ^CTribeViewLayoutMgr.CSlotInfo pxNewSI=m_pxTribeView^.GetSlotInfo(iNewSLotID);
						var ^CPyramidCard pxNewCard=cast<CPyramidCard>(pxNewSI^.GetWindow());
						// level up
						var ^CObj pxObj = pxCard^.GetObj().GetObj();
						if(pxObj!=null)then
							if(iOldLevel < iNewLevel)then
								sToolTip="%/food:0/stone:0/wood:0/skulls:"+iNeedScalps.ToString();
								if(iNeedScalps>GetScalpsAvailable())then
									sToolTip+=":NA";
								else
									if(HasFreeSlots(iNewLevel))then
										/*if(iFixedLevel!=-1 && iNewLevel<iFixedLevel)then
											bReturn=false;
										else
											bReturn=true;
										endif;
										*/
										bReturn=true;
									endif;
								endif;
								sToolTip+="%";
							else
//								if(IsHero(pxCard^.GetClass()))then
								if(!pxCard^.GetIsPyCO() && IsLevelAcceptable(pxCard^.GetClass(),iNewLevel,pxCard^.GetObjPath()))then
									bReturn=true;
								endif;
							endif;
						endif;
					else
						bReturn=true;
					endif;
				endif;
			endif;
		endif;
		p_pxDragWnd^.SetToolTipText(sToolTip);
		return bReturn;
	endproc;

	///called when card or inventorycard is dropped
	proc void DropWindow(^CDragWindow p_pxDragWnd, point p_xMousePos)
		// A different drag & drop operation will be executed in pointbuy mdoe
		if(m_bPBMode)then return DropWindowPB(p_pxDragWnd, p_xMousePos); endif;
		var point xRealPos = p_xMousePos - GetAbsPos();
		if(p_pxDragWnd^.GetIdentifier() !="URSCARD")then return; endif;
		var point xPos = p_pxDragWnd^.GetOriginalPos();
		var string sMsg;
		var ^CPyramidCard pxCard = cast<CPyramidCard>(p_pxDragWnd^.GetSource());
		//var ^CInvCard pxInventoryCard = cast<CInvCard>(p_pxDragWnd^.GetSource());
		if(pxCard==null /*&& pxInventoryCard==null*/)then return; endif;
		//pyrcard is dropped
		if(pxCard!=null)then
			var int iOldSlotID = pxCard^.GetSlotID();
			var int iOldLevel = m_pxTribeView^.SlotIndex2Level(iOldSlotID);
			var int iNewSLotID = m_pxTribeView^.SlotHitTest(xRealPos);
			var int iNewLevel = m_pxTribeView^.SlotIndex2Level(iNewSLotID);

			if(iOldLevel>iNewLevel)then
				var ^CTribeViewLayoutMgr.CSlotInfo pxNewSI=m_pxTribeView^.GetSlotInfo(iNewSLotID);
				var ^CPyramidCard pxNewCard=cast<CPyramidCard>(pxNewSI^.GetWindow());
				if(pxNewCard!=null)then
					var int iNeedScalps=GetScalpCost(pxNewCard^.GetLevel(), iOldLevel);
					if((GetScalpsAvailable()<iNeedScalps))then
						iNewSLotID=m_pxTribeView^.FindFreeSlot(iNewLevel);
					endif;
				endif;
				/*if new Level is below 3
				if(iNewLevel < 3 && iOldLevel >= 3)then
					var int i, iC = 6;
					var ^CObj pxObj = pxCard^.GetObj().GetObj();
					var CClntHndl xHndl = pxCard^.GetObj();
					if(pxObj!=null)then
						var vec3 vPos = pxObj^.GetPos();
						var real fX = vPos.GetX(); var real fY = vPos.GetY(); var real fZ = vPos.GetZ();
						var real fI = 0.1;
						for (i=0)cond(i<iC)iter(i++)do
							var ^CTribeViewLayoutMgr.CSlotInfo pxSI=m_pxTribeView^.GetSlotInfo(iOldSlotID);
							if(pxSI^.GetXtra(false,i)^.m_bUsed == true)then
								pxSI^.GetXtra(false,i)^.m_bUsed = false;
								pxInventoryCard = GetInvCard(iOldSlotID, i);
								var int iOwner = 1;
								var string sName = pxInventoryCard^.GetName();
								fX = fX+fI; fY = fY+fI;
								CEvt_GenericEvent.Send("CreateInvObj&"+sName+"&"+iOwner.ToString()+"&"+fX.ToString()+"&"+fY.ToString()+"&"+fZ.ToString());
								fI = fI+fI;
							endif;
						endfor;
						CEvt_GamePlayCommand.Send(xHndl, "LoseAllInventory", "LevelBelow3");
					endif;
				endif;*/
			endif;
			if(iNewSLotID<0)then return; endif;
			SwapSlotsAndCards(iOldSlotID,iNewSLotID);
			CWindowMgr.Get().BringWindowToTop(m_pxDesktop, true);
			return;
		endif;
	endproc;

	export proc bool AcceptDropWindowPB(^CDragWindow p_pxDragWnd , point p_xMousePos)
		if(GetDisabled())then return false; endif;
		var point xRealPos = p_xMousePos - GetAbsPos();
		if(p_pxDragWnd^.GetIdentifier()!="URSCARD")then
			return false; 
		endif;
		var point xPos = p_pxDragWnd^.GetOriginalPos();
		var ^CPyramidCard pxCard = cast<CPyramidCard>(p_pxDragWnd^.GetSource());
		// Newly bought card
		if(pxCard==null)then
			var int iNewSLotID = m_pxTribeView^.SlotHitTest(xRealPos);
			var int iLevel = m_pxTribeView^.SlotIndex2Level(iNewSLotID);
			var ^CShoppingTab.CShoppingInfo.ShoppingIcon pxShopIcon = cast<CShoppingTab.CShoppingInfo.ShoppingIcon>(p_pxDragWnd^.GetSource());
			var string sClass=pxShopIcon^.GetClass();
			if(iNewSLotID < 0)then
				m_pxPBOwner^.m_pxShoppingList^.UpdateInfoFromPyramid(sClass);
				return false;
			endif;
			var int iNewCost=CPointBuyMgr.GetCostForUnit(sClass,iNewSLotID,m_sTribe);
			if(iNewCost>0)then
				m_pxPBOwner^.m_pxShoppingList^.UpdateInfoFromPyramid(sClass);
				var int iPointsLeft=m_pxPBOwner^.GetCredits();
				if(iPointsLeft-iNewCost >= 0)then
					return m_pxPBOwner^.CheckRestrictions(sClass,iLevel);
				else
					return false;
				endif;
			else
				m_pxPBOwner^.m_pxShoppingList^.UpdateInfoFromPyramid(sClass);
				return false;
			endif;
		endif;
		var int iLeft, iRight;
		var int iMainSlotID = m_pxTribeView^.SlotSubHitTest(xRealPos,iLeft,iRight);
		var int iX = xRealPos.GetX();
		var int iY = xRealPos.GetY();
		var int iOldSlotID  = pxCard^.GetSlotID();
		var int iOldLevel = m_pxTribeView^.SlotIndex2Level(iOldSlotID);
		var int iNewSLotID = m_pxTribeView^.SlotHitTest(xRealPos);
		var int iNewLevel = m_pxTribeView^.SlotIndex2Level(iNewSLotID);
		var int iFixedLevel = pxCard^.GetFixedLevel();
		var string sClass=pxCard^.GetClass();
		if(iNewSLotID < 0)then
			m_pxPBOwner^.m_pxShoppingList^.UpdateInfoFromPyramid(sClass);
			return false; 
		endif;
		///same level
		if(iNewLevel == iOldLevel)then
			return true;
		endif;
		if(iFixedLevel!=-1 && iNewLevel<iFixedLevel)then
//			return false;
//			if(IsHero(pxCard^.GetClass()))then
			if(!pxCard^.GetIsPyCO() && IsLevelAcceptable(pxCard^.GetClass(),iNewLevel,pxCard^.GetObjPath()))then
			else
				return false;
			endif;
		endif;
		var ^CTribeViewLayoutMgr.CSlotInfo pxNewSI=m_pxTribeView^.GetSlotInfo(iNewSLotID);
		var ^CPyramidCard pxNewCard=cast<CPyramidCard>(pxNewSI^.GetWindow());

		var int iNewCost=CPointBuyMgr.GetCostForUnit(sClass,iNewSLotID,m_sTribe);
		if(iNewCost>0)then
			m_pxPBOwner^.m_pxShoppingList^.UpdateInfoFromPyramid(sClass);
		else
			m_pxPBOwner^.m_pxShoppingList^.UpdateInfoFromPyramid(sClass);
		endif;

		if(iOldLevel < iNewLevel)then
			// level up
			var int iOldCost=CPointBuyMgr.GetCostForUnit(sClass,iOldSlotID,m_sTribe);
			var int iPointsLeft=m_pxPBOwner^.GetCredits();
			if((iPointsLeft+iOldCost)-iNewCost >= 0)then
				return true;
			else
				return false;
			endif;
		else
			//level down
			if(iNewCost==0)then
				return false;
			else
				return true;
			endif;
		endif;
	endproc;

	proc void DropWindowPB(^CDragWindow p_pxDragWnd, point p_xMousePos)
		var point xRealPos = p_xMousePos - GetAbsPos();
		if(p_pxDragWnd^.GetIdentifier() !="URSCARD")then return; endif;
		var point xPos = p_pxDragWnd^.GetOriginalPos();
		var ^CPyramidCard pxCard = cast<CPyramidCard>(p_pxDragWnd^.GetSource());

		// Newly bought card
		if(pxCard==null)then
			var int iNewSLotID = m_pxTribeView^.SlotHitTest(xRealPos);
			var ^CShoppingTab.CShoppingInfo.ShoppingIcon pxShopIcon = cast<CShoppingTab.CShoppingInfo.ShoppingIcon>(p_pxDragWnd^.GetSource());
			var string sClass=pxShopIcon^.GetClass();
			CreateCardInSlot(iNewSLotID,sClass,-1);
			return;
		endif;

		var int iOldSlotID  = pxCard^.GetSlotID();
		var int iOldLevel 	= m_pxTribeView^.SlotIndex2Level(iOldSlotID);
		var int iNewSlotID 	= m_pxTribeView^.SlotHitTest(xRealPos);
		var int iNewLevel 	= m_pxTribeView^.SlotIndex2Level(iNewSlotID);

		if(iNewSlotID<0)then return; endif;

		SwapSlotsAndCardsFast(iNewSlotID,iOldSlotID);
		m_pxPBOwner^.SwapSlots(iOldSlotID,iNewSlotID);
	endproc;


	///get method for PyrCard
	export proc ^CPyramidCard GetCard(int p_iSlotID)
		var ^CTribeViewLayoutMgr.CSlotInfo  pxSI = m_pxTribeView^.GetSlotInfo(p_iSlotID);
		return cast<CPyramidCard>(pxSI^.GetWindow());
	endproc;

	export proc void BlockSlots(int p_iLvl,int p_iMaxSlots,int p_iMaxSlotsStart, bool p_bForceUnblock)
		var ^CTribeViewLayoutMgr.CSingleLevelLayoutInfo pxLayout = ^(m_pxTribeView^.GetSingleLevelLayoutInfo(p_iLvl));
		if(pxLayout!=null)then
			var int iFirst = pxLayout^.m_iSlotOffset;
			var int iNum   = pxLayout^.m_iSlotCount;
			
			//pxLayout^.m_xMainMargin = {1000,500,500,500};
			var int iBlocked = iNum-p_iMaxSlots;
			var int iBlockedPerm = iNum-p_iMaxSlotsStart;
			
			var ^CTribeViewLayoutMgr.CSlotInfo pxSI = null;
			var int i,iC=iFirst;
			for(i=iFirst+iNum-1) cond(i>=iC) iter(--i)do
				if(iBlocked<=0 && !p_bForceUnblock)then break; endif;
				pxSI = m_pxTribeView^.GetSlotInfo(i);
				if(pxSI!=null)then
					pxSI^.m_bBlocked = iBlocked-->0;
					pxSI^.m_bBlockedPerm = iBlockedPerm-->0;
				endif;
			endfor;
		endif;
	endproc;
	
	export proc void UpdateBlockedSlots()
		// check for blocked slots
		var int i, iC=5;
		for(i=0) cond(i<iC) iter(++i)do
			var int iMax = CPyramidRestrictionsMgr.Get().GetMaxSlots(i);
			BlockSlots(i,iMax,iMax,true);
		endfor;

		// update card's bitmaps
		iC = m_pxTribeView^.TotalSlotCount();
		for(i=0)cond(i<iC) iter (++i)do
			var ^CTribeViewLayoutMgr.CSlotInfo pxSI = m_pxTribeView^.GetSlotInfo(i);
			if(pxSI==null)then continue; endif;
			if(pxSI^.m_bUsed == true)then
				GetCard(i)^.m_bBitmapChanged = true;
				//GetCard(i)^.UpdateBitmaps();
			else
				var ^CWindow pxWnd = pxSI^.GetWindow();
				if(pxWnd!=null)then
					var ^CPyrSlot pxSlot = cast<CPyrSlot>(pxWnd);
					if(pxSlot!=null)then
						pxSlot^.SetBlocked(pxSI^.m_bBlocked,pxSI^.m_bBlockedPerm);
					endif;
				endif;
			endif;
		endfor;
	endproc;

	export proc void Init(string p_sTribe)
		//setzt den Tribe und die Upgrades fr diesen Tribe
		m_sTribe = p_sTribe;
		if(p_sTribe == "Hu")then
			m_asCurrentTribeUpgrades = m_asHuUpgrades;
		elseif(p_sTribe == "Aje")then
			m_asCurrentTribeUpgrades = m_asAjeUpgrades;
		elseif(p_sTribe == "Ninigi")then
			m_asCurrentTribeUpgrades = m_asNinigiUpgrades;
		elseif(p_sTribe == "SEAS")then
			m_asCurrentTribeUpgrades = m_asSEASUpgrades;
		endif;
		UpdateBlockedSlots();
/*
		// delete additional cards
		while(m_apxAddCards.NumEntries()>0)do
			var ^CPyramidCard pxCard = m_apxAddCards[0];
			System.Assert(pxCard!=null);
			KillCard(m_apxAddCards[0]);
		endwhile;
*/
		// delete visible cards
		var int i,iC;
		iC = m_pxTribeView^.TotalSlotCount();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CPyramidCard pxCard = cast<CPyramidCard>(m_pxTribeView^.GetSlotInfo(i)^.GetWindow());
			if(pxCard!=null)then
				//pxCard^.ResetHitFlash();
				pxCard^.UpdateBitmaps();
			endif;
		endfor;

		//UpdateUpgrades();
	endproc;
	
	///called to set bitmap with icon for Xtra Slots
	proc CBitmapPtr GetUpdateBitmap(int p_iLevel, string p_sPic)
		var string sBitmappath = "1"+p_iLevel.ToString()+",layer background_"+p_iLevel.ToString()+",layer "+p_sPic;
		var ^CCardBitmap pxBmp = CGameInst.GetBitmapMgr().GetBlendBitmap(sBitmappath);
		var CBitmapPtr pxBMP;
		if(pxBmp!=null)then
			return pxBmp^.GetBitmap();
		else
			return pxBMP;
		endif;
	endproc;
	
	
	///called to set bitmap background for Xtra Slots
	export proc CBitmapPtr GetBackgroundBitmap(int p_iLevel, string p_sPic)
		var string sBitmappath = "1"+p_iLevel.ToString()+",layer "+p_sPic+"_"+p_iLevel.ToString();
		var ^CCardBitmap pxBmp = CGameInst.GetBitmapMgr().GetBlendBitmap(sBitmappath);
		var CBitmapPtr pxBMP;
		if(pxBmp!=null)then
			return pxBmp^.GetBitmap();
		else
			return pxBMP;
		endif;
	endproc;
	
	
	///called to set bitmap with icon in a grey state
	export proc CBitmapPtr GetBitmapGrey(int p_iLevel, string p_sPic)
		var string sBitmappath = "1"+p_iLevel.ToString()+",layer background_"+p_iLevel.ToString()+",blend "+p_sPic+" 30";
		var ^CCardBitmap pxBmp = CGameInst.GetBitmapMgr().GetBlendBitmap(sBitmappath);
		var CBitmapPtr pxBMP;
		if(pxBmp!=null)then
			return pxBmp^.GetBitmap();
		else
			return pxBMP;
		endif;
	endproc;
	
	export proc void CardLevelChanged(^CPyramidCard p_pxCard)
		var int iSlotID = p_pxCard^.GetSlotID();
		var int iLevel = p_pxCard^.GetLevel();
		var int iPyramidLevel = m_pxTribeView^.SlotIndex2Level(p_pxCard^.GetSlotID());
		var ^CTribeViewLayoutMgr.CSlotInfo pxSlotInfo = m_pxTribeView^.GetSlotInfo(iSlotID);
		// skip if card is not in tribeview
		if(p_pxCard^.GetAdditionalCard()||iSlotID==-1||pxSlotInfo==null||(pxSlotInfo^.GetWindow()!=p_pxCard))then
//			TryAdditionalCards();
			return;
		endif;
		if(iLevel!=iPyramidLevel)then
			var int iFreeSlot = m_pxTribeView^.FindFreeSlot(iLevel);
			if(iFreeSlot>-1)then
				// move within tribeview
				SwapSlotsAndCardsFast(iSlotID,iFreeSlot);
			else
				// remove card from tribeview and add to additional cards
				var ^CWindow pxBackgroundPane = GetBackgroundPane(iSlotID);
				AddChild(pxBackgroundPane);
				pxSlotInfo^.SetWindow(pxBackgroundPane);
				pxSlotInfo^.m_sName.Empty();
				pxSlotInfo^.m_bUsed=false;
				p_pxCard^.RemoveFromParent();
				m_apxAddCards.AddEntry(p_pxCard);
				if(m_apxNormalCards.FindEntry(p_pxCard)!=-1)then
					m_apxNormalCards.RemEntry(p_pxCard);
				endif;
				p_pxCard^.SetSlotID(-1);
				p_pxCard^.SetAdditionalCard(true);
			endif;
		endif;
	endproc;
	
	static proc void SwapSortCardArray(ref array ^CPyramidCard p_rapxCardArray, int p_iA, int p_iB)
		var ^CPyramidCard pxT = p_rapxCardArray[p_iA];
		p_rapxCardArray[p_iA] = p_rapxCardArray[p_iB];
		p_rapxCardArray[p_iB] = pxT;
	endproc;
	
	static proc void BubbleSortCardArray(ref array ^CPyramidCard p_rapxCardArray)
		if(p_rapxCardArray.NumEntries() <= 0)then return; endif;
		// bubble sort
		var int i, ij, iC;
		var ^CPyramidCard pxT;
		iC=p_rapxCardArray.NumEntries();
		for(i=0)cond(i<iC-1)iter(i++)do
			for(ij=0)cond(ij<iC-i-1)iter(ij++)do
				System.Assert(p_rapxCardArray[ij]!=null && p_rapxCardArray[ij+1]!=null);
				System.Assert(p_rapxCardArray[ij]^.GetObj().IsValid() && p_rapxCardArray[ij+1]^.GetObj().IsValid());
				var ^CObj pxObjA = p_rapxCardArray[ij]^.GetObj().GetObj();
				var ^CObj pxObjB = p_rapxCardArray[ij+1]^.GetObj().GetObj();
				//L KLog.LogSpam("UI.NewPyramid","A["+ij.ToString()+"]='"+p_rapxCardArray[i]^.GetName().ToString()+"' "+p_rapxCardArray[ij]^.m_iSortComparator.ToString()+" A["+(ij+1).ToString()+"]='"+p_rapxCardArray[ij+1]^.GetName().ToString()+"' "+p_rapxCardArray[ij+1]^.m_iSortComparator.ToString());
				var string sClassA = pxObjA^.GetClassName();
				var string sClassB = pxObjB^.GetClassName();
				var string sNameA = pxObjA^.GetName();
				var string sNameB = pxObjB^.GetName();
				var int iCompA = p_rapxCardArray[ij]^.m_iSortComparator;
				var int iCompB = p_rapxCardArray[ij+1]^.m_iSortComparator;
				if(sClassA=="pyramid_card_object")then
					var ^CAttribs pxAttribs = pxObjA^.GetAttribs();
					if(pxAttribs!=null)then
						var string sObjPath = pxAttribs^.GetValue("ObjPath");
						var array string asTok;
						sObjPath.Split(asTok,"/",true);
						sClassA=asTok[asTok.NumEntries()-1];
					endif;
				endif;
				if(sClassB=="pyramid_card_object")then
					var ^CAttribs pxAttribs = pxObjB^.GetAttribs();
					if(pxAttribs!=null)then
						var string sObjPath = pxAttribs^.GetValue("ObjPath");
						var array string asTok;
						sObjPath.Split(asTok,"/",true);
						sClassB=asTok[asTok.NumEntries()-1];
					endif;
				endif;
				if(iCompA > iCompB ||(iCompA == iCompB&&sClassA > sClassB)||(iCompA == iCompB&&sClassA == sClassB&&sNameA > sNameB))then
					SwapSortCardArray(p_rapxCardArray, ij, ij+1);
				endif;
			endfor;
		endfor;

//L		for(i=1)cond(i<iC)iter(i++)do
//L			KLog.LogSpam("UI.NewPyramid","name='"+p_rapxCardArray[i]^.GetName().ToString()+"' m_iSortComparator="+p_rapxCardArray[i]^.m_iSortComparator.ToString());
//L		endfor;

	endproc;
	
	static proc void CalcSortingWeights(ref array ^CPyramidCard p_rapxCardArray, int p_iSortingMethod)
		var int i, iC = p_rapxCardArray.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CPyramidCard pxCard = p_rapxCardArray[i];
			if(pxCard!=null)then
				var ^CObj pxObj = pxCard^.GetObj().GetObj();
				if(pxObj!=null)then
					
					// collect parameters
					var string sTask, sWeapon, sType, sClass, sObjPath;
					var real fAreaRange, fMinRange, fMaxRange;
					var int iHitpoints, iMaxHitpoints, iMaxPassengers, iDamage;
					var bool bIsMeleeUnit, bIsRangedUnit, bIsAreaDamageUnit, bIsResourceCollectingUnit, bIsTransportUnit, bIsWorker, bIsHarvestingUnit, bIsTrader, bCanAttack;
					var bool bHasBonusDefCHTR, bHasBonusDefVHCL, bHasBonusDefBLDG, bHasBonusDefSHIP, bHasBonusDefANML;
					var bool bHasBonusAtkCHTR, bHasBonusAtkVHCL, bHasBonusAtkBLDG, bHasBonusAtkSHIP, bHasBonusAtkANML;
					begin collect_parameters;
						sClass = pxObj^.GetClassName();
						sType = pxObj^.GetType().ToString();
						var ^CAttribs pxAttribs = pxObj^.GetAttribs();
						if(pxAttribs!=null)then
							sTask = pxAttribs^.GetValue("TaskDescription");
							sWeapon = pxAttribs^.GetValue("Equip_Slot_0");
							iHitpoints = pxAttribs^.GetValueInt("hitpoints");
							iMaxHitpoints = pxAttribs^.GetValueInt("maxhitpoints");
							iMaxPassengers = pxAttribs^.GetValueInt("max_passengers");
							bCanAttack = (pxAttribs^.GetValueInt("can_attack")>0);
							iDamage = pxAttribs^.GetValueInt("damage");
							sObjPath = pxAttribs^.GetValue("ObjPath");
							if(sClass=="pyramid_card_object" && !sObjPath.IsEmpty())then
								var array string asTok;
								sObjPath.Split(asTok,"/",true);
								sClass=asTok[asTok.NumEntries()-1];
							endif;
						endif;
						var CTechTree xTT=pxObj^.GetTechTree();
						var ^CTechTree.CNode pxWeapon=xTT.FindNode(sWeapon);
						if(pxWeapon!=null)then
							fAreaRange = pxWeapon^.GetSubValueF("hitrange");
							fMinRange = pxWeapon^.GetSubValueF("minattackrange",0.0);
							fMaxRange = pxWeapon^.GetSubValueF("range");
						endif;
						bIsMeleeUnit = (fMaxRange <= 10.0);
						bIsRangedUnit = (fMaxRange > 10.0);
						bIsAreaDamageUnit = (fAreaRange > 0.0);
						bIsTransportUnit = (iMaxPassengers > 0);
						if(
							sClass=="hu_worker" ||
							sClass=="aje_worker" ||
							sClass=="ninigi_worker" ||
							sClass=="seas_worker"
						)then
							bIsWorker = true;
						else
							bIsWorker = false;
						endif;
						//Henry: inserting more worker units
						if(
							sClass=="hu_mammoth_lumber_upgrade" ||
							sClass=="hu_fishing_boat" ||
							sClass=="aje_floating_harbour" ||
							sClass=="ninigi_harvester" ||
							sClass=="ninigi_fishing_boat" ||
							sClass=="seas_carrier" ||
							sClass=="seas_mechanical_walker"||
							sClass=="seas_lumberjack"||
							sClass=="Barry_s0" ||
							sClass=="Harry_s0" ||
							sClass=="Larry_s0"
						)then
							bIsHarvestingUnit = true;
						else
							bIsHarvestingUnit = false;
						endif;
						//Henry: adding handle dino of seas too
						if(
							sClass=="hu_cart" ||
							sClass=="aje_trade_dino" ||
							sClass=="ninigi_cart" ||
							sClass=="seas_trade_dino"
						)then
							bIsTrader = true;
						else
							bIsTrader = false;
						endif;
						if(
							bIsWorker ||
							bIsHarvestingUnit ||
							bIsTrader ||
							sClass=="aje_resource_collector"
						)then
							bIsResourceCollectingUnit = true;
						else
							bIsResourceCollectingUnit = false;
						endif;
						
						bHasBonusAtkCHTR = IsCounterUnit(sClass, "CHTR");
						bHasBonusAtkVHCL = IsCounterUnit(sClass, "VHCL");
						bHasBonusAtkBLDG = IsCounterUnit(sClass, "BLDG");
						bHasBonusAtkSHIP = IsCounterUnit(sClass, "SHIP");
						bHasBonusAtkANML = IsCounterUnit(sClass, "ANML");
						
					end collect_parameters;
					// collect parameters
					
// //debug
//					KLog.LogSpam("UI.NewPyramid",
//					"name='"+pxObj^.GetName()+"'"+"\n"+
//					"sTask='"+sTask+"'"+"\n"+
//					"sType='"+sType+"'"+"\n"+
//					"sClass='"+sClass+"'"+"\n"+
//					"iHitpoints="+iHitpoints.ToString()+"\n"+
//					"iMaxHitpoints="+iMaxHitpoints.ToString()+"\n"+
//					"iMaxPassengers="+iMaxPassengers.ToString()+"\n"+
//					"iDamage="+iDamage.ToString()+"\n"+
//					"sWeapon='"+sWeapon+"'"+"\n"+
//					"fAreaRange="+fAreaRange.ToString()+"\n"+
//					"fMinRange="+fMinRange.ToString()+"\n"+
//					"fMaxRange="+fMaxRange.ToString()+"\n"+
//					"bIsMeleeUnit="+bIsMeleeUnit.ToString()+"\n"+
//					"bIsRangedUnit="+bIsRangedUnit.ToString()+"\n"+
//					"bIsAreaDamageUnit="+bIsAreaDamageUnit.ToString()+"\n"+
//					"bIsResourceCollectingUnit="+bIsResourceCollectingUnit.ToString()+"\n"+
//					"bIsTransportUnit="+bIsTransportUnit.ToString()+"\n"+
//					"bIsWorker="+bIsWorker.ToString()+"\n"+
//					"bIsHarvestingUnit="+bIsHarvestingUnit.ToString()+"\n"+
//					"bIsTrader="+bIsTrader.ToString()+"\n"+
//					"bCanAttack="+bCanAttack.ToString()+"\n"+
//					"bHasBonusDefCHTR="+bHasBonusDefCHTR.ToString()+"\n"+
//					"bHasBonusDefVHCL="+bHasBonusDefVHCL.ToString()+"\n"+
//					"bHasBonusDefBLDG="+bHasBonusDefBLDG.ToString()+"\n"+
//					"bHasBonusDefSHIP="+bHasBonusDefSHIP.ToString()+"\n"+
//					"bHasBonusDefANML="+bHasBonusDefANML.ToString()+"\n"+
//					"bHasBonusAtkCHTR="+bHasBonusAtkCHTR.ToString()+"\n"+
//					"bHasBonusAtkVHCL="+bHasBonusAtkVHCL.ToString()+"\n"+
//					"bHasBonusAtkBLDG="+bHasBonusAtkBLDG.ToString()+"\n"+
//					"bHasBonusAtkSHIP="+bHasBonusAtkSHIP.ToString()+"\n"+
//					"bHasBonusAtkANML="+bHasBonusAtkANML.ToString()
//					);

					var int iWeight = 0;

					if(p_iSortingMethod==0)then
						if(sTask=="food")then
							iWeight+=500;
						elseif(sTask=="wood")then
							iWeight+=1500;
						elseif(sTask=="stone")then
							iWeight+=2000;
						elseif(sTask=="buildup")then
							iWeight+=2500;
						elseif(sTask=="fight")then
							iWeight+=3000;
						elseif(sTask=="idle")then
							iWeight+=5000;
						else
							iWeight+=3500;
						endif;
						if(bIsWorker)then
							iWeight+=0;
						elseif(bIsResourceCollectingUnit && !bIsWorker)then
							iWeight+=10000;
						elseif(bIsMeleeUnit)then
							iWeight+=20000;
						elseif(bIsRangedUnit)then
							iWeight+=30000;
						elseif(bIsAreaDamageUnit)then
							iWeight+=40000;
						else
							iWeight+=50000;
						endif;
						if(!bCanAttack && !bIsResourceCollectingUnit)then
							iWeight+=100000;
						endif;
						if(sType=="SHIP" && !bIsResourceCollectingUnit)then
							iWeight+=200000;
						endif;
					endif;

					if(p_iSortingMethod==1)then
						if(sTask=="food")then
							iWeight+=500;
						elseif(sTask=="wood")then
							iWeight+=1500;
						elseif(sTask=="stone")then
							iWeight+=2000;
						elseif(sTask=="buildup")then
							iWeight+=2500;
						elseif(sTask=="fight")then
							iWeight+=3000;
						elseif(sTask=="idle")then
							iWeight+=5000;
						else
							iWeight+=3500;
						endif;
						if(bIsWorker)then
							iWeight+=0;
						elseif(bIsResourceCollectingUnit && !bIsWorker)then
							iWeight+=10000;
						else
							iWeight+=50000;
							iWeight+=(9000-iMaxHitpoints);
						endif;
						if(!bCanAttack && !bIsResourceCollectingUnit)then
							iWeight+=100000;
						endif;
					endif;

					if(p_iSortingMethod==2)then
						if(sTask=="food")then
							iWeight+=500;
						elseif(sTask=="wood")then
							iWeight+=1500;
						elseif(sTask=="stone")then
							iWeight+=2000;
						elseif(sTask=="buildup")then
							iWeight+=2500;
						elseif(sTask=="fight")then
							iWeight+=3000;
						elseif(sTask=="idle")then
							iWeight+=5000;
						else
							iWeight+=3500;
						endif;
						if(bIsWorker)then
							iWeight+=0;
						elseif(bIsResourceCollectingUnit && !bIsWorker)then
							iWeight+=10000;
						else
							if(bHasBonusAtkBLDG)then
								iWeight+=20000;
							elseif(bHasBonusAtkBLDG)then
								iWeight+=30000;
							elseif(bHasBonusAtkCHTR)then
								iWeight+=40000;
							elseif(bHasBonusAtkANML)then
								iWeight+=50000;
							elseif(bHasBonusAtkVHCL)then
								iWeight+=60000;
							elseif(bHasBonusAtkSHIP)then
								iWeight+=70000;
							else
								iWeight+=80000;
							endif;
						endif;
						if(!bCanAttack && !bIsResourceCollectingUnit)then
							iWeight+=100000;
						endif;
					endif;

					pxCard^.m_iSortComparator=iWeight;
					
					//L KLog.LogSpam("UI.NewPyramid","set name='"+pxObj^.GetName()+"' weight="+iWeight.ToString());

				endif;
			endif;
		endfor;
	endproc;
	
	static proc bool IsCounterUnit(string p_sClass, string p_sType)
		if(ms_xCompareDB.GetRoot().NumSubs()<=0)then		
			if(ms_xCompareDB.Load(CClientWrap.GetUrsRelPath()+"/Data/Base/Scripts/Ai/settings/CompareValue.txt") == false)then
				KLog.LogWarn("UI.NewPyramid","Failed to load compare table: ../Data/Base/Scripts/Ai/settings/CompareValue.txt");
				return false;
			endif;
		endif;
		
		var ^CPropDB.CNode pxType = ms_xCompareDB.GetRoot().Get(p_sType);
		if(pxType!=null)then 
			var int i, iC=pxType^.NumSubs();
			for(i=0)cond(i<iC)iter(i++)do
				var string sKey=pxType^.Get(i).Name();
				if(sKey==p_sClass)then
					return true;
				endif;
			endfor;
		endif;

		return false;
	endproc;
	
	export proc bool SortLevel(int p_iLevel)
		//L KLog.LogSpam("UI.NewPyramid","CNewPyramid::SortLevel("+p_iLevel.ToString()+")");
		var array ^CPyramidCard apxCards;
		var int i, iC = m_pxTribeView^.TotalSlotCount();
		
		// collect cards and remove from tribeview
		//L KLog.LogSpam("UI.NewPyramid",">>> collect cards");
		for(i=0)cond(i<iC)iter(i++)do
			var ^CTribeViewLayoutMgr.CSlotInfo pxSlotInfo=m_pxTribeView^.GetSlotInfo(i);
			if(m_pxTribeView^.SlotIndex2Level(i)==p_iLevel && pxSlotInfo^.m_bUsed == true)then
				var ^CPyramidCard pxCard = GetCard(i);
				if(pxCard!=null)then
					//kill card, if obj is invalid
					if(!pxCard^.GetObj().IsValid())then
						//L KLog.LogSpam("UI.NewPyramid","SortLevel("+p_iLevel.ToString()+") : Card "+pxCard^.GetName()+" with invalid object handle -> kill card");
						KillCard(pxCard);
						continue;
					endif;
					
					//L KLog.LogSpam("UI.NewPyramid","collect name='"+pxCard^.GetName()+"' former slot="+pxCard^.GetSlotID().ToString()+" i="+i.ToString());
					apxCards.AddEntry(pxCard);
					var ^CWindow pxBackgroundPane = GetBackgroundPane(i);
					AddChild(pxBackgroundPane);
					pxSlotInfo^.SetWindow(pxBackgroundPane);
					pxSlotInfo^.m_sName.Empty();
					pxSlotInfo^.m_bUsed=false;
					pxCard^.RemoveFromParent();
					pxCard^.SetSlotID(-1);
					pxCard^.SetAdditionalCard(true);
				endif;
			endif;
		endfor;
		
		// calc weights
		//L KLog.LogSpam("UI.NewPyramid",">>> calc weights");
		CalcSortingWeights(apxCards,m_iSortingMethod);
		
		// sort cards
		//L KLog.LogSpam("UI.NewPyramid",">>> sort cards");
		BubbleSortCardArray(apxCards);
		
		// insert cards into tribeview
		//L KLog.LogSpam("UI.NewPyramid",">>> insert cards");
		iC = apxCards.NumEntries();
		var int iSlotOffset = m_pxTribeView^.GetGlobalSlotOffset(p_iLevel);
		for(i=0)cond(i<iC)iter(i++)do
			var ^CPyramidCard pxCard = apxCards[i];
			var int iSlotID = iSlotOffset + i;
			pxCard^.SetAdditionalCard(false);
			pxCard^.SetTribeViewPointer(m_pxTribeView);
			pxCard^.SetSlotID(iSlotID);
			SetWindowToSlot(iSlotID,pxCard,true);
			var ^CTribeViewLayoutMgr.CSlotInfo pxSI=m_pxTribeView^.GetSlotInfo(iSlotID);
			pxSI^.m_sName=pxCard^.GetName();
			pxSI^.SetAlertCounter(50);
			pxCard^.m_bBitmapChanged = true;
		endfor;

		// clear working array
		apxCards = 0;

		//L KLog.LogSpam("UI.NewPyramid","CNewPyramid::SortLevel("+p_iLevel.ToString()+")done.");

		return true;
	endproc;
	
	export proc bool ChangeSortMethod()
		m_iSortingMethod = (m_iSortingMethod+1)%3;
		return true;
	endproc;
	
	export proc int GetSortingMethod()
		return m_iSortingMethod;
	endproc;

	export proc bool SelectAllUnitsOfClass(CClntHndl p_xObjHndl, int p_iLevel)
		//L KLog.LogSpam("UI.NewPyramid","SelectAllUnitsOfClass "+p_sClass+" "+p_iLevel.ToString());
		if(p_iLevel<0 || p_iLevel >4)then return false; endif;
		if(!p_xObjHndl.IsValid())then return false; endif;
		var ^CObj pxObj = p_xObjHndl.GetObj();
		var ^CAttribs pxAttribs = pxObj^.GetAttribs();
		if(pxAttribs==null)then return false; endif;
		var string sObjPath = pxAttribs^.GetValue("ObjPath");
		if(sObjPath.IsEmpty())then return false; endif;
		var bool bHitIsSpecial = pxAttribs^.GetValue("ObjPath").Find("Objects/Special/")==0;
		var string sClass = pxObj^.GetClassName();
		var ^CObjSelection pxSel=^(CClientWrap.GetSelection());
		if(pxSel==null)then return false; endif;
		pxSel^.Clear();
		var int iStartSlot = m_pxTribeView^.GetGlobalSlotOffset(p_iLevel);
		var int iNumSlots =  m_pxTribeView^.SlotCount(p_iLevel);
		var int i, iC = iStartSlot+iNumSlots;
		for(i=iStartSlot)cond(i<iC)iter(i++)do
			var ^CPyramidCard pxChar = GetCard(i);
			if(pxChar!=null)then
				var ^CObj pxObjWalk = pxChar^.GetObj().GetObj();
				if(pxObjWalk==null || !pxObjWalk^.IsSelectable())then continue; endif;
				var ^CAttribs pxAttribsWalk = pxObjWalk^.GetAttribs();
				if(bHitIsSpecial && pxAttribsWalk!=null && pxAttribsWalk^.GetValue("ObjPath").Find("Objects/Special/")==0)then
					pxSel^.Include(pxChar^.GetObjToSelect());
					pxChar^.SetSelected(true);
					continue;
				endif;
				var string sClassWalk = pxObjWalk^.GetClassName();
				if(sClass==sClassWalk)then
					pxSel^.Include(pxChar^.GetObjToSelect());
					pxChar^.SetSelected(true);
					continue;
				endif;
			endif;
		endfor;
		var ^CUTCmdSender pxUTCmdSender=CClientWrap.GetUTCmdSender();
		if(pxUTCmdSender!=null)then
			pxUTCmdSender^.SelectionChanged(pxSel^,false,true,false,false,true);
		endif;
		return true;
	endproc;
	
	proc bool IsHero(string p_sClass)
		if(p_sClass=="stina"||p_sClass=="bela"||p_sClass=="cole"||p_sClass=="special_eusmilus"
			||p_sClass=="mayor"||p_sClass=="darwin"||p_sClass=="tesla"||p_sClass=="babbage"
			||p_sClass=="hermit"||p_sClass=="lovelace"||p_sClass=="schliemann"||p_sClass=="death_schliemann"||p_sClass=="livingstone"
			||p_sClass=="miyagi"||p_sClass=="tarna"||p_sClass=="larry"||p_sClass=="special_mobile_suit")then
			return true;
		else
			return false;
		endif;
	endproc;
	
	proc bool IsLevelAcceptable(string p_sClass,int p_iDest, string p_sObjPath)
		var int iSwitch=CMirageClnMgr.Get().DwnLvlSwitch();
		if(iSwitch<1)then
			return false;
		elseif(iSwitch==1)then
			if(!IsHero(p_sClass))then return false; endif;
		endif;
		if(iSwitch<3)then
			if(p_sObjPath=="")then return false; endif;
			var CTechTreeDef xDef;
			var CTechTree xTT=CTechTreeMgr.Get().GetTechTree(xDef);
			var int iMinLevel = xTT.GetValueI(p_sObjPath+"/captainlevel",5)-1;
			if(p_iDest<iMinLevel)then return false; endif;
		endif;
		return true;
	endproc;
	
	export proc void ResetScalpCosts()
		ms_bDisableCache=true;
		m_iScalpsTimer = SetTimer(800, false);
		var int i, iC=ms_aiFoodCostsPerLevel.NumEntries();
		if(iC<=0)then iC=6; ms_aiFoodCostsPerLevel=6; endif;
		for(i=0)cond(i<iC)iter(i++)do
			ms_aiFoodCostsPerLevel[i]=-1;
		endfor;
	endproc;
	
	proc int NumPrePyCO(int p_iLevel)
		if(p_iLevel<0||p_iLevel>4)then return 0; endif;
		var int iCount=0;
		var int i,iC=m_apxPyCOCards.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CPyramidCard pxCard = m_apxPyCOCards[i];
			if(pxCard!=null&&pxCard^.IsPreSpirit()&&pxCard^.GetLevel()==p_iLevel)then
				iCount+=1;
			endif;
		endfor;
		return iCount;
	endproc;
	
	proc int AllPrePyCO()
		var int iCount=0;
		var int i,iC=m_apxPyCOCards.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CPyramidCard pxCard = m_apxPyCOCards[i];
			if(pxCard!=null&&pxCard^.IsPreSpirit())then
				iCount+=1;
			endif;
		endfor;
		return iCount;
	endproc;
	
	export proc void SuccessorAppeared(int p_iSlotID, int p_iLevel, string p_sName)
		var int iPyramidLevel = m_pxTribeView^.SlotIndex2Level(p_iSlotID);
		var ^CTribeViewLayoutMgr.CSlotInfo pxSlotInfo = m_pxTribeView^.GetSlotInfo(p_iSlotID);
		var ^CPyramidCard pxPyCOCard = FindPrePyCOByName(p_sName);
		var int iPyCO;
		if(pxPyCOCard!=null)then
			KillCard(pxPyCOCard);
		endif;
//		TryAdditionalCards();
		m_pxTribeView^.Tick();
	endproc;
	
	export proc void CardGotDestroyed()
		TryAdditionalCards();
		m_pxTribeView^.Tick();
	endproc;
	
	proc ^CPyramidCard FindPrePyCOByName(string p_sName)
		var int i,iC=m_apxPyCOCards.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CPyramidCard pxCard = m_apxPyCOCards[i];
			if(pxCard!=null)then
				if(p_sName==pxCard^.GetName())then
					return pxCard;
				endif;
			endif;
		endfor;
		return null;
	endproc;
	
endclass;

/*?
	?group URS.Scripts.Game.UI
	?item CPyrSlot
	?desc Holdingslots for PyrCards
	?prefix CPyrSlot
?*/
class CPyrSlot inherit CStaticCtrl
	var bool 		m_bBlocked;
	var bool 		m_bBlockedPerm;
	var int			m_iLvl;

	///constructor
	export constructor(int p_iLevel)
		var string sBitmappath = p_iLevel.ToString()+", layer slot_background";
		var ^CCardBitmap pxBmp = CGameInst.GetBitmapMgr().GetBlendBitmap(sBitmappath);
		if(pxBmp!=null)then
			SetBitmap(pxBmp^.GetBitmap());
		else
			CGameWrap.LogError("BitmapMgr","invalid sBitmappath="+sBitmappath);
		endif;
		m_iLvl=p_iLevel;
		SetTransparent(true);
		SetBackground(false);
		var bool bACHidden = CMirageClnMgr.Get().IsACHidden();
		SetVisible(!bACHidden);
		SetAlwaysOnTop(false);
	endconstructor;


	///destructor
	export destructor()
	enddestructor;
	
	///Set method for blocked
	export proc void SetBlocked(bool p_bBlocked,bool p_bBlockedPerm)
		if(m_bBlocked==p_bBlocked&&m_bBlockedPerm==p_bBlockedPerm)then
			//redundant
			return;
		endif;
		
		m_bBlocked = p_bBlocked;
		m_bBlockedPerm = p_bBlockedPerm;
		if(m_bBlockedPerm)then
			SetBitmap(CGameInst.GetBitmapMgr().GetBlendBitmap(m_iLvl.ToString()+", layer closed_perm")^.GetBitmap());
			//SetBackground(false);
		elseif(m_bBlocked)then
			SetBitmap(CGameInst.GetBitmapMgr().GetBlendBitmap(m_iLvl.ToString()+", layer closed_temp")^.GetBitmap());
		else
			SetBackground(true);
			SetBitmap(CGameInst.GetBitmapMgr().GetBlendBitmap(m_iLvl.ToString()+", layer slot_background")^.GetBitmap());
		endif;
		//L KLog.LogWarn("CHP","SetBlocked:"+m_bBlocked.ToString()+" P:"+m_bBlockedPerm.ToString());
	endproc;

	///get method for blocked
	export proc bool IsBlocked()
		return m_bBlocked;
	endproc;

endclass;
