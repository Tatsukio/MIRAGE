class CWaypointSubscriptionMgr inherit CEvtSource
	
	// Singleton-Stuff
	static var ^CWaypointSubscriptionMgr ms_pxInst;
	
	export static proc ref CWaypointSubscriptionMgr Get()
		if(ms_pxInst==null)then ms_pxInst=new CWaypointSubscriptionMgr(); endif;
		return ms_pxInst^;
	endproc;
	
	export static proc void StaticShut()
		delete ms_pxInst;
	endproc;
	
	// da ClassCode
	var CObjList m_xObjs;
	
	constructor()
	endconstructor;
	
	destructor()
	enddestructor;
	
	export proc void AddObj(CObjHndl p_xObj)
		m_xObjs.Include(p_xObj);
	endproc;
	
	export proc void RemObj(CObjHndl p_xObj)
		m_xObjs.RemEntry(p_xObj);
	endproc;
	
	export proc void ObjReachedLastWaypoint(CObjHndl p_xObj)
//		if(m_xObjs.FindEntry(p_xObj)>=0)then //GRAND-HACK
			RemObj(p_xObj);
			var CEvtPointer xEvt = CEvtPointer.CreateEvent("OBJ_WYPT");
			xEvt.SetInt(0, p_xObj.AsInt());
			Broadcast(xEvt);
//		endif;
	endproc;
	
endclass;
	
class CActionFactory inherit CTriggerMgr.IActionFactory
	
	export proc ^CTrigger.IAction  CreateAction ( CFourCC p_xType , ref CAttribs p_rxParams )
		if(p_xType == "UNIT")then
			return new CActionUnit(p_rxParams);
		elseif(p_xType == "RSRC")then
			return new CActionRessource(p_rxParams.GetValueInt("player_id"), p_rxParams.GetValue("res_name"),
				p_rxParams.GetValue("res_mod"),p_rxParams.GetValueInt("res_cap"),
				p_rxParams.GetValue("res_rsrclist"));
		elseif(p_xType == "QUIT")then
			return new CActionQuit(p_rxParams.GetValue("result"));
		elseif(p_xType == "BONI")then
			return new CActionGiveBoni(p_rxParams.GetValueInt("points"));
		elseif(p_xType == "OCPY")then
			return new CActionOccupy(p_rxParams);
		elseif(p_xType == "COBJ")then
			return new CActionCreateObj(p_rxParams);
		elseif(p_xType == "SFOW")then
			return new CActionShowFOW(p_rxParams);
		elseif(p_xType == "CAM_")then
			return new CActionPlaceCam(p_rxParams);
		elseif(p_xType == "ACDO")then
			return new CActionObjDo(p_rxParams);
		elseif(p_xType == "WYPT")then
			return new CActionWaypoints(p_rxParams);
		elseif(p_xType == "AIKH")then
			return new CActionAIKotHAreas(p_rxParams);
		elseif(p_xType == "SQNZ")then
			return new CActionSequence(p_rxParams);
		elseif(p_xType == "TRIG")then
			return new CActionTrigActive(p_rxParams.GetValueInt("state"), p_rxParams.GetValue("guid"));
		elseif(p_xType == "OBAP")then
			return new CActionObjAppear(p_rxParams);
		//From AyCe
		elseif(p_xType == "OBHP")then
			return new CActionObjHitpoints(p_rxParams);
		elseif(p_xType == "TECH")then
			return new CActionTechTreePages(p_rxParams);
		elseif(p_xType == "GAOV")then
			return new CActionGameOver(p_rxParams);
		elseif(p_xType == "FDBK")then
			return new CActionFeedback(p_rxParams.GetValue("msg_text"), p_rxParams.GetValueInt("player_id"));
		elseif(p_xType == "DGSC")then
			return new CActionDialogScene(p_rxParams);
		elseif(p_xType == "QUES")then
			return new CActionQuest(p_rxParams);
		elseif(p_xType == "CPLX")then
			return new CActionComplexCreate(p_rxParams);
		elseif(p_xType == "ACND")then
			return new CActionNode(p_rxParams);
		elseif(p_xType == "MPNG")then
			return new CActionMapPing(p_rxParams);
		elseif(p_xType == "POPL")then
			return new CActionPopulationLimit(p_rxParams);
		elseif(p_xType == "BLSL")then
			return new CActionBlockSlots(p_rxParams);
		elseif(p_xType == "DIPL")then
			return new CActionDiplomacy(p_rxParams);
		elseif(p_xType == "AIRG")then
			return new CActionAiRegion(p_rxParams);
		elseif(p_xType == "AIBV")then
			return new CActionAiBehavior(p_rxParams);
		elseif(p_xType == "AICM")then
			return new CActionAiCallModule(p_rxParams);
		elseif(p_xType == "AIDA")then
			return new CActionAiDefendArea(p_rxParams);
		elseif(p_xType == "AILU")then
			return new CActionAiLockUnit(p_rxParams);
		elseif(p_xType == "VARS")then
			return new CActionVars(p_rxParams);
		elseif(p_xType == "WTHR")then
			return new CActionWeather(p_rxParams);
		elseif(p_xType == "HELP")then
			return new CActionHelp(p_rxParams);
		elseif(p_xType == "PSND")then
			return new CActionSound(p_rxParams);
		elseif(p_xType == "DELO")then
			return new CActionDelObj(p_rxParams);
		elseif(p_xType == "REPL")then
			return new CActionReplaceObj(p_rxParams);
		elseif(p_xType == "VTME")then
			return new CActionVirtTime(p_rxParams);
		elseif(p_xType == "SPGR")then
			return new CActionSpawnGroup(p_rxParams);
		elseif(p_xType == "AIFT")then
			return new CActionAiFight(p_rxParams);
		elseif(p_xType == "AIAM")then
			return new CActionAiAggressionMode(p_rxParams);
		elseif(p_xType == "ADGR")then
			return new CActionAddToGroup(p_rxParams);
		//From AyCe
		elseif(p_xType == "RMGR")then
			return new CActionRemoveFromGroup(p_rxParams);
		elseif(p_xType == "TRSP")then
			return new CActionTransportMounting(p_rxParams);
		elseif(p_xType == "MUSI")then
			return new CActionMusic(p_rxParams);
		elseif(p_xType == "INBA")then
			return new CActionInfoBar(p_rxParams);
		elseif(p_xType == "QUSA")then
			return new CActionQuickSave(p_rxParams);
		elseif(p_xType == "MRGN")then
			return new CActionMoveRegion(p_rxParams);
		elseif(p_xType == "SNFA")then
			return new CActionSetNeutForAnml(p_rxParams);
		elseif(p_xType == "PLCP")then
			return new CActionPlayerCaps(p_rxParams);
		elseif(p_xType == "ARGN")then
			return new CActionActivateRegion(p_rxParams);
		elseif(p_xType == "NWTK")then
			return new CActionNewsTicker(p_rxParams);
		elseif(p_xType == "UIFF")then
			return new CActionUIFeedbackFrame(p_rxParams);
		elseif(p_xType == "SCRE")then
			return new CActionScreenRegion(p_rxParams);
		elseif(p_xType == "QMRK")then
			return new CActionQuestionMark(p_rxParams);
		elseif(p_xType == "AKOS")then
			return new CActionAddKOTHSector(p_rxParams);
		elseif(p_xType == "TIMR")then
			return new CActionTimer(p_rxParams);
		elseif(p_xType == "EFCT")then
			return new CActionEffect(p_rxParams);
		elseif(p_xType == "DGFB")then
			return new CActionDialogFeedback(p_rxParams);
		endif;
		return null;
	endproc;
	
endclass;
	
class CActionObjFinder inherit CObjFinder
	var int m_iCondIdx;
	var ^CTrigger m_pxTrigger;
	
	export constructor()
		m_iCondIdx=-1;
	endconstructor;
	
	export proc void InitTrigger(^CTrigger p_pxTrigger)
		m_pxTrigger=p_pxTrigger;
	endproc;
	
	export proc void Init(ref CAttribs p_rxParams)
		Init(p_rxParams, "");
	endproc;
	
	export proc void Init(ref CAttribs p_rxParams, string p_sPrefix)
		m_iCondIdx=p_rxParams.GetValueInt(p_sPrefix+"from_condition");
		super.Init(p_rxParams, p_sPrefix);
	endproc;
	
	export proc void SetRegion(CGuid p_xGuid)
		if(m_iCondIdx==-1)then super.SetRegion(p_xGuid); endif;
		/* we can't set region for condition
		var ^ObjFinder pxOF=GetCondObjFinder();
		if(pxOF!=null)then pxOF^.SetRegion(p_xGuid); endif;
		*/
	endproc;
	
	export proc ^CRegion GetRegion()
		if(m_iCondIdx==-1)then return super.GetRegion(); endif;
		if(m_pxTrigger==null)then return null; endif;
		if(m_iCondIdx>=m_pxTrigger^.NumConditions())then return null; endif;
		var ^CConditionObjFinder pxCond=cast<CConditionObjFinder>(m_pxTrigger^.GetCondition(m_iCondIdx));
		if(pxCond==null)then return null; endif;
		return pxCond^.m_xObjFinder.GetRegion();
	endproc;
	
	export proc bool MakeQuery(ref CObjList po_rxObjs)
		po_rxObjs.Clear();
		if(m_iCondIdx==-1)then return super.MakeQuery(po_rxObjs); endif;
		if(m_pxTrigger==null)then return false; endif;
		if(m_iCondIdx>=m_pxTrigger^.NumConditions())then return false; endif;
		var ^CConditionObjFinder pxCond=cast<CConditionObjFinder>(m_pxTrigger^.GetCondition(m_iCondIdx));
		if(pxCond==null)then return false; endif;
		po_rxObjs=pxCond^.m_xResultObjects;
		return true;
	endproc;
	
	export proc void DoKArc(ref CArc p_rxArc)
		super.DoKArc(p_rxArc);
		p_rxArc << m_iCondIdx;
	endproc;
	
endclass;
	
//----------------------------------------------------------
// Action:	Unit
//----------------------------------------------------------
class CActionUnit inherit CTrigger.IAction
	
	var CGuid 	m_xGuid;
	var CFourCC	m_xType;
	var string	m_sAttribName;
	var bool	m_bFromCond;
	var string	m_sValue;
	
	var CActionObjFinder m_xObjFinder;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxParams)
		m_xObjFinder.Init(p_rxParams);
		m_sAttribName = p_rxParams.GetValue("attrib_name");
		m_sValue = p_rxParams.GetValue("attrib_mod");
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		m_xObjFinder.InitTrigger(GetAttachedTrigger());
		var CObjList xObjs;
		m_xObjFinder.MakeQuery(xObjs);
		m_sValue.TrimLeft();
		var int i, iC = xObjs.NumEntries();
		for(i=0)cond(i<iC) iter(++i)do
			var ^CGameObj pxO = xObjs[i].GetObj();
			if(pxO!=null)then
				var ^CAttribs pxAttr = pxO^.GetAttribs();
				var string sVal;
				if(pxAttr!=null)then
					if(m_sValue.GetAt(0) == '+')then
						sVal = m_sValue.Mid(1);
						pxAttr^.SetValue(m_sAttribName, pxAttr^.GetValueInt(m_sAttribName) + sVal.ToInt());
					elseif(m_sValue.GetAt(0) == '-')then
						sVal = m_sValue.Mid(1);
						pxAttr^.SetValue(m_sAttribName, pxAttr^.GetValueInt(m_sAttribName) -sVal.ToInt());
					elseif(m_sValue.GetAt(0) == '=')then
						sVal = m_sValue.Mid(1);
						pxAttr^.SetValue(m_sAttribName, sVal.ToInt());
					else
						sVal = m_sValue;
						pxAttr^.SetValue(m_sAttribName, m_sValue.ToInt());
					endif;
				endif;
				var ^CFightingObj pxFO = cast<CFightingObj>(pxO);
				if(pxFO!=null)then
					pxFO^.UpdateAttribs(true);
				endif;
				var ^CFountain pxWell = cast<CFountain>(pxO);
				if(pxWell!=null)then
					pxWell^.UpdateState();
				endif;
			endif;
		endfor;
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="UNIT")then
			if(p_pxNode^.GetVersion()==1)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_sAttribName;
				(pxArc^) << m_sValue;
				(pxArc^) << m_bFromCond;
				if(m_bFromCond)then
					var string sType;
					(pxArc^) << sType;
					m_xType=sType;
				else
					(pxArc^) << m_xGuid;
					var ^CGameObj pxObj = CSrvWrap.GetObjMgr()^.GetObjByGuid(m_xGuid);
					if(pxObj != null)then
						CSrvWrap.GetObjMgr()^.Subscribe(pxObj^.GetHandle(), this);
					endif;
				endif;
			elseif(p_pxNode^.GetVersion()==2)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_sAttribName;
				(pxArc^) << m_sValue;
				m_xObjFinder.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="UNIT";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,2);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_sAttribName;
		(pxArc^) << m_sValue;
		m_xObjFinder.DoKArc(pxArc^);
		pxN^.Close();
	endproc;
	
endclass;
	
//----------------------------------------------------------
// Action:	Ressource
//----------------------------------------------------------
class CActionRessource inherit CTrigger.IAction
	
	var int					m_iPlayerID;
	var string			m_sRes;
	var string			m_sMod;
	var int					m_iModVal;
	var int					m_iCap;
	var int					m_iResValue;
	var int					m_iResLimit;
	var string			m_sResList;
	
	export constructor()
	endconstructor;
	
	export constructor(int p_iPlayerID, string p_sName, string p_sMod, int p_iCap, string p_sResList)
		m_iPlayerID = p_iPlayerID;
		m_sRes = p_sName;
		m_sMod = p_sMod.Left(1);
		p_sMod.TrimLeft(m_sMod);
		m_iModVal=p_sMod.ToInt();
		if(m_sMod != "=" && m_sMod != "-" && m_sMod != "+")then
			CSrvWrap.LogError("Actions", "No valid modificator found. Allowed are '+','-' and '='.");
		endif;
		m_iCap = p_iCap;
		m_sResList=p_sResList;
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		var ^CPlayer pxPlayer = pxLevel^.GetPlayer(m_iPlayerID);
		if(pxPlayer != null)then 
			var ^CAttribs pxAttr = pxPlayer^.GetAttribs();
			if(pxAttr!=null)then 
				if(m_sResList=="")then 
					m_iResLimit=pxAttr^.GetValueInt("max_"+m_sRes);
					m_iResValue = pxAttr^.GetValueInt(m_sRes);
					if(m_iCap==1 && m_sMod == "+" && m_sRes != "iron")then
						if(m_iResLimit < (m_iResValue + m_iModVal))then
							pxPlayer^.SetRessource(m_sRes, m_iResLimit);
						else
							pxPlayer^.SetRessource(m_sRes, m_iResValue + m_iModVal);
						endif;
					elseif(m_iCap==1 && m_sMod == "=" && m_sRes != "iron")then
						if(m_iResLimit < m_iModVal)then
							pxPlayer^.SetRessource(m_sRes, m_iResLimit);
						else
							pxPlayer^.SetRessource(m_sRes, m_iModVal);
						endif;
					elseif(m_iCap==1 && m_sMod == "-")then
						if((m_iResValue - m_iModVal) < 0)then
							pxPlayer^.SetRessource(m_sRes, 0);
						else
							pxPlayer^.SetRessource(m_sRes, m_iResValue - m_iModVal);
						endif;
					else
						var int iPlayerVal = pxAttr^.GetValueInt(m_sRes);
						if(m_sMod == "=")then
							pxPlayer^.SetRessource(m_sRes, m_iModVal);
						elseif(m_sMod == "-")then
							if((iPlayerVal - m_iModVal) < 0)then
								pxPlayer^.SetRessource(m_sRes, 0);
							else
								pxPlayer^.SetRessource(m_sRes, iPlayerVal - m_iModVal);
							endif;
						elseif(m_sMod == "+")then
							pxPlayer^.SetRessource(m_sRes, iPlayerVal + m_iModVal);
						endif;
						// HACK for KingOgTheHill-Test
						/*if(m_sRes=="points")then
							//L KLog.LogSpam("MaZi", "Points: " + pxAttr^.GetValueInt(m_sRes).ToString());
						endif;*/
						// ENDHACK
					endif;
				else
					var int i;
					var array string asTokens;
					//ResName, Modifier, Kapazitätscheck
					m_sResList.Split(asTokens, ":", true);
					for (i=0)cond (i < asTokens.NumEntries()) iter(++i)do
						var string sTmpRow = asTokens[i];
						var array string asTmpTokens;
						sTmpRow.Split(asTmpTokens,"|",true);
						if(asTmpTokens.NumEntries()<3)then continue; endif;
						m_sRes		= asTmpTokens[0];
						m_iResLimit = pxAttr^.GetValueInt("max_"+m_sRes);
						m_iResValue = pxAttr^.GetValueInt(m_sRes);
						m_sMod 		= asTmpTokens[1].Left(1);
						m_iCap 		= asTmpTokens[2].ToInt();
						if(m_sMod != "=" && m_sMod != "-" && m_sMod != "+")then
							CSrvWrap.LogError("Actions", "No valid modificator found. Allowed are '+','-' and '='.");
							return false;
						endif;
						asTmpTokens[1].TrimLeft(m_sMod);
						m_iModVal=asTmpTokens[1].ToInt();
						if(m_iCap==1 && m_sMod == "+" && m_sRes != "iron")then
							if(m_iResLimit < (m_iResValue + m_iModVal))then
								pxPlayer^.SetRessource(m_sRes, m_iResLimit);
							else
								pxPlayer^.SetRessource(m_sRes, m_iResValue + m_iModVal);
							endif;
						elseif(m_iCap==1 && m_sMod == "=" && m_sRes != "iron")then
							if(m_iResLimit < m_iModVal)then
								pxPlayer^.SetRessource(m_sRes, m_iResLimit);
							else
								pxPlayer^.SetRessource(m_sRes, m_iModVal);
							endif;
						elseif(m_iCap==1 && m_sMod == "-")then
							if((m_iResValue - m_iModVal) < 0)then
								pxPlayer^.SetRessource(m_sRes, 0);
							elseif((m_iResValue - m_iModVal) > m_iResLimit)then
								pxPlayer^.SetRessource(m_sRes, m_iResLimit);
							else
								pxPlayer^.SetRessource(m_sRes, m_iResValue - m_iModVal);
							endif;
						else
							var int iPlayerVal = pxAttr^.GetValueInt(m_sRes);
							if(m_sMod == "=")then
								pxPlayer^.SetRessource(m_sRes, m_iModVal);
							elseif(m_sMod == "-")then
								if((iPlayerVal - m_iModVal) < 0)then
									pxPlayer^.SetRessource(m_sRes, 0);
								else
									pxPlayer^.SetRessource(m_sRes, iPlayerVal - m_iModVal);
								endif;
							elseif(m_sMod == "+")then
								pxPlayer^.SetRessource(m_sRes, iPlayerVal + m_iModVal);
							endif;
						endif;
					endfor;
				endif;
			endif;
		endif;
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="RES_")then
			var ^CArc pxArc=^(p_pxNode^.GetArc());
			if(p_pxNode^.GetVersion()==1)then
				(pxArc^) << m_iPlayerID;
				(pxArc^) << m_sRes;
				(pxArc^) << m_sMod;
				(pxArc^) << m_iModVal;
			elseif(p_pxNode^.GetVersion()==2)then
				(pxArc^) << m_iPlayerID;
				(pxArc^) << m_sRes;
				(pxArc^) << m_sMod;
				(pxArc^) << m_iModVal;
				(pxArc^) << m_iCap;
				(pxArc^) << m_sResList;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="RES_";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,2);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_iPlayerID;
		(pxArc^) << m_sRes;
		(pxArc^) << m_sMod;
		(pxArc^) << m_iModVal;
		(pxArc^) << m_iCap;
		(pxArc^) << m_sResList;
		pxN^.Close();
	endproc;
endclass;
	
//----------------------------------------------------------
// Action:	Quit
// TODO
//----------------------------------------------------------
class CActionQuit inherit CTrigger.IAction
	
	var string m_sReason;
	
	export constructor()
	endconstructor;
	
	export constructor(string p_sReason)
		m_sReason = p_sReason;
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		var ^CLevelInfoHost pxLevelInfo=^(CSrvWrap.GetCurLevel()^.GetLevelInfo());
		var ^CPropDB pxGenericData=^(pxLevelInfo^.GetGenericData());
		var string sLevelName=(pxGenericData^)["Base/LevelName"].Value();
		var string sMapType=pxLevelInfo^.GetAttribs().GetValue("GTMapType");
		if(!pxLevelInfo^.IsMultiplayer())then
			CSrvWrap.SendGenericEvtToPlayer(0,"GameOver\tCampaign\tWin");
/*		elseif(CMirageSrvMgr.Get().IsCustomMap(sLevelName))then	//unfinished, thats why commented
			//TODO: probably not all custom maps will have campaign screen
*/		elseif(pxLevelInfo^.GetNumHumanPlayers()==1)then
			CSrvWrap.SendGenericEvtToPlayer(0,"GameOver\tSkirmish\tWin");
		else//multiplayer
			CSrvWrap.SendGenericEvtToPlayer(0,"GameOver\tMultiplayer\tWin");
		endif;
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="QUIT")then
			if(p_pxNode^.GetVersion()==1)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_sReason;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="QUIT";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,1);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_sReason;
		pxN^.Close();
	endproc;
	
endclass;
	
//----------------------------------------------------------
// Action:	Boni
//----------------------------------------------------------
class CActionGiveBoni inherit CTrigger.IAction
	
	var int m_iPoints;
	
	export constructor()
	endconstructor;
	
	export constructor(int p_iPoints)
		m_iPoints=p_iPoints;
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		//CSrvCampaignMgr.Get().AddBonusPoints(m_iPoints);
		var ^CLevel pxLevel = CSrvWrap.GetCurLevel();
		if(pxLevel!=null)then
			var ^CLevelInfoHost pxLI = ^(pxLevel^.GetLevelInfo());
			var ^CGameAttribs pxAttribs=^(pxLI^.GetAttribs());
			var int iBoni=pxAttribs^.GetValueInt("BoniTotal");
			pxAttribs^.SetValue("BoniTotal",iBoni+m_iPoints);
		endif;
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="BONI")then
			if(p_pxNode^.GetVersion()==1)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_iPoints;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="BONI";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,1);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_iPoints;
		pxN^.Close();
	endproc;
	
endclass;
	
//----------------------------------------------------------
// Action:	Maps
// TODO
//----------------------------------------------------------
class CActionMaps inherit CTrigger.IAction
	
	var string m_sMapName;
	
	export constructor()
	endconstructor;
	
	export constructor(string p_sMapName)
		m_sMapName = p_sMapName;
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		//L CSrvWrap.LogInfo("Actions", "OnPush of undone Action. ( CActionMaps )");
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="MAP_")then
			if(p_pxNode^.GetVersion()==1)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_sMapName;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="MAP_";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,1);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_sMapName;
		pxN^.Close();
	endproc;
	
endclass;
	
//----------------------------------------------------------
// Action:	Occupy
// Changes the Owner of given Object
//----------------------------------------------------------
class CActionOccupy inherit CTrigger.IAction
	
	var int								m_iNewOwner;
	var CActionObjFinder	m_xObjFinder;
	var int								m_iCheckHighligthObj;
	var int								m_iTimeObjIsHighlighted;
	var int								m_iTimer;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxParams)
		m_iNewOwner = p_rxParams.GetValueInt("new_owner");
		m_xObjFinder.Init(p_rxParams);
		m_iCheckHighligthObj = p_rxParams.GetValueInt("chk_highlight");
		m_iTimeObjIsHighlighted = p_rxParams.GetValueInt("highlight_time");
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		m_xObjFinder.InitTrigger(GetAttachedTrigger());
		var CObjList xObjs;
		m_xObjFinder.MakeQuery(xObjs);
		var int i,iC=xObjs.NumEntries();
		for(i=0)cond(i<iC)iter(++i)do
			var ^CGameObj pxObj = xObjs[i].GetObj();
			if(pxObj!=null)then
				pxObj^.SetOwner(m_iNewOwner);
				OnHighlightCheck(pxObj);
			endif;
		endfor;
		return true;
	endproc;
	
	proc void OnHighlightCheck(^CGameObj p_pxObj)
		if(m_iCheckHighligthObj == 1 && m_iTimeObjIsHighlighted > 0)then
			CSrvWrap.SendGenericEvtToPlayer(m_iNewOwner, "ocupy_unit\t" + p_pxObj^.GetGuid().ToString() + "\t" + m_iTimeObjIsHighlighted.ToString());
		endif;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="OCUP")then
			if(p_pxNode^.GetVersion()==2)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_iNewOwner;
				var CGuid xRgnGuid;
				(pxArc^) << xRgnGuid;
				m_xObjFinder.SetRegion(xRgnGuid);
				m_xObjFinder.DoKArc(pxArc^);
			elseif(p_pxNode^.GetVersion()==3)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_iNewOwner;
				m_xObjFinder.DoKArc(pxArc^);
			elseif(p_pxNode^.GetVersion()==4)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_iNewOwner;
				m_xObjFinder.DoKArc(pxArc^);
				(pxArc^) << m_iCheckHighligthObj;
				(pxArc^) << m_iTimeObjIsHighlighted;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="OCUP";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,4);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_iNewOwner;
		m_xObjFinder.DoKArc(pxArc^);
		(pxArc^) << m_iCheckHighligthObj;
		(pxArc^) << m_iTimeObjIsHighlighted;
		pxN^.Close();
	endproc;
	
endclass;
	
//----------------------------------------------------------
// Action:	CreateObj
// Creates a new Object.
//----------------------------------------------------------
class CActionCreateObj inherit CTrigger.IAction
	
	var string						m_sObjClass;
	var int								m_iObjOwner;
	var vec3							m_vPos;
	var vec3							m_vRot;
	var int								m_iLevel;
	var CActionObjFinder	m_xObjSel;
	var bool							m_bPosFromObj;
	var bool							m_bIgnorePyramid;
	var string						m_sBuildUp;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxArgs)
		m_xObjSel.Init(p_rxArgs, "trgt_");
		m_sObjClass = p_rxArgs.GetValue("obj_name");
		m_iObjOwner = p_rxArgs.GetValueInt("obj_owner");
		m_vPos.FromString(p_rxArgs.GetValue("obj_pos"));
		m_vRot.FromString(p_rxArgs.GetValue("obj_rot"));
		m_iLevel = p_rxArgs.GetValueInt("obj_level");
		m_bPosFromObj = p_rxArgs.GetValueInt("pos_from_obj")==1;
		m_bIgnorePyramid = p_rxArgs.GetValueInt("ignore_pyramid")==1;
		m_sBuildUp = p_rxArgs.GetValue("buildup");
	endconstructor;
	
	export destructor()
	enddestructor;
	
	proc void OnResizeMap(int p_iOffsetX,int p_iOffsetY,^CAttribs p_pxDescAttribs)
		m_vPos.SetX(m_vPos.GetX()+p_iOffsetX.ToReal());
		m_vPos.SetY(m_vPos.GetY()+p_iOffsetY.ToReal());
		if(p_pxDescAttribs!=null)then
			p_pxDescAttribs^.SetValue("obj_pos",m_vPos.ToString());
		endif;
	endproc;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		if(m_bPosFromObj)then
			var CObjList xL;
			m_xObjSel.MakeQuery(xL);
			if(xL.NumEntries()>0)then
				var ^CGameObj pxO = xL[0].GetObj();
				if(pxO!=null)then
					m_vPos = pxO^.GetPos();
					pxO^.GetRot().ToVec3(m_vRot);
				endif;
			endif;
		endif;
		if(m_bIgnorePyramid == false)then
			if(CRequirementsMgr.Get().CheckUnits(m_iObjOwner, m_iLevel) == false)then
				//L KLog.LogSpam("RoStTmp", "No free level "+m_iLevel.ToString()+" for Object '"+m_sObjClass+"'!");
				return true;
			endif;
		endif;
		var string sModdedType="", sTmp=m_sObjClass;
		CMirageSrvMgr.CorrectInvalidNameToReal(sTmp,sModdedType);
		var ^CGameObj pxO = CSrvWrap.GetObjMgr()^.CreateObj(sTmp, m_iObjOwner, m_vPos);
		if(pxO!=null)then
			var Quat qRot;
			qRot.FromVec3(m_vRot);
			pxO^.SetRot(qRot);
			if(sModdedType!="")then
				var ^CFightingObj pxFight=cast<CFightingObj>(pxO);
				if(pxFight!=null)then
					pxFight^.AcceptModification(sModdedType);
				endif;
			else
				var ^CAttribs pxObjAttrib = pxO^.GetAttribs();
				if(pxObjAttrib!=null)then
					if(pxObjAttrib^.GetValue("tribe")!="")then
						var string sFilter="/Filters/" + pxObjAttrib^.GetValue("tribe") + "/Upgrades/" + m_sObjClass + "/" + m_sBuildUp;
						if(pxO^.GetTechTreeDef() != null)then 
							pxO^.GetTechTreeDef()^.ClearFilters();
							pxO^.GetTechTreeDef()^.EnableFilter(sFilter);
						endif;
					endif;
				endif;
			endif;
			var ^CFightingObj pxFightingObj = cast<CFightingObj>(pxO);
			if(pxFightingObj!=null)then
				pxFightingObj^.SetLevelClean(m_iLevel);
			endif;
			/// it's hacky, but works
			var ^CBuilding pxB=cast<CBuilding>(pxO);
			if(pxB!=null)then
				pxB^.SetReady();
			endif;
		endif;
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="COBJ")then
			var ^CArc pxArc=^(p_pxNode^.GetArc());
			if(p_pxNode^.GetVersion()==1)then
				(pxArc^) << m_sObjClass;
				(pxArc^) << m_iObjOwner;
				(pxArc^) << m_vPos;
				(pxArc^) << m_vRot;
			elseif(p_pxNode^.GetVersion()==2)then
				(pxArc^) << m_sObjClass;
				(pxArc^) << m_iObjOwner;
				(pxArc^) << m_vPos;
				(pxArc^) << m_vRot;
				(pxArc^) << m_iLevel;
			elseif(p_pxNode^.GetVersion()==3)then
				(pxArc^) << m_sObjClass;
				(pxArc^) << m_iObjOwner;
				(pxArc^) << m_vPos;
				(pxArc^) << m_vRot;
				(pxArc^) << m_iLevel;
				m_xObjSel.DoKArc(pxArc^);
				pxArc^ << m_bPosFromObj;
			elseif(p_pxNode^.GetVersion()==4)then
				(pxArc^) << m_sObjClass;
				(pxArc^) << m_iObjOwner;
				(pxArc^) << m_vPos;
				(pxArc^) << m_vRot;
				(pxArc^) << m_iLevel;
				m_xObjSel.DoKArc(pxArc^);
				pxArc^ << m_bPosFromObj;
				pxArc^ << m_bIgnorePyramid;
			elseif(p_pxNode^.GetVersion()==5)then
				(pxArc^) << m_sObjClass;
				(pxArc^) << m_iObjOwner;
				(pxArc^) << m_vPos;
				(pxArc^) << m_vRot;
				(pxArc^) << m_iLevel;
				m_xObjSel.DoKArc(pxArc^);
				pxArc^ << m_bPosFromObj;
				pxArc^ << m_bIgnorePyramid;
				(pxArc^) << m_sBuildUp;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="COBJ";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,5);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_sObjClass;
		(pxArc^) << m_iObjOwner;
		(pxArc^) << m_vPos;
		(pxArc^) << m_vRot;
		(pxArc^) << m_iLevel;
		m_xObjSel.DoKArc(pxArc^);
		pxArc^ << m_bPosFromObj;
		pxArc^ << m_bIgnorePyramid;
		(pxArc^) << m_sBuildUp;
		pxN^.Close();
	endproc;
	
endclass;
	
//----------------------------------------------------------
// Action:	ShowFOW
//----------------------------------------------------------
class CActionShowFOW inherit CTrigger.IAction
	
	var vec3 m_vPos;
	var int	 m_iOwner;
	var int  m_iRadius;
	var real m_fDuration;
	var CActionObjFinder 	m_xObjFinder;
	
	var bool m_bStarted;
	var real m_fStartTime;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxAttr)
		m_vPos.FromString(p_rxAttr.GetValue("pos"));
		m_iRadius = p_rxAttr.GetValueInt("radius");
		m_fDuration = p_rxAttr.GetValueFloat("duration");
		m_iOwner = p_rxAttr.GetValueInt("owner");
		m_xObjFinder.Init(p_rxAttr);
	endconstructor;
	
	export destructor()
	enddestructor;
	
	proc void OnResizeMap(int p_iOffsetX,int p_iOffsetY,^CAttribs p_pxDescAttribs)
		if(m_vPos.Abs()< 0.0001)then return; endif;
		m_vPos.SetX(m_vPos.GetX()+p_iOffsetX.ToReal());
		m_vPos.SetY(m_vPos.GetY()+p_iOffsetY.ToReal());
		if(p_pxDescAttribs!=null)then
			p_pxDescAttribs^.SetValue("pos",m_vPos.ToString());
		endif;
	endproc;
	
	proc bool StartSFOWAction(real p_fDuration )
		m_xObjFinder.InitTrigger(GetAttachedTrigger());
		if(m_vPos.Abs() < 0.0001)then
			var CObjList xObjs;
			m_xObjFinder.MakeQuery(xObjs);
			var int i, iC = xObjs.NumEntries();
			for (i=0)cond(i<iC) iter(++i)do
				if(xObjs[i].IsValid())then
					var ^CGameObj pxO = xObjs[i].GetObj();
					CreateSFOWObjects(p_fDuration, m_iOwner, pxO^.GetPos(), xObjs[i], true);
//					var ^CGameObj pxSFOW = CSrvWrap.GetObjMgr()^.CreateObj("ShowFOW_Obj", m_iOwner, pxO^.GetPos());
//					var ^CShowFOWObj pxFOWObj = cast<CShowFOWObj>(pxSFOW);
//					pxFOWObj^.SetFOW(m_iRadius.ToReal());
//					if(pxFOWObj!=null)then
//						if(p_fDuration > 0.0f)then
//							pxFOWObj^.SetKillTimer(p_fDuration);
//						endif;
//						var CFourCC xLink = "LINK";
//						pxFOWObj^.LinkAction(pxO^.GetHandle(), xLink, {0.0f, 0.0f, -2.0f});
//						m_fStartTime = CTimeMgr.Get().GetTime().GetSecondsF();
//						m_bStarted = true;
//					endif;
				endif;
			endfor;
		else
			CreateSFOWObjects(p_fDuration, m_iOwner, m_vPos, CObjHndl.Invalid(), false);
//			var ^CGameObj pxObj = CSrvWrap.GetObjMgr()^.CreateObj("ShowFOW_Obj", m_iOwner, m_vPos);
//			if(pxObj!=null)then
//				pxObj^.SetFOW(m_iRadius.ToReal());
//				var ^CShowFOWObj pxFOWObj = cast<CShowFOWObj>(pxObj);
//				if(pxFOWObj!=null && p_fDuration > 0.0f)then
//					pxFOWObj^.SetKillTimer(p_fDuration);
//				endif;
//				//pxObj^.SetVisible(false);
//				m_fStartTime = CTimeMgr.Get().GetTime().GetSecondsF();
//				m_bStarted = true;
//			endif;
		endif;
		return true;
	endproc;
	
	proc void CreateSFOWObjects(real p_fDuration, int p_iPlayer, vec3 p_vPos, CObjHndl p_xHndl, bool p_bLink)
		var CFourCC xLink = "LINK";
		var int i, iC=8, iStart=-1;
		if(p_iPlayer!=-2)then
			iStart=p_iPlayer;
			iC=p_iPlayer+1;
		endif;
		for(i=iStart)cond(i<iC)iter(i++)do
			var ^CGameObj pxSFOW = CSrvWrap.GetObjMgr()^.CreateObj("ShowFOW_Obj", i, p_vPos);
			var ^CShowFOWObj pxFOWObj = cast<CShowFOWObj>(pxSFOW);
			pxFOWObj^.SetFOW(m_iRadius.ToReal());
			if(pxFOWObj!=null)then
				if(p_fDuration > 0.0f)then
					pxFOWObj^.SetKillTimer(p_fDuration);
				endif;
				if(p_bLink)then
					pxFOWObj^.LinkAction(p_xHndl, xLink, {0.0f, 0.0f, -2.0f});
				endif;
			endif;
		endfor;
		m_fStartTime = CTimeMgr.Get().GetTime().GetSecondsF();
		m_bStarted = true;
	endproc;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		return StartSFOWAction(m_fDuration);
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="SFOW")then
			if(p_pxNode^.GetVersion()==1)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_iRadius;
				(pxArc^) << m_fDuration;
				(pxArc^) << m_iOwner;
				(pxArc^) << m_vPos;
			elseif(p_pxNode^.GetVersion()==2)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_iRadius;
				(pxArc^) << m_fDuration;
				(pxArc^) << m_iOwner;
				(pxArc^) << m_vPos;
				m_xObjFinder.DoKArc(pxArc^);
			elseif(p_pxNode^.GetVersion()==3)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_iRadius;
				(pxArc^) << m_fDuration;
				(pxArc^) << m_iOwner;
				(pxArc^) << m_vPos;
				(pxArc^) << m_bStarted;
				(pxArc^) << m_fStartTime;
				m_xObjFinder.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxNode);
		endif;
		var bool bStartNow = false;
		var real fDur = 0.0f;
		if(m_bStarted)then
			if(m_fDuration > 0.0f)then
				 fDur = m_fDuration - (CTimeMgr.Get().GetTime().GetSecondsF() - m_fStartTime);
				if(fDur > 0.0f)then
					bStartNow = true;
				endif;
			else
				bStartNow = true;
			endif;
		endif;
		if(bStartNow)then
			StartSFOWAction(fDur);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="SFOW";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,3);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_iRadius;
		(pxArc^) << m_fDuration;
		(pxArc^) << m_iOwner;
		(pxArc^) << m_vPos;
		(pxArc^) << m_bStarted;
		(pxArc^) << m_fStartTime;
		m_xObjFinder.DoKArc(pxArc^);
		pxN^.Close();
	endproc;
	
endclass;
	
//----------------------------------------------------------
// Action:	PlaceCam
//----------------------------------------------------------
class CActionPlaceCam inherit CTrigger.IAction
	
	var vec3 m_vLookAt;
	
	var int m_iClientID;
	var int m_iSetDefault;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxParams)
		m_vLookAt.FromString(p_rxParams.GetValue("lookat"));
		m_iClientID = p_rxParams.GetValueInt("client_id");
		m_iSetDefault = p_rxParams.GetValueInt("set_default");
	endconstructor;
	
	export destructor()
	enddestructor;
	
	proc void OnResizeMap(int p_iOffsetX,int p_iOffsetY,^CAttribs p_pxDescAttribs)
		m_vLookAt.SetX(m_vLookAt.GetX()+p_iOffsetX.ToReal());
		m_vLookAt.SetY(m_vLookAt.GetY()+p_iOffsetY.ToReal());
		if(p_pxDescAttribs!=null)then
			p_pxDescAttribs^.SetValue("lookat",m_vLookAt.ToString());
		endif;
	endproc;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		var string sSend = m_vLookAt.ToString() + "\t" + m_iSetDefault.ToString();
		CSrvWrap.SendGenericEvtToPlayer(m_iClientID, "SetCam\t" + sSend);
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="PCAM")then
			if(p_pxNode^.GetVersion()==1)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_iClientID;
				(pxArc^) << m_vLookAt;
				(pxArc^) << m_iSetDefault;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="PCAM";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,1);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_iClientID;
		(pxArc^) << m_vLookAt;
		(pxArc^) << m_iSetDefault;
		pxN^.Close();
	endproc;
	
endclass;
	
//----------------------------------------------------------
// Action:	ObjDo
//----------------------------------------------------------
class CActionObjDo inherit CTrigger.IAction
	
	var CGuid		m_xGuid;
	var CGuid		m_xTargetObj;
	var string	m_sAction;
	var string	m_sAdditionalParams;
	var bool		m_bFromCond;
	var bool		m_bTargetFromCond;
	var real		m_fSecs;
	var string	m_sAttribName;
	var int			m_iCheckSubj;
	
	var CActionObjFinder	m_xObjFinder;
	var CActionObjFinder	m_xSubFinder;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxAttr)
		/*m_xGuid.FromString(p_rxAttr.GetValue("obj_guid"));
		if(p_rxAttr.GetValue("obj_guid") == "From Condition")then
			m_bFromCond = true;
		else
			m_bFromCond = false;
		endif;
		var string sTmp = p_rxAttr.GetValue("target_guid");
		if(sTmp=="From Condition")then
			m_bTargetFromCond=true;
		else
			m_bTargetFromCond=false;
		endif;
		if(sTmp!="")then m_xTargetObj.FromString(sTmp); endif;*/
		m_sAttribName = "invul_state";
		m_sAction = p_rxAttr.GetValue("action");
		m_sAdditionalParams = p_rxAttr.GetValue("additional_params");
		m_xObjFinder.Init(p_rxAttr);
		m_xSubFinder.Init(p_rxAttr, "dst_");
		m_iCheckSubj = p_rxAttr.GetValueInt("check_subj");
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		m_xObjFinder.InitTrigger(GetAttachedTrigger());
		m_xSubFinder.InitTrigger(GetAttachedTrigger());
		var CObjList xObjs, xSubs;
		m_xObjFinder.MakeQuery(xObjs);
		m_xSubFinder.MakeQuery(xSubs);
		var int i,iC=xObjs.NumEntries();
		for(i=0)cond(i<iC)iter(++i)do
			var ^CGameObj pxObj = xObjs[i].GetObj();
			if(pxObj!=null)then
				HandleAction(pxObj, xSubs);
			endif;
		endfor;
		return true;
	endproc;
	
	proc void HandleAction(^CGameObj p_pxObj, ref CObjList p_rxSubs)
		var int iOwner=p_pxObj^.GetOwner();
		if(m_sAction == "WalkAction" || m_sAction == "SetPos" || m_sAction=="Aggressive Walk" || m_sAction=="RotateTo")then
			var vec3 vPos;
			var array string asTokens;
			m_sAdditionalParams.Split(asTokens, "|", true);
			if(asTokens.NumEntries()<2 && (m_sAction!="RotateTo"))then return; endif;
			vPos.FromString(asTokens[0]);
			var ^CFightingObj pxFO = cast<CFightingObj>(p_pxObj);
			if(pxFO!=null)then
				var ^CTransportObj pxTO=cast<CTransportObj>(pxFO^.GetTransportObj().GetObj());
				if(pxTO!=null)then
//					if(iOwner!=pxTO^.GetOwner())then
						return;
//					endif;
//					pxTO^.OnDismount(pxFO^.GetHandle());
				endif;
			endif;
			if(m_sAction == "WalkAction")then
				DoWalkAction(p_pxObj, vPos, asTokens[1].ToInt());
			elseif(m_sAction=="Aggressive Walk")then
				p_pxObj^.HandleGamePlayCommand("Action", null, vPos, "/AggressiveTarget");
			elseif(m_sAction=="RotateTo")then
				var ^CFightingObj pxFO = cast<CFightingObj>(p_pxObj);
				if(pxFO!=null)then
					pxFO^.BreakEveryTask();
				endif;
				p_pxObj^.TerminateAction();
				if(pxFO!=null)then
					pxFO^.RotateToEnemy(null,vPos);
				endif;
			else
				if(p_pxObj^.GetType()=="GROU")then
					p_pxObj^.HandleGamePlayCommand("Action", null, vPos, "/SetPos");
				else
					var ^CFightingObj pxFO = cast<CFightingObj>(p_pxObj);
					if(pxFO!=null)then
						pxFO^.BreakEveryTask();
					endif;
					p_pxObj^.TerminateAction();
					p_pxObj^.SetPos(vPos);
					//From AyCe
					CSrvWrap.GetPathfinder().UpdatePFBlocker(p_pxObj);
				endif;
			endif;
		elseif(m_sAction == "FullHeal")then
			var ^CFightingObj pxFighter=cast<CFightingObj>(p_pxObj);
			if(pxFighter!=null)then pxFighter^.FullHeal(); endif;
		elseif(m_sAction == "Attack")then
			DoAttack(p_pxObj, p_rxSubs);
		elseif(m_sAction=="AdvanceAction")then
			var array string asToks;
			m_sAdditionalParams.Split(asToks, "|", true);
			var real fMinDist = 1.0f;
			var int iSpeed = 3;
			if(asToks.NumEntries()>=1)then
				fMinDist = asToks[0].ToReal();
			endif;
			if(asToks.NumEntries()>=2)then
				iSpeed = asToks[1].ToInt();
			endif;
			var int i, iC = p_rxSubs.NumEntries();
			for(i=0)cond(i<iC) iter(++i)do
				p_pxObj^.AdvanceAction(p_rxSubs[i], fMinDist, iSpeed);
			endfor;
		elseif(m_sAction == "SetAnim")then
			var array string asToks;
			m_sAdditionalParams.Split(asToks, "|", true);
			if(asToks.NumEntries() < 2)then return; endif;
			DoAnimAction(p_pxObj, asToks[0], asToks[1].ToInt());
		elseif(m_sAction == "Kill")then
			DoKill(p_pxObj);
		elseif(m_sAction == "AbortTask")then
			DoAbortTask(p_pxObj);
		elseif(m_sAction == "WeaponRemove")then //Kr1s1m: If the action is the newly added weapon removal, then:
			//Kr1s1m: Tokenize the input params and pass them to DoWeaponRemove similar to Invulnerability
			var array string asTokensz;
			m_sAdditionalParams.Split(asTokensz, ":", true);
			var bool bEnabled = false;
			m_fSecs = 0.0f;
			if(asTokensz[0] == "Enable")then
				bEnabled = true;
			elseif(asTokensz[0] == "Timer")then
				bEnabled = true;
				if(asTokensz.NumEntries() >= 2)then
					m_fSecs = asTokensz[1].ToReal();
				else
					//KLog.LogSpam("Kr1s1m", "Wrong parameters for WeaponRemove ACDO trigger");
				endif;
			endif;
			DoWeaponRemove(p_pxObj, bEnabled, m_fSecs);
		elseif(m_sAction == "Invulnerability")then
			var array string asToks;
			m_sAdditionalParams.Split(asToks, ":", true);
			var bool bOn = false;
			m_fSecs = 0.0f;
			if(asToks[0] == "Enable")then
				bOn = true;
			elseif(asToks[0] == "Timer")then
				bOn = true;
				if(asToks.NumEntries() >= 2)then
					m_fSecs = asToks[1].ToReal();
				else
					//L KLog.LogSpam("CyGi", "Wrong Params for AcDo");
				endif;
			endif;
			DoInvulnerability(p_pxObj, bOn, m_fSecs);
		elseif(m_sAction == "Coles Shotgun")then
			if(p_pxObj!=null)then
				if(p_pxObj^.GetName().Find("Cole")>=0)then
					DoShotgunAction(p_pxObj, p_rxSubs);
				else
					KLog.LogError("Trigger.Action.ACDO", "Shotgun-Action applied on Non-Cole Obj ... dat jeht so nich.");
				endif;
			endif;
		elseif(m_sAction == "Belas Throwdown-Shot")then
			if(p_pxObj!=null)then
				if(p_pxObj^.GetName().Find("Bela")>=0)then
					DoThrowdownAction(p_pxObj, p_rxSubs);
				else
					KLog.LogError("Trigger.Action.ACDO", "Throwdownshot-Action applied on Non-Bela Obj ... dat jeht so nich.");
				endif;
			endif;
		elseif(m_sAction == "Open Gate")then
			if(p_pxObj!=null)then
				var vec3 vP;
				p_pxObj^.HandleGamePlayCommand("Action", null, vP, "Open");
			endif;
		elseif(m_sAction == "Close Gate")then
			if(p_pxObj!=null)then
				var vec3 vP;
				p_pxObj^.HandleGamePlayCommand("Action", null, vP, "Close");
			endif;
		elseif(m_sAction == "Auto Gate")then
			if(p_pxObj!=null)then
				var vec3 vP;
				p_pxObj^.HandleGamePlayCommand("Action", null, vP, "Auto");
			endif;
		elseif(m_sAction=="Disguise")then
			DoDisguise(p_pxObj);
		elseif(m_sAction=="oracle")then
			if(p_pxObj!=null)then
				var vec3 vP;
				vP.FromString(m_sAdditionalParams);
				DoOracle(p_pxObj, vP);
			endif;
		elseif(m_sAction=="entrench")then
			if(p_pxObj!=null)then
				var vec3 vP;
				vP.FromString(m_sAdditionalParams);
				DoEntrench(p_pxObj, vP);
			endif;
		elseif(m_sAction=="lockpicking")then
			if(p_pxObj!=null)then
				var vec3 vP;
				vP.FromString(m_sAdditionalParams);
				DoLockpicking(p_pxObj, vP);
			endif;
		elseif(m_sAction=="JumpOffWall")then
			if(p_pxObj!=null)then
				p_pxObj^.HandleGamePlayCommand("Action", null, p_pxObj^.GetPos(), "/JumpOffWall");
			endif;
		elseif(m_sAction=="TeslaLvl16Task")then
			if(p_pxObj!=null)then
				p_pxObj^.HandleGamePlayCommand("Action", null, p_pxObj^.GetPos(), "/TeslaLvl16Task");
			endif;
		elseif(m_sAction=="camouflage")then
			if(p_pxObj!=null)then
				var vec3 vP;
				vP.FromString(m_sAdditionalParams);
				DoCamouflage(p_pxObj, vP);
			endif;
		elseif(m_sAction=="LevelUp")then
			if(p_pxObj!=null)then
				p_pxObj^.HandleGamePlayCommand("Action", null, p_pxObj^.GetPos(), "LevelUp");
			endif;
		elseif(m_sAction=="Walk")then
			if(p_pxObj!=null)then
				var vec3 vP;
				vP.FromString(m_sAdditionalParams);
				p_pxObj^.HandleGamePlayCommand("Action", null, vP, "/Walk");
			endif;
		elseif(m_sAction=="FountainHeal")then
			if(p_pxObj!=null)then
				p_pxObj^.HandleGamePlayCommand("Action", null, p_pxObj^.GetPos(), "/FountainHeal");
			endif;
		elseif(m_sAction=="BoardTransporter")then
			if(p_pxObj!=null)then
				var vec3 vP;
				vP.FromString(m_sAdditionalParams);
				p_pxObj^.HandleGamePlayCommand("Action", null, vP, "/BoardTransporter");
			endif;
		elseif(m_sAction=="UnboardTransporter")then
			if(p_pxObj!=null)then
				var vec3 vP;
				vP.FromString(m_sAdditionalParams);
				p_pxObj^.HandleGamePlayCommand("Action", null, vP, "/UnboardTransporter");
			endif;
		elseif(m_sAction=="AggroState")then
			if(p_pxObj!=null)then
				p_pxObj^.HandleGamePlayCommand("Action", null, p_pxObj^.GetPos(), "/AggroState_"+m_sAdditionalParams);
			endif;
		elseif(m_sAction=="Notify")then
			if(p_pxObj!=null)then
				var vec3 vP;
				vP.FromString(m_sAdditionalParams);
				p_pxObj^.HandleGamePlayCommand("Action", null, vP, "/Notify");
			endif;
		elseif(m_sAction=="Stop")then
			if(p_pxObj!=null)then
				p_pxObj^.HandleGamePlayCommand("Action", null, p_pxObj^.GetPos(), "/Stop");
			endif;
		elseif(m_sAction=="Hu Ladder")then
			if(p_pxObj!=null)then
				var vec3 vP;
				vP.FromString(m_sAdditionalParams);
				p_pxObj^.HandleGamePlayCommand("Action", null, vP, "/hu_ladder");
			endif;
		elseif(m_sAction=="FeignDeath")then
			if(p_pxObj!=null)then
				p_pxObj^.HandleGamePlayCommand("Action", null, p_pxObj^.GetPos(), "/FeignDeath");
			endif;
		elseif(m_sAction=="RamAttack")then
			if(p_pxObj!=null)then
				p_pxObj^.HandleGamePlayCommand("Action", null, p_pxObj^.GetPos(), "/RamAttack");
			endif;
		elseif(m_sAction=="BuildDown")then
			if(p_pxObj!=null)then
				p_pxObj^.HandleGamePlayCommand("Action", null, p_pxObj^.GetPos(), "/BuildDown");
			endif;
		elseif(m_sAction=="GiveItem")then
			var ^CFightingObj pxFighter=cast<CFightingObj>(p_pxObj);
			if(pxFighter!=null && p_rxSubs.NumEntries()>0)then
				pxFighter^.AddItem(p_rxSubs[0]);
				p_rxSubs.DeleteEntry(0);
			endif;
		elseif(m_sAction=="Repair")then
			if(p_pxObj!=null)then
				p_pxObj^.HandleGamePlayCommand("Action", null, p_pxObj^.GetPos(), "/Repair");
			endif;
		elseif(m_sAction=="AjeQuicksand")then
			DoAjeQuicksand(p_pxObj, p_rxSubs);
		elseif(m_sAction=="Whirlewind")then
			DoWhirlewind(p_pxObj, p_rxSubs);
		elseif(m_sAction=="SetRallyPoint")then
			if(p_pxObj!=null)then
				var vec3 vRallyPos;
				vRallyPos.FromString(m_sAdditionalParams);
				if(vRallyPos!={0.0,0.0,0.0})then
					p_pxObj^.HandleGamePlayCommand("SetRallyPoint", null, vRallyPos, "");
				endif;
			endif;
		elseif(m_sAction=="BuildUp")then
			if(p_pxObj!=null)then
				if(p_rxSubs.NumEntries()>0 && p_rxSubs[0].IsValid())then
					var ^CBuilding pxBuilding=cast<CBuilding>(p_rxSubs[0].GetObj());
					if(pxBuilding!=null)then
						p_pxObj^.HandleGamePlayCommand("Build",pxBuilding,{0.0,0.0,0.0},"");
					endif;
				endif;
			endif;
		elseif(m_sAction=="PrepareUnboard")then //From AyCe
			if(p_pxObj!=null)then
				var vec3 vP;
				vP.FromString(m_sAdditionalParams);
				p_pxObj^.HandleGamePlayCommand("Action", null, vP, "/PrepareUnboard");
			endif;
		elseif(m_sAction=="StartHatching")then
			var ^CNest pxNest = cast<CNest>(p_pxObj);
			if(pxNest!=null)then
				pxNest^.StartTimer();
			endif;
		elseif(m_sAction=="Use")then
			UseSubject(p_pxObj, p_rxSubs);
		elseif(m_sAction=="HarvestWood")then
			if(p_pxObj!=null)then
				var vec3 vP;
				vP.FromString(m_sAdditionalParams);
				p_pxObj^.HandleGamePlayCommand("Harvest", null, vP, "");
			endif;
		elseif(m_sAction == "SetBlocker")then
			if(p_pxObj!=null)then
				p_pxObj^.HandleEditorCommand("SetPFBBlocking", null, p_pxObj^.GetPos(),m_sAdditionalParams);
			endif;
		elseif(m_sAction == "SetNoParticles")then
			if(p_pxObj!=null)then
				p_pxObj^.SetNoParticles(m_sAdditionalParams=="true");
			endif;
		elseif(m_sAction == "SetDisableShadowCast")then
			if(p_pxObj!=null)then
				p_pxObj^.SetDisableShadowCast(m_sAdditionalParams=="true");
			endif;
		elseif(m_sAction == "SetDisableShadowReceive")then
			if(p_pxObj!=null)then
				p_pxObj^.SetDisableShadowReceive(m_sAdditionalParams=="true");
			endif;
		elseif(m_sAction == "Production")then
			if(p_pxObj!=null)then
				var vec3 vP;
				p_pxObj^.HandleGamePlayCommand("Action", null, vP, m_sAdditionalParams);
			endif;
		endif;
	endproc;
	
	proc void DoWalkAction(^CGameObj p_pxObj, vec3 p_vDest, int p_iSpeed)
		if(p_pxObj==null)then return; endif;
		p_pxObj^.HandleGamePlayCommand("Action", null, p_vDest, "/Walk /Speed="+p_iSpeed.ToString());
		/*
		var ^CFightingObj pxFO = cast<CFightingObj>(p_pxObj);
		if(pxFO!=null)then
			pxFO^.GoTo(p_vDest, true, p_iSpeed, true, true);
		else
			if(p_pxObj^.GetOnWall())then
				p_pxObj^.WallWalkAction(p_vDest,true,p_iSpeed,false);
			else
				p_pxObj^.WalkAction(p_vDest, p_iSpeed);
			endif;
		endif;*/
	endproc;
	
	proc void DoAttack(^CGameObj p_pxObj, ref CObjList p_rxFoes)
		if(p_pxObj==null || p_rxFoes.NumEntries() <= 0)then return; endif;
		if(p_pxObj!=null)then
			p_rxFoes.SortDistance(p_pxObj^.GetPos());
			if(!p_rxFoes[0].IsValid())then return; endif;
			//pxFO^.Fight(p_rxFoes[0].GetObj(), p_rxFoes[0].GetObj()^.GetPos(), true);
			////L KLog.LogSpam("MaZi", ">>> " + p_pxObj^.GetName() + " attacks " + p_rxFoes[0].GetObj()^.GetName());
			p_pxObj^.HandleGamePlayCommand("Action", p_rxFoes[0].GetObj(), p_rxFoes[0].GetObj()^.GetPos(), "/Attack");
		endif;
	endproc;
	
	proc void DoAnimAction(^CGameObj p_pxObj, string p_sAnim, int p_iNumLoops)
		if(p_pxObj==null || p_sAnim.IsEmpty())then return; endif;
		p_sAnim.TrimRight();
		p_sAnim.TrimLeft();
		if(p_pxObj^.GetType()=="GROU")then
			var vec3 vP;
			p_pxObj^.HandleGamePlayCommand("Action", null, vP, "/AnimAction /AnimName="+p_sAnim+" /Loops="+p_iNumLoops.ToString());
		else
			var ^CFightingObj pxFO = cast<CFightingObj>(p_pxObj);
			if(pxFO!=null)then
				pxFO^.BreakEveryTask();
			endif;
			p_pxObj^.TerminateAction();
			if(p_iNumLoops > 1)then
				p_pxObj^.AnimAction(p_sAnim, p_iNumLoops, true, true);
			else
				p_pxObj^.AnimAction(p_sAnim);
			endif;
		endif;
	endproc;
	
	proc void DoKill(^CGameObj p_pxObj)
		var ^CFightingObj pxObject = cast<CFightingObj>(p_pxObj);
		if(pxObject!=null)then
			var vec3 vP;
			pxObject^.HandleGamePlayCommand("Action", null, vP, "/Kill");
		endif;
	endproc;
	
	proc void DoAbortTask(^CGameObj p_pxObj)
		if(p_pxObj==null)then return; endif;
		if(p_pxObj^.GetType()=="GROU")then
			var vec3 vP;
			p_pxObj^.HandleGamePlayCommand("Action", null, vP, "/AbortTask");
		else
			var ^CFightingObj pxFO = cast<CFightingObj>(p_pxObj);
			if(pxFO!=null)then
//				pxFO^.AbortTask();
				pxFO^.TriggerAbortTask();
			endif;
		endif;
	endproc;
	
	//Kr1s1m: added function for WeaponRemove ActionObjDo trigger
	proc void DoWeaponRemove(^CGameObj p_pxObj, bool p_bEnable, real p_fSecs)
		if(p_pxObj==null)then return; endif;
		//Kr1s1m: Cast the generic non-null object into fighting context:
		var ^CFightingObj pxFO = cast<CFightingObj>(p_pxObj);
		//Kr1s1m: Get the fighting object attribs
		//var ^CAttribs pxAttr = pxFO^.GetAttribs();
		//Kr1s1m: If the object and its attribs exist then:
		if(pxFO!=null /*&& pxAttr!=null*/)then
			if(!p_bEnable)then
				pxFO^.RemoveAllWeapons(false); //Kr1s1m: Disable WeaponRemove effect restoring weapons back
			else
				if(p_fSecs == 0.00)then
					pxFO^.RemoveAllWeapons(true); //Kr1s1m: Enable WeaponRemove effect disarming fighting object
				endif;
				if(p_fSecs > 0.00)then
					pxFO^.TriggerTimer("WeaponRemove", p_fSecs); //Kr1s1m: Enable the disarm and set an automatic disable timer
				endif;
			endif;
		endif;
	endproc;
	
	proc void DoInvulnerability(^CGameObj p_pxObj, bool p_bEnable, real p_fSecs)
		var ^CFightingObj pxFO = cast<CFightingObj>(p_pxObj);
		if(pxFO==null)then return; endif;
		var ^CAttribs pxAttr = pxFO^.GetAttribs();
		if(pxFO!=null)then
			if(!p_bEnable)then
				if(pxAttr!=null)then
					pxFO^.SetLDInvulnerable(false);
					//pxFO^.SetInvulnerable(0);
				endif;
			elseif(p_bEnable && p_fSecs == 0.00)then
				if(pxAttr!=null)then
					pxFO^.SetLDInvulnerable(true);
					//pxFO^.SetInvulnerable(1);
				endif;
			endif;
			if(p_bEnable && p_fSecs > 0.00)then
				pxFO^.TriggerTimer("Invulnerability", p_fSecs);
			endif;
		endif;
	endproc;
	
	proc void DoShotgunAction(^CGameObj p_pxObj, ref CObjList p_rxFoes)
		if(p_rxFoes.NumEntries() <= 0)then return; endif;
		var string sPath = "/Actions/";
		var ^CCharacter pxC = cast<CCharacter>(p_pxObj);
		if(pxC!=null)then
			sPath += pxC^.GetTribeName() + "/Moves/CHTR/Shotgunmove";
			p_rxFoes.SortDistance(pxC^.GetPos());
			var ^CGameObj pxEnemy = p_rxFoes[0].GetObj();
			if(pxEnemy!=null)then
				pxC^.Shotgun(pxEnemy, pxEnemy^.GetPos(), sPath, false);
			endif;
		endif;
	endproc;
	
	proc void DoThrowdownAction(^CGameObj p_pxObj, ref CObjList p_rxFoes)
		if(p_rxFoes.NumEntries() <= 0)then return; endif;
		var string sPath="/Actions/";
		var ^CCharacter pxC = cast<CCharacter>(p_pxObj);
		if(pxC!=null)then
			sPath+=pxC^.GetTribeName()+"/Moves/CHTR/Throwdownshot";
			p_rxFoes.SortDistance(pxC^.GetPos());
			var ^CGameObj pxEnemy = p_rxFoes[0].GetObj();
			if(pxEnemy!=null)then
				pxC^.Throwdownshot(pxEnemy,sPath,false);
			endif;
		endif;
	endproc;
	
	proc void DoAjeQuicksand(^CGameObj p_pxObj, ref CObjList p_rxFoes)
		if(p_pxObj!=null && m_iCheckSubj!=1)then
			var ^CCharacter pxC = cast<CCharacter>(p_pxObj);
			var string sTT = "/Actions/" + pxC^.GetPlayerTribeName() + "/Moves/CHTR/quicksand";
			if(pxC!=null)then
				var ^CGameObj pxEnemy = p_rxFoes[0].GetObj();
				if(pxEnemy!=null)then
					p_pxObj^.HandleGamePlayCommand("Action",  pxEnemy, pxEnemy^.GetPos(), sTT);
				endif;
			endif;
		elseif(m_iCheckSubj == 1)then
			if(m_sAdditionalParams == "[0.0f 0.0f 0.0f]")then return; endif;
			var ^CCharacter pxC = cast<CCharacter>(p_pxObj);
			var string sTT = "/Actions/" + pxC^.GetPlayerTribeName() + "/Moves/CHTR/quicksand";
			if(pxC!=null)then
				var vec3 vP;
				vP.FromString(m_sAdditionalParams);
				p_pxObj^.HandleGamePlayCommand("Action", null, vP, sTT);
			endif;
		endif;
	endproc;
	
	proc void DoWhirlewind (^CGameObj p_pxObj, ref CObjList p_rxFoes)
		if(p_pxObj!=null  && m_iCheckSubj!=1 )then
			var ^CCharacter pxC = cast<CCharacter>(p_pxObj);
			if(pxC!=null)then
				var ^CGameObj pxEnemy = p_rxFoes[0].GetObj();
				var string sTT = "/Actions/" + pxC^.GetPlayerTribeName() + "/Moves/CHTR/tornado";
				if(pxEnemy!=null)then
					p_pxObj^.HandleGamePlayCommand("Action",  pxEnemy, pxEnemy^.GetPos(), sTT);
				endif;
			endif;
		elseif(m_iCheckSubj == 1)then
			if(m_sAdditionalParams == "[0.0f 0.0f 0.0f]")then return; endif;
			var ^CCharacter pxC = cast<CCharacter>(p_pxObj);
			var string sTT = "/Actions/" + pxC^.GetPlayerTribeName() + "/Moves/CHTR/tornado";
			if(pxC!=null)then
				var vec3 vP;
				vP.FromString(m_sAdditionalParams);
				p_pxObj^.HandleGamePlayCommand("Action", null, vP, sTT);
			endif;
		endif;
	endproc;
	
	proc void DoDisguise(^CGameObj p_pxObj)
		if(p_pxObj!=null)then
			var ^CCharacter pxC = cast<CCharacter>(p_pxObj);
			if(pxC!=null)then
				var string sTT = "/Actions/" + pxC^.GetPlayerTribeName() + "/Moves/CHTR/Disguise";
				var vec3 vP;
				pxC^.HandleGamePlayCommand("Disguise", null, vP, sTT);
			endif;
		endif;
	endproc;
	
	proc void DoOracle(^CGameObj p_pxObj, vec3 p_vPos)
		if(p_pxObj!=null)then
			var ^CCharacter pxC = cast<CCharacter>(p_pxObj);
			if(pxC!=null)then
				var string sTT = "/Actions/" + pxC^.GetPlayerTribeName() + "/Moves/CHTR/oracle";
				pxC^.HandleGamePlayCommand("Disguise", null, p_vPos, sTT);
			endif;
		endif;
	endproc;
	
	proc void DoEntrench(^CGameObj p_pxObj, vec3 p_vPos)
		if(p_pxObj!=null)then
			var ^CCharacter pxC = cast<CCharacter>(p_pxObj);
			if(pxC!=null)then
				var string sTT = "/Actions/" + pxC^.GetPlayerTribeName() + "/Moves/CHTR/entrench";
				pxC^.HandleGamePlayCommand("Action", null, p_pxObj^.GetPos(), sTT);
			endif;
		endif;
	endproc;
	
	proc void DoLockpicking(^CGameObj p_pxObj, vec3 p_vPos)
		if(p_pxObj!=null)then
			var ^CCharacter pxC = cast<CCharacter>(p_pxObj);
			if(pxC!=null)then
				var string sTT = "/Actions/" + pxC^.GetPlayerTribeName() + "/Moves/CHTR/lockpicking";
				pxC^.HandleGamePlayCommand("Lockpicking", null, p_pxObj^.GetPos(), sTT);
			endif;
		endif;
	endproc;
	
	proc void DoCamouflage(^CGameObj p_pxObj, vec3 p_vPos)
		if(p_pxObj!=null)then
			var ^CCharacter pxC = cast<CCharacter>(p_pxObj);
			if(pxC!=null)then
				var string sTT = "/Actions/" + pxC^.GetPlayerTribeName() + "/Moves/CHTR/camouflage";
				pxC^.HandleGamePlayCommand("Camouflage", null, p_pxObj^.GetPos(), sTT);
			endif;
		endif;
	endproc;
	
	proc void UseSubject(^CGameObj p_pxObj, ref CObjList p_rxSubs)
		if(p_pxObj==null || p_rxSubs.NumEntries() <= 0)then return; endif;
		var ^CFightingObj pxFO=cast<CFightingObj>(p_pxObj);
		if(pxFO==null)then return; endif;
		var ^CCharacter pxChar=cast<CCharacter>(p_pxObj);
		if(!p_rxSubs[0].IsValid())then return; endif;
		var ^CGameObj pxTarget=p_rxSubs[0].GetObj();
		if(pxTarget==null)then return; endif;
		if(pxChar!=null)then
			begin Walls;
				var ^CWall pxW=cast<CWall>(pxTarget);
				if((pxW!=null) && CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxChar^.GetOwner(), pxW^.GetOwner()))then
					pxChar^.GoTo(pxTarget^.GetPos(),true,pxChar^.GetDefaultSpeed(),true,true,true, false);
					return;
				endif;
			end Walls;
			if(pxTarget!=null)then
				var ^CGrowingField pxGrow=cast<CGrowingField>(pxTarget);
				if(pxGrow!=null)then
					pxChar^.GetCorn(pxTarget,false);
					return;
				elseif(pxTarget^.GetAttribs()!=null && pxTarget^.GetAttribs()^.GetValueInt("UnlimitedBuilding")==1)then
					pxChar^.GetUnlimited(pxTarget,false);
					return;
				endif;
			endif;
			var ^CResource pxResource=cast<CResource>(pxTarget);
			if(pxResource!=null)then
				if(pxResource^.GetType()=="STON")then
					pxChar^.Mine(p_rxSubs[0],true);
					return;
				elseif(pxResource^.GetType()=="FOOD")then
					pxChar^.GetFood(p_rxSubs[0],true,1);
					return;
				elseif(pxResource^.GetType()=="FRUI")then
					pxChar^.GetFood(p_rxSubs[0],true,1);
					return;
				elseif(pxResource^.GetType()=="WOOD")then
					pxChar^.Harvest(pxResource,pxResource^.GetPos(),true);
					return;
				endif;
			endif;
		endif;
		if(pxTarget!=null)then
			pxFO^.GoToObj(pxTarget^.GetHandle(),true, false);
		endif;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="OBDO")then
			if(p_pxNode^.GetVersion()==1)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_xGuid;
				(pxArc^) << m_xTargetObj;
				(pxArc^) << m_sAction;
				(pxArc^) << m_sAdditionalParams;
				(pxArc^) << m_bFromCond;
				(pxArc^) << m_bTargetFromCond;
			elseif(p_pxNode^.GetVersion()==2)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_sAction;
				(pxArc^) << m_sAdditionalParams;
				m_xObjFinder.DoKArc(pxArc^);
				m_xSubFinder.DoKArc(pxArc^);
			elseif(p_pxNode^.GetVersion()==3)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_sAction;
				(pxArc^) << m_sAdditionalParams;
				m_xObjFinder.DoKArc(pxArc^);
				m_xSubFinder.DoKArc(pxArc^);
				(pxArc^) << m_iCheckSubj;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="OBDO";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,3);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_sAction;
		(pxArc^) << m_sAdditionalParams;
		m_xObjFinder.DoKArc(pxArc^);
		m_xSubFinder.DoKArc(pxArc^);
		(pxArc^) << m_iCheckSubj;
		/*(pxArc^) << m_xGuid;
		(pxArc^) << m_xTargetObj;
		(pxArc^) << m_sAction;
		(pxArc^) << m_sAdditionalParams;
		(pxArc^) << m_bFromCond;
		(pxArc^) << m_bTargetFromCond;*/
		pxN^.Close();
	endproc;
	
endclass;
	
//----------------------------------------------------------
// Action:	Waypoints
//----------------------------------------------------------
class CActionAIKotHAreas inherit CTrigger.IAction
	
	var string m_sAreas;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxAttr)
		m_sAreas = p_rxAttr.GetValue("areas");
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		var array string asTokens;
		m_sAreas.Split(asTokens, "|", true);
		var int i, iC = asTokens.NumEntries();
		//L KLog.LogSpam("RoStTmp", "Found "+iC.ToString()+" Entries");
		for(i=0)cond(i<iC)iter(++i)do
			var array string asSubTokens;
			asTokens[i].Split(asSubTokens, ";", true);
			if(asSubTokens.NumEntries() != 2)then
				//L KLog.LogWarn("RoStTmp", "Malformed Area Entry: "+asTokens[i]+" (not 2 tokens)");
				continue;
			endif;
			var vec3 vPos;
			vPos.FromString(asSubTokens[0]);
			var real fRadius = asSubTokens[1].ToReal();
			var ^CGameObj pxO = CSrvWrap.GetObjMgr()^.CreateObj("simple_koth_sector", -1);
			var ^CAttribs pxA = pxO^.GetAttribs();
			if(pxA!=null)then
				pxA^.SetValue("rgn_pos", vPos.ToString());
				pxA^.SetValue("rgn_radius", fRadius);
				pxA^.SetValue("controlling_team", -1);
				//L KLog.LogSpam("RoStTmp", "RegionPos : "+vPos.ToString());
				//L KLog.LogSpam("RoStTmp", "RegionRad : "+fRadius.ToString());
			endif;
		endfor;
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="AIKH")then
			if(p_pxNode^.GetVersion()==1)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_sAreas;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="AIKH";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,1);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_sAreas;
		pxN^.Close();
	endproc;
	
endclass;
	
//----------------------------------------------------------
// Action:	Waypoints
//----------------------------------------------------------
class CActionWaypoints inherit CTrigger.IAction
	
	// PatrolModes
	// 0 = No Patrol ... use queued WalkActions
	// 1 = Circular Patrol ... Ex.: 1 2 3 4 5 1 2 3 4 5 1 ....
	// 2 = Linear Patrol ... Ex.: 1 2 3 4 5 4 3 2 1 2 3 ....
	
	var CGuid					m_xObjGuid;
	var array vec3		m_avWaypoints;
	var bool					m_bFromCond;
	var int						m_iPatrolMode;
	var int						m_iSpeed;
	var bool					m_bUseMaterial;
	var bool					m_bStraightWalk;
	
	var CActionObjFinder m_xObjFinder;
	
	export constructor()
		m_bUseMaterial = true;
	endconstructor;
	
	export constructor(ref CAttribs p_rxAttr)
		var string sWaypoints = p_rxAttr.GetValue("waypoints");
		var array string asTokens;
		sWaypoints.Split(asTokens, "|", true);
		var int i;
		m_avWaypoints = 0;
		var string sTmp;
		for (i=0)cond (i<asTokens.NumEntries()) iter (++i)do
			sTmp = asTokens[i];
			sTmp.TrimLeft();
			if(sTmp=="0.0, 0.0, 0.0")then continue; endif;
			var vec3 vTmp;
			vTmp.FromString(asTokens[i]);
			m_avWaypoints.AddEntry(vTmp);
		endfor;
		m_iPatrolMode = p_rxAttr.GetValueInt("patrolmode");
		m_xObjFinder.Init(p_rxAttr);
		m_iSpeed = p_rxAttr.GetValueInt("walkspeed");
		m_bUseMaterial=p_rxAttr.GetValueInt("ignorematerial")==0;
		m_bStraightWalk = (p_rxAttr.GetValueInt("straightwalk") == 1);
	endconstructor;
	
	export destructor()
	enddestructor;
	
	proc void OnResizeMap(int p_iOffsetX,int p_iOffsetY,^CAttribs p_pxDescAttribs)
		var int i,iC=m_avWaypoints.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			m_avWaypoints[i].SetX(m_avWaypoints[i].GetX()+p_iOffsetX.ToReal());
			m_avWaypoints[i].SetY(m_avWaypoints[i].GetY()+p_iOffsetY.ToReal());
		endfor;
		if(p_pxDescAttribs!=null)then
			var string sWayPoints;
			for(i=0)cond(i<iC)iter(i++)do
				sWayPoints+=m_avWaypoints[i].ToString()+"|";
			endfor;
			p_pxDescAttribs^.SetValue("waypoints",sWayPoints);
		endif;
	endproc;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		m_xObjFinder.InitTrigger(GetAttachedTrigger());
		var CObjList xObjs;
		m_xObjFinder.MakeQuery(xObjs);
		if(m_avWaypoints.NumEntries() <= 0)then
			return false;
		endif;
		var int i, iC = xObjs.NumEntries();
		for (i=0)cond(i<iC) iter(++i)do
			var ^CGameObj pxO = xObjs[i].GetObj();
			if(pxO != null)then
				if(pxO^.GetType()=="GROU")then
					var ^CGroupObj pxGroup = cast<CGroupObj>(pxO);
					if(pxGroup!=null)then
						var int j,iJC=pxGroup^.NumMembers();
						for(j=0)cond(j<iJC) iter(++j)do
							var CObjHndl xHndl = pxGroup^.GetMember(j);
							if(xHndl.IsValid())then
								var ^CFightingObj pxFO = cast<CFightingObj>(xHndl.GetObj());
								if(pxFO!=null)then
									pxFO^.StartPatrol(m_avWaypoints, m_iPatrolMode, m_iSpeed, m_bStraightWalk);
								endif;
							endif;
						endfor;
					endif;
				else
					var ^CFightingObj pxFO = cast<CFightingObj>(pxO);
					if(pxFO!=null)then
						pxFO^.StartPatrol(m_avWaypoints, m_iPatrolMode, m_iSpeed, m_bStraightWalk);
					endif;
				endif;
			endif;
		endfor;
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="WAYP")then
			if(p_pxNode^.GetVersion()==1)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_xObjGuid;
				(pxArc^) << m_bFromCond;
				var bool bPatrol;
				(pxArc^) << bPatrol;
				if(bPatrol)then m_iPatrolMode=1; else m_iPatrolMode=0; endif;
				var int i,iC;
				(pxArc^) << iC;
				m_avWaypoints=iC;
				for (i=0)cond (i<iC) iter (++i)do
					(pxArc^) << m_avWaypoints[i];
				endfor;
			elseif(p_pxNode^.GetVersion()==2)then
				var ^CArc pxArc = ^(p_pxNode^.GetArc());
				var bool bPatrol;
				(pxArc^) << bPatrol;
				if(bPatrol)then m_iPatrolMode=1; else m_iPatrolMode=0; endif;
				var int i,iC;
				(pxArc^) << iC;
				m_avWaypoints=iC;
				for (i=0)cond (i<iC) iter (++i)do
					(pxArc^) << m_avWaypoints[i];
				endfor;
				m_xObjFinder.DoKArc(pxArc^);
			elseif( p_pxNode^.GetVersion()==3)then
				var ^CArc pxArc = ^(p_pxNode^.GetArc());
				(pxArc^) << m_iPatrolMode;
				var int i,iC;
				(pxArc^) << iC;
				m_avWaypoints=iC;
				for (i=0)cond (i<iC) iter (++i)do
					(pxArc^) << m_avWaypoints[i];
				endfor;
				m_iSpeed=3;
				m_xObjFinder.DoKArc(pxArc^);
			elseif( p_pxNode^.GetVersion()==4)then
				var ^CArc pxArc = ^(p_pxNode^.GetArc());
				(pxArc^) << m_iPatrolMode;
				var int i,iC;
				(pxArc^) << iC;
				m_avWaypoints=iC;
				for (i=0)cond (i<iC) iter (++i)do
					(pxArc^) << m_avWaypoints[i];
				endfor;
				m_xObjFinder.DoKArc(pxArc^);
				(pxArc^) << m_iSpeed;
			elseif( p_pxNode^.GetVersion()==5)then
				var ^CArc pxArc = ^(p_pxNode^.GetArc());
				(pxArc^) << m_iPatrolMode;
				var int i,iC;
				(pxArc^) << iC;
				m_avWaypoints=iC;
				for (i=0)cond (i<iC) iter (++i)do
					(pxArc^) << m_avWaypoints[i];
				endfor;
				m_xObjFinder.DoKArc(pxArc^);
				(pxArc^) << m_iSpeed;
				(pxArc^) << m_bUseMaterial;
			elseif( p_pxNode^.GetVersion()==6)then
				var ^CArc pxArc = ^(p_pxNode^.GetArc());
				(pxArc^) << m_iPatrolMode;
				var int i,iC;
				(pxArc^) << iC;
				m_avWaypoints=iC;
				for (i=0)cond (i<iC) iter (++i)do
					(pxArc^) << m_avWaypoints[i];
				endfor;
				m_xObjFinder.DoKArc(pxArc^);
				(pxArc^) << m_iSpeed;
				(pxArc^) << m_bUseMaterial;
				(pxArc^) << m_bStraightWalk;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="WAYP";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,6);
		var ^CArc pxArc=^(pxN^.GetArc());
		//(pxArc^) << m_xObjGuid;
		//(pxArc^) << m_bFromCond;
		(pxArc^) << m_iPatrolMode;
		var int i,iC=m_avWaypoints.NumEntries();
		(pxArc^) << iC;
		for (i=0)cond (i<iC) iter (++i)do
			(pxArc^) << m_avWaypoints[i];
		endfor;
		m_xObjFinder.DoKArc(pxArc^);
		(pxArc^) << m_iSpeed;
		(pxArc^) << m_bUseMaterial;
		(pxArc^) << m_bStraightWalk;
		pxN^.Close();
	endproc;
	
endclass;
	
//----------------------------------------------------------
// Action:	SeqDummy
//----------------------------------------------------------
class CActionSequence inherit CTrigger.IAction
	
	var string		m_sText;
	var string		m_sReason;
	var bool			m_bQuit;
	var bool			m_bSnapCameraBack;
	var string		m_sCameraData;
	var bool			m_bSnapActorsBack;
	var bool			m_bDisableFOW;
	var vec3			m_vFOWPos;
	var int				m_iFOWRadius;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxAttr)
		m_sText = p_rxAttr.GetValue("sequence");
		m_sReason = p_rxAttr.GetValue("reason");
		m_bQuit = p_rxAttr.GetValueInt("quit")==1;
		m_bSnapCameraBack = p_rxAttr.GetValueInt("snap_cam_back")==1;
		m_sCameraData=p_rxAttr.GetValue("camera_data");
		m_bSnapActorsBack = p_rxAttr.GetValueInt("snap_actors_back")==1;
		m_bDisableFOW = p_rxAttr.GetValueInt("disable_fow")==1;
		m_vFOWPos.FromString(p_rxAttr.GetValue("fow_pos"));
		m_iFOWRadius=p_rxAttr.GetValueInt("fow_radius");
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		/*var ^CGameObj pxObj = null;
		var ^CTrigger pxTrigger = GetAttachedTrigger();
		if(pxTrigger != null)then
			var int i=0;
			var ^CTrigger.ICondition pxCond = pxTrigger^.GetCondition(i);
			if(pxCond!=null)then
				var ^CConditionRegion pxRgnCond = cast<CConditionRegion>(pxCond);
				if(pxRgnCond!=null)then
					var ^CRegion pxRgn=pxRgnCond^.m_xObjFinder.GetRegion();
					if(pxRgn!=null)then
						if(pxRgn^.GetLastChangedObj().IsValid())then
							pxObj = pxRgn^.GetLastChangedObj().GetObj();
						endif;
					endif;
				endif;
			endif;
		endif;*/
		var CSequenceInfo xSeqInfo;
		xSeqInfo.m_sSeqFile=m_sText;
		xSeqInfo.m_bSnapCameraBack=m_bSnapCameraBack;
		xSeqInfo.m_sCameraData=m_sCameraData;
		xSeqInfo.m_bSnapActorsBack=m_bSnapActorsBack;
		xSeqInfo.m_bDisableFOW=m_bDisableFOW;
		xSeqInfo.m_vFOWPos=m_vFOWPos;
		xSeqInfo.m_fFOWRadius=m_iFOWRadius.ToReal();
		xSeqInfo.m_bQuitAfterSequence=m_bQuit;
		xSeqInfo.m_sQuitReason=m_sReason;
		CSrvWrap.StartSequence(xSeqInfo);
		if(m_bQuit)then 
			//CCampaignMgr.Get().RegisterEndSequence(m_sText, m_sReason);
		endif;
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="SEQU")then
			var ^CArc pxArc=^(p_pxNode^.GetArc());
			if(p_pxNode^.GetVersion()==1)then
				(pxArc^) << m_sText;
			endif;
			if(p_pxNode^.GetVersion()>=2)then
				(pxArc^) << m_sText;
				(pxArc^) << m_sReason;
				(pxArc^) << m_bQuit;
			endif;
			if(p_pxNode^.GetVersion()>=3)then
				(pxArc^) << m_bSnapCameraBack;
				(pxArc^) << m_bSnapActorsBack;
			endif;
			if(p_pxNode^.GetVersion()>=4)then
				(pxArc^) << m_bDisableFOW;
			endif;
			if(p_pxNode^.GetVersion()>=5)then
				(pxArc^) << m_vFOWPos;
				(pxArc^) << m_iFOWRadius;
			endif;
			if(p_pxNode^.GetVersion()==6)then
				var vec3 vTmp;
				(pxArc^) << vTmp;
				(pxArc^) << vTmp;
			endif;
			if(p_pxNode^.GetVersion()>=7)then
				(pxArc^) << m_sCameraData;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="SEQU";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,7);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_sText;
		(pxArc^) << m_sReason;
		(pxArc^) << m_bQuit;
		(pxArc^) << m_bSnapCameraBack;
		(pxArc^) << m_bSnapActorsBack;
		(pxArc^) << m_bDisableFOW;
		(pxArc^) << m_vFOWPos;
		(pxArc^) << m_iFOWRadius;
		(pxArc^) << m_sCameraData;
		pxN^.Close();
	endproc;
	
endclass;
	
//----------------------------------------------------------
class CActionDialogScene inherit CTrigger.IAction
	
	var string m_sScene;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxAttr)
		m_sScene=p_rxAttr.GetValue("scene");
		//L CSrvWrap.LogSpam("DialogScene", "CActionDialogScene::constructor() : "+m_sScene);
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		//L CSrvWrap.LogSpam("DialogScene", "DialogScene OnPush(: )"+m_sScene);
		CSrvWrap.StartDialogScene(m_sScene);
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="DGSC")then
			//if(p_pxNode^.GetVersion()==0)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_sScene;
			//endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="DGSC";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,0);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_sScene;
		pxN^.Close();
	endproc;
	
endclass;
	
//----------------------------------------------------------
// Action:	SeqDummy
//----------------------------------------------------------
class CActionFeedback inherit CTrigger.IAction
	
	var int			m_iPlayerID;
	var string	m_sText;
	
	export constructor()
	endconstructor;
	
	export constructor(string p_sText, int p_iID)
		m_sText = p_sText;
		m_iPlayerID = p_iID;
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		var bitset dwFlags = 0.ToBitset();
		if(m_iPlayerID < 0)then
			dwFlags = 0FFFFFFFFh;
		else
			dwFlags |= 01b<<m_iPlayerID;
		endif;
		if(m_iPlayerID<0)then m_iPlayerID=-2; endif;
		var CConfig xConf;
		if(xConf.GetSetB("Server/Trigger/EnableFDBK",false))then
			CFeedback.Print(m_iPlayerID, CFeedback.SYSTEM, m_sText);
		endif;
		//L KLog.LogSpam("FeedbackAction_DbgLogging", "Feedback: " + m_sText);
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="FDBK")then
			if(p_pxNode^.GetVersion()==1)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_sText;
				(pxArc^) << m_iPlayerID;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="FDBK";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,1);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_sText;
		(pxArc^) << m_iPlayerID;
		pxN^.Close();
	endproc;
	
endclass;
	
//----------------------------------------------------------
// Action:	TrigActive
//----------------------------------------------------------
class CActionTrigActive inherit CTrigger.IAction
	
	var int			m_iVal; // 0==Deactivate / 1==Activate / 2==Toggle
	var CGuid		m_xTriggerGuid;
	
	export constructor()
	endconstructor;
	
	export constructor(int p_iVal, string p_sGuid)
		m_iVal = p_iVal;
		m_xTriggerGuid.FromString(p_sGuid);
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		var int iIdx = CSrvWrap.GetTriggerMgr().FindTrigger(m_xTriggerGuid);
		if(iIdx >= 0)then
			var ^CTrigger pxTrig = CSrvWrap.GetTriggerMgr().GetTrigger(iIdx);
			if(pxTrig!=null)then
				var bool bOn = m_iVal==1 || (m_iVal==2 && pxTrig^.IsEnabled()==false);
				pxTrig^.Enable(bOn);
			endif;
			
		endif;
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="TRIG")then
			if(p_pxNode^.GetVersion()==1)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_iVal;
				(pxArc^) << m_xTriggerGuid;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="TRIG";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,1);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_iVal;
		(pxArc^) << m_xTriggerGuid;
		pxN^.Close();
	endproc;
	
endclass;
	
//----------------------------------------------------------
// Action:	ObjAppear
//----------------------------------------------------------
class CActionObjAppear inherit CTrigger.IAction
	
	const bitset VISIBLE 		= 01b;
	const bitset HITABLE 		= 010b;
	const bitset SELECTABLE 	= 0100b;
	const bitset CONSTRUCTIBLE 	= 01000b;
	const bitset DESTRUCTIBLE 	= 010000b;
	const bitset DECONSTRUCTIBLE= 0100000b;
	const bitset BLOCKER 		= 01000000b;
	
	var bitset  m_dwFlags;
	var CGuid m_xGuid;
	
	var CActionObjFinder m_xObjFinder;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxAttr)
		m_dwFlags = p_rxAttr.GetValueInt("flags").ToBitset();
		m_xObjFinder.Init(p_rxAttr);
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		m_xObjFinder.InitTrigger(GetAttachedTrigger());
		var CObjList xObjs;
		m_xObjFinder.MakeQuery(xObjs);
		var int i, iC = xObjs.NumEntries();
		for(i=0)cond(i<iC) iter(++i)do
			var ^CGameObj pxObj = xObjs[i].GetObj();
			if(pxObj!=null)then
				pxObj^.SetVisible( (m_dwFlags&VISIBLE)!=0b );
				pxObj^.SetHitable( (m_dwFlags&HITABLE)!=0b );
				var bool bSelectable = (m_dwFlags&SELECTABLE)!=0b;
				pxObj^.SetSelectable(bSelectable);
				if(!bSelectable)then
					CSrvWrap.SendGenericEvtToPlayer(pxObj^.GetOwner(), "Unselect\t"+pxObj^.GetGuid().ToString());
				endif;
				pxObj^.SetConstructible( (m_dwFlags&CONSTRUCTIBLE)!=0b );
				pxObj^.SetDeconstructible((m_dwFlags&DECONSTRUCTIBLE)!=0b);
				pxObj^.SetDestructible((m_dwFlags&DESTRUCTIBLE)!=0b);
				// RT#13585 -> use of method not allowed in USL
				// pxObj^.SetPFBlocker((m_dwFlags&BLOCKER)!=0b);
			endif;
		endfor;
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="OAPR")then
			if(p_pxNode^.GetVersion()==1)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_dwFlags;
				(pxArc^) << m_xGuid;
			elseif(p_pxNode^.GetVersion()==2)then
				var ^CArc pxArc = ^(p_pxNode^.GetArc());
				(pxArc^) << m_dwFlags;
				m_xObjFinder.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="OAPR";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,2);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_dwFlags;
		m_xObjFinder.DoKArc(pxArc^);
		pxN^.Close();
	endproc;
	
endclass;
	
//----------------------------------------------------------
// Action:	ObjHitpoints
// By AyCe
//----------------------------------------------------------
class CActionObjHitpoints inherit CTrigger.IAction
	
	var CActionObjFinder	m_xObjFinder;
	var bool							m_bDeath;
	var int								m_iType;
	var int								m_iArmour;
	var real							m_fValue;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxAttr)
		m_xObjFinder.Init(p_rxAttr);
		m_bDeath = p_rxAttr.GetValueBool("allow_death");
		m_iType = p_rxAttr.GetValueInt("hitpoint_type");
		m_iArmour = p_rxAttr.GetValueInt("use_armour");
		m_fValue = p_rxAttr.GetValueFloat("damage_value");
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		m_xObjFinder.InitTrigger(GetAttachedTrigger());
		var CObjList xObjs;
		m_xObjFinder.MakeQuery(xObjs);
		var int i, iC = xObjs.NumEntries();
		for(i=0)cond(i<iC) iter(++i)do
			var ^CGameObj pxObj = xObjs[i].GetObj();
			if(pxObj!=null)then
				DoTheAction(pxObj);
			endif;
		endfor;
		return true;
	endproc;
	
	proc void DoTheAction(^CGameObj p_pxObj)
		if(p_pxObj^.GetType()=="GROU")then
			var ^CGroupObj pxGroup = cast<CGroupObj>(p_pxObj);
			if(pxGroup!=null)then
				var ^CGameObj pxObj;
				var int j,iJC=pxGroup^.NumMembers();
				for(j=0)cond(j<iJC) iter(++j)do
					pxObj = pxGroup^.GetMember(j).GetObj();
					if(pxObj!=null)then
						DoTheAction(pxObj);
					endif;
				endfor;
			endif;
		else
			var ^CFightingObj pxFO = cast<CFightingObj>(p_pxObj);
			if(pxFO != null)then
				// Do the action here...
				// 1. Get MaxHP, HP and both Armours
				// 2. Do the modifying with type
				// 3. Write it back
				var real fHP = pxFO^.GetHitpoints();
				var real fMaxHP = pxFO^.GetMaxHitpoints();
				var real fDef = pxFO^.GetProtection();
				var real fRangedDef = pxFO^.GetRangedProtection();
				var real fArmour = 0.0;
				if(m_iArmour==1)then
					fArmour = fDef;
				elseif(m_iArmour==2)then
					fArmour = fRangedDef;
				endif;
				//CFeedback.Print(CFeedback.ALL, CFeedback.SYSTEM, "ObjHP: MaxHP: "+fMaxHP.ToString()+" \nHP: "+fHP.ToString()+" \nDef: "+fDef.ToString()+" \nRDef: "+fRangedDef.ToString());
				switch(m_iType)
					case(0)do
						// Set to absolute value
						fHP = m_fValue;
					endcase;
					case(1)do
						// Set to percent of max value
						fHP = m_fValue*fMaxHP;
					endcase;
					case(2)do
						// Cause absolute damage
						fHP -= CalculateWithArmour(m_fValue, fArmour);
					endcase;
					case(3)do
						// Cause damage: 0 = 0hp, 1 = curenthp
						fHP -= CalculateWithArmour(m_fValue*fHP, fArmour);
					endcase;
					case(4)do
						// Cause damage: 0 = 0hp, 1 = maxhp
						fHP -= CalculateWithArmour(m_fValue*fMaxHP, fArmour);
					endcase;
					case default do endcase;
				endswitch;
				if(!m_bDeath)then
					if(fHP < 1.0)then
						fHP = 1.0;
					endif;
				endif;
				if(fHP > fMaxHP)then
					fHP = fMaxHP;
				endif;
				pxFO^.SetHitpoints(fHP);
			endif;
		endif;
	endproc;
	
	proc real CalculateWithArmour(real p_fDmg, real p_fArmour)
		return p_fDmg*((100.0-p_fArmour)/100.0);
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="OBHP")then
			var ^CArc pxArc=^(p_pxNode^.GetArc());
			m_xObjFinder.DoKArc(pxArc^);
			(pxArc^) << m_bDeath;
			(pxArc^) << m_iType;
			(pxArc^) << m_iArmour;
			(pxArc^) << m_fValue;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="OBHP";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,1);
		var ^CArc pxArc=^(pxN^.GetArc());
		m_xObjFinder.DoKArc(pxArc^);
		(pxArc^) << m_bDeath;
		(pxArc^) << m_iType;
		(pxArc^) << m_iArmour;
		(pxArc^) << m_fValue;
		pxN^.Close();
	endproc;
	
endclass;
	
//----------------------------------------------------------
// Action:	TechTree
//----------------------------------------------------------
class CActionTechTreePages inherit CTrigger.IAction
	
	const int FILTER_ACTION_REM = 0;
	const int FILTER_ACTION_ADD = 1;
	
	class CFilterDesc
	
		export proc void DoKArc(^CArc p_pxArc)
			(p_pxArc^) << m_sPath;
			(p_pxArc^) << m_iAction;
		endproc;
	
		export var string		m_sPath;
		export var int			m_iAction;
	
	endclass;
	
	class CFilter
		export var array CFilterDesc	m_axFilter;
	
		export proc void DoKArc(^CArc p_pxArc)
			var int i, iC = m_axFilter.NumEntries();
			(p_pxArc^) << iC;
			m_axFilter = iC;
			for(i=0)cond(i<iC) iter(++i)do
				m_axFilter[i].DoKArc(p_pxArc);
			endfor;
		endproc;
	endclass;
	
	var array CFilter m_axFilter;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxArgs)
		var string sFilter = p_rxArgs.GetValue("filters");
		var array string asFilter;
		sFilter.Split(asFilter, "\n", true);
		var int i, iC = asFilter.NumEntries();
		for(i=0)cond(i<iC) iter(++i)do
			var array string asToks;
			asFilter[i].Split(asToks, "|", true);
			var int iPlayer = asToks[0].ToInt();
			if(iPlayer >= m_axFilter.NumEntries())then
				m_axFilter = iPlayer+1;
			endif;
			var CFilterDesc xFD;
			xFD.m_sPath = asToks[2];
			xFD.m_iAction = asToks[1].ToInt();
			m_axFilter[iPlayer].m_axFilter.AddEntry(xFD);
		endfor;
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		var int i, iC = m_axFilter.NumEntries();
		for(i=0)cond(i<iC) iter(++i)do
			var ^CPlayer pxPlayer = CSrvWrap.GetCurLevel()^.GetPlayer(i);
			if(pxPlayer==null)then continue; endif;
			var ^CFilter pxF = ^(m_axFilter[i]);
			var int j, iJC = pxF^.m_axFilter.NumEntries();
			for(j=0)cond(j<iJC) iter(++j)do
				var ^CFilterDesc pxFD = ^(pxF^.m_axFilter[j]);
				if(pxFD^.m_iAction == FILTER_ACTION_REM)then
					pxPlayer^.GetPlayerTechTreeDef().DisableFilter(pxFD^.m_sPath);
				else
					pxPlayer^.GetPlayerTechTreeDef().EnableFilter(pxFD^.m_sPath);
				endif;
			endfor;
		endfor;
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="TTRE")then
			if(p_pxNode^.GetVersion()==1)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				var string sF;
				var int iP;
				var bool bA;
				(pxArc^) << sF;
				(pxArc^) << iP;
				(pxArc^) << bA;
			elseif(p_pxNode^.GetVersion()==2)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				var int i, iC=0;
				(pxArc^) << iC;
				m_axFilter = iC;
				for(i=0)cond(i<iC) iter(++i)do
					m_axFilter[i].DoKArc(pxArc);
				endfor;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="TTRE";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,2);
		var ^CArc pxArc=^(pxN^.GetArc());
		var int i, iC = m_axFilter.NumEntries();
		(pxArc^) << iC;
		for(i=0)cond(i<iC) iter(++i)do
			m_axFilter[i].DoKArc(pxArc);
		endfor;
		pxN^.Close();
	endproc;
	
endclass;
	
//----------------------------------------------------------
// Action:	GameOver
//----------------------------------------------------------
class CActionGameOver inherit CTrigger.IAction
	
	var int				m_iPlayerID;
	var string		m_sReason;
	
	const int TIMER_ID = 1122;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxArgs)
		m_iPlayerID = p_rxArgs.GetValueInt("player_id");
		m_sReason = p_rxArgs.GetValue("reason");
	endconstructor;
	
	export constructor(int p_iPlayer, string p_sReason)
		m_iPlayerID = p_iPlayer;
		m_sReason = p_sReason;
	endconstructor;
	
	export destructor()
		DeleteTimer(TIMER_ID);
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		if(p_rxEP.GetClass()==ms_xTimerClass)then
			DeleteTimer(TIMER_ID);
			var string sLevelType="Campaign";//Skirmish;
			var string sSend = "GameOver\t"+sLevelType+"\tLose\t"+m_sReason;
			CSrvWrap.SendGenericEvtToPlayer(m_iPlayerID, sSend);
			return true;
		endif;
		if(!HasTimer(TIMER_ID))then
			CreateTimer(TIMER_ID,CGameTimeSpan.OneSecond()*4.0, false);
			CAiInterface.GameOver(m_iPlayerID, true);
			if(m_sReason=="dead")then
				var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
				var ^CPlayer pxPlayer = pxLevel^.GetPlayer(m_iPlayerID);
				if(pxPlayer != null)then
					var ^CLevelInfo.CPlayerSlot pxSlot=pxPlayer^.GetPlayerSlot();
					if(pxSlot!=null && !pxSlot^.IsFree())then
						CFeedback.Print(CFeedback.ALL, CFeedback.GAMEPLAY,"_NT_DiplPlayerKilled\t"+pxSlot^.GetName());
					endif;
				endif;
			endif;
		endif;
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="GAOV")then
			if(p_pxNode^.GetVersion()==1)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_iPlayerID;
			elseif(p_pxNode^.GetVersion()==2)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_iPlayerID;
				(pxArc^) << m_sReason;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="GAOV";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,2);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_iPlayerID;
		(pxArc^) << m_sReason;
		pxN^.Close();
	endproc;
	
endclass;
	
//----------------------------------------------------------
// Action:	ActionQuest
//----------------------------------------------------------
class CActionQuest inherit CTrigger.IAction
	
	var string	m_sQuestname;
	var CGuid		m_xGuid;
	var int			m_iOwner;
	var int			m_iDestState;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxAttr)
		m_sQuestname = p_rxAttr.GetValue("quest_name");
		m_iOwner = p_rxAttr.GetValueInt("owner");
		m_iDestState = p_rxAttr.GetValueInt("dest_state");
		m_xGuid.FromString(p_rxAttr.GetValue("quest_guid"));
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		var ^CQuestMgrHost pxQM=^(pxLevel^.GetQuestMgr());
		var ^CQuestMgr.CQuest pxQuest = pxQM^.GetQuest(m_xGuid);
		// temp fallback
		if(pxQuest==null)then
			pxQuest = pxQM^.GetQuest(m_sQuestname);
		endif;
		if(pxQuest!=null)then
			if(m_iDestState==0)then//UNACCOMPLISHED
				pxQuest^.SetAccomplished(false);
				pxQuest^.SetVisible(true);
			elseif(m_iDestState==1)then//ACCOMPLISHED)
				pxQuest^.SetAccomplished(true);
				pxQuest^.SetVisible(true);
				if(pxLevel!=null)then
					var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
					var int iDifficulty=pxLevelInfo^.GetGenericData()["Base/CurrentDifficulty"].ValueI();
					var int iBoni=pxQuest^.GetBoniEasy();
					if(iDifficulty==1)then
						iBoni=pxQuest^.GetBoniMiddle();
					elseif(iDifficulty==2)then
						iBoni=pxQuest^.GetBoniHard();
					endif;
					var ^CStatisticMgr pxStatisticMgr=^(pxLevel^.GetStatisticMgr());
					if(pxQuest^.IsMainQuest())then
						pxStatisticMgr^.AddSample(CStatisticSample.QuestPointsMain.ToInt(),0,iBoni);
					else
						pxStatisticMgr^.AddSample(CStatisticSample.QuestPointsSub.ToInt(),0,iBoni);
					endif;
					var ^CGameAttribs pxAttribs=^(pxLevelInfo^.GetAttribs());
					var int iBoniTotal=pxAttribs^.GetValueInt("BoniTotal");
					pxAttribs^.SetValue("BoniTotal",iBoniTotal+iBoni);
				endif;
			elseif(m_iDestState==2)then//UNACCOMPLISHABLE
				pxQuest^.SetUnaccomplishable(true);
				pxQuest^.SetVisible(true);
			elseif(m_iDestState==3)then//NOTVISIBLE
				pxQuest^.SetVisible(false);
			endif;
		endif;
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="QUES")then
			if(p_pxNode^.GetVersion()==1)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_sQuestname;
				(pxArc^) << m_iOwner;
				(pxArc^) << m_iDestState;
			elseif(p_pxNode^.GetVersion()==2)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_sQuestname;
				(pxArc^) << m_iOwner;
				(pxArc^) << m_iDestState;
				(pxArc^) << m_xGuid;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="QUES";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,2);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_sQuestname;
		(pxArc^) << m_iOwner;
		(pxArc^) << m_iDestState;
		(pxArc^) << m_xGuid;
		pxN^.Close();
	endproc;
	
endclass;
	
class CActionComplexCreate inherit CTrigger.IAction
	
	var string	m_sClass;
	var string	m_sBuildUp;
	var int			m_iOwner;
	var int			m_iCptLvl;
	var int			m_iIgnorePyramid;
	var int			m_iNumPassengers;
	var string	m_sPassengers;
	var vec3		m_vPos;
	var int			m_iWaitTimer;
	var int			m_iSubIndex;
	
	var ^CTransportObj m_pxTO;
	var CObjHndl m_xSubTrp;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxAttr)
		m_sClass = p_rxAttr.GetValue("obj_name");
		m_sBuildUp = p_rxAttr.GetValue("buildup");
		m_iOwner = p_rxAttr.GetValueInt("obj_owner");
		//m_iNumPassengers = p_rxAttr.GetValueInt("num_passengers");
		m_sPassengers = p_rxAttr.GetValue("passengers");
		m_vPos.FromString(p_rxAttr.GetValue("obj_pos"));
		m_iCptLvl = p_rxAttr.GetValueInt("cptlvl");
		m_iIgnorePyramid = p_rxAttr.GetValueInt("ignore_pyramid");
		m_iWaitTimer = -1;
		m_iSubIndex = 0;
	endconstructor;
	
	export destructor()
	enddestructor;
	
	proc void OnResizeMap(int p_iOffsetX,int p_iOffsetY,^CAttribs p_pxDescAttribs)
		m_vPos.SetX(m_vPos.GetX()+p_iOffsetX.ToReal());
		m_vPos.SetY(m_vPos.GetY()+p_iOffsetY.ToReal());
		if(p_pxDescAttribs!=null)then
			p_pxDescAttribs^.SetValue("obj_pos",m_vPos.ToString());
		endif;
	endproc;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		if(m_iWaitTimer >= 0 && CTimeMgr.Get().GetTimer(m_iWaitTimer) != null)then
			if(p_rxEP.GetClass() == CTimeMgr.Get().GetTimer(m_iWaitTimer)^.GetEventTemplate().GetClass())then
				CTimeMgr.Get().GetTimer(m_iWaitTimer)^.Unsubscribe(this);
				CTimeMgr.Get().DeleteTimer(m_iWaitTimer);
				if(m_pxTO==null)then return false; endif;
				var array string asPassengers;
				m_sPassengers.Split(asPassengers,"|",true);
				var int i, iC = asPassengers.NumEntries();
				for(i=m_iSubIndex)cond(i<iC)iter(i++)do
					if(m_pxTO^.IsFull())then break; endif;
					var string sCurPas = asPassengers[i];
					var array string asTok;
					sCurPas.Split(asTok,"/",true);
					if(asTok.NumEntries() < 2)then continue; endif;
					var ^CGameObj pxPas;
					if(!m_xSubTrp.IsValid())then
						if(m_iIgnorePyramid == 0)then
							if(CRequirementsMgr.Get().CheckUnits(m_iOwner, asTok[1].ToInt()-1) == false)then
								continue;
							endif;
						endif;
						var string sModdedType="", sTmp=asTok[0];
						CMirageSrvMgr.CorrectInvalidNameToReal(sTmp,sModdedType);
						pxPas = CSrvWrap.GetObjMgr()^.CreateObj(sTmp, m_pxTO^.GetOwner(), m_pxTO^.GetPos());
						var ^CFightingObj pxF = cast<CFightingObj>(pxPas);
						if(pxF!=null)then
							pxF^.SetLevelClean(asTok[1].ToInt()-1);
							if(sModdedType!="")then
								pxF^.AcceptModification(sModdedType);
								var ^CTransportObj pxSubTrp = cast<CTransportObj>(pxF);
								if(pxSubTrp!=null && asTok.NumEntries()>2)then
									m_xSubTrp = pxSubTrp^.GetHandle();
									m_iWaitTimer = CTimeMgr.Get().CreateTimer(CGameTimeSpan.OneSecond() * 0.3f, false);
									var ^CTimerObj pxSub=CTimeMgr.Get().GetTimer(m_iWaitTimer);
									pxSub^.Subscribe(this);
									m_iSubIndex=i;
									return true;
								endif;
							endif;
						endif;
					else
						pxPas=m_xSubTrp.GetObj();
						m_xSubTrp.FromInt(-1);
					endif;
					if(asTok.NumEntries()>2)then
						var string sSubPas = asTok[2];
						sSubPas.TrimLeft('(');
						sSubPas.TrimRight(')');
						var array string asSubPas;
						sSubPas.Split(asSubPas, "&", true);
						var ^CTransportObj pxT = cast<CTransportObj>(pxPas);
						if(pxT!=null)then
							var int j, iJC = asSubPas.NumEntries();
							for(j=0)cond(j<iJC) iter(++j)do
								var array string asSubPasData;
								asSubPas[j].Split(asSubPasData, ":", true);
								if(asSubPasData.NumEntries()>=1)then
									if(m_iIgnorePyramid == 0)then
										var int iSubPassLvl = 0; 
										if(asSubPasData.NumEntries() >= 2)then
											iSubPassLvl = asSubPasData[1].ToInt()-1;
										endif;
										if(CRequirementsMgr.Get().CheckUnits(m_iOwner, iSubPassLvl) == false)then
											continue;
										endif;
									endif;
									var ^CGameObj pxPas = CSrvWrap.GetObjMgr()^.CreateObj(asSubPasData[0], m_pxTO^.GetOwner());
									var ^CCharacter pxC = cast<CCharacter>(pxPas);
									if(pxC!=null)then
										if(asSubPasData.NumEntries()>=2)then
											pxC^.SetLevelClean(asSubPasData[1].ToInt()-1);
										endif;
									endif;
									pxT^.OnMount(pxPas^.GetHandle());
								endif;
							endfor;
						endif;
					endif;
					m_pxTO^.OnMount(pxPas^.GetHandle());
				endfor;
				return true;
			endif;
		endif;
		if(m_iIgnorePyramid == 0)then
			if(CRequirementsMgr.Get().CheckUnits(m_iOwner, m_iCptLvl - 1) == false)then
				//L KLog.LogSpam("RoStTmp", "No free level "+(m_iCptLvl - 1).ToString()+" for Captain/TRNS-Obj");
				return true;
			endif;
		endif;
		var ^CGameObj pxObj = CSrvWrap.GetObjMgr()^.CreateObj(m_sClass, m_iOwner, m_vPos);
		if(pxObj!=null)then
			var vec3 vP = m_vPos;
			CSrvWrap.GetObjMgr()^.GetFreePos(vP, pxObj, vP);
			pxObj^.SetPos(vP);
			var ^CTransportObj pxTO =cast<CTransportObj>(pxObj);
			if(pxTO!=null)then
				var string sFilter="/Filters/"+pxTO^.GetTribeName()+"/Upgrades/"+m_sClass+"/"+m_sBuildUp;
				pxObj^.GetTechTreeDef()^.ClearFilters();
				pxObj^.GetTechTreeDef()^.EnableFilter(sFilter);
				pxTO^.SetLevelClean(m_iCptLvl-1);
				m_iWaitTimer = CTimeMgr.Get().CreateTimer(CGameTimeSpan.OneSecond() * 0.2f, false);
				var ^CTimerObj pxTimer=CTimeMgr.Get().GetTimer(m_iWaitTimer);
				pxTimer^.Subscribe(this);
				m_pxTO = pxTO;
			endif;
		endif;
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="CPLX")then
			if(p_pxNode^.GetVersion()==1)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_sClass;
				(pxArc^) << m_sBuildUp;
				(pxArc^) << m_iOwner;
				(pxArc^) << m_iNumPassengers;
				(pxArc^) << m_vPos;
			elseif(p_pxNode^.GetVersion()==2)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_sClass;
				(pxArc^) << m_sBuildUp;
				(pxArc^) << m_iOwner;
				(pxArc^) << m_sPassengers;
				(pxArc^) << m_vPos;
			elseif(p_pxNode^.GetVersion()==3)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_sClass;
				(pxArc^) << m_sBuildUp;
				(pxArc^) << m_iOwner;
				(pxArc^) << m_sPassengers;
				(pxArc^) << m_vPos;
				(pxArc^) << m_iCptLvl;
			elseif(p_pxNode^.GetVersion()==4)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_sClass;
				(pxArc^) << m_sBuildUp;
				(pxArc^) << m_iOwner;
				(pxArc^) << m_sPassengers;
				(pxArc^) << m_vPos;
				(pxArc^) << m_iCptLvl;
				(pxArc^) << m_iIgnorePyramid;
			elseif(p_pxNode^.GetVersion()==5)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_sClass;
				(pxArc^) << m_iOwner;
				(pxArc^) << m_sPassengers;
				(pxArc^) << m_vPos;
				(pxArc^) << m_iCptLvl;
				(pxArc^) << m_iIgnorePyramid;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="CPLX";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,4);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_sClass;
		(pxArc^) << m_sBuildUp;
		(pxArc^) << m_iOwner;
		(pxArc^) << m_sPassengers;
		(pxArc^) << m_vPos;
		(pxArc^) << m_iCptLvl;
		(pxArc^) << m_iIgnorePyramid;
		pxN^.Close();
	endproc;
	
endclass;
	
class CActionNode inherit CTrigger.IAction
	
	var string		m_sNodeName;
	var int				m_iDestState;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxAttr)
		m_sNodeName  = p_rxAttr.GetValue("nodename");
		m_iDestState = p_rxAttr.GetValueInt("deststate");
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		var CTriggerDescMgr.CNode xNode = CSrvWrap.GetTriggerMgr().GetTriggerDescMgr()^.FindNodeByName(m_sNodeName);
		if(xNode.IsValid())then
			CSrvWrap.GetTriggerMgr().SetNodeActive(xNode, m_iDestState==1, m_iDestState==0);
		endif;
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="ACND")then
			if(p_pxNode^.GetVersion()==1)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_sNodeName;
				(pxArc^) << m_iDestState;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="ACND";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,1);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_sNodeName;
		(pxArc^) << m_iDestState;
		pxN^.Close();
	endproc;
	
endclass;
	
//----------------------------------------------------------
// Action:	MapPing
//----------------------------------------------------------
class CActionMapPing inherit CTrigger.IAction
	
	var vec3 m_vPos;
	var string m_sOwner;
	var bool m_bUsePos;
	var CActionObjFinder 	m_xObjFinder;
	
	var bool	m_bExtended;
	var bool	m_bAdd;
	var string	m_sID;
	var int		m_iTimeToLife;
	var int		m_iNumRepeats;
	var int		m_iMSBetween;
	
	var string m_sColorType;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxAttr)
		m_vPos.FromString(p_rxAttr.GetValue("pos"));
		m_sOwner=p_rxAttr.GetValue("owner");
		m_bUsePos=p_rxAttr.GetValueBool("pos_objquery_flag")&&(m_vPos!={0.0f,0.0f,0.0f});
		m_xObjFinder.Init(p_rxAttr);
		m_bExtended = (p_rxAttr.GetValueInt("extended") != 0);
		m_bAdd = (p_rxAttr.GetValueInt("add_remove") == 0);
		m_sID = p_rxAttr.GetValue("id");
		m_iTimeToLife = p_rxAttr.GetValueInt("time_to_life");
		m_iNumRepeats = p_rxAttr.GetValueInt("num_repeats");
		m_iMSBetween = p_rxAttr.GetValueInt("ms_between");
		m_sColorType=p_rxAttr.GetValue("colortype");
		var string sFixedColor=p_rxAttr.GetValue("fixedcolor");
		if(m_sColorType=="FixedColor")then
			m_sColorType+=":"+sFixedColor;
		endif;
		if(m_sColorType.IsEmpty())then
			m_sColorType="Attack";
		endif;
	endconstructor;
	
	export destructor()
	enddestructor;
	
	proc void OnResizeMap(int p_iOffsetX,int p_iOffsetY,^CAttribs p_pxDescAttribs)
		m_vPos.SetX(m_vPos.GetX()+p_iOffsetX.ToReal());
		m_vPos.SetY(m_vPos.GetY()+p_iOffsetY.ToReal());
		if(p_pxDescAttribs!=null)then
			p_pxDescAttribs^.SetValue("pos",m_vPos.ToString());
		endif;
	endproc;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		//Credit to AyCe
		if(m_bExtended && m_sID != "")then
			var ^CMapPingObj pxMPO;
			if(m_bAdd)then
				var int iOwner = -2;
				var vec3 vPos;
				var ^CGameObj pxO = CSrvWrap.GetObjMgr()^.CreateObj("MapPingObj", -1, vPos);
				if(pxO!=null)then
					pxMPO = cast<CMapPingObj>(pxO);
					if(pxMPO != null)then
						var array int aiOwner;
						var array vec3 avPos;
						if(m_bUsePos)then
							if(m_sOwner.ToInt().ToString()==m_sOwner)then
								aiOwner.AddEntry(m_sOwner.ToInt());
							else
								aiOwner.AddEntry(-2);
							endif;
							avPos.AddEntry(m_vPos);
						else
							var CObjList xObjList;
							m_xObjFinder.InitTrigger(GetAttachedTrigger());
							m_xObjFinder.MakeQuery(xObjList);
							var int i,iC=xObjList.NumEntries();
							for(i=0)cond(i<iC)iter(i++)do
								var ^CGameObj pxObj=xObjList[i].GetObj();
								if(pxObj!=null)then
									avPos.AddEntry(pxObj^.GetPos());
									if(m_sOwner=="All")then
										aiOwner.AddEntry(-2);
									elseif(m_sOwner=="trigger obj")then
										aiOwner.AddEntry(pxObj^.GetOwner());
									else
										aiOwner.AddEntry(m_sOwner.ToInt());
									endif;
								endif;
							endfor;
						endif;
						pxMPO^.InitMapPing(aiOwner, avPos, m_sID, m_iTimeToLife, m_iNumRepeats, m_iMSBetween, m_sColorType);
					endif;
				endif;
			else
				var CObjHndl xHndl;
				var CObjQuery xQ;
				var CObjList xResult;
				xQ.SetClass("MapPingObj");
				xQ.Execute(xResult);
				var int i, iC = xResult.NumEntries();
				var ^CGameObj pxGO;
				for(i=0)cond(i<iC)iter(i++)do
					xHndl = xResult[i];
					pxGO = xHndl.GetObj();
					if(pxGO != null)then
						pxMPO = cast<CMapPingObj>(pxGO);
						if(pxMPO != null)then
							if(pxMPO^.GetMapPingID() == m_sID)then
								pxMPO^.KillMapPing();
							endif;
						endif;
					endif;
				endfor;
			endif;
			return true;
		endif;
		if(m_sColorType.IsEmpty())then
			m_sColorType="Attack";
		endif;
		var string sMoffa = "MiniMapEvent\t"+m_vPos.ToString()+"\t"+m_sColorType;
		sMoffa+="\t"+m_bExtended.ToString()+"\t"+m_bAdd.ToString()+"\t"+m_sID;
		sMoffa+="\t"+m_iTimeToLife.ToString()+"\t"+m_iNumRepeats.ToString()+"\t"+m_iMSBetween.ToString();
		if(m_bUsePos)then
			if(m_sOwner=="All")then
				var int i;
				for(i=0)cond(i<8)iter(i++)do
					CSrvWrap.SendGenericEvtToPlayer(i, sMoffa);
				endfor;
			elseif(m_sOwner=="trigger obj")then
				CSrvWrap.SendGenericEvtToPlayer(0, sMoffa);
			else
				var int iOwner=m_sOwner.ToInt();
				CSrvWrap.SendGenericEvtToPlayer(iOwner, sMoffa);
			endif;
		else
			var CObjList xObjList;
			m_xObjFinder.InitTrigger(GetAttachedTrigger());
			m_xObjFinder.MakeQuery(xObjList);
			var int i,iC=xObjList.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				var ^CGameObj pxObj=xObjList[i].GetObj();
				if(pxObj!=null)then
					var vec3 vPos=pxObj^.GetPos();
					sMoffa.Replace("[0 0 0]",vPos.ToString());
					if(m_sOwner=="All")then
						var int i;
						for(i=0)cond(i<8)iter(i++)do
							CSrvWrap.SendGenericEvtToPlayer(i, sMoffa);
						endfor;
					elseif(m_sOwner=="trigger obj")then
						CSrvWrap.SendGenericEvtToPlayer(pxObj^.GetOwner(), sMoffa);
					else
						var int iOwner=m_sOwner.ToInt();
						CSrvWrap.SendGenericEvtToPlayer(iOwner, sMoffa);
					endif;
				endif;
			endfor;
		endif;
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="MPNG")then
			var ^CArc pxArc=^(p_pxNode^.GetArc());
			if(p_pxNode^.GetVersion()>=1)then
				(pxArc^) << m_vPos;
				(pxArc^) << m_sOwner;
				(pxArc^) << m_bUsePos;
				m_xObjFinder.DoKArc(pxArc^);
			endif;
			if(p_pxNode^.GetVersion()>=2)then
				(pxArc^) << m_sColorType;
			endif;
			if(p_pxNode^.GetVersion()>=3)then
				(pxArc^) << m_bExtended;
				(pxArc^) << m_bAdd;
				(pxArc^) << m_sID;
				(pxArc^) << m_iTimeToLife;
				(pxArc^) << m_iNumRepeats;
				(pxArc^) << m_iMSBetween;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="MPNG";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,3);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_vPos;
		(pxArc^) << m_sOwner;
		(pxArc^) << m_bUsePos;
		m_xObjFinder.DoKArc(pxArc^);
		(pxArc^) << m_sColorType;
		(pxArc^) << m_bExtended;
		(pxArc^) << m_bAdd;
		(pxArc^) << m_sID;
		(pxArc^) << m_iTimeToLife;
		(pxArc^) << m_iNumRepeats;
		(pxArc^) << m_iMSBetween;
		pxN^.Close();
	endproc;
	
endclass;
	
//----------------------------------------------------------
// Action:	Set Population Limit
//----------------------------------------------------------
class CActionPopulationLimit inherit CTrigger.IAction
	
	var int m_iPlayer;
	var int m_iLimit;
	
	///constructor
	export constructor()
	endconstructor;
	
	///constructor
	export constructor(ref CAttribs p_rxAttr)
		m_iLimit = p_rxAttr.GetValueInt("limit");
		m_iPlayer = p_rxAttr.GetValueInt("player_id");
	endconstructor;
	
	///destructor
	export destructor()
	enddestructor;
	
	///onpush
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		var ^CLevel pxLevel = CSrvWrap.GetCurLevel();
		if(pxLevel!=null)then
			var ^CLevelInfoHost pxLI = ^(pxLevel^.GetLevelInfo());
			var ^CPropDB pxDB = ^(pxLI^.GetGenericData());
			var ^CPropDB.CNode pxNode =
			pxDB^.FindNode("PlayerSettings/Player_"+m_iPlayer.ToString()+"/Restrictions/Chars/Population", true);
			if(pxNode!=null)then pxNode^.SetValue("Max", m_iLimit); endif;
		endif;
		CSrvWrap.GetGame().SendLevelInfoUpdate();
		//CAiInterface.SetPyramidPopLimit(m_iPlayer, m_iLimit);
		//L KLog.LogSpam("CyGi", "PlayerSettings/Player_"+m_iPlayer.ToString()+"/Restrictions/Chars/Population Limit is="+m_iLimit.ToString());
		return true;
	endproc;
	
	///load
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="POPL")then
			if(p_pxNode^.GetVersion()==1)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_iLimit;
			endif;
			if(p_pxNode^.GetVersion()==2)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_iLimit;
				(pxArc^) << m_iPlayer;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	///save
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="POPL";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,2);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_iLimit;
		(pxArc^) << m_iPlayer;
		pxN^.Close();
	endproc;
	
endclass;
	
//----------------------------------------------------------
// Action:	Block/Unblock Slots
//----------------------------------------------------------
class CActionBlockSlots inherit CTrigger.IAction
	
	var int m_iPlayer;
	var array int m_aiOpen;
	
	///constructor
	export constructor()
	endconstructor;
	
	///constructor
	export constructor(ref CAttribs p_rxAttr)
		m_iPlayer = p_rxAttr.GetValueInt("player_id");
		var int i, iC = 5;
		m_aiOpen = iC;
		for(i=0)cond(i<iC) iter(++i)do
			m_aiOpen[i] = p_rxAttr.GetValueInt("open_" + (i+1).ToString());
		endfor;
	endconstructor;
	
	///destructor
	export destructor()
	enddestructor;
	
	///onpush
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		var ^CLevel pxLevel = CSrvWrap.GetCurLevel();
		var string sLimit;
		if(pxLevel!=null)then
			var ^CLevelInfoHost pxLI = ^(pxLevel^.GetLevelInfo());
			var ^CPropDB pxDB = ^(pxLI^.GetGenericData());
			var int i,iC=5;
			for(i=0)cond(i<iC) iter(++i)do
				var ^CPropDB.CNode pxNode =
					pxDB^.FindNode("PlayerSettings/Player_"+m_iPlayer.ToString()+"/Restrictions/Chars/Level"+(i+1).ToString(), true);
				if(pxNode!=null)then
					pxNode^.SetValue("Max", m_aiOpen[i]);
					sLimit+="/"+m_aiOpen[i].ToString();
					//L KLog.LogSpam("CyGi","PlayerSettings/Player_"+m_iPlayer.ToString()+"/Restrictions/Chars/Level "+(i+1).ToString()+"Restriction is= "+sLimit);
				endif;
			endfor;
		endif;
		CSrvWrap.GetGame().SendLevelInfoUpdate();
		//CAiInterface.BlockPyramidSlots(m_iPlayer, sLimit);
		return true;
	endproc;
	
	///load
	proc void Load(^CUOFReaderNode p_pxNode)
		var int iTmp;
		if(p_pxNode^.GetType()=="BLSL")then
			if(p_pxNode^.GetVersion()==1)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << iTmp;
				(pxArc^) << iTmp;
			elseif(p_pxNode^.GetVersion()==2)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_iPlayer;
				(pxArc^) << iTmp;
				(pxArc^) << iTmp;
			elseif(p_pxNode^.GetVersion()==3)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_iPlayer;
				var int i, iC;
				(pxArc^) << iC;
				m_aiOpen=iC;
				for(i=0)cond(i<iC) iter(++i)do
					(pxArc^) << m_aiOpen[i];
				endfor;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	///save
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="BLSL";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,3);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_iPlayer;
		var int i, iC = m_aiOpen.NumEntries();
		(pxArc^) << iC;
		for(i=0)cond(i<iC) iter(++i)do
			(pxArc^) << m_aiOpen[i];
		endfor;
		pxN^.Close();
	endproc;
	
endclass;
	
//----------------------------------------------------------
// Action:	Diplomacy
//----------------------------------------------------------
class CActionDiplomacy inherit CTrigger.IAction
	
	const int RELATION_FRIEND		= 0;
	const int RELATION_NEUTRAL	= 1;
	const int RELATION_ENEMY		= 2;
	
	class CDiplomacyChange
	
		export var int m_iPlyr1, m_iPlyr2, m_iRelation;
	
		export proc void DoKArc(^CArc p_pxArc)
			(p_pxArc^) << m_iPlyr1;
			(p_pxArc^) << m_iPlyr2;
			(p_pxArc^) << m_iRelation;
		endproc;
	
	endclass;
	
	var array CDiplomacyChange m_axDipls;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxAttr)
		var string sChanges = p_rxAttr.GetValue("changes");
		var array string asChanges;
		sChanges.Split(asChanges, "\n", true);
		var int i, iC = asChanges.NumEntries();
		for(i=0)cond(i<iC) iter(++i)do
			var array string asToks;
			asChanges[i].Split(asToks,"|",true);
			var CDiplomacyChange xDC;
			xDC.m_iPlyr1 = asToks[0].ToInt();
			xDC.m_iRelation = asToks[1].ToInt();
			xDC.m_iPlyr2 = asToks[2].ToInt();
			m_axDipls.AddEntry(xDC);
		endfor;
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		var ^CDiplomacySrvMgr pxDiplMgr = ^(CSrvWrap.GetDiplomacyMgr());
		var ^CBasePlayer pxBase;
		var int i, iC = m_axDipls.NumEntries();
		for(i=0)cond(i<iC) iter(++i)do
			pxDiplMgr^.SetRelation(m_axDipls[i].m_iPlyr1, m_axDipls[i].m_iPlyr2, m_axDipls[i].m_iRelation);
			pxBase=CBasePlayer.GetPlayer(m_axDipls[i].m_iPlyr1);
			if(pxBase!=null)then
				pxBase^.SetDiplomacy(m_axDipls[i].m_iPlyr2, m_axDipls[i].m_iRelation);
			endif;
		endfor;
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		var int iTmp;
		if(p_pxNode^.GetType()=="DIPL")then
			if(p_pxNode^.GetVersion()==1)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				var int i, iC=0;
				(pxArc^) << iC;
				m_axDipls = iC;
				for(i=0)cond(i<iC) iter(++i)do
					m_axDipls[i].DoKArc(pxArc);
				endfor;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="DIPL";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,1);
		var ^CArc pxArc=^(pxN^.GetArc());
		var int i, iC = m_axDipls.NumEntries();
		(pxArc^) << iC;
		for(i=0)cond(i<iC) iter(++i)do
			m_axDipls[i].DoKArc(pxArc);
		endfor;
		pxN^.Close();
	endproc;
	
endclass;
	
//----------------------------------------------------------
// Action:	AiRegion
//----------------------------------------------------------
class CActionAiRegion inherit CTrigger.IAction
	
	var int				m_iPlayerID;
	var bool			m_bAllPlayers;
	var string		m_sMapName;
	var string		m_sBehaviorName;
	var bool			m_bAddEdit;
	var string		m_sRegionName;
	var real			m_fValue;
	
	///export constructor
	export constructor()
	endconstructor;
	
	/// export constructor
	export constructor(ref CAttribs p_rxArgs)
		m_iPlayerID = p_rxArgs.GetValueInt("player_id");
		m_bAllPlayers = p_rxArgs.GetValueBool("all_players");
		m_sMapName = p_rxArgs.GetValue("map_name");
		m_sBehaviorName = p_rxArgs.GetValue("behavior_name");
		m_bAddEdit = p_rxArgs.GetValueBool("add_edit");
		m_sRegionName = p_rxArgs.GetValue("region_name");
		m_fValue = p_rxArgs.GetValueFloat("value");
		//L KLog.LogSpam("CyGi","Attribs: PlayerID="+m_iPlayerID.ToString()+"  AllPlayers bool="+m_bAllPlayers.ToString()+"  MapName="+m_sMapName+"  AddEdit="+m_bAddEdit.ToString()+"  RegionName"+m_sRegionName+"  MultiplicationValue="+m_fValue.ToString());
	endconstructor;
	
	///export constructor
	export constructor(int p_iPlayer, bool p_bAllPlayers, string p_sMapName, string p_sBehaviorName, bool p_bAddEdit, string p_sRegionName, real p_fValue)
		m_iPlayerID = p_iPlayer;
		m_bAllPlayers = p_bAllPlayers;
		m_sMapName = p_sMapName;
		m_bAddEdit = p_bAddEdit;
		m_sRegionName = p_sRegionName;
		m_fValue = p_fValue;
		m_sBehaviorName=p_sBehaviorName;
	endconstructor;
	
	///export destructor
	export destructor()
	enddestructor;
	
	///on push
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		//L KLog.LogSpam("CyGi","OnPush AIRG (AddEdit="+m_bAddEdit.ToString()+",  PlayerID="+m_iPlayerID.ToString()+",  AllPlayers="+m_bAllPlayers.ToString()+",  MapName="+m_sMapName+",  RegionName="+m_sRegionName+",  Value="+m_fValue.ToString()+")");
		var bool bSuccess=false;
		//ressources
		if(m_sMapName=="ALLFOOD"||m_sMapName=="FOOD"||m_sMapName=="WOOD"||m_sMapName=="STON"||m_sMapName=="FRUI"||m_sMapName=="Fish"||m_sMapName=="Enemy"||m_sMapName=="Land"||
			m_sMapName=="Forest"||m_sMapName=="CoastModifier"||m_sMapName=="HostileAnimalModifier"||m_sMapName=="NeutralAnimalModifier"||m_sMapName=="FriendlyAnimalModifier"||
			m_sMapName=="DefensiveCoverage"||m_sMapName=="BuildModifier")then
			if(m_bAddEdit==true)then
				if(m_bAllPlayers==true)then
					var int i=0;
					bSuccess=true;
					for(i=0)cond(i<8)iter(i++)do
						if(CAiInterface.AddEditRegionRessources(i, m_sMapName, m_sRegionName, m_fValue)==false)then
							bSuccess=false;
						endif;
					endfor;
				else
					bSuccess=CAiInterface.AddEditRegionRessources(m_iPlayerID, m_sMapName, m_sRegionName, m_fValue);
				endif;
			else
				if(m_bAllPlayers==true)then
					var int i=0;
					bSuccess=true;
					for(i=0)cond(i<8)iter(i++)do
						if(CAiInterface.RemRegionRessources(i, m_sMapName, m_sRegionName)==false)then
							bSuccess=false;
						endif;
					endfor;
				else
					bSuccess=CAiInterface.RemRegionRessources(m_iPlayerID, m_sMapName, m_sRegionName);
				endif;
			endif;
		//economy
		elseif(m_sMapName=="village_level X1"||m_sMapName=="village_level X2"||m_sMapName=="village_level X3")then
			if(m_bAddEdit==true)then
				if(m_bAllPlayers==true)then
					var int i=0;
					bSuccess=true;
					for(i=0)cond(i<8)iter(i++)do
						if(CAiInterface.AddEditRegionEconomy(i, m_sMapName, m_sRegionName, m_fValue)==false)then
							bSuccess=false;
						endif;
					endfor;
				else
					bSuccess=CAiInterface.AddEditRegionEconomy(m_iPlayerID, m_sMapName, m_sRegionName, m_fValue);
				endif;
			else
				if(m_bAllPlayers==true)then
					var int i=0;
					bSuccess=true;
					for(i=0)cond(i<8)iter(i++)do
						if(CAiInterface.RemRegionEconomy(i, m_sMapName, m_sRegionName)==false)then
							bSuccess=false;
						endif;
					endfor;
				else
					bSuccess=CAiInterface.RemRegionEconomy(m_iPlayerID, m_sMapName, m_sRegionName);
				endif;
			endif;
		elseif(m_sMapName=="WOOD/STON/ALLFOOD")then
			var int i, iC=2;
			for(i=0)cond(i<iC)iter(i++)do
				if(i==0)then m_sMapName="WOOD";
				elseif(i==1)then m_sMapName="STON";
				else m_sMapName="ALLFOOD";
				endif;
				if(m_bAddEdit==true)then
					if(m_bAllPlayers==true)then
						var int i=0;
						bSuccess=true;
						for(i=0)cond(i<8)iter(i++)do
							if(CAiInterface.AddEditRegionRessources(i, m_sMapName, m_sRegionName, m_fValue)==false)then
								bSuccess=false;
							endif;
						endfor;
					else
						bSuccess=CAiInterface.AddEditRegionRessources(m_iPlayerID, m_sMapName, m_sRegionName, m_fValue);
					endif;
				else
					if(m_bAllPlayers==true)then
						var int i=0;
						bSuccess=true;
						for(i=0)cond(i<8)iter(i++)do
							if(CAiInterface.RemRegionRessources(i, m_sMapName, m_sRegionName)==false)then
								bSuccess=false;
							endif;
						endfor;
					else
						bSuccess=CAiInterface.RemRegionRessources(m_iPlayerID, m_sMapName, m_sRegionName);
					endif;
				endif;
			endfor;
		endif;
		//only for debugging. can be removed.
		if(bSuccess==true)then 
			//L KLog.LogSpam("CyGi","AIRG: Execution was successful");
		else 
			//L KLog.LogSpam("CyGi","AIRG: Execution was a failure");
		endif;
		return true;
	endproc;
	
	///on load
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="AIRG")then
			if(p_pxNode^.GetVersion()>=1)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_iPlayerID;
				if(p_pxNode^.GetVersion()>=2)then
					(pxArc^) << m_bAllPlayers;
				endif;
				(pxArc^) << m_sBehaviorName;
				(pxArc^) << m_sMapName;
				(pxArc^) << m_bAddEdit;
				(pxArc^) << m_sRegionName;
				(pxArc^) << m_fValue;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	///on save
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="AIRG";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,2);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_iPlayerID;
		(pxArc^) << m_bAllPlayers;
		(pxArc^) << m_sBehaviorName;
		(pxArc^) << m_sMapName;
		(pxArc^) << m_bAddEdit;
		(pxArc^) << m_sRegionName;
		(pxArc^) << m_fValue;
		pxN^.Close();
	endproc;
	
endclass;
	
//----------------------------------------------------------
// Action:	AiBehavior
//----------------------------------------------------------
class CActionAiBehavior inherit CTrigger.IAction
	
	var int			m_iPlayerID;
	var string		m_sModule;
	var string		m_sBehavior;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxArgs)
		m_iPlayerID = p_rxArgs.GetValueInt("player_id");
		m_sModule = p_rxArgs.GetValue("module");
		m_sBehavior = p_rxArgs.GetValue("behavior");
	endconstructor;
	
	export constructor(int p_iPlayer, string p_sModule, string p_sBehavior)
		m_iPlayerID = p_iPlayer;
		m_sModule = p_sModule;
		m_sBehavior = p_sBehavior;
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		KLog.LogSpam("CyGi","Executing Trigger Action AIBV (PlayerID="+m_iPlayerID.ToString()+", Module="+m_sModule+", Behavior="+m_sBehavior+")");
		
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel==null)then
			KLog.LogError("CActionAiBehavior","pxLevel is null");
			return false;
		endif;
		
		var ^CPlayer pxPlayer = pxLevel^.GetPlayer(m_iPlayerID);
		if(pxPlayer==null)then
			KLog.LogError("CActionAiBehavior","Player_" + m_iPlayerID.ToString() + " is null");
			return false;
		endif;
		
		var ^CLevelInfo.CPlayerSlot pxSlot=pxPlayer^.GetPlayerSlot();
		if(pxSlot==null)then
			KLog.LogError("CActionAiBehavior","pxSlot is null");
			return false;
		endif;
		
		if(!pxSlot^.IsAIPlayer())then return false; endif;
		
		var bool bSuccess=false;
		var bitset dwModId;
		if(m_sModule=="CTRL")then
			dwModId=CAiInterface.AiModule_Control;
			KLog.LogSpam("CyGi","AiModule_Control");
		elseif(m_sModule=="ECON")then
			dwModId=CAiInterface.AiModule_Economy;
			KLog.LogSpam("CyGi","AiModule_Economy");
		elseif(m_sModule=="DFNS")then
			dwModId=CAiInterface.AiModule_Defense;
			KLog.LogSpam("CyGi","AiModule_Defense");
		elseif(m_sModule=="FGHT")then
			dwModId=CAiInterface.AiModule_Fight;
			KLog.LogSpam("CyGi","AiModule_Fight");
		elseif(m_sModule=="AREA")then
			dwModId=CAiInterface.AiModule_Area;
			KLog.LogSpam("CyGi","AiModule_Area");
		else
			dwModId=CAiInterface.AiModule_Unknown;
			KLog.LogSpam("CyGi","AiModule_Unknown");
		endif;
		bSuccess = CAiInterface.SetModuleBehavior(m_iPlayerID,dwModId,m_sBehavior);
		
		if(bSuccess==true)then
			KLog.LogSpam("CyGi","AIBV: Execution was successful");
		else
			KLog.LogSpam("CyGi","AIBV: Execution was a failure");
		endif;
		
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if((p_pxNode^.GetType()=="AIST")||(p_pxNode^.GetType()=="AIBV"))then
			if(p_pxNode^.GetVersion()>=1)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_iPlayerID;
				(pxArc^) << m_sModule;
				(pxArc^) << m_sBehavior;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="AIBV";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,1);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_iPlayerID;
		(pxArc^) << m_sModule;
		(pxArc^) << m_sBehavior;
		pxN^.Close();
	endproc;
	
endclass;
	
//----------------------------------------------------------
// Action:	AiCallModule
//----------------------------------------------------------
class CActionAiCallModule inherit CTrigger.IAction
	
	var int				m_iPlayerID;
	var string		m_sModule;
	var string		m_sCommand;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxArgs)
		m_iPlayerID = p_rxArgs.GetValueInt("player_id");
		m_sModule = p_rxArgs.GetValue("module");
		m_sCommand = p_rxArgs.GetValue("command");
	endconstructor;
	
	export constructor(int p_iPlayer, string p_sModule, string p_sCommand)
		m_iPlayerID = p_iPlayer;
		m_sModule = p_sModule;
		m_sCommand = p_sCommand;
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		//L KLog.LogSpam("PaHa","Executing Trigger Action AICM (PlayerID="+m_iPlayerID.ToString()+", Module="+m_sModule+", Command="+m_sCommand+")");
		var bool bSuccess=false;
		var bitset dwModId;
		if(m_sModule=="CTRL")then
			dwModId=CAiInterface.AiModule_Control;
		elseif(m_sModule=="ECON")then
			dwModId=CAiInterface.AiModule_Economy;
		elseif(m_sModule=="FGHT")then
			dwModId=CAiInterface.AiModule_Fight;
		elseif(m_sModule=="DFNS")then
			dwModId=CAiInterface.AiModule_Defense;
		elseif(m_sModule=="AREA")then
			dwModId=CAiInterface.AiModule_Area;
		else
			dwModId=CAiInterface.AiModule_Unknown;
		endif;
		bSuccess = CAiInterface.CallModule(m_iPlayerID,dwModId,m_sCommand);
		if(bSuccess==true)then
			//L KLog.LogSpam("PaHa","Execution was successful");
		else
			//L KLog.LogSpam("PaHa","Execution was a failure");
		endif;
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="AICM")then
			if(p_pxNode^.GetVersion()>=1)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_iPlayerID;
				(pxArc^) << m_sModule;
				(pxArc^) << m_sCommand;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="AICM";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,1);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_iPlayerID;
		(pxArc^) << m_sModule;
		(pxArc^) << m_sCommand;
		pxN^.Close();
	endproc;
	
endclass;
	
//----------------------------------------------------------
// Action:	AiDefendArea
//----------------------------------------------------------
class CActionAiDefendArea inherit CTrigger.IAction
	
	var int				m_iPlayerID;
	var string		m_sID;
	var string		m_sPosition;
	var real			m_fRadius;
	var int				m_iMaxUnits;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxArgs)
		m_iPlayerID = p_rxArgs.GetValueInt("player_id");
		m_sID = p_rxArgs.GetValue("id");
		m_sPosition = p_rxArgs.GetValue("position");
		m_fRadius = p_rxArgs.GetValueFloat("radius");
		m_iMaxUnits = p_rxArgs.GetValueInt("max_units");
	endconstructor;
	
	export constructor(int p_iPlayer, string p_sID, string p_sPosition, real p_fRadius, int p_iMaxUnits)
		m_iPlayerID = p_iPlayer;
		m_sID = p_sID;
		m_sPosition = p_sPosition;
		m_fRadius = p_fRadius;
		m_iMaxUnits = p_iMaxUnits;
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		//L KLog.LogSpam("RoStTmp","Executing Trigger Action AIDA (PlayerID="+m_iPlayerID.ToString()+", ID="+m_sID+", position="+m_sPosition+", radius="+m_fRadius.ToString()+", max_units="+m_iMaxUnits.ToString()+")");
		var bool bSuccess = false;
		var bitset dwModId = CAiInterface.AiModule_Defense;
		var string sCommand = "AddDefenseArea "+m_sID+" "+m_sPosition+" "+m_fRadius.ToString()+" "+m_iMaxUnits.ToString();
		bSuccess = CAiInterface.SetModuleBehavior(m_iPlayerID,dwModId,sCommand);
		if(bSuccess==true)then
			//L KLog.LogSpam("RoStTmp","Execution was successful");
		else
			//L KLog.LogSpam("RoStTmp","Execution was a failure");
		endif;
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="AIDA")then
			if(p_pxNode^.GetVersion()>=1)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_iPlayerID;
				(pxArc^) << m_sID;
				(pxArc^) << m_sPosition;
				(pxArc^) << m_fRadius;
				(pxArc^) << m_iMaxUnits;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="AIDA";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,1);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_iPlayerID;
		(pxArc^) << m_sID;
		(pxArc^) << m_sPosition;
		(pxArc^) << m_fRadius;
		(pxArc^) << m_iMaxUnits;
		pxN^.Close();
	endproc;
	
endclass;
	
//----------------------------------------------------------
// Action:	AiLockUnit
// Code changed: credit to AyCe
//----------------------------------------------------------
class CActionAiLockUnit inherit CTrigger.IAction
	
	var int										m_iPlayerID;
	var bool									m_bLock;
	var bool									m_bEnableObjSel;
	var CGuidList							m_xUnitList;
	var CGuidList							m_xUnitListFull;
	var CActionObjFinder			m_xObjFinder;
	var CGuid									m_xGuid;
	
	//constructor
	export constructor()
	endconstructor;
	
	//constructor
	export constructor(ref CAttribs p_rxArgs)
		m_xObjFinder.Init(p_rxArgs);
		m_iPlayerID = p_rxArgs.GetValueInt("player_id");
		m_bLock = p_rxArgs.GetValueBool("lock");
		m_xUnitList.Clear();
		m_xUnitListFull.Clear();
		m_bEnableObjSel = p_rxArgs.GetValueBool("enable_objsel");
		var array string asGUIDs;
		p_rxArgs.GetValue("units").Split(asGUIDs,"\n",true);
		var int i, iC=asGUIDs.NumEntries();
		var CGuid xUnit;
		for(i=0)cond(i<iC)iter(i++)do
			xUnit.FromString(asGUIDs[i]);
			m_xUnitList.AddEntry(xUnit);
		endfor;
	endconstructor;
	
	//destructor
	export destructor()
	enddestructor;
	
	//onpush
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		// Fixed by AyCe Scripting Inc.
		m_xUnitListFull.Clear();
		var int i, iC = m_xUnitList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			m_xUnitListFull.AddEntry(m_xUnitList[i]);
		endfor;
		if(m_bEnableObjSel == true)then //evaluate units from objsel only, if its enabled
			var CObjList xObjs;
			m_xObjFinder.InitTrigger(GetAttachedTrigger());
			m_xObjFinder.MakeQuery(xObjs);
			if(xObjs.NumEntries() > 0)then
				var int i, iC=xObjs.NumEntries();
				for(i=0)cond(i<iC)iter(i++)do
					m_xGuid=xObjs[i].GetObj()^.GetGuid();
					m_xUnitListFull.AddEntry(m_xGuid);
				endfor;
			endif;
		endif;
		KLog.LogSpam("CyGi","Executing Trigger Action AILU (PlayerID="+m_iPlayerID.ToString()+", m_xUnitList.NumEntries="+m_xUnitList.NumEntries().ToString()+")");
		var bool bSuccess = false;
		if(m_bLock==true)then
			bSuccess = CAiInterface.LockUnit(m_iPlayerID,m_xUnitListFull);
		else
			bSuccess = CAiInterface.UnlockUnit(m_iPlayerID,m_xUnitListFull);
		endif;
		if(bSuccess==true)then
			KLog.LogSpam("CyGi","AILU Execution was successful");
		else
			KLog.LogSpam("CyGi","AILU Execution was a failure");
		endif;
		return true;
	endproc;
	
	//load
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="AILU")then
			if(p_pxNode^.GetVersion()>=1)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_iPlayerID;
				(pxArc^) << m_bLock;
				// load unit GUIDs
				m_xUnitList.Clear();
				var int i, iC;
				(pxArc^) << iC;
				KLog.LogSpam("CyGi","AILU Loading "+iC.ToString()+" unit GUIDs");
				for(i=0)cond(i<iC)iter(i++)do
					var CGuid xUnit;
					(pxArc^) << xUnit;
					m_xUnitList.AddEntry(xUnit);
				endfor;
				if(p_pxNode^.GetVersion()>=2)then
					m_xObjFinder.DoKArc(pxArc^);
				endif;
				(pxArc^) << m_bEnableObjSel;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	//save
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="AILU";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,2);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_iPlayerID;
		(pxArc^) << m_bLock;
		// store unit GUIDs
		var int i, iC=m_xUnitList.NumEntries();
		KLog.LogSpam("CyGi","Saving "+iC.ToString()+" unit GUIDs");
		(pxArc^) << iC;
		for(i=0)cond(i<iC)iter(i++)do
			(pxArc^) << m_xUnitList[i];
		endfor;
		m_xObjFinder.DoKArc(pxArc^);
		(pxArc^) << m_bEnableObjSel;
		pxN^.Close();
	endproc;
	
endclass;
	
//----------------------------------------------------------
// Action:	CActionVars
//----------------------------------------------------------
class CActionVars inherit CTrigger.IAction
	
	var bool			m_bLocal;
	var string		m_sVar;
	var string		m_sOp;
	var string		m_sVal;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxArgs)
		m_bLocal = p_rxArgs.GetValueInt("local")==1;
		m_sVar = p_rxArgs.GetValue("varname");
		m_sOp = p_rxArgs.GetValue("operation");
		m_sVal = p_rxArgs.GetValue("value");
	endconstructor;
	
	export destructor()
	enddestructor;
	
	proc string GetValue(string p_sOldVal, string p_sNewVal, string p_sOp, string p_sType)
		if(p_sOp=="set")then
			return p_sNewVal;
		else
			if(p_sType=="int")then
				var int iVal = p_sOldVal.ToInt();
				var int iMod = p_sNewVal.ToInt();
				if(p_sOp=="+")then
					iVal+=iMod;
				elseif(p_sOp=="-")then
					iVal-=iMod;
				elseif(p_sOp=="*")then
					iVal*=iMod;
				elseif(p_sOp=="/")then
					if(iMod==0)then
						KLog.LogError("Action", "CActionVars -> Division durch 0 ... so wird das nix");
						return "";
					endif;
					iVal/=iMod;
				endif;
				return iVal.ToString();
			else
				var real fVal = p_sOldVal.ToReal();
				var real fMod = p_sNewVal.ToReal();
				if(p_sOp=="+")then
					fVal+=fMod;
				elseif(p_sOp=="-")then
					fVal-=fMod;
				elseif(p_sOp=="*")then
					fVal*=fMod;
				elseif(p_sOp=="/")then
					if(fMod==0.0f)then
						KLog.LogError("Action", "CActionVars -> Division durch 0 ... so wird das nix");
						return "";
					endif;
					fVal/=fMod;
				endif;
				return fVal.ToString();
			endif;
		endif;
	endproc;
	
	proc bool PushLocal()
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		var ^CLevelInfo pxLevelInfo=^(pxLevel^.GetLevelInfo());
		var ^CPropDB.CNode pxNode = pxLevelInfo^.GetGenericData().FindNode("Variables", true);
		if(pxNode!=null)then
			var ^CPropDB.CNode pxVar = pxNode^.Get(m_sVar);
			if(pxVar==null)then
				pxVar = ^(pxNode^.AddValue(m_sVar, ""));
				pxVar^.SetValue("type", "int");
				pxVar^.SetValue("value", "0");
			endif;
			if(pxVar!=null)then
				var string sNew = GetValue(pxVar^.GetValueS("value"), m_sVal, m_sOp, pxVar^.GetValueS("type"));
				if(!sNew.IsEmpty())then
					pxVar^.SetValue("value", sNew);
				endif;
			endif;
		endif;
		pxLevelInfo^.NotifyVarsChange();
		return true;
	endproc;
	
	proc bool PushGlobal()
		var string sType;
		var string sDefault;
		var CPropDB xDef;
		if(xDef.Load(CSrvWrap.GetUrsRelPath()+"/Data/Base/Scripts/Server/settings/ProfileVariables.txt"))then
			var ^CPropDB.CNode pxVar = xDef.GetRoot().Get(m_sVar);
			if(pxVar==null)then
				//L KLog.LogSpam("MaZi", "Unknown global Variable '"+m_sVar+"'. Global Vars must be defined in /Server/settings/ProfileVariables.txt.");
				return false;
			endif;
			sType = pxVar^.GetValueS("type", "");
			sDefault = pxVar^.GetValueS("default", "");
		endif;
		var ^CUserProfile pxP = CSrvWrap.GetCurUserProfile();
		if(pxP!=null)then
			var ^CPropDB.CNode pxVars = pxP^.GetPropDB().FindNode("Campaign/Variables", true);
			if(pxVars!=null)then
				var string sOldVal = pxVars^.GetValueS(m_sVar, sDefault);
				var string sNew = GetValue(sOldVal, m_sVal, m_sOp, sType);
				if(!sNew.IsEmpty())then
					pxVars^.SetValue(m_sVar, sNew);
					pxP^.NotifyChanges();
					CSrvWrap.UpdatePlayerProfile();
				endif;
			endif;
		endif;
		return true;
	endproc;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		if(m_bLocal)then
			return PushLocal();
		endif;
		return PushGlobal();
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="VARS")then
			var ^CArc pxArc=^(p_pxNode^.GetArc());
			if(p_pxNode^.GetVersion()>=1)then
				(pxArc^) << m_sVar;
				(pxArc^) << m_sOp;
				(pxArc^) << m_sVal;
				m_bLocal = true;
			endif;
			if(p_pxNode^.GetVersion()>=2)then
				(pxArc^) << m_bLocal;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="VARS";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,2);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_sVar;
		(pxArc^) << m_sOp;
		(pxArc^) << m_sVal;
		(pxArc^) << m_bLocal;
		pxN^.Close();
	endproc;
	
endclass;
	
class CActionWeather inherit CTrigger.IAction
	
	var int m_iChgType;
	var string m_sProgName;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxArgs)
		m_iChgType = p_rxArgs.GetValueInt("chgtype");
		m_sProgName = p_rxArgs.GetValue("progpath");
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		var string sSend = "WeatherChg";
		if(m_iChgType==0)then
			sSend+="\t"+m_sProgName;
		endif;
	
		var bitset dwCl = 011111111b;
		CSrvWrap.SendGenericEvtToClients(dwCl, sSend);
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="WTHR")then
			if(p_pxNode^.GetVersion()>=1)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_iChgType;
				(pxArc^) << m_sProgName;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="WTHR";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,1);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_iChgType;
		(pxArc^) << m_sProgName;
		pxN^.Close();
	endproc;
	
endclass;
	
class CActionHelp inherit CTrigger.IAction
	
	var int				m_iOwner;
	var string		m_sSemlUrl;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxArgs)
		m_iOwner = p_rxArgs.GetValueInt("player");
		m_sSemlUrl = p_rxArgs.GetValue("semlurl");
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		if(m_iOwner==-1)then
			var bitset dwCl = 011111111b;
			CSrvWrap.SendGenericEvtToClients(dwCl, "ShowHelpAndNav\t" + m_sSemlUrl);
		else
			CSrvWrap.SendGenericEvtToPlayer(m_iOwner, "ShowHelpAndNav\t" + m_sSemlUrl);
		endif;
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="HELP")then
			if(p_pxNode^.GetVersion()>=1)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_sSemlUrl;
				(pxArc^) << m_iOwner;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="HELP";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,1);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_sSemlUrl;
		(pxArc^) << m_iOwner;
		pxN^.Close();
	endproc;
	
endclass;
	
class CActionSound inherit CTrigger.IAction
	
	var string	m_sSoundName;
	var int			m_iSoundType;
	var int			m_iPlayer;
	var vec3		m_vPos;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxArgs)
		m_sSoundName = p_rxArgs.GetValue("soundname");
		m_iSoundType = p_rxArgs.GetValueInt("soundtype");
		m_iPlayer = p_rxArgs.GetValueInt("player");
		m_vPos.FromString(p_rxArgs.GetValue("position"));
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		if(m_iPlayer==-1)then
			CSoundEvent.PlayAll(m_sSoundName, m_iSoundType, m_vPos);
		else
			CSoundEvent.PlaySingle(m_sSoundName, m_iSoundType, m_vPos, m_iPlayer);
		endif;
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="PSND")then
			if(p_pxNode^.GetVersion()>=1)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_sSoundName;
				(pxArc^) << m_iSoundType;
				(pxArc^) << m_iPlayer;
				(pxArc^) << m_vPos;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="PSND";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,1);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_sSoundName;
		(pxArc^) << m_iSoundType;
		(pxArc^) << m_iPlayer;
		(pxArc^) << m_vPos;
		pxN^.Close();
	endproc;
	
endclass;
	
class CActionDelObj inherit CTrigger.IAction
	
	var CActionObjFinder	m_xObjFinder;
	var int								m_iMaxObjs;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxArgs)
		m_xObjFinder.Init(p_rxArgs);
		m_iMaxObjs=p_rxArgs.GetValueInt("maxobjs");
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		m_xObjFinder.InitTrigger(GetAttachedTrigger());
		var CObjList xObjs;
		m_xObjFinder.MakeQuery(xObjs);
		var int i, iC = xObjs.NumEntries();
		for(i=0)cond(i<iC) iter(++i)do
			if(m_iMaxObjs>=0 && i>=m_iMaxObjs)then
				break;
			endif;
			var ^CGameObj pxO = xObjs[i].GetObj();
			var ^CFightingObj pxF = cast<CFightingObj>(pxO);
			if(pxF!=null)then
				pxF^.SetSkipCorpse(true);
			endif;
			pxO^.Delete();
		endfor;
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="<FourCC>")then
			if(p_pxNode^.GetVersion()>=1)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				m_xObjFinder.DoKArc(pxArc^);
				if(p_pxNode^.GetVersion()>=2)then
					(pxArc^) << m_iMaxObjs;
				endif;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="<FourCC>";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,2);
		var ^CArc pxArc=^(pxN^.GetArc());
		m_xObjFinder.DoKArc(pxArc^);
		(pxArc^) << m_iMaxObjs;
		pxN^.Close();
	endproc;
	
endclass;
	
class CActionReplaceObj inherit CTrigger.IAction
	
	var CActionObjFinder	m_xObjFinder;
	var string						m_sNewObj;
	var int								m_iLevel;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxArgs)
		m_xObjFinder.Init(p_rxArgs);
		m_sNewObj = p_rxArgs.GetValue("new_obj");
		m_iLevel = p_rxArgs.GetValueInt("obj_level");
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		m_xObjFinder.InitTrigger(GetAttachedTrigger());
		var CObjList xObjs;
		m_xObjFinder.MakeQuery(xObjs);
		var int i, iC=xObjs.NumEntries();
		if(iC>=1)then
			var ^CGameObj pxO;
			for(i=0)cond(i<iC)iter(i++)do
				pxO = xObjs[i].GetObj();
				if(pxO!=null)then
					var int iOwner = pxO^.GetOwner();
					var vec3 vPos = pxO^.GetPos();
					var Quat qRot = pxO^.GetRot();
					var ^CFightingObj pxFightingObj = cast<CFightingObj>(pxO);
					if(pxFightingObj!=null)then
						pxFightingObj^.SetSkipCorpse(true);
					endif;
					pxO^.Delete();
					pxO = CSrvWrap.GetObjMgr()^.CreateObj(m_sNewObj, iOwner, vPos);
					if(pxO!=null)then
						pxO^.SetRot(qRot);
//						var ^CFightingObj pxFightingObj = cast<CFightingObj>(pxO);
						pxFightingObj = cast<CFightingObj>(pxO);
						if(pxFightingObj!=null)then
							pxFightingObj^.SetLevelClean(m_iLevel);
							var ^CBuilding pxBuilding = cast<CBuilding>(pxFightingObj);
							if(pxBuilding!=null)then
								pxBuilding^.SetReadyBuildTrigger();
							endif;
						endif;
					endif;
				endif;
			endfor;
		endif;
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="REPL")then
			var ^CArc pxArc=^(p_pxNode^.GetArc());
			if(p_pxNode^.GetVersion()==1)then
				m_xObjFinder.DoKArc(pxArc^);
				(pxArc^) << m_sNewObj;
			elseif(p_pxNode^.GetVersion()==2)then
				m_xObjFinder.DoKArc(pxArc^);
				(pxArc^) << m_sNewObj;
				pxArc^ << m_iLevel;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="REPL";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,2);
		var ^CArc pxArc=^(pxN^.GetArc());
		m_xObjFinder.DoKArc(pxArc^);
		(pxArc^) << m_sNewObj;
		pxArc^<<m_iLevel;
		pxN^.Close();
	endproc;
	
endclass;
	
class CActionVirtTime inherit CTrigger.IAction
	
	var real m_fVirtTime;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxArgs)
		var string sTime = p_rxArgs.GetValue("time");
		var array string asToks;
		sTime.Split(asToks, ":", true);
		var real fH=12.0f;
		var real fM=0.0f;
		if(asToks.NumEntries() >= 1)then fH = asToks[0].ToReal(); endif;
		if(asToks.NumEntries() >= 2)then fM = asToks[1].ToReal(); endif;
		m_fVirtTime = fH*60.0f*60.0f + fM*60.0;
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		CTimeMgr.Get().SetVirtualTime(m_fVirtTime);
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="VTME")then
			if(p_pxNode^.GetVersion()>=1)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				(pxArc^) << m_fVirtTime;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="VTME";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,1);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_fVirtTime;
		pxN^.Close();
	endproc;
endclass;
	
/**
	class CActionAiFight
**/
class CActionAiFight inherit CTrigger.IAction
	
	var int									m_iPlayerID;
	var CActionObjFinder		m_xObjFinder;
	var string							m_sTargetObj;
	var string							m_sUnitType, m_sAttackType, m_sPosition, m_sAnimal, m_sFriendly, m_sNeutral, m_sAggressive, m_sSpawnPosition;
	var int									m_iAttackOnTheWay, m_iAttackWithAll, m_iIgnoreLocation, m_iCustomAttack, m_iUnitAmount, m_iAttackObjOnly, m_iShip, m_iShipLand;
	
	///constructor
	export constructor()
	endconstructor;
	
	///constructor with Attribs params
	export constructor(ref CAttribs p_rxArgs)
		//L KLog.LogSpam("CyGi","AIFT ActionFactory constructor()");
		m_xObjFinder.Init(p_rxArgs);
		m_sTargetObj = p_rxArgs.GetValue("obj");
		m_iPlayerID = p_rxArgs.GetValueInt("player_id");
		m_sAnimal=p_rxArgs.GetValue("animal");
		m_sFriendly=p_rxArgs.GetValue("friendly");
		m_sNeutral=p_rxArgs.GetValue("neutral");
		m_sAggressive=p_rxArgs.GetValue("aggressive");
		m_sUnitType=p_rxArgs.GetValue("unit_type");
		m_sAttackType=p_rxArgs.GetValue("attack_type");
		m_sPosition=p_rxArgs.GetValue("position_edit");
		m_sSpawnPosition=p_rxArgs.GetValue("spawn_position");
		m_iAttackWithAll=p_rxArgs.GetValueInt("attack_with_all");
		m_iIgnoreLocation=p_rxArgs.GetValueInt("ignore_locations");
		m_iAttackOnTheWay=p_rxArgs.GetValueInt("all_the_way");
		m_iCustomAttack=p_rxArgs.GetValueInt("custom_attack");
		m_iUnitAmount=p_rxArgs.GetValueInt("unit_amount");
		m_iAttackObjOnly=p_rxArgs.GetValueInt("target_obj");
		m_iShip=p_rxArgs.GetValueInt("ship");
		m_iShipLand=p_rxArgs.GetValueInt("ship_land");
		//L KLog.LogSpam("CyGi","AIFT ActionFactory constructor() 1 CustomAttack: "+ m_iCustomAttack.ToString());
	endconstructor;
	
	///constructor with int params
	export constructor(int p_iPlayerId, string p_sAnimal, string p_sFriendly, string p_sNeutral, string p_sAggressive, 
						string p_sUnitType, string p_sAttackType, string p_sPosition, int p_iAttackOnTheWay, int p_iAttackWithAll, int p_iIgnoreLocation, 
						int p_iCustomAttack, int p_iUnitAmount, int p_iTargetAttackObj, int p_iShip, int p_iShipLand, string p_sSpawnPosition)
		//L KLog.LogSpam("CyGi","AIFT ActionFactory constructor() 2 CustomAttack: "+ p_iCustomAttack.ToString());
		m_iPlayerID=p_iPlayerId;
		m_sAnimal=p_sAnimal;
		m_sFriendly=p_sFriendly;
		m_sNeutral=p_sNeutral;
		m_sAggressive=p_sAggressive;
		m_sUnitType=p_sUnitType;
		m_sAttackType=p_sAttackType;
		m_sPosition=p_sPosition;
		m_sSpawnPosition=p_sSpawnPosition;
		m_iAttackOnTheWay=p_iAttackOnTheWay;
		m_iAttackWithAll=p_iAttackWithAll;
		m_iIgnoreLocation=p_iIgnoreLocation;
		m_iCustomAttack=p_iCustomAttack;
		m_iUnitAmount=p_iUnitAmount;
		m_iAttackObjOnly=p_iTargetAttackObj;
		m_iShip=p_iShip;
		m_iShipLand=p_iShipLand;
	endconstructor;
	
	///destructor
	export destructor()
		//L KLog.LogSpam("CyGi","AIFT ActionFactory destructor()");
	enddestructor;
	
	//OnPush
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		//L KLog.LogSpam("CyGi", " AIFT OnPush()");
		var bitset dwModId=CAiInterface.AiModule_Fight;
		var string sAnimal, sFriendly, sNeutral, sAggressive, sHndls, sAttackType, sAttackOnTheWay, sAttackWithAll, sIgnoreLocation;
		var string sShip, sShipLand, sAttackObj;
		var int i;
		m_xObjFinder.InitTrigger(GetAttachedTrigger());
		var CObjList xObjs;
		m_xObjFinder.MakeQuery(xObjs);
		if(xObjs.NumEntries()<1)then
			//L KLog.LogWarn("CyGi", "Bäh! No Objects!");
			return false;
		endif;
		if(m_iCustomAttack==0)then
			if(m_sFriendly!="")then sFriendly="Friendly"; endif;
			if(m_sNeutral!="")then sNeutral="Neutral"; endif;
			if(m_sAggressive!="")then sAggressive="Aggressive"; endif;
			if(m_sAnimal!="")then sAnimal="Animal"; endif;
			for(i=0)cond(i<xObjs.NumEntries())iter(i++)do sHndls+= ":"+xObjs[i].AsInt().ToString(); endfor;
			var string sOut = sAnimal+"/"+sFriendly+"/"+sNeutral+"/"+sAggressive+"/"+sHndls;
			CAiInterface.SetFightModuleAttack(m_iPlayerID,dwModId, sOut);
		else
			if(m_iAttackOnTheWay==1)then sAttackOnTheWay="true"; else sAttackOnTheWay="false"; endif;
			if(m_iAttackWithAll==1)then sAttackWithAll="true"; else sAttackWithAll="false"; endif;
			if(m_iIgnoreLocation==1)then sIgnoreLocation="true"; else sIgnoreLocation="false"; endif;
			if(m_iAttackObjOnly==1)then sAttackObj="true"; else sAttackObj="false"; endif;
			if(m_iShip==1)then sShip="true"; else sShip="false"; endif;
			if(m_iShipLand==1)then sShipLand="true"; else sShipLand="false"; endif;
			for(i=0)cond(i<xObjs.NumEntries())iter(i++)do sHndls+= ":"+xObjs[i].AsInt().ToString(); endfor;
			var string sOut = m_sAttackType+"/"+sAttackOnTheWay+"/"+sAttackWithAll+"/"+sIgnoreLocation+"/"+m_sPosition+"/"+sAttackObj+"/"+sShip+"/"+sShipLand+"/"+m_sSpawnPosition+"/"+sHndls;
			var bool bSuccess = false;
			bSuccess = CAiInterface.SetCustomAttack(m_iPlayerID,dwModId, sOut);
//			KLog.LogSpam("CyGi","AIFT: m_iPlayerId="+m_iPlayerID.ToString());
//			KLog.LogSpam("CyGi", "AIFT: AttackTypeout: " + sOut);
//
//			if(bSuccess==true)then
//				KLog.LogSpam("CyGi","AIFT: Execution was successful");
//			else
//				KLog.LogSpam("CyGi","AIFT: Execution was a failure");
//			endif;
		endif;
		return true;
	endproc;
	
	///Load
	proc void Load(^CUOFReaderNode p_pxNode)
		//L KLog.LogSpam("CyGi","AIFT ActionFactory Load()");
		if(p_pxNode^.GetType()=="AIFT")then
			var ^CArc pxArc=^(p_pxNode^.GetArc());
			if(p_pxNode^.GetVersion()>=1)then
				m_xObjFinder.DoKArc(pxArc^);
				(pxArc^)<<m_iPlayerID;
				(pxArc^)<<m_sAnimal;
				(pxArc^)<<m_sFriendly;
				(pxArc^)<<m_sNeutral;
				(pxArc^)<<m_sAggressive;
				(pxArc^)<<m_sAttackType;
				(pxArc^)<<m_sPosition;
				(pxArc^)<<m_iAttackOnTheWay;
				(pxArc^)<<m_iAttackWithAll;
				(pxArc^)<<m_iCustomAttack;
				(pxArc^)<<m_iAttackObjOnly;
				(pxArc^)<<m_iShip;
				(pxArc^)<<m_iShipLand;
				(pxArc^)<<m_sSpawnPosition;
			endif;
			if(p_pxNode^.GetVersion()>=2)then
				(pxArc^)<<m_iIgnoreLocation;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	///Save
	proc void Save(^CUOFWriterNode p_pxNode)
		//L KLog.LogSpam("CyGi","AIFT ActionFactory Save()");
		super.Save(p_pxNode);
		var CFourCC xF="AIFT";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,2);
		var ^CArc pxArc=^(pxN^.GetArc());
		m_xObjFinder.DoKArc(pxArc^);
		(pxArc^)<<m_iPlayerID;
		(pxArc^)<<m_sAnimal;
		(pxArc^)<<m_sFriendly;
		(pxArc^)<<m_sNeutral;
		(pxArc^)<<m_sAggressive;
		(pxArc^)<<m_sAttackType;
		(pxArc^)<<m_sPosition;
		(pxArc^)<<m_iAttackOnTheWay;
		(pxArc^)<<m_iAttackWithAll;
		(pxArc^)<<m_iCustomAttack;
		(pxArc^)<<m_iAttackObjOnly;
		(pxArc^)<<m_iShip;
		(pxArc^)<<m_iShipLand;
		(pxArc^)<<m_sSpawnPosition;
		(pxArc^)<<m_iIgnoreLocation;
		pxN^.Close();
	endproc;
	
endclass;
	
/**
	class CActionAiAggressionMode
**/
class CActionAiAggressionMode inherit CTrigger.IAction
	
	var int								m_iAggroState;
	var CActionObjFinder	m_xObjFinder;
	var bool							m_bSelectorEnabled;
	var CObjList					m_xObjList;
	
	///constructor
	export constructor()
	endconstructor;
	
	///constructor with Attribs params
	export constructor(ref CAttribs p_rxArgs)
		m_xObjFinder.Init(p_rxArgs);
		m_bSelectorEnabled = p_rxArgs.GetValueInt("selector_enabled") == 1;
		m_iAggroState = p_rxArgs.GetValueInt("aggro_state");
		var ^CObjMgrHost pxObjMgr = CSrvWrap.GetObjMgr();
		var array string asGUIDs;
		p_rxArgs.GetValue("aggro_state_units").Split(asGUIDs,"\n",true);
		var int i, iC=asGUIDs.NumEntries();
		var CGuid xUnit;
		for(i=0)cond(i<iC)iter(i++)do
			xUnit.FromString(asGUIDs[i]);
			var ^CGameObj pxObj = pxObjMgr^.GetObjByGuid(xUnit);
			if(pxObj==null)then continue; endif;
			m_xObjList.AddEntry(pxObj^.GetHandle());
		endfor;
	endconstructor;
	
	///constructor with int params
	export constructor(int p_iAggroState)
		m_iAggroState	= p_iAggroState;
	endconstructor;
	
	///destructor
	export destructor()
	enddestructor;
	
	//OnPush
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		var CObjList xObjs;
		m_xObjFinder.InitTrigger(GetAttachedTrigger());
		if(m_bSelectorEnabled)then
			m_xObjFinder.MakeQuery(xObjs);
		endif;
		xObjs.Include(m_xObjList);
		if(xObjs.NumEntries() <= 0)then
			//L KLog.LogSpam("CyGi","AIAM: OnPush: nothing found for aggression change");
			return false;
		endif;
		var int i;
		var vec3 vP;
		var ^CGameObj pxObj;
		for(i = 0)cond(i < xObjs.NumEntries())iter(i++)do
			if(xObjs[i].IsValid() == false)then
				//L KLog.LogWarn("CyGi", "AIAM: OnPush(): Skipping invalid obj " + i.ToString());
				continue;
			endif;
			pxObj = xObjs[i].GetObj();
			pxObj^.HandleGamePlayCommand("Action", null, vP, "/AggroState_" + m_iAggroState.ToString());
		endfor;
		return true;
	endproc;
	
	///Load
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType() == "AIAM")then
			var int iVersion = p_pxNode^.GetVersion();
			var ^CArc pxArc = ^(p_pxNode^.GetArc());
			if(iVersion >= 1)then
				m_xObjFinder.DoKArc(pxArc^);
				(pxArc^) << m_iAggroState;
			endif;
			if(iVersion>=2)then
				(pxArc^) << m_bSelectorEnabled;
				m_xObjList.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	///Save
	proc void Save(^CUOFWriterNode p_pxNode)
//		//L KLog.LogSpam("RoSt","AIAM: Save()");
		super.Save(p_pxNode);
		var CFourCC xF = "AIAM";
		var ^CUOFWriterNode pxN = p_pxNode^.AddSubChunk(xF,2);
		var ^CArc pxArc = ^(pxN^.GetArc());
		m_xObjFinder.DoKArc(pxArc^);
		(pxArc^) << m_iAggroState;
		(pxArc^) << m_bSelectorEnabled;
		m_xObjList.DoKArc(pxArc^);
		pxN^.Close();
	endproc;
	
endclass;
	
class CActionSpawnGroup inherit CTrigger.IAction
	
	var int								m_iOwner;
	var vec3							m_vPos;
	var array string			m_asClass;
	var array int					m_aiCount;
	var array int					m_aiLevel;
	var CObjHndl					m_xGroup;
	var bool							m_bCheckPyramid;
	var bool							m_bSpawnObj;
	var CActionObjFinder	m_xObjFinder;
	var real							m_fSpawnDelay;
	var array string			m_asBuildup;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxArgs)
		m_iOwner = p_rxArgs.GetValueInt("owner");
		m_vPos.FromString(p_rxArgs.GetValue("pos"));
		m_bCheckPyramid = p_rxArgs.GetValueBool("checkpyramid");
		var int i, iC = p_rxArgs.GetValueInt("num_stages");
		var CGuid xG;
		xG.FromString(p_rxArgs.GetValue("group"));
		var ^CGameObj pxO = CSrvWrap.GetObjMgr()^.GetObjByGuid(xG);
		if(pxO!=null)then
			m_xGroup = pxO^.GetHandle();
		endif;
		for(i=0)cond(i<iC) iter(++i)do
			var string sStage = p_rxArgs.GetValue("classes_"+i.ToString());
			if(sStage.IsEmpty())then break; endif;
			var array string asToks;
			sStage.Split(asToks, "|", true);
			var int j, iJC = asToks.NumEntries();
			for(j=0)cond(j<iJC) iter(++j)do
				var array string asDef;
				asToks[j].Split(asDef, " ", true);
				var int iIdx = m_asClass.NewEntry();
				//var int iIdx = m_asClass.FindEntry(asDef[0]);
				//if(iIdx<0)then
				m_aiCount.NewEntry();
				m_aiLevel.NewEntry();
				//endif;
				m_asClass[iIdx]=asDef[0];
				if(asDef[1].ToInt()-1<0)then
					m_aiLevel[iIdx]=0;
				else
					m_aiLevel[iIdx]=asDef[1].ToInt()-1;
				endif;
				m_aiCount[iIdx]=asDef[2].ToInt();
			endfor;
		endfor;
		m_xObjFinder.Init(p_rxArgs);
		m_bSpawnObj = p_rxArgs.GetValueInt("use_spawn_obj")==1;
		m_fSpawnDelay = p_rxArgs.GetValueInt("spawn_delay").ToReal();
		////L KLog.LogSpam("MaZi", "Spawn-Delay = "+m_fSpawnDelay.ToString());
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		var array int aiLevel, aiMaxLevel;
		aiLevel = 5;
		aiMaxLevel = 5;
		aiMaxLevel[0] = 25;
		aiMaxLevel[1] = 15;
		aiMaxLevel[2] = 8;
		aiMaxLevel[3] = 3;
		aiMaxLevel[4] = 1;
		var CObjQuery xQ;
		xQ.SetOwner(m_iOwner);
		xQ.SetType("CHTR", false);
		var CObjList xL;
		xQ.Execute(xL);
		var int i, iC = xL.NumEntries();
		for(i=0)cond(i<iC)iter(++i)do
			var ^CCharacter pxC = cast<CCharacter>(xL[i].GetObj());
			if(pxC!=null)then
				++aiLevel[pxC^.GetLevel()];
			endif;
		endfor;
		var ^CGroupObj pxGroup = cast<CGroupObj>(m_xGroup.GetObj());
		var ^CDelayedArmySpawn pxSpawner = null;
		if(m_bSpawnObj)then
			pxSpawner = cast<CDelayedArmySpawn>(CSrvWrap.GetObjMgr()^.CreateObj("delayed_army_spawn", m_iOwner));
			var CObjList xL;
			m_xObjFinder.MakeQuery(xL);
			if(xL.NumEntries()<=0)then
				pxSpawner^.Delete();
				pxSpawner = null;
			else
				var ^CGameObj pxSpawnObj = xL[0].GetObj();
				if(pxSpawnObj!=null)then
					var vec3 vSpawnPos;
					var CFourCC xLink="Spwn";
					if(!pxSpawnObj^.GetLinkPosWorld(xLink, vSpawnPos))then
						vSpawnPos = pxSpawnObj^.GetPos();
					endif;
					var vec3 vExitPos;
					xLink="Ex_1";
					if(!pxSpawnObj^.GetLinkPosWorld(xLink, vExitPos))then
						vExitPos = pxSpawnObj^.GetPos();
						CSrvWrap.GetObjMgr()^.GetFreePos(vExitPos, pxSpawnObj, vExitPos);
					endif;
					var ^CFightingObj pxFightingObj=cast<CFightingObj>(pxSpawnObj);
					if(pxFightingObj!=null)then
						pxFightingObj^.SetRallyPoint(m_vPos,CObjHndl.Invalid());
					endif;
					pxSpawner^.SetSpawnPos(vSpawnPos);
					pxSpawner^.SetExitPos(vExitPos);
					pxSpawner^.SetDestinationPos(m_vPos);
					pxSpawner^.SetGroup(m_xGroup);
					pxSpawner^.SetSourceObj(pxSpawnObj^.GetHandle());
					pxSpawner^.SetSpawnDelay(m_fSpawnDelay);
					
				endif;
			endif;
		endif;
		iC = m_asClass.NumEntries();
		for(i=0)cond(i<iC) iter(++i)do
			if(!m_bCheckPyramid || (aiLevel[m_aiLevel[i]] < aiMaxLevel[m_aiLevel[i]]))then
				++aiLevel[m_aiLevel[i]];
				var string sName;
				var string sTmpBuildname;
				if(m_asClass[i].Find("§") >= 0)then
					sName = m_asClass[i].Left(m_asClass[i].Find("§"));
					sTmpBuildname = m_asClass[i].Right((m_asClass[i].GetLength() - m_asClass[i].Find("§"))-1);
				else
					sName = m_asClass[i];
				endif;
				var int j, jC = m_aiCount[i];
				for(j=0)cond(j<jC) iter(++j)do
					if(m_bSpawnObj && pxSpawner!=null)then
						pxSpawner^.AddJob(sName, m_aiLevel[i]);
						continue;
					endif;
					if(m_bCheckPyramid && (aiLevel[m_aiLevel[i]] > aiMaxLevel[m_aiLevel[i]]))then break; endif;
					var ^CGameObj pxO = CSrvWrap.GetObjMgr()^.CreateObj(sName, m_iOwner, m_vPos);
					if(pxO!=null)then
						++aiLevel[m_aiLevel[i]];
						var vec3 vP;
						CSrvWrap.GetObjMgr()^.GetFreePos(vP, pxO, m_vPos);
						pxO^.SetPos(vP);
						////L KLog.LogSpam("MaZi", "spawned obj: "+pxO^.GetClassName());
						var ^CAttribs pxObjAttrib = pxO^.GetAttribs();
						if(pxObjAttrib!=null)then
							if(pxObjAttrib^.GetValue("tribe")!="")then
							var string sFilter="/Filters/" + pxObjAttrib^.GetValue("tribe") + "/Upgrades/" + sName + "/" + sTmpBuildname;
								if(pxO^.GetTechTreeDef() != null)then 
									pxO^.GetTechTreeDef()^.ClearFilters();
									pxO^.GetTechTreeDef()^.EnableFilter(sFilter);
								endif;
							endif;
						endif ;
						var ^CFightingObj pxFightingObj = cast<CFightingObj>(pxO);
						if(pxFightingObj!=null)then
							pxFightingObj^.SetLevelClean(m_aiLevel[i]);
							pxFightingObj^.PreCheckForEnemies();
							pxFightingObj^.ExamineEnemies(false);
						endif;
						var ^CBuilding pxBuilding = cast<CBuilding>(pxO);
						if(pxBuilding!=null)then
							pxBuilding^.SetReadyBuild();
						endif;
						if(pxGroup!=null)then
							pxGroup^.AddMember(pxO^.GetHandle());
						endif;
					endif;
				endfor;
			endif;
		endfor;
		if(pxSpawner!=null)then
			pxSpawner^.StartAnim();
		endif;
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="SPGR")then
			var ^CArc pxArc=^(p_pxNode^.GetArc());
			if(p_pxNode^.GetVersion()>=2)then
				(pxArc^) << m_iOwner;
				(pxArc^) << m_vPos;
				var int i, iC;
				(pxArc^) << iC;
				m_asClass=iC;
				m_aiLevel=iC;
				m_aiCount=iC;
				for(i=0)cond(i<iC) iter(++i)do
					(pxArc^) << m_asClass[i];
					(pxArc^) << m_aiLevel[i];
					(pxArc^) << m_aiCount[i];
				endfor;
			endif;
			if(p_pxNode^.GetVersion()>=3)then
				m_xGroup.DoKArc(pxArc^);
			endif;
			if(p_pxNode^.GetVersion()>=4)then
				(pxArc^) << m_bCheckPyramid;
			endif;
			if(p_pxNode^.GetVersion()>=5)then
				pxArc^ << m_bSpawnObj;
				pxArc^ << m_fSpawnDelay;
				m_xObjFinder.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="SPGR";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,5);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_iOwner;
		(pxArc^) << m_vPos;
		var int i, iC = m_asClass.NumEntries();
		(pxArc^) << iC;
		for(i=0)cond(i<iC) iter(++i)do
			(pxArc^) << m_asClass[i];
			(pxArc^) << m_aiLevel[i];
			(pxArc^) << m_aiCount[i];
		endfor;
		m_xGroup.DoKArc(pxArc^);
		(pxArc^) << m_bCheckPyramid;
		pxArc^ << m_bSpawnObj;
		pxArc^ << m_fSpawnDelay;
		m_xObjFinder.DoKArc(pxArc^);
		pxN^.Close();
	endproc;
	
endclass;
	
class CActionAddToGroup inherit CTrigger.IAction
	
	var CActionObjFinder	m_xObjFinder;
	var CObjHndl					m_xGroup;
	var bool							m_bSelectorEnabled;
	var CObjList					m_xObjList;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxArgs)
		m_xObjFinder.Init(p_rxArgs);
		var CGuid xG; xG.FromString(p_rxArgs.GetValue("group"));
		var ^CGameObj pxO = CSrvWrap.GetObjMgr()^.GetObjByGuid(xG);
		if(pxO!=null)then
			m_xGroup = pxO^.GetHandle();
		endif;
		m_bSelectorEnabled = p_rxArgs.GetValueInt("selector_enabled") == 1;
		var ^CObjMgrHost pxObjMgr = CSrvWrap.GetObjMgr();
		var array string asGUIDs;
		p_rxArgs.GetValue("add_to_group_units").Split(asGUIDs,"\n",true);
		var int i, iC=asGUIDs.NumEntries();
		var CGuid xUnit;
		for(i=0)cond(i<iC)iter(i++)do
			xUnit.FromString(asGUIDs[i]);
			var ^CGameObj pxObj = pxObjMgr^.GetObjByGuid(xUnit);
			if(pxObj==null)then continue; endif;
			m_xObjList.AddEntry(pxObj^.GetHandle());
		endfor;
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		m_xObjFinder.InitTrigger(GetAttachedTrigger());
		var CObjList xL;
		if(m_bSelectorEnabled)then
			m_xObjFinder.MakeQuery(xL);
		endif;
		xL.Include(m_xObjList);
		var ^CGroupObj pxO = cast<CGroupObj>(m_xGroup.GetObj());
		if(pxO!=null)then
			var int i, iC = xL.NumEntries();
			for(i=0)cond(i<iC) iter(++i)do
				pxO^.AddMember(xL[i]);
			endfor;
		endif;
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="ADGR")then
			var int iVersion = p_pxNode^.GetVersion();
			var ^CArc pxArc=^(p_pxNode^.GetArc());
			if(iVersion>=1)then
				m_xObjFinder.DoKArc(pxArc^);
				m_xGroup.DoKArc(pxArc^);
			endif;
			if(iVersion>=2)then
				m_xObjList.DoKArc(pxArc^);
				(pxArc^) << m_bSelectorEnabled;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="ADGR";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,2);
		var ^CArc pxArc=^(pxN^.GetArc());
		m_xObjFinder.DoKArc(pxArc^);
		m_xGroup.DoKArc(pxArc^);
		m_xObjList.DoKArc(pxArc^);
		(pxArc^) << m_bSelectorEnabled;
		pxN^.Close();
	endproc;
	
endclass;
	
//From AyCe
class CActionRemoveFromGroup inherit CTrigger.IAction
	
	var CActionObjFinder	m_xObjFinder;
	var CObjHndl					m_xGroup;
	var bool							m_bSelectorEnabled;
	var CObjList					m_xObjList;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxArgs)
		m_xObjFinder.Init(p_rxArgs);
		var CGuid xG; xG.FromString(p_rxArgs.GetValue("group"));
		var ^CGameObj pxO = CSrvWrap.GetObjMgr()^.GetObjByGuid(xG);
		if(pxO!=null)then
			m_xGroup = pxO^.GetHandle();
		endif;
		m_bSelectorEnabled = p_rxArgs.GetValueInt("selector_enabled") == 1;
		var ^CObjMgrHost pxObjMgr = CSrvWrap.GetObjMgr();
		var array string asGUIDs;
		p_rxArgs.GetValue("remove_from_group_units").Split(asGUIDs,"\n",true);
		var int i, iC=asGUIDs.NumEntries();
		var CGuid xUnit;
		for(i=0)cond(i<iC)iter(i++)do
			xUnit.FromString(asGUIDs[i]);
			var ^CGameObj pxObj = pxObjMgr^.GetObjByGuid(xUnit);
			if(pxObj==null)then continue; endif;
			m_xObjList.AddEntry(pxObj^.GetHandle());
		endfor;
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		m_xObjFinder.InitTrigger(GetAttachedTrigger());
		var CObjList xL;
		if(m_bSelectorEnabled)then
			m_xObjFinder.MakeQuery(xL);
		endif;
		xL.Include(m_xObjList);
		var ^CGroupObj pxO = cast<CGroupObj>(m_xGroup.GetObj());
		if(pxO!=null)then
			var int i, iC = xL.NumEntries();
			for(i=0)cond(i<iC) iter(++i)do
				pxO^.RemMember(xL[i]);
			endfor;
		endif;
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="RMGR")then
			var int iVersion = p_pxNode^.GetVersion();
			var ^CArc pxArc=^(p_pxNode^.GetArc());
			if(iVersion>=1)then
				m_xObjFinder.DoKArc(pxArc^);
				m_xGroup.DoKArc(pxArc^);
			endif;
			if(iVersion>=2)then
				m_xObjList.DoKArc(pxArc^);
				(pxArc^) << m_bSelectorEnabled;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="RMGR";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,2);
		var ^CArc pxArc=^(pxN^.GetArc());
		m_xObjFinder.DoKArc(pxArc^);
		m_xGroup.DoKArc(pxArc^);
		m_xObjList.DoKArc(pxArc^);
		(pxArc^) << m_bSelectorEnabled;
		pxN^.Close();
	endproc;
	
endclass;
	
class CActionTransportMounting inherit CTrigger.IAction
	
	var bool							m_bMount;
	var CActionObjFinder	m_xObjects, m_xSubjects;
	var CObjList					m_xObjList, m_xSubList;
	var bool							m_bEnObjects, m_bEnSubjects;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxArgs)
		m_xObjList.Clear();
		m_xSubList.Clear();
		m_bMount = p_rxArgs.GetValueInt("mount")==1;
		m_xObjects.Init(p_rxArgs);
		m_xSubjects.Init(p_rxArgs, "sub_");
		var ^CObjMgrHost pxObjMgr = CSrvWrap.GetObjMgr();
		var array string asGUIDs;
		m_bEnObjects = p_rxArgs.GetValueInt("enable_objsel")==1;
		m_bEnSubjects = p_rxArgs.GetValueInt("enable_subsel")==1;
		p_rxArgs.GetValue("objects_units").Split(asGUIDs,"\n",true);
		var int i, iC=asGUIDs.NumEntries();
		var CGuid xUnit;
		for(i=0)cond(i<iC)iter(i++)do
			xUnit.FromString(asGUIDs[i]);
			var ^CGameObj pxObj = pxObjMgr^.GetObjByGuid(xUnit);
			if(pxObj==null)then continue; endif;
			m_xObjList.AddEntry(pxObj^.GetHandle());
		endfor;
		asGUIDs = 0;
		p_rxArgs.GetValue("subjects_units").Split(asGUIDs,"\n",true);
		iC=asGUIDs.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			xUnit.FromString(asGUIDs[i]);
			var ^CGameObj pxObj = pxObjMgr^.GetObjByGuid(xUnit);
			if(pxObj==null)then continue; endif;
			m_xSubList.AddEntry(pxObj^.GetHandle());
		endfor;
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		m_xObjects.InitTrigger(GetAttachedTrigger());
		m_xSubjects.InitTrigger(GetAttachedTrigger());
		var CObjList xA, xB;
		if(m_bEnObjects)then
			m_xObjects.MakeQuery(xA);
		endif;
		if(m_bMount && m_bEnSubjects)then
			m_xSubjects.MakeQuery(xB);
		endif;
		xA.Include(m_xObjList);
		xB.Include(m_xSubList);
		if(m_bMount)then
			var array ^CGameObj apxContainers;
			var CObjList xChars;
			var int i, iC = xB.NumEntries();
			for(i=0)cond(i<iC) iter(++i)do
				var ^CGameObj pxContainer=xB[i].GetObj();
				if(pxContainer!=null)then
					var ^CTransportObj pxTO = cast<CTransportObj>(pxContainer);
					if(pxTO!=null && pxTO^.IsFull())then
						continue;
					endif;
				endif;
				apxContainers.AddEntry(pxContainer);
			endfor;
			iC=xA.NumEntries();
			for(i=0)cond(i<iC) iter(++i)do
				var ^CFightingObj pxF = cast<CFightingObj>(xA[i].GetObj());
				if(pxF!=null && !pxF^.GetTransportObj().IsValid())then
					xChars.Include(xA[i]);
				endif;
			endfor;
			iC = apxContainers.NumEntries();
			for(i=0)cond(i<iC) iter(i++)do
				var ^CGameObj pxContainer=apxContainers[i];
				var ^CTransportObj pxTransport = cast<CTransportObj>(pxContainer);
				if(pxTransport!=null)then
					xChars.SortDistance(pxTransport^.GetPos());
					var int iSpaceLeft = pxTransport^.GetMaxPassengers()-pxTransport^.NumPassengers();
					while(iSpaceLeft>0 && xChars.NumEntries()>0)do
						var ^CFightingObj pxFO = cast<CFightingObj>(xChars[0].GetObj());
						if(pxFO!=null)then
							pxFO^.BoardTransport(pxTransport, pxTransport^.GetPos(), true, "/BoardTransporter");
						endif;
						xChars.DeleteEntry(0);
						--iSpaceLeft;
					endwhile;
				else
					var ^CBunker pxBunker=cast<CBunker>(pxContainer);
					if(pxBunker!=null)then
						var int i,iC=xChars.NumEntries();
						for(i=0)cond(i<iC)iter(i++)do
							var ^CCharacter pxChar = cast<CCharacter>(xChars[i].GetObj());
							if(pxChar!=null)then
								pxChar^.EnterBunker(pxBunker, false);
							endif;
						endfor;
					endif;
				endif;
			endfor;
		else
			var int i, iC = xA.NumEntries();
			for(i=0)cond(i<iC) iter(++i)do
				if(xA[i].IsValid())then
					var ^CTransportObj pxTO =cast<CTransportObj>(xA[i].GetObj());
					if(pxTO!=null)then
						if(iC>0)then
							var string sCurTask = pxTO^.GetTaskMgr()^.GetCurTaskName();
							if((sCurTask=="None" || sCurTask.IsEmpty())&&pxTO^.NumPassengers()>1)then
								pxTO^.DismountAll();
								return true;
							endif;
						else
							pxTO^.DismountAll();
						endif;
					else
						var ^CBunker pxBunker=cast<CBunker>(xA[i].GetObj());
						if(pxBunker!=null)then
							pxBunker^.DismountAll();
						endif;
					endif;
				endif;
			endfor;
		endif;
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="TRSP")then
			var ^CArc pxArc=^(p_pxNode^.GetArc());
			if(p_pxNode^.GetVersion()>=1)then
				(pxArc^) << m_bMount;
				m_xObjects.DoKArc(pxArc^);
				m_xSubjects.DoKArc(pxArc^);
			endif;
			if(p_pxNode^.GetVersion()>=2)then
				m_xObjList.DoKArc(pxArc^);
				m_xSubList.DoKArc(pxArc^);
				(pxArc^) << m_bEnObjects;
				(pxArc^) << m_bEnSubjects;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="TRSP";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,2);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_bMount;
		m_xObjects.DoKArc(pxArc^);
		m_xSubjects.DoKArc(pxArc^);
		m_xObjList.DoKArc(pxArc^);
		m_xSubList.DoKArc(pxArc^);
		(pxArc^) << m_bEnObjects;
		(pxArc^) << m_bEnSubjects;
		pxN^.Close();
	endproc;
	
endclass;
	
class CActionMusic inherit CTrigger.IAction
	
	var bool		m_bLoop;
	var string	m_sMusic;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxArgs)
		m_sMusic = p_rxArgs.GetValue("musicfile");
		m_bLoop  = p_rxArgs.GetValueInt("loop")==1;
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		var bitset dwCl = 011111111b;
		CSrvWrap.SendGenericEvtToClients(dwCl, "PlayMusic\t" + m_sMusic+"\t"+m_bLoop.ToString());
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="MUSI")then
			var ^CArc pxArc=^(p_pxNode^.GetArc());
			if(p_pxNode^.GetVersion()>=1)then
				pxArc^ << m_sMusic;
			endif;
			if(p_pxNode^.GetVersion()>=2)then
				pxArc^ << m_bLoop;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="MUSI";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,2);
		var ^CArc pxArc=^(pxN^.GetArc());
		pxArc^ << m_sMusic;
		pxArc^ << m_bLoop;
		pxN^.Close();
	endproc;
	
endclass;
	
class CActionInfoBar inherit CTrigger.IAction
	
	//static var array ^CActionInfoBar ms_apxStuff;
	
	var string m_sText;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxArgs)
		m_sText = p_rxArgs.GetValue("text");
	endconstructor;
	
	export destructor()
		/*var ^CLevelInfoHost pxLevelInfo = ^(CSrvWrap.GetCurLevel()^.GetLevelInfo());
		if(pxLevelInfo!=null)then
			ms_apxStuff.RemEntry(this);
			pxLevelInfo^.Unsubscribe(this);
		endif;*/
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		/*if(p_rxEP.GetClass().ToString()=="SCHANGED" || p_rxEP.GetClass().ToString()=="VARSCHG")then
			if(p_rxEP.GetClass().ToString()=="SCHANGED" || m_sText.IsEmpty())then
				var ^CLevelInfoHost pxLevelInfo = ^(CSrvWrap.GetCurLevel()^.GetLevelInfo());
				if(pxLevelInfo!=null)then
					if(m_sText.IsEmpty())then
						var int i, iC = ms_apxStuff.NumEntries();
						for(i=0)cond(i<iC) iter(++i)do
							pxLevelInfo^.Unsubscribe(ms_apxStuff[i]);
						endfor;
						ms_apxStuff=0;
					else
						pxLevelInfo^.Subscribe(this);
						ms_apxStuff.AddEntry(this);
					endif;
				endif;
			endif;
		*/
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel!=null)then 
				var ^CLevelInfoHost pxLevelInfo = ^(pxLevel^.GetLevelInfo());
				pxLevelInfo^.GetAttribs().SetValue("InfoBarText",m_sText);
			endif;
		//endif;
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="INBA")then
			if(p_pxNode^.GetVersion()>=1)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				pxArc^ << m_sText;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="INBA";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,1);
		var ^CArc pxArc=^(pxN^.GetArc());
		pxArc^ << m_sText;
		pxN^.Close();
	endproc;
	
endclass;
	
class CActionQuickSave inherit CTrigger.IAction
	
	var string m_sSaveName;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxArgs)
		m_sSaveName = p_rxArgs.GetValue("savename");
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		var ^CUserProfileList pxList = CSrvWrap.GetUserProfileList();
		if(pxList!=null)then
			var string sSavegame = pxList^.TransformSaveGameFilename(m_sSaveName);
			sSavegame.Replace("savegame_", "autosave_");
			CSrvWrap.SaveLevel(sSavegame);
			CFeedback.Print(0, CFeedback.SYSTEM, "_NT_Quicksave");
		endif;
		var string sPath=CSrvWrap.GetUrsRelPath()+"/Data/Base/Maps/SaveGames/Quicksave.ula";
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="QUSA")then
			if(p_pxNode^.GetVersion()>=2)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				pxArc^ << m_sSaveName;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="QUSA";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,2);
		var ^CArc pxArc=^(pxN^.GetArc());
		pxArc^ << m_sSaveName;
		pxN^.Close();
	endproc;
	
endclass;
	
class CActionMoveRegion inherit CTrigger.IAction
	
	var CGuid m_xRgnGuid;
	var vec3 m_vPos, m_vScale;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxArgs)
		m_xRgnGuid.FromString(p_rxArgs.GetValue("rgn_guid"));
		m_vPos.FromString(p_rxArgs.GetValue("pos"));
		m_vScale = {1.0f, 1.0f, 1.0f};
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		var ^CRegionMgr pxRM = ^(CSrvWrap.GetRegionMgr());
		var ^CRegion pxRgn = pxRM^.GetRegionByGuid(m_xRgnGuid);
		pxRgn^.SetPos(m_vPos);
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="MRGN")then
			if(p_pxNode^.GetVersion()>=1)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				pxArc^ << m_xRgnGuid;
				pxArc^ << m_vPos;
				pxArc^ << m_vScale;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="MRGN";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,1);
		var ^CArc pxArc=^(pxN^.GetArc());
		pxArc^ << m_xRgnGuid;
		pxArc^ << m_vPos;
		pxArc^ << m_vScale;
		pxN^.Close();
	endproc;
	
endclass;
	
class CActionSetNeutForAnml inherit CTrigger.IAction
	
	var int m_iPlayer;
	var bool m_bAdd;
	var bool m_bAndOtherWise;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxArgs)
		m_iPlayer = p_rxArgs.GetValueInt("player");
		var int iArgValue=p_rxArgs.GetValueInt("neutral");
	
		if(iArgValue==1||iArgValue==3)then
			m_bAdd = true;
		endif;
	
		if(iArgValue>1)then
			m_bAndOtherWise=true;
		endif;
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		if(m_bAdd)then
			CNest.ms_aiNeutralPlayer.AddEntry(m_iPlayer);
		else
			CNest.ms_aiNeutralPlayer.RemEntry(m_iPlayer);
		endif;
		// CSrvWrap.GetObjMgr()^.SetForcedToBeNeutral(m_iPlayer,m_bAndOtherWise);
		var ^CPlayer pxPlayer=CSrvWrap.GetCurLevel()^.GetPlayer(m_iPlayer);
		if(pxPlayer!=null)then
//			var ^CAttribs pxPlayerAttr=pxPlayer^.GetAttribs();
//			if(pxPlayerAttr!=null)then
//				pxPlayerAttr^.SetValue("neutral_to_anmls",m_bAndOtherWise);
//			else
//				return false;
//			endif;
			var ^CBasePlayer pxBPl=cast<CBasePlayer>(pxPlayer);
			if(pxBPl!=null)then
				pxBPl^.SetForcedToBeNeutral(m_bAndOtherWise);
			else
				return false;
			endif;
		else
			return false;
		endif;
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="SNFA")then
			if(p_pxNode^.GetVersion()>=1)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				pxArc^ << m_iPlayer;
				pxArc^ << m_bAdd;
				pxArc^ << m_bAndOtherWise;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="SNFA";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,1);
		var ^CArc pxArc=^(pxN^.GetArc());
		pxArc^ << m_iPlayer;
		pxArc^ << m_bAdd;
		pxArc^ << m_bAndOtherWise;
		pxN^.Close();
	endproc;
	
endclass;
	
class CActionPlayerCaps inherit CTrigger.IAction
	
	var int m_iOwner, m_iF, m_iW, m_iS;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxArgs)
		m_iOwner = p_rxArgs.GetValueInt("player");
		m_iF = p_rxArgs.GetValueInt("food");
		m_iW = p_rxArgs.GetValueInt("wood");
		m_iS = p_rxArgs.GetValueInt("stone");
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		var ^CBasePlayer pxPlayer = CBasePlayer.GetPlayer(m_iOwner);
		if(pxPlayer==null)then
			KLog.LogError("CActionPlayerCaps","Player [" + m_iOwner.ToString() + "] is null");
			return false;
		endif;
		
		var ^CAttribs pxA = pxPlayer^.GetAttribs();
		if(pxA!=null)then
			pxA^.SetValue("rescap_food", m_iF);
			pxA^.SetValue("rescap_wood", m_iW);
			pxA^.SetValue("rescap_stone", m_iS);
		endif;
		pxPlayer^.UpdateResCaps();
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="PLCP")then
			if(p_pxNode^.GetVersion()>=1)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				pxArc^ << m_iOwner;
				pxArc^ << m_iF;
				pxArc^ << m_iW;
				pxArc^ << m_iS;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="PLCP";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,1);
		var ^CArc pxArc=^(pxN^.GetArc());
		pxArc^ << m_iOwner;
		pxArc^ << m_iF;
		pxArc^ << m_iW;
		pxArc^ << m_iS;
		pxN^.Close();
	endproc;
	
endclass;
	
class CActionActivateRegion inherit CTrigger.IAction
	
	var CGuid m_xRgn;
	var int m_iSub;
	var bool m_bOn;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxArgs)
		m_xRgn.FromString(p_rxArgs.GetValue("rgn_guid"));
		m_iSub = p_rxArgs.GetValueInt("sub_idx");
		m_bOn = p_rxArgs.GetValueInt("dest_state")==1;
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		var ^CRegionMgr pxRM = ^(CSrvWrap.GetRegionMgr());
		var ^CRegion pxRgn = pxRM^.GetRegionByGuid(m_xRgn);
		if(m_iSub>=0)then
			var ^CSubRegion pxSub = pxRgn^[m_iSub];
			pxSub^.SetEnable(m_bOn);
		else
			pxRgn^.SetEnable(m_bOn);
		endif;
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="ARGN")then
			if(p_pxNode^.GetVersion()>=1)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				pxArc^ << m_xRgn;
				pxArc^ << m_iSub;
				pxArc^ << m_bOn;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="ARGN";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,1);
		var ^CArc pxArc=^(pxN^.GetArc());
		pxArc^ << m_xRgn;
		pxArc^ << m_iSub;
		pxArc^ << m_bOn;
		pxN^.Close();
	endproc;
	
endclass;
	
class CActionNewsTicker inherit CTrigger.IAction
	
		var int			m_iPlayerID;
		var string	m_sMessage;
		var int			m_iDuration;
		var int			m_iType;
		var vec3		m_vPos;
		var string	m_sSpecialEvent;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxArgs)
		m_iPlayerID=p_rxArgs.GetValueInt("player_id");
		m_sMessage=p_rxArgs.GetValue("message");
		m_iDuration=p_rxArgs.GetValueInt("duration");
		m_iType=p_rxArgs.GetValueInt("type");
		m_vPos.FromString(p_rxArgs.GetValue("position"));
		m_sSpecialEvent=p_rxArgs.GetValue("special_event");
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		if(m_iPlayerID<0)then m_iPlayerID=-2; endif;
		CFeedback.Print(m_iPlayerID,m_iType,m_sMessage+m_sSpecialEvent,m_vPos,m_iDuration*1000);
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="NWTK")then
			var int iVersion=p_pxNode^.GetVersion();
			var ^CArc pxArc=^(p_pxNode^.GetArc());
			(pxArc^) << m_iPlayerID;
			(pxArc^) << m_sMessage;
			(pxArc^) << m_iDuration;
			(pxArc^) << m_iType;
			(pxArc^) << m_vPos;
			(pxArc^) << m_sSpecialEvent;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="NWTK";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,0);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_iPlayerID;
		(pxArc^) << m_sMessage;
		(pxArc^) << m_iDuration;
		(pxArc^) << m_iType;
		(pxArc^) << m_vPos;
		(pxArc^) << m_sSpecialEvent;
		pxN^.Close();
	endproc;
	
endclass;
	
class CActionUIFeedbackFrame inherit CTrigger.IAction
	
	var string		m_sFrameName;
	var bool			m_bActivate;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxArgs)
		m_sFrameName=p_rxArgs.GetValue("framename");
		m_bActivate=p_rxArgs.GetValueBool("activate");
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		if(m_bActivate)then
			var CGuid xObjGuid;
			begin check_obj;
				var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
				var ^CLevelInfo pxLevelInfo=^(pxLevel^.GetLevelInfo());
				var ^CPropDB.CNode pxFrameNode=pxLevelInfo^.GetGenericData().FindNode("FeedbackFrames/"+m_sFrameName,false);
				if(pxFrameNode!=null)then
					if(pxFrameNode^.GetValueI("type")==2)then
						var ^CPropDB.CNode pxOQNode=pxFrameNode^.Get("ObjQuery");
						if(pxOQNode!=null)then
							var CObjFinder xOF;
							xOF.Init(pxOQNode^);
							var CObjList xObjList;
							xOF.MakeQuery(xObjList);
							if(xObjList.NumEntries()>0)then
								var ^CGameObj pxObj=xObjList[0].GetObj();
								if(pxObj!=null)then
									xObjGuid=pxObj^.GetGuid();
								endif;
							endif;
						endif;
					endif;
				endif;
			end check_obj;
			CSrvWrap.SendGenericEvtToPlayer(0,"feedback_frame\tactivate\t"+m_sFrameName+"\t"+xObjGuid.ToString());
		else
			CSrvWrap.SendGenericEvtToPlayer(0,"feedback_frame\tdeactivate\t"+m_sFrameName);
		endif;
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="UIFF")then
			var int iVersion=p_pxNode^.GetVersion();
			var ^CArc pxArc=^(p_pxNode^.GetArc());
			(pxArc^) << m_sFrameName;
			(pxArc^) << m_bActivate;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="UIFF";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,0);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_sFrameName;
		(pxArc^) << m_bActivate;
		pxN^.Close();
	endproc;
endclass;
	
class CActionScreenRegion inherit CTrigger.IAction
	
	var string		m_sRegionName;
	var bool			m_bActivate;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxArgs)
		m_sRegionName=p_rxArgs.GetValue("regionname");
		m_bActivate=p_rxArgs.GetValueBool("activate");
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		if(m_bActivate)then
			CUniversalTriggerMgr.Get().ScreenRegionAdd(m_sRegionName);
		else
			CUniversalTriggerMgr.Get().ScreenRegionDel(m_sRegionName);
		endif;
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="SCRE")then
			var int iVersion=p_pxNode^.GetVersion();
			var ^CArc pxArc=^(p_pxNode^.GetArc());
			(pxArc^) << m_sRegionName;
			(pxArc^) << m_bActivate;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="SCRE";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,0);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_sRegionName;
		(pxArc^) << m_bActivate;
		pxN^.Close();
	endproc;
	
endclass;
	
class CActionQuestionMark inherit CTrigger.IAction
	
	var CGuid		m_xQuestionMark;
	var string	m_sState;
	var string	m_sToolTip;
	var string	m_sPicture;
	var string	m_sName;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxArgs)
		m_xQuestionMark.FromString(p_rxArgs.GetValue("questionmark"));
		m_sState=p_rxArgs.GetValue("questionstate");
		m_sToolTip=p_rxArgs.GetValue("questiontooltip");
		m_sPicture=p_rxArgs.GetValue("questionpicture");
		m_sName=p_rxArgs.GetValue("questionname");
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		var ^CGameObj pxObj = CSrvWrap.GetObjMgr()^.GetObjByGuid(m_xQuestionMark);
		if(pxObj!=null)then
			var ^CQuestionMark pxQuestionMark=cast<CQuestionMark>(pxObj);
			if(pxQuestionMark!=null)then
				pxQuestionMark^.SetState(m_sState);
				pxQuestionMark^.SetToolTip(m_sToolTip);
				pxQuestionMark^.SetPicture(m_sPicture);
				pxQuestionMark^.SetName(m_sName);
			endif;
		endif;
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="QMRK")then
			var int iVersion=p_pxNode^.GetVersion();
			var ^CArc pxArc=^(p_pxNode^.GetArc());
			(pxArc^) << m_xQuestionMark;
			(pxArc^) << m_sState;
			if(iVersion>=1)then
				(pxArc^) << m_sToolTip;
			endif;
			if(iVersion>=2)then
				(pxArc^) << m_sPicture;
				(pxArc^) << m_sName;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="QMRK";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,2);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_xQuestionMark;
		(pxArc^) << m_sState;
		(pxArc^) << m_sToolTip;
		(pxArc^) << m_sPicture;
		(pxArc^) << m_sName;
		pxN^.Close();
	endproc;
endclass;
	
class CActionAddKOTHSector inherit CTrigger.IAction
	
	var CGuid m_xRgnGuid;
	var string m_sOp;
	var real m_fDuration;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxArgs)
		m_xRgnGuid.FromString(p_rxArgs.GetValue("rgn_guid"));
		m_sOp = p_rxArgs.GetValue("op");
		m_fDuration = p_rxArgs.GetValueFloat("duration");
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		if(m_sOp=="add_sector")then
			CKOTHMgr.Get().CreateSector(m_xRgnGuid);
		elseif(m_sOp=="clear")then
			CKOTHMgr.Get().Clear();
		elseif(m_sOp=="create_timer")then
			CKOTHMgr.Get().CreateTimerHandle(m_fDuration);
		endif;
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="AKOS")then
			if(p_pxNode^.GetVersion()>=2)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				pxArc^ << m_xRgnGuid;
				pxArc^ << m_sOp;
				pxArc^ << m_fDuration;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="AKOS";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,2);
		var ^CArc pxArc=^(pxN^.GetArc());
		pxArc^ << m_xRgnGuid;
		pxArc^ << m_sOp;
		pxArc^ << m_fDuration;
		pxN^.Close();
	endproc;
	
endclass;
	
class CActionTimer inherit CTrigger.IAction
	
	var int m_iTimerID;
	var string m_sEvent;
	var real m_fDuration;
	var bool m_bShow;
	var bool m_bRepeat;
	var string m_sTooltip;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxArgs)
		m_sEvent=p_rxArgs.GetValue("event");
		m_fDuration=p_rxArgs.GetValueFloat("duration");
		m_iTimerID=p_rxArgs.GetValueInt("timer_id");
		m_bShow=p_rxArgs.GetValueBool("show");
		m_bRepeat=p_rxArgs.GetValueBool("repeat");
		m_sTooltip=p_rxArgs.GetValue("tooltip");
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		var ^CObjTime pxTimerObj=CObjTime.FindTimerObj("ActionTimer",m_iTimerID); //checking ID only isn't collision safe!!!
//		var ^CObjMgrHost pxObjMgr=(CSrvWrap.GetObjMgr());
//		var ^CObjTime pxTimerObj=null;
//		var int i,iC=pxObjMgr^.GetNumTimerObjects();
//		for(i=0)cond(i<iC)iter(i++)do
//			var ^CObjTime pxWalk=cast<CObjTime>(pxObjMgr^.GetTimerObj(i));
//			if(pxWalk!=null)then
//				//checking ID only isn't collision safe!!!
//				if(pxWalk^.GetID()==m_iTimerID&&pxWalk^.GetOccupant()=="ActionTimer";)then
//					pxTimerObj=pxWalk;
//					break;
//				endif;
//			endif;
//		endfor;
		if(m_sEvent=="create")then
			if(pxTimerObj==null)then
				pxTimerObj=cast<CObjTime>(CSrvWrap.GetObjMgr()^.CreateObj("ObjTime",0));
				if(pxTimerObj==null)then
					KLog.LogError("CConditionTime","TimerObj create failed");
					return true;
				endif;
				pxTimerObj^.SetID(m_iTimerID);
				pxTimerObj^.SetOccupant("ActionTimer");
				pxTimerObj^.SetTooltip(m_sTooltip);
			endif;
			var CGameTimeSpan xInterval=CGameTimeSpan.OneSecond()*m_fDuration;
			pxTimerObj^.Start(xInterval,m_bRepeat,m_bShow);
			elseif(m_sEvent=="pause")then
			if(pxTimerObj!=null)then
				pxTimerObj^.Pause();
			endif;
		elseif(m_sEvent=="unpause")then
			if(pxTimerObj!=null)then
				pxTimerObj^.Unpause();
			endif;
		else//kill
			if(pxTimerObj!=null)then
				pxTimerObj^.Kill();
			endif;
		endif;
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="TIMR")then
			var ^CArc pxArc=^(p_pxNode^.GetArc());
			pxArc^ << m_iTimerID;
			pxArc^ << m_sEvent;
			pxArc^ << m_fDuration;
			pxArc^ << m_bShow;
			pxArc^ << m_bRepeat;
			if(p_pxNode^.GetVersion()>=1)then
				pxArc^ << m_sTooltip;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="TIMR";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,1);
		var ^CArc pxArc=^(pxN^.GetArc());
		pxArc^ << m_iTimerID;
		pxArc^ << m_sEvent;
		pxArc^ << m_fDuration;
		pxArc^ << m_bShow;
		pxArc^ << m_bRepeat;
		// version 1
		pxArc^ << m_sTooltip;
		// version 1
		pxN^.Close();
	endproc;
	
endclass;
	
class CActionEffect inherit CTrigger.IAction
	
	var string						m_sEffectPath;
	var int								m_iNumLoops;
	var vec3							m_vPos;
	var vec3							m_vRot;
	var bool							m_bUseObjQuery;
	var CActionObjFinder	m_xObjFinder;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxArgs)
		m_xObjFinder.Init(p_rxArgs);
		m_sEffectPath=p_rxArgs.GetValue("effect_path");
		m_iNumLoops=p_rxArgs.GetValueInt("loop_value");
		m_vPos.FromString(p_rxArgs.GetValue("pos"));
		m_vRot.FromString(p_rxArgs.GetValue("rot"));
		m_bUseObjQuery=p_rxArgs.GetValueBool("use_objquery");
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		var ^CActionEffectObj pxEffectObj=cast<CActionEffectObj>(CSrvWrap.GetObjMgr()^.CreateObj("ActionEffectObj",0,m_vPos,m_vRot));
		if(pxEffectObj!=null)then
			if(m_bUseObjQuery)then
				m_xObjFinder.InitTrigger(GetAttachedTrigger());
				var CObjList xObjs;
				m_xObjFinder.MakeQuery(xObjs);
				if(xObjs.NumEntries()>0)then
					var ^CGameObj pxTmpObj=xObjs[0].GetObj();
					if(pxTmpObj!=null)then
						pxEffectObj^.SetPos(pxTmpObj^.GetPos());
					endif;
				endif;
			endif;
			pxEffectObj^.Init(m_sEffectPath,m_iNumLoops);
		endif;
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="EFCT")then
			var ^CArc pxArc=^(p_pxNode^.GetArc());
			pxArc^ << m_sEffectPath;
			pxArc^ << m_iNumLoops;
			pxArc^ << m_vPos;
			pxArc^ << m_vRot;
			if(p_pxNode^.GetVersion()>=1)then
				pxArc^ << m_bUseObjQuery;
				m_xObjFinder.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="EFCT";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,1);
		var ^CArc pxArc=^(pxN^.GetArc());
		pxArc^ << m_sEffectPath;
		pxArc^ << m_iNumLoops;
		pxArc^ << m_vPos;
		pxArc^ << m_vRot;
		pxArc^ << m_bUseObjQuery;
		m_xObjFinder.DoKArc(pxArc^);
		pxN^.Close();
	endproc;
	
endclass;
	
//----------------------------------------------------------
class CActionDialogFeedback inherit CTrigger.IAction
	
	var string m_sScene;
	var int m_iPlayer;
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxAttr)
		m_sScene=p_rxAttr.GetValue("scene");
		m_iPlayer=p_rxAttr.GetValueInt("player_id");
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		CSrvWrap.SendGenericEvtToPlayer(m_iPlayer, "dialogscene\t" + m_sScene);
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="DGFB")then
			var ^CArc pxArc=^(p_pxNode^.GetArc());
			(pxArc^) << m_sScene;
			(pxArc^) << m_iPlayer;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="DGFB";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,0);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_sScene;
		(pxArc^) << m_iPlayer;
		pxN^.Close();
	endproc;
	
endclass;
	
/*
	Action - Template
	
class CAction<Name> inherit CTrigger.IAction
	
	export constructor()
	endconstructor;
	
	export constructor(ref CAttribs p_rxArgs)
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		return true;
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="<FourCC>")then
			if(p_pxNode^.GetVersion()>=1)then
				var ^CArc pxArc=^(p_pxNode^.GetArc());
				// TODO: Load stuff
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="<FourCC>";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,1);
		var ^CArc pxArc=^(pxN^.GetArc());
		// TODO: Save stuff
		pxN^.Close();
	endproc;
	
endclass;
*/
