class CMirageSrvMgr
	//CMirageSrvMgr.Get().
	//CMirageSrvMgr.Debug("");
	//CMirageSrvMgr.Debug("xxxxxx: '"+xxxxxx+"'");
	//CMirageSrvMgr.Debug("xxxxxx: '"+(xxxxxx).ToString()+"'");
	//CMirageSrvMgr.SDK();
	//CMirageSrvMgr.Get().DumpLevelInfo()
	
	export const string ALL4ONE="Hu:Aje:Ninigi:SEAS:";
	export const string FAKEGFX="Dummy";
	static var ^CMirageSrvMgr ms_pxMrgSrvInstance;
	var bool m_bUseSupplyChecked;
	export var bool m_bUseSupply;
	var bool m_bShowResourcesInFOWChecked;
	export var bool m_bShowResourcesInFOW;
	var bool m_bHeroPoolChecked;
	export var bool m_bHeroPool;
	var bool m_bResourcesUnlimitedChecked;
	export var bool m_bResourcesUnlimited;
	var bool m_bBuildingCancellationChecked;
	export var bool m_bBuildingCancellation;
	var bool m_bNoHQTimerChecked;
	export var bool m_bNoHQTimer;
	var bool m_bWarpInvisibleChecked;
	export var bool m_bWarpInvisible;
	var bool m_bPortalsChecked;
	export var bool m_bPortals;
	var bool m_bNestRespawnChecked;
	export var bool m_bNestRespawn;
	var bool m_bTransportHealingChecked;
	export var bool m_bTransportHealing;
	var real m_fTHF;
	var bool m_bManaEnabledChecked;
	export var bool m_bManaEnabled;
	var bool m_bUnitResourcesChecked;
	export var bool m_bUnitResources;
	var bool m_bBuildingBurndownChecked;
	export var bool m_bBuildingBurndown;
	var bool m_bUseFinishingMovesChecked;
	export var bool m_bUseFinishingMoves;
	var bool m_bAnimalsVisInFOWChecked;
	export var bool m_bAnimalsVisInFOW;
	var bool m_bDiploLockedChecked;
	export var bool m_bDiploLocked;
	export var bool m_bEndscreen;
	var bool m_bFreeSpecialsChecked;
	export var bool m_bFreeSpecials;
	var bool m_bBonusSkullsChecked;
	export var bool m_bBonusSkulls;
	var bool m_bEpochSixChecked;
	export var bool m_bEpochSix;
	var bool m_bMaxDefChecked;
	export var real m_fMaxDef;
	var bool m_bNoWGTimerChecked;
	export var bool m_bNoWGTimer;
	var bool m_bTitanSlotsChecked;
	export var bool m_bTitanSlots;
	var bool m_bHeroGratisChecked;
	export var bool m_bHeroGratis;
	var bool m_bFlyingEnabledChecked;
	export var bool m_bFlyingEnabled;
	var bool m_bDwnLvlSwitchChecked;
	export var int m_iDwnLvlSwitch;
	var bool m_bTreasureSharingChecked;
	export var bool m_bTreasureSharing;
	var bool m_bFruitsRemovementChecked;
	export var bool m_bFruitsRemovement;
	var bool m_bEarlyTransportChecked;
	export var bool m_bEarlyTransport;
	var bool m_bPhantomModeChecked;
	export var bool m_bPhantomMode;
	var bool m_bRandomRoles;
	var bool m_bSeerPlayer;
	var bool m_bRevelation;
	var bool m_bBloodBrothers;
	var bool m_bSoulKeepers;
	var bool m_bPopulationBonus;
	var int m_iConquerors;
	var int m_iPaladins;
	var int m_iDefenders;
	var bool m_bSandGlassChecked;
	export var bool m_bSandGlass;
	export var int m_iSandGlass;
	var bool m_bDominationUpDownTimerChecked;
	export var bool m_bDominationUpDownTimer;
	var bool m_bBldgMaxCapacityChecked;
	export var bool m_bBldgMaxCapacity;
	var bool m_bSpeedUpChecked;
	export var bool m_bSpeedUp;
	var bool m_bAllowAttackOwnStuff;
	var bool m_bPaused;
	var array int m_aiTacticalPauses;
	var int m_iCurrentPauseOwner;
	var int m_iPauseLimit;
	var bool m_bPauseLimitChecked;
	var bool m_bExternalUnpauseChecked;
	export var bool m_bExternalUnpause;
	var bool m_bTrainingDummiesChecked;
	export var bool m_bTrainingDummies;
	var bool m_bAllowThrowChecked;
	export var bool m_bAllowThrow;
	var bool m_bUseOldSpiritsChecked;
	export var bool m_bUseOldSpirits;
	var bool m_bGlobalReanimChecked;
	export var bool m_bGlobalReanim;
	var bool m_bDisableSpiritsChecked;
	export var bool m_bDisableSpirits;
	var bool m_bDisableBurningChecked;
	export var bool m_bDisableBurning;
	var bool m_bDisableArtifactReleaseChecked;
	export var bool m_bDisableArtifactRelease;
	var bool m_bDisableBerserkingChecked;
	export var bool m_bDisableBerserking;
	var bool m_bExcludeBuildUpChecked;
	export var bool m_bExcludeBuildUp;
	var bool m_bAttackInFOWChecked;
	export var bool m_bAttackInFOW;
	var bool m_bTechtreeStealChecked;
	export var bool m_bTechtreeSteal;
	var bool m_bMultiTribeChecked;
	export var bool m_bMultiTribe;
	var bool m_bOldDisembarkChecked;
	export var bool m_bOldDisembark;
	var bool m_bAuraSharingChecked;
	export var bool m_bAuraSharing;
	var bool m_bDivideSkullsChecked;
	export var bool m_bDivideSkulls;
	var bool m_bObserverChatChecked;
	export var bool m_bObserverChat;
	var bool m_bNoHumpWalkingChecked;
	export var bool m_bNoHumpWalking;
	var bool m_bRemoveTitansChecked;
	export var bool m_bRemoveTitans;
	var bool m_bRemoveTradingChecked;
	export var bool m_bRemoveTrading;
	var bool m_bInfantryWarChecked;
	export var bool m_bInfantryWar;
	var bool m_bDeliveryUnboundChecked;
	export var bool m_bDeliveryUnbound;
	var bool m_bGeneralAdvancementChecked;
	export var bool m_bGeneralAdvancement;
	var bool m_bAllyBuildupChecked;
	export var bool m_bAllyBuildup;
	var bool m_bDominationContinueChecked;
	export var bool m_bDominationContinue;
	var bool m_bAlienCommandsChecked;
	export var bool m_bAlienCommands;
	
	var ^CPropDB m_pxCodex;
	var ^CPropDB.CNode m_pxGreatArchive;
	var ^CPropDB.CNode m_pxSupply;
	var ^CPropDB.CNode m_pxDieAck;
	var ^CPropDB.CNode m_pxBuildUp;
	var ^CPropDB.CNode m_pxCustomMapStuff;
	var ^CPropDB.CNode m_pxClassFromCode;
	var ^CPropDB.CNode m_pxCodeFromClass;
	
	var array string m_asNames;
	var array bool m_abRepairNoCost;
	var array bool m_abBoomingEconomy;
	var array bool m_abResetRallyPoint;
	var array bool m_abContinueRepair;
	var array bool m_abNeutralToWildAnimals;
	export static var ^CPoolMixer ms_pxPoolMixer;
	export static var real ms_fHQTimer;
	export static var real ms_fWGTimer;
	export static var real ms_fDFTimer;
	export var array bool m_abGodMode;
	var array bool m_abANMLResBack;
	var array bool m_abBLDGResBack;
	var array bool m_abCHTRResBack;
	var array bool m_abSHIPResBack;
	var array bool m_abVHCLResBack;
	export static var real ms_fBounty;
	export static var array bool ms_abSkipAtDivision;
	var string m_sMapName;
	
	//CMirageSrvMgr.Get(). ...
	export proc bool Inited()
		var bool bResult=true;
		if(!UseSupply())then bResult=false; endif;
		if(!HeroPool())then bResult=false; endif;
		if(!ShowResourcesInFOW())then bResult=false; endif;
		if(!ResourcesUnlimited())then bResult=false; endif;
		if(!BuildingCancellation())then bResult=false; endif;
		if(!NoHQTimer())then bResult=false; endif;
		if(!WarpInvisible())then bResult=false; endif;
		if(!Portals())then bResult=false; endif;
		if(!NestRespawn())then bResult=false; endif;
		if(!TransportHealing())then bResult=false; endif;
		if(!UnitResources())then bResult=false; endif;
		if(!BuildingBurndown())then bResult=false; endif;
		if(!TimerInitiation())then bResult=false; endif;
		if(!UseFinishingMoves())then bResult=false; endif;
		if(!AnimalsVisInFOW())then bResult=false; endif;
		if(!DiploLocked())then bResult=false; endif;
		if(!MaxDefSet())then bResult=false; endif;
		if(!CorpseDmgAllowed())then bResult=false; endif;
		if(!EpochSix())then bResult=false; endif;
		if(!FreeSpecials())then bResult=false; endif;
		if(!BonusSkulls())then bResult=false; endif;
		if(!NoWGTimer())then bResult=false; endif;
		if(!TitanSlots())then bResult=false; endif;
		if(!HeroGratis())then bResult=false; endif;
		if(!FlyingEnabled())then bResult=false; endif;
		if(DwnLvlSwitch()==0)then bResult=false; endif;
		if(!TreasureSharing())then bResult=false; endif;
		if(!FruitsRemovement())then bResult=false; endif;
		if(!EarlyTransport())then bResult=false; endif;
		if(!PhantomMode())then bResult=false; endif;
		if(!SandGlass())then bResult=false; endif;
		if(!BldgMaxCapacity())then bResult=false; endif;
		if(!SpeedUp())then bResult=false; endif;
		if(!ExternalUnpause())then bResult=false; endif;
		if(PauseLimit()==0)then bResult=false; endif;
		if(!TrainingDummies())then bResult=false; endif;
		if(!AllowThrow())then bResult=false; endif;
		if(!UseOldSpirits())then bResult=false; endif;
		if(!GlobalReanim())then bResult=false; endif;
		if(!DisableSpirits())then bResult=false; endif;
		if(!DisableBurning())then bResult=false; endif;
		if(!DisableArtifactRelease())then bResult=false; endif;
		if(!DisableBerserking())then bResult=false; endif;
		if(!ExcludeBuildUp())then bResult=false; endif;
		if(!AttackInFOW())then bResult=false; endif;
		if(!TechtreeSteal())then bResult=false; endif;
		if(!MultiTribe())then bResult=false; endif;
		if(!OldDisembark())then bResult=false; endif;
		if(!AuraSharing())then bResult=false; endif;
		if(!DominationUpDownTimer())then bResult=false; endif;
		if(!DivideSkulls())then bResult=false; endif;
		if(!ObserverChat())then bResult=false; endif;
		if(!NoHumpWalking())then bResult=false; endif;
		if(!RemoveTitans())then bResult=false; endif;
		if(!RemoveTrading())then bResult=false; endif;
		if(!InfantryWar())then bResult=false; endif;
		if(!DeliveryUnbound())then bResult=false; endif;
		if(!GeneralAdvancement())then bResult=false; endif;
		if(!AllyBuildup())then bResult=false; endif;
		if(!DominationContinue())then bResult=false; endif;
		if(!AlienCommands())then bResult=false; endif;
		UpdateMapName();
		return bResult;
	endproc;
	
	proc void UpdateMapName()
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel==null)then return; endif;
		var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
		if(pxLevelInfo!=null)then
			m_sMapName=CMirageSrvMgr.GetMapName(pxLevelInfo);
		endif;
	endproc;
	
	export static proc ref CMirageSrvMgr Get()
		if(ms_pxMrgSrvInstance==null)then
			ms_pxMrgSrvInstance=new CMirageSrvMgr();
		endif;
		return ms_pxMrgSrvInstance^;
	endproc;
	
	export static proc void ShutStatic()
		delete ms_pxMrgSrvInstance;
	endproc;
	
	export static proc void Kill()
		if(ms_pxMrgSrvInstance!=null)then
			delete ms_pxMrgSrvInstance;
			ms_pxMrgSrvInstance=null;
		endif;
	endproc;
	
	export proc bool Purify()
		m_abANMLResBack=0;
		m_abBLDGResBack=0;
		m_abCHTRResBack=0;
		m_abSHIPResBack=0;
		m_abVHCLResBack=0;
		m_abRepairNoCost=0;
		m_abBoomingEconomy=0;
		m_abResetRallyPoint=0;
		m_abContinueRepair=0;
		m_abNeutralToWildAnimals=0;
		m_aiTacticalPauses=0;
		m_bPaused=false;
		m_abGodMode=0;
		ms_abSkipAtDivision=0;
		m_bUseSupplyChecked=false;
		m_bShowResourcesInFOWChecked=false;
		m_bHeroPoolChecked=false;
		m_bResourcesUnlimitedChecked=false;
		m_bBuildingCancellationChecked=false;
		m_bNoHQTimerChecked=false;
		m_bWarpInvisibleChecked=false;
		m_bPortalsChecked=false;
		m_bNestRespawnChecked=false;
		m_bTransportHealingChecked=false;
		m_bManaEnabledChecked=false;
		m_bUnitResourcesChecked=false;
		m_bBuildingBurndownChecked=false;
		m_bUseFinishingMovesChecked=false;
		m_bAnimalsVisInFOWChecked=false;
		m_bDiploLockedChecked=false;
		m_bEndscreen=false;
		m_bMaxDefChecked=false;
		m_bFreeSpecialsChecked=false;
		m_bBonusSkullsChecked=false;
		m_bEpochSixChecked=false;
		m_bNoWGTimerChecked=false;
		m_bTitanSlotsChecked=false;
		m_bHeroGratisChecked=false;
		m_bFlyingEnabledChecked=false;
		m_bDwnLvlSwitchChecked=false;
		m_bTreasureSharingChecked=false;
		m_bFruitsRemovementChecked=false;
		m_bEarlyTransportChecked=false;
		m_bPhantomModeChecked=false;
		m_bRandomRoles=false;
		m_bSeerPlayer=false;
		m_bRevelation=false;
		m_bBloodBrothers=false;
		m_bSoulKeepers=false;
		m_bPopulationBonus=false;
		m_iConquerors=0;
		m_iPaladins=0;
		m_iDefenders=0;
		m_bSandGlassChecked=false;
		m_iSandGlass=0;
		m_bBldgMaxCapacityChecked=false;
		m_bSpeedUpChecked=false;
		m_abRepairNoCost=8;
		m_abBoomingEconomy=8;
		m_abResetRallyPoint=8;
		m_abContinueRepair=9;
		m_abNeutralToWildAnimals=9;
		m_abGodMode=9;
		ms_abSkipAtDivision=9;
		m_abANMLResBack=9;
		m_abBLDGResBack=9;
		m_abCHTRResBack=9;
		m_abSHIPResBack=9;
		m_abVHCLResBack=9;
		m_aiTacticalPauses=8;
		m_iCurrentPauseOwner=-1;
		m_bExternalUnpauseChecked=false;
		m_bPauseLimitChecked=false;
		m_bTrainingDummiesChecked=false;
		m_bAllowThrowChecked=false;
		m_bUseOldSpiritsChecked=false;
		m_bGlobalReanimChecked=false;
		m_bDisableSpiritsChecked=false;
		m_bDisableBurningChecked=false;
		m_bDisableArtifactReleaseChecked=false;
		m_bDisableBerserkingChecked=false;
		m_bExcludeBuildUpChecked=false;
		m_bAttackInFOWChecked=false;
		m_bTechtreeStealChecked=false;
		m_bMultiTribeChecked=false;
		m_bOldDisembarkChecked=false;
		m_bAuraSharingChecked=false;
		m_bDivideSkullsChecked=false;
		m_bObserverChatChecked=false;
		m_bNoHumpWalkingChecked=false;
		m_bRemoveTitansChecked=false;
		m_bRemoveTradingChecked=false;
		m_bInfantryWarChecked=false;
		m_bDeliveryUnboundChecked=false;
		m_bGeneralAdvancementChecked=false;
		m_bAllyBuildupChecked=false;
		m_bDominationContinueChecked=false;
		m_bAlienCommandsChecked=false;
		CMirageSrvMgr.ms_pxPoolMixer=null;
		var CConfig xConf;
		ms_fHQTimer=xConf.GetSetF("Server/GameplayOptions/HQTimer",5.0f);
		ms_fWGTimer=xConf.GetSetF("Server/GameplayOptions/WarpGateTimer",10.0f);
		ms_fDFTimer=Math.Clamp(xConf.GetSetF("Server/GameplayOptions/DominationUpDownTimer",10.0f),1.0,30.0);
		m_bDominationUpDownTimerChecked=false;
		UpdateMapName();
		return true;
	endproc;
	
	constructor()
		var ^CPropDB pxSupplies=new CPropDB;
		if(pxSupplies^.Load(CSrvWrap.GetUrsRelPath()+"/Data/Base/Scripts/Server/settings/unit_supplies.txt"))then
			m_pxSupply=^((pxSupplies^).GetRoot());
		else
			m_pxSupply=null;
		endif;
		var ^CPropDB pxDieAck=new CPropDB;
		if(pxDieAck^.Load(CSrvWrap.GetUrsRelPath()+"/Data/Base/Scripts/Server/settings/die_acks.txt"))then
			m_pxDieAck=^((pxDieAck^).GetRoot());
		else
			m_pxDieAck=null;
		endif;
		var ^CPropDB pxBuildUp=new CPropDB;
		if(pxBuildUp^.Load(CSrvWrap.GetUrsRelPath()+"/Data/Base/Scripts/Server/settings/custom_buildups.txt"))then
			m_pxBuildUp=^((pxBuildUp^).GetRoot());
		else
			m_pxBuildUp=null;
		endif;
		var ^CPropDB pxCustomMapStuff=new CPropDB;
		if(pxCustomMapStuff^.Load(CSrvWrap.GetUrsRelPath()+"/Data/Base/Scripts/Server/settings/custom_maps/custom_level_data.txt"))then
			m_pxCustomMapStuff=^((pxCustomMapStuff^).GetRoot());
		else
			m_pxCustomMapStuff=null;
		endif;
		var ^CPropDB pxCodeName=new CPropDB;
		var ^CPropDB.CNode pxClassCodes;
		if(pxCodeName^.Load(CSrvWrap.GetUrsRelPath()+"/Data/Base/Scripts/Server/settings/class_codes.txt"))then
			pxClassCodes=^((pxCodeName^).GetRoot());
			if(pxClassCodes!=null)then
				m_pxCodeFromClass=pxClassCodes^.Get("class_to_code");
				m_pxClassFromCode=pxClassCodes^.Get("code_to_class");
			endif;
		else
			m_pxClassFromCode=null;
			m_pxCodeFromClass=null;
		endif;
		m_bUseSupplyChecked=false;
		m_bShowResourcesInFOWChecked=false;
		m_bHeroPoolChecked=false;
		m_bResourcesUnlimitedChecked=false;
		m_bBuildingCancellationChecked=false;
		m_bNoHQTimerChecked=false;
		m_bWarpInvisibleChecked=false;
		m_bPortalsChecked=false;
		m_bNestRespawnChecked=false;
		m_bTransportHealingChecked=false;
		m_bManaEnabledChecked=false;
		m_bUnitResourcesChecked=false;
		m_bBuildingBurndownChecked=false;
		m_bUseFinishingMovesChecked=false;
		m_bAnimalsVisInFOWChecked=false;
		m_bDiploLockedChecked=false;
		m_bEndscreen=false;
		m_bMaxDefChecked=false;
		m_bFreeSpecialsChecked=false;
		m_bBonusSkullsChecked=false;
		m_bEpochSixChecked=false;
		m_bNoWGTimerChecked=false;
		m_bTitanSlotsChecked=false;
		m_bHeroGratisChecked=false;
		m_bFlyingEnabledChecked=false;
		m_bDwnLvlSwitchChecked=false;
		m_bTreasureSharingChecked=false;
		m_bFruitsRemovementChecked=false;
		m_bEarlyTransportChecked=false;
		m_bPhantomModeChecked=false;
		m_bRandomRoles=false;
		m_bSeerPlayer=false;
		m_bRevelation=false;
		m_bBloodBrothers=false;
		m_bSoulKeepers=false;
		m_bPopulationBonus=false;
		m_iConquerors=0;
		m_iPaladins=0;
		m_iDefenders=0;
		m_bSandGlassChecked=false;
		m_iSandGlass=0;
		m_bBldgMaxCapacityChecked=false;
		m_bSpeedUpChecked=false;
		m_asNames=0;
		m_abRepairNoCost=8;
		m_abBoomingEconomy=8;
		m_abResetRallyPoint=8;
		m_abContinueRepair=9;
		m_abNeutralToWildAnimals=9;
		m_abGodMode=9;
		ms_abSkipAtDivision=9;
		m_abANMLResBack=9;
		m_abBLDGResBack=9;
		m_abCHTRResBack=9;
		m_abSHIPResBack=9;
		m_abVHCLResBack=9;
		m_aiTacticalPauses=8;
		m_iCurrentPauseOwner=-1;
		m_bPaused=false;
		m_bAllowAttackOwnStuff=false;
		m_bExternalUnpauseChecked=false;
		m_bPauseLimitChecked=false;
		m_bTrainingDummiesChecked=false;
		m_bAllowThrowChecked=false;
		m_bUseOldSpiritsChecked=false;
		m_bGlobalReanimChecked=false;
		m_bDisableSpiritsChecked=false;
		m_bDisableBurningChecked=false;
		m_bDisableArtifactReleaseChecked=false;
		m_bDisableBerserkingChecked=false;
		m_bExcludeBuildUpChecked=false;
		m_bAttackInFOWChecked=false;
		m_bTechtreeStealChecked=false;
		m_bMultiTribeChecked=false;
		m_bOldDisembarkChecked=false;
		m_bAuraSharingChecked=false;
		m_bDivideSkullsChecked=false;
		m_bObserverChatChecked=false;
		m_bNoHumpWalkingChecked=false;
		m_bRemoveTitansChecked=false;
		m_bRemoveTradingChecked=false;
		m_bInfantryWarChecked=false;
		m_bDeliveryUnboundChecked=false;
		m_bGeneralAdvancementChecked=false;
		m_bAllyBuildupChecked=false;
		m_bDominationContinueChecked=false;
		m_bAlienCommandsChecked=false;
		var CConfig xConf;
		ms_fHQTimer=xConf.GetSetF("Server/GameplayOptions/HQTimer",5.0f);
		ms_fWGTimer=xConf.GetSetF("Server/GameplayOptions/WarpGateTimer",10.0f);
		ms_fDFTimer=Math.Clamp(xConf.GetSetF("Server/GameplayOptions/DominationUpDownTimer",10.0f),1.0,30.0);
		m_bDominationUpDownTimerChecked=false;
		CMirageSrvMgr.ms_pxPoolMixer=null;
	endconstructor;
	
	destructor()
		m_abRepairNoCost=0;
		m_abBoomingEconomy=0;
		m_abResetRallyPoint=0;
		m_abContinueRepair=0;
		m_abNeutralToWildAnimals=0;
		m_abGodMode=0;
		ms_abSkipAtDivision=0;
		m_abANMLResBack=0;
		m_abBLDGResBack=0;
		m_abCHTRResBack=0;
		m_abSHIPResBack=0;
		m_abVHCLResBack=0;
		m_aiTacticalPauses=0;
		m_iCurrentPauseOwner=-1;
		m_bPaused=false;
		while(m_axNests.NumEntries()>0)do
			m_axNests.DeleteEntry(0);
		endwhile;
		while(m_axResources.NumEntries()>0)do
			m_axResources.DeleteEntry(0);
		endwhile;
		while(m_axIdiObjects.NumEntries()>0)do
			m_axIdiObjects.DeleteEntry(0);
		endwhile;
		while(m_axGameObjects.NumEntries()>0)do
			m_axGameObjects.DeleteEntry(0);
		endwhile;
	enddestructor;
	
	export proc bool GetRepairNoCost(int p_iPlayer)
		if(p_iPlayer<0||p_iPlayer>7)then return false; endif;
		return m_abRepairNoCost[p_iPlayer];
	endproc;
	
	export proc void SetRepairNoCost(int p_iPlayer, bool p_bEnable)
		if(p_iPlayer<0||p_iPlayer>7)then return; endif;
		m_abRepairNoCost[p_iPlayer]=p_bEnable;
	endproc;
	
	export proc bool GetBoomingEconomy(int p_iPlayer)
		if(p_iPlayer<0||p_iPlayer>7)then return false; endif;
		return m_abBoomingEconomy[p_iPlayer];
	endproc;
	
	export proc void SetBoomingEconomy(int p_iPlayer, bool p_bEnable)
		if(p_iPlayer<0||p_iPlayer>7)then return; endif;
		m_abBoomingEconomy[p_iPlayer]=p_bEnable;
	endproc;
	
	export proc bool GetResetRallyPoint(int p_iPlayer)
		if(p_iPlayer<0||p_iPlayer>7)then return false; endif;
		return m_abResetRallyPoint[p_iPlayer];
	endproc;
	
	export proc void SetResetRallyPoint(int p_iPlayer, bool p_bEnable)
		if(p_iPlayer<0||p_iPlayer>7)then return; endif;
		m_abResetRallyPoint[p_iPlayer]=p_bEnable;
	endproc;
	
	export proc bool GetGodMode(int p_iPlayer)
		if(p_iPlayer<-1||p_iPlayer>7)then return false; endif;
		return m_abGodMode[p_iPlayer+1];
	endproc;
	
	export proc void SetGodMode(int p_iPlayer, bool p_bEnable)
		if(p_iPlayer<-1||p_iPlayer>7)then return; endif;
		m_abGodMode[p_iPlayer+1]=p_bEnable;
	endproc;
	
	export proc bool GetContinueRepair(int p_iPlayer)
		if(p_iPlayer<-1||p_iPlayer>7)then return false; endif;
		return m_abContinueRepair[p_iPlayer+1];
	endproc;
	
	export proc void SetContinueRepair(int p_iPlayer, bool p_bEnable)
		if(p_iPlayer<-1||p_iPlayer>7)then return; endif;
		m_abContinueRepair[p_iPlayer+1]=p_bEnable;
	endproc;
	
	export proc bool GetNeutralToWildAnimals(int p_iPlayer)
		if(p_iPlayer<-1||p_iPlayer>7)then return false; endif;
		return m_abNeutralToWildAnimals[p_iPlayer+1];
	endproc;
	
	export proc void SetNeutralToWildAnimals(int p_iPlayer, bool p_bEnable)
		if(p_iPlayer<-1||p_iPlayer>7)then return; endif;
		m_abNeutralToWildAnimals[p_iPlayer+1]=p_bEnable;
	endproc;
	
	export proc void ToggleGodMode(int p_iPlayer, ref bool p_rbOn)
		if(p_iPlayer<-1||p_iPlayer>7)then return; endif;
		p_rbOn=m_abGodMode[p_iPlayer+1]=!m_abGodMode[p_iPlayer+1];
	endproc;
	
	export proc void UpdateTacticalPauses(int p_iID, int p_iUsed)
		if(p_iID<0||p_iID>=m_aiTacticalPauses.NumEntries())then return; endif;
		m_aiTacticalPauses[p_iID]=p_iUsed;
	endproc;
	
	export proc bool CanTacticalPause(int p_iID, ref bool p_rbUnlimited, ref int p_riRemaining)
		if(p_iID<0||p_iID>=m_aiTacticalPauses.NumEntries())then return false; endif;
		if(PauseLimit()==-1)then p_rbUnlimited=true; return true; endif;
		var int iAvailable = PauseLimit()-m_aiTacticalPauses[p_iID];
		var bool bReturn = iAvailable>0;
		if(bReturn)then
			m_aiTacticalPauses[p_iID]+=1;
			p_riRemaining=iAvailable-1;
		endif;
		return bReturn;
	endproc;
	
	export proc bool CanUnpause(int p_iID, ref bool p_rbUnlimited, ref int p_riRemaining)
		if(p_iID<0||p_iID>=m_aiTacticalPauses.NumEntries())then return false; endif;
		if(PauseLimit()==-1)then p_rbUnlimited=true; return true; endif;
		var int iAvailable = PauseLimit()-m_aiTacticalPauses[p_iID];
		var bool bReturn = iAvailable>0;
		if(bReturn)then
			m_aiTacticalPauses[p_iID]+=1;
			p_riRemaining=iAvailable-1;
		endif;
		return bReturn;
	endproc;
	
	export proc void ToggleTacticalPause(int p_iID, string p_sName, ref int p_riPauses)
		if(p_iID<0||p_iID>=m_aiTacticalPauses.NumEntries())then return; endif;
		if(PauseLimit()==0)then
			CFeedback.Print(p_iID, CFeedback.SYSTEM, "_MIRAGE_NT_TacticalPauseNotAllowed");
			return;
		endif;
		if(m_bPaused&&p_iID!=m_iCurrentPauseOwner&&!ExternalUnpause())then
			CFeedback.Print(p_iID, CFeedback.SYSTEM, "_MIRAGE_NT_UnpauseNotAllowed");
			return;
		endif;
		var bool bUnlimited=false;
		var int iRemain;
		var int i, iC = 8;
		if(!m_bPaused)then
			if(CanTacticalPause(p_iID,bUnlimited,iRemain))then
				var string sEvent="Paused\t"+p_iID.ToString()+"\t"+p_sName;
				p_riPauses+=1;
				CTimeMgr.Get().Stop();
				m_iCurrentPauseOwner=p_iID;
				m_bPaused=true;
//				CSrvWrap.SendGenericEvtToPlayer(p_iID, "UPStart");
				CFeedback.Print(CFeedback.ALL, CFeedback.SYSTEM, "_MIRAGE_NT_TacticalPauseByPlayer\t"+p_sName);
				if(!bUnlimited)then
					CFeedback.Print(p_iID, CFeedback.SYSTEM, "_NT_SpeedTacticalPausesLeft\t"+iRemain.ToString());
				endif;
				for(i=0)cond(i<iC)iter(i++)do
					CSrvWrap.SendGenericEvtToPlayer(i, sEvent);
				endfor;
			else
				CFeedback.Print(p_iID, CFeedback.SYSTEM, "_NT_SpeedTacticalFailNoPausesLeft");
			endif;
		else
			if(p_iID!=m_iCurrentPauseOwner)then
				if(CanUnpause(p_iID,bUnlimited,iRemain))then
					p_riPauses+=1;
					if(!bUnlimited)then
						CFeedback.Print(p_iID, CFeedback.SYSTEM, "_NT_SpeedTacticalPausesLeft\t"+iRemain.ToString());
					endif;
				else
					CFeedback.Print(p_iID, CFeedback.SYSTEM, "_MIRAGE_NT_UnpauseNotPossible");
				endif;
			endif;
			var string sEvent="Unpaused\t"+p_iID.ToString()+"\t"+p_sName;
			CTimeMgr.Get().Start();
			m_iCurrentPauseOwner=-1;
			m_bPaused=false;
			CFeedback.Print(CFeedback.ALL, CFeedback.SYSTEM, "_MIRAGE_NT_UnpauseByPlayer\t"+p_sName);
			for(i=0)cond(i<iC)iter(i++)do
				CSrvWrap.SendGenericEvtToPlayer(i, sEvent);
			endfor;
		endif;
	endproc;
	
	export proc bool ExternalUnpause()
		if(!m_bExternalUnpauseChecked)then
			m_bExternalUnpause=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iExternalUnpause=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxExternalUnpause=^(pxCSNode^.Get("ExternalUnpause"));
			if(pxExternalUnpause==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bExternalUnpause=xConf.GetSetB("Server/GameplayOptions/ExternalUnpause",false);
					if(m_bExternalUnpause)then
						iExternalUnpause=1;
					endif;
				else
					iExternalUnpause=pxGame^.GetAttribInt("ExternalUnpause");
					m_bExternalUnpause=iExternalUnpause==1;
				endif;
				pxExternalUnpause=^(pxCSNode^.AddValue("ExternalUnpause",iExternalUnpause));
			else
				iExternalUnpause=pxCSNode^.GetValueI("ExternalUnpause");
				m_bExternalUnpause=iExternalUnpause==1;
				m_bExternalUnpauseChecked=true;
			endif;
			return m_bExternalUnpause;
		else
			return m_bExternalUnpause;
		endif;
	endproc;
	
	export proc int PauseLimit()
		if(!m_bPauseLimitChecked)then
			m_iPauseLimit=-1;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return -1; endif;
			if(pxGame^.IsLevelEd())then return -1; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return -1; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return -1; endif;
			if(!pxLevelInfo^.IsMultiplayer())then
				m_iPauseLimit=-1;
				m_bPauseLimitChecked=true;
				return -1;
			endif;
			var int iPauseLimit=-1;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return -1; endif;
			var ^CPropDB.CNode pxPauseLimit=^(pxCSNode^.Get("PauseLimit"));
			if(pxPauseLimit==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_iPauseLimit=xConf.GetSetI("Server/GameplayOptions/PauseLimit",3);
				else
					m_iPauseLimit=pxGame^.GetAttribInt("PauseLimit");
				endif;
				pxPauseLimit=^(pxCSNode^.AddValue("PauseLimit",m_iPauseLimit));
			else
				m_iPauseLimit=pxCSNode^.GetValueI("PauseLimit");
				m_bPauseLimitChecked=true;
			endif;
			return m_iPauseLimit;
		else
			return m_iPauseLimit;
		endif;
	endproc;
	
	export proc int GetSupply(string p_sCllsNm)
		if(m_pxSupply==null)then return 0; endif;
		var int iSuppCount=m_pxSupply^.GetValueI(p_sCllsNm, 0);
		return iSuppCount;
	endproc;
	
	export proc int GetDieAck(string p_sClass, ref int p_riUISex)
		if(m_pxDieAck==null)then return -1; endif;
		var int iIndex=m_pxDieAck^.Find("voice_"+p_sClass+"_die");
		p_riUISex=m_pxDieAck^.Find("ui_"+p_sClass+"_die");
		return iIndex;
	endproc;
	
	export proc bool UseSupply()
		if(!m_bUseSupplyChecked)then
			m_bUseSupply=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iUseSupply=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
//			var ^CPropDB.CNode pxCSNode=^((pxGenericDB^)["ClientSettings"]);
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxUseSupply=^(pxCSNode^.Get("UseSupply"));
			if(pxUseSupply==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bUseSupply=xConf.GetSetB("Server/GameplayOptions/UseSupply",false);
					//m_bUseSupply=xConf.GetSetB("Server/GameplayOptions/UseSupply",true);
					if(m_bUseSupply)then
						iUseSupply=1;
					endif;
				else
					iUseSupply=pxGame^.GetAttribInt("UseSupply");
					m_bUseSupply=iUseSupply==1;
				endif;
				pxUseSupply=^(pxCSNode^.AddValue("UseSupply",iUseSupply));
			else
				iUseSupply=pxCSNode^.GetValueI("UseSupply");
				m_bUseSupply=iUseSupply==1;
				m_bUseSupplyChecked=true;
			endif;
			return m_bUseSupply;
		else
			return m_bUseSupply;
		endif;
	endproc;
	
	export proc bool ShowResourcesInFOW()
		if(!m_bShowResourcesInFOWChecked)then
			m_bShowResourcesInFOW=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iShowResourcesInFOW=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
//			var ^CPropDB.CNode pxCSNode=^((pxGenericDB^)["ClientSettings"]);
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxShowResourcesInFOW=^(pxCSNode^.Get("ShowResourcesInFOW"));
			if(pxShowResourcesInFOW==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					//m_bShowResourcesInFOW=xConf.GetSetB("Server/GameplayOptions/ShowResourcesInFOW",false);
					m_bShowResourcesInFOW=xConf.GetSetB("Server/GameplayOptions/ShowResourcesInFOW",true);
					if(m_bShowResourcesInFOW)then
						iShowResourcesInFOW=1;
					endif;
				else
					iShowResourcesInFOW=pxGame^.GetAttribInt("ShowResourcesInFOW");
					m_bShowResourcesInFOW=iShowResourcesInFOW==1;
				endif;
				pxShowResourcesInFOW=^(pxCSNode^.AddValue("ShowResourcesInFOW",iShowResourcesInFOW));
			else
				iShowResourcesInFOW=pxCSNode^.GetValueI("ShowResourcesInFOW");
				m_bShowResourcesInFOW=iShowResourcesInFOW==1;
				m_bShowResourcesInFOWChecked=true;
			endif;
			return m_bShowResourcesInFOW;
		else
			return m_bShowResourcesInFOW;
		endif;
	endproc;
	
	export proc bool AnimalsVisInFOW()
		if(!m_bAnimalsVisInFOWChecked)then
			m_bAnimalsVisInFOW=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iAnimalsVisInFOW=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
//			var ^CPropDB.CNode pxCSNode=^((pxGenericDB^)["ClientSettings"]);
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxAnimalsVisInFOW=^(pxCSNode^.Get("AnimalsVisInFOW"));
			if(pxAnimalsVisInFOW==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bAnimalsVisInFOW=xConf.GetSetB("Server/GameplayOptions/AnimalsVisInFOW",false);
	//				m_bAnimalsVisInFOW=xConf.GetSetB("Server/GameplayOptions/AnimalsVisibleInFOW",true);
					if(m_bAnimalsVisInFOW)then
						iAnimalsVisInFOW=1;
					endif;
				else
					iAnimalsVisInFOW=pxGame^.GetAttribInt("AnimalsVisInFOW");
					m_bAnimalsVisInFOW=iAnimalsVisInFOW==1;
				endif;
				pxAnimalsVisInFOW=^(pxCSNode^.AddValue("AnimalsVisInFOW",iAnimalsVisInFOW));
			else
				iAnimalsVisInFOW=pxCSNode^.GetValueI("AnimalsVisInFOW");
				m_bAnimalsVisInFOW=iAnimalsVisInFOW==1;
				m_bAnimalsVisInFOWChecked=true;
			endif;
			return m_bAnimalsVisInFOW;
		else
			return m_bAnimalsVisInFOW;
		endif;
	endproc;
	
	export proc bool TimerInitiation()
		// Henry: initing game timer
		var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
		if(pxGame==null)then return false; endif;
		if(pxGame^.IsLevelEd())then return false; endif;
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel==null)then return false; endif;
		var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
		if(pxLevelInfo==null)then return false; endif;
		var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
		var ^CPropDB.CNode pxBaseNode=^((pxGenericDB^)["Base"]);
		if(pxBaseNode==null)then return false; endif;
		var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
		if(pxCSNode==null)then return false; endif;
		var int iInit=1;
		var ^CPropDB.CNode pxTimerIniated=^(pxCSNode^.Get("TimerIniated"));
		if(!pxLevelInfo^.IsSaveGame())then
			if(pxTimerIniated==null)then
				pxBaseNode^.SetValue("PlayedTime",0.0);
			endif;
		endif;
		if(pxTimerIniated==null)then
			pxTimerIniated=^(pxCSNode^.AddValue("TimerIniated",iInit));
		endif;
		return true;
	endproc;
	
	export proc real GetMaxDef()
		if(!m_bMaxDefChecked)then
			m_bMaxDefChecked=MaxDefSet();
		endif;
		return m_fMaxDef;
	endproc;
	
	export proc bool MaxDefSet()
		m_fMaxDef=0.99f;
		var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
		if(pxGame==null)then return false; endif;
		if(pxGame^.IsLevelEd())then return false; endif;
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel==null)then return false; endif;
		var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
		if(pxLevelInfo==null)then return false; endif;
		var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
		var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
		if(pxCSNode==null)then return false; endif;
		var ^CPropDB.CNode pxTotalDefAllowed=^(pxCSNode^.Get("TotalDefAllowed"));
		var int iAllowed=0;
		if(pxTotalDefAllowed==null)then
			var bool bTotalDefAllowed;
			if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
				var CConfig xConf;
				bTotalDefAllowed=xConf.GetSetB("Server/GameplayOptions/PerfectArmor",false);
			else
				bTotalDefAllowed=pxGame^.GetAttribInt("PerfectArmor")==1;
			endif;
			if(bTotalDefAllowed)then
				iAllowed=1;
				m_fMaxDef=1.0f;
			endif;
			pxTotalDefAllowed=^(pxCSNode^.AddValue("TotalDefAllowed",iAllowed));
		else
			iAllowed=pxCSNode^.GetValueI("TotalDefAllowed");
			if(iAllowed==1)then
				m_fMaxDef=1.0f;
			endif;
		endif;
		return true;
	endproc;
	
	export proc bool CorpseDmgAllowed()
		CResource.ms_bCORPSEDMG=false;
		var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
		if(pxGame==null)then return false; endif;
		if(pxGame^.IsLevelEd())then return false; endif;
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel==null)then return false; endif;
		var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
		if(pxLevelInfo==null)then return false; endif;
		var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
		var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
		if(pxCSNode==null)then return false; endif;
		var ^CPropDB.CNode pxCorpseDmgAllowed=^(pxCSNode^.Get("CorpseDmgAllowed"));
		var int iAllowed=0;
		if(pxCorpseDmgAllowed==null)then
			var bool bCorpseDmgAllowed;
			if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
				var CConfig xConf;
				bCorpseDmgAllowed=xConf.GetSetB("Server/GameplayOptions/CorpseDamage",false);
				if(bCorpseDmgAllowed)then
					iAllowed=1;
				endif;
			else
				iAllowed=pxGame^.GetAttribInt("CorpseDamage");
				bCorpseDmgAllowed=iAllowed==1;
			endif;
			CResource.ms_bCORPSEDMG=bCorpseDmgAllowed;
			pxCorpseDmgAllowed=^(pxCSNode^.AddValue("CorpseDmgAllowed",iAllowed));
		else
			iAllowed=pxCSNode^.GetValueI("CorpseDmgAllowed");
			CResource.ms_bCORPSEDMG=iAllowed==1;
		endif;
		return true;
	endproc;
	
	export proc bool DiploLocked()
		if(!m_bDiploLockedChecked)then
			m_bDiploLocked=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			if(!pxLevelInfo^.IsMultiplayer())then
				m_bDiploLocked=false;
				m_bDiploLockedChecked=true;
				return false;
			endif;
			var int iDiploLocked=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
//			var ^CPropDB.CNode pxCSNode=^((pxGenericDB^)["ClientSettings"]);
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxDiploLocked=^(pxCSNode^.Get("DiploLocked"));
			if(pxDiploLocked==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bDiploLocked=xConf.GetSetB("Server/GameplayOptions/DiploLocked",false);
	//				m_bDiploLocked=xConf.GetSetB("Server/GameplayOptions/DiploLocked",true);
					if(m_bDiploLocked)then
						iDiploLocked=1;
					endif;
				else
					iDiploLocked=pxGame^.GetAttribInt("DiplomacyLocked");
					m_bDiploLocked=iDiploLocked==1;
				endif;
//				if(CMirageSrvMgr.GetMapName(pxLevelInfo)=="_CU_MP_6_CRASH_RPG")then
//					m_bDiploLocked=true;
//					iDiploLocked=1;
//				endif;
				pxDiploLocked=^(pxCSNode^.AddValue("DiploLocked",iDiploLocked));
			else
				iDiploLocked=pxCSNode^.GetValueI("DiploLocked");
				m_bDiploLocked=iDiploLocked==1;
				m_bDiploLockedChecked=true;
			endif;
			return m_bDiploLocked;
		else
			return m_bDiploLocked;
		endif;
	endproc;
	
	export proc void UnlockDiplo()
		m_bDiploLocked=false;
	endproc;
	
	export proc void Endscreen()
		m_bEndscreen=true;
	endproc;
	
	export proc bool AfterEndscreen()
		return m_bEndscreen;
	endproc;
	
	export static proc bool IsHost(int p_iID)
		if(p_iID<0||p_iID>7)then return false; endif;
		var ^CLevelInfoHost pxLevelInfo = CSrvWrap.GetLevelInfo(false);
		if(pxLevelInfo==null)then
			return false;
		endif;
		var CPlayerSlotID xIter;
		xIter=CPlayerSlotID.First();
		if(xIter.IsValid())then
			var ^CLevelInfo.CPlayerSlot pxPlayerSlot=^(pxLevelInfo^.GetPlayerSlot(xIter));
			if(pxPlayerSlot!=null)then
				var int iSlotOwner=pxPlayerSlot^.GetOwner();
//				var int iSlotOwner=pxPlayerSlot^.GetHeadQuater();
				if(iSlotOwner==p_iID)then
					return true;
				endif;
			endif;
		endif;
		return false;
	endproc;
	
	export proc bool HeroPool()
		if(!m_bHeroPoolChecked)then
			m_bHeroPool=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			if(CMirageSrvMgr.IsCustomMap(pxLevelInfo)||!pxLevelInfo^.IsMultiplayer())then
				m_bHeroPool=false;
				m_bHeroPoolChecked=true;
				return false;
			endif;
			var int iHeroPool=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxHeroPool=^(pxCSNode^.Get("HeroPool"));
			if(pxHeroPool==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bHeroPool=xConf.GetSetB("Server/GameplayOptions/HeroPool",false);
					if(m_bHeroPool)then
						iHeroPool=1;
					endif;
				else
					iHeroPool=pxGame^.GetAttribInt("HeroPool");
					m_bHeroPool=iHeroPool==1;
				endif;
				pxHeroPool=^(pxCSNode^.AddValue("HeroPool",iHeroPool));
			else
				iHeroPool=pxCSNode^.GetValueI("HeroPool");
				m_bHeroPool=iHeroPool==1;
				m_bHeroPoolChecked=true;
			endif;
			return m_bHeroPool;
		else
			return m_bHeroPool;
		endif;
	endproc;
	
	export proc bool ResourcesUnlimited()
		if(!m_bResourcesUnlimitedChecked)then
			m_bResourcesUnlimited=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iResourcesUnlimited=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
//			var ^CPropDB.CNode pxCSNode=^((pxGenericDB^)["ClientSettings"]);
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxResourcesUnlimited=^(pxCSNode^.Get("ResourcesUnlimited"));
			if(pxResourcesUnlimited==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bResourcesUnlimited=xConf.GetSetB("Server/GameplayOptions/ResourcesUnlimited",false);
					//m_bResourcesUnlimited=xConf.GetSetB("Server/GameplayOptions/ResourcesUnlimited",true);
					if(m_bResourcesUnlimited)then
						iResourcesUnlimited=1;
					endif;
				else
					iResourcesUnlimited=pxGame^.GetAttribInt("ResourcesUnlimited");
					m_bResourcesUnlimited=iResourcesUnlimited==1;
				endif;
				pxResourcesUnlimited=^(pxCSNode^.AddValue("ResourcesUnlimited",iResourcesUnlimited));
			else
				iResourcesUnlimited=pxCSNode^.GetValueI("ResourcesUnlimited");
				m_bResourcesUnlimited=iResourcesUnlimited==1;
				m_bResourcesUnlimitedChecked=true;
			endif;
			return m_bResourcesUnlimited;
		else
			return m_bResourcesUnlimited;
		endif;
	endproc;
	
	export proc bool BuildingCancellation()
		if(!m_bBuildingCancellationChecked)then
			m_bBuildingCancellation=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iBuildingCancellation=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
//			var ^CPropDB.CNode pxCSNode=^((pxGenericDB^)["ClientSettings"]);
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxBuildingCancellation=^(pxCSNode^.Get("BuildingCancellation"));
			if(pxBuildingCancellation==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bBuildingCancellation=xConf.GetSetB("Server/GameplayOptions/BuildingCancellation",false);
					//m_bBuildingCancellation=xConf.GetSetB("Server/GameplayOptions/BuildingCancellation",true);
					if(m_bBuildingCancellation)then
						iBuildingCancellation=1;
					endif;
				else
					iBuildingCancellation=pxGame^.GetAttribInt("BuildingCancellation");
					m_bBuildingCancellation=iBuildingCancellation==1;
				endif;
				pxBuildingCancellation=^(pxCSNode^.AddValue("BuildingCancellation",iBuildingCancellation));
			else
				iBuildingCancellation=pxCSNode^.GetValueI("BuildingCancellation");
				m_bBuildingCancellation=iBuildingCancellation==1;
				m_bBuildingCancellationChecked=true;
			endif;
			return m_bBuildingCancellation;
		else
			return m_bBuildingCancellation;
		endif;
	endproc;
	
	export proc bool NoHQTimer()
		if(!m_bNoHQTimerChecked)then
			m_bNoHQTimer=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			if(!pxLevelInfo^.IsMultiplayer())then
				m_bNoHQTimer=false;
				m_bNoHQTimerChecked=true;
				return false;
			endif;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxNoHQTimer=^(pxCSNode^.Get("NoHQTimer"));
			if(pxNoHQTimer==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					ms_fHQTimer=xConf.GetSetF("Server/GameplayOptions/HQTimer",5.0f);
					m_bNoHQTimer=ms_fHQTimer<=-1.0f;
				else
					ms_fHQTimer=pxGame^.GetAttrib("HQTimer").ToReal();
					m_bNoHQTimer=ms_fHQTimer<=-1.0f;
				endif;
				pxNoHQTimer=^(pxCSNode^.AddValue("NoHQTimer",ms_fHQTimer));
			else
				ms_fHQTimer=pxCSNode^.GetValueR("NoHQTimer");
				m_bNoHQTimer=ms_fHQTimer<=-1.0f;
				m_bNoHQTimerChecked=true;
			endif;
			return m_bNoHQTimer;
		else
			return m_bNoHQTimer;
		endif;
	endproc;
	
	export proc bool WarpInvisible()
		if(!m_bWarpInvisibleChecked)then
			m_bWarpInvisible=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iWarpInvisible=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
//			var ^CPropDB.CNode pxCSNode=^((pxGenericDB^)["ClientSettings"]);
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxWarpInvisible=^(pxCSNode^.Get("WarpInvisible"));
			if(pxWarpInvisible==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bWarpInvisible=xConf.GetSetB("Server/GameplayOptions/WarpInvisible",false);
					//m_bWarpInvisible=xConf.GetSetB("Server/GameplayOptions/WarpInvisible",true);
					if(m_bWarpInvisible)then
						iWarpInvisible=1;
					endif;
				else
					iWarpInvisible=pxGame^.GetAttribInt("WarpInvisible");
					m_bWarpInvisible=iWarpInvisible==1;
				endif;
				pxWarpInvisible=^(pxCSNode^.AddValue("WarpInvisible",iWarpInvisible));
			else
				iWarpInvisible=pxCSNode^.GetValueI("WarpInvisible");
				m_bWarpInvisible=iWarpInvisible==1;
				m_bWarpInvisibleChecked=true;
			endif;
			return m_bWarpInvisible;
		else
			return m_bWarpInvisible;
		endif;
	endproc;
	
	export proc bool Portals()
		if(!m_bPortalsChecked)then
			m_bPortals=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iPortals=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
//			var ^CPropDB.CNode pxCSNode=^((pxGenericDB^)["ClientSettings"]);
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxPortals=^(pxCSNode^.Get("Portals"));
			if(pxPortals==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bPortals=xConf.GetSetB("Server/GameplayOptions/Portals",false);
					//m_bPortals=xConf.GetSetB("Server/GameplayOptions/Portals",true);
					if(m_bPortals)then
						iPortals=1;
					endif;
				else
					iPortals=pxGame^.GetAttribInt("Portals");
					m_bPortals=iPortals==1;
				endif;
				pxPortals=^(pxCSNode^.AddValue("Portals",iPortals));
			else
				iPortals=pxCSNode^.GetValueI("Portals");
				m_bPortals=iPortals==1;
				m_bPortalsChecked=true;
			endif;
			return m_bPortals;
		else
			return m_bPortals;
		endif;
	endproc;
	
	export proc bool NestRespawn()
		if(!m_bNestRespawnChecked)then
			m_bNestRespawn=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
//			if(!pxLevelInfo^.IsMultiplayer())then
//				m_bNestRespawn=false;
//				m_bNestRespawnChecked=true;
//				return false;
//			endif;
			var int iNestRespawn=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
//			var ^CPropDB.CNode pxCSNode=^((pxGenericDB^)["ClientSettings"]);
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxNestRespawn=^(pxCSNode^.Get("NestRespawn"));
			if(pxNestRespawn==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bNestRespawn=xConf.GetSetB("Server/GameplayOptions/NestRespawn",false);
					//m_bNestRespawn=xConf.GetSetB("Server/GameplayOptions/NestRespawn",true);
					if(m_bNestRespawn)then
						iNestRespawn=1;
					endif;
				else
					iNestRespawn=pxGame^.GetAttribInt("NestRespawn");
					m_bNestRespawn=iNestRespawn==1;
				endif;
				pxNestRespawn=^(pxCSNode^.AddValue("NestRespawn",iNestRespawn));
			else
				iNestRespawn=pxCSNode^.GetValueI("NestRespawn");
				m_bNestRespawn=iNestRespawn==1;
				m_bNestRespawnChecked=true;
			endif;
			return m_bNestRespawn;
		else
			return m_bNestRespawn;
		endif;
	endproc;
	
	export proc real GetTHF()
		if(!m_bTransportHealingChecked)then
			m_bTransportHealingChecked=TransportHealing();
		endif;
		return m_fTHF;
	endproc;
	
	export proc bool TransportHealing()
		if(!m_bTransportHealingChecked)then
			m_bTransportHealing=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iTransportHealing=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
//			var ^CPropDB.CNode pxCSNode=^((pxGenericDB^)["ClientSettings"]);
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxTransportHealing=^(pxCSNode^.Get("TransportHealing"));
			if(pxTransportHealing==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					iTransportHealing=xConf.GetSetI("Server/GameplayOptions/TransportHealing",60);
					m_bTransportHealing=iTransportHealing>0;
				else
					iTransportHealing=pxGame^.GetAttribInt("TransportHealing");
					m_bTransportHealing=iTransportHealing>0;
				endif;
				pxTransportHealing=^(pxCSNode^.AddValue("TransportHealing",iTransportHealing));
			else
				iTransportHealing=pxCSNode^.GetValueI("TransportHealing");
				m_bTransportHealing=iTransportHealing>0;
				m_bTransportHealingChecked=true;
			endif;
			m_fTHF=Math.Clamp(iTransportHealing.ToReal(),0.0,100.0)/100.0;
			return m_bTransportHealing;
		else
			return m_bTransportHealing;
		endif;
	endproc;
	
//	export proc bool ManaEnabled()
//		return true;
//	endproc;
	
	export proc bool ManaEnabled()
//		if(true)then return false; endif;
		if(!m_bManaEnabledChecked)then
			m_bManaEnabled=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iManaEnabled=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
//			var ^CPropDB.CNode pxCSNode=^((pxGenericDB^)["ClientSettings"]);
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxManaEnabled=^(pxCSNode^.Get("ManaEnabled"));
			if(pxManaEnabled==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bManaEnabled=xConf.GetSetB("Server/GameplayOptions/ManaEnabled",false);
					if(m_bManaEnabled)then
						iManaEnabled=1;
					endif;
				else
					iManaEnabled=pxGame^.GetAttribInt("ManaEnabled");
					m_bManaEnabled=iManaEnabled==1;
				endif;
				pxManaEnabled=^(pxCSNode^.AddValue("ManaEnabled",iManaEnabled));
			else
				iManaEnabled=pxCSNode^.GetValueI("ManaEnabled");
				m_bManaEnabled=iManaEnabled==1;
				m_bManaEnabledChecked=true;
			endif;
			return m_bManaEnabled;
		else
			return m_bManaEnabled;
		endif;
	endproc;
	
	export proc bool UnitResources()
		if(!m_bUnitResourcesChecked)then
			m_bUnitResources=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iUnitResources=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
//			var ^CPropDB.CNode pxCSNode=^((pxGenericDB^)["ClientSettings"]);
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxUnitResources=^(pxCSNode^.Get("UnitResources"));
			if(pxUnitResources==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bUnitResources=xConf.GetSetB("Server/GameplayOptions/UnitResources",false);
					//m_bUnitResources=xConf.GetSetB("Server/GameplayOptions/UnitResources",true);
					if(m_bUnitResources)then
						iUnitResources=1;
					endif;
				else
					iUnitResources=pxGame^.GetAttribInt("UnitResources");
					m_bUnitResources=iUnitResources==1;
				endif;
				pxUnitResources=^(pxCSNode^.AddValue("UnitResources",iUnitResources));
			else
				iUnitResources=pxCSNode^.GetValueI("UnitResources");
				m_bUnitResources=iUnitResources==1;
				m_bUnitResourcesChecked=true;
			endif;
			return m_bUnitResources;
		else
			return m_bUnitResources;
		endif;
	endproc;
	
	export proc bool BuildingBurndown()
		if(!m_bBuildingBurndownChecked)then
			m_bBuildingBurndown=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iBuildingBurndown=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
//			var ^CPropDB.CNode pxCSNode=^((pxGenericDB^)["ClientSettings"]);
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxBuildingBurndown=^(pxCSNode^.Get("BuildingBurndown"));
			if(pxBuildingBurndown==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bBuildingBurndown=xConf.GetSetB("Server/GameplayOptions/BuildingBurndown",false);
					//m_bBuildingBurndown=xConf.GetSetB("Server/GameplayOptions/BuildingBurndown",true);
					if(m_bBuildingBurndown)then
						iBuildingBurndown=1;
					endif;
				else
					iBuildingBurndown=pxGame^.GetAttribInt("BuildingBurndown");
					m_bBuildingBurndown=iBuildingBurndown==1;
				endif;
				pxBuildingBurndown=^(pxCSNode^.AddValue("BuildingBurndown",iBuildingBurndown));
			else
				iBuildingBurndown=pxCSNode^.GetValueI("BuildingBurndown");
				m_bBuildingBurndown=iBuildingBurndown==1;
				m_bBuildingBurndownChecked=true;
			endif;
			return m_bBuildingBurndown;
		else
			return m_bBuildingBurndown;
		endif;
	endproc;
	
	export proc bool UseFinishingMoves()
		if(!m_bUseFinishingMovesChecked)then
			m_bUseFinishingMoves=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iUseFinishingMoves=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
//			var ^CPropDB.CNode pxCSNode=^((pxGenericDB^)["ClientSettings"]);
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxUseFinishingMoves=^(pxCSNode^.Get("UseFM"));
			if(pxUseFinishingMoves==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					//m_bUseFinishingMoves=xConf.GetSetB("Server/GameplayOptions/UseFM",false);
					m_bUseFinishingMoves=xConf.GetSetB("Server/GameplayOptions/UseFM",true);
					if(m_bUseFinishingMoves)then
						iUseFinishingMoves=1;
					endif;
				else
					iUseFinishingMoves=pxGame^.GetAttribInt("UseFM");
					m_bUseFinishingMoves=iUseFinishingMoves==1;
				endif;
				pxUseFinishingMoves=^(pxCSNode^.AddValue("UseFM",iUseFinishingMoves));
			else
				iUseFinishingMoves=pxCSNode^.GetValueI("UseFM");
				m_bUseFinishingMoves=iUseFinishingMoves==1;
				m_bUseFinishingMovesChecked=true;
			endif;
			return m_bUseFinishingMoves;
		else
			return m_bUseFinishingMoves;
		endif;
	endproc;
	
	export proc bool FreeSpecials()
		if(!m_bFreeSpecialsChecked)then
			m_bFreeSpecials=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
//			if(!pxLevelInfo^.IsMultiplayer())then
//				m_bFreeSpecials=false;
//				m_bFreeSpecialsChecked=true;
//				return false;
//			endif;
			var int iFreeSpecials=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxFreeSpecials=^(pxCSNode^.Get("FreeSpecials"));
			if(pxFreeSpecials==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bFreeSpecials=xConf.GetSetB("Server/GameplayOptions/FreeSpecials",false);
					if(m_bFreeSpecials)then
						iFreeSpecials=1;
					endif;
				else
					iFreeSpecials=pxGame^.GetAttribInt("FreeSpecials");
					m_bFreeSpecials=iFreeSpecials==1;
				endif;
				pxFreeSpecials=^(pxCSNode^.AddValue("FreeSpecials",iFreeSpecials));
			else
				iFreeSpecials=pxCSNode^.GetValueI("FreeSpecials");
				m_bFreeSpecials=iFreeSpecials==1;
				m_bFreeSpecialsChecked=true;
			endif;
			return m_bFreeSpecials;
		else
			return m_bFreeSpecials;
		endif;
	endproc;
	
	export proc bool BonusSkulls()
		if(!m_bBonusSkullsChecked)then
			m_bBonusSkulls=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iBonusSkulls=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxBonusSkulls=^(pxCSNode^.Get("BonusSkulls"));
			if(pxBonusSkulls==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bBonusSkulls=xConf.GetSetB("Server/GameplayOptions/BonusSkulls",false);
					if(m_bBonusSkulls)then
						iBonusSkulls=1;
					endif;
				else
					iBonusSkulls=pxGame^.GetAttribInt("BonusSkulls");
					m_bBonusSkulls=iBonusSkulls==1;
				endif;
				pxBonusSkulls=^(pxCSNode^.AddValue("BonusSkulls",iBonusSkulls));
			else
				iBonusSkulls=pxCSNode^.GetValueI("BonusSkulls");
				m_bBonusSkulls=iBonusSkulls==1;
				m_bBonusSkullsChecked=true;
			endif;
			return m_bBonusSkulls;
		else
			return m_bBonusSkulls;
		endif;
	endproc;
	
	export proc bool EpochSix()
		if(!m_bEpochSixChecked)then
			m_bEpochSix=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iEpochSix=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxEpochSix=^(pxCSNode^.Get("EpochSix"));
			if(pxEpochSix==null)then
				var int iMaxEpoch;
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
//					m_bEpochSix=xConf.GetSetB("Server/GameplayOptions/EpochSix",false);
					iMaxEpoch=xConf.GetSetI("Server/GameplayOptions/MaxEpoch",5);
					m_bEpochSix=iMaxEpoch>=6;
					if(m_bEpochSix)then
						iEpochSix=1;
					endif;
				else
//					iEpochSix=pxGame^.GetAttribInt("EpochSix");
//					m_bEpochSix=iEpochSix==1;
					iMaxEpoch=pxGame^.GetAttribInt("MaxEpoch");
					m_bEpochSix=iMaxEpoch>=6;
					if(m_bEpochSix)then
						iEpochSix=1;
					else
						iEpochSix=0;
					endif;
				endif;
				pxEpochSix=^(pxCSNode^.AddValue("EpochSix",iEpochSix));
				pxEpochSix=^(pxCSNode^.AddValue("MaxEpoch",iMaxEpoch));
				m_bEpochSixChecked=true;
			else
				iEpochSix=pxCSNode^.GetValueI("EpochSix");
				m_bEpochSix=iEpochSix==1;
				m_bEpochSixChecked=true;
			endif;
			return m_bEpochSix;
		else
			return m_bEpochSix;
		endif;
	endproc;
	
	export proc bool NoWGTimer()
		if(!m_bNoWGTimerChecked)then
			m_bNoWGTimer=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			if(!pxLevelInfo^.IsMultiplayer())then
				m_bNoWGTimer=false;
				m_bNoWGTimerChecked=true;
				return false;
			endif;
			var int iNoWGTimer=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
//			var ^CPropDB.CNode pxCSNode=^((pxGenericDB^)["ClientSettings"]);
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxNoWGTimer=^(pxCSNode^.Get("NoWGTimer"));
			if(pxNoWGTimer==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					ms_fWGTimer=xConf.GetSetF("Server/GameplayOptions/WarpGateTimer",5.0f);
					m_bNoWGTimer=ms_fWGTimer<=0.0f;
					if(m_bNoWGTimer)then
						iNoWGTimer=1;
					endif;
				else
					ms_fWGTimer=pxGame^.GetAttrib("WarpGateTimer").ToReal();
					m_bNoWGTimer=ms_fWGTimer<=0.0f;
					if(m_bNoWGTimer)then
						iNoWGTimer=1;
					else
						iNoWGTimer=0;
					endif;
				endif;
				pxNoWGTimer=^(pxCSNode^.AddValue("NoWGTimer",ms_fWGTimer));
			else
				ms_fWGTimer=pxCSNode^.GetValueR("NoWGTimer");
				m_bNoWGTimer=ms_fWGTimer<=0.0f;
				m_bNoWGTimerChecked=true;
			endif;
			return m_bNoWGTimer;
		else
			return m_bNoWGTimer;
		endif;
	endproc;
	
	export proc bool TitanSlots()
		if(!m_bTitanSlotsChecked)then
			m_bTitanSlots=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iTitanSlots=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxTitanSlots=^(pxCSNode^.Get("TitanSlots"));
			if(pxTitanSlots==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bTitanSlots=xConf.GetSetB("Server/GameplayOptions/TitanSlots",false);
					if(m_bTitanSlots)then
						iTitanSlots=1;
					endif;
				else
					iTitanSlots=pxGame^.GetAttribInt("TitanSlots");
					m_bTitanSlots=iTitanSlots==1;
				endif;
				pxTitanSlots=^(pxCSNode^.AddValue("TitanSlots",iTitanSlots));
			else
				iTitanSlots=pxCSNode^.GetValueI("TitanSlots");
				m_bTitanSlots=iTitanSlots==1;
				m_bTitanSlotsChecked=true;
			endif;
			return m_bTitanSlots;
		else
			return m_bTitanSlots;
		endif;
	endproc;
	
	export proc bool HeroGratis()
		if(!m_bHeroGratisChecked)then
			m_bHeroGratis=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iHeroGratis=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxHeroGratis=^(pxCSNode^.Get("HeroGratis"));
			if(pxHeroGratis==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bHeroGratis=xConf.GetSetB("Server/GameplayOptions/HeroGratis",false);
					if(m_bHeroGratis)then
						iHeroGratis=1;
					endif;
				else
					iHeroGratis=pxGame^.GetAttribInt("HeroGratis");
					m_bHeroGratis=iHeroGratis==1;
				endif;
				pxHeroGratis=^(pxCSNode^.AddValue("HeroGratis",iHeroGratis));
			else
				iHeroGratis=pxCSNode^.GetValueI("HeroGratis");
				m_bHeroGratis=iHeroGratis==1;
				m_bHeroGratisChecked=true;
			endif;
			return m_bHeroGratis;
		else
			return m_bHeroGratis;
		endif;
	endproc;
	
	export proc bool FlyingEnabled()
		if(!m_bFlyingEnabledChecked)then
			m_bFlyingEnabled=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iFlyingEnabled=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxFlyingEnabled=^(pxCSNode^.Get("FlyingEnabled"));
			if(pxFlyingEnabled==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bFlyingEnabled=xConf.GetSetB("Server/GameplayOptions/FlyingEnabled",false);
					if(m_bFlyingEnabled)then
						iFlyingEnabled=1;
					endif;
				else
					iFlyingEnabled=pxGame^.GetAttribInt("FlyingEnabled");
					m_bFlyingEnabled=iFlyingEnabled==1;
				endif;
				pxFlyingEnabled=^(pxCSNode^.AddValue("FlyingEnabled",iFlyingEnabled));
			else
				iFlyingEnabled=pxCSNode^.GetValueI("FlyingEnabled");
				m_bFlyingEnabled=iFlyingEnabled==1;
				m_bFlyingEnabledChecked=true;
			endif;
			return m_bFlyingEnabled;
		else
			return m_bFlyingEnabled;
		endif;
	endproc;
	
	export proc int DwnLvlSwitch()
		if(!m_bDwnLvlSwitchChecked)then
			m_iDwnLvlSwitch=0;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return 0; endif;
			if(pxGame^.IsLevelEd())then return 0; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return 0; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return 0; endif;
			var int iDwnLvlSwitch=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return 0; endif;
			var ^CPropDB.CNode pxDwnLvlSwitch=^(pxCSNode^.Get("DwnLvlSwitch"));
			if(pxDwnLvlSwitch==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_iDwnLvlSwitch=xConf.GetSetI("Server/GameplayOptions/DwnLvlSwitch",0);
				else
					m_iDwnLvlSwitch=pxGame^.GetAttribInt("DwnLvlSwitch");
				endif;
				pxDwnLvlSwitch=^(pxCSNode^.AddValue("DwnLvlSwitch",m_iDwnLvlSwitch));
			else
				m_iDwnLvlSwitch=pxCSNode^.GetValueI("DwnLvlSwitch");
				m_bDwnLvlSwitchChecked=true;
			endif;
			return m_iDwnLvlSwitch;
		else
			return m_iDwnLvlSwitch;
		endif;
	endproc;
	
	export proc bool TreasureSharing()
		if(!m_bTreasureSharingChecked)then
			m_bTreasureSharing=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iTreasureSharing=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxTreasureSharing=^(pxCSNode^.Get("TreasureSharing"));
			if(pxTreasureSharing==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bTreasureSharing=xConf.GetSetB("Server/GameplayOptions/TreasureSharing",false);
					if(m_bTreasureSharing)then
						iTreasureSharing=1;
					endif;
				else
					iTreasureSharing=pxGame^.GetAttribInt("TreasureSharing");
					m_bTreasureSharing=iTreasureSharing==1;
				endif;
				pxTreasureSharing=^(pxCSNode^.AddValue("TreasureSharing",iTreasureSharing));
			else
				iTreasureSharing=pxCSNode^.GetValueI("TreasureSharing");
				m_bTreasureSharing=iTreasureSharing==1;
				m_bTreasureSharingChecked=true;
			endif;
			return m_bTreasureSharing;
		else
			return m_bTreasureSharing;
		endif;
	endproc;
	
	export proc bool FruitsRemovement()
		if(!m_bFruitsRemovementChecked)then
			m_bFruitsRemovement=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iFruitsRemovement=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxFruitsRemovement=^(pxCSNode^.Get("FruitsRemovement"));
			if(pxFruitsRemovement==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bFruitsRemovement=xConf.GetSetB("Server/GameplayOptions/FruitsRemovement",false);
					if(m_bFruitsRemovement)then
						iFruitsRemovement=1;
					endif;
				else
					iFruitsRemovement=pxGame^.GetAttribInt("FruitsRemovement");
					m_bFruitsRemovement=iFruitsRemovement==1;
				endif;
				pxFruitsRemovement=^(pxCSNode^.AddValue("FruitsRemovement",iFruitsRemovement));
			else
				iFruitsRemovement=pxCSNode^.GetValueI("FruitsRemovement");
				m_bFruitsRemovement=iFruitsRemovement==1;
				m_bFruitsRemovementChecked=true;
			endif;
			return m_bFruitsRemovement;
		else
			return m_bFruitsRemovement;
		endif;
	endproc;
	
	export proc bool EarlyTransport()
		if(!m_bEarlyTransportChecked)then
			m_bEarlyTransport=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iEarlyTransport=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxEarlyTransport=^(pxCSNode^.Get("EarlyTransport"));
			if(pxEarlyTransport==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bEarlyTransport=xConf.GetSetB("Server/GameplayOptions/EarlyTransport",true);
					if(m_bEarlyTransport)then
						iEarlyTransport=1;
					endif;
				else
					iEarlyTransport=pxGame^.GetAttribInt("EarlyTransport");
					m_bEarlyTransport=iEarlyTransport==1;
				endif;
				pxEarlyTransport=^(pxCSNode^.AddValue("EarlyTransport",iEarlyTransport));
			else
				iEarlyTransport=pxCSNode^.GetValueI("EarlyTransport");
				m_bEarlyTransport=iEarlyTransport==1;
				m_bEarlyTransportChecked=true;
			endif;
			return m_bEarlyTransport;
		else
			return m_bEarlyTransport;
		endif;
	endproc;
	
	export proc bool PhantomMode()
		if(!m_bPhantomModeChecked)then
			m_bPhantomMode=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iPhantomMode=0;
			var int iGameType=CSrvWrap.GetGame().GetType();
			if(pxLevelInfo^.IsSaveGame())then
				iGameType=pxLevelInfo^.GetAttribs().GetValueInt("SavedGameType");
//			else
//				pxLevelInfo^.GetAttribs().SetValue("SavedGameType",iGameType);
			endif;
			if(!pxLevelInfo^.IsMultiplayer()||iGameType!=0||DiploLocked())then
				m_bPhantomMode=false;
				m_bPhantomModeChecked=true;
				return false;
			endif;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxPhantomMode=^(pxCSNode^.Get("PhantomMode"));
			if(pxPhantomMode==null)then
				var int iDef, k, iK, iMid;
				var int iAll=pxLevelInfo^.GetNumPlayers();
				var int iRemain=iAll;
				iMid=iAll/2;
				if(iAll<3)then m_bPhantomModeChecked=true; m_bPhantomMode=false; return false; endif;
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bPhantomMode=xConf.GetSetB("Server/GameplayOptions/PhantomMode",false);
					if(m_bPhantomMode)then
						iPhantomMode=1;
					endif;
					m_bRandomRoles=xConf.GetSetB("Server/GameplayOptions/RandomRoles",false);
					m_bSeerPlayer=xConf.GetSetB("Server/GameplayOptions/SeerPlayer",false);
					k=1; iK=Math.Min(4,iMid); iDef=1;
					m_iConquerors=Math.Clamp(xConf.GetSetI("Server/GameplayOptions/ConquerorNumber",iDef),k,iK);
					iRemain-=m_iConquerors;
					k=0; iK=Math.Min(4,Math.Min(iMid,iRemain)); iDef=0;
					m_iPaladins=Math.Clamp(xConf.GetSetI("Server/GameplayOptions/PaladinNumber",iDef),k,iK);
					iRemain-=m_iPaladins;
					m_iDefenders=iRemain;
					m_bRevelation=xConf.GetSetB("Server/GameplayOptions/Revelation",false)&&(m_bRandomRoles||m_iConquerors>1);
					m_bBloodBrothers=xConf.GetSetB("Server/GameplayOptions/BloodBrothers",false);
					m_bSoulKeepers=xConf.GetSetB("Server/GameplayOptions/SoulKeepers",false)&&(m_bRandomRoles||m_iDefenders>0);
					m_bPopulationBonus=xConf.GetSetB("Server/GameplayOptions/PopulationBonus",false);
				else
					iPhantomMode=pxGame^.GetAttribInt("PhantomMode");
					m_bPhantomMode=iPhantomMode==1;
					m_bRandomRoles=pxGame^.GetAttribInt("RandomRoles")==1;
					m_bSeerPlayer=pxGame^.GetAttribInt("SeerPlayer")==1&&m_bRandomRoles;
					k=1; iK=Math.Min(4,iMid);
					m_iConquerors=Math.Clamp(pxGame^.GetAttribInt("ConquerorNumber"),k,iK);
					iRemain-=m_iConquerors;
					iMid+=1;
					k=0; iK=Math.Min(5,Math.Min(iMid,iRemain));
					m_iPaladins=Math.Clamp(pxGame^.GetAttribInt("PaladinNumber"),k,iK);
					iRemain-=m_iPaladins;
					m_iDefenders=iRemain;
					m_bRevelation=pxGame^.GetAttribInt("Revelation")==1&&(m_bRandomRoles||m_iConquerors>1);
					m_bBloodBrothers=pxGame^.GetAttribInt("BloodBrothers")==1;
					m_bSoulKeepers=pxGame^.GetAttribInt("SoulKeepers")==1&&(m_bRandomRoles||m_iDefenders>0);
					m_bPopulationBonus=pxGame^.GetAttribInt("PopulationBonus")==1;
				endif;
				pxPhantomMode=^(pxCSNode^.AddValue("PhantomMode",iPhantomMode));
				pxPhantomMode=^(pxCSNode^.AddValue("RandomRoles",ToInt(m_bRandomRoles)));
				pxPhantomMode=^(pxCSNode^.AddValue("SeerPlayer",ToInt(m_bSeerPlayer)));
				pxPhantomMode=^(pxCSNode^.AddValue("ConquerorNumber",m_iConquerors));
				pxPhantomMode=^(pxCSNode^.AddValue("PaladinNumber",m_iPaladins));
				pxPhantomMode=^(pxCSNode^.AddValue("DefenderNumber",m_iDefenders));
				pxPhantomMode=^(pxCSNode^.AddValue("Revelation",ToInt(m_bRevelation)));
				pxPhantomMode=^(pxCSNode^.AddValue("BloodBrothers",ToInt(m_bBloodBrothers)));
				pxPhantomMode=^(pxCSNode^.AddValue("SoulKeepers",ToInt(m_bSoulKeepers)));
				pxPhantomMode=^(pxCSNode^.AddValue("PopulationBonus",ToInt(m_bPopulationBonus)));
			else
				iPhantomMode=pxCSNode^.GetValueI("PhantomMode");
				m_bRandomRoles=pxCSNode^.GetValueI("RandomRoles",0)==1;
				m_bSeerPlayer=pxCSNode^.GetValueI("SeerPlayer",0)==1&&m_bRandomRoles;
				m_iConquerors=pxCSNode^.GetValueI("ConquerorNumber",1);
				m_iPaladins=pxCSNode^.GetValueI("PaladinNumber",1);
				m_iDefenders=pxCSNode^.GetValueI("DefenderNumber",1);
				m_bRevelation=pxCSNode^.GetValueI("Revelation",0)==1&&(m_bRandomRoles||m_iConquerors>1);
				m_bBloodBrothers=pxCSNode^.GetValueI("BloodBrothers")==1;
				m_bSoulKeepers=pxCSNode^.GetValueI("SoulKeepers")==1&&(m_bRandomRoles||m_iDefenders>0);
				m_bPopulationBonus=pxCSNode^.GetValueI("PopulationBonus")==1;
				m_bPhantomMode=iPhantomMode==1;
				m_bPhantomModeChecked=true;
			endif;
			return m_bPhantomMode;
		else
			return m_bPhantomMode;
		endif;
	endproc;
	
	export proc bool RandomRoles()
		return m_bRandomRoles;
	endproc;
	
	export proc bool SeerPlayer()
		return m_bSeerPlayer;
	endproc;
	
	export proc int Conquerors()
		return m_iConquerors;
	endproc;
	
	export proc int Paladins()
		return m_iPaladins;
	endproc;
	
	export proc int Defenders()
		return m_iDefenders;
	endproc;
	
	export proc bool Revelation()
		return m_bRevelation;
	endproc;
	
	export proc bool BloodBrothers()
		return m_bBloodBrothers;
	endproc;
	
	export proc bool SoulKeepers()
		return m_bSoulKeepers;
	endproc;
	
	export proc bool PopulationBonus()
		return m_bPopulationBonus;
	endproc;
	
	export proc bool SandGlass()
		if(!m_bSandGlassChecked)then
			m_iSandGlass=0;
			m_bSandGlass=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iGameType=CSrvWrap.GetGame().GetType();
			if(pxLevelInfo^.IsSaveGame())then
				iGameType=pxLevelInfo^.GetAttribs().GetValueInt("SavedGameType");
//			else
//				pxLevelInfo^.GetAttribs().SetValue("SavedGameType",iGameType);
			endif;
			if(!pxLevelInfo^.IsMultiplayer()||iGameType==2)then
				m_bSandGlass=false;
				m_bSandGlassChecked=true;
				return false;
			endif;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxSandGlass=^(pxCSNode^.Get("SandGlass"));
			if(pxSandGlass==null)then
				if(pxLevelInfo^.IsSaveGame()/*||!pxLevelInfo^.IsMultiplayer()*/||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_iSandGlass=xConf.GetSetI("Server/GameplayOptions/SandGlass",0);
					m_bSandGlass=m_iSandGlass>0;
				else
					m_iSandGlass=pxGame^.GetAttribInt("SandGlass");
					m_bSandGlass=m_iSandGlass>0;
				endif;
				pxSandGlass=^(pxCSNode^.AddValue("SandGlass",m_iSandGlass));
			else
				m_iSandGlass=pxCSNode^.GetValueI("SandGlass");
				m_bSandGlass=m_iSandGlass>0;
				m_bSandGlassChecked=true;
			endif;
			return m_bSandGlass;
		else
			return m_bSandGlass;
		endif;
	endproc;
	
	export proc int SandGlassTime()
		return m_iSandGlass;
	endproc;
	
	export proc bool DominationUpDownTimer()
		if(!m_bDominationUpDownTimerChecked)then
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			if(!pxLevelInfo^.IsMultiplayer())then
				m_bDominationUpDownTimerChecked=true;
				return false;
			endif;
			var int iDominationUpDownTimer=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxDominationUpDownTimer=^(pxCSNode^.Get("DominationUpDownTimer"));
			if(pxDominationUpDownTimer==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					ms_fDFTimer=Math.Clamp(xConf.GetSetF("Server/GameplayOptions/DominationUpDownTimer",10.0f),1.0,30.0);
				else
					ms_fDFTimer=Math.Clamp(pxGame^.GetAttrib("DominationUpDownTimer").ToReal(),1.0,30.0);
				endif;
				pxDominationUpDownTimer=^(pxCSNode^.AddValue("DominationUpDownTimer",ms_fDFTimer));
			else
				ms_fDFTimer=pxCSNode^.GetValueR("DominationUpDownTimer");
				m_bDominationUpDownTimerChecked=true;
			endif;
			return true;
		else
			return true;
		endif;
	endproc;
	
	export proc bool BldgMaxCapacity()
		if(!m_bBldgMaxCapacityChecked)then
			m_bBldgMaxCapacity=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iBldgMaxCapacity=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxBldgMaxCapacity=^(pxCSNode^.Get("BldgMaxCapacity"));
			if(pxBldgMaxCapacity==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bBldgMaxCapacity=xConf.GetSetB("Server/GameplayOptions/BldgMaxCapacity",false);
					if(m_bBldgMaxCapacity)then
						iBldgMaxCapacity=1;
					endif;
				else
					iBldgMaxCapacity=pxGame^.GetAttribInt("BldgMaxCapacity");
					m_bBldgMaxCapacity=iBldgMaxCapacity==1;
				endif;
				pxBldgMaxCapacity=^(pxCSNode^.AddValue("BldgMaxCapacity",iBldgMaxCapacity));
			else
				iBldgMaxCapacity=pxCSNode^.GetValueI("BldgMaxCapacity");
				m_bBldgMaxCapacity=iBldgMaxCapacity==1;
				m_bBldgMaxCapacityChecked=true;
			endif;
			return m_bBldgMaxCapacity;
		else
			return m_bBldgMaxCapacity;
		endif;
	endproc;
	
	export proc bool SpeedUp()
		if(!m_bSpeedUpChecked)then
			m_bSpeedUp=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iSpeedUp=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxSpeedUp=^(pxCSNode^.Get("SpeedUp"));
			if(pxSpeedUp==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bSpeedUp=xConf.GetSetB("Server/GameplayOptions/SpeedUp",true);
					if(m_bSpeedUp)then
						iSpeedUp=1;
					endif;
				else
					iSpeedUp=pxGame^.GetAttribInt("SpeedUp");
					m_bSpeedUp=iSpeedUp==1;
				endif;
				pxSpeedUp=^(pxCSNode^.AddValue("SpeedUp",iSpeedUp));
			else
				iSpeedUp=pxCSNode^.GetValueI("SpeedUp");
				m_bSpeedUp=iSpeedUp==1;
				m_bSpeedUpChecked=true;
			endif;
			return m_bSpeedUp;
		else
			return m_bSpeedUp;
		endif;
	endproc;
	
	export proc bool TrainingDummies()
		return true;
//		if(!m_bTrainingDummiesChecked)then
//			m_bTrainingDummies=false;
//			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
//			if(pxGame==null)then return false; endif;
//			if(pxGame^.IsLevelEd())then return false; endif;
//			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
//			if(pxLevel==null)then return false; endif;
//			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
//			if(pxLevelInfo==null)then return false; endif;
//			var int iTrainingDummies=0;
//			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
//			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
//			if(pxCSNode==null)then return false; endif;
//			var ^CPropDB.CNode pxTrainingDummies=^(pxCSNode^.Get("TrainingDummies"));
//			if(pxTrainingDummies==null)then
//				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
//					var CConfig xConf;
//					m_bTrainingDummies=xConf.GetSetB("Server/GameplayOptions/TrainingDummies",true);
//					if(m_bTrainingDummies)then
//						iTrainingDummies=1;
//					endif;
//				else
//					iTrainingDummies=pxGame^.GetAttribInt("TrainingDummies");
//					m_bTrainingDummies=iTrainingDummies==1;
//				endif;
//				pxTrainingDummies=^(pxCSNode^.AddValue("TrainingDummies",iTrainingDummies));
//			else
//				iTrainingDummies=pxCSNode^.GetValueI("TrainingDummies");
//				m_bTrainingDummies=iTrainingDummies==1;
//				m_bTrainingDummiesChecked=true;
//			endif;
//			return m_bTrainingDummies;
//		else
//			return m_bTrainingDummies;
//		endif;
	endproc;
	
	export proc bool AllowThrow()
		if(!m_bAllowThrowChecked)then
			m_bAllowThrow=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iAllowThrow=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxAllowThrow=^(pxCSNode^.Get("AllowThrow"));
			if(pxAllowThrow==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bAllowThrow=xConf.GetSetB("Server/GameplayOptions/AllowThrow",true);
					if(m_bAllowThrow)then
						iAllowThrow=1;
					endif;
				else
					iAllowThrow=pxGame^.GetAttribInt("AllowThrow");
					m_bAllowThrow=iAllowThrow==1;
				endif;
				pxAllowThrow=^(pxCSNode^.AddValue("AllowThrow",iAllowThrow));
			else
				iAllowThrow=pxCSNode^.GetValueI("AllowThrow");
				m_bAllowThrow=iAllowThrow==1;
				m_bAllowThrowChecked=true;
			endif;
			return m_bAllowThrow;
		else
			return m_bAllowThrow;
		endif;
	endproc;
	
	export proc bool UseOldSpirits()
		if(!m_bUseOldSpiritsChecked)then
			m_bUseOldSpirits=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iUseOldSpirits=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxUseOldSpirits=^(pxCSNode^.Get("UseOldSpirits"));
			if(pxUseOldSpirits==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bUseOldSpirits=xConf.GetSetB("Server/GameplayOptions/UseOldSpirits",false);
					if(m_bUseOldSpirits)then
						iUseOldSpirits=1;
					endif;
				else
					iUseOldSpirits=pxGame^.GetAttribInt("UseOldSpirits");
					m_bUseOldSpirits=iUseOldSpirits==1;
				endif;
				pxUseOldSpirits=^(pxCSNode^.AddValue("UseOldSpirits",iUseOldSpirits));
			else
				iUseOldSpirits=pxCSNode^.GetValueI("UseOldSpirits");
				m_bUseOldSpirits=iUseOldSpirits==1;
				m_bUseOldSpiritsChecked=true;
			endif;
			return m_bUseOldSpirits;
		else
			return m_bUseOldSpirits;
		endif;
	endproc;
	
	export proc bool GlobalReanim()
		if(!m_bGlobalReanimChecked)then
			m_bGlobalReanim=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iGlobalReanim=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxGlobalReanim=^(pxCSNode^.Get("GlobalReanim"));
			if(pxGlobalReanim==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bGlobalReanim=xConf.GetSetB("Server/GameplayOptions/GlobalReanim",false);
					if(m_bGlobalReanim)then
						iGlobalReanim=1;
					endif;
				else
					iGlobalReanim=pxGame^.GetAttribInt("GlobalReanim");
					m_bGlobalReanim=iGlobalReanim==1;
				endif;
				pxGlobalReanim=^(pxCSNode^.AddValue("GlobalReanim",iGlobalReanim));
			else
				iGlobalReanim=pxCSNode^.GetValueI("GlobalReanim");
				m_bGlobalReanim=iGlobalReanim==1;
				m_bGlobalReanimChecked=true;
			endif;
			return m_bGlobalReanim;
		else
			return m_bGlobalReanim;
		endif;
	endproc;
	
	export proc bool DisableSpirits()
		if(!m_bDisableSpiritsChecked)then
			m_bDisableSpirits=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iDisableSpirits=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxDisableSpirits=^(pxCSNode^.Get("DisableSpirits"));
			if(pxDisableSpirits==null)then
				m_bDisableSpiritsChecked=true;
//				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
//					var CConfig xConf;
//					m_bDisableSpirits=xConf.GetSetB("Server/GameplayOptions/DisableSpirits",false);
//					if(m_bDisableSpirits)then
//						iDisableSpirits=1;
//					endif;
//				else
//					iDisableSpirits=pxGame^.GetAttribInt("DisableSpirits");
//					m_bDisableSpirits=iDisableSpirits==1;
//				endif;
				pxDisableSpirits=^(pxCSNode^.AddValue("DisableSpirits",iDisableSpirits));
			else
				iDisableSpirits=pxCSNode^.GetValueI("DisableSpirits");
				m_bDisableSpirits=iDisableSpirits==1;
				m_bDisableSpiritsChecked=true;
			endif;
			return m_bDisableSpirits;
		else
			return m_bDisableSpirits;
		endif;
	endproc;
	
	export proc bool DisableBurning()
		if(!m_bDisableBurningChecked)then
			m_bDisableBurning=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iDisableBurning=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxDisableBurning=^(pxCSNode^.Get("DisableBurning"));
			if(pxDisableBurning==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bDisableBurning=xConf.GetSetB("Server/GameplayOptions/DisableBurning",false);
					if(m_bDisableBurning)then
						iDisableBurning=1;
					endif;
				else
					iDisableBurning=pxGame^.GetAttribInt("DisableBurning");
					m_bDisableBurning=iDisableBurning==1;
				endif;
				pxDisableBurning=^(pxCSNode^.AddValue("DisableBurning",iDisableBurning));
			else
				iDisableBurning=pxCSNode^.GetValueI("DisableBurning");
				m_bDisableBurning=iDisableBurning==1;
				m_bDisableBurningChecked=true;
			endif;
			return m_bDisableBurning;
		else
			return m_bDisableBurning;
		endif;
	endproc;
	
	export proc bool DisableArtifactRelease()
		if(!m_bDisableArtifactReleaseChecked)then
			m_bDisableArtifactRelease=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iDisableArtifactRelease=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxDisableArtifactRelease=^(pxCSNode^.Get("DisableArtifactRelease"));
			if(pxDisableArtifactRelease==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bDisableArtifactRelease=xConf.GetSetB("Server/GameplayOptions/DisableArtifactRelease",false);
					if(m_bDisableArtifactRelease)then
						iDisableArtifactRelease=1;
					endif;
				else
					iDisableArtifactRelease=pxGame^.GetAttribInt("DisableArtifactRelease");
					m_bDisableArtifactRelease=iDisableArtifactRelease==1;
				endif;
				pxDisableArtifactRelease=^(pxCSNode^.AddValue("DisableArtifactRelease",iDisableArtifactRelease));
			else
				iDisableArtifactRelease=pxCSNode^.GetValueI("DisableArtifactRelease");
				m_bDisableArtifactRelease=iDisableArtifactRelease==1;
				m_bDisableArtifactReleaseChecked=true;
			endif;
			return m_bDisableArtifactRelease;
		else
			return m_bDisableArtifactRelease;
		endif;
	endproc;
	
	export proc bool DisableBerserking()
		if(!m_bDisableBerserkingChecked)then
			m_bDisableBerserking=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iDisableBerserking=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxDisableBerserking=^(pxCSNode^.Get("DisableBerserking"));
			if(pxDisableBerserking==null)then
				m_bDisableBerserkingChecked=true;
//				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bDisableBerserking=xConf.GetSetB("Server/GameplayOptions/DisableBerserking",false);
					if(m_bDisableBerserking)then
						iDisableBerserking=1;
					endif;
//				else
//					iDisableBerserking=pxGame^.GetAttribInt("DisableBerserking");
//					m_bDisableBerserking=iDisableBerserking==1;
//				endif;
				pxDisableBerserking=^(pxCSNode^.AddValue("DisableBerserking",iDisableBerserking));
			else
				iDisableBerserking=pxCSNode^.GetValueI("DisableBerserking");
				m_bDisableBerserking=iDisableBerserking==1;
				m_bDisableBerserkingChecked=true;
			endif;
			return m_bDisableBerserking;
		else
			return m_bDisableBerserking;
		endif;
	endproc;
	
	export proc bool ExcludeBuildUp()
		if(!m_bExcludeBuildUpChecked)then
			m_bExcludeBuildUp=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iExcludeBuildUp=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxExcludeBuildUp=^(pxCSNode^.Get("ExcludeBuildUp"));
			if(pxExcludeBuildUp==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bExcludeBuildUp=xConf.GetSetB("Server/GameplayOptions/ExcludeBuildUp",false);
					if(m_bExcludeBuildUp)then
						iExcludeBuildUp=1;
					endif;
				else
					iExcludeBuildUp=pxGame^.GetAttribInt("ExcludeBuildUp");
					m_bExcludeBuildUp=iExcludeBuildUp==1;
				endif;
				pxExcludeBuildUp=^(pxCSNode^.AddValue("ExcludeBuildUp",iExcludeBuildUp));
			else
				iExcludeBuildUp=pxCSNode^.GetValueI("ExcludeBuildUp");
				m_bExcludeBuildUp=iExcludeBuildUp==1;
				m_bExcludeBuildUpChecked=true;
			endif;
			return m_bExcludeBuildUp;
		else
			return m_bExcludeBuildUp;
		endif;
	endproc;
	
	export proc bool AttackInFOW()
		if(!m_bAttackInFOWChecked)then
			m_bAttackInFOW=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iAttackInFOW=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxAttackInFOW=^(pxCSNode^.Get("AttackInFOW"));
			if(pxAttackInFOW==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bAttackInFOW=xConf.GetSetB("Server/GameplayOptions/AttackInFOW",false);
					if(m_bAttackInFOW)then
						iAttackInFOW=1;
					endif;
				else
					iAttackInFOW=pxGame^.GetAttribInt("AttackInFOW");
					m_bAttackInFOW=iAttackInFOW==1;
				endif;
				pxAttackInFOW=^(pxCSNode^.AddValue("AttackInFOW",iAttackInFOW));
			else
				iAttackInFOW=pxCSNode^.GetValueI("AttackInFOW");
				m_bAttackInFOW=iAttackInFOW==1;
				m_bAttackInFOWChecked=true;
			endif;
			return m_bAttackInFOW;
		else
			return m_bAttackInFOW;
		endif;
	endproc;
	
	export proc bool OldDisembark()
		if(!m_bOldDisembarkChecked)then
			m_bOldDisembark=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iOldDisembark=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxOldDisembark=^(pxCSNode^.Get("OldDisembark"));
			if(pxOldDisembark==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bOldDisembark=xConf.GetSetB("Server/GameplayOptions/OldDisembark",true);
					if(m_bOldDisembark)then
						iOldDisembark=1;
					endif;
				else
					iOldDisembark=pxGame^.GetAttribInt("OldDisembark");
					m_bOldDisembark=iOldDisembark==1;
				endif;
				pxOldDisembark=^(pxCSNode^.AddValue("OldDisembark",iOldDisembark));
			else
				iOldDisembark=pxCSNode^.GetValueI("OldDisembark");
				m_bOldDisembark=iOldDisembark==1;
				m_bOldDisembarkChecked=true;
			endif;
			return m_bOldDisembark;
		else
			return m_bOldDisembark;
		endif;
	endproc;
	
	export proc bool AuraSharing()
		if(!m_bAuraSharingChecked)then
			m_bAuraSharing=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iAuraSharing=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxAuraSharing=^(pxCSNode^.Get("AuraSharing"));
			if(pxAuraSharing==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bAuraSharing=xConf.GetSetB("Server/GameplayOptions/AuraSharing",true);
					if(m_bAuraSharing)then
						iAuraSharing=1;
					endif;
				else
					iAuraSharing=pxGame^.GetAttribInt("AuraSharing");
					m_bAuraSharing=iAuraSharing==1;
				endif;
				pxAuraSharing=^(pxCSNode^.AddValue("AuraSharing",iAuraSharing));
			else
				iAuraSharing=pxCSNode^.GetValueI("AuraSharing");
				m_bAuraSharing=iAuraSharing==1;
				m_bAuraSharingChecked=true;
			endif;
			return m_bAuraSharing;
		else
			return m_bAuraSharing;
		endif;
	endproc;
	
	export proc bool TechtreeSteal()
		if(!m_bTechtreeStealChecked)then
			m_bTechtreeSteal=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iTechtreeSteal=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxTechtreeSteal=^(pxCSNode^.Get("TechtreeSteal"));
			if(pxTechtreeSteal==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bTechtreeSteal=xConf.GetSetB("Server/GameplayOptions/TechtreeSteal",false);
					if(m_bTechtreeSteal)then
						iTechtreeSteal=1;
					endif;
				else
					iTechtreeSteal=pxGame^.GetAttribInt("TechtreeSteal");
					m_bTechtreeSteal=iTechtreeSteal==1;
				endif;
				pxTechtreeSteal=^(pxCSNode^.AddValue("TechtreeSteal",iTechtreeSteal));
			else
				iTechtreeSteal=pxCSNode^.GetValueI("TechtreeSteal");
				m_bTechtreeSteal=iTechtreeSteal==1;
				m_bTechtreeStealChecked=true;
			endif;
			return m_bTechtreeSteal;
		else
			return m_bTechtreeSteal;
		endif;
	endproc;
	
	export proc bool MultiTribe()
		if(!m_bMultiTribeChecked)then
			m_bMultiTribe=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iMultiTribe=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxMultiTribe=^(pxCSNode^.Get("MultiTribe"));
			if(pxMultiTribe==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bMultiTribe=xConf.GetSetB("Server/GameplayOptions/MultiTribe",false);
					if(m_bMultiTribe)then
						iMultiTribe=1;
					endif;
				else
					iMultiTribe=pxGame^.GetAttribInt("MultiTribe");
					m_bMultiTribe=iMultiTribe==1;
				endif;
				pxMultiTribe=^(pxCSNode^.AddValue("MultiTribe",iMultiTribe));
			else
				iMultiTribe=pxCSNode^.GetValueI("MultiTribe");
				m_bMultiTribe=iMultiTribe==1;
				m_bMultiTribeChecked=true;
			endif;
			return m_bMultiTribe;
		else
			return m_bMultiTribe;
		endif;
	endproc;
	
	export proc bool DivideSkulls()
		if(!m_bDivideSkullsChecked)then
			m_bDivideSkulls=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iDivideSkulls=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxDivideSkulls=^(pxCSNode^.Get("DivideSkulls"));
			if(pxDivideSkulls==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bDivideSkulls=xConf.GetSetB("Server/GameplayOptions/DivideSkulls",false);
					if(m_bDivideSkulls)then
						iDivideSkulls=1;
					endif;
				else
					iDivideSkulls=pxGame^.GetAttribInt("DivideSkulls");
					m_bDivideSkulls=iDivideSkulls==1;
				endif;
				pxDivideSkulls=^(pxCSNode^.AddValue("DivideSkulls",iDivideSkulls));
			else
				iDivideSkulls=pxCSNode^.GetValueI("DivideSkulls");
				m_bDivideSkulls=iDivideSkulls==1;
				m_bDivideSkullsChecked=true;
			endif;
			return m_bDivideSkulls;
		else
			return m_bDivideSkulls;
		endif;
	endproc;
	
	export proc bool ObserverChat()
		if(!m_bObserverChatChecked)then
			m_bObserverChat=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iObserverChat=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxObserverChat=^(pxCSNode^.Get("ObserverChat"));
			if(pxObserverChat==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bObserverChat=xConf.GetSetB("Server/GameplayOptions/ObserverChat",false);
					if(m_bObserverChat)then
						iObserverChat=1;
					endif;
				else
					iObserverChat=pxGame^.GetAttribInt("ObserverChat");
					m_bObserverChat=iObserverChat==1;
				endif;
				pxObserverChat=^(pxCSNode^.AddValue("ObserverChat",iObserverChat));
			else
				iObserverChat=pxCSNode^.GetValueI("ObserverChat");
				m_bObserverChat=iObserverChat==1;
				m_bObserverChatChecked=true;
			endif;
			return m_bObserverChat;
		else
			return m_bObserverChat;
		endif;
	endproc;
	
	export proc bool NoHumpWalking()
		if(!m_bNoHumpWalkingChecked)then
			m_bNoHumpWalking=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iNoHumpWalking=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxNoHumpWalking=^(pxCSNode^.Get("NoHumpWalking"));
			if(pxNoHumpWalking==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bNoHumpWalking=xConf.GetSetB("Server/GameplayOptions/NoHumpWalking",false);
					if(m_bNoHumpWalking)then
						iNoHumpWalking=1;
					endif;
				else
					iNoHumpWalking=pxGame^.GetAttribInt("NoHumpWalking");
					m_bNoHumpWalking=iNoHumpWalking==1;
				endif;
				pxNoHumpWalking=^(pxCSNode^.AddValue("NoHumpWalking",iNoHumpWalking));
			else
				iNoHumpWalking=pxCSNode^.GetValueI("NoHumpWalking");
				m_bNoHumpWalking=iNoHumpWalking==1;
				m_bNoHumpWalkingChecked=true;
			endif;
			return m_bNoHumpWalking;
		else
			return m_bNoHumpWalking;
		endif;
	endproc;
	
	export proc bool RemoveTitans()
		if(!m_bRemoveTitansChecked)then
			m_bRemoveTitans=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iRemoveTitans=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxRemoveTitans=^(pxCSNode^.Get("RemoveTitans"));
			if(pxRemoveTitans==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bRemoveTitans=xConf.GetSetB("Server/GameplayOptions/RemoveTitans",false);
					if(m_bRemoveTitans)then
						iRemoveTitans=1;
					endif;
				else
					iRemoveTitans=pxGame^.GetAttribInt("RemoveTitans");
					m_bRemoveTitans=iRemoveTitans==1;
				endif;
				pxRemoveTitans=^(pxCSNode^.AddValue("RemoveTitans",iRemoveTitans));
			else
				iRemoveTitans=pxCSNode^.GetValueI("RemoveTitans");
				m_bRemoveTitans=iRemoveTitans==1;
				m_bRemoveTitansChecked=true;
			endif;
			return m_bRemoveTitans;
		else
			return m_bRemoveTitans;
		endif;
	endproc;
	
	export proc bool RemoveTrading()
		if(!m_bRemoveTradingChecked)then
			m_bRemoveTrading=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iRemoveTrading=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxRemoveTrading=^(pxCSNode^.Get("RemoveTrading"));
			if(pxRemoveTrading==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bRemoveTrading=xConf.GetSetB("Server/GameplayOptions/RemoveTrading",false);
					if(m_bRemoveTrading)then
						iRemoveTrading=1;
					endif;
				else
					iRemoveTrading=pxGame^.GetAttribInt("RemoveTrading");
					m_bRemoveTrading=iRemoveTrading==1;
				endif;
				pxRemoveTrading=^(pxCSNode^.AddValue("RemoveTrading",iRemoveTrading));
			else
				iRemoveTrading=pxCSNode^.GetValueI("RemoveTrading");
				m_bRemoveTrading=iRemoveTrading==1;
				m_bRemoveTradingChecked=true;
			endif;
			return m_bRemoveTrading;
		else
			return m_bRemoveTrading;
		endif;
	endproc;
	
	export proc bool InfantryWar()
		if(!m_bInfantryWarChecked)then
			m_bInfantryWar=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iInfantryWar=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxInfantryWar=^(pxCSNode^.Get("InfantryWar"));
			if(pxInfantryWar==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bInfantryWar=xConf.GetSetB("Server/GameplayOptions/InfantryWar",false);
					if(m_bInfantryWar)then
						iInfantryWar=1;
					endif;
				else
					iInfantryWar=pxGame^.GetAttribInt("InfantryWar");
					m_bInfantryWar=iInfantryWar==1;
				endif;
				pxInfantryWar=^(pxCSNode^.AddValue("InfantryWar",iInfantryWar));
			else
				iInfantryWar=pxCSNode^.GetValueI("InfantryWar");
				m_bInfantryWar=iInfantryWar==1;
				m_bInfantryWarChecked=true;
			endif;
			return m_bInfantryWar;
		else
			return m_bInfantryWar;
		endif;
	endproc;
	
	export proc bool DeliveryUnbound()
		if(!m_bDeliveryUnboundChecked)then
			m_bDeliveryUnbound=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iDeliveryUnbound=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxDeliveryUnbound=^(pxCSNode^.Get("DeliveryUnbound"));
			if(pxDeliveryUnbound==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bDeliveryUnbound=xConf.GetSetB("Server/GameplayOptions/DeliveryUnbound",false);
					if(m_bDeliveryUnbound)then
						iDeliveryUnbound=1;
					endif;
				else
					iDeliveryUnbound=pxGame^.GetAttribInt("DeliveryUnbound");
					m_bDeliveryUnbound=iDeliveryUnbound==1;
				endif;
				pxDeliveryUnbound=^(pxCSNode^.AddValue("DeliveryUnbound",iDeliveryUnbound));
			else
				iDeliveryUnbound=pxCSNode^.GetValueI("DeliveryUnbound");
				m_bDeliveryUnbound=iDeliveryUnbound==1;
				m_bDeliveryUnboundChecked=true;
			endif;
			return m_bDeliveryUnbound;
		else
			return m_bDeliveryUnbound;
		endif;
	endproc;
	
	export proc bool GeneralAdvancement()
		if(!m_bGeneralAdvancementChecked)then
			m_bGeneralAdvancement=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iGeneralAdvancement=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxGeneralAdvancement=^(pxCSNode^.Get("GeneralAdvancement"));
			if(pxGeneralAdvancement==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bGeneralAdvancement=xConf.GetSetB("Server/GameplayOptions/GeneralAdvancement",false);
					if(m_bGeneralAdvancement)then
						iGeneralAdvancement=1;
					endif;
				else
					iGeneralAdvancement=pxGame^.GetAttribInt("GeneralAdvancement");
					m_bGeneralAdvancement=iGeneralAdvancement==1;
				endif;
				pxGeneralAdvancement=^(pxCSNode^.AddValue("GeneralAdvancement",iGeneralAdvancement));
			else
				iGeneralAdvancement=pxCSNode^.GetValueI("GeneralAdvancement");
				m_bGeneralAdvancement=iGeneralAdvancement==1;
				m_bGeneralAdvancementChecked=true;
			endif;
			return m_bGeneralAdvancement;
		else
			return m_bGeneralAdvancement;
		endif;
	endproc;
	
	export proc bool AllyBuildup()
		if(!m_bAllyBuildupChecked)then
			m_bAllyBuildup=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iAllyBuildup=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxAllyBuildup=^(pxCSNode^.Get("AllyBuildup"));
			if(pxAllyBuildup==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bAllyBuildup=xConf.GetSetB("Server/GameplayOptions/AllyBuildup",true)||(!pxLevelInfo^.IsMultiplayer());
					if(m_bAllyBuildup)then
						iAllyBuildup=1;
					endif;
				else
					iAllyBuildup=pxGame^.GetAttribInt("AllyBuildup");
					m_bAllyBuildup=iAllyBuildup==1;
				endif;
				pxAllyBuildup=^(pxCSNode^.AddValue("AllyBuildup",iAllyBuildup));
			else
				iAllyBuildup=pxCSNode^.GetValueI("AllyBuildup");
				m_bAllyBuildup=iAllyBuildup==1;
				m_bAllyBuildupChecked=true;
			endif;
			return m_bAllyBuildup;
		else
			return m_bAllyBuildup;
		endif;
	endproc;
	
	export proc bool DominationContinue()
		if(!m_bDominationContinueChecked)then
			m_bDominationContinue=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iDominationContinue=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxDominationContinue=^(pxCSNode^.Get("DominationContinue"));
			if(pxDominationContinue==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bDominationContinue=xConf.GetSetB("Server/GameplayOptions/DominationContinue",false)||(!pxLevelInfo^.IsMultiplayer());
					if(m_bDominationContinue)then
						iDominationContinue=1;
					endif;
				else
					iDominationContinue=pxGame^.GetAttribInt("DominationContinue");
					m_bDominationContinue=iDominationContinue==1;
//					var CConfig xConf;
//					m_bDominationContinue=xConf.GetSetB("Server/GameplayOptions/DominationContinue",false)||(!pxLevelInfo^.IsMultiplayer());
//					if(m_bDominationContinue)then
//						iDominationContinue=1;
//					endif;
				endif;
				pxDominationContinue=^(pxCSNode^.AddValue("DominationContinue",iDominationContinue));
			else
				iDominationContinue=pxCSNode^.GetValueI("DominationContinue");
				m_bDominationContinue=iDominationContinue==1;
				m_bDominationContinueChecked=true;
			endif;
			return m_bDominationContinue;
		else
			return m_bDominationContinue;
		endif;
	endproc;
	
	export proc bool AlienCommands()
		if(!m_bAlienCommandsChecked)then
			m_bAlienCommands=false;
			var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
			if(pxGame==null)then return false; endif;
			if(pxGame^.IsLevelEd())then return false; endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return false; endif;
			var ^CLevelInfoHost pxLevelInfo=^(pxLevel^.GetLevelInfo());
			if(pxLevelInfo==null)then return false; endif;
			var int iAlienCommands=0;
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxCSNode=pxGenericDB^.FindNode("ClientSettings",false);
			if(pxCSNode==null)then return false; endif;
			var ^CPropDB.CNode pxAlienCommands=^(pxCSNode^.Get("AlienCommands"));
			if(pxAlienCommands==null)then
				if(pxLevelInfo^.IsSaveGame()||!pxLevelInfo^.IsMultiplayer()||pxGame^.GetAttribInt("NewGame")==0)then
					var CConfig xConf;
					m_bAlienCommands=xConf.GetSetB("Server/AllowAlienCommands",false);
					if(m_bAlienCommands)then
						iAlienCommands=1;
					endif;
				else
					iAlienCommands=pxGame^.GetAttribInt("AlienCommands");
					m_bAlienCommands=iAlienCommands==1;
				endif;
				pxAlienCommands=^(pxCSNode^.AddValue("AlienCommands",iAlienCommands));
			else
				iAlienCommands=pxCSNode^.GetValueI("AlienCommands");
				m_bAlienCommands=iAlienCommands==1;
				m_bAllyBuildupChecked=true;
			endif;
			return m_bAlienCommands;
		else
			return m_bAlienCommands;
		endif;
	endproc;
	
	export static proc real IsBigBuilding(string p_sName, string p_sModel)
		var real fDis=4.0f;
		if(p_sName=="seas_fortress")then
			fDis=10.0f;
		elseif(p_sName=="seas_big_tent")then
			fDis=12.0f;
		elseif(p_sName=="seas_great_cannon")then
			fDis=25.0f;
		elseif(p_sModel=="amazon_temple")then
			fDis=30.0f;
		elseif(p_sModel=="aje_floating_harbour")then
			fDis=20.0f;
		elseif(p_sModel=="seas_carrier")then
			fDis=20.0f;
		endif;
		return fDis;
	endproc;
	
	export static proc bool IsBigBuildingAgain(string p_sName, string p_sModel)
		var bool bBB=false;
		if(p_sName=="seas_fortress")then
			bBB=true;
		elseif(p_sName=="seas_big_tent")then
			bBB=true;
		elseif(p_sName=="seas_great_cannon")then
			bBB=true;
		elseif(p_sModel=="amazon_temple")then
			bBB=true;
		elseif(p_sModel=="aje_floating_harbour")then
			bBB=true;
		elseif(p_sModel=="seas_carrier")then
			bBB=true;
		endif;
		return bBB;
	endproc;
	
	//Henry: original idea from AyCe, made it read from an external file
	export proc void ResetAINames()
		m_asNames=0;
		var ^CPropDB pxAINames=new CPropDB();
		if(!pxAINames^.Load(CSrvWrap.GetUrsRelPath()+"/Data/Base/Scripts/Server/settings/ai_names.txt"))then return; endif;
		var ^CPropDB.CNode pxNames=^(pxAINames^.GetRoot());
		var int i, iC=pxNames^.NumSubs();
		for(i=0)cond(i<iC)iter(i++)do
			m_asNames.AddEntry((pxNames^)[i].Name());
		endfor;
	endproc;
	
	export proc string GetRandomAIName()
		if(m_asNames.NumEntries()==0)then
			return "NoName";
		endif;
		var int iNr=Random.GetInt()%m_asNames.NumEntries();
		var string sName=m_asNames[iNr];
		m_asNames.DeleteEntryUS(iNr);
		return sName;
	endproc;
	
	export proc bool UseAINames(string p_sLevel, int p_iSlot)
		if((p_sLevel.Find("BfPW - Highland")!=-1||p_sLevel.Find("BfPW - HL")!=-1) && (p_iSlot==6||p_iSlot==7))then
			return false;
		endif;
		if(p_sLevel.Find("_CU_MP_6_CRASH_RPG")!=-1 && (p_iSlot==6||p_iSlot==7))then
			return false;
		endif;
		return true;
	endproc;
	
	export proc bool GetCustomSlotName(string p_sMap, int p_iID, ref string p_rsName)
		if(m_pxCustomMapStuff==null)then return false; endif;
		var ^CPropDB.CNode pxMap=m_pxCustomMapStuff^.Get(p_sMap);
		if(pxMap!=null)then
			var string sTmp="NAME_"+p_iID.ToString();
			if(pxMap^.Get(sTmp)!=null)then
				p_rsName=pxMap^.GetValueS(sTmp,p_rsName);
				return true;
			endif;
		endif;
		return false;
	endproc;
	
	export proc bool GetCustomSlotTeam(string p_sMap, int p_iID, ref int p_riTeam)
		if(m_pxCustomMapStuff==null)then return false; endif;
		var ^CPropDB.CNode pxMap=m_pxCustomMapStuff^.Get(p_sMap);
		if(pxMap!=null)then
			var string sTmp="TEAM_"+p_iID.ToString();
			if(pxMap^.Get(sTmp)!=null)then
				p_riTeam=pxMap^.GetValueI(sTmp,p_riTeam);
				return true;
			endif;
		endif;
		return false;
	endproc;
	
// added ParaworldFan	

	export proc bool GetCustomSlotDifficulty(string p_sMap, int p_iID, ref int p_riDifficulty)
		if(m_pxCustomMapStuff==null)then return false; endif;
		var ^CPropDB.CNode pxMap=m_pxCustomMapStuff^.Get(p_sMap);
		if(pxMap!=null)then
			var string sTmp="DIFFICULTY_"+p_iID.ToString();
			if(pxMap^.Get(sTmp)!=null)then
				p_riDifficulty=pxMap^.GetValueI(sTmp,p_riDifficulty);
			//	m_pxPlayerSlot^.SetValue("Difficulty",iDif);
			//	pxPlayerSlot^.SetValue("Difficulty",iAIDifficulty);
			//	pxCM^.SetDifficulty(iDifficulty);
			//	m_iDifficulty = iDif;
			//	m_sDifficulty=m_pxCM^.GetDifficulty();
			//	iDifficulty
			//	var int iDifficulty;
			//	(pxUserProfile^)["Campaign"].SetValue("Difficulty",p_iDifficulty);	НУЖНАЯ ПЕРЕМЕННАЯ
			//	var int iDiff=pxPlayerSlot^.GetValueInt("Difficulty");
			//	int p_iLevel
			//	var int iDff=pxPlayerSlot^.GetValueInt("Difficulty");
			//	SetDifficulty(9);
				return true;
			endif;
		endif;
		return false;
	endproc;
	
	export proc bool GetCustomSlotType(string p_sMap, int p_iID, ref string p_rsType)
		if(m_pxCustomMapStuff==null)then return false; endif;
		var ^CPropDB.CNode pxMap=m_pxCustomMapStuff^.Get(p_sMap);
		if(pxMap!=null)then
			var string sTmp="TYPE_"+p_iID.ToString();
			if(pxMap^.Get(sTmp)!=null)then
				p_rsType=pxMap^.GetValueS(sTmp,p_rsType);
				return true;
			endif;
		endif;
		return false;
	endproc;
	
	export proc bool GetCustomSlotColor(string p_sMap, int p_iID, ref int p_riColor)
		if(m_pxCustomMapStuff==null)then return false; endif;
		var ^CPropDB.CNode pxMap=m_pxCustomMapStuff^.Get(p_sMap);
		if(pxMap!=null)then
			var string sTmp="COLOR_"+p_iID.ToString();
			if(pxMap^.Get(sTmp)!=null)then
				p_riColor=pxMap^.GetValueI(sTmp,p_riColor);
				return true;
			endif;
		endif;
		return false;
	endproc;
	
	export proc bool GetPreferedSlotColor(string p_sMap, int p_iID, ref int p_riColor)
		if(m_pxCustomMapStuff==null)then return false; endif;
		var ^CPropDB.CNode pxMap=m_pxCustomMapStuff^.Get(p_sMap);
		if(pxMap!=null)then
			var string sTmp="PREFER_C_"+p_iID.ToString();
			if(pxMap^.Get(sTmp)!=null)then
				p_riColor=pxMap^.GetValueI(sTmp,p_riColor);
				return true;
			endif;
		endif;
		return false;
	endproc;
	
	export proc bool GetCustomSlotHQ(string p_sMap, int p_iID, ref int p_riHQ)
		if(m_pxCustomMapStuff==null)then return false; endif;
		var ^CPropDB.CNode pxMap=m_pxCustomMapStuff^.Get(p_sMap);
		if(pxMap!=null)then
			var string sTmp="HQ_"+p_iID.ToString();
			if(pxMap^.Get(sTmp)!=null)then
				p_riHQ=pxMap^.GetValueI(sTmp,p_riHQ);
				return true;
			endif;
		endif;
		return false;
	endproc;
	
	export proc bool GetCustomSlotTribe(string p_sMap, int p_iID, ref string p_rsTribe)
		if(m_pxCustomMapStuff==null)then return false; endif;
		var ^CPropDB.CNode pxMap=m_pxCustomMapStuff^.Get(p_sMap);
		if(pxMap!=null)then
			var string sTmp="TRIBE_"+p_iID.ToString();
			if(pxMap^.Get(sTmp)!=null)then
				p_rsTribe=pxMap^.GetValueS(sTmp,p_rsTribe);
				return true;
			endif;
		endif;
		return false;
	endproc;
	
	export proc bool IsSlotForced(string p_sMap, int p_iID)
		if(m_pxCustomMapStuff==null)then return false; endif;
		var ^CPropDB.CNode pxMap=m_pxCustomMapStuff^.Get(p_sMap);
		if(pxMap!=null)then
			var string sTmp="FORCE_"+p_iID.ToString();
			if(pxMap^.Get(sTmp)!=null)then
				return pxMap^.GetValueI(sTmp,0)==1;
			endif;
		endif;
		return false;
	endproc;
	
	export proc bool GetCustomSettingS(string p_sMap, string p_sSetting, ref string p_rsValue)
		if(m_pxCustomMapStuff==null)then return false; endif;
		var ^CPropDB.CNode pxMap=m_pxCustomMapStuff^.Get(p_sMap);
		if(pxMap!=null)then
			if(pxMap^.Get(p_sSetting)!=null)then
				p_rsValue=pxMap^.GetValueS(p_sSetting,p_rsValue);
				return true;
			endif;
		endif;
		return false;
	endproc;
	
	export proc bool GetCustomSettingI(string p_sMap, string p_sSetting, ref int p_riValue)
		if(m_pxCustomMapStuff==null)then return false; endif;
		var ^CPropDB.CNode pxMap=m_pxCustomMapStuff^.Get(p_sMap);
		if(pxMap!=null)then
			if(pxMap^.Get(p_sSetting)!=null)then
				p_riValue=pxMap^.GetValueI(p_sSetting,p_riValue);
				return true;
			endif;
		endif;
		return false;
	endproc;
	
	//Code from AyCe
	//Henry: the fake buildings names need to be identical is the same procedure in PlaceController.usl
	export proc string UseSmallerGfx(string p_sGfxClass) //Henry: HACK for seas buildings get the placemanager think they are smaller ^^
		if(p_sGfxClass=="seas_big_tent")then
			p_sGfxClass="hu_kennel";
		elseif(p_sGfxClass=="seas_small_tent")then
			p_sGfxClass="hu_kennel";
		elseif(p_sGfxClass=="seas_barracks")then
			p_sGfxClass="hu_kennel";
		elseif(p_sGfxClass=="seas_fortress")then
			p_sGfxClass="hu_kennel";
		elseif(p_sGfxClass=="seas_garage")then
			p_sGfxClass="hu_kennel";
		elseif(p_sGfxClass=="seas_great_cannon")then
			p_sGfxClass="hu_kennel";
		elseif(p_sGfxClass=="seas_final_boss")then
			p_sGfxClass="hu_kennel";
		elseif(p_sGfxClass=="seas_laboratory")then
			p_sGfxClass="hu_kennel";
		elseif(p_sGfxClass=="seas_steelwork")then
			p_sGfxClass="hu_kennel";
		elseif(p_sGfxClass=="seas_mine")then
			p_sGfxClass="hu_kennel";
		elseif(p_sGfxClass=="hu_mine")then
			p_sGfxClass="hu_kennel";
		elseif(p_sGfxClass=="aje_amazon_temple")then
			p_sGfxClass="aje_temple";
		elseif(p_sGfxClass=="aje_small_farm"||p_sGfxClass=="aje_huge_farm")then
			p_sGfxClass = "aje_medium_farm";
		endif;
		return p_sGfxClass;
	endproc;
	
	//New code from AyCe's and mine (till i make also new object brushes...)
	export proc string GetObjBrush(string p_sClass, string p_sGfx)
		if(p_sClass=="seas_hq_machinegun_nest")then
			p_sClass="seas_mg_nest";
		elseif(p_sClass=="seas_hq_defense_turret")then
			p_sClass="seas_small_cannon";
		elseif(p_sClass=="seas_pub"||p_sClass=="seas_small_cannon"||p_sClass=="seas_mg_nest"||p_sClass=="seas_fortress"||p_sClass=="seas_tesla_machine")then
			return p_sClass;
		endif;
		if(p_sGfx=="flying_trader_destroyed")then
			p_sGfx="ninigi_engineer";
		elseif(p_sGfx=="scorpion_controller")then
			p_sGfx="hu_bunker";
		elseif(p_sGfx=="scorpion")then
			p_sGfx="ninigi_dojo";
		elseif(p_sGfx=="seas_mine")then
			p_sGfx="hu_arena";
		elseif(p_sGfx=="seas_hq_big_cannon")then
			p_sGfx="aje_warpgate";
		elseif(p_sGfx=="seas_healspring")then
			p_sGfx="hu_bunker";
		elseif(p_sGfx=="seas_laboratory")then
			p_sGfx="hu_arena";
		elseif(p_sGfx=="horn")then
			p_sGfx="hu_stone_cottage";
		elseif(p_sGfx=="rocket_ramp_control_pad_open")then
			p_sGfx="hu_small_tower";
		elseif(p_sGfx=="seq_hc_watchtower")then
			p_sGfx="hu_bunker";
		elseif(p_sGfx=="amazon_temple")then
			p_sGfx="aje_temple";
		elseif(p_sGfx=="hu_mine")then
			p_sGfx="hu_arena";
		elseif(p_sGfx=="hu_mud_pit")then
			p_sGfx="hu_bunker";
		elseif(p_sGfx=="hu_punching_bag")then
			p_sGfx="hu_bunker";
		endif;
		return p_sGfx;
	endproc;
	
	export proc string GetBuildAction(string p_sClass)
		var string sAction=p_sClass;
		if(p_sClass.IsEmpty())then return sAction; endif;
		if(p_sClass=="aje_archer")then
			sAction="aje_archer_2";
		elseif(p_sClass=="aje_assassin")then
			sAction="aje_assassin_3";
		elseif(p_sClass=="aje_flamethrower")then
			sAction="aje_flamethrower_2";
		elseif(p_sClass=="aje_poisoner")then
			sAction="aje_poisoner_3";
		elseif(p_sClass=="aje_rammer")then
			sAction="aje_rammer_3";
		elseif(p_sClass=="aje_scythian")then
			sAction="aje_scythian_2";
		elseif(p_sClass=="aje_shaman")then
			sAction="aje_shaman_3";
		elseif(p_sClass=="aje_spearman")then
			sAction="aje_spearman_2";
		elseif(p_sClass=="aje_thrower")then
			sAction="aje_thrower_2";
		elseif(p_sClass=="aje_warrior")then
			sAction="aje_warrior_2";
		elseif(p_sClass=="hu_archer")then
			sAction="hu_archer_2";
		elseif(p_sClass=="hu_berserker")then
			sAction="hu_berserker_3";
		elseif(p_sClass=="hu_druid")then
			sAction="hu_druid_3";
		elseif(p_sClass=="hu_flamethrower")then
			sAction="hu_flamethrower_2";
		elseif(p_sClass=="hu_jetpack_warrior")then
			sAction="hu_jetpack_warrior_2";
		elseif(p_sClass=="hu_killer")then
			sAction="hu_killer_3";
		elseif(p_sClass=="hu_marksman")then
			sAction="hu_marksman_2";
		elseif(p_sClass=="hu_pikeman")then
			sAction="hu_pikeman_2";
		elseif(p_sClass=="hu_spearman")then
			sAction="hu_spearman_2";
		elseif(p_sClass=="hu_zombie_warrior")then
			sAction="hu_zombie_warrior_2";
		elseif(p_sClass=="hu_zombie_archer")then
			sAction="hu_zombie_archer_2";
		elseif(p_sClass=="hu_warrior")then
			sAction="hu_warrior_2";
		elseif(p_sClass=="ninigi_archer")then
			sAction="ninigi_archer_2";
		elseif(p_sClass=="ninigi_flamethrower")then
			sAction="ninigi_flamethrower_2";
		elseif(p_sClass=="ninigi_icespearman")then
			sAction="ninigi_icespearman_3";
		elseif(p_sClass=="ninigi_marksman")then
			sAction="ninigi_marksman_2";
		elseif(p_sClass=="ninigi_monk")then
			sAction="ninigi_monk_3";
		elseif(p_sClass=="ninigi_mortar")then
			sAction="ninigi_mortar_2";
		elseif(p_sClass=="ninigi_ninja")then
			sAction="ninigi_ninja_3";
		elseif(p_sClass=="ninigi_spearman")then
			sAction="ninigi_spearman_2";
		elseif(p_sClass=="ninigi_sumo")then
			sAction="ninigi_sumo_3";
		elseif(p_sClass=="ninigi_warrior")then
			sAction="ninigi_warrior_2";
		elseif(p_sClass == "seas_mercenary")then
			sAction = "seas_mercenary_3";
		elseif(p_sClass == "seas_sniper")then
			sAction = "seas_sniper_3";
		elseif(p_sClass=="seas_warrior")then
			sAction="seas_warrior_2";
		endif
		return sAction;
	endproc;
	
	export static proc bool IsCustomMap(^CLevelInfo p_pxLevelInfo)
		var string sName="";
		if(p_pxLevelInfo==null)then return false; endif;
		var ^CPropDB.CNode pxBaseNode=^((p_pxLevelInfo^.GetGenericData())["Base"]);
		if(pxBaseNode!=null)then
			sName=pxBaseNode^.GetValueS("LevelName");
		endif;
		if(sName.Find("BfPW - Highland")!=-1||sName.Find("BfPW - HL")!=-1/*||sName.Find("_CU_MP_6_BFPW_HIGHLAND")!=-1||sName.Find("BfPW - Holy City")!=-1||sName=="_CU_MP_4_ASS_CREED"*/)then
			return true;
		endif;
		return false;
	endproc;
	
	export static proc string GetMapName(^CLevelInfo p_pxLevelInfo)
		var string sName="";
		if(p_pxLevelInfo==null)then return sName; endif;
		var ^CPropDB.CNode pxBaseNode=^((p_pxLevelInfo^.GetGenericData())["Base"]);
		if(pxBaseNode!=null)then
			sName=pxBaseNode^.GetValueS("LevelName");
		endif;
		return sName;
	endproc;
	
	export proc string GetMapNameSimple()
		return m_sMapName;
	endproc;
	
	export proc bool CustomBuildUp(string p_sClass, ref array vec3 p_ravCrane, ref bool p_rbCustom, ref real p_rfStart, ref real p_rfOffset, ref bool p_rbCorpse)
		if(m_pxBuildUp==null)then return false; endif;
		var ^CPropDB.CNode pxClass=m_pxBuildUp^.Get(p_sClass);
		if(pxClass!=null)then
			p_rfStart=pxClass^.GetValueR("StartHeight",0.0);
			p_rfOffset=pxClass^.GetValueR("HeightOffset",0.0);
			p_rbCustom=pxClass^.GetValueI("CustomConstruction",0)==1;
			p_rbCorpse=pxClass^.GetValueI("FakeCorpse",0)==1;
			var ^CPropDB.CNode pxCranes=pxClass^.Get("Cranes");
			if(pxCranes!=null)then
				var int i, iC=pxCranes^.NumSubs();
				var vec3 vCrane={0.0,0.0,0.0};
				for(i=0)cond(i<iC)iter(i++)do
					var ^CPropDB.CNode pxCrane=^(pxCranes^.Get(i));
					if(pxCrane!=null)then
						vCrane.FromString(pxCrane^.Value());
						p_ravCrane.AddEntry(vCrane);
					endif;
				endfor;
			endif;
		else
			p_rbCustom=false;
			p_rbCorpse=false;
			p_ravCrane=0;
			p_rfOffset=0.0f;
			p_rfStart=0.0f;
		endif;
		return true;
	endproc;
	
	export static proc bool AreEqual(CObjList p_xListA, CObjList p_xListB)
		var int i=p_xListA.NumEntries(), iC=p_xListB.NumEntries();
		if(iC!=i||i<0||iC<0)then return false; endif;
		for(i=0)cond(i<iC)iter(i++)do
			if(!(p_xListA[i]==p_xListB[i]))then return false; endif;
		endfor;
		return true;
	endproc;
	
	export proc string GetCodeFromName(string p_sName,string p_sClass)
		if(m_pxCodeFromClass==null)then return p_sName; endif;
		var string sBase=p_sClass+"_";
		if(p_sName.Find(sBase)!=0)then return p_sName; endif;
		var string sCode=m_pxCodeFromClass^.GetValueS(p_sClass);
		if(sCode=="")then return p_sName; endif
		sCode+=p_sName.Mid(p_sClass.GetLength()+1);
		return sCode;
	endproc;
	
	export proc string GetNameFromCode(string p_sCodedName)
		if(m_pxClassFromCode==null)then return p_sCodedName; endif;
		if(p_sCodedName.GetLength()<3)then return p_sCodedName; endif;
		var string sName=m_pxClassFromCode^.GetValueS(p_sCodedName.Left(2));
		if(sName=="")then return p_sCodedName; endif
		sName+="_"+p_sCodedName.Mid(2);
		return sName;
	endproc;
	
	export proc void HardcodeTTFilters(string p_sLevelName, int p_iPlayer, ^CTechTreeDef p_pxTTDef)
		//CMirageSrvMgr.Debug("p_sLevelName: '"+p_sLevelName+"'");
		if(p_sLevelName=="tutorial"||p_sLevelName=="single_01"||p_sLevelName=="single_02")then
			HardcodeTTFilterAAEveryone("CHTR/Larry_s0", p_pxTTDef);
			HardcodeTTFilterAAEveryone("CHTR/Tarna_s0", p_pxTTDef);
			if(p_sLevelName=="single_07"||p_sLevelName=="single_10"||
			p_sLevelName=="single_12"||p_sLevelName=="single_13"||p_sLevelName=="single_14"||
			p_sLevelName=="single_15"||p_sLevelName=="single_16")then
				p_pxTTDef^.EnableFilter("/Filters/SEAS/Upgrades/xenage/old_school_stats");
				p_pxTTDef^.EnableFilter("/Filters/SEAS/Upgrades/xenage/old_school_stats");
			endif;
			if(p_sLevelName=="single_seas_02"&&p_iPlayer==0)then
				p_pxTTDef^.EnableFilter("/Filters/SEAS/Upgrades/xenage/seas_flamethrower_override_leighton");
				p_pxTTDef^.EnableFilter("/Filters/SEAS/Upgrades/xenage/seas_gunner_override_bela");
			endif;
			if(p_sLevelName=="tutorial")then
				p_pxTTDef^.EnableFilter("/Filters/Hu/Build/BLDG/hu_ladder");
			endif;
			if(p_sLevelName=="single_05")then
				p_pxTTDef^.EnableFilter("/Filters/Aje/Upgrades/aje_cook_house/hc_model");
			endif;
			if(p_sLevelName=="single_07")then
				p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Upgrades/aje_medium_tower/tesla_tower");
				p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Upgrades/aje_small_tower/tesla_tower");
			endif;
			if(p_sLevelName=="single_08"||p_sLevelName=="single_b42"||p_sLevelName=="single_b43")then
				p_pxTTDef^.EnableFilter("/Filters/Aje/Upgrades/aje_cook_house/deathshot_visibility");
			endif;
			if(p_sLevelName=="single_b43"||p_sLevelName=="single_b43_seas")then
				p_pxTTDef^.EnableFilter("/Filters/Ninigi/Upgrades/xenage/super_ice_spear");
			endif;
			if(p_sLevelName=="single_11")then
				p_pxTTDef^.EnableFilter("/Filters/Aje/Upgrades/xenage/roguemask");
				p_pxTTDef^.EnableFilter("/Filters/Hu/Upgrades/xenage/roguemask");
				p_pxTTDef^.EnableFilter("/Filters/Ninigi/Upgrades/xenage/roguemask");
				p_pxTTDef^.EnableFilter("/Filters/SEAS/Upgrades/xenage/roguemask");
			endif;
		elseif(p_sLevelName=="_mn_mp_2_arena")then
		//elseif(p_sLevelName=="multi_2_arena_001")then
			p_pxTTDef^.EnableFilter("/Filters/Aje/Upgrades/xenage/roguemask");
			p_pxTTDef^.EnableFilter("/Filters/Hu/Upgrades/xenage/roguemask");
			p_pxTTDef^.EnableFilter("/Filters/Ninigi/Upgrades/xenage/roguemask");
			p_pxTTDef^.EnableFilter("/Filters/SEAS/Upgrades/xenage/roguemask");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/BLDG/aje_amazon_temple");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/BLDG/aje_gallimimus_nest");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/BLDG/aje_sensor_tower");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/BLDG/aje_launchpad_zeppelin");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/BLDG/aje_portal_terminus");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/CHTR/aje_archer_2");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/CHTR/aje_assassin_3");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/CHTR/aje_flamethrower_2");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/CHTR/aje_poisoner_3");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/CHTR/aje_rammer_3");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/CHTR/aje_shaman_3");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/CHTR/aje_spearman_1");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/CHTR/aje_spearman_2");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/CHTR/aje_spearman_3");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/CHTR/aje_thrower_2");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/CHTR/aje_warrior_2");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/CHTR/aje_worker");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_goods");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_launchpad_zeppelin");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_mine");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_mud_pit");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_punching_bag");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_portal_terminus");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Moves/CHTR/entrench");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Ninigi/Build/BLDG/ninigi_launchpad_zeppelin");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Ninigi/Build/BLDG/ninigi_portal_terminus");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/SEAS/Build/BLDG/seas_barracks");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/SEAS/Build/BLDG/seas_big_tent");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/SEAS/Build/BLDG/seas_carrier");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/SEAS/Build/BLDG/seas_disruptor");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/SEAS/Build/BLDG/seas_fence");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/SEAS/Build/BLDG/seas_fortress");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/SEAS/Build/BLDG/seas_garage");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/SEAS/Build/BLDG/seas_gate");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/SEAS/Build/BLDG/seas_great_cannon");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/SEAS/Build/BLDG/seas_greenhouse");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/SEAS/Build/BLDG/seas_headquarters");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/SEAS/Build/BLDG/seas_laboratory");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/SEAS/Build/BLDG/seas_launchpad_zeppelin");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/SEAS/Build/BLDG/seas_mg_nest");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/SEAS/Build/BLDG/seas_mine");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/SEAS/Build/BLDG/seas_portal_terminus");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/SEAS/Build/BLDG/seas_pub");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/SEAS/Build/BLDG/seas_outpouring");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/SEAS/Build/BLDG/seas_small_cannon");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/SEAS/Build/BLDG/seas_small_tent");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/SEAS/Build/BLDG/seas_speaker");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/SEAS/Build/BLDG/seas_steelwork");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/SEAS/Build/BLDG/seas_stygimoloch_nest");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/SEAS/Build/BLDG/seas_tesla_machine");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/SEAS/Build/BLDG/seas_turret_tower");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/SEAS/Build/BLDG/seas_wall");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/SEAS/Build/BLDG/seas_wall_gate");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/SEAS/Build/BLDG/seas_warpgate");
		elseif(p_sLevelName=="divided_world")then
		//elseif(p_sLevelName=="fun_8_dw_1a")then
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_pallisade");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_pallisade_gate");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_small_tower");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_mine");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_portal_terminus");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_punching_bag");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_special_box");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_mud_pit");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_launchpad_zeppelin");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/ANML/hu_carcharadonthosaurus");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/ANML/hu_pteranodon");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/ANML/hu_ballista_titan");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/CHTR/nm_worker_dr");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/CHTR/nm_worker_dc");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/CHTR/nm_worker_ss");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/CHTR/hu_flamethrower");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/CHTR/hu_zombie_warrior");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/CHTR/hu_zombie_archer");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/CHTR/hu_spearman_1");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/CHTR/hu_spearman_3");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/CHTR/hu_archer_1");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/CHTR/hu_archer_3");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Upgrades/hu_temple/meteor");
			p_pxTTDef^.EnableFilter("/Filters/Hu/Upgrades/hu_machine_maker/hu_ballista_damage");
			p_pxTTDef^.EnableFilter("/Filters/Hu/Upgrades/hu_machine_maker/hu_ballista_range");
			p_pxTTDef^.EnableFilter("/Filters/Hu/Upgrades/hu_machine_maker/hu_ballista_frequency");
		elseif(p_sLevelName=="multi_8_nor_bfpw_highland"||p_sLevelName=="bfpw_highland#"||
		p_sLevelName=="bfpw_highland")then
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/BLDG/aje_amazon_temple");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/BLDG/aje_temple");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/BLDG/aje_weapons_builder");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/BLDG/aje_warpgate");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/BLDG/aje_rodeo");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/BLDG/aje_tent");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/BLDG/aje_small_farm");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/BLDG/aje_medium_farm");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/BLDG/aje_huge_farm");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/BLDG/aje_bazaar");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/BLDG/aje_bone_palisade");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/BLDG/aje_bone_palisade_gate");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/BLDG/aje_clay_wall");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/BLDG/aje_clay_wall_gate");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/BLDG/aje_slaughterhouse");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/BLDG/aje_cook_house");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/BLDG/aje_floating_harbour");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/BLDG/aje_small_tower");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/BLDG/aje_medium_tower");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/BLDG/aje_tesla_tower");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/BLDG/aje_scarecrow");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/BLDG/aje_skull_protector");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/BLDG/aje_sensor_tower");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/BLDG/aje_gallimimus_nest");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/BLDG/aje_special_box");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/BLDG/aje_launchpad_zeppelin");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/BLDG/aje_portal_terminus");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_lumberjack_cottage");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_machine_maker");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_magic_cauldron");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_arena");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_bunker");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_corn_field");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_fireplace");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_harbour");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_kennel");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_ladder");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_large_tower");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_launchpad_zeppelin");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_pallisade");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_palisade_gate");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_re_enforced_wall");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_re_enforced_wall_gate");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_small_animal_farm");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_small_tower");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_small_wall");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_small_wall_gate");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_special_box");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_stone_cottage");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_stone_quarry");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_tavern");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_temple");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_warehouse");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_warpgate");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_stone_quarry");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_weapons_smith");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_big_horn");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_punching_bag");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_mine");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_portal_terminus");
			p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/BLDG/hu_mud_pit");
		endif;
	endproc;
	
	export proc void HardcodeTTFilterAAEveryone(string p_sKey, ^CTechTreeDef p_pxTTDef)
		p_pxTTDef^.EnableFilter("/Filters/AntiActions/Hu/Build/"+p_sKey);
		p_pxTTDef^.EnableFilter("/Filters/AntiActions/Aje/Build/"+p_sKey);
		p_pxTTDef^.EnableFilter("/Filters/AntiActions/Ninigi/Build/"+p_sKey);
		p_pxTTDef^.EnableFilter("/Filters/AntiActions/SEAS/Build/"+p_sKey);
	endproc;
	
	export static proc bool SDK()
		var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
		if(pxGame!=null&&pxGame^.IsLevelEd())then return true; endif;
		return false;
	endproc;
	
	export proc bool GetANMLResBack(int p_iPlayer)
		if(p_iPlayer<0||p_iPlayer>8)then return false; endif;
		return m_abANMLResBack[p_iPlayer];
	endproc;
	
	export proc void SetANMLResBack(int p_iPlayer, bool p_bEnable)
		if(p_iPlayer<0||p_iPlayer>7)then return; endif;
		m_abANMLResBack[p_iPlayer]=p_bEnable;
	endproc;
	
	export proc bool GetBLDGResBack(int p_iPlayer)
		if(p_iPlayer<0||p_iPlayer>8)then return false; endif;
		return m_abBLDGResBack[p_iPlayer];
	endproc;
	
	export proc void SetBLDGResBack(int p_iPlayer, bool p_bEnable)
		if(p_iPlayer<0||p_iPlayer>7)then return; endif;
		m_abBLDGResBack[p_iPlayer]=p_bEnable;
	endproc;
	
	export proc bool GetCHTRResBack(int p_iPlayer)
		if(p_iPlayer<0||p_iPlayer>8)then return false; endif;
		return m_abCHTRResBack[p_iPlayer];
	endproc;
	
	export proc void SetCHTRResBack(int p_iPlayer, bool p_bEnable)
		if(p_iPlayer<0||p_iPlayer>7)then return; endif;
		m_abCHTRResBack[p_iPlayer]=p_bEnable;
	endproc;
	
	export proc bool GetSHIPResBack(int p_iPlayer)
		if(p_iPlayer<0||p_iPlayer>8)then return false; endif;
		return m_abSHIPResBack[p_iPlayer];
	endproc;
	
	export proc void SetSHIPResBack(int p_iPlayer, bool p_bEnable)
		if(p_iPlayer<0||p_iPlayer>7)then return; endif;
		m_abSHIPResBack[p_iPlayer]=p_bEnable;
	endproc;
	
	export proc bool GetVHCLResBack(int p_iPlayer)
		if(p_iPlayer<0||p_iPlayer>8)then return false; endif;
		return m_abVHCLResBack[p_iPlayer];
	endproc;
	
	export proc void SetVHCLResBack(int p_iPlayer, bool p_bEnable)
		if(p_iPlayer<0||p_iPlayer>7)then return; endif;
		m_abVHCLResBack[p_iPlayer]=p_bEnable;
	endproc;
	
	export proc bool AllowAttackOwnStuff()
//		return true;
//		return false;
		return m_bAllowAttackOwnStuff;
	endproc;
	
	export proc void SetAttackOwnStuff(bool p_bOn)
		m_bAllowAttackOwnStuff=p_bOn;
	endproc;
	
	export proc void DumpLevelInfo()
		if(true)then
			var ^CLevelInfoHost pxLevelInfo=^(CSrvWrap.GetCurLevel()^.GetLevelInfo());
			if(pxLevelInfo!=null)then
				var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
				pxGenericDB^.Save("C:/LevelInfoHostDumpMirageSrvMgr.txt");
			endif;
		endif;
	endproc;
	
	export static proc void InventAllEpochsForOwner(int p_iOwner, int p_iMax)
		var ^CBasePlayer pxBPlayer=CBasePlayer.GetPlayer(p_iOwner);
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxBPlayer==null||pxLevel==null)then return; endif;
		var ^CAttribs pxAttribs=pxBPlayer^.GetAttribs();
		if(pxAttribs==null)then return; endif;
		var string sTribe=pxBPlayer^.m_sTribe;
		var ^CTechTreeDef pxDef=^(pxBPlayer^.GetPlayerTechTreeDef());
		if(pxDef!=null)then
			var int iMinEpoch=p_iMax;
			var int iX=0;
			var string sFilterAje,sFilterHu,sFilterNinigi,sFilterSEAS,sSuffix;
			if(iMinEpoch>1)then
				iMinEpoch++;
				sFilterAje="/Filters/Aje/Upgrades/aje_resource_collector/";
				sFilterHu="/Filters/Hu/Upgrades/hu_fireplace/";
				sFilterNinigi="/Filters/Ninigi/Upgrades/ninigi_fireplace/";
				sFilterSEAS="/Filters/SEAS/Upgrades/seas_headquarters/";
				var ^CStatisticMgr pxStatisticMgr=^(pxLevel^.GetStatisticMgr());
				for(iX=2)cond(iX<iMinEpoch)iter(iX++)do
					sSuffix="age_"+iX.ToString();
					if(iX==6)then
						sSuffix="final_stage";
					endif;
					if(!pxDef^.HasFilter(sFilterAje+sSuffix))then
						pxDef^.EnableFilter(sFilterAje+sSuffix);
						if(sTribe=="Aje")then
							pxStatisticMgr^.AddSample(CStatisticSample.Epoch.ToInt(), p_iOwner,iX);
						endif;
					endif;
					if(!pxDef^.HasFilter(sFilterHu+sSuffix))then
						pxDef^.EnableFilter(sFilterHu+sSuffix);
						if(sTribe=="Hu")then
							pxStatisticMgr^.AddSample(CStatisticSample.Epoch.ToInt(), p_iOwner,iX);
						endif;
					endif;
					if(!pxDef^.HasFilter(sFilterNinigi+sSuffix))then
						pxDef^.EnableFilter(sFilterNinigi+sSuffix);
						if(sTribe=="Ninigi")then
							pxStatisticMgr^.AddSample(CStatisticSample.Epoch.ToInt(), p_iOwner,iX);
						endif;
					endif;
					if(!pxDef^.HasFilter(sFilterSEAS+sSuffix))then
						pxDef^.EnableFilter(sFilterSEAS+sSuffix);
						if(sTribe=="SEAS")then
							pxStatisticMgr^.AddSample(CStatisticSample.Epoch.ToInt(), p_iOwner,iX);
						endif;
					endif;
				endfor;
			endif;
			var int iOldAge=pxAttribs^.GetValueInt("age");
			if(iOldAge!=p_iMax&&iOldAge<p_iMax)then
				pxAttribs^.SetValue("age", p_iMax);
			endif;
		endif;
		pxBPlayer^.CheckEpochs();
	endproc;
	
	export static proc void InventUpgradeForOwner(int p_iOwner, string p_sPath)
		var ^CBasePlayer pxBPlayer=CBasePlayer.GetPlayer(p_iOwner);
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxBPlayer==null||pxLevel==null)then return; endif;
		var ^CTechTreeDef pxDef=^(pxBPlayer^.GetPlayerTechTreeDef());
		if(pxDef!=null)then
			if(!pxDef^.HasFilter(p_sPath))then
				pxDef^.EnableFilter(p_sPath);
			endif;
		endif;
	endproc;
	
	export static proc void ProduceCustomUnit(string p_sClass, int p_iOwner, vec3 p_vPos, int p_iLevel, string p_sFlag)
		var ^CFightingObj pxO=cast<CFightingObj>(CSrvWrap.GetObjMgr()^.CreateObj(p_sClass,p_iOwner,p_vPos));
		if(pxO!=null)then
			pxO^.SetLevelClean(p_iLevel);
			if(p_sFlag!="")then
				var ^CTechTreeDef pxTechTreeDef=pxO^.GetTechTreeDef();
				if(pxTechTreeDef!=null)then
					pxTechTreeDef^.EnableFilter(p_sFlag);
					if(pxO^.GetType()=="ANML")then
						(cast<CAnimal>(pxO))^.HandleAction(p_sFlag.Mid(p_sFlag.FindRev('/')+1));
					elseif(pxO^.GetType()=="VHCL")then
						(cast<CVehicle>(pxO))^.HandleAction(p_sFlag.Mid(p_sFlag.FindRev('/')+1));
					endif;
				endif;
			endif;
		endif;
	endproc;
	
	export proc void CheckAllVariableCondition(string p_sVar)
		var ^CTriggerMgr pxTM = ^(CSrvWrap.GetTriggerMgr());
		var int i,iC=pxTM^.NumTrigger();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CTrigger pxWalkTrigger=pxTM^.GetTrigger(i);
			if(pxWalkTrigger==null)then continue; endif;
			var int k,kC=pxWalkTrigger^.NumConditions();
			for(k=0)cond(k<kC)iter(k++)do
				var ^CConditionVars pxCondVar=cast<CConditionVars>(pxWalkTrigger^.GetCondition(k));
				if(pxCondVar==null)then continue; endif;
				if(pxCondVar^.GetVariable()==p_sVar)then
					var CEvtPointer xEvt;
					pxCondVar^.OnPush(xEvt);
					break;
				endif;
			endfor;
		endfor;
	endproc;
	
	class CNestInfo
	
		export var string m_sName;
		export var string m_sClass;
		export var string m_sSpawnType;
		export var int m_iSpawnAmount;
		export var int m_iSpawnMax;
		export var real m_fSpawnRate;
//		export var string m_sPreAnimals;
		export var real m_fAdvTime;
		export var string m_sHotTable;
		export var vec3 m_vPos;
		export var Quat m_qRot;
		export var int m_iOwner;
		export var bool m_bVisible;
		export var bool m_bHitable;
		export var bool m_bSelectable;
		export var array vec3 m_avActionSubsPos;
		export var array vec3 m_avActionSubsExt;
		export var array bitset m_adwActionSubsType;
		export var array bool m_abActionEnabled;
		export var array vec3 m_avSafeSubsPos;
		export var array vec3 m_avSafeSubsExt;
		export var array bitset m_adwSafeSubsType;
		export var array bool m_abSafeEnabled;
		export var array vec3 m_avHotspotSubsPos;
		export var array vec3 m_avHotspotSubsExt;
		export var array bitset m_adwHotspotSubsType;
		export var array bool m_abHotspotEnabled;
		
		export proc bool op_Greater(ref CMirageSrvMgr.CNestInfo p_rxOther)
			return m_sName>p_rxOther.m_sName;
		endproc;
		
		export proc void SaveRegionsData(^CRegion p_pxAction, ^CRegion p_pxSafe, ^CRegion p_pxHotspot)
			if(p_pxAction==null||p_pxSafe==null||p_pxHotspot==null)then return; endif;
			var int k, kC=p_pxAction^.NumSubs();
			for(k=0)cond(k<kC)iter(k++)do
				var ^CSubRegion pxSub = p_pxAction^[k];
				if(pxSub!=null)then
					var vec3 vExt, vSub=pxSub^.GetPos();
					m_avActionSubsPos.AddEntry(vSub);
					var string sPos=pxSub^.ToString();
					sPos=sPos.Mid(sPos.Find("Ext: ")+5);
					vExt.FromString(sPos);
					m_avActionSubsExt.AddEntry(vExt);
					m_abActionEnabled.AddEntry(pxSub^.GetEnable());
					m_adwActionSubsType.AddEntry(pxSub^.GetType());
				endif;
			endfor;
			kC=p_pxSafe^.NumSubs();
			for(k=0)cond(k<kC)iter(k++)do
				var ^CSubRegion pxSub = p_pxSafe^[k];
				if(pxSub!=null)then
					var vec3 vExt, vSub=pxSub^.GetPos();
					m_avSafeSubsPos.AddEntry(vSub);
					var string sPos=pxSub^.ToString();
					sPos=sPos.Mid(sPos.Find("Ext: ")+5);
					vExt.FromString(sPos);
					m_avSafeSubsExt.AddEntry(vExt);
					m_abSafeEnabled.AddEntry(pxSub^.GetEnable());
					m_adwSafeSubsType.AddEntry(pxSub^.GetType());
				endif;
			endfor;
			kC=p_pxHotspot^.NumSubs();
			for(k=0)cond(k<kC)iter(k++)do
				var ^CSubRegion pxSub = p_pxHotspot^[k];
				if(pxSub!=null)then
					var vec3 vExt, vSub=pxSub^.GetPos();
					m_avHotspotSubsPos.AddEntry(vSub);
					var string sPos=pxSub^.ToString();
					sPos=sPos.Mid(sPos.Find("Ext: ")+5);
					vExt.FromString(sPos);
					m_avHotspotSubsExt.AddEntry(vExt);
					m_abHotspotEnabled.AddEntry(pxSub^.GetEnable());
					m_adwHotspotSubsType.AddEntry(pxSub^.GetType());
				endif;
			endfor;
		endproc;
		
		export proc void DoKArcSave(ref CArc p_rxArc)
			p_rxArc << m_sName;
			p_rxArc << m_sClass;
			p_rxArc << m_sSpawnType;
			p_rxArc << m_iSpawnAmount;
			p_rxArc << m_iSpawnMax;
			p_rxArc << m_fSpawnRate;
			p_rxArc << m_fAdvTime;
			p_rxArc << m_sHotTable;
			p_rxArc << m_vPos;
			p_rxArc << m_qRot;
			p_rxArc << m_bVisible;
			p_rxArc << m_bHitable;
			p_rxArc << m_bSelectable;
			p_rxArc << m_iOwner;
			var int i, iC = m_abActionEnabled.NumEntries();
			p_rxArc << iC;
			for(i=0)cond(i<iC)iter(++i)do
				p_rxArc << m_avActionSubsPos[i];
				p_rxArc << m_avActionSubsExt[i];
				p_rxArc << m_abActionEnabled[i];
				p_rxArc << m_adwActionSubsType[i];
			endfor;
			iC = m_abSafeEnabled.NumEntries();
			p_rxArc << iC;
			for(i=0)cond(i<iC)iter(++i)do
				p_rxArc << m_avSafeSubsPos[i];
				p_rxArc << m_avSafeSubsExt[i];
				p_rxArc << m_abSafeEnabled[i];
				p_rxArc << m_adwSafeSubsType[i];
			endfor;
			iC = m_abHotspotEnabled.NumEntries();
			p_rxArc << iC;
			for(i=0)cond(i<iC)iter(++i)do
				p_rxArc << m_avHotspotSubsPos[i];
				p_rxArc << m_avHotspotSubsExt[i];
				p_rxArc << m_abHotspotEnabled[i];
				p_rxArc << m_adwHotspotSubsType[i];
			endfor;
		endproc;
		
		export proc void DoKArcLoad(ref CArc p_rxArc)
			p_rxArc << m_sName;
			p_rxArc << m_sClass;
			p_rxArc << m_sSpawnType;
			p_rxArc << m_iSpawnAmount;
			p_rxArc << m_iSpawnMax;
			p_rxArc << m_fSpawnRate;
			p_rxArc << m_fAdvTime;
			p_rxArc << m_sHotTable;
			p_rxArc << m_vPos;
			p_rxArc << m_qRot;
			p_rxArc << m_bVisible;
			p_rxArc << m_bHitable;
			p_rxArc << m_bSelectable;
			p_rxArc << m_iOwner;
			var int i, iC;
			p_rxArc << iC;
			m_avActionSubsPos=iC;
			m_avActionSubsExt=iC;
			m_abActionEnabled=iC;
			m_adwActionSubsType=iC;
			for(i=0)cond(i<iC)iter(++i)do
				p_rxArc << m_avActionSubsPos[i];
				p_rxArc << m_avActionSubsExt[i];
				p_rxArc << m_abActionEnabled[i];
				p_rxArc << m_adwActionSubsType[i];
			endfor;
			p_rxArc << iC;
			m_avSafeSubsPos=iC;
			m_avSafeSubsExt=iC;
			m_abSafeEnabled=iC;
			m_adwSafeSubsType=iC;
			for(i=0)cond(i<iC)iter(++i)do
				p_rxArc << m_avSafeSubsPos[i];
				p_rxArc << m_avSafeSubsExt[i];
				p_rxArc << m_abSafeEnabled[i];
				p_rxArc << m_adwSafeSubsType[i];
			endfor;
			p_rxArc << iC;
			m_avHotspotSubsPos=iC;
			m_avHotspotSubsExt=iC;
			m_abHotspotEnabled=iC;
			m_adwHotspotSubsType=iC;
			for(i=0)cond(i<iC)iter(++i)do
				p_rxArc << m_avHotspotSubsPos[i];
				p_rxArc << m_avHotspotSubsExt[i];
				p_rxArc << m_abHotspotEnabled[i];
				p_rxArc << m_adwHotspotSubsType[i];
			endfor;
		endproc;
		
		export proc void CreateNest(^CObjMgrHost p_pxObjMgr)
			if(p_pxObjMgr==null)then return; endif;
			var ^CNest pxNest = cast<CNest>(p_pxObjMgr^.CreateObj(m_sClass,-1,m_vPos));
			if(pxNest==null)then return; endif;
			var ^CAttribs pxA=pxNest^.GetAttribs();
			if(pxA==null)then return; endif;
			pxNest^.SetOwner(m_iOwner);
			pxNest^.SetRot(m_qRot);
			pxNest^.SetHitable(m_bHitable);
			pxNest^.SetSelectable(m_bSelectable);
			pxNest^.SetVisible(m_bVisible);
//			pxNest^.SetName(m_sName);
			pxA^.SetValue("spawn_type",m_sSpawnType);
			pxA^.SetValue("hotspot_timetable",m_sHotTable);
			pxA^.SetValue("spawn_max",m_iSpawnMax);
			pxA^.SetValue("spawn_amount",m_iSpawnAmount);
			pxA^.SetValue("spawn_rate",m_fSpawnRate);
			pxA^.SetValue("advance_time",m_fAdvTime);
			pxNest^.NewRegions(0,m_avActionSubsPos,m_avActionSubsExt,m_abActionEnabled,m_adwActionSubsType);
			pxNest^.NewRegions(1,m_avSafeSubsPos,m_avSafeSubsExt,m_abSafeEnabled,m_adwSafeSubsType);
			pxNest^.NewRegions(2,m_avHotspotSubsPos,m_avHotspotSubsExt,m_abHotspotEnabled,m_adwHotspotSubsType);
		endproc;
		
	endclass;
	
	var array CNestInfo m_axNests;
	
	export proc void RegisterNest(^CNest p_pxNest, ^CAttribs p_pxAttr)
		if(p_pxNest==null||p_pxAttr==null)then return; endif;
		var ^CNestInfo pxNI=^(m_axNests.NewEntryRef());
		pxNI^.m_sName=p_pxNest^.GetName();
		pxNI^.m_sClass=p_pxNest^.GetClassName();
		pxNI^.m_sSpawnType=p_pxAttr^.GetValue("spawn_type");
		pxNI^.m_iSpawnAmount=p_pxAttr^.GetValueInt("spawn_amount");
		pxNI^.m_iSpawnMax=p_pxAttr^.GetValueInt("spawn_max");
		pxNI^.m_fSpawnRate=p_pxAttr^.GetValueFloat("spawn_rate");
		pxNI^.m_fAdvTime=p_pxAttr^.GetValueFloat("advance_time");
		pxNI^.m_sHotTable=p_pxAttr^.GetValue("hotspot_timetable");
		pxNI^.m_vPos=p_pxNest^.GetPos();
		pxNI^.m_qRot=p_pxNest^.GetRot();
		pxNI^.m_iOwner=p_pxNest^.GetOwner();
		pxNI^.m_bVisible=p_pxNest^.GetVisibleMask()!=0h;
		pxNI^.m_bHitable=p_pxNest^.IsHitable();
		pxNI^.m_bSelectable=p_pxNest^.IsSelectable();
		pxNI^.SaveRegionsData(p_pxNest^.GetActionAreaPtr(),p_pxNest^.GetSafeAreaPtr(),p_pxNest^.GetHotspotAreaPtr()/*,p_pxNest^.GetToleranceAreaPtr()*/);
		m_axNests.QSort();
	endproc;
	
	export proc void SaveNestInfos(string p_sFile)
		var ^CArc pxArc= new CArc();
		pxArc^.OpenWrite("C:\\"+p_sFile+"_nests.arc",0);
		var int i, iC=m_axNests.NumEntries();
		(pxArc^) << iC;
		for(i=0)cond(i<iC)iter(i++)do
			m_axNests[i].DoKArcSave(pxArc^);
		endfor;
		pxArc^.Close();
	endproc;
	
	export proc void LoadNestInfos(string p_sFile)
		var ^CObjMgrHost pxObjMgr=CSrvWrap.GetObjMgr();
		if(pxObjMgr==null)then return; endif;
		var ^CArc pxArc= new CArc();
		pxArc^.OpenRead("C:\\"+p_sFile+"_nests.arc");
		var int i, iC;
		(pxArc^) << iC;
		for(i=0)cond(i<iC)iter(i++)do
			var ^CMirageSrvMgr.CNestInfo pxNI=^(m_axNests.NewEntryRef());
			pxNI^.DoKArcLoad(pxArc^);
		endfor;
		pxArc^.Close();
		iC=m_axNests.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			m_axNests[i].CreateNest(pxObjMgr);
		endfor;
		while(m_axNests.NumEntries()>0)do
			m_axNests.DeleteEntry(0);
		endwhile;
	endproc;
	
	export static proc bool SkipTolerance()
		if(CMirageSrvMgr.SDK())then
			var CConfig xConf;
			var bool bSkip=xConf.GetB("Game/SkipTolerance",true);
			return bSkip;
		endif;
		return false;
	endproc;
	
	export static proc bool SkipOrphans()
		if(CMirageSrvMgr.SDK())then
			var CConfig xConf;
			var bool bSkip=xConf.GetB("Game/SkipOrphans",false);
			return bSkip;
		endif;
		return false;
	endproc;
	
	class CResourceInfo
	
		export var string m_sName;
		export var string m_sClass;
		export var vec3 m_vPos;
		export var Quat m_qRot;
		export var int m_iOwner;
		export var int m_iValue;
		export var bool m_bVisible;
		export var bool m_bHitable;
		export var bool m_bSelectable;
		
		export proc bool op_Greater(ref CMirageSrvMgr.CResourceInfo p_rxOther)
			return m_sName>p_rxOther.m_sName;
		endproc;
		
		export proc void DoKArcSave(ref CArc p_rxArc)
			p_rxArc << m_sName;
			p_rxArc << m_sClass;
			p_rxArc << m_iOwner;
			p_rxArc << m_iValue;
			p_rxArc << m_vPos;
			p_rxArc << m_qRot;
			p_rxArc << m_bVisible;
			p_rxArc << m_bHitable;
			p_rxArc << m_bSelectable;
		endproc;
		
		export proc void DoKArcLoad(ref CArc p_rxArc)
			p_rxArc << m_sName;
			p_rxArc << m_sClass;
			p_rxArc << m_iOwner;
			p_rxArc << m_iValue;
			p_rxArc << m_vPos;
			p_rxArc << m_qRot;
			p_rxArc << m_bVisible;
			p_rxArc << m_bHitable;
			p_rxArc << m_bSelectable;
		endproc;
		
		export proc void CreateResource(^CObjMgrHost p_pxObjMgr)
			if(p_pxObjMgr==null)then return; endif;
			var ^CResource pxResource = cast<CResource>(p_pxObjMgr^.CreateObj(m_sClass,-1,m_vPos));
			if(pxResource==null)then return; endif;
			var ^CAttribs pxA=pxResource^.GetAttribs();
			if(pxA==null)then return; endif;
			pxResource^.SetOwner(m_iOwner);
			pxResource^.SetRot(m_qRot);
			pxResource^.SetHitable(m_bHitable);
			pxResource^.SetSelectable(m_bSelectable);
			pxResource^.SetVisible(m_bVisible);
			pxA^.SetValue("value",m_iValue);
		endproc;
		
	endclass;
	
	var array CResourceInfo m_axResources;
	
	export proc void RegisterResource(^CResource p_pxResource, ^CAttribs p_pxAttr)
		if(p_pxResource==null||p_pxAttr==null)then return; endif;
		var ^CResourceInfo pxRI=^(m_axResources.NewEntryRef());
		pxRI^.m_sName=p_pxResource^.GetName();
		pxRI^.m_sClass=p_pxResource^.GetClassName();
		pxRI^.m_iValue=p_pxAttr^.GetValueInt("value");
		pxRI^.m_vPos=p_pxResource^.GetPos();
		pxRI^.m_qRot=p_pxResource^.GetRot();
		pxRI^.m_iOwner=p_pxResource^.GetOwner();
		pxRI^.m_bVisible=p_pxResource^.GetVisibleMask()!=0h;
		pxRI^.m_bHitable=p_pxResource^.IsHitable();
		pxRI^.m_bSelectable=p_pxResource^.IsSelectable();
		m_axResources.QSort();
	endproc;
	
	export proc void SaveResourceInfos(string p_sFile)
		var ^CArc pxArc= new CArc();
		pxArc^.OpenWrite("C:\\"+p_sFile+"_resources.arc",0);
		var int i, iC=m_axResources.NumEntries();
		(pxArc^) << iC;
		for(i=0)cond(i<iC)iter(i++)do
			m_axResources[i].DoKArcSave(pxArc^);
		endfor;
		pxArc^.Close();
	endproc;
	
	export proc void LoadResourceInfos(string p_sFile)
		var ^CObjMgrHost pxObjMgr=CSrvWrap.GetObjMgr();
		if(pxObjMgr==null)then return; endif;
		var ^CArc pxArc= new CArc();
		pxArc^.OpenRead("C:\\"+p_sFile+"_resources.arc");
		var int i, iC;
		(pxArc^) << iC;
		for(i=0)cond(i<iC)iter(i++)do
			var ^CMirageSrvMgr.CResourceInfo pxRI=^(m_axResources.NewEntryRef());
			pxRI^.DoKArcLoad(pxArc^);
		endfor;
		pxArc^.Close();
		iC=m_axResources.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			m_axResources[i].CreateResource(pxObjMgr);
		endfor;
		while(m_axResources.NumEntries()>0)do
			m_axResources.DeleteEntry(0);
		endwhile;
	endproc;
	
	class CIdiObjectInfo
	
		export var string m_sName;
		export var string m_sClass;
		export var vec3 m_vPos;
		export var Quat m_qRot;
		export var int m_iOwner;
		export var bool m_bVisible;
		export var bool m_bHitable;
		export var bool m_bSelectable;
		
		export proc bool op_Greater(ref CMirageSrvMgr.CIdiObjectInfo p_rxOther)
			return m_sName>p_rxOther.m_sName;
		endproc;
		
		export proc void DoKArcSave(ref CArc p_rxArc)
			p_rxArc << m_sName;
			p_rxArc << m_sClass;
			p_rxArc << m_iOwner;
			p_rxArc << m_vPos;
			p_rxArc << m_qRot;
			p_rxArc << m_bVisible;
			p_rxArc << m_bHitable;
			p_rxArc << m_bSelectable;
		endproc;
		
		export proc void DoKArcLoad(ref CArc p_rxArc)
			p_rxArc << m_sName;
			p_rxArc << m_sClass;
			p_rxArc << m_iOwner;
			p_rxArc << m_vPos;
			p_rxArc << m_qRot;
			p_rxArc << m_bVisible;
			p_rxArc << m_bHitable;
			p_rxArc << m_bSelectable;
		endproc;
		
		export proc void CreateIdiObject(^CObjMgrHost p_pxObjMgr)
			if(p_pxObjMgr==null)then return; endif;
			var ^CGameObj pxIdiObject = p_pxObjMgr^.CreateObj(m_sClass,-1,m_vPos);
			if(pxIdiObject==null)then return; endif;
			pxIdiObject^.SetOwner(m_iOwner);
			pxIdiObject^.SetRot(m_qRot);
			pxIdiObject^.SetHitable(m_bHitable);
			pxIdiObject^.SetSelectable(m_bSelectable);
			pxIdiObject^.SetVisible(m_bVisible);
		endproc;
		
	endclass;
	
	var array CIdiObjectInfo m_axIdiObjects;
	
	export proc void RegisterIdiObject(^CGameObj p_pxIdiObject)
		if(p_pxIdiObject==null)then return; endif;
		var ^CIdiObjectInfo pxII=^(m_axIdiObjects.NewEntryRef());
		pxII^.m_sName=p_pxIdiObject^.GetName();
		pxII^.m_sClass=p_pxIdiObject^.GetClassName();
		pxII^.m_vPos=p_pxIdiObject^.GetPos();
		pxII^.m_qRot=p_pxIdiObject^.GetRot();
		pxII^.m_iOwner=p_pxIdiObject^.GetOwner();
		pxII^.m_bVisible=p_pxIdiObject^.GetVisibleMask()!=0h;
		pxII^.m_bHitable=p_pxIdiObject^.IsHitable();
		pxII^.m_bSelectable=p_pxIdiObject^.IsSelectable();
		m_axIdiObjects.QSort();
	endproc;
	
	export proc void SaveIdiObjectInfos(string p_sFile)
		var ^CArc pxArc= new CArc();
		pxArc^.OpenWrite("C:\\"+p_sFile+"_idiobjects.arc",0);
		var int i, iC=m_axIdiObjects.NumEntries();
		CMirageSrvMgr.Debug("num of IdiObjects: '"+(iC).ToString()+"'");
		(pxArc^) << iC;
		for(i=0)cond(i<iC)iter(i++)do
			m_axIdiObjects[i].DoKArcSave(pxArc^);
		endfor;
		pxArc^.Close();
		while(m_axIdiObjects.NumEntries()>0)do
			m_axIdiObjects.DeleteEntry(0);
		endwhile;
	endproc;
	
	export proc void LoadIdiObjectInfos(string p_sFile)
		var ^CObjMgrHost pxObjMgr=CSrvWrap.GetObjMgr();
		if(pxObjMgr==null)then return; endif;
		var ^CArc pxArc= new CArc();
		pxArc^.OpenRead("C:\\"+p_sFile+"_idiobjects.arc");
		var int i, iC;
		(pxArc^) << iC;
		for(i=0)cond(i<iC)iter(i++)do
			var ^CMirageSrvMgr.CIdiObjectInfo pxII=^(m_axIdiObjects.NewEntryRef());
			pxII^.DoKArcLoad(pxArc^);
		endfor;
		pxArc^.Close();
		iC=m_axIdiObjects.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			m_axIdiObjects[i].CreateIdiObject(pxObjMgr);
		endfor;
		while(m_axIdiObjects.NumEntries()>0)do
			m_axIdiObjects.DeleteEntry(0);
		endwhile;
	endproc;
	
	class CGameObjectInfo
	
		export var string m_sName;
		export var string m_sClass;
		export var vec3 m_vPos;
		export var Quat m_qRot;
		export var int m_iOwner;
		export var bool m_bVisible;
		export var bool m_bHitable;
		export var bool m_bSelectable;
		export var bool m_bConstructible;
		export var bool m_bDeconstructible;
		export var bool m_bIsDestructible;
		export var bool m_bIsDisableShadowCast;
		export var bool m_bIsDisableShadowReceive;
		export var array string m_asKeys;
		export var array string m_asValues;
		
		export proc bool op_Greater(ref CMirageSrvMgr.CGameObjectInfo p_rxOther)
			return m_sName>p_rxOther.m_sName;
		endproc;
		
		export proc void DoKArcSave(ref CArc p_rxArc)
			p_rxArc << m_sName;
			p_rxArc << m_sClass;
			p_rxArc << m_iOwner;
			p_rxArc << m_vPos;
			p_rxArc << m_qRot;
			p_rxArc << m_bVisible;
			p_rxArc << m_bHitable;
			p_rxArc << m_bSelectable;
			p_rxArc << m_bConstructible;
			p_rxArc << m_bDeconstructible;
			p_rxArc << m_bIsDestructible;
			p_rxArc << m_bIsDisableShadowCast;
			p_rxArc << m_bIsDisableShadowReceive;
			var int i, iC = m_asKeys.NumEntries();
			p_rxArc << iC;
			for(i=0)cond(i<iC)iter(i++)do
				p_rxArc << m_asKeys[i];
				p_rxArc << m_asValues[i];
			endfor;
		endproc;
		
		export proc void DoKArcLoad(ref CArc p_rxArc)
			p_rxArc << m_sName;
			p_rxArc << m_sClass;
			p_rxArc << m_iOwner;
			p_rxArc << m_vPos;
			p_rxArc << m_qRot;
			p_rxArc << m_bVisible;
			p_rxArc << m_bHitable;
			p_rxArc << m_bSelectable;
			p_rxArc << m_bConstructible;
			p_rxArc << m_bDeconstructible;
			p_rxArc << m_bIsDestructible;
			p_rxArc << m_bIsDisableShadowCast;
			p_rxArc << m_bIsDisableShadowReceive;
			var int i, iC;
			p_rxArc << iC;
			m_asKeys=iC;
			m_asValues=iC;
			for(i=0)cond(i<iC)iter(i++)do
				p_rxArc << m_asKeys[i];
				p_rxArc << m_asValues[i];
			endfor;
		endproc;
		
		export proc void CreateGameObject(^CObjMgrHost p_pxObjMgr)
			if(p_pxObjMgr==null)then return; endif;
			var ^CGameObj pxGameObject = p_pxObjMgr^.CreateObj(m_sClass,-1,m_vPos);
			if(pxGameObject==null)then return; endif;
			pxGameObject^.SetOwner(m_iOwner);
			pxGameObject^.SetRot(m_qRot);
			pxGameObject^.SetHitable(m_bHitable);
			pxGameObject^.SetSelectable(m_bSelectable);
			pxGameObject^.SetVisible(m_bVisible);
			pxGameObject^.SetConstructible(m_bConstructible);
			pxGameObject^.SetDeconstructible(m_bDeconstructible);
			pxGameObject^.SetDestructible(m_bIsDestructible);
			pxGameObject^.SetDisableShadowCast(m_bIsDisableShadowCast);
			pxGameObject^.SetDisableShadowReceive(m_bIsDisableShadowReceive);
			var ^CAttribs pxA=pxGameObject^.GetAttribs();
			if(pxA==null)then return; endif;
			var int i, iC = m_asKeys.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				pxA^.SetValue(m_asKeys[i],m_asValues[i]);
			endfor;
		endproc;
		
	endclass;
	
	var array CGameObjectInfo m_axGameObjects;
	
	export proc void RegisterGameObject(^CGameObj p_pxGameObject)
		if(p_pxGameObject==null)then return; endif;
		var ^CGameObjectInfo pxGI=^(m_axGameObjects.NewEntryRef());
		pxGI^.m_sName=p_pxGameObject^.GetName();
		pxGI^.m_sClass=p_pxGameObject^.GetClassName();
		pxGI^.m_vPos=p_pxGameObject^.GetPos();
		pxGI^.m_qRot=p_pxGameObject^.GetRot();
		pxGI^.m_iOwner=p_pxGameObject^.GetOwner();
		pxGI^.m_bVisible=p_pxGameObject^.GetVisibleMask()!=0h;
		pxGI^.m_bHitable=p_pxGameObject^.IsHitable();
		pxGI^.m_bSelectable=p_pxGameObject^.IsSelectable();
		pxGI^.m_bConstructible=p_pxGameObject^.IsConstructible();
		pxGI^.m_bDeconstructible=p_pxGameObject^.IsDeconstructible();
		pxGI^.m_bIsDestructible=p_pxGameObject^.IsDestructible();
		pxGI^.m_bIsDisableShadowCast=p_pxGameObject^.IsDisableShadowCast();
		pxGI^.m_bIsDisableShadowReceive=p_pxGameObject^.IsDisableShadowReceive();
		var ^CAttribs pxA=p_pxGameObject^.GetAttribs();
		if(pxA==null)then return; endif;
		var int i, iC = pxA^.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var string sKey, sValue;
			if(pxA^.GetEntry(i, sKey, sValue))then
				pxGI^.m_asKeys.AddEntry(sKey);
				pxGI^.m_asValues.AddEntry(sValue);
			endif;
		endfor;
		m_axGameObjects.QSort();
	endproc;
	
	export proc void SaveGameObjectInfos(string p_sFile)
		var ^CArc pxArc= new CArc();
		pxArc^.OpenWrite("C:\\"+p_sFile+"_gameobjects.arc",0);
		var int i, iC=m_axGameObjects.NumEntries();
		(pxArc^) << iC;
		for(i=0)cond(i<iC)iter(i++)do
			m_axGameObjects[i].DoKArcSave(pxArc^);
		endfor;
		pxArc^.Close();
		while(m_axGameObjects.NumEntries()>0)do
			m_axGameObjects.DeleteEntry(0);
		endwhile;
	endproc;
	
	export proc void LoadGameObjectInfos(string p_sFile)
		var ^CObjMgrHost pxObjMgr=CSrvWrap.GetObjMgr();
		if(pxObjMgr==null)then return; endif;
		var ^CArc pxArc= new CArc();
		pxArc^.OpenRead("C:\\"+p_sFile+"_gameobjects.arc");
		var int i, iC;
		(pxArc^) << iC;
		for(i=0)cond(i<iC)iter(i++)do
			var ^CMirageSrvMgr.CGameObjectInfo pxGI=^(m_axGameObjects.NewEntryRef());
			pxGI^.DoKArcLoad(pxArc^);
		endfor;
		pxArc^.Close();
		iC=m_axGameObjects.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			m_axGameObjects[i].CreateGameObject(pxObjMgr);
		endfor;
		while(m_axGameObjects.NumEntries()>0)do
			m_axGameObjects.DeleteEntry(0);
		endwhile;
	endproc;
	
	export proc void SaveRegions(string p_sFile)
		var ^CPropDB pxSource=new CPropDB;
		var ^CPropDB.CNode pxRegionGuids;
//		if(pxSource^.Load(CSrvWrap.GetUrsRelPath()+"/Data/Base/Scripts/Server/settings/custom_maps/"+p_sFile+"_region_source.txt"))then
		if(pxSource^.Load("C:/"+p_sFile+"_region_source.txt"))then
			pxRegionGuids=^((pxSource^).GetRoot());
		endif;
		if(pxRegionGuids==null)then return; endif;
		var ^CRegionMgr pxRM=^(CSrvWrap.GetRegionMgr());
		if(pxRM==null)then return; endif;
		var ^CRegion pxRegion;
		var string sGuid, sName;
		var CGuid xG;
		var int i, iC=pxRegionGuids^.NumSubs();
		if(iC<1)then return; endif;
		var ^CArc pxArc= new CArc();
		pxArc^.OpenWrite("C:\\"+p_sFile+"_regions.arc",0);
		(pxArc^) << iC;
		for(i=0)cond(i<iC)iter(i++)do
			sGuid=pxRegionGuids^.GetValueS("region_"+i.ToString(),"");
			xG.FromString(sGuid);
			pxRegion=pxRM^.GetRegionByGuid(xG);
			if(pxRegion==null)then continue; endif;
			sName=pxRegion^.GetName();
			(pxArc^) << sGuid;
			(pxArc^) << sName;
			var int k, kC=pxRegion^.NumSubs();
			var array vec3 avPos, avExt;
			var array bitset adwType, adwGroups;
			var array bool abEnabled;
			for(k=0)cond(k<kC)iter(k++)do
				var ^CSubRegion pxSub = pxRegion^[k];
				if(pxSub!=null)then
					var vec3 vExt, vSub=pxSub^.GetPos();
					avPos.AddEntry(vSub);
					var string sPos=pxSub^.ToString();
					sPos=sPos.Mid(sPos.Find("Ext: ")+5);
					vExt.FromString(sPos);
					avExt.AddEntry(vExt);
					adwType.AddEntry(pxSub^.GetType());
					adwGroups.AddEntry(pxSub^.GetGroups());
					abEnabled.AddEntry(pxSub^.GetEnable());
				endif;
			endfor;
			kC=avPos.NumEntries();
			(pxArc^) << kC;
			for(k=0)cond(k<kC)iter(k++)do
				(pxArc^) << avPos[k];
				(pxArc^) << avExt[k];
				(pxArc^) << adwType[k];
				(pxArc^) << adwGroups[k];
				(pxArc^) << abEnabled[k];
			endfor;
		endfor;
		pxArc^.Close();
	endproc;
	
	export proc void LoadRegions(string p_sFile)
		var ^CRegionMgr pxRM=^(CSrvWrap.GetRegionMgr());
		if(pxRM==null)then return; endif;
		var ^CArc pxArc= new CArc();
		pxArc^.OpenRead("C:\\"+p_sFile+"_regions.arc");
		var int i, iC;
		(pxArc^) << iC;
		for(i=0)cond(i<iC)iter(i++)do
			var ^CRegion pxRegion;
			var string sName, sGuid;
			(pxArc^) << sGuid;
			(pxArc^) << sName;
			var int iIndex=pxRM^.CreateRegion(sName);
			pxRegion=pxRM^.GetRegion(iIndex);
			if(pxRegion==null)then continue; endif;
			pxRegion^.Clear();
			var array vec3 avPos, avExt;
			var array bitset adwType, adwGroups;
			var array bool abEnabled;
			var int k, kC;
			(pxArc^) << kC;
			avPos=kC;
			avExt=kC;
			adwType=kC;
			adwGroups=kC;
			abEnabled=kC;
			for(k=0)cond(k<kC)iter(k++)do
				(pxArc^) << avPos[k];
				(pxArc^) << avExt[k];
				(pxArc^) << adwType[k];
				(pxArc^) << adwGroups[k];
				(pxArc^) << abEnabled[k];
			endfor;
			for(k=0)cond(k<kC)iter(k++)do
				var vec3 vNewExt=avExt[k];
				vNewExt.SetXYZ(vNewExt.GetX()/2.0f, vNewExt.GetY()/2.0f, 0.0f);
				var int iIdx=pxRegion^.AddSubRegion(CSubRegion.RT_Oval,avPos[k],vNewExt);
				if(iIdx!=-1)then
					pxRegion^[iIdx]^.SetType(adwType[k]);
					pxRegion^[iIdx]^.SetGroups(adwGroups[k]);
					pxRegion^[iIdx]^.SetEnable(abEnabled[k]);
				endif;
			endfor;
		endfor;
		pxArc^.Close();
	endproc;
	
	export proc void SaveRegion(string p_sFile, string p_sGuid)
		var ^CRegionMgr pxRM=^(CSrvWrap.GetRegionMgr());
		if(pxRM==null)then return; endif;
		var ^CRegion pxRegion;
		var string sGuid, sName;
		var CGuid xG;
		if(p_sGuid=="")then return; endif;
		var ^CArc pxArc= new CArc();
		pxArc^.OpenWrite("C:\\"+p_sFile+"_regions.arc",0);
		var int iTmp=1;
		(pxArc^) << iTmp;
		xG.FromString(p_sGuid);
		pxRegion=pxRM^.GetRegionByGuid(xG);
		if(pxRegion!=null)then
			sName=pxRegion^.GetName();
			(pxArc^) << p_sGuid;
			(pxArc^) << sName;
			var int k, kC=pxRegion^.NumSubs();
			var array vec3 avPos, avExt;
			var array bitset adwType, adwGroups;
			var array bool abEnabled;
			for(k=0)cond(k<kC)iter(k++)do
				var ^CSubRegion pxSub = pxRegion^[k];
				if(pxSub!=null)then
					var vec3 vExt, vSub=pxSub^.GetPos();
					avPos.AddEntry(vSub);
					var string sPos=pxSub^.ToString();
					sPos=sPos.Mid(sPos.Find("Ext: ")+5);
					vExt.FromString(sPos);
					avExt.AddEntry(vExt);
					adwType.AddEntry(pxSub^.GetType());
					adwGroups.AddEntry(pxSub^.GetGroups());
					abEnabled.AddEntry(pxSub^.GetEnable());
				endif;
			endfor;
			kC=avPos.NumEntries();
			(pxArc^) << kC;
			for(k=0)cond(k<kC)iter(k++)do
				(pxArc^) << avPos[k];
				(pxArc^) << avExt[k];
				(pxArc^) << adwType[k];
				(pxArc^) << adwGroups[k];
				(pxArc^) << abEnabled[k];
			endfor;
		endif;
		pxArc^.Close();
	endproc;
	
	export proc void LoadRegion(string p_sFile, string p_sName, string p_sGuid)
		if(p_sName==""&&p_sGuid=="")then return; endif;
		if(p_sName!=""&&p_sGuid!="")then return; endif;
		var ^CRegionMgr pxRM=^(CSrvWrap.GetRegionMgr());
		if(pxRM==null)then return; endif;
		var ^CArc pxArc= new CArc();
		pxArc^.OpenRead("C:\\"+p_sFile+"_regions.arc");
		var int i, iC;
		(pxArc^) << iC;
		for(i=0)cond(i<iC)iter(i++)do
			var ^CRegion pxRegion;
			var string sName, sGuid;
			(pxArc^) << sGuid;
			(pxArc^) << sName;
			var array vec3 avPos, avExt;
			var array bitset adwType, adwGroups;
			var array bool abEnabled;
			var int k, kC;
			(pxArc^) << kC;
			avPos=kC;
			avExt=kC;
			adwType=kC;
			adwGroups=kC;
			abEnabled=kC;
			for(k=0)cond(k<kC)iter(k++)do
				(pxArc^) << avPos[k];
				(pxArc^) << avExt[k];
				(pxArc^) << adwType[k];
				(pxArc^) << adwGroups[k];
				(pxArc^) << abEnabled[k];
			endfor;
			if(p_sName!=""&&sName!=p_sName)then continue; endif;
			if(p_sGuid!=""&&sGuid!=p_sGuid)then continue; endif;
			var int iIndex=pxRM^.CreateRegion(sName);
			pxRegion=pxRM^.GetRegion(iIndex);
			if(pxRegion==null)then continue; endif;
			pxRegion^.Clear();
			for(k=0)cond(k<kC)iter(k++)do
				var vec3 vNewExt=avExt[k];
				vNewExt.SetXYZ(vNewExt.GetX()/2.0f, vNewExt.GetY()/2.0f, 0.0f);
				var int iIdx=pxRegion^.AddSubRegion(CSubRegion.RT_Oval,avPos[k],vNewExt);
				if(iIdx!=-1)then
					pxRegion^[iIdx]^.SetType(adwType[k]);
					pxRegion^[iIdx]^.SetGroups(adwGroups[k]);
					pxRegion^[iIdx]^.SetEnable(abEnabled[k]);
				endif;
			endfor;
			pxArc^.Close();
			return;
		endfor;
	endproc;
	
	export static proc void DumpLevelData()
		var ^CTriggerMgr pxTM=^(CSrvWrap.GetTriggerMgr());
		var ^CTriggerDescMgr pxTDM=pxTM^.GetTriggerDescMgr();
		if(pxTDM!=null)then
			pxTDM^.GenerateTriggerInfo();
		endif;
		var ^CLevelInfoHost pxLevelInfo=^(CSrvWrap.GetCurLevel()^.GetLevelInfo());
		if(pxLevelInfo!=null)then
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var string sName="temp";
			var ^CPropDB.CNode pxBaseNode=^((pxLevelInfo^.GetGenericData())["Base"]);
			if(pxBaseNode!=null)then
				sName=pxBaseNode^.GetValueS("LevelName");
			endif;
			pxGenericDB^.Save("C:/"+sName+"_levelinfo.txt");
		endif;
	endproc;
	
	export proc void SaveQuests(string p_sFile)
		var ^CArc pxArc= new CArc();
		pxArc^.OpenWrite("C:\\"+p_sFile+"_quests.arc",0);
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		var ^CQuestMgrHost pxQM=^(pxLevel^.GetQuestMgr());
		var int i, iC=pxQM^.NumQuests();
		(pxArc^) << iC;
		for(i=0)cond(i<iC)iter(i++)do
			var ^CQuestMgr.CQuest pxQ = ^(pxQM^.GetQuest(i));
			if(pxQ==null)then continue; endif;
			var CGuid xG=pxQ^.GetGuid();
			(pxArc^) << xG;
			Debug(i.ToString()+". quest ("+pxQ^.GetName()+") info: "+pxQ^.GetAdditionalInfo() + " | headline: "+pxQ^.GetHeadline() + " | description: "+pxQ^.GetDescription());
			var int k, kC=pxQ^.NumEntries();
			(pxArc^) << kC;
			for(k=0)cond(k<kC)iter(k++)do
				var string sKey=pxQ^.GetNameByIndex(k);
				var string sValue=pxQ^.GetValueByIndex(k);
				(pxArc^) << sKey;
				(pxArc^) << sValue;
			endfor;
			var string sName=pxQ^.GetName(), sGroup=pxQ^.GetGroup(), sImage=pxQ^.GetImagePath();
			var int iBoniE=pxQ^.GetBoniEasy(), iBoniM=pxQ^.GetBoniMiddle(), iBonyH=pxQ^.GetBoniHard();
			var bool bAccomp=pxQ^.IsAccomplished(), bUnAcc=pxQ^.IsUnaccomplishable(), bImage=pxQ^.GetImageSelected(), bVisible=pxQ^.IsVisible(), bMainQ=pxQ^.IsMainQuest();
			(pxArc^) << sName;
			(pxArc^) << sGroup;
			(pxArc^) << sImage;
			(pxArc^) << iBoniE;
			(pxArc^) << iBoniM;
			(pxArc^) << iBonyH;
			(pxArc^) << bAccomp;
			(pxArc^) << bUnAcc;
			(pxArc^) << bImage;
			(pxArc^) << bVisible;
			(pxArc^) << bMainQ;
		endfor;
		pxArc^.Close();
	endproc;
	
	export proc void LoadQuests(string p_sFile)
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		var ^CQuestMgrHost pxQM=^(pxLevel^.GetQuestMgr());
		if(pxQM==null)then return; endif;
		var ^CArc pxArc= new CArc();
		pxArc^.OpenRead("C:\\"+p_sFile+"_quests.arc");
		var int i, iC;
		(pxArc^) << iC;
		for(i=0)cond(i<iC)iter(i++)do
			var CGuid xG;
			(pxArc^) << xG;
			var ^CQuestMgr.CQuest pxQ = ^(pxQM^.NewQuestRef(xG));
			if(pxQ==null)then continue; endif;
			var int k, kC;
			(pxArc^) << kC;
			for(k=0)cond(k<kC)iter(k++)do
				var string sKey, sValue;
				(pxArc^) << sKey;
				(pxArc^) << sValue;
				pxQ^.SetValue(sKey,sValue);
			endfor;
			var string sName, sGroup, sImage;
			var int iBoniE, iBoniM, iBonyH;
			var bool bAccomp, bUnAcc, bImage, bVisible, bMainQ;
			(pxArc^) << sName;
			(pxArc^) << sGroup;
			(pxArc^) << sImage;
			(pxArc^) << iBoniE;
			(pxArc^) << iBoniM;
			(pxArc^) << iBonyH;
			(pxArc^) << bAccomp;
			(pxArc^) << bUnAcc;
			(pxArc^) << bImage;
			(pxArc^) << bVisible;
			(pxArc^) << bMainQ;
			pxQ^.SetName(sName);
			pxQ^.SetGroup(sGroup);
			pxQ^.SetImagePath(sImage);
			pxQ^.SetBoniEasy(iBoniE);
			pxQ^.SetBoniMiddle(iBoniM);
			pxQ^.SetBoniHard(iBonyH);
			pxQ^.SetAccomplished(bAccomp);
			pxQ^.SetUnaccomplishable(bUnAcc);
			pxQ^.SetImageSelected(bImage);
			pxQ^.SetVisible(bVisible);
			pxQ^.SetMainQuest(bMainQ);
		endfor;
		pxArc^.Close();
	endproc;
	
	proc int ToInt(bool p_bB)
		if(p_bB)then
			return 1;
		else
			return 0;
		endif;
	endproc;
	
	class CNodeInfo
		
		export var string m_sName;
		export var string m_sParent;
		export var string m_sPath;
		export var bool m_bActive;
		export var int m_iNodes;
		export var int m_iTriggers;
		
		export constructor()
		endconstructor;
		
		export destructor()
		enddestructor;
		
		export proc void DoKArc(ref CArc p_rxArc)
			p_rxArc << m_sName;
			p_rxArc << m_sParent;
			p_rxArc << m_sPath;
			p_rxArc << m_bActive;
			p_rxArc << m_iNodes;
			p_rxArc << m_iTriggers;
		endproc;
		
		export proc void DoNodeSave(ref CPropDB.CNode p_rxNode)
			p_rxNode.AddValue("m_sName",m_sName);
			p_rxNode.AddValue("m_sParent",m_sParent);
			p_rxNode.AddValue("m_sPath",m_sPath);
			p_rxNode.AddValue("m_bActive",m_bActive.ToString());
			p_rxNode.AddValue("m_iNodes",m_iNodes.ToString());
			p_rxNode.AddValue("m_iTriggers",m_iTriggers.ToString());
		endproc;
		
		export proc void DoNodeLoad(ref CPropDB.CNode p_rxNode)
			m_sName=p_rxNode.GetValueS("m_sName");
			m_sParent=p_rxNode.GetValueS("m_sParent");
			m_sPath=p_rxNode.GetValueS("m_sPath");
			m_bActive=p_rxNode.GetValueS("m_bActive")=="true";
			m_iNodes=p_rxNode.GetValueI("m_iNodes");
			m_iTriggers=p_rxNode.GetValueI("m_iTriggers");
		endproc;
		
		export proc void Init(string p_sParent, CTriggerDescMgr.CNode p_xNode)
			if(!p_xNode.IsValid())then return; endif;
			var ^CTriggerDescMgr.CHierarchyDesc pxData=p_xNode.GetData();
			if(pxData==null)then return; endif;
			m_sName=pxData^.GetNodeName();
			m_sParent=p_sParent;
			m_sPath=p_xNode.GetFullPath();
			m_bActive=p_xNode.IsActive();
			m_iNodes=p_xNode.NumChildren();
			m_iTriggers=pxData^.NumTriggers();
			var int i, iC = m_iNodes;
			for(i=0)cond(i<iC)iter(i++)do
				CMirageSrvMgr.Get().ExtractDataFromNode(m_sName, p_xNode.GetChild(i));
			endfor;
			iC = m_iTriggers;
			for(i=0)cond(i<iC)iter(i++)do
				CMirageSrvMgr.Get().RegisterDescription(m_sName, pxData^.GetTrigger(i));
			endfor;
		endproc;
		
	endclass;
	
	class CDescriptionInfo
		
		class CActCondInfo
			
			export var CFourCC m_xType;
			export var string m_sName;
			export var string m_sDescription;
			export var array string m_asKeys;
			export var array string m_asValues;
			
			export constructor()
			endconstructor;
			
			export destructor()
			enddestructor;
			
			export proc void InitAction(^CTriggerDesc.CAction p_pxAction)
				if(p_pxAction==null)then return; endif;
				m_xType = p_pxAction^.GetType();
				m_sName = p_pxAction^.GetName();
				m_sDescription = p_pxAction^.GetDesc();
				var ^CAttribs pxAttribs = ^(p_pxAction^.GetParams());
				if(pxAttribs==null)then return; endif;
				var int i, iC = pxAttribs^.NumEntries();
				for(i=0)cond(i<iC)iter(i++)do
					var string sKey, sValue;
					if(pxAttribs^.GetEntry(i, sKey, sValue))then
						m_asKeys.AddEntry(sKey);
						m_asValues.AddEntry(sValue);
					endif;
				endfor;
			endproc;
			
			export proc void InitCondition(^CTriggerDesc.CCondition p_pxCondition)
				if(p_pxCondition==null)then return; endif;
				m_xType = p_pxCondition^.GetType();
				m_sName = p_pxCondition^.GetName();
				m_sDescription = p_pxCondition^.GetDesc();
				var ^CAttribs pxAttribs = ^(p_pxCondition^.GetParams());
				if(pxAttribs==null)then return; endif;
				var int i, iC = pxAttribs^.NumEntries();
				for(i=0)cond(i<iC)iter(i++)do
					var string sKey, sValue;
					if(pxAttribs^.GetEntry(i, sKey, sValue))then
						m_asKeys.AddEntry(sKey);
						m_asValues.AddEntry(sValue);
					endif;
				endfor;
			endproc;
			
			export proc void AddAction(^CTriggerDesc p_pxDescription)
//				if(p_pxDescription==null)then return; endif;
				var int iIdx=p_pxDescription^.AddAction(m_xType);
				if(iIdx<0)then return; endif;
				var ^CTriggerDesc.CAction pxAction=p_pxDescription^.GetAction(iIdx);
				if(pxAction==null)then return; endif;
				pxAction^.SetName(m_sName);
				pxAction^.SetDesc(m_sDescription);
				var ^CAttribs pxAttribs = ^(pxAction^.GetParams());
				if(pxAttribs==null)then return; endif;
				var int i, iC = m_asKeys.NumEntries();
				for(i=0)cond(i<iC)iter(i++)do
					pxAttribs^.SetValue(m_asKeys[i], m_asValues[i]);
				endfor;
			endproc;
			
			export proc void AddCondition(^CTriggerDesc p_pxDescription)
//				if(p_pxDescription==null)then return; endif;
				var int iIdx=p_pxDescription^.AddCondition(m_xType);
				if(iIdx<0)then return; endif;
				var ^CTriggerDesc.CCondition pxCondition=p_pxDescription^.GetCondition(iIdx);
				if(pxCondition==null)then return; endif;
				pxCondition^.SetName(m_sName);
				pxCondition^.SetDesc(m_sDescription);
				var ^CAttribs pxAttribs = ^(pxCondition^.GetParams());
				if(pxAttribs==null)then return; endif;
				var int i, iC = m_asKeys.NumEntries();
				for(i=0)cond(i<iC)iter(i++)do
					pxAttribs^.SetValue(m_asKeys[i], m_asValues[i]);
				endfor;
			endproc;
			
			export proc void DoNodeSave(ref CPropDB.CNode p_rxNode)
				p_rxNode.AddValue("m_xType",m_xType.AsString());
				p_rxNode.AddValue("m_sName",m_sName);
				p_rxNode.AddValue("m_sDescription",m_sDescription);
				var ^CPropDB.CNode pxAttribsNode;
				var int i, iC=m_asKeys.NumEntries();
				for(i=0)cond(i<iC)iter(i++)do
					pxAttribsNode = p_rxNode.FindNode("attrib_"+i.ToString(), true);
					if(pxAttribsNode==null)then continue; endif;
					pxAttribsNode^.AddValue("attrib_name",m_asKeys[i]);
					pxAttribsNode^.AddValue("attrib_value",m_asValues[i]);
				endfor;
			endproc;
			
			export proc void DoNodeLoad(ref CPropDB.CNode p_rxNode)
				m_xType=p_rxNode.GetValueS("m_xType");
				m_sName=p_rxNode.GetValueS("m_sName");
				m_sDescription=p_rxNode.GetValueS("m_sDescription");
				var ^CPropDB.CNode pxAttribsNode;
				var int i, iC=p_rxNode.NumSubs()-3;
				m_asKeys = iC;
				m_asValues = iC;
				for(i=0)cond(i<iC)iter(i++)do
					pxAttribsNode = p_rxNode.FindNode("attrib_"+i.ToString(), false);
					if(pxAttribsNode==null)then continue; endif;
					m_asKeys[i]=pxAttribsNode^.GetValueS("attrib_name");
					m_asValues[i]=pxAttribsNode^.GetValueS("attrib_value");
				endfor;
			endproc;
			
			export proc void DoKArcSave(ref CArc p_rxArc)
				p_rxArc << m_xType;
				p_rxArc << m_sName;
				p_rxArc << m_sDescription;
				var int i, iC = m_asKeys.NumEntries();
				p_rxArc << iC;
				for(i=0)cond(i<iC)iter(i++)do
					p_rxArc << m_asKeys[i];
					p_rxArc << m_asValues[i];
				endfor;
			endproc;
			
			export proc void DoKArcLoad(ref CArc p_rxArc)
				p_rxArc << m_xType;
				p_rxArc << m_sName;
				p_rxArc << m_sDescription;
				var int i, iC;
				p_rxArc << iC;
				m_asKeys = iC;
				m_asValues = iC;
				for(i=0)cond(i<iC)iter(i++)do
					p_rxArc << m_asKeys[i];
					p_rxArc << m_asValues[i];
				endfor;
			endproc;
			
		endclass;
		
		var array CActCondInfo m_axActions;
		var array CActCondInfo m_axConditions;
		
		export var CGuid m_xGuid;
		export var string m_sParent;
		export var string m_sName;
		export var string m_sDescription;
		export var bitset m_dwEdgeType;
		export var string m_sExpression;
		export var bool m_bMultiDifficulty;
		export var bool m_bRandomAction;
		export var bool m_bDisabled;
		export var int m_iActions;
		export var int m_iConditions;
		
		export constructor()
		endconstructor;
		
		export destructor()
			while(m_axActions.NumEntries()>0)do
				m_axActions.DeleteEntry(0);
			endwhile;
			while(m_axConditions.NumEntries()>0)do
				m_axConditions.DeleteEntry(0);
			endwhile;
		enddestructor;
		
		export proc void Init(string p_sParent, ^CTriggerDesc p_pxDescription)
			if(p_pxDescription==null)then return; endif;
			m_sName=p_pxDescription^.GetName();
			m_sParent=p_sParent;
			m_sDescription=p_pxDescription^.GetDesc();
			m_dwEdgeType=p_pxDescription^.GetEdgeType();
			m_sExpression=p_pxDescription^.GetExpression();
			m_xGuid=p_pxDescription^.GetGuid();
			m_bMultiDifficulty=p_pxDescription^.GetMultiDifficulty();
			m_bRandomAction=p_pxDescription^.GetRandomAction();
			m_bDisabled=p_pxDescription^.IsCompleteDisabled();
			m_iActions=p_pxDescription^.NumActions();
			m_iConditions=p_pxDescription^.NumConditions();
			var int i, iC = m_iActions;
			for(i=0)cond(i<iC)iter(i++)do
				var ^CActCondInfo pxAI=^(m_axActions.NewEntryRef());
				pxAI^.InitAction(p_pxDescription^.GetAction(i));
			endfor;
			iC = m_iConditions;
			for(i=0)cond(i<iC)iter(i++)do
				var ^CActCondInfo pxCI=^(m_axConditions.NewEntryRef());
				pxCI^.InitCondition(p_pxDescription^.GetCondition(i));
			endfor;
		endproc;
		
		export proc void PassOn(CTriggerDescMgr.CNode p_xParent, ^CTriggerDesc p_pxDescription, ^CTriggerDescMgr p_pxTDM)
			if(p_pxDescription==null||!p_xParent.IsValid())then return; endif;
			p_pxDescription^.SetName(m_sName);
			p_pxDescription^.SetDesc(m_sDescription);
			p_pxDescription^.SetEdgeType(m_dwEdgeType);
			p_pxDescription^.SetExpression(m_sExpression);
			p_pxDescription^.SetMultiDifficulty(m_bMultiDifficulty);
			p_pxDescription^.SetRandomAction(m_bRandomAction);
			while(m_axActions.NumEntries()>0)do
				m_axActions[0].AddAction(p_pxDescription);
				m_axActions.DeleteEntry(0);
			endwhile;
			while(m_axConditions.NumEntries()>0)do
				m_axConditions[0].AddCondition(p_pxDescription);
				m_axConditions.DeleteEntry(0);
			endwhile;
			if(p_xParent.GetData()!=null)then
				var ^CTriggerDescMgr.CHierarchyDesc pxData = p_xParent.GetData();
				if(pxData^.FindTrigger(p_pxDescription)<0)then
					pxData^.AddTrigger(p_pxDescription);
				else
					return;
				endif;
			endif;
			var CTriggerDescMgr.CNode xRoot = p_pxTDM^.GetHierarchyRoot();
			var ^CTriggerDescMgr.CHierarchyDesc pxRD = xRoot.GetData();
			if(pxRD!=null)then
				var int iIdx = pxRD^.FindTrigger(p_pxDescription);
				if(iIdx>=0)then
					pxRD^.RemTrigger(iIdx);
				endif;
			endif;
		endproc;
		
		export proc void DoKArcSave(ref CArc p_rxArc)
			p_rxArc << m_sName;
			p_rxArc << m_sParent;
			p_rxArc << m_sDescription;
			p_rxArc << m_dwEdgeType;
			p_rxArc << m_sExpression;
			p_rxArc << m_xGuid;
			p_rxArc << m_bMultiDifficulty;
			p_rxArc << m_bRandomAction;
			p_rxArc << m_bDisabled;
			p_rxArc << m_iActions;
			p_rxArc << m_iConditions;
			var int i, iC = m_axActions.NumEntries();
			p_rxArc << iC;
			for(i=0)cond(i<iC)iter(i++)do
				m_axActions[i].DoKArcSave(p_rxArc);
			endfor;
			iC = m_axConditions.NumEntries();
			p_rxArc << iC;
			for(i=0)cond(i<iC)iter(i++)do
				m_axConditions[i].DoKArcSave(p_rxArc);
			endfor;
		endproc;
		
		export proc void DoKArcLoad(ref CArc p_rxArc)
			p_rxArc << m_sName;
			p_rxArc << m_sParent;
			p_rxArc << m_sDescription;
			p_rxArc << m_dwEdgeType;
			p_rxArc << m_sExpression;
			p_rxArc << m_xGuid;
			p_rxArc << m_bMultiDifficulty;
			p_rxArc << m_bRandomAction;
			p_rxArc << m_bDisabled;
			p_rxArc << m_iActions;
			p_rxArc << m_iConditions;
			var int i, iC;
			p_rxArc << iC;
			for(i=0)cond(i<iC)iter(i++)do
				var ^CMirageSrvMgr.CDescriptionInfo.CActCondInfo pxA=^(m_axActions.NewEntryRef());
				pxA^.DoKArcLoad(p_rxArc);
			endfor;
			p_rxArc << iC;
			for(i=0)cond(i<iC)iter(i++)do
				var ^CMirageSrvMgr.CDescriptionInfo.CActCondInfo pxC=^(m_axConditions.NewEntryRef());
				pxC^.DoKArcLoad(p_rxArc);
			endfor;
		endproc;
		
		export proc void DoNodeSave(ref CPropDB.CNode p_rxNode)
			p_rxNode.AddValue("m_sName",m_sName);
			p_rxNode.AddValue("m_sParent",m_sParent);
			p_rxNode.AddValue("m_sDescription",m_sDescription);
			p_rxNode.AddValue("m_dwEdgeType",m_dwEdgeType.ToInt());
			p_rxNode.AddValue("m_sExpression",m_sExpression);
			p_rxNode.AddValue("m_xGuid",m_xGuid.ToString());
			p_rxNode.AddValue("m_bMultiDifficulty",m_bMultiDifficulty.ToString());
			p_rxNode.AddValue("m_bRandomAction",m_bRandomAction.ToString());
			p_rxNode.AddValue("m_bDisabled",m_bDisabled.ToString());
			p_rxNode.AddValue("m_iActions",m_iActions.ToString());
			p_rxNode.AddValue("m_iConditions",m_iConditions.ToString());
			var ^CPropDB.CNode pxActionsNode, pxConditionsNode;
			var ^CPropDB.CNode pxAction, pxCondition;
			pxActionsNode = p_rxNode.FindNode("actions", true);
			pxConditionsNode = p_rxNode.FindNode("conditions", true);
			var int i, iC=m_axActions.NumEntries();;
			for(i=0)cond(i<iC)iter(i++)do
				pxAction = pxActionsNode^.FindNode("action_"+i.ToString(), true);
				if(pxAction==null)then continue; endif;
				m_axActions[i].DoNodeSave(pxAction^);
			endfor;
			iC = m_axConditions.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				pxCondition = pxConditionsNode^.FindNode("condition_"+i.ToString(), true);
				if(pxCondition==null)then continue; endif;
				m_axConditions[i].DoNodeSave(pxCondition^);
			endfor;
		endproc;
		
		export proc void DoNodeLoad(ref CPropDB.CNode p_rxNode)
			m_sName=p_rxNode.GetValueS("m_sName");
			m_sParent=p_rxNode.GetValueS("m_sParent");
			m_sDescription=p_rxNode.GetValueS("m_sDescription");
			m_dwEdgeType=Math.IntToBitset(p_rxNode.GetValueI("m_dwEdgeType"));
			m_sExpression=p_rxNode.GetValueS("m_sExpression");
			m_xGuid.FromString(p_rxNode.GetValueS("m_xGuid"));
			m_bMultiDifficulty=p_rxNode.GetValueS("m_bMultiDifficulty")=="true";
			m_bRandomAction=p_rxNode.GetValueS("m_bRandomAction")=="true";
			m_iActions=p_rxNode.GetValueI("m_iActions");
			m_iConditions=p_rxNode.GetValueI("m_iConditions");
			var ^CPropDB.CNode pxActionsNode, pxConditionsNode;
			var ^CPropDB.CNode pxAction, pxCondition;
			pxActionsNode = p_rxNode.FindNode("actions", false);
			pxConditionsNode = p_rxNode.FindNode("conditions", false);
			if(pxActionsNode!=null)then
				var int i, iC=pxActionsNode^.NumSubs();
				for(i=0)cond(i<iC)iter(i++)do
					pxAction = pxActionsNode^.FindNode("action_"+i.ToString(), false);
					if(pxAction==null)then continue; endif;
					var ^CMirageSrvMgr.CDescriptionInfo.CActCondInfo pxA=^(m_axActions.NewEntryRef());
					pxA^.DoNodeLoad(pxAction^);
				endfor;
			endif;
			if(pxConditionsNode!=null)then
				var int i, iC=pxConditionsNode^.NumSubs();
				for(i=0)cond(i<iC)iter(i++)do
					pxCondition = pxConditionsNode^.FindNode("condition_"+i.ToString(), false);
					if(pxCondition==null)then continue; endif;
					var ^CMirageSrvMgr.CDescriptionInfo.CActCondInfo pxC=^(m_axConditions.NewEntryRef());
					pxC^.DoNodeLoad(pxCondition^);
				endfor;
			endif;
		endproc;
		
	endclass;
	
	var array CNodeInfo m_axNodes;
	var array CDescriptionInfo m_axDescriptions;
	var array string m_asInactiveNodes;
	
	proc void RegisterAllTriggers()
		while(m_axNodes.NumEntries()>0)do
			m_axNodes.DeleteEntry(0);
		endwhile;
		while(m_axDescriptions.NumEntries()>0)do
			m_axDescriptions.DeleteEntry(0);
		endwhile;
		var ^CTriggerMgr pxTM = ^(CSrvWrap.GetTriggerMgr());
		var ^CTriggerDescMgr pxTDM = pxTM^.GetTriggerDescMgr();
		if(pxTDM==null)then return; endif;
		var CTriggerDescMgr.CNode xRoot=pxTDM^.GetHierarchyRoot();
		ExtractDataFromNode("", xRoot);
	endproc;
	
	export proc void ExtractDataFromNode(string p_sParent, CTriggerDescMgr.CNode p_xNode)
//		if(!p_xNode.IsValid())then return; endif;
		var ^CNodeInfo pxNI=^(m_axNodes.NewEntryRef());
		pxNI^.Init(p_sParent, p_xNode);
	endproc;
	
	export proc void RegisterDescription(string p_sParentNode, ^CTriggerDesc p_pxDescription)
//		if(p_pxDescription==null)then return; endif;
		var ^CDescriptionInfo pxDI=^(m_axDescriptions.NewEntryRef());
		pxDI^.Init(p_sParentNode, p_pxDescription);
	endproc;
	
	export proc void SaveTriggers(string p_sFile)
		RegisterAllTriggers();
		var ^CArc pxArc= new CArc();
		pxArc^.OpenWrite("C:\\"+p_sFile+"_trigger_nodes.arc",0);
		var int i, iC=m_axNodes.NumEntries();
		(pxArc^) << iC;
		for(i=0)cond(i<iC)iter(i++)do
			m_axNodes[i].DoKArc(pxArc^);
		endfor;
		pxArc^.Close();
		pxArc= new CArc();
		pxArc^.OpenWrite("C:\\"+p_sFile+"_trigger_descriptions.arc",0);
		iC=m_axDescriptions.NumEntries();
		(pxArc^) << iC;
		for(i=0)cond(i<iC)iter(i++)do
			m_axDescriptions[i].DoKArcSave(pxArc^);
		endfor;
		pxArc^.Close();
	endproc;
	
	export proc void LoadTriggers(string p_sFile)
		var ^CTriggerMgr pxTM = ^(CSrvWrap.GetTriggerMgr());
		var ^CTriggerDescMgr pxTDM = pxTM^.GetTriggerDescMgr();
		if(pxTDM==null)then return; endif;
		var CTriggerDescMgr.CNode xRoot=pxTDM^.GetHierarchyRoot();
		pxTDM^.DeleteNodeAndSubs(xRoot);
		var ^CArc pxArc= new CArc();
		pxArc^.OpenRead("C:\\"+p_sFile+"_trigger_nodes.arc");
		var int i, iC;
		(pxArc^) << iC;
		for(i=0)cond(i<iC)iter(i++)do
			var ^CMirageSrvMgr.CNodeInfo pxNode=^(m_axNodes.NewEntryRef());
			pxNode^.DoKArc(pxArc^);
		endfor;
		pxArc^.Close();
		pxArc= new CArc();
		pxArc^.OpenRead("C:\\"+p_sFile+"_trigger_descriptions.arc");
		(pxArc^) << iC;
		for(i=0)cond(i<iC)iter(i++)do
			var ^CMirageSrvMgr.CDescriptionInfo pxDescription=^(m_axDescriptions.NewEntryRef());
			pxDescription^.DoKArcLoad(pxArc^);
		endfor;
		pxArc^.Close();
		// Henry: begin recreating nodes and descriptions...
		CreateSubs("Root", xRoot, pxTDM);
		while(m_asInactiveNodes.NumEntries()>0)do
			var CTriggerDescMgr.CNode xTemp = pxTDM^.FindNodeByName(m_asInactiveNodes[0]);
			if(xTemp.IsValid())then
				xTemp.SetActive(false,true);
			endif;
			m_asInactiveNodes.DeleteEntry(0);
		endwhile;
		while(m_axNodes.NumEntries()>0)do
			m_axNodes.DeleteEntry(0);
		endwhile;
		while(m_axDescriptions.NumEntries()>0)do
			m_axDescriptions.DeleteEntry(0);
		endwhile;
	endproc;
	
	export proc void SaveTriggersNode(string p_sFile)
		RegisterAllTriggers();
		var ^CPropDB pxSource = new CPropDB;
		var ^CPropDB.CNode pxRoot = ^(pxSource^.GetRoot());
		var ^CPropDB.CNode pxTNode;
		var int i, iC=m_axNodes.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			pxTNode = pxRoot^.FindNode("trigger_"+i.ToString(), true);
			if(pxTNode==null)then continue; endif;
			m_axNodes[i].DoNodeSave(pxTNode^);
		endfor;
		pxSource^.Save("C:/"+p_sFile+"_triggers.txt");
		pxSource = new CPropDB;
		pxRoot = ^(pxSource^.GetRoot());
		iC=m_axDescriptions.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			pxTNode = pxRoot^.FindNode("description_"+i.ToString(), true);
			if(pxTNode==null)then continue; endif;
			m_axDescriptions[i].DoNodeSave(pxTNode^);
		endfor;
		pxSource^.Save("C:/"+p_sFile+"_descriptions.txt");
	endproc;
	
	export proc void LoadTriggersNode(string p_sFile)
		var ^CPropDB pxSource = new CPropDB;
		if(!pxSource^.Load("C:/"+p_sFile+"_triggers.txt"))then return; endif;
		var ^CPropDB.CNode pxRoot = ^(pxSource^.GetRoot());
		var ^CPropDB.CNode pxTNode;
		var ^CTriggerMgr pxTM = ^(CSrvWrap.GetTriggerMgr());
		var ^CTriggerDescMgr pxTDM = pxTM^.GetTriggerDescMgr();
		if(pxTDM==null)then return; endif;
		var CTriggerDescMgr.CNode xRoot=pxTDM^.GetHierarchyRoot();
		pxTDM^.DeleteNodeAndSubs(xRoot);
		var int i, iC=pxRoot^.NumSubs();
		for(i=0)cond(i<iC)iter(i++)do
			pxTNode = pxRoot^.FindNode("trigger_"+i.ToString(), false);
			if(pxTNode==null)then continue; endif;
			var ^CMirageSrvMgr.CNodeInfo pxNode=^(m_axNodes.NewEntryRef());
			pxNode^.DoNodeLoad(pxTNode^);
		endfor;
		if(!pxSource^.Load("C:/"+p_sFile+"_descriptions.txt"))then return; endif;
		pxRoot = ^(pxSource^.GetRoot());
		iC=pxRoot^.NumSubs();
		for(i=0)cond(i<iC)iter(i++)do
			pxTNode = pxRoot^.FindNode("description_"+i.ToString(), false);
			if(pxTNode==null)then continue; endif;
			var ^CMirageSrvMgr.CDescriptionInfo pxDescription=^(m_axDescriptions.NewEntryRef());
			pxDescription^.DoNodeLoad(pxTNode^);
		endfor;
		// Henry: begin recreating nodes and descriptions...
		CreateSubs("Root", xRoot, pxTDM);
		while(m_asInactiveNodes.NumEntries()>0)do
			var CTriggerDescMgr.CNode xTemp = pxTDM^.FindNodeByName(m_asInactiveNodes[0]);
			if(xTemp.IsValid())then
				xTemp.SetActive(false,true);
			endif;
			m_asInactiveNodes.DeleteEntry(0);
		endwhile;
		while(m_axNodes.NumEntries()>0)do
			m_axNodes.DeleteEntry(0);
		endwhile;
		while(m_axDescriptions.NumEntries()>0)do
			m_axDescriptions.DeleteEntry(0);
		endwhile;
	endproc;
	
	export proc void CreateSubs(string p_sParent, CTriggerDescMgr.CNode p_xNode, ^CTriggerDescMgr p_pxTDM)
//		if(!p_xNode.IsValid()||p_pxTDM==null)then return; endif;
		if(!p_xNode.IsValid())then return; endif;
		var int i, iC=m_axDescriptions.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(m_axDescriptions[i].m_sParent!=p_sParent)then continue; endif;
//			var CGuid xGuid=p_pxTDM^.CreateTrigger(m_axDescriptions[i].m_sName);
			var CGuid xGuid=p_pxTDM^.CreateTrigger();
			var ^CTriggerDesc pxTrigger=p_pxTDM^.GetTrigger(xGuid);
			if(pxTrigger!=null)then
				m_axDescriptions[i].PassOn(p_xNode, pxTrigger, p_pxTDM);
			endif;
		endfor;
		iC=m_axNodes.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(m_axNodes[i].m_sParent!=p_sParent)then continue; endif;
			var string sChild=m_axNodes[i].m_sName;
			if(!m_axNodes[i].m_bActive)then
				m_asInactiveNodes.Include(sChild);
			endif;
			var CTriggerDescMgr.CNode xChild=p_pxTDM^.CreateNewNode(p_xNode,sChild);
			CreateSubs(sChild, xChild, p_pxTDM);
		endfor;
	endproc;
	
	export proc void SaveTAttribs(string p_sFile)
		var ^CPropDB pxSource = new CPropDB;
		var ^CPropDB.CNode pxRoot = ^(pxSource^.GetRoot());
		var ^CTriggerMgr pxTM = ^(CSrvWrap.GetTriggerMgr());
		var ^CTriggerDescMgr pxTDM = pxTM^.GetTriggerDescMgr();
		if(pxTDM==null)then return; endif;
		var int i, iC = pxTDM^.NumTrigger(), k, j;
		for(i=0)cond(i<iC)iter(i++)do
			var ^CTriggerDesc pxTrigger=pxTDM^.GetTrigger(i);
			if(pxTrigger==null)then continue; endif;
			var ^CPropDB.CNode pxTNode = pxRoot^.FindNode(pxTrigger^.GetName(), true);
			if(pxTNode==null)then continue; endif;
			var ^CPropDB.CNode pxANode = pxTNode^.FindNode("Actions", true);
			var ^CPropDB.CNode pxCNode = pxTNode^.FindNode("Conditions", true);
			if(pxANode==null||pxCNode==null)then continue; endif;
			var ^CAttribs pxAttribs;
			var int iActions=pxTrigger^.NumActions(), iConditions=pxTrigger^.NumConditions();
			for(k=0)cond(k<iActions)iter(k++)do
				var ^CTriggerDesc.CAction pxAction=pxTrigger^.GetAction(k);
				if(pxAction==null)then continue; endif;
				var ^CPropDB.CNode pxActionN = pxANode^.FindNode("action_"+k.ToString(), true);
				if(pxActionN==null)then continue; endif;
				pxAttribs = ^(pxAction^.GetParams());
				if(pxAttribs==null)then continue; endif;
				var int iEntries = pxAttribs^.NumEntries();
				for(j=0)cond(j<iEntries)iter(j++)do
					var ^CPropDB.CNode pxAParam = pxActionN^.FindNode("param_"+j.ToString(), true);
					if(pxAParam==null)then continue; endif;
					var string sKey, sValue;
					if(pxAttribs^.GetEntry(j, sKey, sValue))then
						pxAParam^.AddValue("key", sKey);
						pxAParam^.AddValue("value", sValue);
					endif;
				endfor;
			endfor;
			for(k=0)cond(k<iConditions)iter(k++)do
				var ^CTriggerDesc.CCondition pxCondition=pxTrigger^.GetCondition(k);
				if(pxCondition==null)then continue; endif;
				var ^CPropDB.CNode pxConditionN = pxCNode^.FindNode("condition_"+k.ToString(), true);
				if(pxConditionN==null)then continue; endif;
				pxAttribs = ^(pxCondition^.GetParams());
				if(pxAttribs==null)then continue; endif;
				var int iEntries = pxAttribs^.NumEntries();
				for(j=0)cond(j<iEntries)iter(j++)do
					var ^CPropDB.CNode pxCParam = pxConditionN^.FindNode("param_"+j.ToString(), true);
					if(pxCParam==null)then continue; endif;
					var string sKey, sValue;
					if(pxAttribs^.GetEntry(j, sKey, sValue))then
						pxCParam^.AddValue("key", sKey);
						pxCParam^.AddValue("value", sValue);
					endif;
				endfor;
			endfor;
		endfor;
		pxSource^.Save("C:/"+p_sFile+"_trigger_attribs.txt");
	endproc;
	
	export proc void LoadTAttribs(string p_sFile)
		var ^CPropDB pxSource = new CPropDB;
		if(!pxSource^.Load("C:/"+p_sFile+"_trigger_attribs.txt"))then return; endif;
		var ^CPropDB.CNode pxRoot = ^(pxSource^.GetRoot());
		var ^CTriggerMgr pxTM = ^(CSrvWrap.GetTriggerMgr());
		var ^CTriggerDescMgr pxTDM = pxTM^.GetTriggerDescMgr();
		if(pxTDM==null)then return; endif;
		var int i, iC = pxTDM^.NumTrigger(), k, j;
		for(i=0)cond(i<iC)iter(i++)do
			var ^CTriggerDesc pxTrigger=pxTDM^.GetTrigger(i);
			if(pxTrigger==null)then continue; endif;
			var ^CPropDB.CNode pxTNode = pxRoot^.FindNode(pxTrigger^.GetName(), false);
			if(pxTNode==null)then continue; endif;
			var ^CPropDB.CNode pxANode = pxTNode^.FindNode("Actions", false);
			var ^CPropDB.CNode pxCNode = pxTNode^.FindNode("Conditions", false);
			if(pxANode==null||pxCNode==null)then continue; endif;
			var ^CAttribs pxAttribs;
			var int iActions=pxTrigger^.NumActions(), iConditions=pxTrigger^.NumConditions();
			for(k=0)cond(k<iActions)iter(k++)do
				var ^CTriggerDesc.CAction pxAction=pxTrigger^.GetAction(k);
				if(pxAction==null)then continue; endif;
				var ^CPropDB.CNode pxActionN = pxANode^.FindNode("action_"+k.ToString(), false);
				if(pxActionN==null)then continue; endif;
				pxAttribs = ^(pxAction^.GetParams());
				if(pxAttribs==null)then continue; endif;
				var int iEntries = pxAttribs^.NumEntries();
				for(j=0)cond(j<iEntries)iter(j++)do
					var ^CPropDB.CNode pxAParam = pxActionN^.FindNode("param_"+j.ToString(), false);
					if(pxAParam==null)then continue; endif;
					var string sKey = pxAParam^.GetValueS("key", sKey), sValue = pxAParam^.GetValueS("value", sValue);
					pxAttribs^.SetValue(sKey, sValue);
				endfor;
			endfor;
			for(k=0)cond(k<iConditions)iter(k++)do
				var ^CTriggerDesc.CCondition pxCondition=pxTrigger^.GetCondition(k);
				if(pxCondition==null)then continue; endif;
				var ^CPropDB.CNode pxConditionN = pxCNode^.FindNode("condition_"+k.ToString(), false);
				if(pxConditionN==null)then continue; endif;
				pxAttribs = ^(pxCondition^.GetParams());
				if(pxAttribs==null)then continue; endif;
				var int iEntries = pxAttribs^.NumEntries();
				for(j=0)cond(j<iEntries)iter(j++)do
					var ^CPropDB.CNode pxCParam = pxConditionN^.FindNode("param_"+j.ToString(), false);
					if(pxCParam==null)then continue; endif;
					var string sKey = pxCParam^.GetValueS("key", sKey), sValue = pxCParam^.GetValueS("value", sValue);
					pxAttribs^.SetValue(sKey, sValue);
				endfor;
			endfor;
		endfor;
	endproc;
	
	export static proc void Archive(^CGameObj p_pxObj)
		if(p_pxObj==null)then return; endif;
		CMirageSrvMgr.Debug("");
		CMirageSrvMgr.Debug("archiving...");
		CMirageSrvMgr.Debug("class: "+p_pxObj^.GetClassName());
		CMirageSrvMgr.Debug("name: "+p_pxObj^.GetName());
		CMirageSrvMgr.Debug("pos: "+p_pxObj^.GetPos().ToString());
		CMirageSrvMgr.Debug("guid: "+p_pxObj^.GetGuid().ToString());
	endproc;
	
	export proc void CreateArchive()
		if(m_pxGreatArchive!=null)then
			m_pxGreatArchive^.Clear();
			return;
		endif;
		m_pxCodex = new CPropDB;
		if(m_pxCodex==null)then return; endif;
		m_pxGreatArchive = ^(m_pxCodex^.GetRoot());
	endproc;
	
	export proc void SaveArchive(string p_sName)
		if(m_pxCodex==null)then return; endif;
		m_pxCodex^.Save("C:/"+p_sName+"_codex.txt");
	endproc;
	
	export proc void PutIntoArchive(^CGameObj p_pxObj)
		if(m_pxGreatArchive==null)then return; endif;
		if(p_pxObj==null)then return; endif;
		var string sName=p_pxObj^.GetName();
		if(sName.IsEmpty())then return; endif;
		var string sType=p_pxObj^.GetType().AsString();
		if(sType.IsEmpty())then sType="Typeless"; endif;
		var ^CPropDB.CNode pxType = m_pxGreatArchive^.FindNode(sType, true);
		if(pxType==null)then return; endif;
		var string sClass=p_pxObj^.GetClassName();
		if(sClass.IsEmpty())then sClass="Classless"; endif;
		var ^CPropDB.CNode pxClass = pxType^.FindNode(sClass, true);
		if(pxClass==null)then return; endif;
		var ^CPropDB.CNode pxName = pxClass^.FindNode(sName, true);
		if(pxName==null)then return; endif;
		pxName^.AddValue("Name", sName);
		pxName^.AddValue("Class", p_pxObj^.GetClassName());
		pxName^.AddValue("Type", p_pxObj^.GetType().ToString());
		pxName^.AddValue("Gfx", p_pxObj^.GetGfxName());
		pxName^.AddValue("Visible", (p_pxObj^.GetVisibleMask()!=0h).ToString());
		pxName^.AddValue("Owner", p_pxObj^.GetOwner().ToString());
		pxName^.AddValue("Guid", p_pxObj^.GetGuid().ToString());
		pxName^.AddValue("Pos", p_pxObj^.GetPos().ToString());
		pxName^.AddValue("Quat", p_pxObj^.GetRot().ToString());
		pxName^.AddValue("Rot", p_pxObj^.GetRotation().ToString());
		pxName^.AddValue("Constructible", p_pxObj^.IsConstructible().ToString());
		pxName^.AddValue("Deconstructible", p_pxObj^.IsDeconstructible().ToString());
		pxName^.AddValue("IsDestructible", p_pxObj^.IsDestructible().ToString());
		pxName^.AddValue("IsDisableShadowCast", p_pxObj^.IsDisableShadowCast().ToString());
		pxName^.AddValue("IsDisableShadowReceive", p_pxObj^.IsDisableShadowReceive().ToString());
		pxName^.AddValue("IsHitable", p_pxObj^.IsHitable().ToString());
		pxName^.AddValue("IsSelectable", p_pxObj^.IsSelectable().ToString());
//		pxName^.AddValue("xxxx", xxxx);
		var ^CAttribs pxAttribs = p_pxObj^.GetAttribs();
		if(pxAttribs==null)then return; endif;
		var ^CPropDB.CNode pxAtt = pxName^.FindNode("Attributes", true);
		if(pxAtt==null)then return; endif;
		var int i, iC = pxAttribs^.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var string sKey, sValue;
			if(pxAttribs^.GetEntry(i, sKey, sValue))then
				var ^CPropDB.CNode pxParam = pxAtt^.FindNode("param_#"+i.ToString()+"_"+sKey, true);
				if(pxParam==null)then continue; endif;
				pxParam^.AddValue("key", sKey);
				pxParam^.AddValue("value", sValue);
			endif;
		endfor;
	endproc;
	
	export proc void RegisterAllObjects()
		if(m_pxGreatArchive!=null)then
			m_pxGreatArchive^.Clear();
		else
			CreateArchive();
		endif;
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel==null)then return; endif;
		var CObjQuery xQuery;
//		xQuery.SetOwner(-1);
//		xQ.SetRegion(CSrvWrap.GetRegionMgr().GetWorldRgnHndl());
		var CObjList xList;
		if(xQuery.Execute(xList))then
			var int k, iK=xList.NumEntries();
			for(k=0)cond(k<iK)iter(k++)do
				if(!xList[k].IsValid())then continue; endif;
				CMirageSrvMgr.Get().PutIntoArchive(xList[k].GetObj());
				xList[k].GetObj()^.SetVisible(true);
			endfor;
		endif;
//		var int i, iC=8;
//		for(i=0)cond(i<iC)iter(i++)do
//			var ^CPlayer pxPlayer=pxLevel^.GetPlayer(i);
//			if(pxPlayer==null)then continue; endif;
//			CMirageSrvMgr.Debug("registering player: "+i.ToString());
//			var CObjList xAllObj=pxPlayer^.GetAllObjects();
//			var int k, iK=xAllObj.NumEntries();
//			for(k=0)cond(k<iK)iter(k++)do
//				if(!xAllObj[k].IsValid())then continue; endif;
//				CMirageSrvMgr.Get().PutIntoArchive(xAllObj[k].GetObj());
//				xAllObj[k].GetObj()^.SetVisible(true);
//			endfor;
//		endfor;
	endproc;
	
	export proc void DeleteAllObjectsQ()
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel==null)then return; endif;
		var CObjQuery xQuery;
		var CObjList xList;
		if(xQuery.Execute(xList))then
			var int k, iK=xList.NumEntries()-1;
			for(k=iK)cond(k>-1)iter(k--)do
				if(!xList[k].IsValid())then continue; endif;
				xList[k].GetObj()^.Delete();
			endfor;
		endif;
	endproc;
	
	export proc void DeleteAllObjectsR()
		var int iHndl = CSrvWrap.GetRegionMgr().GetWorldRgnHndl();
		var ^CRegion pxRgn = CSrvWrap.GetRegionMgr().GetRegion(iHndl);
		if(pxRgn==null)then return; endif;
		var int k, iK=pxRgn^.NumObjects()-1;
		for(k=iK)cond(k>-1)iter(k--)do
			var CObjHndl xHndl = pxRgn^.GetObject(k);
			if(!xHndl.IsValid())then continue; endif;
			xHndl.GetObj()^.Delete();
		endfor;
	endproc;
	
	export proc void ArchiveAllIdiObjectsR()
		var int iHndl = CSrvWrap.GetRegionMgr().GetWorldRgnHndl();
		var ^CRegion pxRgn = CSrvWrap.GetRegionMgr().GetRegion(iHndl);
		if(pxRgn!=null)then
			var int i, iC=pxRgn^.NumObjects();
			for(i=0)cond(i<iC)iter(i++)do
				var CObjHndl xHndl = pxRgn^.GetObject(i);
				if(xHndl.IsValid())then
					RegisterIdiObject(xHndl.GetObj());
				endif;
			endfor;
		endif;
	endproc;
	
	export proc void ArchiveAllIdiObjectsQ()
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel==null)then return; endif;
		var CObjQuery xQuery;
		var CObjList xList;
		if(xQuery.Execute(xList))then
			var int k, iK=xList.NumEntries();
			for(k=0)cond(k<iK)iter(k++)do
				if(!xList[k].IsValid())then continue; endif;
				RegisterIdiObject(xList[k].GetObj());
			endfor;
		endif;
	endproc;
	
	export proc void ArchiveAllNests()
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel==null)then return; endif;
		var CObjQuery xQuery;
		var CObjList xList;
		xQuery.SetClass("Nest_Armoured_Dinosaur",false);
		xQuery.SetClass("Nest_Small_Carnivores",true);
		xQuery.SetClass("Nest_Big_Carnivores",true);
		xQuery.SetClass("Nest_Hadrosaurs",true);
		xQuery.SetClass("Nest_Saurpods",true);
		xQuery.SetClass("Nest_Mammal_Cave",true);
		xQuery.SetClass("nest_ice_mammal_cave",true);
		xQuery.SetClass("Nest_Swimmer",true);
		xQuery.SetClass("Nest_HC_Cititzen",true);
		xQuery.SetClass("Nest_Small_Birds",true);
		xQuery.SetClass("Nest_Birds",true);
		if(xQuery.Execute(xList))then
			var int k, iK=xList.NumEntries();
			for(k=0)cond(k<iK)iter(k++)do
				if(!xList[k].IsValid())then continue; endif;
				CMirageSrvMgr.Get().RegisterNest(cast<CNest>(xList[k].GetObj()),xList[k].GetObj()^.GetAttribs());
				xList[k].GetObj()^.Delete();
			endfor;
		endif;
	endproc;
	
	export proc void ArchiveAllResis()
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel==null)then return; endif;
		var CObjQuery xQuery;
		var CObjList xList;
		xQuery.SetType("STON",false);
		xQuery.SetType("FRUI",true);
		xQuery.SetType("FOOD",true);
		xQuery.SetType("WOOD",true);
		if(xQuery.Execute(xList))then
			var int k, iK=xList.NumEntries();
			for(k=0)cond(k<iK)iter(k++)do
				if(!xList[k].IsValid())then continue; endif;
				CMirageSrvMgr.Get().RegisterResource(cast<CResource>(xList[k].GetObj()),xList[k].GetObj()^.GetAttribs());
				xList[k].GetObj()^.Delete();
			endfor;
		endif;
	endproc;
	
	export proc void ArchiveAllGameObjectsR()
		var int iHndl = CSrvWrap.GetRegionMgr().GetWorldRgnHndl();
		var ^CRegion pxRgn = CSrvWrap.GetRegionMgr().GetRegion(iHndl);
		if(pxRgn!=null)then
			var int i, iC=pxRgn^.NumObjects();
			for(i=0)cond(i<iC)iter(i++)do
				var CObjHndl xHndl = pxRgn^.GetObject(i);
				if(xHndl.IsValid())then
					RegisterGameObject(xHndl.GetObj());
				endif;
			endfor;
		endif;
	endproc;
	
	export proc void ArchiveAllGameObjectsQ()
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel==null)then return; endif;
		var CObjQuery xQuery;
		var CObjList xList;
		if(xQuery.Execute(xList))then
			var int k, iK=xList.NumEntries();
			for(k=0)cond(k<iK)iter(k++)do
				if(!xList[k].IsValid())then continue; endif;
				RegisterGameObject(xList[k].GetObj());
			endfor;
		endif;
	endproc;
	
	export static proc void DumpWorldRegionObjects()
		var int iHndl = CSrvWrap.GetRegionMgr().GetWorldRgnHndl();
		var ^CRegion pxRgn = CSrvWrap.GetRegionMgr().GetRegion(iHndl);
		if(pxRgn!=null)then
			var int i, iC=pxRgn^.NumObjects();
			CMirageSrvMgr.Debug("WorldRgn NumObjects: '"+(iC).ToString()+"'");
			for(i=0)cond(i<iC)iter(i++)do
				var CObjHndl xHndl = pxRgn^.GetObject(i);
				if(xHndl.IsValid())then
					var ^CGameObj pxObj = xHndl.GetObj();
					if(pxObj!=null)then
						Debug((i).ToString()+". obj is: '"+pxObj^.GetName()+"'");
					endif;
				endif;
			endfor;
		endif;
	endproc;
	
	export static proc void DumpQueryObjects()
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel==null)then return; endif;
		var CObjQuery xQuery;
		var CObjList xList;
		if(xQuery.Execute(xList))then
			var int k, iK=xList.NumEntries();
			CMirageSrvMgr.Debug("Query objects: '"+(iK).ToString()+"'");
			for(k=0)cond(k<iK)iter(k++)do
				var CObjHndl xHndl = xList[k];
				if(xHndl.IsValid())then
					var ^CGameObj pxObj = xHndl.GetObj();
					if(pxObj!=null)then
						Debug((k).ToString()+". obj is: '"+pxObj^.GetName()+"'");
					endif;
				endif;
			endfor;
		endif;
	endproc;
	
	export proc void LoadLevelInfo(string p_sFile)
		var ^CPropDB pxSource = new CPropDB;
		if(!pxSource^.Load("C:/"+p_sFile+"levelinfo.txt"))then return; endif;
//		var ^CPropDB.CNode pxRoot = ^(pxSource^.GetRoot());
		var string sLevelInfo = pxSource^.ToString();
		var ^CLevelInfo pxLevelInfo=CSrvWrap.GetLevelInfo(false);
		var ^CPropDB pxGenericDB;
		pxGenericDB=^(pxLevelInfo^.GetGenericData());
		if(pxGenericDB==null)then return; endif;
		var ^CPropDB.CNode pxLIRoot = ^(pxGenericDB^.GetRoot());
		if(pxLIRoot==null)then return; endif;
		pxLIRoot^.Clear();
		pxGenericDB^.FromString(sLevelInfo);
	endproc;
	
	export proc void SaveLevelInfoAttribs(string p_sFile)
		var ^CPropDB pxSource = new CPropDB;
		var ^CPropDB.CNode pxRoot = ^(pxSource^.GetRoot());
		var ^CPropDB.CNode pxMap = pxRoot^.FindNode(p_sFile, true);
		if(pxMap==null)then return; endif;
		var ^CLevelInfo pxLevelInfo=CSrvWrap.GetLevelInfo(false);
		if(pxLevelInfo==null)then return; endif;
		pxLevelInfo^.SavePicToFile("C:/"+p_sFile+"_levelinfo_pic.jpg");
		pxLevelInfo^.SavePicToFile("C:/"+p_sFile+"_levelinfo_pic.tga");
		var ^CGameAttribs pxAttribs = ^(pxLevelInfo^.GetAttribs());
		if(pxAttribs==null)then return; endif;
		var int i, iC = pxAttribs^.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var string sKey=pxAttribs^.GetNameByIndex(i);
			var string sValue=pxAttribs^.GetValueByIndex(i);
			var ^CPropDB.CNode pxParam = pxMap^.FindNode("param_#"+i.ToString()+"_"+sKey, true);
			if(pxParam==null)then continue; endif;
			pxParam^.AddValue("key", sKey);
			pxParam^.AddValue("value", sValue);
		endfor;
		pxSource^.Save("C:/"+p_sFile+"_levelinfo_attribs.txt");
	endproc;
	
	export proc void ExtractThisMap(string p_sFilePrefix)
		SaveNestInfos(p_sFilePrefix);
		SaveResourceInfos(p_sFilePrefix);
		SaveRegions(p_sFilePrefix);
		SaveTAttribs(p_sFilePrefix);
		SaveTriggers(p_sFilePrefix);
		SaveQuests(p_sFilePrefix);
		RegisterAllObjects();
		SaveArchive(p_sFilePrefix);
	endproc;
	
	export static proc void RetrieveFilters(string p_sClass, string p_sMod, ref array string p_rasPaths, ref array string p_rasTypes)
		if(p_sMod=="")then return; endif;
		if(p_sClass=="aje_ankylosaurus")then
			p_rasPaths.AddEntry("/Filters/Aje/Upgrades/aje_ankylosaurus/aje_ankylosaurus");
			p_rasTypes.AddEntry("deactivate");
			p_rasPaths.AddEntry("/Filters/Aje/Upgrades/aje_ankylosaurus/aje_ankylosaurus_catapult");
			p_rasTypes.AddEntry("activate");
			if(p_sMod=="_sec")then
				p_rasPaths.AddEntry("/Filters/Aje/Upgrades/aje_ankylosaurus/aje_ankylosaurus_catapult_stone");
				p_rasTypes.AddEntry("activate");
			elseif(p_sMod=="_thi")then
				p_rasPaths.AddEntry("/Filters/Aje/Upgrades/aje_ankylosaurus/aje_ankylosaurus_catapult_dino");
				p_rasTypes.AddEntry("activate");
			endif;
		elseif(p_sClass=="aje_brachiosaurus")then
			p_rasPaths.AddEntry("/Filters/Aje/Upgrades/aje_brachiosaurus/aje_brachiosaurus");
			p_rasTypes.AddEntry("deactivate");
			if(p_sMod=="_sec")then
				p_rasPaths.AddEntry("/Filters/Aje/Upgrades/aje_brachiosaurus/aje_brachiosaurus_catapult");
				p_rasTypes.AddEntry("activate");
				p_rasPaths.AddEntry("/Filters/Aje/Upgrades/aje_brachiosaurus/aje_brachiosaurus_catapult_stone");
				p_rasTypes.AddEntry("activate");
			elseif(p_sMod=="_thi")then
				p_rasPaths.AddEntry("/Filters/Aje/Upgrades/aje_brachiosaurus/aje_brachiosaurus_mobile_camp");
				p_rasTypes.AddEntry("activate");
			elseif(p_sMod=="_fou")then
				p_rasPaths.AddEntry("/Filters/Aje/Upgrades/aje_brachiosaurus/aje_brachiosaurus_siege");
				p_rasTypes.AddEntry("activate");
			elseif(p_sMod=="_fif")then
				p_rasPaths.AddEntry("/Filters/Aje/Upgrades/aje_brachiosaurus/aje_brachiosaurus_transporter");
				p_rasTypes.AddEntry("activate");
			elseif(p_sMod=="_six")then
				p_rasPaths.AddEntry("/Filters/Aje/Upgrades/aje_brachiosaurus/aje_brachiosaurus_catapult");
				p_rasTypes.AddEntry("activate");
				p_rasPaths.AddEntry("/Filters/Aje/Upgrades/aje_brachiosaurus/aje_brachiosaurus_catapult_dino");
				p_rasTypes.AddEntry("activate");
			endif;
		elseif(p_sClass=="aje_catapult_rex")then
			if(p_sMod=="_sec")then
				p_rasPaths.AddEntry("/Filters/Aje/Upgrades/aje_catapult_rex/aje_catapult_rex_spear");
				p_rasTypes.AddEntry("deactivate");
				p_rasPaths.AddEntry("/Filters/Aje/Upgrades/aje_catapult_rex/aje_catapult_rex_egg");
				p_rasTypes.AddEntry("activate");
			endif;
		elseif(p_sClass=="aje_stegosaurus")then
			if(p_sMod=="_sec")then
				p_rasPaths.AddEntry("/Filters/Aje/Upgrades/aje_stegosaurus/aje_stegosaurus_transporter");
				p_rasTypes.AddEntry("activate");
				p_rasPaths.AddEntry("/Filters/Aje/Upgrades/aje_stegosaurus/aje_stegosaurus");
				p_rasTypes.AddEntry("deactivate");
			endif;
		elseif(p_sClass=="seas_helicopter")then
			if(p_sMod=="_sec")then
				p_rasPaths.AddEntry("/Filters/SEAS/Upgrades/seas_helicopter/seas_helicopter_flying");
				p_rasTypes.AddEntry("activate");
				p_rasPaths.AddEntry("/Filters/SEAS/Upgrades/seas_helicopter/seas_helicopter");
				p_rasTypes.AddEntry("deactivate");
			endif;
		endif;
	endproc;
	
	export static proc void CorrectInvalidNameToReal(ref string po_rsObjClass, ref string po_rsType)
		if(po_rsObjClass.GetLength()<5)then return; endif;
		var string sAddon=po_rsObjClass.Right(4);
		if(sAddon=="_sec"||sAddon=="_thi"||sAddon=="_fou"||sAddon=="_fif"||sAddon=="_six")then
			po_rsObjClass.Delete(po_rsObjClass.GetLength()-4,4);
			po_rsType=sAddon;
		endif;
	endproc;
	
	export proc void DumpGameAttribs()
		CMirageSrvMgr.Debug("");
		CMirageSrvMgr.Debug("gameattribs debug start");
		var ^CLevelInfoHost pxLevelInfo=CSrvWrap.GetLevelInfo(false);
		if(pxLevelInfo==null)then return; endif;
		var ^CGameAttribs pxGIAttr=^(pxLevelInfo^.GetAttribs()^);
		if(pxGIAttr==null)then return; endif;
		var int i, iC=pxGIAttr^.NumEntries();
		CMirageSrvMgr.Debug("NumEntries: '"+(iC).ToString()+"'");
		for(i=0)cond(i<iC)iter(i++)do
			CMirageSrvMgr.Debug("i: '"+(i).ToString()+"'");
			CMirageSrvMgr.Debug("name: '"+(pxGIAttr^.GetNameByIndex(i))+"'");
			CMirageSrvMgr.Debug("value: '"+(pxGIAttr^.GetValueByIndex(i))+"'");
		endfor;
		CMirageSrvMgr.Debug("gameattribs debug end");
	endproc;
	
	export proc void SetServerValue(string p_sName, bool p_bOn)
		if(p_sName=="UseSupply")then
			m_bUseSupplyChecked=true;
			m_bUseSupply=p_bOn;
		elseif(p_sName=="ShowResourcesInFOW")then
			m_bShowResourcesInFOWChecked=true;
			m_bShowResourcesInFOW=p_bOn;
		elseif(p_sName=="HeroPool")then
			m_bHeroPoolChecked=true;
			m_bHeroPool=p_bOn;
		elseif(p_sName=="WarpInvisible")then
			m_bWarpInvisibleChecked=true;
			m_bWarpInvisible=p_bOn;
		elseif(p_sName=="Portals")then
			m_bPortalsChecked=true;
			m_bPortals=p_bOn;
		elseif(p_sName=="NestRespawn")then
			m_bNestRespawnChecked=true;
			m_bNestRespawn=p_bOn;
		elseif(p_sName=="ManaEnabled")then
			m_bManaEnabledChecked=true;
			m_bManaEnabled=p_bOn;
		elseif(p_sName=="UnitResources")then
			m_bUnitResourcesChecked=true;
			m_bUnitResources=p_bOn;
		elseif(p_sName=="AnimalsVisInFOW")then
			m_bAnimalsVisInFOWChecked=true;
			m_bAnimalsVisInFOW=p_bOn;
		elseif(p_sName=="TitanSlots")then
			m_bTitanSlotsChecked=true;
			m_bTitanSlots=p_bOn;
		elseif(p_sName=="FlyingEnabled")then
			m_bFlyingEnabledChecked=true;
			m_bFlyingEnabled=p_bOn;
		elseif(p_sName=="TreasureSharing")then
			m_bTreasureSharingChecked=true;
			m_bTreasureSharing=p_bOn;
		elseif(p_sName=="FruitsRemovement")then
			m_bFruitsRemovementChecked=true;
			m_bFruitsRemovement=p_bOn;
		elseif(p_sName=="BldgMaxCapacity")then
			m_bBldgMaxCapacityChecked=true;
			m_bBldgMaxCapacity=p_bOn;
		endif;
	endproc;
	
	export static proc void CreateCustomFX(int p_iIndex, vec3 p_vPos, bool p_bGroundLevel)
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel!=null)then
			if(p_bGroundLevel)then
				var real fHeight=CSrvWrap.GetScapeMgr().GetHeight(p_vPos.GetX(),p_vPos.GetY());
				p_vPos.SetZ(fHeight);
			endif;
			var int i;
			for(i=0)cond(i<8)iter(i++)do
				var ^CPlayer pxPlayer=pxLevel^.GetPlayer(i);
				if(pxPlayer!=null)then
					var ^CAiPlayer pxAiPl=cast<CAiPlayer>(pxPlayer);
					if(pxAiPl==null)then
						CSrvWrap.SendGenericEvtToPlayer(i, "mrg\t"+p_iIndex.ToString()+"\t" +p_vPos.ToString());
					endif;
				endif;
			endfor;
		endif;
	endproc;
	
	export static proc bool Debug(string p_sText)
		return Debug(p_sText,true);
	endproc;
	
	export static proc bool Debug(string p_sText, bool p_bTime)
		var string sFile="server_log.txt";
		if(!Filesystem.FileExists(sFile))then return false; endif;
		var Filesystem.CFile xFile;
		xFile.OpenAppend(sFile);
		var string sPrefix;
		if(p_bTime)then
			sPrefix=CTime.CurrentTime().ToString()+": ";
		endif;
		xFile.PrintLn(sPrefix+p_sText);
		xFile.Close();
		return true;
	endproc;
	
endclass;

/*

CFeedback.Print(CFeedback.CHAT,"");
CFeedback.Print(-2, 4, "", {0.0,0.0,0.0});
CMirageSrvMgr.Debug("");
Windows.MessageBox("Debug information",""+""+"\n\n Continue?",050004h);
Windows.DbgPrint(""+);

*/