/*?
	?group URS.Scripts.Server.Classes
	?item CBuilding
	?desc This Class describes a Building in the Game.
	?prefix CBuilding
?*/
class CBuilding inherit CFightingObj
	
	var	bool					m_bStoneDelivery;				// can Characters deposite stone here
	var	bool					m_bWoodDelivery;				// can Characters deposite wood here
	var	bool					m_bFoodDelivery;				// can Characters deposite food here
	var	bool					m_bIronDelivery;				// can Characters deposite iron here
	var	bool					m_bResinDelivery;				// can Characters deposite resin (harz) here
	var	bool					m_bBoneDelivery;				// can Characters deposite bone here
	var	bool					m_bHideDelivery;				// can Characters deposite hide (tierhaut) here
	
	var bool					m_bBuildingReady;			//declares if building is ready or not
	
	var	bool					m_bUpgradeRes;				// can Characters deposite resin (harz) here
	var	bool					m_bUpgradeNat;				// can Characters deposite bone here
	var	bool					m_bUpgradeTec;				// can Characters deposite hide (tierhaut) here
	
	var bool					m_bHealthBuilding;				// can Charcters gain Health here
	var bool					m_bManaBuilding;					// can Charcters gain Plus Energy here
	var real					m_fHealingValue;
	
	var array string		m_asLimits;					//names of the limit attribs in player
	var array int				m_aiResLimits;				//resource limits update values
	
	var real						m_fProcess;
	
	var bool 						m_bNight;					// is it Night?
	var bool						m_bPartyMode;
	
	var string 					m_sClass;					// sets class for RallyPoint
	var string					m_sRalPos;
	
	var bool						m_bQuickHarvest;
	export var bool			m_bHidden;
	
	var int							m_iMaxBuilders;
	var CRepairDesc			m_xRepairDesc;
	
	var bool						m_bSelfRepair;
	var bool						m_bSelfBurning;
	export var bool			m_bFakeCorpse;
	export var bool			m_bCustomConstruction;
	export var real			m_fStartHeight;
	export var real			m_fHeightOffset;
	export var CBuildUpMgr m_xBUMgr;
	export var bool			m_bSkipTowerStuff;
	var bool						m_bDeliveryUnbound;
	
	var array CObjHndl m_axCranes;
	export var array vec3 m_avCranes;
	//Test
	var bool m_bDeliverProduct; //Sets if the product is allowed to deliver
	
	var array CBuilding.CBuildUpLink m_axBuildUpLinks; //Array of BuildUp links available
	
	const real					SELF_BURN=5.0;
	const real					WORK_ANIM_TIMEOUT=6.0;
	export const int		WORK_ANIM_TIMER_ID=724;
	export const int		NIGHT_TIMER=196;
	const int 					FUNCTION_TIMER=201;
	const int						PRESENT_MANA_TIMER=40006;
	const int 					FUNCTION_SELF_REPAIR=40013;
	const int 					TIMER_REPAIR_PROTECTION=40042;
	export const int		NEST_GROW_TIMER=40005;
	
	export const string			WORK_ANIM_NAME="work";
	export const string			WORK_FINISHED_ANIM_NAME_1="work_finished";
	export const string			WORK_FINISHED_ANIM_NAME_2="spawn";
	export var bool					m_bUnderRepair; //for burning buildings which are under repair
	export const vec3				CRANE_NONE={0.0,0.0,0.0};
	export var bool					m_bPRDSFX;
	
	class CBuildUpLink
		export var CFourCC	m_xLink;
		export var int		m_iWorkers;
		export var vec3		m_vPos;
	
		export proc bool op_Greater(ref CBuilding.CBuildUpLink p_rxOther)
			return (m_iWorkers>p_rxOther.m_iWorkers);
		endproc;
	
		export proc void DoKArc(ref CArc p_rxArc)
			var string sA=m_xLink.AsString();
			p_rxArc << sA;
			m_xLink=sA;
			p_rxArc << m_iWorkers;
			p_rxArc << m_vPos;
		endproc;
	endclass;
	
	constructor()
		m_bBuildingReady=false;
		m_bPartyMode=false;
		m_bUnderRepair=false;
		m_bPRDSFX=false;
		CMirageSrvMgr.Get().CustomBuildUp(GetClassName(),m_avCranes,m_bCustomConstruction,m_fStartHeight,m_fHeightOffset,m_bFakeCorpse);
		m_bDeliveryUnbound=CMirageSrvMgr.Get().DeliveryUnbound();
	endconstructor;
	
	destructor()
		var ^CBasePlayer pxBasePlayer=CBasePlayer.GetPlayer(GetOwner());
		if(pxBasePlayer!=null)then
			pxBasePlayer^.DestroyLimitCountBuilding(GetHandle());
		endif;
		var int i, iC=m_axCranes.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(m_axCranes[i].IsValid())then
				m_axCranes[i].GetObj()^.Delete();
			endif;
			m_axCranes[i]=CObjHndl.Invalid();
		endfor;
	enddestructor;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="Bldg")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			pxArc^<<m_bBuildingReady;
			if(iVersion>=2)then
				m_xRepairDesc.DoKArc(pxArc,iVersion,true);
			endif;
			if(iVersion>=3)then
				var int i, iC;
				pxArc^ << iC;
				m_aiResLimits=iC;
				for(i=0)cond(i<iC)iter(i++)do
					pxArc^ << m_aiResLimits[i];
				endfor;
			endif;
			if(iVersion>=4)then
				pxArc^ << m_bHidden;
				pxArc^ << m_bUnderRepair;
				pxArc^ << m_bSelfBurning;
				pxArc^ << m_bPRDSFX;
			endif;
		elseif(p_pxReaderNode^.GetType()=="FaCr")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			if(iVersion>=1)then
				var int i, iC;
				pxArc^ << iC;
				m_axCranes=iC;
				for(i=0)cond(i<iC)iter(i++)do
					m_axCranes[i].DoKArc(pxArc^);
				endfor;
				pxArc^ << iC;
				m_avCranes=iC;
				for(i=0)cond(i<iC)iter(i++)do
					pxArc^ << m_avCranes[i];
				endfor;
			endif;
//			if(iVersion>=2)then
////				m_xBUMgr.Load(p_pxReaderNode^.GetSubChunk(0));
//				m_xBUMgr.Load(p_pxReaderNode);
//			endif;
		elseif(p_pxReaderNode^.GetType()=="BUMg")then
			m_xBUMgr.Load(p_pxReaderNode);
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="Bldg"; //Building base
		var int iVersion=5;
		if(CMirageSrvMgr.SDK())then
			iVersion=3;
		endif;
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,iVersion);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		pxArc^ << m_bBuildingReady;
		m_xRepairDesc.DoKArc(pxArc,iVersion,false);
		var int i, iC=m_aiResLimits.NumEntries();
		pxArc^ << iC;
		for(i=0)cond(i<iC)iter(i++)do
			pxArc^ << m_aiResLimits[i];
		endfor;
		if(iVersion>=4)then
			pxArc^ << m_bHidden;
			pxArc^ << m_bUnderRepair;
			pxArc^ << m_bSelfBurning;
			pxArc^ << m_bPRDSFX;
			pxWalk^.Close();
			xBase="FaCr";
			pxWalk=p_pxWriterNode^.AddSubChunk(xBase,2);
			pxArc=^(pxWalk^.GetArc());
			iC=m_axCranes.NumEntries();
			pxArc^ << iC;
			for(i=0)cond(i<iC)iter(i++)do
				m_axCranes[i].DoKArc(pxArc^);
			endfor;
			iC=m_avCranes.NumEntries();
			pxArc^ << iC;
			for(i=0)cond(i<iC)iter(i++)do
				pxArc^ << m_avCranes[i];
			endfor;
			pxWalk^.Close();
//			m_xBUMgr.Save(pxWalk);
			m_xBUMgr.Save(p_pxWriterNode);
		else
			pxWalk^.Close();
		endif;
	endproc;
	
	export proc bool IsBuildMode()
		return (GetConstructLevel()<4);
	endproc;
	
	export proc void Die()
		CBLDGMgr.Get().RemoveBuilding(this);
		CBLDGMgr.Get().RemoveClass(GetLimitClass(),GetTribeName(),GetOwner());
		if(m_bBuildingReady)then
			CBLDGConditionsMgr.Get().DeleteBuilding(this);
			CreateCorpse();
		endif;
		super.Die();
	endproc;
	
	export proc void CreateCorpse()
		var string sGfx;
		var string sClassName = GetClassName();
		var bool bIsWall = GetIsWall();
		var bool bIsGate = GetIsGate();
		var bool bIsTrap = GetIsTrap();
		var bool bIsTower = GetIsTower();
		if(CMirageSrvMgr.Get().UnitResources() && CorpseAvailable(sGfx) && sClassName!="seas_final_boss" && !bIsWall && !bIsGate && !bIsTrap)then
			var CFightingObj.CBuildCosts xCosts = GetBuildCosts();
			if(sClassName=="seas_carrier" || sClassName=="aje_floating_harbour")then
				var vec3 vCorpsePos = GetPos();
				vCorpsePos.SetZ(16.0);
				var ^CChar_Food pxFood=cast<CChar_Food>(CSrvWrap.GetObjMgr()^.CreateObj("ship_corpse",GetOwner(),vCorpsePos,GetRotation()));
				if(pxFood!=null)then
					pxFood^.SetName(GetName());
					pxFood^.SetPos(vCorpsePos);
					pxFood^.Initialize(this);
					pxFood^.SetAggressive(GetTechTreeAggressiv());
					pxFood^.InvokeGenericSCEvent(16,4.0f);
					pxFood^.Init();
				endif;
				return;
			endif;
			if(xCosts.m_iStone == 0)then
				var ^CBldg_Corpse_Wood pxBldgCorpse=cast<CBldg_Corpse_Wood>(CSrvWrap.GetObjMgr()^.CreateObj("BldgCorpse_Wood",GetOwner(),GetPos(),GetRotation()));
				if(pxBldgCorpse!=null)then
					pxBldgCorpse^.SetName(GetName());
					pxBldgCorpse^.SetGFX(sGfx);
					pxBldgCorpse^.Initialize(this);
					pxBldgCorpse^.SetDieAnim("destroy",true);
					pxBldgCorpse^.SetAggressive(GetTechTreeAggressiv());
					pxBldgCorpse^.Init();
				endif;
			else
				var ^CBldg_Corpse_Stone pxBldgCorpse=cast<CBldg_Corpse_Stone>(CSrvWrap.GetObjMgr()^.CreateObj("BldgCorpse_Stone",GetOwner(),GetPos(),GetRotation()));
				if(pxBldgCorpse!=null)then
					pxBldgCorpse^.SetName(GetName());
					pxBldgCorpse^.SetGFX(sGfx);
					//if(sClassName=="aje_sensor_tower")then
					//	pxBldgCorpse^.SetPos(GetPos()); //If it works then its not stupid
					//endif;
					pxBldgCorpse^.Initialize(this);
					pxBldgCorpse^.SetDieAnim("destroy",true);
					pxBldgCorpse^.SetAggressive(GetTechTreeAggressiv());
					pxBldgCorpse^.Init();
				endif;
			endif;
			super.Delete();
			
			//Links D_01 - D_16
			var int i;
			var int iMaxDestDecoLinks = 17;
			if(sClassName=="seas_greenhouse")then
				iMaxDestDecoLinks = 6; //Disable flying links
			endif;
			if(	bIsTower
				|| sClassName=="hu_magic_cauldron"
				|| sClassName=="ninigi_cauldron"
				|| sClassName=="hu_kennel"
				|| sClassName=="ninigi_dilophosaurus_nest"
				|| sClassName=="aje_gallimimus_nest"
				|| sClassName=="seas_stygimoloch_nest" )then
				//TODO: Num links to use based on obj size CGameObj.GetSize();
				iMaxDestDecoLinks = 8;
			endif;
			for(i=1)cond(i<iMaxDestDecoLinks)iter(i++)do
				var CFourCC xLink="D_"+i.ToReal().ToString("02.0");
				var vec3 vDecoPos;
				var vec3 vRot={1.0,0.0,0.0};
				var real fRandomRot = ((Random.GetInt()%100).ToReal() / 100.0) * Math.Pi() * 2.0;
				var real fRandomPos = Random.MTRandF(-2.0, 2.0);
				vRot.SetX(fRandomRot);
				vRot.SetY(fRandomRot);
				vRot.SetZ(fRandomRot);
				GetLinkPosWorld(xLink,vDecoPos);
				vDecoPos.SetX(vDecoPos.GetX()+fRandomPos);
				vDecoPos.SetY(vDecoPos.GetY()+fRandomPos);
				vDecoPos.SetZ(vDecoPos.GetZ()-0.2);
				var string sTribe = GetTribeName();
				sTribe.MakeLower();
				var int iMaxTribeDestDeco = 29;
				if(sTribe=="aje")then
					iMaxTribeDestDeco = 14; //Disable cloth-sim objects
				endif;
				var string sDestObj = sTribe+"_destruction_object_"+(1+Random.GetInt()%iMaxTribeDestDeco).ToReal().ToString("02.0");
				CSrvWrap.GetObjMgr()^.CreateObj(sDestObj,GetOwner(),vDecoPos,vRot);
			endfor;
		else
			//KLog.LogError("CreateCorpse","super.CreateCorpse();");
			//super.CreateCorpse();
		endif;
	endproc;
	
	export proc bool CorpseAvailable(ref string p_rsClass)
		p_rsClass=GetGfxName()+"_dest";
		return CSrvWrap.GetGfxMgrBase().FindGraphicSetEntry(p_rsClass);
	endproc;
	
	export proc bool CreateBuildingCorpse()
		if(!m_bBuildingReady)then return true; endif;
		if(m_bFakeCorpse)then
			var ^CFakeCorpse pxGameObj=cast<CFakeCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("mirage_bldg_corpse",GetOwner(),GetPos(),GetRotation()));
			if(pxGameObj!=null)then
				pxGameObj^.SetSource(this);
				pxGameObj^.Init(GetName(), 3.0, GetGfxName());
				pxGameObj^.AddAddons(GetAddons());
				pxGameObj^.SetDestructLevel(2);
				var bool bIsGate = GetIsGate();
				if(bIsGate)then
					pxGameObj^.SetAnim("open",1);
				endif;
				TransferLinkedObjs(pxGameObj^.GetHandle());
			endif;
			return true;
		endif;
		return false;
	endproc;
	
	export proc void EnableRepairProtection()
		m_bUnderRepair=true;
		if(HasTimer(TIMER_REPAIR_PROTECTION))then DeleteTimer(TIMER_REPAIR_PROTECTION); endif;
		CreateTimer(TIMER_REPAIR_PROTECTION,CGameTimeSpan.OneSecond()*3.0,false);
	endproc;
	
	export proc void SetRepairProtection(bool p_bProtect)
		m_bUnderRepair=p_bProtect;
	endproc;
	
	export proc bool IsUnderRepair()
		return m_bUnderRepair;
	endproc;
	
	export proc bool UpdateDestructionFlags()
		if(GetConstructLevel()<4)then return false; endif;
		if(IsTooMuchDamaged())then
//			if(!IsUnderRepair() && !m_bSelfRepair)then
			if(!IsUnderRepair())then
				IgniteBuilding(SELF_BURN,2,CObjHndl.Invalid(),-1);
			endif;
		endif;
		return super.UpdateDestructionFlags();
	endproc;
	
	export proc bool IsTooMuchDamaged()
		m_bSelfBurning=false;
		if(!CMirageSrvMgr.Get().BuildingBurndown())then return false; endif;
		if(!m_bBuildingReady)then return false; endif;
		if((GetHitpoints()!=GetMaxHitpoints())&&((GetHitpoints()!=0.0f)&&(GetMaxHitpoints()!=0.0f)))then
			var real fPercentage=GetHitpoints()/(GetMaxHitpoints()/100.0f);
			if(fPercentage > 1000.0f)then fPercentage=1000.0f; endif;
			if(fPercentage<10.0f)then
				m_bSelfBurning=true;
				return true;
			endif;
		endif;
		return false;
	endproc;
	
//	export proc void IgniteBuilding(real p_fDmg, int p_iMaxCount, CObjHndl p_xSource, int p_iSource)
//		if(m_bSelfRepair)then
//			return;
//		else
//			super.IgniteBuilding(p_fDmg, p_iMaxCount, p_xSource, p_iSource);
//		endif;
//	endproc;
/*?
	?item 	OnActionStart(void)
	?desc	Is called on Start of an Action
?*/
	proc void OnActionStart()
		GetFSM()^.Enable(false);			// Deactivate the FSM
	endproc;

/*?
	?item	OnInit(bool p_bLoad)
	?desc	Is called after construction to initialize this Structure
	?param	p_bLoad		true if the Initializing-Data have to be loaded
?*/
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetFreeBorderBlocker(true);
		if(!p_bLoad)then															// If the object is created
			m_bSelfRepair=false;
			m_bSelfBurning=false;
			m_bBuildingReady=false;
			SetType("BLDG");															// ... set the Type ...
			SetSelectable(true);														// ... make it selectable ...
			SetHitable(true);															// ... and hitable.
			InitAttribs();														// Initializes the Attributes
			var ^CAttribs pxAttr=GetAttribs();
			if(cast<CVirtualProduceUnit>(this)==null/* && cast<CPirateShipBuildUp>(this)==null*/)then //no ui sound for VPU
				var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
				if(pxLevel!=null)then
					// no building placed fx for virtual produce units or during loading of level
					if(!pxLevel^.IsLoading())then
						InvokeGenericSCEvent(4,3.0f);	// Place building FX
					endif;
					var ^CPlayer pxPlayer=pxLevel^.GetPlayer(GetOwner());
					if(pxPlayer!=null)then
						CSrvWrap.SendGenericEvtToPlayer(pxPlayer^.GetID(), "Placed\t"+GetClassName());
					endif;
				endif;
			endif;
			if(pxAttr!=null)then
				pxAttr^.SetValue("AIRelevant", false);
			endif;
		endif;
		CBLDGMgr.Get().AddBuilding(this);
		CBLDGMgr.Get().AddClass(GetLimitClass(),GetTribeName(),GetOwner(),p_bLoad);
		UpdateAttribs(p_bLoad);
		AddUnit();
		// Sets the Type of Classes on which the Function has Effect ...
		m_xFunctionUnits.SetType("CHTR");											// ... this are Characters ...
		m_xFunctionUnits.SetType("ANML",true);										// ... this are Animals ...
		m_xFunctionUnits.SetType("VHCL",true);										// ... this are Vehicles ...
		m_xFunctionUnits.SetType("SHIP",true);										// ... this are Ships ...
		InitTimers();																// Initializes the Timers
		InitInventory(6);															// Initializes the Inventory
		m_asLimits.AddEntry("max_units");
		m_asLimits.AddEntry("max_stone");
		m_asLimits.AddEntry("max_wood");
		m_asLimits.AddEntry("max_food");
		m_asLimits.AddEntry("max_iron");
		m_asLimits.AddEntry("max_resin");
		m_asLimits.AddEntry("max_bone");
		m_asLimits.AddEntry("max_hide");
		m_aiResLimits=8;
		var ^CFSM pxFSM=GetFSM();													// Initializes the FiniteStateMachine
		// Creates the Idle-States
		var ^CState pxIdleState;
		SetDmg(0.0);
		SetMovableInFight(false);
		SetCanWalk(false);
		SetCanSwim(false);
		SetCanFly(false);
		m_bDeliverProduct=false;
		m_bQuickHarvest=false;
		m_bHidden=false;
//		SetPlaceBlocker(true);
		OnTechTreeChange();
		if(!p_bLoad)then
			SetPlaceBlocker(m_bPBlocker);
			StartTT();
			SetCanFightAttrib(false);
		else
			SetCanFightAttrib(m_bPBlocker);
		endif;
		SetMaxBuilders(10);
		CScareMap.Get().AddScareSource(GetPos(), GetRadius()*2.0f, 10.0f, 3, "building");
		CBuildingCost.Register(this);
		m_xRepairDesc.Init(GetHandle());
	endproc;
	
	export proc void SetIced(real p_fDuration)
		//buildings can't get iced
	endproc;
	
	proc void CheckAge()
		// track the time we reached a new techtree level for the statistics
		var CGameTime xTime=CTimeMgr.Get().GetTime();
		var int iOldAge=GetAge();
		var int iFinal=0;
//		var string sTribe=GetPlayerTribeName();
		var string sTribe=GetTribeName();
		if(m_xTechTree.GetValueI("Objects/"+sTribe+"/InventObjects/final_stage/invented",0)!=0)then
			iFinal=6;
		endif;
		if(m_xTechTree.GetValueB("/Objects/"+sTribe+"/InventObjects/age_5/invented",false))then
			SetAge(5);
			CSrvWrap.GetGameLogger().Log("Age",GetOwner().ToString(),"5");
		elseif(m_xTechTree.GetValueB("/Objects/"+sTribe+"/InventObjects/age_4/invented",false))then
			SetAge(4);
			CSrvWrap.GetGameLogger().Log("Age",GetOwner().ToString(),"4");
		elseif(m_xTechTree.GetValueB("/Objects/"+sTribe+"/InventObjects/age_3/invented",false))then
			SetAge(3);
			CSrvWrap.GetGameLogger().Log("Age",GetOwner().ToString(),"3");
		elseif(m_xTechTree.GetValueB("/Objects/"+sTribe+"/InventObjects/age_2/invented",false))then
			SetAge(2);
			CSrvWrap.GetGameLogger().Log("Age",GetOwner().ToString(),"2");
		else
			SetAge(1);
		endif;
		var int iMaxAge=GetAge()+1;
		CheckEpoch(iMaxAge);
		var ^CAttribs pxAttribs=GetPlayerAttribs();
		if(pxAttribs!=null)then
			if(iOldAge!=GetAge()&&iOldAge<GetAge()&&GetTribeName()==GetPlayerTribeName())then
				pxAttribs^.SetValue("age", GetAge());
			endif;
			iOldAge=pxAttribs^.GetValueInt("final");
			if(iOldAge!=iFinal&&iOldAge==0&&GetTribeName()==GetPlayerTribeName())then
				pxAttribs^.SetValue("final", iFinal);
			endif;
		endif;
	endproc;
	
	export proc void HandleEditorCommand(string p_sCommand,^CGameObj p_pxObject,vec3 p_vPos,string p_sMiscParams)
		if(p_sCommand=="LE_SetReady")then
			if(p_sMiscParams=="true")then
				BuildUpSDK();
			endif;
		else
			super.HandleEditorCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams);
		endif;
	endproc;
	
	export proc bool DoesCountInUnitLimit()
		return false;
	endproc;
	
	export proc void SetProcess(int p_iP)
		var ^CAttribs pxA=GetAttribs();
		if(pxA!=null)then
			pxA^.SetValue("CurProcess", p_iP);
			if(m_bCustomConstruction)then
				pxA^.SetValue("BuildupProcess", p_iP);
			endif;
		endif;
		if(m_bCustomConstruction && GetConstructLevel()<4)then
			m_xBUMgr.Update(GetTtGfx());
		endif;
	endproc;
	
	export proc void UpdateAttribs(bool p_bLoad)
		super.UpdateAttribs(p_bLoad);
		var ^CAttribs pxAttribs=GetAttribs();
		if(pxAttribs==null)then return; endif;
		if(!p_bLoad)then
			pxAttribs^.SetValue("CurTask","Ready");									//new_attr: currently processed task in this building
			pxAttribs^.SetValue("CurProcess",100);									//new_attr: currently processing state in CurTask
			pxAttribs^.SetValue("BuildupProcess",0);
			pxAttribs^.SetValue("CurProcessObj","");								//new_attr: currently processed object
		endif;
	endproc;
	
	export proc void UpdateDeliveries()
		if(m_bBuildingReady)then
			super.UpdateDeliveries();
		endif;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		//don't do that in OnInit, because VirtualProduceUnit's OnInit can be called later
		if(!IsBuildMode())then
			SetReady();
		endif;
		if(!m_bBuildingReady && m_bCustomConstruction)then
			SetGFX(GetFakeGfx());
			m_xBUMgr.Init(this, m_fStartHeight, m_fHeightOffset);
		endif;
	endproc;
	
	proc void OnDefend(^CGameObj p_pxEnemy)
		if(cast<CWall>(this)==null)then
			ShoutForHelp(false);
		endif;
	endproc;
	
	proc void UpdateFOW()
		if(m_bBuildingReady)then
			var real fFOW=m_xTechTree.GetValueR(GetObjPath()+"/FOW",25.0);
			SetFOWRange(fFOW);
		else
			SetFOWRange(0.0);
		endif;
	endproc;
	
	export proc bool UpdateGfx()
	
		if(m_axBuildUpLinks.NumEntries()==0)then
			var int i;
			for(i=0)cond(i<10)iter(i++)do
				var CFourCC xLink="Bl_"+i.ToString();
				var vec3 vPos;
				if(GetLinkPosWorld(xLink, vPos))then
					var ^CBuilding.CBuildUpLink pxLink=^(m_axBuildUpLinks.NewEntryRef());
					pxLink^.m_xLink=xLink;
					pxLink^.m_vPos=vPos;
				else
					//Fake buildup pos if there is no Bl_ links
					vPos = GetPos();
					var real fBldgSize = GetRadius() - 10.0;
					var real fAngle = 36.0 * i.ToReal();
					fAngle = fAngle*Math.Pi()/180.0;
					
					vPos.SetX(vPos.GetX() + fBldgSize * Math.Cos(fAngle)); 
					vPos.SetY(vPos.GetY() + fBldgSize * Math.Sin(fAngle)); 
					var ^CBuilding.CBuildUpLink pxLink=^(m_axBuildUpLinks.NewEntryRef());
					pxLink^.m_xLink=xLink;
					pxLink^.m_vPos=vPos;
				endif;
			endfor;
		endif;
	
		if(!m_bBuildingReady && m_bCustomConstruction)then
			return false;
		endif;

		return super.UpdateGfx();
	endproc;
	
	export proc CFourCC OccupyLink(vec3 p_vBuilderPos)
		m_axBuildUpLinks.QSort();
		var int i, iC=m_axBuildUpLinks.NumEntries();
		var CFourCC xReturn="INVD";
		if(iC==0)then return xReturn; endif;
		var int iMaxWorker=m_axBuildUpLinks[0].m_iWorkers;
		var real fMinDist=999999999.9;
		var int iIndex=-1;
		for(i=0)cond(i<iC)iter(i++)do
			if(m_axBuildUpLinks[i].m_iWorkers>iMaxWorker)then break; endif;
			var real fSqDist=(m_axBuildUpLinks[i].m_vPos-p_vBuilderPos).Abs2S();
			if(fSqDist<fMinDist)then
				fMinDist=fSqDist;
				iIndex=i;
			endif;
		endfor;
		if(iIndex==-1)then return xReturn; endif;
		xReturn=m_axBuildUpLinks[iIndex].m_xLink;
		m_axBuildUpLinks[iIndex].m_iWorkers++;
		return xReturn;
	endproc;
	
	export proc vec3 GetFakeBuilderPos()
		var int i, iC=m_axBuildUpLinks.NumEntries();
		var vec3 vPos;
		if(iC==0 || iC != 10)then
			vPos = GetPos();
			return vPos;
		endif;
		return m_axBuildUpLinks[Random.GetInt()%9].m_vPos;
	endproc;
	
	export proc void FreeLink(CFourCC p_xLink)
		if(p_xLink=="INVD")then return; endif;
		var int iIndex=-1;
		var int i, iC=m_axBuildUpLinks.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(m_axBuildUpLinks[i].m_xLink==p_xLink)then
				iIndex=i;
				break;
			endif;
		endfor;
		if(iIndex==-1)then return; endif;
		m_axBuildUpLinks[iIndex].m_iWorkers--;
	endproc;
	
/*?
	?item 	SetOwner(int p_iNewOwner)
	?desc	Sets a new Owner for this Building
	?param	p_iNewOwner		The ID of the PlayerSlot of the new Owner
?*/
	export proc void SetOwner(int p_iNewOwner)
		if(GetOwner()==p_iNewOwner)then return; endif;
		// Upadte the Ressource-Limits of the old Owner
		CBLDGMgr.Get().RemoveBuilding(this);
		CBLDGMgr.Get().RemoveClass(GetLimitClass(),GetTribeName(),GetOwner());
		if(m_bBuildingReady)then
			var ^CBasePlayer pxBasePlayer=CBasePlayer.GetPlayer(GetOwner());
			if(pxBasePlayer!=null)then
				pxBasePlayer^.RemoveLimitCountBuilding(GetHandle());
			endif;
			CBLDGConditionsMgr.Get().DeleteBuilding(this);
		endif;
		// Call the Method of the Superclass to set a new Owner
		super.SetOwner(p_iNewOwner);
		CBLDGMgr.Get().AddBuilding(this);
		CBLDGMgr.Get().AddClass(GetLimitClass(),GetTribeName(),GetOwner());
		if(m_bBuildingReady)then
			var ^CBasePlayer pxBasePlayer=CBasePlayer.GetPlayer(GetOwner());
			if(pxBasePlayer!=null)then
				pxBasePlayer^.AddLimitCountBuilding(GetHandle());
			endif;
			CBLDGConditionsMgr.Get().AddBuilding(this);
		endif;
		OnTechTreeChange();
	endproc;

/*?
	?item 	InitTimer(void)
	?desc	Initializes the Timers
?*/
	proc void InitTimers()
		if(!m_bBuildingReady)then return; endif;										// if the Build-Mode is active, return.
		//healing building timer
		if(m_bHealthBuilding && !HasTimer(FUNCTION_TIMER))then							// If this is a Healthbuilding ...
			CreateTimer(FUNCTION_TIMER,CGameTimeSpan.OneSecond()*2.0,true);		// Create a new one
			m_xLastFunctionTime=CTimeMgr.Get().GetTime();								// Update the last Timer, the Function called
		endif;
		if(m_bManaEnabled && m_bManaBuilding && !HasTimer(PRESENT_MANA_TIMER))then
			CreateTimer(PRESENT_MANA_TIMER,CGameTimeSpan.OneSecond()*2.0,true);
			m_xLastSecFunctionTime=CTimeMgr.Get().GetTime();
		endif;
		if(m_bSelfRepair && !HasTimer(FUNCTION_SELF_REPAIR))then							// If selfrepair is invented and not started...
			CreateTimer(FUNCTION_SELF_REPAIR,CGameTimeSpan.OneSecond()*1.0,true);		// Create a new one
		endif;
		//night mode timer
		if(!HasTimer(NIGHT_TIMER))then
			if(m_bPartyMode)then
				CreateTimer(NIGHT_TIMER,CGameTimeSpan.OneSecond()*0.2f,true);		// creates the Timer
			else
				CreateTimer(NIGHT_TIMER,CGameTimeSpan.OneSecond()*20.0f,true);		// creates the Timer
			endif;
		endif;
	endproc;
	
	export proc void OnWork()
		DeleteTimer(WORK_ANIM_TIMER_ID);
		CreateTimer(WORK_ANIM_TIMER_ID,CGameTimeSpan.OneSecond()*WORK_ANIM_TIMEOUT,false);
		//KLog.LogWarn("CHP","OnWork:"+GetCurrentAnimName()+" "+HasAnim(WORK_ANIM_NAME).ToString());
		if((GetCurrentAnimName()!=WORK_ANIM_NAME||GetCurrentAnimMode()!=3)&&HasAnim(WORK_ANIM_NAME))then
			SetAnim(WORK_ANIM_NAME,3);
		endif;
	endproc;
	
	export proc void OnWorkFinished()
		if(HasAnim(WORK_FINISHED_ANIM_NAME_1))then
			if(HasAction())then
				SetAnim(WORK_FINISHED_ANIM_NAME_1,1);
			else
				AnimAction(WORK_FINISHED_ANIM_NAME_1);
			endif;
		elseif(HasAnim(WORK_FINISHED_ANIM_NAME_2))then
			if(HasAction())then
				SetAnim(WORK_FINISHED_ANIM_NAME_2,1);
			else
				AnimAction(WORK_FINISHED_ANIM_NAME_2);
			endif;
		else
			SetIdleAnim();
		endif;
	endproc;
	
	export proc void OnWorkFinishedSimple()
		SetIdleAnim();
	endproc;
	
	export proc void StartWorkAnim()
		DeleteTimer(WORK_ANIM_TIMER_ID);
		CreateTimer(WORK_ANIM_TIMER_ID,CGameTimeSpan.OneSecond()*WORK_ANIM_TIMEOUT,false);
		if(GetCurrentAnimName()!=WORK_ANIM_NAME&&HasAnim(WORK_ANIM_NAME))then
			SetAnim(WORK_ANIM_NAME,3);
		endif;
	endproc;
	
	export proc void DoWorkAnim()
		if((GetCurrentAnimName()!=WORK_ANIM_NAME||GetCurrentAnimMode()!=3)&&HasAnim(WORK_ANIM_NAME))then
			SetAnim(WORK_ANIM_NAME,3);
		endif;
	endproc;
	
	export proc void StopWorkAnim()
		if(GetCurrentAnimName()==WORK_ANIM_NAME)then
			EndCurrentLoopAnim();
		endif;
	endproc;
	
	export proc int GetAggressive()
		if(!IsBuildMode())then
			return GetTechTreeAggressiv();
		else
			return -1;
		endif;
	endproc;
	
	//Sets whether the worker is supposed to work on that building immediately.
	export proc void SetQuickHarvest(bool p_bParam)
		m_bQuickHarvest=p_bParam;
	endproc;
	
	export proc bool GetQuickHarvest()
		return(m_bQuickHarvest);
	endproc;
	
	export proc void SetMaxBuilders(int p_iMaxBuilders)
		m_iMaxBuilders=p_iMaxBuilders;
	endproc;
	
	export proc ref int GetMaxBuilders()
		return m_iMaxBuilders;
	endproc;
	
	export proc void SetPFBlocking()
		if(m_bPBlocker)then
			CSrvWrap.GetPathfinder().UpdatePFBlocker(this);
		endif;
	endproc;

/*?
	?item 	SetReady(void)
	?desc	Sets this building Ready. This means that the building is built
			up and ready to use.
?*/
	export proc void SetReady()
		// show feedback message if build up is finished
		begin userfeedback;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(!m_bBuildingReady && pxLevel!=null && !m_bHidden)then
				if(cast<CVirtualProduceUnit>(this)==null/* && cast<CPirateShipBuildUp>(this)==null*/)then //no ui sound for VPU
					var ^CPlayer pxPlayer=pxLevel^.GetPlayer(GetOwner());
					if(pxPlayer!=null)then
						CSrvWrap.SendGenericEvtToPlayer(pxPlayer^.GetID(), "Completed\t"+GetClassName());
						CFeedback.Print(pxPlayer^.GetID(), CFeedback.ECONOMY, "_NT_BldgDone\t"+GetTechTreeDesc(), GetPos());
					endif;
				endif;
			endif;
		end userfeedback;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("building_ready",true);
			pxAttr^.SetValue("count_as_hq",true);
		endif;
		var bool bBuildingWasAlreadyReady=m_bBuildingReady;
		m_bBuildingReady=true;
		SetConstructLevel(4); // Deactivates the BuildMode ...
		if(pxAttr!=null)then
			pxAttr^.SetValue("AIRelevant", true);
		endif;
		var CFourCC xFCCB;
		xFCCB="Cr_1";RemLinkGFX(xFCCB);
		xFCCB="Cr_2";RemLinkGFX(xFCCB);
		xFCCB="Cr_3";RemLinkGFX(xFCCB);
		xFCCB="Cr_4";RemLinkGFX(xFCCB);
		RemoveCranes();
		InitTimers();
		//Fieser dreckiger Hack /  ja da hast du völlig recht !!! //Ich kannte mal einen Hack aus Letland... //moment, war das der mit der blondine als freundin?
		/*var ^CGrowingField pxField=cast<CGrowingField>(this);
		var ^CTrap pxTrap=cast<CTrap>(this);
		if(pxField==null && pxTrap==null)then
			CSrvWrap.GetPathfinder().AddPFBlocker(this);
		endif;*/
		SetPFBlocking();
		CBLDGConditionsMgr.Get().AddBuilding(this);
		var bool bNight=!CTimeMgr.Get().IsVirtualDay();
		SetRndInvMaskSingleFlagInv(VIS_FLAG_BLDG_NIGHTMODE,m_bNight);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_BLDG_INIGHTMODE,!m_bNight);
		OnTechTreeChange();
		if(!bBuildingWasAlreadyReady)then
			if(cast<CVirtualProduceUnit>(this)==null)then 
				// no building ready fx for virtual produce units or during loading of level
				var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
				if(pxLevel!=null)then
						if(!pxLevel^.IsLoading())then
							InvokeGenericSCEvent(5,3.0f);
						endif;
					endif;
			endif;
		endif;
		var ^CBasePlayer pxBasePlayer=CBasePlayer.GetPlayer(GetOwner());
		if(pxBasePlayer!=null)then
			pxBasePlayer^.AddLimitCountBuilding(GetHandle());
		endif;
		SetIdleAnim();
		begin UpdateLinked;
			var CGuid xPar;
			if(GetGroupedParent(xPar))then
				var ^CBuilding pxBuilding=cast<CBuilding>(CSrvWrap.GetObjMgr()^.GetObjByGuid(xPar));
				if(pxBuilding!=null)then
					pxBuilding^.OnTechTreeChange();
				endif;
			endif;
		end UpdateLinked;
		if(m_bCustomConstruction)then
			m_xBUMgr.Update(GetTtGfx());
		endif;
	endproc;
	
	export proc void SetReadyBuild()
		SetReady();
		CProdLog.AddEntry(GetOwner(),GetClassName());
		CGameOverMgr.Get().OnReadyBuild(this);
	endproc;
	
	export proc void SetReadyBuildTrigger()
		SetReady();
		CProdLog.AddEntry(GetOwner(),GetClassName());
		CGameOverMgr.Get().OnReadyBuild(this);
	endproc;
	
	//Returns true if building is ready
	export proc bool IsReady()
		return(m_bBuildingReady);
	endproc;
	
	export proc void OnTechTreeChange()
		super.OnTechTreeChange();
	endproc;
	
	export proc void OnTechTreeChange(ref CStringArray p_rasChanges)
		super.OnTechTreeChange(p_rasChanges);
		m_fHealingValue=m_xTechTree.GetValueR("Objects/"+GetPlayerTribeName()+"/InventObjects/Healing/value",1.0);
		var int i,iC=p_rasChanges.NumEntries();
		var bool bUpdateLimits=false;
		for(i=0) cond(i<iC) iter(i++)do
			if(p_rasChanges[i].Find("/UpdateLimits/max_")>0)then
				bUpdateLimits=true;
			endif;
		endfor;
		if(bUpdateLimits)then
			var ^CBasePlayer pxBasePlayer=CBasePlayer.GetPlayer(GetOwner());
			if(pxBasePlayer!=null)then
				pxBasePlayer^.UpdateLimits(false);
			endif;
		endif;
		var string sObjPath="/"+GetObjPath();
		var bool bSpecialAbilities=false;
		for(i=0) cond(i<p_rasChanges.NumEntries()) iter(i++)do
			var string sVal=p_rasChanges[i];
			if(sVal.Find("/ForceWeaponUpdate")!=-1)then
				bSpecialAbilities=true;
			elseif((sVal.Find(sObjPath)!=-1)||(sObjPath.Find(sVal)!=-1))then
				if(sVal.Find("special_abilities")!=1)then
					bSpecialAbilities=true;
				endif;
			endif;
		endfor;
		var ^CTechTree.CNode pxNode=m_xTechTree.FindNode(m_sObjPath+"/special_abilities");
		m_xAbilities.AddAbilities(pxNode, true);
		if(bSpecialAbilities)then
			var ^CFightingObj.CSpecialAbility pxSuppr=m_xAbilities.GetAbility("fire_suppression", true);
			DeleteTimer(FUNCTION_SELF_REPAIR);
			if(pxSuppr!=null)then
				m_bSelfRepair=true;
				CreateTimer(FUNCTION_SELF_REPAIR, CGameTimeSpan.OneSecond() * 1.0, true);
				m_fCuringAmount=pxSuppr^.GetValueF("amount");
				FireExtinguish();
			else
				m_bSelfRepair=false;
				DeleteTimer(FUNCTION_SELF_REPAIR);
			endif;
		endif;
	endproc;
	
	export proc void SetTrappedHandle(CObjHndl p_xTrapHndl)
		if(!m_bBuildingReady)then return; endif;
		super.SetTrappedHandle(p_xTrapHndl);
	endproc;
	
	export proc void SetTrappedBool(bool p_bTrapped)
		if(!m_bBuildingReady)then return; endif;
		super.SetTrappedBool(p_bTrapped);
	endproc;
	
	export proc void SetTrappedTime(real p_fDuration)
		if(!m_bBuildingReady)then return; endif;
		super.SetTrappedTime(p_fDuration);
	endproc;
	
	export proc void UpdateTechTree()
	endproc;
/*
	export proc real GetTechTreeHitpoints()
		var real fOwnMaxHitpoints=super.GetTechTreeHitpoints();
	
		var int i,iC=GetMaxGroupedChildSlots();
		for(i=0)cond(i<iC)iter(i++)do
			var CGuid xWalk;
			if(GetGroupedChild(i,xWalk))then
				var ^CBuilding pxB=cast<CBuilding>(CSrvWrap.GetObjMgr()^.GetObjByGuid(xWalk));
				if(pxB!=null)then
					fOwnMaxHitpoints+=pxB^.GetTechTreeHitpoints();
				endif;
			endif;
		endfor;
		return fOwnMaxHitpoints;
	endproc;
*/
	proc void SetStoneDelivery(bool p_bStone)
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr==null)then return; endif;
		m_bStoneDelivery=p_bStone;
		pxAttr^.SetValue("stoneDelivery",p_bStone);
	endproc;
	
	proc void SetWoodDelivery(bool p_bWood)
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr==null)then return; endif;
		m_bWoodDelivery=p_bWood;
		pxAttr^.SetValue("woodDelivery",p_bWood);
	endproc;
	
	proc void SetFoodDelivery(bool p_bFood)
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr==null)then return; endif;
		m_bFoodDelivery=p_bFood;
		pxAttr^.SetValue("foodDelivery",p_bFood);
	endproc;
	
	proc void SetIronDelivery(bool p_bIron)
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr==null)then return; endif;
		m_bIronDelivery=p_bIron;
		pxAttr^.SetValue("ironDelivery",p_bIron);
	endproc;
	
	proc void SetResinDelivery(bool p_bResin)
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr==null)then return; endif;
		m_bResinDelivery=p_bResin;
		pxAttr^.SetValue("resinDelivery",p_bResin);
	endproc;
	
	proc void SetBoneDelivery(bool p_bBone)
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr==null)then return; endif;
		m_bBoneDelivery=p_bBone;
		pxAttr^.SetValue("boneDelivery",p_bBone);
	endproc;
	
	proc void SetHideDelivery(bool p_bHide)
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr==null)then return; endif;
		m_bHideDelivery=p_bHide;
		pxAttr^.SetValue("hideDelivery",p_bHide);
	endproc;
	
	export proc bool AttackEnemy(^CFightingObj p_pxEnemy, vec3 p_vTarget, ref bool p_rbRotated)
		//dont defend
		return false;
	endproc;
	
	//////////////////////// IDLE STATE ////////////////////////////////
	export proc void OnIdleEnter(^CState p_pxFrom, ^CState p_pxTo)
		SetIdleAnim();
		super.OnIdleEnter(p_pxFrom,p_pxTo);
	endproc;
	
	export proc void OnIdleTick(int p_iTime)
		super.OnIdleTick(p_iTime);
	endproc;
	
	export proc void OnIdleLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.OnIdleLeave(p_pxFrom,p_pxTo);
	endproc;
	
	export proc void SetIdleAnim()
		if(HasAnim("standanim"))then
			if(GetCurrentAnimName()!="standanim")then
				SetAnim("standanim",3);
			endif;
		elseif(HasAnim("idle"))then
			if(GetCurrentAnimName()!="idle")then
				SetAnim("idle",3);
			endif;
		elseif(HasAnim("work"))then
			if(GetCurrentAnimName()!="work")then
				SetAnim("work",1);
			else
				EndCurrentLoopAnim();
			endif;
		elseif(HasAnim("deliver"))then
			if(GetCurrentAnimName()!="deliver")then
				SetAnim("deliver",1);
			else
				EndCurrentLoopAnim();
			endif;
		endif;
	endproc;
	
	///////////////////////////////////////////////////////////////////

/*?
	?item 	DoBuildFunction(void)
	?desc	Processes the autmatic Function of this Building. This can be
			Health.
?*/
	
	proc void ReplenishMana()
		//HACK to disable important building functions while incapacitation (see aje rammer)
		if(GetIncapacitated())then return; endif;
		//ENDHACK
		if(!m_bBuildingReady)then return; endif;
		if(!m_bManaBuilding)then return; endif;
		var CGameTime xNow=CTimeMgr.Get().GetTime();
		var CGameTimeSpan xDT=xNow-m_xLastSecFunctionTime;
		var real fTime=xDT.GetSecondsF();
		if(fTime==0.0)then return; endif;
		m_xLastSecFunctionTime=xNow;
		var CObjList xUnits;
		CSrvWrap.GetDiplomacyMgr().AddMyFriendsToSearch(GetOwner(), m_xFunctionUnits);
		m_xFunctionUnits.RegionCircle(GetPos(),GetManaRadius());
		if(!m_xFunctionUnits.Execute(xUnits))then return; endif;
		var int i,iC=xUnits.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFightingObj pxFWalk=cast<CFightingObj>(xUnits[i].GetObj());
			if(pxFWalk!=null)then
				var real fValue=fTime*GetManaAmount(pxFWalk);
				pxFWalk^.AddMana(fValue);
			endif;
		endfor;
	endproc;
	
	proc void DoBuildingFunction()
		//TODO: use regions instead of CObjQuery
		if(!m_bBuildingReady)then return; endif;
		if(!m_bHealthBuilding)then return; endif;			// If this Building do not have such a Function return.
		var CGameTime xNow=CTimeMgr.Get().GetTime();						// Gets the current GameTime ...
		var CGameTimeSpan xDT=xNow-m_xLastFunctionTime;					// ... and sets the DeltaTime between now and the last call.
		var real fTime=xDT.GetSecondsF();
		if(fTime==0.0)then return; endif;
		m_xLastFunctionTime=xNow;
		//HACK to disable important building functions while incapacitation (see aje rammer)
		if(GetIncapacitated())then return; endif;
		//ENDHACK
		var CObjList xUnits;
		//Henry: HACK für SEAS Amph.-Einheiten und Dunkleosteus
		var CObjList xAddUnits;
		var bool bAddUnitsFound=false;
		var ^CHarbour pxHarbour=cast<CHarbour>(this);
		var ^CTemple pxTemple=cast<CTemple>(this);
		if(pxHarbour!=null)then
//			m_xAdditionalFunctionUnits.SetClass("ninigi_pirate_ship_row",true);
//			m_xAdditionalFunctionUnits.SetClass("ninigi_pirate_ship_sail",true);
//			m_xAdditionalFunctionUnits.SetClass("ninigi_pirate_ship_tail",true);
			m_xAdditionalFunctionUnits.SetClass("ninigi_helicopter",false);
			m_xAdditionalFunctionUnits.SetClass("seas_helicopter",true);
			m_xAdditionalFunctionUnits.SetClass("seas_hovercraft",true);
			CSrvWrap.GetDiplomacyMgr().AddMyFriendsToSearch(GetOwner(), m_xAdditionalFunctionUnits);
			m_xAdditionalFunctionUnits.RegionCircle(GetPos(),GetHealingRadius());
			if(m_xAdditionalFunctionUnits.Execute(xAddUnits))then
				bAddUnitsFound=true;
			endif;
		elseif(pxTemple!=null)then
			m_xAdditionalFunctionUnits.SetClass("aje_transport_turtle",false);
			CSrvWrap.GetDiplomacyMgr().AddMyFriendsToSearch(GetOwner(), m_xAdditionalFunctionUnits);
			m_xAdditionalFunctionUnits.RegionCircle(GetPos(),GetHealingRadius());
			if(m_xAdditionalFunctionUnits.Execute(xAddUnits))then
				bAddUnitsFound=true;
			endif;
		endif;
		//ENDHACK
		CSrvWrap.GetDiplomacyMgr().AddMyFriendsToSearch(GetOwner(), m_xFunctionUnits);
		m_xFunctionUnits.RegionCircle(GetPos(),GetHealingRadius()); // ... this is the Function Radius ...
		m_xFunctionUnits.Execute(xUnits);
		if(bAddUnitsFound)then
			xUnits.Include(xAddUnits);
		endif;
		if(xUnits.NumEntries()<1)then return; endif;
		var int i,iC=xUnits.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do // Loop through all units in radius ...
			var ^CFightingObj pxFWalk=cast<CFightingObj>(xUnits[i].GetObj());
			if(pxFWalk!=null)then
				var real fValue=fTime*GetHealingAmount(pxFWalk);
				pxFWalk^.HealMe(fValue);// ... change the hitpoints.
			endif;
		endfor;
	endproc;
	
	export proc void DoSelfRepair()
		if(!m_bBuildingReady)then return; endif;
		//HACK to disable important building functions while incapacitation (see aje rammer)
		if(GetIncapacitated())then return; endif;
		//ENDHACK
		if(!m_bSelfRepair)then return; endif; //If this Building do not have such a Function.
		var real fSelfRepair=m_fCuringAmount;
		if(m_bSelfBurning)then
			fSelfRepair+=SELF_BURN;
		endif;
		CureMe(fSelfRepair);
	endproc;
	
	export proc void SetUnlimitedBuilding(bool p_bState)
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			if(p_bState)then
				pxAttr^.SetValue("UnlimitedBuilding",1);
			else
				pxAttr^.SetValue("UnlimitedBuilding",0);
			endif;
		endif;
	endproc;
	
	export proc void SetConvertBuilding(bool p_bState)
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			if(p_bState)then
				pxAttr^.SetValue("ConvertBuilding",1);
			else
				pxAttr^.SetValue("ConvertBuilding",0);
			endif;
		endif;
	endproc;
	
	export proc void SetInventSite(bool p_bState)
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			if(p_bState)then
				pxAttr^.SetValue("IsInventSite",1);
			else
				pxAttr^.SetValue("IsInventSite",0);
			endif;
		endif;
	endproc;
	
	export proc void Action(string p_sTTPath)
		if(p_sTTPath.Find("Kill")!=-1)then
			DiePerHarakiri();
			return;
		endif;
		var CObjHndl xPyCO;
		var CAction.CResourceCosts xCosts;
		var bool bCheck=false;
		var string sBefore, sAfter, sTribe;
		if(CRequirementsMgr.Get().CheckConditionsAndPayLimit(this, p_sTTPath, xPyCO, xCosts, true, sBefore, sAfter, bCheck, sTribe))then
			// Create a Invent-Task
			var ^CAction pxTask= cast<CAction>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"Action"));
//			if(pxTask==null)then return; endif;
//			pxTask^.Init(GetHandle(),p_sTTPath,xCosts);
			if(pxTask==null)then return; endif;
			if(!pxTask^.Init(GetHandle(), p_sTTPath, xCosts, sBefore, sAfter, bCheck, sTribe))then
				pxTask^.GetFactory()^.FreeState(pxTask);
				return;
			endif;
			pxTask^.SetPyCO(xPyCO);
			AddTask(pxTask, true);
		endif;
	endproc;
	
	export proc void CancelAction(string p_sTTPath)
		var ^CVirtualProduceUnit pxProduceUnit=cast<CVirtualProduceUnit>(GetProduceUnit().GetObj());
		if(pxProduceUnit!=null)then
			var ^CTaskMgr pxVPTM=pxProduceUnit^.GetTaskMgr();
			if(pxVPTM!=null)then
				pxVPTM^.RemoveAction(p_sTTPath);
				return;
			endif;
		endif;
		if(m_pxTaskMgr!=null)then
			m_pxTaskMgr^.RemoveAction(p_sTTPath);
		endif;
	endproc;
	
	export proc bool HasCanceledAction(string p_sTTPath)
		var bool bReturn = false;
		var ^CVirtualProduceUnit pxProduceUnit=cast<CVirtualProduceUnit>(m_xProduceUnit.GetObj());
		if(pxProduceUnit!=null)then
			var ^CTaskMgr pxVPTM=pxProduceUnit^.GetTaskMgr();
			if(pxVPTM!=null)then
				bReturn = pxVPTM^.CanRemoveAction(p_sTTPath);
				if(bReturn)then
					return bReturn;
				endif;
			endif;
		endif;
		if(m_pxTaskMgr!=null)then
			bReturn = m_pxTaskMgr^.CanRemoveAction(p_sTTPath);
		endif;
		return bReturn;
	endproc;
/*?
	?item 	Die(void)
	?desc	Set the Die-Task
?*/
	
	export proc void Delete()
		if(m_bCustomConstruction)then
			m_xBUMgr.DieAndOut(true);
		endif;
		if(!SkipCorpse())then
			if(!CreateBuildingCorpse())then
				if(cast<CWall>(this)==null && cast<CVirtualProduceUnit>(this)==null && m_bBuildingReady)then
					var ^CBuildingCorpse pxGameObj=cast<CBuildingCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("BuildingCorpse",GetOwner(),GetPos(),GetRotation()));
					if(pxGameObj!=null)then
						//pxGameObj^.SetConstructLevel(6);
						//KLog.LogSpam("MaZi", GetClassName()+" / "+GetGfxName());
						pxGameObj^.SetSource(this);
						pxGameObj^.Init(GetGfxName(), GetName(), 8.0, GetAge());
					endif;
				endif;
			endif;
		endif;
		super.Delete();
	endproc;
	
	export proc void DieFastAndSilent()
		if(m_bCustomConstruction)then
			m_xBUMgr.DieAndOut(true);
		endif;
		CBLDGMgr.Get().RemoveBuilding(this);
		CBLDGMgr.Get().RemoveClass(GetLimitClass(),GetTribeName(),GetOwner());
		if(m_bBuildingReady)then
			CBLDGConditionsMgr.Get().DeleteBuilding(this);
		endif;
		super.DieFastAndSilent();
	endproc;
	
	export proc bool PayBack(real p_fPercent)
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel!=null)then
			var ^CBasePlayer pxPlayer=cast<CBasePlayer>(pxLevel^.GetPlayer(GetOwner()));
			if(pxPlayer!=null)then
				var ^CAttribs pxPlAttr=pxPlayer^.GetAttribs();
				if(pxPlAttr!=null)then
					var ^CLevelInfoHost pxLevelInfo=CSrvWrap.GetLevelInfo(false);
					if(pxLevelInfo!=null)then
						var ^CLevelInfo.CPlayerSlot pxPlSlot=pxLevelInfo^.GetOwnerPlayerSlot(GetOwner());
						if(pxPlSlot!=null)then
							var CFightingObj.CBuildCosts xCosts = GetBuildCosts();
							pxPlayer^.AddResource("wood",Math.Round((xCosts.m_iWood).ToReal()*p_fPercent),true);
							pxPlayer^.AddResource("stone",Math.Round((xCosts.m_iStone).ToReal()*p_fPercent),true);
							pxPlayer^.AddResource("food",Math.Round((xCosts.m_iFood).ToReal()*p_fPercent),true);
							pxPlayer^.AddResource("iron",Math.Round((xCosts.m_iSkulls).ToReal()*p_fPercent),true);
						endif;
					endif;
				endif;
			endif;
		endif;
		return true;
	endproc;
	
	export proc void DiePerHarakiri()
		if(m_bSlaveInvincible)then return; endif;
		if(IsDestructible())then return; endif;
		if(!m_bBuildingReady && CMirageSrvMgr.Get().BuildingCancellation())then
			var bool bPayBack=PayBack(0.75);
		endif;
		OnKill();
		Die();
		return;
	endproc;
	
/*?
	?item 	BuildUp(string p_sClass)
	?desc	Set the BuildUp-Task. The Building has to be build.
	?param	p_sClass		Classname of the Object to build.
?*/
/*	proc void BuildUp(string p_sClass)
		SetConstructLevel(0);
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("CurTask","BuildUp");
			pxAttr^.SetValue("CurProcess",0);
		endif;
	endproc;
*/
	proc void BuildUpSDK()
		if(!CMirageSrvMgr.SDK())then return; endif;
		BuildUp("/Actions/"+GetTribeName()+"/Build/BLDG/"+GetClassName());
	endproc;
	
	export proc void BuildUpInGame()
		BuildUp("/Actions/"+GetTribeName()+"/Build/BLDG/"+GetClassName());
	endproc;
	
	proc void BuildUp(string p_sPath)
		SetConstructLevel(0);
		var CFourCC xFCCB;
		var string sTribe=GetTribeName();
		//if(sTribe!="Ninigi")then // Ninigi Cranes are still missing 08.02.05 RT#10806
			xFCCB="Cr_1";if(HasLink(xFCCB))then SetLinkGFX(xFCCB,sTribe+"_Crane_01","none"); endif;
			xFCCB="Cr_2";if(HasLink(xFCCB))then SetLinkGFX(xFCCB,sTribe+"_Crane_01","none"); endif;
			xFCCB="Cr_3";if(HasLink(xFCCB))then SetLinkGFX(xFCCB,sTribe+"_Crane_02","none"); endif;
			xFCCB="Cr_4";if(HasLink(xFCCB))then SetLinkGFX(xFCCB,sTribe+"_Crane_02","none"); endif;
			StopCranes();
		//endif;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("CurTask","BuildUp");
			pxAttr^.SetValue("ReadyForWork",0);
			pxAttr^.SetValue("CurProcess",0);
		endif;
		var ^CBuildUpBuilding pxTask=cast<CBuildUpBuilding>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"BuildUpB"));
		if(pxTask==null)then return; endif;
		if(!pxTask^.Init(GetHandle(), p_sPath))then
			pxTask^.GetFactory()^.FreeState(pxTask);
			return;
		endif;
		SetTaskFO(pxTask);
		if(m_bCustomConstruction)then
			m_xBUMgr.Init(this, m_fStartHeight, m_fHeightOffset);
			SetGFX(GetFakeGfx());
		endif;
	endproc;
	
	export proc void BuildUpInGame(real p_fPercent)
		BuildUp("/Actions/"+GetTribeName()+"/Build/BLDG/"+GetClassName(),p_fPercent);
	endproc;
	
	proc void BuildUp(string p_sPath, real p_fPercent)
		var real fProg=Math.Clamp(p_fPercent,0.0f,100.0f);
		var int iProg=Math.Floor(fProg/25.0f).ToInt();
		SetConstructLevel(iProg);
		var CFourCC xFCCB;
		var string sTribe=GetTribeName();
		xFCCB="Cr_1";if(HasLink(xFCCB))then SetLinkGFX(xFCCB,sTribe+"_Crane_01","none"); endif;
		xFCCB="Cr_2";if(HasLink(xFCCB))then SetLinkGFX(xFCCB,sTribe+"_Crane_01","none"); endif;
		xFCCB="Cr_3";if(HasLink(xFCCB))then SetLinkGFX(xFCCB,sTribe+"_Crane_02","none"); endif;
		xFCCB="Cr_4";if(HasLink(xFCCB))then SetLinkGFX(xFCCB,sTribe+"_Crane_02","none"); endif;
		StopCranes();
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("CurTask","BuildUp");
			pxAttr^.SetValue("ReadyForWork",0);
			pxAttr^.SetValue("CurProcess",fProg.ToInt());
		endif;
		var ^CBuildUpBuilding pxTask=cast<CBuildUpBuilding>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"BuildUpB"));
		if(pxTask==null)then return; endif;
		if(!pxTask^.Init(GetHandle(), p_sPath, fProg))then
			pxTask^.GetFactory()^.FreeState(pxTask);
			return;
		endif;
		SetTaskFO(pxTask);
		if(m_bCustomConstruction)then
			m_xBUMgr.Init(this, m_fStartHeight, m_fHeightOffset);
			SetGFX(GetFakeGfx());
		endif;
	endproc;
	
	export proc void BuildDown(string p_sPath)
		if(m_pxTaskMgr==null)then return; endif;
		var int i,iC=m_pxTaskMgr^.NumSubs();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CBuildDownBuilding pxBldDown=cast<CBuildDownBuilding>(m_pxTaskMgr^.GetSubState(i));
			if(pxBldDown!=null)then
				return;
			endif;
		endfor;
		var ^CBuildDownBuilding pxTask=cast<CBuildDownBuilding>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"BldDownB"));
		if(pxTask==null)then return; endif;
		if(pxTask^.Init(GetHandle(),p_sPath))then
			AddTask(pxTask,true);
		else
			pxTask^.GetFactory()^.FreeState(pxTask);
		endif;
	endproc;
	
/*?
	?item 	HandleGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams )
	?desc 	This Method Handles the recieved GamePlayCommands.
	?param	p_sCommand		a string describing the Command
	?param	p_pxObject		a possibility to pass a CGameObj to this Function
	?param	p_vPos			a possibility to pass a Position to this Function
	?param	p_sMiscParam	a string containing whatever you want and need
?*/
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(GetIncapacitated() && (p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") && !(p_sCommand=="Cancel"))then return; endif;
		//L KLog.LogWarn("CaOr","GPCmd "+p_sCommand);
		if(p_sCommand=="Delete")then
			Delete();
		elseif(p_sCommand=="Action")then
			if(p_sMiscParams.Find("BuildDown")!=-1)then
				BuildDown(p_sMiscParams);
			elseif(p_sMiscParams.Find("/Attack")==-1 && p_sMiscParams.Find("/Walk")==-1 && p_sMiscParams.Find("/Stop")==-1 && p_sMiscParams.Find("/LevelUp")==-1 && p_sMiscParams.Find("/Kill")==-1 && p_sMiscParams.Find("/AggroState_")==-1 && p_sMiscParams.Find("/HuntAnimals")==-1)then
				Action(p_sMiscParams);
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		elseif(p_sCommand=="BuildUp")then
			BuildUp(p_sMiscParams);
		elseif(p_sCommand=="Cancel")then
			CancelAction(p_sMiscParams);
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;

/*?
	?item	HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
	?desc	Handles the incoming Events
	?param	p_rxEvtPtr		Reference to the recieved Event
?*/
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()=="BuildUp")then
			//BuildUp(p_rxEvtPtr.GetString());
			//L KLog.LogSpam("BuildUp","BuildUp(1)");
			BuildUp("");
		elseif(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==196)then
				var bool bNight=!CTimeMgr.Get().IsVirtualDay();
				if(m_bPartyMode)then bNight=!m_bNight; endif;
				if(m_bNight!=bNight)then
					m_bNight=bNight;
					SetRndInvMaskSingleFlagInv(VIS_FLAG_BLDG_NIGHTMODE,m_bNight);
					SetRndInvMaskSingleFlagInv(VIS_FLAG_BLDG_INIGHTMODE,!m_bNight);
				endif;
			elseif(p_rxEvtPtr.GetInt(0)==FUNCTION_TIMER)then
				DoBuildingFunction();
			elseif(p_rxEvtPtr.GetInt(0)==PRESENT_MANA_TIMER)then
				ReplenishMana();
			elseif(p_rxEvtPtr.GetInt(0)==FUNCTION_SELF_REPAIR)then
				DoSelfRepair();
			elseif(p_rxEvtPtr.GetInt(0)==WORK_ANIM_TIMER_ID)then
				StopWorkAnim();
			elseif(p_rxEvtPtr.GetInt(0)==TIMER_EXPLOSION)then
				DeleteTimer(TIMER_EXPLOSION);
				Delete();
			elseif(p_rxEvtPtr.GetInt(0)==TIMER_REPAIR_PROTECTION)then
				SetRepairProtection(false);
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;

/*?
	?item	PlayDieAnim(void)
	?desc	Starts the Die-Animation
?*/
	export proc void PlayDieAnim()
		AnimAction("dying");
	endproc;
/*?
	?item	GetDamageValue(void)
	?desc	Returns the DamageValue.
?*/
	export proc real GetDamageValue()
		var	real fDamageValue=20.0f;
		return fDamageValue;
	endproc;
	
	export proc void UpdateMods()
		if(m_bBuildingReady)then
			var ^CBasePlayer pxBasePlayer=CBasePlayer.GetPlayer(GetOwner());
			if(pxBasePlayer!=null)then
				//pxBasePlayer^.UpdateLimits(false);
			endif;
		endif;
	endproc;
	
	export proc bool CanDeliver(string p_sTTPath)
		if(m_bDeliveryUnbound)then return true; endif;
		if(!CRequirementsMgr.Get().CheckFreeSlotNonVirtual(GetOwner(),p_sTTPath))then
			return false;
		endif;
		return true;
	endproc;
	
	export proc bool CalculateDelivery(string p_sProduct)
		if(p_sProduct=="CHTR")then
			var CObjQuery xZeroSearch;
			var CObjList xZeroers;
			xZeroSearch.SetType("CHTR");
			xZeroSearch.SetOwner(GetOwner());
			xZeroSearch.SetAttribsPos("level",0);
			xZeroSearch.Execute(xZeroers);
			if(xZeroers.NumEntries()<32)then
				SetDeliveryAllowed(true);
			endif;
		endif;
		return(true);
	endproc;
	
	export proc bool SetDeliveryAllowed(bool p_bAllowed)
		m_bDeliverProduct=p_bAllowed;
		return(true);
	endproc;
	
	export proc bool GetDeliveryAllowed()
		return(m_bDeliverProduct);
	endproc;
	
	export proc void UpdateHitpoints()
		super.UpdateHitpoints();
		m_xRepairDesc.Update();
	endproc;
	
	export proc bool Repair(real p_fValue, bool p_bFreeRepair, int p_iID)
		FireExtinguish();
		m_bPRDSFX=true;
		if(GetHitpoints()+p_fValue<=m_fMaxHitpoints)then
			SetHitpoints(GetHitpoints()+p_fValue);
			return m_xRepairDesc.PayForRepair(p_fValue, p_bFreeRepair, p_iID);
		else
			SetHitpoints(m_fMaxHitpoints);
			m_xRepairDesc.PayForRepair(p_fValue, p_bFreeRepair, p_iID);
			return false;
		endif;
	endproc;
	
	export proc bool AddCranes()
		AddCranesCustom();
		return true;
	endproc;
	
	export proc bool StopCranes()
		StopCraneCustom();
		return true;
	endproc;
	
	export proc void AddCranesCustom()
		var int i, iC=m_avCranes.NumEntries();
		if(iC==0)then return; endif;
		if(m_axCranes.NumEntries()!=iC)then
			m_axCranes=iC;
		endif;
		var CFourCC xLink="NOPE";
		for(i=0)cond(i<iC)iter(i++)do
			if(m_axCranes[i].IsValid() && m_axCranes[i].GetObj()!=null)then
				m_axCranes[i].GetObj()^.LinkAction(GetHandle(),xLink,m_avCranes[i]);
				m_axCranes[i].GetObj()^.SetAnim("build",3);
			else
				var string sCrane=GetCranesName();
				sCrane.MakeLower();
				if(Random.GetInt()%2==1 && sCrane!="seas")then
					sCrane += "_crane_02";
				else
					sCrane += "_crane_01";
				endif;
				var ^CMiscNonIdiObj pxCrane=cast<CMiscNonIdiObj>(CSrvWrap.GetObjMgr()^.CreateObj(sCrane,GetOwner(),GetPos()));
				if(pxCrane!=null)then
					m_axCranes[i]=pxCrane^.GetHandle();
					pxCrane^.LinkAction(GetHandle(),xLink,m_avCranes[i]);
					pxCrane^.SetAnim("build",3);
				endif;
			endif;
		endfor;
	endproc;
	
	export proc void StopCraneCustom()
		var int i, iC=m_avCranes.NumEntries();
		if(iC==0)then return; endif;
		if(m_axCranes.NumEntries()!=iC)then
			m_axCranes=iC;
		endif;
		var CFourCC xLink="NOPE";
		for(i=0)cond(i<iC)iter(i++)do
			if(m_axCranes[i].IsValid() && m_axCranes[i].GetObj()!=null)then
				m_axCranes[i].GetObj()^.LinkAction(GetHandle(),xLink,m_avCranes[i]);
				m_axCranes[i].GetObj()^.SetAnim("none",3);
			else
				var string sCrane=GetCranesName();
				sCrane.MakeLower();
				if(Random.GetInt()%2==1 && sCrane!="seas")then
					sCrane += "_crane_02";
				else
					sCrane += "_crane_01";
				endif;
				var ^CMiscNonIdiObj pxCrane=cast<CMiscNonIdiObj>(CSrvWrap.GetObjMgr()^.CreateObj(sCrane,GetOwner(),GetPos()));
				if(pxCrane!=null)then
					m_axCranes[i]=pxCrane^.GetHandle();
					pxCrane^.LinkAction(GetHandle(),xLink,m_avCranes[i]);
					pxCrane^.SetAnim("none",3);
				endif;
			endif;
		endfor;
	endproc;
	
	export proc string GetCranesName()
//		return GetPlayerTribeName();
		return GetTribeName();
	endproc;
	
	export proc bool RemoveCranes()
		var int i, iC=m_axCranes.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(m_axCranes[i].IsValid())then
				m_axCranes[i].GetObj()^.Delete();
			endif;
			m_axCranes[i]=CObjHndl.Invalid();
		endfor;
		return true;
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy)
		return super.TakeDmg(p_pxEnemy);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile)
		return super.TakeDmg(p_pxEnemy, p_bProjectile);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, real p_fFactor)
		return super.TakeDmg(p_pxEnemy, p_fFactor);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile, real p_fFactor)
		return super.TakeDmg(p_pxEnemy, p_bProjectile, p_fFactor);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile, real p_fFactor, real p_fHitDelay)
		return super.TakeDmg(p_pxEnemy, p_bProjectile, p_fFactor, p_fHitDelay);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile, real p_fFactor, real p_fHitDelay, real p_fArmorPiercing)
		var real fReturn=super.TakeDmg(p_pxEnemy, p_bProjectile, p_fFactor, p_fHitDelay, p_fArmorPiercing);
		if(GetClassName()=="ninigi_telescope_tower" && fReturn==0.0)then
			fReturn=10.0;
			fReturn += m_xTechTree.GetValueI("MiscValues/Ninigi/Tower_Damage",0).ToReal();
		endif;
		return fReturn;
	endproc;
	
	export proc void TieUpAllLooseEnds()
	endproc;
	
	export proc string GetReportCode()
		return "bldg";
	endproc;
	
	export proc bool PlayRepairDoneSFX()
		var bool bReturn=m_bPRDSFX;
		m_bPRDSFX=false;
		return bReturn;
	endproc;
	
	export proc void TransferLinkedObjs(CObjHndl p_xC)
	endproc;
	
	export proc CObjList GetAddons();
		var CObjList xL;
		return xL;
	endproc;
	
	proc string GetLimitClass()
		if(GetClassName().Find("aje_")!=-1&&GetObjectFlag()!="")then
			return GetObjectFlag();
		else
			return GetClassName();
		endif;
	endproc;
	
	export proc void SetReadyManually(bool p_bReady)
		m_bBuildingReady=p_bReady;
	endproc;
	
endclass;

class CBuildingFOWVIsible inherit CBuilding
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetVisInFOW(true);
	endproc;
endclass;

class CNoFreeBorderBlockerBuilding inherit CBuilding
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetFreeBorderBlocker(false);
	endproc;
endclass;

class CRallyBuilding inherit CBuilding
	
	var CObjHndl m_xTeslaM;
	
	export constructor()
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetRallySite(true);
		if(m_xTechTree.GetValueS(GetObjPath()+"/gfx","")=="hc_"+GetClassName().Right((GetClassName().GetLength())-4))then
			if(!IsVisInFOW())then SetVisInFOW(true); endif;
			//if(!GetHideMiniMap())then SetHideMiniMap(true); endif;	//SetHideMiniMap not working with BLDG type objects
		endif;
	endproc;
	
	export proc void SetReady()
		var ^CVirtualProduceUnit pxUnit=cast<CVirtualProduceUnit>(m_xReactor.GetObj());
		if(pxUnit!=null)then
			pxUnit^.SetReady();
		endif;
		pxUnit=cast<CVirtualProduceUnit>(m_xProduceUnit.GetObj());
		if(pxUnit!=null)then
			pxUnit^.SetReady();
		endif;
		super.SetReady();
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		var ^CVirtualProduceUnit pxReactor=cast<CVirtualProduceUnit>(GetReactor().GetObj());
		if(pxReactor==null)then
			return super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("/Build/ANML/seas")!=-1||p_sMiscParams.Find("/Build/CHTR/seas")!=-1||p_sMiscParams.Find("/Build/VHCL/seas")!=-1/*||p_sMiscParams.Find("/Upgrades/seas")!=-1*/)then
				if(p_bS)then
					pxReactor^.ActionReactored(p_sMiscParams);
					ActionVPU(p_sMiscParams);
				elseif(GetPQENO() >= GetPQENR() && pxReactor^.IsReady())then
					pxReactor^.ActionReactored(p_sMiscParams);
				else
					ActionVPU(p_sMiscParams);
				endif;
			elseif(p_sMiscParams.Find("/Upgrades/seas")!=-1)then
				ActionVPU(p_sMiscParams);
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		elseif(p_sCommand=="Cancel")then
			CancelAction(p_sMiscParams, p_bS);
//			return;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	export proc bool UpdateGfx()
		var bool bReturn=super.UpdateGfx();
		if((GetClassName()=="seas_garage"||GetClassName()=="seas_barracks"||GetClassName()=="seas_laboratory"||GetClassName()=="seas_jail_part_01"||GetClassName()=="seas_jail_part_02"||GetClassName()=="seas_headquarters") && !m_xReactor.IsValid())then
			if(m_xTechTree.GetValueB("/Objects/SEAS/InventObjects/"+GetClassName()+"_reactor/invented",false))then
//			if(m_xTechTree.GetValueB("/Objects/SEAS/InventObjects/virtual_reactor/invented",true))then
				if(!m_xProduceUnit.IsValid())then
					CreatePersonalProduceUnit(m_bBuildingReady);
				endif;
				CreateReactor(m_bBuildingReady);
			endif;
		endif;
		return true;
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="RlyB")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			if(p_pxReaderNode^.GetVersion()>=2)then
				m_xTeslaM.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		if(!CMirageSrvMgr.SDK())then
			var CFourCC xBase="RlyB";
			var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,2);
			var ^CArc pxArc=^(pxWalk^.GetArc());
			m_xTeslaM.DoKArc(pxArc^);
			pxWalk^.Close();
		endif;
	endproc;
	
	export proc bool StornoLast()
		var ^CVirtualProduceUnit pxReactor=null;
		if(m_xReactor.IsValid())then
			pxReactor=cast<CVirtualProduceUnit>(m_xReactor.GetObj());
		endif;
		if(GetPQENR() > GetPQENO())then
			if(pxReactor==null||!pxReactor^.StornoLast())then
				return super.StornoLast();
			else
				return true;
			endif;
		else
			return super.StornoLast();
		endif;
	endproc;
	
	export proc void ActionVPU(string p_sTTPath)
		var ^CVirtualProduceUnit pxProduceUnit=cast<CVirtualProduceUnit>(GetProduceUnit().GetObj());
		if(pxProduceUnit==null)then
			super.Action(p_sTTPath);
		else
			pxProduceUnit^.Action(p_sTTPath);
		endif;
	endproc;
	
//	export proc void CancelAction(string p_sTTPath)
//		return super.CancelAction(p_sTTPath);
//	endproc;
	
	export proc void CancelAction(string p_sTTPath)
		if(m_xReactor.IsValid())then
			var ^CVirtualProduceUnit pxProduceUnit=cast<CVirtualProduceUnit>(GetProduceUnit().GetObj());
			if(pxProduceUnit==null||!pxProduceUnit^.HasCanceledAction(p_sTTPath))then
				if(m_pxTaskMgr!=null)then
					m_pxTaskMgr^.RemoveAction(p_sTTPath);
				endif;
			endif;
			return;
		else
			return super.CancelAction(p_sTTPath);
		endif;
	endproc;
	
	export proc void CancelAction(string p_sTTPath, bool p_bShift)
		var ^CVirtualProduceUnit pxReactor=null;
//		var bool bRCA=false;
		if(m_xReactor.IsValid())then
			pxReactor=cast<CVirtualProduceUnit>(m_xReactor.GetObj());
			if(pxReactor!=null)then
				if(p_bShift)then
					pxReactor^.CancelAction(p_sTTPath);
					CancelAction(p_sTTPath);
					return;
				elseif(GetPQENR() > GetPQENO())then
					if(pxReactor^.HasCanceledAction(p_sTTPath))then
						return;
					endif;
				endif;
			endif;
		endif;
		if(!HasCanceledAction(p_sTTPath) && pxReactor!=null)then
			pxReactor^.CancelAction(p_sTTPath);
		endif;
	endproc;
	
	export proc void CheckTeslaMachine(CObjHndl p_xRally)
		var string sClass=GetClassName();
//		if(sClass!="seas_barracks"&&sClass!="seas_headquarters"&&sClass!="seas_garage"&&sClass!="seas_laboratory"&&sClass!="seas_jail_part_01"&&sClass!="seas_jail_part_02")then m_xTeslaM=CObjHndl.Invalid(); return; endif;
		if(p_xRally.IsValid())then
			var ^CTeslaMachine pxM=cast<CTeslaMachine>(p_xRally.GetObj());
			if(pxM==null)then m_xTeslaM=CObjHndl.Invalid(); return; endif;
//			if(pxM^.GetOwner()!=GetOwner()||!pxM^.IsReady())then m_xTeslaM=CObjHndl.Invalid(); return; endif;
			if(!CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxM^.GetOwner(), GetOwner())||!CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxM^.GetOwner())||!pxM^.IsReady())then m_xTeslaM=CObjHndl.Invalid(); return; endif;
			m_xTeslaM=pxM^.GetHandle();
		else
			m_xTeslaM=CObjHndl.Invalid();
		endif;
	endproc;
	
	export proc CObjHndl GetSpawnPos(ref vec3 p_rvPos,ref vec3 p_rvRot)
		if(m_xTeslaM.IsValid()&&m_xTeslaM.GetObj()^.GetConstructLevel()>=4)then
			p_rvPos=m_xTeslaM.GetObj()^.GetPos()+({0.0,1.0,0.0}*m_xTeslaM.GetObj()^.GetRadius());
			p_rvRot=m_xTeslaM.GetObj()^.GetRotation();
			return m_xTeslaM;
		endif;
		return CObjHndl.Invalid();
	endproc;
	
endclass;

//Hu: Hu_Stone_Cottage
//Aje: Aje_Tent
//Ninigi: ??
class CSmallestHouse inherit CBuilding
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetRallySite(true);
	endproc;
	
	/*
	export proc void Die()
		if(!m_bDead && GetGfxName()=="Aje_Big_Tent")then
			var ^CBuildingCorpse pxGameObj=cast<CBuildingCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("BuildingCorpse",GetOwner(),GetPos(),GetRotation()));
			if(pxGameObj!=null)then
				//pxGameObj^.SetConstructLevel(6);
				pxGameObj^.Init("Aje_Big_Tent", GetName(), 20.0);
			endif;
		endif;
		super.Die();
	endproc;
	*/
endclass;

//Hu: Hu_Small_House
//Aje: Aje_Small_House
//Ninigi: Ninigi_Small_House_S1
class CMediumHouse inherit CBuilding
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
	endproc;
endclass;

//Hu: Hu_Large_House
//Aje: ??
//Ninigi: ??
class CLargeHouse inherit CBuilding
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetRallySite(true);
	endproc;
endclass;

class CTurret inherit CGameObj
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			SetType("TRRT");
			InitAttribs();
		endif;
	endproc;
	
	export proc void AddHitpoints(real p_fH)
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			var real fH=pxAttr^.GetValueFloat("hitpoints");
			pxAttr^.SetValue("hitpoints", fH+p_fH);
		endif;
	endproc;
	
	export proc void Delete()
		TerminateAction();
		super.Delete();
	endproc;

endclass;

class CSeasBigCannon inherit CTower
	
	var CObjHndl m_xBirdie;
	var bool m_bActivated;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			m_bActivated=false;
			SetTurretLink("we");
			SetTurret("seas_hq_big_cannon_rotator");
			m_sTurretAttackAnim="attack_front";
		endif;
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="SBig")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xBirdie.DoKArc(pxArc^);
			pxArc^ << m_bActivated;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="SBig";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xBirdie.DoKArc(pxArc^);
		pxArc^ << m_bActivated;
		pxWalk^.Close();
	endproc;
	
	export proc void AbortTask()
		if(!m_bActivated)then
			m_bActivated=true;
			var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("seas_hq_big_cannon_cannon", GetOwner());
			AddGroupedChildren(pxO^.GetGuid());
			var CFourCC xLink="we";
			pxO^.LinkAction(m_xTurret,xLink);
			m_xBirdie=pxO^.GetHandle();
		endif;
	endproc;
	
	export proc bool CreateBuildingCorpse()
		var ^CBuildingCorpse pxGameObj=cast<CBuildingCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("BuildingCorpse",GetOwner(),GetPos(),GetRotation()));
		if(pxGameObj!=null)then
			pxGameObj^.SetSource(m_xTurret.GetObj());
			pxGameObj^.Init("seas_hq_big_cannon_rotator", GetName(), 8.0, GetAge());
			if(m_xTurret.IsValid())then
				pxGameObj^.SetRot(m_xTurret.GetObj()^.GetRot());
				pxGameObj^.SecRotAction(m_xTurret.GetObj()^.GetAdditionalRot(),0.0);
				m_xTurret.GetObj()^.Delete();
			endif;
		endif;
		pxGameObj=cast<CBuildingCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("BuildingCorpse",GetOwner(),GetPos(),GetRotation()));
		if(pxGameObj!=null)then
			pxGameObj^.SetSource(this);
			pxGameObj^.Init("seas_hq_big_cannon", GetName(), 8.0, GetAge());
		endif;
		return true;
	endproc;
	
	export proc void Delete()
		if(m_xBirdie.IsValid())then m_xBirdie.GetObj()^.Delete(); endif;
		super.Delete();
	endproc;
	
	export proc bool AttackEnemy(^CFightingObj p_pxEnemy, vec3 p_vTarget, ref bool p_rbRotated)
		if(!m_bActivated)then return false; endif;
		var bool bReturned=super.AttackEnemy(p_pxEnemy,p_vTarget,p_rbRotated);
		var ^CGameObj pxBuildUp=m_xBirdie.GetObj();
		if(pxBuildUp!=null && !p_rbRotated)then
			pxBuildUp^.SetAnim("attack_front",1);
		endif;
		return bReturned;
	endproc;
	
	proc bool UpdateDestructionFlags()
		if(((GetHitpoints()!=0.0f)&&(GetMaxHitpoints()!=0.0f)))then
			var real fPercentage=GetHitpoints()/(GetMaxHitpoints()/100.0f);
			if(m_xBirdie.IsValid())then
				var ^CGameObj pxGameObj=m_xBirdie.GetObj();
				if(pxGameObj==null)then return false; endif;
				if(fPercentage>50.0f)then
					pxGameObj^.SetDestructLevel(0);
				elseif(fPercentage>25.0f)then
					if(pxGameObj^.GetDestructLevel()!=1)then
						pxGameObj^.SetDestructLevel(1);
					endif;
				elseif(pxGameObj^.GetDestructLevel()!=2)then
					pxGameObj^.SetDestructLevel(2);
				endif;
			endif;
		endif;
		return true;
	endproc;
	
endclass;

class CRocketRamp inherit CTower
	
	var CObjHndl m_xBirdie;
	
	export proc void OnInit(bool p_bLoad)
		SetTurretLink("RE_1");
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			SetTurret("ninigi_rb_top");
			m_sTurretAttackAnim="attack_front";
		endif;
	endproc;
	
	export proc void SetConstructLevel(int p_iLvl)
		super.SetConstructLevel(p_iLvl);
		if(m_xTurret.IsValid())then
			m_xTurret.GetObj()^.SetConstructLevel(p_iLvl);
		endif;
	endproc;
	
	export proc void SetTurret(string p_sObjName)
		if(m_xTurret.IsValid())then
			m_xTurret.GetObj()^.Delete();
		endif;
		if(p_sObjName.IsEmpty())then return; endif;
		var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj(p_sObjName, GetOwner(),GetPos(),GetRotation());
		if(pxO==null)then return();endif;
//		pxO^.LinkAction(GetHandle(), m_xTurretLink);
		m_xTurret=pxO^.GetHandle();
//		AddGroupedChildren(pxO^.GetGuid());
		var ^CAttribs pxA=pxO^.GetAttribs();
		if(pxA!=null)then
			pxA^.SetValue("maxhitpoints", GetAttribs()^.GetValueFloat("maxhitpoints"));
			pxA^.SetValue("hitpoints", GetAttribs()^.GetValueFloat("hitpoints"));
		endif;
		pxO^.SetConstructLevel(4);
		return;
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		if(m_xTurret.IsValid())then
			m_xTurret.GetObj()^.LinkAction(GetHandle(), m_xTurretLink);
			AddGroupedChildren(m_xTurret.GetObj()^.GetGuid());
		endif;
		if(!m_xBirdie.IsValid())then
			var ^CBirdieBuildUp pxO=cast<CBirdieBuildUp>(CSrvWrap.GetObjMgr()^.CreateObj("ninigi_rb_bird", GetOwner()));
			AddGroupedChildren(pxO^.GetGuid());
			var CFourCC xLink="we";
			pxO^.LinkAction(m_xTurret,xLink);
			m_xBirdie=pxO^.GetHandle();
			pxO^.StartIdleAnims("");
		endif;
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="RoRa")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xBirdie.DoKArc(pxArc^);
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="RoRa";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xBirdie.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
	endproc;
	
	export proc void AddHitpoints(real p_fH)
		super.AddHitpoints(p_fH);
		if(m_xTurret.IsValid())then
			var ^CTurret pxT=cast<CTurret>(m_xTurret.GetObj());
			if(pxT!=null)then
				pxT^.AddHitpoints(p_fH);
			endif;
		endif;
	endproc;
	
	export proc bool CreateBuildingCorpse()
		if(!m_bBuildingReady)then return true; endif;
		var ^CBuildingCorpse pxGameObj=cast<CBuildingCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("BuildingCorpse",GetOwner(),GetPos(),GetRotation()));
		if(pxGameObj!=null)then
			pxGameObj^.SetSource(m_xTurret.GetObj());
			pxGameObj^.Init("ninigi_rb_top", GetName(), 8.0, GetAge());
			if(m_xTurret.IsValid())then
				pxGameObj^.SetRot(m_xTurret.GetObj()^.GetRot());
				pxGameObj^.SecRotAction(m_xTurret.GetObj()^.GetAdditionalRot(),0.0);
			endif;
		endif;
		pxGameObj=cast<CBuildingCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("BuildingCorpse",GetOwner(),GetPos(),GetRotation()));
		if(pxGameObj!=null)then
			pxGameObj^.SetSource(m_xBirdie.GetObj());
			pxGameObj^.Init("ninigi_rb_bird", GetName(), 8.0, GetAge());
			if(m_xTurret.IsValid())then
				pxGameObj^.SetRot(m_xTurret.GetObj()^.GetRot());
				pxGameObj^.SecRotAction(m_xTurret.GetObj()^.GetAdditionalRot(),0.0);
			endif;
		endif;
		pxGameObj=cast<CBuildingCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("BuildingCorpse",GetOwner(),GetPos(),GetRotation()));
		if(pxGameObj!=null)then
			pxGameObj^.SetSource(this);
			pxGameObj^.Init("ninigi_rocket_ramp", GetName(), 8.0, GetAge());
		endif;
		return true;
	endproc;
	
	export proc void Delete()
		if(m_xBirdie.IsValid())then m_xBirdie.GetObj()^.Delete(); endif;
		super.Delete();
	endproc;
	
	export proc bool AttackEnemy(^CFightingObj p_pxEnemy, vec3 p_vTarget, ref bool p_rbRotated)
		if(p_pxEnemy!=null)then
			if(p_pxEnemy^.IsFlyingUnit() && !CanShootAir())then return false; endif;
		endif;
//		var ^CAiPlayer pxPlayer=cast<CAiPlayer>(CSrvWrap.GetCurLevel()^.GetPlayer(GetOwner()));
//		if(p_pxEnemy!=null && pxPlayer!=null)then
//			var ^CAttribs pxAttribs=p_pxEnemy^.GetAttribs();
//			if(pxAttribs!=null)then
//				if(pxAttribs^.GetValueBool("active_camouflage"))then return false; endif;
//			endif;
//		endif;
		var bool bReturned=super.AttackEnemy(p_pxEnemy,p_vTarget,p_rbRotated);
		var ^CBirdieBuildUp pxBuildUp=cast<CBirdieBuildUp>(m_xBirdie.GetObj());
		if(pxBuildUp!=null && !p_rbRotated)then
			pxBuildUp^.AttackEnemy();
		endif;
		return bReturned;
	endproc;
	
//	export proc void AttackSrv(^CGameObj p_pxEnemy)
//		return;
//	endproc;
	
endclass;

class CBirdieBuildUp inherit CProduct
	
	const int TIMER_IDLEANIMS=103;
	var array string m_asIdleAnims;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		m_asIdleAnims.AddEntry("ninigi_rb_bird_idle_001");
		m_asIdleAnims.AddEntry("ninigi_rb_bird_idle_002");
		m_asIdleAnims.AddEntry("ninigi_rb_bird_idle_003");
		m_asIdleAnims.AddEntry("ninigi_rb_bird_idle_004");
	endproc;
	
	export proc void StartIdleAnims(string p_sAnim)
		if(HasTimer(TIMER_IDLEANIMS))then
			DeleteTimer(TIMER_IDLEANIMS);
		endif;
		NextAnim(p_sAnim);
	endproc;
	
	export proc void NextAnim(string p_sForceAnim)
		var real fDuration=3.0;
		if(p_sForceAnim.IsEmpty())then
			var int iRandom=Random.GetInt()%4;
			if(HasAnim(m_asIdleAnims[iRandom]))then
				SetAnim(m_asIdleAnims[iRandom],1);
				fDuration=GetCurrentAnimLength();
			endif;
		else
			fDuration=6.0;
			if(HasAnim(p_sForceAnim))then
				SetAnim(p_sForceAnim,1);
				fDuration=GetCurrentAnimLength();
			endif;
		endif;
		CreateTimer(TIMER_IDLEANIMS,CGameTimeSpan.OneSecond()*fDuration,false);
	endproc;
	
	proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		super.HandleEvent(p_rxEvtPtr);
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==TIMER_IDLEANIMS)then
				DeleteTimer(TIMER_IDLEANIMS);
				NextAnim("");
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	export proc void AttackEnemy()
		StartIdleAnims("ninigi_rb_bird_shoot");
	endproc;

endclass;

class CNinigiSmallTower inherit CTower
	
	export proc void OnInit(bool p_bLoad)
		SetTurretLink("we");
		super.OnInit(p_bLoad);
		m_sTurretAttackAnim="";
	endproc;
	
	export proc void UpdateGfxFlags()
		if(!m_xTurret.IsValid()&&m_xTechTree.GetValueB("/Objects/Ninigi/InventObjects/tower_sordes_upgrade/invented",false))then
			SetTurret("ninigi_small_tower_upgrade");
		endif;
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy)
		return super.TakeDmg(p_pxEnemy);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile)
		return super.TakeDmg(p_pxEnemy, p_bProjectile);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, real p_fFactor)
		return super.TakeDmg(p_pxEnemy, p_fFactor);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile, real p_fFactor)
		return super.TakeDmg(p_pxEnemy, p_bProjectile, p_fFactor);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile, real p_fFactor, real p_fHitDelay)
		return super.TakeDmg(p_pxEnemy, p_bProjectile, p_fFactor, p_fHitDelay);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile, real p_fFactor, real p_fHitDelay, real p_fArmorPiercing)
		var real fReturn=super.TakeDmg(p_pxEnemy, p_bProjectile, p_fFactor, p_fHitDelay, p_fArmorPiercing);
		if(fReturn==0.0)then
			fReturn=10.0;
			fReturn += m_xTechTree.GetValueI("MiscValues/Ninigi/Tower_Damage",0).ToReal();
		endif;
		return fReturn;
	endproc;

endclass;

//Hu: Hu_Tower
//Aje: ??
//Ninigi: ??
class CTower inherit CBuilding
	
	var CObjHndl			m_xTurret;
	var string				m_sTurretAttackAnim;
	var CFourCC				m_xTurretLink;
	var bool				m_bUpgraded;
	
	export constructor()
		m_xTurretLink="Proj";
	endconstructor;
	
	export proc vec3 GetProjectileStartPos()
		if(!m_xTurret.IsValid())then return super.GetProjectileStartPos(); endif;
		var vec3 vBuildUpBasePos;
		var vec3 vProjectilePos;
		var CFourCC xProjectileLink="Proj";
		if(!GetLinkPosWorld(m_xTurretLink, vBuildUpBasePos))then return super.GetProjectileStartPos(); endif;
		var ^CGameObj pxObj=m_xTurret.GetObj();
		if(pxObj==null)then return super.GetProjectileStartPos(); endif;
		if(!pxObj^.GetLinkPosWorld(xProjectileLink, vProjectilePos))then return super.GetProjectileStartPos(); endif;
		vProjectilePos=vProjectilePos-vBuildUpBasePos;
		var Quat qAdditionalRot=pxObj^.GetAdditionalRot();
		qAdditionalRot.VecRotateU(vProjectilePos);
		return (vBuildUpBasePos+vProjectilePos);
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetFreeBorderBlocker(false);
		UpdateAggressive();
		if(!p_bLoad)then
			var ^CAttribs pxAttr=GetAttribs();
			if(pxAttr!=null)then
				pxAttr^.SetValue("AttackBuilding", true);
			endif;
			SetCanFightAttrib(true);
		endif;
		m_sTurretAttackAnim="attack_front";
		if(GetClassName()=="aje_small_tower"||GetClassName()=="aje_medium_tower")then
			m_sTurretAttackAnim="gun_shoot";
		elseif(GetClassName()=="ninigi_large_tower")then
			m_sTurretAttackAnim="load";
		endif;
		SetWallMapObj(true);
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		var ^CGameObj pxO=m_xTurret.GetObj();
		if(pxO!=null)then
			if(GetClassName()=="ninigi_rocket_ramp")then
				if(GetConstructLevel()==4)then
					pxO^.LinkAction(GetHandle(), m_xTurretLink);
				endif;
			else
				pxO^.LinkAction(GetHandle(), m_xTurretLink);
			endif;
		endif;
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="ToBa")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xTurret.DoKArc(pxArc^);
			if(p_pxReaderNode^.GetVersion()>=2)then
				var string sLink;
				(pxArc^) << sLink;
				m_xTurretLink=sLink;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="ToBa"; //Tower base
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,2);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xTurret.DoKArc(pxArc^);
		var string sLink=m_xTurretLink.AsString();
		(pxArc^) << sLink;
		pxWalk^.Close();
	endproc;
	
	export proc bool CorpseAvailable(ref string p_rsClass)
		if(GetClassName()=="ninigi_large_tower")then
			p_rsClass="ninigi_smoke_tower_dest";
		else
			p_rsClass=GetGfxName()+"_dest";
		endif;
		return CSrvWrap.GetGfxMgrBase().FindGraphicSetEntry(p_rsClass);
	endproc;
	
	proc void SetTurretLink(string p_sLink)
		m_xTurretLink=p_sLink;
	endproc;
	
	destructor()
		if(m_xTurret.IsValid())then
			m_xTurret.GetObj()^.Delete();
		endif;
	enddestructor;
	
	export proc void BuildDown(string p_sPath)
		if(!m_xProduceUnit.IsValid())then
			CreatePersonalProduceUnit(m_bBuildingReady);
		endif;
		var ^CVirtualProduceUnit pxProduceUnit=cast<CVirtualProduceUnit>(GetProduceUnit().GetObj());
		if(pxProduceUnit==null)then
			super.BuildDown(p_sPath);
		else
			pxProduceUnit^.BuildDownParent(p_sPath);
		endif;
	endproc;
	
	export proc void Action(string p_sTTPath)
		if(m_bSkipTowerStuff)then return super.Action(p_sTTPath); endif;
		if(p_sTTPath.Find("/Upgrades/"+GetClassName())!=-1&&!m_xProduceUnit.IsValid())then
			CreatePersonalProduceUnit(m_bBuildingReady);
		endif;
		var ^CVirtualProduceUnit pxProduceUnit=cast<CVirtualProduceUnit>(GetProduceUnit().GetObj());
		if(pxProduceUnit==null)then
			super.Action(p_sTTPath);
		elseif(!pxProduceUnit^.ActionTowerVPU(p_sTTPath))then
			DeleteVPU();
		endif;
	endproc;
	
	///////
	//	Fight()
	///////
	export proc void Fight(^CGameObj p_pxTarget, vec3 p_vPos, bool p_bUserCommand, bool p_bQ)
		if(!m_bBuildingReady)then return; endif;
//		var ^CBuildDownBuilding pxBldDown=cast<CBuildDownBuilding>(GetCurTask());
//		if(pxBldDown!=null)then return; endif;
		super.Fight(p_pxTarget, p_vPos, p_bUserCommand, p_bQ);
	endproc;
	
	export proc CObjHndl GetTurret()
		return(m_xTurret);
	endproc;
	
	export proc void SetTurret(string p_sObjName)
		if(GetClassName()=="ninigi_rocket_ramp")then return; endif;
		if(m_xTurret.IsValid())then
			m_xTurret.GetObj()^.Delete();
		endif;
		if(p_sObjName.IsEmpty())then return; endif;
		var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj(p_sObjName, GetOwner());
		if(pxO==null)then return();endif;
		pxO^.LinkAction(GetHandle(), m_xTurretLink);
		m_xTurret=pxO^.GetHandle();
		AddGroupedChildren(pxO^.GetGuid());
		var ^CAttribs pxA=pxO^.GetAttribs();
		if(pxA!=null)then
			pxA^.SetValue("maxhitpoints", GetAttribs()^.GetValueFloat("maxhitpoints"));
			pxA^.SetValue("hitpoints", GetAttribs()^.GetValueFloat("hitpoints"));
		endif;
		pxO^.SetConstructLevel(4);
	endproc;
	
	proc void OnDefend(^CGameObj p_pxEnemy)
		if(m_bBuildingReady)then
			//L KLog.LogInfo("Fight",GetName()+" defends himself!");
			if(p_pxEnemy!=null)then
//				ReactToGamePlayCommand("Action",p_pxEnemy, p_pxEnemy^.GetPos(), "/AttackSrv");
				AttackSrv(p_pxEnemy);
			endif;
		endif;
	endproc;
	
	export proc bool AttackEnemy(^CFightingObj p_pxEnemy, vec3 p_vTarget, ref bool p_rbRotated)
		if(IsBuildMode())then return false; endif;
		if(GetIncapacitated())then return false; endif;
		if(GetProjectile()!="")then
			if(p_pxEnemy!=null)then
				if(p_pxEnemy^.IsFlyingUnit() && !CanShootAir())then return false; endif;
			endif;
			if(m_xTurret.IsValid())then
				var ^CGameObj pxWO=m_xTurret.GetObj();
				var vec3 vCurDir={0.0,1.0,0.0};
				pxWO^.GetRot().VecRotateU(vCurDir);
				var vec3 vCur=vCurDir;
				pxWO^.GetAdditionalRot().VecRotateU(vCur);
				var vec3 vAEDir;
				if(p_pxEnemy!=null)then
					vAEDir=(p_pxEnemy^.GetPos() - GetPos());
				else
					vAEDir=(p_vTarget - GetPos());
				endif;
				var Quat qOld; qOld.FromXYDir(vCur.GetX(), vCur.GetY());
				var Quat qR;
				if(GetClassName()=="ninigi_large_tower")then
					qR.FromXYDir(-vAEDir.GetX(), -vAEDir.GetY());
				else
					qR.FromXYDir(vAEDir.GetX(), vAEDir.GetY());
				endif;
				var real fD=(qR - qOld).Abs();//(vAEDir-vCur).Abs();
				if(pxWO^.GetSecActionDesc()=="CAct" && (fD > 0.0001f||fD<-0.0001f))then
					qR /= pxWO^.GetRot();
					pxWO^.SecRotAction(qR, 0.8f);
					p_rbRotated=true;
					ResetHitDone();
					return false;
				endif;
			endif;
			CreateProjectileAndShoot(p_pxEnemy, p_vTarget);
			if(GetFightAnim()!="" && HasAnim(GetFightAnim()))then
				SetAnim(GetFightAnim(),1);
			endif;
			if(!m_sTurretAttackAnim.IsEmpty() && m_xTurret.IsValid())then
				if(GetClassName()=="ninigi_large_tower")then
					m_xTurret.GetObj()^.SetSLEAnim(m_sTurretAttackAnim,15,true,true);
				else
					m_xTurret.GetObj()^.SetAnim(m_sTurretAttackAnim, 1);
				endif;
			endif;
			return false;
		endif;
		return false;
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		var ^CWallMapSrv pxWM=CSrvWrap.GetObjMgr()^.GetObjPlaceChecker()^.GetWallMap();
		pxWM^.SetReady(GetHandle());
	endproc;
	
	export proc void Delete()
		var int i,iC=GetMaxGroupedChildSlots();
		for(i=0)cond(i<iC)iter(i++)do
			RemGroupedChildren(i);
		endfor;
		super.Delete();
	endproc;
	
	export proc void UpdateGfxFlags()
		if(GetClassName()=="hu_large_tower")then
			m_xTurretLink="we";
			if(!m_xTurret.IsValid() && m_xTechTree.GetValueB("/Objects/Hu/InventObjects/hu_ballista_upgrade/invented",false))then
				if(m_bBuildingReady)then
					SetTurret("Hu_Large_Tower_Upgrade_Balista");
					DeleteVPU();
				endif;
			endif;
		elseif((GetClassName()=="aje_small_tower"||GetClassName()=="aje_medium_tower") && m_xTechTree.GetValueB("/Objects/Aje/InventObjects/local_tesla_upgrade/invented",false))then
			SetTurretLink("we");
			if(!m_xTurret.IsValid())then
				m_sTurretAttackAnim="gun_shoot";
				SetTurret("aje_tesla_tower_canon");
				DeleteVPU();
			endif;
		elseif(GetClassName()=="ninigi_large_tower")then
			if(!m_xTurret.IsValid())then
				if(m_bBuildingReady)then
					m_sTurretAttackAnim="load";
					SetTurret("ninigi_rocket_ramp_top");
					DeleteVPU();
				endif;
			endif;
		endif;
	endproc;
	
	export proc bool UpdateDestructionFlags()
		if(((GetHitpoints()!=0.0f)&&(GetMaxHitpoints()!=0.0f)))then
			var real fPercentage=GetHitpoints()/(GetMaxHitpoints()/100.0f);
			if(fPercentage>50.0f)then
				SetDestructLevel(0);
			elseif(fPercentage>25.0f)then
				if(GetDestructLevel()!=1)then
					SetDestructLevel(1);
				endif;
			elseif(GetDestructLevel()!=2)then
				SetDestructLevel(1);
			endif;
		endif;
		return false;
	endproc;
	
	export proc void CancelAction(string p_sTTPath)
		if(m_bSkipTowerStuff)then return super.CancelAction(p_sTTPath); endif;
		var ^CVirtualProduceUnit pxProduceUnit=cast<CVirtualProduceUnit>(GetProduceUnit().GetObj());
		if(pxProduceUnit==null||!pxProduceUnit^.HasCanceledAction(p_sTTPath))then
			super.CancelAction(p_sTTPath);
		endif;
		DeleteVPU();
	endproc;
	
	export proc bool StornoLast()
		if(m_bSkipTowerStuff)then return super.StornoLast(); endif;
		var bool bReturn=super.StornoLast();
		DeleteVPU();
		return bReturn;
	endproc;
	
	export proc void StornoAll()
		if(m_bSkipTowerStuff)then return super.StornoAll(); endif;
		super.StornoAll();
		DeleteVPU();
	endproc;
	
	export proc bool IsAbleToFight()
		if(GetCurTaskName()=="BuildUpB")then
			return false;
		endif;
		return true;
	endproc;
	
	export proc void OnTechTreeChange()
		super.OnTechTreeChange();
	endproc;
	
	export proc void OnTechTreeChange(ref CStringArray p_rasChanges)
		super.OnTechTreeChange(p_rasChanges);
		m_fHealingValue=m_xTechTree.GetValueR("Objects/"+GetPlayerTribeName()+"/InventObjects/Healing/value",1.0);
	endproc;
	
	export proc void SetConstructLevel(int p_iLvl)
		super.SetConstructLevel(p_iLvl);
//		if(m_xTurret.IsValid())then
//			m_xTurret.GetObj()^.SetConstructLevel(p_iLvl);
//		endif;
		if(m_bCustomConstruction)then
			m_xBUMgr.Update(GetTtGfx());
		endif;
	endproc;
	
	export proc void SetDestructLevel(int p_iLvl)
		super.SetDestructLevel(p_iLvl);
		if(m_xTurret.IsValid())then
			m_xTurret.GetObj()^.SetDestructLevel(p_iLvl);
		endif;
		if(m_bCustomConstruction)then
			m_xBUMgr.Update(GetTtGfx());
		endif;
	endproc;
	
	export proc bool CreateBuildingCorpse()
		if(m_bBuildingReady && m_xTurret.IsValid())then
			var ^CBuildingCorpse pxGameObj=cast<CBuildingCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("BuildingCorpse",GetOwner(),GetPos(),GetRotation()));
			if(pxGameObj!=null)then
				pxGameObj^.SetSource(m_xTurret.GetObj());
				pxGameObj^.Init(m_xTurret.GetObj()^.GetGfxName(), GetName(), 8.0, GetAge());
				pxGameObj^.SetRot(m_xTurret.GetObj()^.GetRot());
				pxGameObj^.SecRotAction(m_xTurret.GetObj()^.GetAdditionalRot(),0.0);
			endif;
		endif;
		return false;
	endproc;
	
	export proc string GetReportCode()
		return "defence";
	endproc;
	
endclass;

class CStealthBuilding inherit CBuilding
	
	var real			m_fRadius;
	var bool			m_bActive;
	
	var array string	m_asHidingTypes;
	
	export constructor()
		m_asHidingTypes=1;
		m_asHidingTypes[0]="BLDG";
	endconstructor;
	
	proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		m_fRadius=35.0;
		if(!p_bLoad)then
			SetCanFightAttrib(false);
		endif;
		m_xSink.m_xOnObjAdd=OnObjAdd;
		m_xSink.m_xOnObjRem=OnObjRem;
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		if(!HasPersonalRegion())then
			var vec3 vP;vP.SetXYZ(m_fRadius,m_fRadius,0.0f);
			CreatePersonalRegion("SmokerRegion_"+GetName()+"_"+Random.GetInt().ToString(), vP, 010b);
			AddRangedBuff("owner_invisibility_bldg");
		endif;
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="STba")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var CGuid xG;
			pxArc^ << xG;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	proc bool OnObjAdd(CObjHndl p_xHndl)
		if(m_bToBeDeleted)then return false; endif;
		if(GetHandle()==p_xHndl)then return false; endif;
		if(m_xRegionObjects.FindEntry(p_xHndl)!=-1)then return false; endif;
		var ^CFightingObj pxFO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxFO==null)then return false; endif;
		if(!AuraSharing()&&pxFO^.GetOwner()!=GetOwner())then return false; endif;
//		if(!CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxFO^.GetOwner()))then return false; endif;
		if(!(CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxFO^.GetOwner(), GetOwner())&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxFO^.GetOwner())))then return false; endif;
		if(m_asHidingTypes.FindEntry(pxFO^.GetType().AsString())==-1)then return false; endif;
		if(pxFO^.GetClassName()==GetClassName())then return false; endif;
		if(cast<CWarpGate>(pxFO)!=null)then return false; endif;
		if(cast<CDefenderObj>(pxFO)!=null)then return false; endif;
//		if(cast<CPirateShipBuildUp>(pxFO)!=null)then return false; endif;
		m_xRegionObjects.Include(p_xHndl);
		pxFO^.SetEffectFlag(CFightingObj.EFFECT_SMOKER_INVIS, true);
		var ^CTower pxTower=cast<CTower>(p_xHndl.GetObj());
		if(pxTower!=null)then
			var CObjHndl xTurret=pxTower^.GetTurret();
			if(xTurret.IsValid())then
				var ^CFightingObj pxTmp=cast<CFightingObj>(xTurret.GetObj());
				if(pxTmp!=null)then
					pxTmp^.SetEffectFlag(CFightingObj.EFFECT_SMOKER_INVIS, true);
				endif;
			endif;
		endif;
		return true;
	endproc;
	
	proc bool OnObjRem(CObjHndl p_xHndl)
		if(m_xRegionObjects.FindEntry(p_xHndl)==-1)then return false; endif;
		m_xRegionObjects.RemEntry(p_xHndl);
		var ^CFightingObj pxFO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxFO==null)then return false; endif;
		pxFO^.SetEffectFlag(CFightingObj.EFFECT_SMOKER_INVIS, false);
//		var bool bHidden=pxFO^.GetCamouflage();
//		if(!bHidden)then
			//pxFO^.RemoveRangedBuff("is_invisible");
//		endif;
		var ^CTower pxTower=cast<CTower>(p_xHndl.GetObj());
		if(pxTower!=null)then
			var CObjHndl xTurret=pxTower^.GetTurret();
			if(xTurret.IsValid())then
				var ^CFightingObj pxTmp=cast<CFightingObj>(xTurret.GetObj());
				if(pxTmp!=null)then
					pxTmp^.SetEffectFlag(CFightingObj.EFFECT_SMOKER_INVIS,false);
//					if(!bHidden)then
//						pxTmp^.RemoveRangedBuff("is_invisible");
//					endif;
				endif;
			endif;
		endif;
		return true;
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy)
		return super.TakeDmg(p_pxEnemy);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile)
		return super.TakeDmg(p_pxEnemy, p_bProjectile);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, real p_fFactor)
		return super.TakeDmg(p_pxEnemy, p_fFactor);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile, real p_fFactor)
		return super.TakeDmg(p_pxEnemy, p_bProjectile, p_fFactor);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile, real p_fFactor, real p_fHitDelay)
		return super.TakeDmg(p_pxEnemy, p_bProjectile, p_fFactor, p_fHitDelay);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile, real p_fFactor, real p_fHitDelay, real p_fArmorPiercing)
		var real fReturn=super.TakeDmg(p_pxEnemy, p_bProjectile, p_fFactor, p_fHitDelay, p_fArmorPiercing);
		if(fReturn==0.0)then
			fReturn=10.0;
			fReturn += m_xTechTree.GetValueI("MiscValues/Ninigi/Tower_Damage",0).ToReal();
		endif;
		return fReturn;
	endproc;

	export proc void InitOwnRegion()
		if(!HasPersonalRegion())then
			var vec3 vP;vP.SetXYZ(m_fRadius,m_fRadius,0.0f);
			CreatePersonalRegion("SmokerRegion_"+GetName()+"_"+Random.GetInt().ToString(), vP, 010b);
			AddRangedBuff("owner_invisibility_bldg");
		endif;
	endproc;
	
	export proc string GetReportCode()
		return "defence";
	endproc;
	
endclass;

class CSeasTurretTower inherit CTower
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
	
		if(!p_bLoad)then
			SetTurretLink("we");
			SetTurret("seas_turret");
			m_sTurretAttackAnim="attack_front";
		endif;
	endproc;
endclass;

class CSeasMGTower inherit CTower
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
	
		if(!p_bLoad)then
			SetTurretLink("we");
			SetTurret("seas_hq_machinegun_nest_top");
			m_sTurretAttackAnim="attack_front";
		endif;
	endproc;
endclass;

class CSeasDefenseTower inherit CTower
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
	
		if(!p_bLoad)then
			SetTurretLink("we");
			SetTurret("seas_hq_defense_turret_top");
			m_sTurretAttackAnim="attack_front";
		endif;
	endproc;
endclass;

class CSeasSteelwork inherit CWarehouse
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
	endproc;

endclass;

class CTeslaTower inherit CTower
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
	
		if(!p_bLoad)then
			SetTurretLink("we");
			SetTurret("aje_tesla_tower_canon");
		endif;
		m_sTurretAttackAnim="gun_shoot";
	endproc;

endclass;

class CTradingOrder
	export var int m_iSellIndex;
	export var int m_iBuyIndex;
	export var int m_iSellAmount;
	export var int m_iBuyAmount;
endclass;

//Hu: Hu_Warehouse
//Aje: Aje_Storehouse
//Ninigi: ??
class CWarehouse inherit CRallyBuilding
	
	var bool m_bMarketplace;
	var array string m_asResources;
	var array real m_afChangeValues;
	
	var array CTradingOrder m_axTradingOrders;
	
	constructor()
	endconstructor;
	
	destructor()
		var ^CFlyingTrader pxTrader=CFlyingTraderMgr.GetFlyingTrader();
		if(pxTrader!=null)then
			pxTrader^.DeRegisterTradeBuilding(this);
		endif;
	enddestructor;
	
	export proc void OnInit(bool p_bLoad)
		m_bMarketplace=false;
		super.OnInit(p_bLoad);
		
		m_afChangeValues=0;
		m_afChangeValues.AddEntry(1.0);	//food
		m_afChangeValues.AddEntry(1.0);	//wood
		m_afChangeValues.AddEntry(1.0);	//stone
		var CPropDB xDB;
		if(xDB.Load(CSrvWrap.GetUrsRelPath()+"/Data/Base/Scripts/Server/settings/NewPointBuyCosts.txt"))then
			var ^CPropDB.CNode pxResources=xDB.FindNode("Resources",false);
			if(pxResources!=null)then
				var ^CPropDB.CNode pxTribe=pxResources^.Get(GetTribeName());
				if(pxTribe!=null)then
					m_afChangeValues[0]=pxTribe^.GetValueR("food",1.0);
					m_afChangeValues[1]=pxTribe^.GetValueR("wood",1.0);
					m_afChangeValues[2]=pxTribe^.GetValueR("stone",1.0);
				endif;
			endif;
		endif;
		ExamineFlags();
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		UpdateDeliveries();
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("TradeBuilding",1);
		endif;
	endproc;
	
	export proc void AcceptTrader()
		if(!m_bMarketplace)then return; endif;
		if(!HasAnim("open_gate"))then return; endif;
		InvokeGenericSCEvent(24,4.0f);
	endproc;
	
	export proc void ExamineFlags()
		if(GetTribeName()=="Hu")then
			if(!m_bMarketplace && m_xTechTree.GetValueI(GetObjPath()+"/flags/hu_marketplace",0)!=0)then
				SetMarketplace(true);
				SetRallySite(true);
			endif;
		elseif(GetTribeName()=="Aje")then
			if(!m_bMarketplace && m_xTechTree.GetValueI(GetObjPath()+"/flags/aje_bazaar",0)!=0)then
				SetMarketplace(true);
				SetRallySite(true);
			endif;
		elseif(GetTribeName()=="Ninigi")then
			if(!m_bMarketplace && m_xTechTree.GetValueI(GetObjPath()+"/flags/ninigi_warehouse",0)!=0)then
				SetMarketplace(true);
				SetRallySite(true);
			endif;
		elseif(GetTribeName()=="SEAS")then
			if(!m_bMarketplace && m_xTechTree.GetValueI(GetObjPath()+"/flags/seas_steelwork",0)!=0)then
				SetMarketplace(true);
				SetRallySite(true);
			endif;
		endif;
		super.ExamineFlags();
	endproc;
	
	proc void SetMarketplace(bool p_bStatus)
		m_bMarketplace=p_bStatus;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("Marketplace",p_bStatus);
		endif;
	
		if(m_bMarketplace)then
			/*var ^CFlyingTrader pxTrader=CFlyingTraderMgr.GetFlyingTrader();
			if(pxTrader!=null)then
				pxTrader^.RegisterTradeBuilding(this);
			endif;*/
		endif;
	endproc;
	
	proc void Buy(string p_sResource, int p_iAmount)
//		KLog.LogSpam("AnTr","Buy: "+p_sResource+", Amount: "+p_iAmount.ToString());
		var ^CPlayer pxPlayer=CSrvWrap.GetCurLevel()^.GetPlayer(GetOwner());
		if(pxPlayer==null)then return; endif;
		var ^CBasePlayer pxBasePlayer=cast<CBasePlayer>(pxPlayer);
		if(pxBasePlayer==null)then return; endif;
		var ^CAttribs pxPlAttr=pxPlayer^.GetAttribs();
		if(pxPlAttr==null)then return; endif;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr==null)then return; endif;
		var int iPlayerSkullAmount = pxPlAttr^.GetValueInt("iron");
		var int iPlayerAmount = pxPlAttr^.GetValueInt(p_sResource);
		var int iPlayerMaxAmount = pxPlAttr^.GetValueInt("max_"+p_sResource);
		if(iPlayerSkullAmount<=0)then
			CSrvWrap.SendGenericEvtToPlayer(GetOwner(), "MoreIron");
			CFeedback.Print(GetOwner(), CFeedback.ECONOMY, "_NT_BldgFailNotEnoughSkulls");
			return;
		endif;
		var real fChangeValue = 1.0;
		if(p_sResource=="stone")then
			fChangeValue=m_afChangeValues[2];
		elseif(p_sResource=="wood")then
			fChangeValue=m_afChangeValues[1];
		elseif(p_sResource=="food")then
			fChangeValue=m_afChangeValues[0];
		endif;
		if(iPlayerSkullAmount<p_iAmount)then
			p_iAmount=iPlayerSkullAmount;
		endif;
		if(iPlayerAmount>=iPlayerMaxAmount && !CMirageSrvMgr.Get().ResourcesUnlimited())then
			CFeedback.Print(GetOwner(), CFeedback.ECONOMY, "_NT_BldgFailRscCap");
			return;
		endif;
		if(!CMirageSrvMgr.Get().ResourcesUnlimited())then
			p_iAmount=Math.Min(p_iAmount, (iPlayerMaxAmount-iPlayerAmount));
		endif;
		var int iValue=Math.Round(p_iAmount.ToReal()/fChangeValue).ToInt();
		pxBasePlayer^.AddResource(p_sResource,iValue.ToReal(),true);
//		if(p_sResource=="stone")then
//			pxBasePlayer^.AddStone(iValue);
//		elseif(p_sResource=="wood")then
//			pxBasePlayer^.AddWood(iValue);
//		elseif(p_sResource=="food")then
//			pxBasePlayer^.AddFood(iValue);
//		endif;
		pxBasePlayer^.AddSkulls(-p_iAmount);
	endproc;
	
	export proc bool TraderArrived()
		return false;
	endproc;
	
	proc int Resource2Index(string p_sResource)
		var ^CLevelInfoHost pxLevelInfo=CSrvWrap.GetLevelInfo(false);
		if(pxLevelInfo==null)then return -1; endif;
		var ^CLevelInfo.CPlayerSlot pxPlSlot=pxLevelInfo^.GetOwnerPlayerSlot(GetOwner());
		if(pxPlSlot==null)then return -1; endif;
		var string sTribe=GetTribeName();
		var int i, iC=m_xTechTree.NumSubs("Resources/"+sTribe);
		var int iReturn=0;
		for(i=0)cond(i<iC)iter(i++)do
			if(m_xTechTree.GetValueS("Resources/"+sTribe+"/"+i.ToString(),"")!=p_sResource)then continue; endif;
			iReturn=i;
			break;
		endfor;
		return iReturn;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("buy_")!=-1)then
				KLog.LogSpam("AnTr","Command: '"+p_sCommand+"'");
				Buy(p_sMiscParams.Mid(p_sMiscParams.FindRev('_')+1),100);
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;

endclass;

class CLadder inherit CBuilding
	
	class CBuildUpInfo
		export var int			m_iGroupCmdID; ///< group command id, used for build up the ladder
		export var CObjHndl	m_xLadder; ///< ladder to build up
		export var CObjHndl	m_xWall; ///< targeted wall
	endclass;
	
	static var array CBuildUpInfo ms_axBUI;
	var CDockInfo m_xDockInfo;
	var CObjList m_xClimbers;
	var bool m_bSiegeBreak;
	
	export static proc void RegisterLadderBuildUp(int p_iCmdID,CObjHndl p_xLadder,CObjHndl p_xWall)
		var CBuildUpInfo xNew;
		xNew.m_iGroupCmdID=p_iCmdID;
		xNew.m_xLadder=p_xLadder;
		xNew.m_xWall=p_xWall;
		ms_axBUI.AddEntry(xNew);
	endproc;
	
	export static proc CObjHndl GetLadderBuildUp(int p_iCmdID, CObjHndl p_xWall)
		var int i,iC=ms_axBUI.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(ms_axBUI[i].m_iGroupCmdID==p_iCmdID&&ms_axBUI[i].m_xWall==p_xWall&&ms_axBUI[i].m_xWall.IsValid())then
				return ms_axBUI[i].m_xLadder;
			endif;
		endfor;
		return CObjHndl.Invalid();
	endproc;
	
	export static proc void UnregisterLadderBuildUp(CObjHndl p_xLadder)
		var int i,iC=ms_axBUI.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(ms_axBUI[i].m_xLadder==p_xLadder)then
				ms_axBUI.DeleteEntry(i);
				return;
			endif;
		endfor;
	endproc;
	
	export constructor()
		m_xDockInfo.SetMoveCallback(Climb);
	endconstructor;
	
	export proc ref CDockInfo GetDockInfo()
		return m_xDockInfo;
	endproc;
	
	export proc bool RegisterClimber(CObjHndl p_xClimber)
		if(!p_xClimber.IsValid()||m_bSiegeBreak)then return false; endif;
		m_xClimbers.Include(p_xClimber);
		return true;
	endproc;
	
	export proc bool UnregisterClimber(CObjHndl p_xClimber)
		if(!p_xClimber.IsValid())then return false; endif;
		if(m_xClimbers.FindEntry(p_xClimber)==-1)then return false; endif;
		m_xClimbers.RemEntry(p_xClimber);
		return true;
	endproc;
	
	proc real Climb(CObjHndl p_xActor,bool p_bUp)
		//L KLog.LogSpam("MaMa","Climb Up:"+p_bUp.ToString());
		var ^CCharacter pxActor=cast<CCharacter>(p_xActor.GetObj());
		if(pxActor==null)then return -1.0f; endif;
		return pxActor^.StartLadderClimb(GetHandle(),p_bUp,false,false);
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		m_xDockInfo.SetDockedDocker(true,GetHandle());
		UnregisterLadderBuildUp(GetHandle());
		SetIsSieging(true);
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("IsSiegeUnit", 1);
			pxAttr^.SetValue("IsDockingWall", 1);
		endif;
	endproc;
	
	export proc void Delete()
		m_xDockInfo.SetDockedDocker(false,GetHandle());
		super.Delete();
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="Ladd";
		var int iVersion=2;
		if(CMirageSrvMgr.SDK())then
			iVersion=1;
		endif;
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,iVersion);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xDockInfo.DoKArc(pxArc^);
		if(iVersion>=2)then
			m_xClimbers.DoKArc(pxArc^);
			pxArc^ << m_bSiegeBreak;
		endif;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="Ladd")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			m_xDockInfo.DoKArc(pxArc^);
			if(iVersion>=2)then
				m_xClimbers.DoKArc(pxArc^);
				pxArc^ << m_bSiegeBreak;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
	endproc;
	
	proc void OnDockedWallDeleted()
		BreakSiege();
	endproc;
	
	export proc void BreakSiege()
		m_bSiegeBreak=true;
		while(m_xClimbers.NumEntries()>0)do
			var ^CCharacter pxC=cast<CCharacter>(m_xClimbers[0].GetObj());
			m_xClimbers.DeleteEntry(0);
			if(pxC!=null)then
				pxC^.TerminateAction();
				pxC^.BreakSieging();
			endif;
		endwhile;
		m_xClimbers.Clear();
		return super.DiePerHarakiri();
	endproc;
	
	export proc void SetSiegeBreak(bool p_bOn)
		m_bSiegeBreak=p_bOn;
	endproc;
	
	export proc void DiePerHarakiri()
		if(m_xClimbers.Validate()>0)then return; endif;
		return super.DiePerHarakiri();
	endproc;
	
	export proc string GetReportCode()
		return "unit";
	endproc;
	
endclass;

class CNinigi_Defense_Skewer inherit CWall
	
	constructor()
	endconstructor;
	
	destructor()
	enddestructor;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy)
		return super.TakeDmg(p_pxEnemy);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile)
		return super.TakeDmg(p_pxEnemy, p_bProjectile);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, real p_fFactor)
		return super.TakeDmg(p_pxEnemy, p_fFactor);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile, real p_fFactor)
		return super.TakeDmg(p_pxEnemy, p_bProjectile, p_fFactor);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile, real p_fFactor, real p_fHitDelay)
		return super.TakeDmg(p_pxEnemy, p_bProjectile, p_fFactor, p_fHitDelay);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile, real p_fFactor, real p_fHitDelay, real p_fArmorPiercing)
		var real fReturn=super.TakeDmg(p_pxEnemy, p_bProjectile, p_fFactor, p_fHitDelay, p_fArmorPiercing);
		if(fReturn==0.0)then
			fReturn=10.0;
			fReturn += m_xTechTree.GetValueI("MiscValues/Ninigi/Skewer_Damage",0).ToReal();
		endif;
		return fReturn;
	endproc;
	
endclass;

class CNinigi_Defense_Skewer_Gate inherit CGate
	
	constructor()
	endconstructor;
	
	destructor()
	enddestructor;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy)
		return super.TakeDmg(p_pxEnemy);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile)
		return super.TakeDmg(p_pxEnemy, p_bProjectile);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, real p_fFactor)
		return super.TakeDmg(p_pxEnemy, p_fFactor);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile, real p_fFactor)
		return super.TakeDmg(p_pxEnemy, p_bProjectile, p_fFactor);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile, real p_fFactor, real p_fHitDelay)
		return super.TakeDmg(p_pxEnemy, p_bProjectile, p_fFactor, p_fHitDelay);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile, real p_fFactor, real p_fHitDelay, real p_fArmorPiercing)
		var real fReturn=super.TakeDmg(p_pxEnemy, p_bProjectile, p_fFactor, p_fHitDelay, p_fArmorPiercing);
		if(fReturn==0.0)then
			fReturn=10.0;
			fReturn += m_xTechTree.GetValueI("MiscValues/Ninigi/Skewer_Damage",0).ToReal();
		endif;
		return fReturn;
	endproc;
	
endclass;

class CWall inherit CBuilding
	
	var bool m_bStones;
	var bool m_bGateDestruct;
	const int STONES_RELOAD_TIMER=182;
	
	var vec3 m_vBuildVector; //vector from getpos to buildposition
	var CObjList m_xParentGates;
	var CObjHndl m_xDocker; ///< object docking this wall
	
	constructor()
		m_bGateDestruct=true;
	endconstructor;
	
	destructor()
		if(m_xDocker.IsValid())then
			var ^CFightingObj pxD=cast<CFightingObj>(m_xDocker.GetObj());
			if(pxD!=null)then
				pxD^.BreakSiege();
			endif;
		endif;
	enddestructor;
	
	export proc void SetBuildVector(vec3 p_vPos)
		m_vBuildVector=p_vPos;
	endproc;
	
	export proc ref vec3 GetBuildVector()
		return m_vBuildVector;
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetFreeBorderBlocker(false);
		SetIsWall(true);
		SetWallMapObj(true);
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="WaBa")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xParentGates.DoKArc(pxArc^);
			if(pxArc^.GetVersion()>=2)then
				pxArc^ << m_bGateDestruct;
			endif;
			if(pxArc^.GetVersion()>=3)then
				m_xDocker.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="WaBa"; //Wall base
		var int iVersion=3;
		if(CMirageSrvMgr.SDK())then
			iVersion=1;
		endif;
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,iVersion);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xParentGates.DoKArc(pxArc^);
		if(iVersion>=2)then
			pxArc^ << m_bGateDestruct;
		endif;
		if(iVersion>=3)then
			m_xDocker.DoKArc(pxArc^);
		endif;
		pxWalk^.Close();
	endproc;
	
	export proc void SetParentGate(CObjHndl p_xGate)
		if(m_xParentGates.NumEntries()==0)then
			p_xGate.GetObj()^.AddGroupedChild(this);
		endif;
		if(m_xParentGates.Validate()>0)then
			CancelAction("Actions/Aje/Upgrades/aje_bone_palisade/clay_wall");
			CancelAction("Actions/Aje/Moves/BLDG/BuildDown");
		endif;
		m_xParentGates.AddEntry(p_xGate);
	endproc;
	
	export proc void OnDeleteParentGate(CObjHndl p_xGate)
		p_xGate.GetObj()^.RemGroupedChild(this);
		m_xParentGates.Exclude(p_xGate);
		//we can have up to 4 parent gates
		if(m_xParentGates.Validate()>0)then
			m_xParentGates[0].GetObj()^.AddGroupedChild(this);
		else
			CancelAction("Actions/Aje/Upgrades/aje_bone_palisade/clay_wall");
		endif;
	endproc;
	
	export proc void ExamineFlags()
//		if(m_xTechTree.GetValueI("Objects/"+GetTribeName()+"/InventObjects/hu_falling_stones/invented",0)!=0/* && GetGfxName()!="hu_palisade"*/)then
		if(m_xTechTree.GetValueI("Objects/"+GetTribeName()+"/InventObjects/hu_falling_stones/invented",0)!=0/*&&GetGfxName()=="hu_re_enforced_wall"*/)then
			m_bStones=true;
		else
			m_bStones=false;
		endif;
		super.ExamineFlags();
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy)
		return super.TakeDmg(p_pxEnemy);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile)
		return super.TakeDmg(p_pxEnemy, p_bProjectile);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, real p_fFactor)
		return super.TakeDmg(p_pxEnemy, p_fFactor);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile, real p_fFactor)
		return super.TakeDmg(p_pxEnemy, p_bProjectile, p_fFactor);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile, real p_fFactor, real p_fHitDelay)
		return super.TakeDmg(p_pxEnemy, p_bProjectile, p_fFactor, p_fHitDelay);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile, real p_fFactor, real p_fHitDelay, real p_fArmorPiercing)
		if(m_xParentGates.Validate()>0)then
			//redirect dmg to parent gate
			// Henry: i commented this, because gates suffer enormous damage from catapults, if they target the gate, but the 2 wall parts transfer damage from aoe to gate as well
//			return cast<CGate>(m_xParentGates[0].GetObj())^.TakeDmg(p_pxEnemy,p_fFactor,p_fHitDelay);
			return 0.0;
		endif;
		if(m_bStones && m_bBuildingReady && !m_bIncapacitated && !HasTimer(STONES_RELOAD_TIMER))then
			CreateTimer(STONES_RELOAD_TIMER, CGameTimeSpan.OneSecond() * GetWeaponDuration() , false);
			var ^CAreaDamage pxDmg=new CAreaDamage(this, GetPos());
			var CObjHndl xFX=AddFX("Hu_Wallstones_Fx",0.8);
			var ^CFX pxFX=cast<CFX>(xFX.GetObj());
			if(pxFX!=null)then
				pxFX^.SetRot(GetAngleToQ(p_pxEnemy));
				pxFX^.SetAnim("anim",1);
			endif;
			//SetAnim("wall_stones",1);
		endif;
		return super.TakeDmg(p_pxEnemy, p_bProjectile, p_fFactor, p_fHitDelay, p_fArmorPiercing);
	endproc;
	
	export proc real TakeDmgFromBuildup(^CFightingObj p_pxEnemy, real p_fFactor, real p_fHitDelay)
		if(m_xParentGates.Validate()>0)then
			//redirect dmg to parent gate
//			return cast<CGate>(m_xParentGates[0].GetObj())^.TakeDmgFromBuildup(p_pxEnemy,p_fFactor,p_fHitDelay);
			return 0.0;
		endif;
		if(m_bStones && m_bBuildingReady && !m_bIncapacitated && !HasTimer(STONES_RELOAD_TIMER))then
			CreateTimer(STONES_RELOAD_TIMER, CGameTimeSpan.OneSecond() * GetWeaponDuration() , false);
			var ^CAreaDamage pxDmg=new CAreaDamage(this, GetPos());
			var CObjHndl xFX=AddFX("Hu_Wallstones_Fx",0.8);
			var ^CFX pxFX=cast<CFX>(xFX.GetObj());
			if(pxFX!=null)then
				pxFX^.SetRot(GetAngleToQ(p_pxEnemy));
				pxFX^.SetAnim("anim",1);
			endif;
			//SetAnim("wall_stones",1);
		endif;
		return super.TakeDmgFromBuildup(p_pxEnemy, p_fFactor, p_fHitDelay);
	endproc;
	
	proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		super.HandleEvent(p_rxEvtPtr);
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==STONES_RELOAD_TIMER )then
				DeleteTimer(STONES_RELOAD_TIMER);
			endif;
		endif;
	endproc;
	
	export proc bool UpdateGfx()
		var string sGFX=m_xTechTree.GetValueS(GetObjPath()+"/gfx","");
		if(sGFX.IsEmpty())then return false; endif;
		if(sGFX!=GetGfxName())then
			var ^CWallMapSrv pxWM=CSrvWrap.GetObjMgr()^.GetObjPlaceChecker()^.GetWallMap();
			pxWM^.WallClassChanged(GetHandle(),sGFX);
			m_sMyBuildAction="";
			SetGFX(sGFX);
			UpdateObjPath();
			OnTechTreeChange();
			if(m_xDocker.IsValid())then
				var ^CFightingObj pxD=cast<CFightingObj>(m_xDocker.GetObj());
				if(pxD!=null&&pxD^.GetClassName()=="ninigi_siegetower")then
					var ^CDockWall pxTaskDW=cast<CDockWall>(pxD^.GetCurTask());
					if(pxTaskDW!=null)then
						var string sAnim="opengate_moveup";
						pxTaskDW^.SetAnim(sAnim);
						if(pxD^.GetCurrentAnimName()!=sAnim)then
							pxD^.SetAnim(sAnim,1);
						endif;
					endif;
				endif;
			endif;
			return true;
		endif;
		return false;
	endproc;
	
	export proc void SetReadyBuildTrigger()
		super.SetReady();
		var ^CWallMapSrv pxWM=CSrvWrap.GetObjMgr()^.GetObjPlaceChecker()^.GetWallMap();
		if(pxWM!=null)then
			pxWM^.WallClassChanged(GetHandle(),GetGfxName());
			var CObjList xWalls;
			pxWM^.GetNextWalls(GetPos(),10.0f,xWalls,true,false,false,true);
		endif;
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		var ^CWallMapSrv pxWM=CSrvWrap.GetObjMgr()^.GetObjPlaceChecker()^.GetWallMap();
		pxWM^.SetReady(GetHandle());
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("IsDockable", 1);
		endif;
	endproc;
	
	export proc void SetOwner(int p_iNewOwner)
		super.SetOwner(p_iNewOwner);
		var ^CWallMapSrv pxWM=CSrvWrap.GetObjMgr()^.GetObjPlaceChecker()^.GetWallMap();
		pxWM^.SetReady(GetHandle());
	endproc;
		
	export proc void HarakiriFastAndSilent()
		m_bGateDestruct=false;
		super.HarakiriFastAndSilent();
	endproc;
	
	export proc void DieFastAndSilent()
		m_bGateDestruct=false;
		super.DieFastAndSilent();
	endproc;
	
	export proc void Die()
		m_bGateDestruct=false;
		super.Die();
	endproc;
	
	export proc void Delete()
		if(m_bGateDestruct)then
			PayBack(1.0);
		endif;
		return super.Delete();
	endproc;
	
	export proc void BuildDown(string p_sPath)
		if(m_xParentGates.Validate()>0)then
			return;
		endif;
		return super.BuildDown(p_sPath);
	endproc;
	
	export proc void IgniteBuilding(real p_fDmg, int p_iMaxCount, CObjHndl p_xSource, int p_iSource)
		return;
	endproc;
	
	export proc bool ActionGateUpgrade(string p_sTTPath)
		if(!m_bBuildingReady)then return false; endif;
		var CObjHndl xPyCO;
		var CAction.CResourceCosts xCosts;
		var bool bCheck=false;
		var string sBefore, sAfter, sTribe;
		if(CRequirementsMgr.Get().CheckConditionsAndPayLimit(this, p_sTTPath, xPyCO, xCosts, true, sBefore, sAfter, bCheck, sTribe))then
			var ^CAction pxTask= cast<CAction>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"Action"));
//			if(pxTask==null)then return false; endif;
//			pxTask^.Init(GetHandle(),p_sTTPath, xCosts);
			if(pxTask==null)then return false; endif;
			if(!pxTask^.Init(GetHandle(), p_sTTPath, xCosts, sBefore, sAfter, bCheck, sTribe))then
				pxTask^.GetFactory()^.FreeState(pxTask);
				return false;
			endif;
			pxTask^.SetPyCO(xPyCO);
			AddTask(pxTask,true);
		else
			return false;
		endif;
		return true;
	endproc;
	
	export proc void SetDockerObj(CObjHndl p_xDocker)
		m_xDocker=p_xDocker;
		if(m_xDocker.IsValid())then
			var ^CFightingObj pxD=cast<CFightingObj>(m_xDocker.GetObj());
			if(pxD!=null)then
				pxD^.SetSiegeBreak(false);
			endif;
		endif;
	endproc;
	
	export proc CObjHndl GetDockerObj()
		return m_xDocker;
	endproc;
	
	export proc void DiePerHarakiri()
		if(m_xDocker.IsValid())then return; endif;
		return super.DiePerHarakiri();
	endproc;
	
	export proc string GetReportCode()
		return "defence";
	endproc;
	
	export proc bool AuthorizationPicardFourSevenAlphaTango()
		return false;
	endproc;
	
endclass;

class CGateFOWVIsible inherit CGate
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetVisInFOW(true);
	endproc;
endclass;

class CGate inherit CBuilding
	
	var int				m_iState;	///< GATE_STATE_OPEN/GATE_STATE_CLOSED/GATE_STATE_AUTO
	const int			BROCKEN_TIMER=188;
	const int			AUTO_GATE_TIMER=189;
	var int				m_iFormerState;
	var CObjList	m_xHackers;
	var CObjHndl	m_xWallL;
	var CObjHndl	m_xWallR;
	var bool			m_bHaraKiri;
	
	export const int VIS_FLAG_OST_BIT			= 11;
	export const int VIS_FLAG_WEST_BIT		= 7;
	export const int VIS_FLAG_OPEN_BIT		= 14;	///< bit for collision volumes in open state
	export const int VIS_FLAG_CLOSED_BIT	= 16;	///< bit for collision volumes in closed state
	
	export const bitset COL_DIRECTION_MASK	= 011111111100000b;	///< mask for direction flags
	export const bitset COL_OPEN_BIT				= 0100000000000000b;	///< bit for collision volumes on state change
	export const bitset COL_CLOSED_BIT			= 010000000000000000b;	///< bit for collision volumes in closed state
	
	export const int GATE_STATE_OPEN				=0;
	export const int GATE_STATE_CLOSED			=1;
	export const int GATE_STATE_AUTO				=2;
	
	var bool					m_bStones;
	const int					STONES_RELOAD_TIMER=40017;
	
	export proc void ExamineFlags()
//		if(m_xTechTree.GetValueI("Objects/"+GetTribeName()+"/InventObjects/hu_falling_stones/invented",0)!=0/* && GetGfxName()!="hu_palisade_gate"*/)then
		if(m_xTechTree.GetValueI("Objects/"+GetTribeName()+"/InventObjects/hu_falling_stones/invented",0)!=0/*&&GetGfxName()=="hu_re_enforced_wall_gate"*/)then
			m_bStones=true;
		else
			m_bStones=false;
		endif;
		super.ExamineFlags();
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy)
		return super.TakeDmg(p_pxEnemy);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile)
		return super.TakeDmg(p_pxEnemy, p_bProjectile);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, real p_fFactor)
		return super.TakeDmg(p_pxEnemy, p_fFactor);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile, real p_fFactor)
		return super.TakeDmg(p_pxEnemy, p_bProjectile, p_fFactor);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile, real p_fFactor, real p_fHitDelay)
		return super.TakeDmg(p_pxEnemy, p_bProjectile, p_fFactor, p_fHitDelay);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile, real p_fFactor, real p_fHitDelay, real p_fArmorPiercing)
		if(m_bStones && m_bBuildingReady && !m_bIncapacitated && !HasTimer(STONES_RELOAD_TIMER))then
			CreateTimer(STONES_RELOAD_TIMER, CGameTimeSpan.OneSecond() * GetWeaponDuration(), false);
			var ^CAreaDamage pxDmg=new CAreaDamage(this, GetPos());
			var CObjHndl xFX=AddFX("Hu_Wallstones_Fx",0.8);
			var ^CFX pxFX=cast<CFX>(xFX.GetObj());
			if(pxFX!=null)then
				pxFX^.SetRot(GetAngleToQ(p_pxEnemy));
				pxFX^.SetAnim("anim",1);
			endif;
		endif;
		return super.TakeDmg(p_pxEnemy, p_bProjectile, p_fFactor, p_fHitDelay, p_fArmorPiercing);
	endproc;
	
	export proc real TakeDmgFromBuildup(^CFightingObj p_pxEnemy, real p_fFactor, real p_fHitDelay)
		if(m_bStones && m_bBuildingReady && !m_bIncapacitated && !HasTimer(STONES_RELOAD_TIMER))then
			CreateTimer(STONES_RELOAD_TIMER, CGameTimeSpan.OneSecond() * GetWeaponDuration() , false);
			var ^CAreaDamage pxDmg=new CAreaDamage(this, GetPos());
			var CObjHndl xFX=AddFX("Hu_Wallstones_Fx",0.8);
			var ^CFX pxFX=cast<CFX>(xFX.GetObj());
			if(pxFX!=null)then
				pxFX^.SetRot(GetAngleToQ(p_pxEnemy));
				pxFX^.SetAnim("anim",1);
			endif;
		endif;
		return super.TakeDmgFromBuildup(p_pxEnemy, p_fFactor, p_fHitDelay);
	endproc;
	
	export constructor()
		m_iState=-1;
		m_bHaraKiri=false;
	endconstructor;
	
	export destructor()
		CSrvWrap.GetPathfinder().UnregisterGate(this);
	enddestructor;
	
	export proc void Delete()
		var ^CWall pxWallL=cast<CWall>(m_xWallL.GetObj());
		var ^CWall pxWallR=cast<CWall>(m_xWallR.GetObj());
		if(pxWallL!=null)then
			pxWallL^.OnDeleteParentGate(GetHandle());
		endif;
		if(pxWallR!=null)then
			pxWallR^.OnDeleteParentGate(GetHandle());
		endif;
		super.Delete();
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetFreeBorderBlocker(false);
		SetIsGate(true);
		var bitset dwCol=GetPFBlockerMask()&COL_DIRECTION_MASK;
		CSrvWrap.GetPathfinder().RegisterGate(this,dwCol|COL_OPEN_BIT,dwCol|COL_CLOSED_BIT);
		var vec3 vPos=GetPos();
		var bool bNewGate=vPos.GetX().ToInt()%8==4&&vPos.GetY().ToInt()%8==4;
		if(bNewGate)then
			var ^CWallMapSrv pxWM=CSrvWrap.GetObjMgr()^.GetObjPlaceChecker()^.GetWallMap();
			var bool bDiagonal=pxWM^.IsGateDiagonal(this);
			SetRndInvMaskSingleFlagInv(VIS_FLAG_OST_BIT,bDiagonal);
			SetRndInvMaskSingleFlagInv(VIS_FLAG_WEST_BIT,bDiagonal);
			if(!p_bLoad)then
				var CObjHndl xWL,xWR;
				pxWM^.GetGateConnectingWalls(this,m_xWallL,m_xWallR);
				var ^CWall pxWallL=cast<CWall>(m_xWallL.GetObj());
				var ^CWall pxWallR=cast<CWall>(m_xWallR.GetObj());
				if(pxWallL!=null)then
					pxWallL^.SetParentGate(GetHandle());
				endif;
				if(pxWallR!=null)then
					pxWallR^.SetParentGate(GetHandle());
				endif;
			endif;
		endif;
		SetRndInvMaskSingleFlagInv(VIS_FLAG_OPEN_BIT,false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_CLOSED_BIT,true);
		SetWallMapObj(true);
		if(p_bLoad)then
			if(m_iState==GATE_STATE_OPEN)then
				m_iState=-1;
				Open();
			elseif(m_iState==GATE_STATE_CLOSED)then
				m_iState=-1;
				Close();
			elseif(m_iState==GATE_STATE_AUTO)then
				m_iState=-1;
				Auto();
			else
				m_iState=-1;
				Auto();
			endif;
		else
//			m_iState=-1;
//			Auto();
			m_iState=GATE_STATE_AUTO;
//			SetPFBlocking();
//			UpdateStateAttrib();
		endif;
		SetLEGfxFlags();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="Gaba")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			pxArc^<<m_iState;
			if(pxArc^.GetVersion()<2)then
				//in old versions this was a bool, (false==closed)
				if(m_iState!=0)then m_iState=GATE_STATE_OPEN; else m_iState=GATE_STATE_CLOSED; endif;
				return;
			endif;
			pxArc^<<m_iFormerState;
			if(pxArc^.GetVersion()>=3)then
				m_xWallL.DoKArc(pxArc^);
				m_xWallR.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="Gaba"; //Gate base
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,3);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		pxArc^ << m_iState;
		pxArc^ << m_iFormerState;
		m_xWallL.DoKArc(pxArc^);
		m_xWallR.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;
	
	export proc bool UpdateGfx()
		var string sGFX=m_xTechTree.GetValueS(GetObjPath()+"/gfx","");
		if(sGFX.IsEmpty())then return false; endif;
		if(sGFX!=GetGfxName())then
			var ^CWallMapSrv pxWM=CSrvWrap.GetObjMgr()^.GetObjPlaceChecker()^.GetWallMap();
			pxWM^.WallClassChanged(GetHandle(),sGFX);
			m_sMyBuildAction="";
			SetGFX(sGFX);
			UpdateObjPath();
			OnTechTreeChange();
			var int iLastAnimFrame=50;
			if(sGFX.Find("hu_palisade")!=-1)then
//				iLastAnimFrame=70;
				iLastAnimFrame=69;
			elseif(sGFX=="ninigi_defense_skewer_gate")then
				iLastAnimFrame=40;
			elseif( sGFX=="tutorial_vikingpark_gate")then
				iLastAnimFrame=40;
			endif;
			if(m_iState==GATE_STATE_OPEN)then
				if(sGFX.Find("hcl13_gate")!=-1)then
					iLastAnimFrame=30;
					SetAnim("open",0,iLastAnimFrame);
				elseif(sGFX.Find("ship_chain")!=-1)then
					iLastAnimFrame=250;
					SetAnim("open_anim",0,iLastAnimFrame);
				else
					SetAnim("open",0,iLastAnimFrame);
				endif;
			elseif(m_iState==GATE_STATE_CLOSED||m_iState==GATE_STATE_AUTO)then
				if(sGFX.Find("hcl13_gate")!=-1)then
					iLastAnimFrame=29;
					SetAnim("close",0,iLastAnimFrame);
				elseif(sGFX.Find("ship_chain")!=-1)then
					iLastAnimFrame=250;
					SetAnim("open_anim",2,iLastAnimFrame);
				else
					SetAnim("close",0,iLastAnimFrame);
				endif;
			endif;
			return true;
		endif;
		return false;
	endproc;
	
	export proc void SetReadyBuildTrigger()
		super.SetReady();
		var ^CWallMapSrv pxWM=CSrvWrap.GetObjMgr()^.GetObjPlaceChecker()^.GetWallMap();
		pxWM^.WallClassChanged(GetHandle(),GetGfxName());
	endproc;
	
	export proc void SetIdleAnim()
		//skip idle anim //WT#781
	endproc;
	
	proc void Open()
		var string sGFX=GetGfxName();
		if(m_iState==GATE_STATE_OPEN)then return; endif; //redundant
		if(m_xHackers.NumEntries()>0)then
			OpenViolently(true);
		endif;
		if(HasTimer(AUTO_GATE_TIMER))then
			DeleteTimer(AUTO_GATE_TIMER);
		else
			if(sGFX=="ship_chain")then
				SetAnim("open_anim",1);
			else
				SetAnim("open",1);
			endif;
		endif;
		m_iState=GATE_STATE_OPEN;
		SetPFBlocking();
		UpdateStateAttrib();
	endproc;
	
	proc void Close()
		var string sGFX=GetGfxName();
		if(m_iState==GATE_STATE_CLOSED)then return; endif; //redundant
		if(HasTimer(BROCKEN_TIMER))then return; endif;
		var bool bSetAnim=true;
		if(HasTimer(AUTO_GATE_TIMER))then
			DeleteTimer(AUTO_GATE_TIMER);
		elseif(m_iState==GATE_STATE_AUTO)then
			bSetAnim=false;
		endif;
		if(bSetAnim)then
			if(sGFX=="ship_chain")then
				SetAnim("open_anim",2);
			else
				SetAnim("close",1);
			endif;
		endif;
		m_iState=GATE_STATE_CLOSED;
		SetPFBlocking();
		UpdateStateAttrib();
	endproc;
	
	proc void Auto()
		var string sGFX=GetGfxName();
		if(m_iState==GATE_STATE_AUTO)then return; endif; //redundant
		if(HasTimer(BROCKEN_TIMER))then return; endif;
		if(m_iState!=GATE_STATE_CLOSED)then
			if(sGFX=="ship_chain")then
				SetAnim("open_anim",2);
			else
				SetAnim("close",1);
			endif;
		endif;
		m_iState=GATE_STATE_AUTO;
		SetPFBlocking();
		UpdateStateAttrib();
	endproc;
	
	proc void OnAutoGatePassUnit()
		var string sGFX=GetGfxName();
		if(m_iState!=GATE_STATE_AUTO)then return; endif;
		//KLog.LogWarn("CHP","Gate\n");
		if(HasTimer(AUTO_GATE_TIMER))then
			DeleteTimer(AUTO_GATE_TIMER);
		else
			if(sGFX=="ship_chain")then
				SetAnim("open_anim",1);
			else
				SetAnim("open",1);
			endif;
		endif;
		CreateTimer(AUTO_GATE_TIMER,CGameTimeSpan.OneSecond()*8.0,false);
	endproc;
	
	proc void UpdateStateAttrib()
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("GateState",m_iState);
		endif;
	endproc;
	
	export proc void SetPFBlocking()
		//CSrvWrap.GetPathfinder().UpdatePFBlocker(this);
		var bitset dwState=CPathfinder.GS_Open;
		if(m_iState==GATE_STATE_CLOSED)then dwState=CPathfinder.GS_Closed; endif;
		if(m_iState==GATE_STATE_AUTO)then dwState=CPathfinder.GS_Auto; endif;
		CSrvWrap.GetPathfinder().UpdateGateState(this,dwState);
	endproc;
	
	proc void SetPFBlockerMask(bitset p_dwMask)
		super.SetPFBlockerMask(p_dwMask);
		if(m_bBuildingReady)then
			// validate pathfinding information
			SetPFBlocking();
		endif;
	endproc;
	
	proc void SetLEGfxFlags()
		if(CSrvWrap.GetCurLevel()==null||!CSrvWrap.GetCurLevel()^.IsEditable())then return; endif;
		if(m_iState==0)then
			//we can't use anims inside LevelEd, so use Flags instead
			SetRndInvMaskSingleFlagInv(VIS_FLAG_OPEN_BIT,true);
			SetRndInvMaskSingleFlagInv(VIS_FLAG_CLOSED_BIT,false);
		elseif(m_iState==1)then
			SetRndInvMaskSingleFlagInv(VIS_FLAG_OPEN_BIT,false);
			SetRndInvMaskSingleFlagInv(VIS_FLAG_CLOSED_BIT,true);
		elseif(m_iState==2)then
			SetRndInvMaskSingleFlagInv(VIS_FLAG_OPEN_BIT,true);
			SetRndInvMaskSingleFlagInv(VIS_FLAG_CLOSED_BIT,true);
		endif;
	endproc;
	
	export proc void HandleEditorCommand(string p_sCommand,^CGameObj p_pxObject,vec3 p_vPos,string p_sMiscParams)
		if(p_sCommand=="LE_SetGateState")then
			var int iState=p_sMiscParams.ToInt();
			if(iState==0)then
				Open();
			elseif(iState==1)then
				Close();
			else
				Auto();
			endif;
			SetLEGfxFlags();
		else
			super.HandleEditorCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams);
		endif;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("Open")!=-1)then
				if(m_bBuildingReady)then
					Open();
				else
					m_iState=GATE_STATE_OPEN;
					UpdateStateAttrib();
				endif;
			elseif(p_sMiscParams.Find("Close")!=-1)then
				if(m_bBuildingReady)then
					Close();
				else
					m_iState=GATE_STATE_CLOSED;
					UpdateStateAttrib();
				endif;
			elseif(p_sMiscParams.Find("Auto")!=-1)then
				if(m_bBuildingReady)then
					Auto();
				else
					m_iState=GATE_STATE_AUTO;
					UpdateStateAttrib();
				endif;
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	export proc void Action(string p_sTTPath)
		if(p_sTTPath.Find("Aje/Upgrades/aje_bone_palisade_gate")!=-1)then
			var ^CWall pxWallL=cast<CWall>(m_xWallL.GetObj());
			var ^CWall pxWallR=cast<CWall>(m_xWallR.GetObj());
			if(pxWallL!=null&&pxWallL^.GetGfxName()!="aje_clay_wall")then
				if(!pxWallL^.ActionGateUpgrade("Actions/Aje/Upgrades/aje_bone_palisade/clay_wall"))then return; endif;
			endif;
			if(pxWallR!=null&&pxWallR^.GetGfxName()!="aje_clay_wall")then
				if(!pxWallR^.ActionGateUpgrade("Actions/Aje/Upgrades/aje_bone_palisade/clay_wall"))then return; endif;
			endif;
			return super.Action(p_sTTPath);
		else
			super.Action(p_sTTPath);
		endif;
	endproc;
	
	export proc void CancelAction(string p_sTTPath)
		if(p_sTTPath.Find("Aje/Upgrades/aje_bone_palisade_gate")!=-1)then
			var ^CWall pxWallL=cast<CWall>(m_xWallL.GetObj());
			var ^CWall pxWallR=cast<CWall>(m_xWallR.GetObj());
			if(pxWallL!=null)then
				pxWallL^.CancelAction("Actions/Aje/Upgrades/aje_bone_palisade/clay_wall");
			endif;
			if(pxWallR!=null)then
				pxWallR^.CancelAction("Actions/Aje/Upgrades/aje_bone_palisade/clay_wall");
			endif;
			return super.CancelAction(p_sTTPath);
		else
			super.CancelAction(p_sTTPath);
		endif;
	endproc;
	
	export proc void SetReadyBuild()
		super.SetReadyBuild();
		if(m_iState==-1)then
			Auto();
		else
			if(m_iState==GATE_STATE_OPEN)then
				m_iState=-1;
				Open();
			elseif(m_iState==GATE_STATE_CLOSED)then
				m_iState=-1;
				Close();
			else
				m_iState=-1;
				Auto();
			endif;
		endif;
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		if(m_bBuildingReady)then
			if(GetClassName()=="seas_wall_gate")then
				var vec3 vPos=GetPos();
				vPos.SetZ(CSrvWrap.GetScapeMgr().GetHeight(vPos.GetX(),vPos.GetY())-1.0f);
				SetPos(vPos);
			endif;
		endif;
		var ^CWallMapSrv pxWM=CSrvWrap.GetObjMgr()^.GetObjPlaceChecker()^.GetWallMap();
		pxWM^.SetReady(GetHandle());
		SetPFBlocking();
	endproc;
	
	export proc bool IsOpen()
		return m_iState==GATE_STATE_OPEN;
	endproc;
	
	export proc void AddHacker(CObjHndl p_xHacker)
		if(p_xHacker.IsValid())then
			m_xHackers.Include(p_xHacker);
		endif;
		var int i;
		for(i=0)cond(i<m_xHackers.NumEntries())iter(i++)do
			if(!m_xHackers[i].IsValid())then
				m_xHackers.DeleteEntry(i);
				i--;
			endif;
		endfor;
	endproc;
	
	//Anti-Virus-Programm
	export proc void RemoveHacker(CObjHndl p_xHacker)
		var int iIndex=m_xHackers.FindEntry(p_xHacker);
		if(iIndex!=-1)then
			m_xHackers.RemEntry(p_xHacker);
		endif;
	endproc;
	
	proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		super.HandleEvent(p_rxEvtPtr);
		var string sGFX=GetGfxName();
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==BROCKEN_TIMER )then
				DeleteTimer(BROCKEN_TIMER);
				if(m_iFormerState==GATE_STATE_CLOSED)then
					Close();
				elseif(m_iFormerState==GATE_STATE_AUTO)then
					Auto();
				endif;
			elseif(p_rxEvtPtr.GetInt(0)==STONES_RELOAD_TIMER)then
				DeleteTimer(STONES_RELOAD_TIMER);
			elseif(p_rxEvtPtr.GetInt(0)==AUTO_GATE_TIMER)then
				if(m_iState==GATE_STATE_AUTO)then
					if(sGFX=="ship_chain")then
						SetAnim("open_anim",2);
					else
						SetAnim("close",1);
					endif;
				endif;
			endif;
		endif;
	endproc;
	
	export proc bool OpenViolently(bool p_bOwn)
		if(!HasTimer(BROCKEN_TIMER)&& !IsOpen())then
			m_iFormerState=m_iState;
			CreateTimer(BROCKEN_TIMER, CGameTimeSpan.OneSecond() * 30.0 , false);
			if(!p_bOwn)then
				Open();
			endif;
			return true;
		endif;
		return false;
	endproc;
	
	export proc void DiePerHarakiri()
		if(IsDestructible())then return; endif;
		m_bHaraKiri=true;
		if(!m_bBuildingReady && CMirageSrvMgr.Get().BuildingCancellation())then
			var bool bPayBack=PayBack(0.75);
		endif;
		OnKill();
		Die();
		return;
	endproc;
	
	export proc void Die()
		if(m_bHaraKiri)then return super.Die(); endif;
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel!=null)then
			var ^CPlayer pxPlayer=pxLevel^.GetPlayer(GetOwner());
			if(pxPlayer!=null && cast<CAiPlayer>(pxPlayer)==null)then
				CSrvWrap.SendGenericEvtToPlayer(GetOwner(), "GateBreak");
			endif;
		endif;
		super.Die();
	endproc;
	
	// Added by AyCe, so transferring the gate to another player updates PF
	export proc void SetOwner(int p_iNewOwner)
		super.SetOwner(p_iNewOwner);
		if(m_iState==GATE_STATE_OPEN)then
			m_iState=-1;
			Open();
		elseif(m_iState==GATE_STATE_CLOSED)then
			m_iState=-1;
			Close();
		elseif(m_iState==GATE_STATE_AUTO)then
			m_iState=-1;
			Auto();
		else
			m_iState=-1;
			Auto();
		endif;
	endproc;
	
	export proc void IgniteBuilding(real p_fDmg, int p_iMaxCount, CObjHndl p_xSource, int p_iSource)
		return;
	endproc;
	
	export proc string GetReportCode()
		return "defence";
	endproc;
	
	export proc bool AuthorizationPicardFourSevenAlphaTango()
		return false;
	endproc;
	
endclass;

//Hu: Hu_Fireplace
class CFireplace inherit CRallyBuilding
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		CheckAge();
	endproc;
	
	export proc void OnTechTreeChange()
		super.OnTechTreeChange();
	endproc;
	
	export proc void OnTechTreeChange(ref CStringArray p_rasChanges)
		super.OnTechTreeChange(p_rasChanges);
		var int i,iC=p_rasChanges.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(p_rasChanges[i].Find("InventObjects/age_")!=-1)then
				CheckAge();
			elseif(p_rasChanges[i].Find("InventObjects/final_stage")!=-1)then
				CheckAge();
			endif;
		endfor;
	endproc;
	
	export proc bool ShallBeRevealedAutomaticaly()
		if(GetClassName()=="hu_fireplace"||GetClassName()=="ninigi_fireplace"||GetClassName()=="seas_headquarters")then return false; endif;
		return true;
	endproc;
	
	export proc string GetReportCode()
		return "center";
	endproc;
	
endclass;

class CHuFireplace inherit CFireplace
	var bool			m_bEquipped;
	var CObjList		m_xAddons;
	var array vec3		m_avAddonOffsets;
	
	constructor()
		m_bEquipped=false;
	endconstructor;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="HuHq")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			if(iVersion>=1)then
				(pxArc^) << m_bEquipped;
				var int i,iC;
				(pxArc^) << iC;
				m_avAddonOffsets=iC;
				for(i=0) cond(i<iC) iter(i++)do
					(pxArc^) << m_avAddonOffsets[i];
				endfor;
				m_xAddons.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="HuHq";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		(pxArc^) << m_bEquipped;
		var int i,iC=m_avAddonOffsets.NumEntries();
		(pxArc^) << iC;
		for(i=0) cond(i<iC) iter(i++)do
			(pxArc^) << m_avAddonOffsets[i];
		endfor;
		m_xAddons.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		if(m_bBuildingReady)then
			var string sTribe=GetTribeName();
			if(m_xTechTree.GetValueI("Objects/"+sTribe+"/InventObjects/final_stage/invented",0)!=0)then
				BuildAddons();
			endif;
		endif;
	endproc;

	export proc void OnTechTreeChange(ref CStringArray p_rasChanges)
		super.OnTechTreeChange(p_rasChanges);
		var int i,iC=p_rasChanges.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(p_rasChanges[i].Find("InventObjects/age_")!=-1)then
				//CheckAge();
			elseif(p_rasChanges[i].Find("InventObjects/final_stage")!=-1)then
				//CheckAge();
				BuildAddons();
			endif;
		endfor;
	endproc;
	
	proc void BuildAddons()
		if(!m_bEquipped)then
			m_bEquipped=true;
			var CFourCC xLink="NOPE";
			var ^CMirageDeco pxA;
			m_avAddonOffsets.AddEntry({-0.5,11.0,0.0});
			m_avAddonOffsets.AddEntry({-5.38,2.74,0.0});
			var int i, iC=m_avAddonOffsets.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				pxA=cast<CMirageDeco>(CSrvWrap.GetObjMgr()^.CreateObj("hu_final_stage_deco_"+i.ToString(),GetOwner(),GetPos(),GetRotation()));
				if(pxA!=null)then
					m_xAddons.AddEntry(pxA^.GetHandle());
					AddGroupedChildren(pxA^.GetGuid());
					pxA^.LinkAction(GetHandle(),xLink,m_avAddonOffsets[i]);
				endif;
			endfor;
		endif;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		var CFourCC xLink="NOPE";
		var int i, iC=m_xAddons.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CGameObj pxA=m_xAddons[i].GetObj();
			if(pxA!=null)then
				pxA^.LinkAction(GetHandle(),xLink,m_avAddonOffsets[i]);
			endif;
		endfor;
	endproc;

	export proc void TransferLinkedObjs(CObjHndl p_xC)
		if(!p_xC.IsValid())then return; endif;
		var CFourCC xLink="NOPE";
		while(m_xAddons.NumEntries()>0)do
			var ^CGameObj pxA = m_xAddons[0].GetObj();
			if(pxA==null)then
				m_xAddons.DeleteEntry(0);
				m_avAddonOffsets.DeleteEntry(0);
				continue;
			endif;
			RemGroupedChildren(pxA^.GetGuid());
			pxA^.TerminateAction();
			pxA^.LinkAction(p_xC,xLink,m_avAddonOffsets[0]);
			m_xAddons.DeleteEntry(0);
			m_avAddonOffsets.DeleteEntry(0);
		endwhile;
		m_xAddons.Clear();
	endproc;
	
	export proc CObjList GetAddons();
		return m_xAddons;
	endproc;
	
endclass;

class CSeasFireplace inherit CFireplace
	var bool			m_bEquipped;
	var CObjList		m_xAddons;
	var array vec3		m_avAddonOffsets;
	
	constructor()
		m_bEquipped=false;
	endconstructor;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="SeHq")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			if(iVersion>=1)then
				(pxArc^) << m_bEquipped;
				var int i,iC;
				(pxArc^) << iC;
				m_avAddonOffsets=iC;
				for(i=0) cond(i<iC) iter(i++)do
					(pxArc^) << m_avAddonOffsets[i];
				endfor;
				m_xAddons.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="SeHq";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		(pxArc^) << m_bEquipped;
		var int i,iC=m_avAddonOffsets.NumEntries();
		(pxArc^) << iC;
		for(i=0) cond(i<iC) iter(i++)do
			(pxArc^) << m_avAddonOffsets[i];
		endfor;
		m_xAddons.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		if(m_bBuildingReady)then
			var string sTribe=GetTribeName();
			if(m_xTechTree.GetValueI("Objects/"+sTribe+"/InventObjects/final_stage/invented",0)!=0)then
				BuildAddons();
			endif;
		endif;
	endproc;

	export proc void OnTechTreeChange(ref CStringArray p_rasChanges)
		super.OnTechTreeChange(p_rasChanges);
		var int i,iC=p_rasChanges.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(p_rasChanges[i].Find("InventObjects/age_")!=-1)then
				//CheckAge();
			elseif(p_rasChanges[i].Find("InventObjects/final_stage")!=-1)then
				//CheckAge();
				BuildAddons();
			endif;
		endfor;
	endproc;
	
	proc void BuildAddons()
		if(!m_bEquipped)then
			m_bEquipped=true;
			var CFourCC xLink="NOPE";
			var ^CMirageDeco pxA;
			m_avAddonOffsets.AddEntry({-3.31,-4.11,-14.06});
			m_avAddonOffsets.AddEntry({-0.05,7.99,-0.52});
			m_avAddonOffsets.AddEntry({0.08,3.98,-0.52});
			m_avAddonOffsets.AddEntry({-8.77,8.71,-3.98});
			var int i, iC=m_avAddonOffsets.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				pxA=cast<CMirageDeco>(CSrvWrap.GetObjMgr()^.CreateObj("seas_final_stage_deco_"+i.ToString(),GetOwner(),GetPos(),GetRotation()));
				if(pxA!=null)then
					m_xAddons.AddEntry(pxA^.GetHandle());
					AddGroupedChildren(pxA^.GetGuid());
					if(i==2)then
						var vec3 vDir=pxA^.GetPos()-GetPos();
						var Quat qRot;
						qRot.FromXYDir(vDir.GetX(),vDir.GetY());
						qRot.RotateZ(Math.Pi());
						pxA^.SecRotAction(qRot,0.01);
					endif;
					pxA^.LinkAction(GetHandle(),xLink,m_avAddonOffsets[i]);
				endif;
			endfor;
		endif;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		var CFourCC xLink="NOPE";
		var int i, iC=m_xAddons.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CGameObj pxA=m_xAddons[i].GetObj();
			if(pxA!=null)then
				if(i==2)then
					var vec3 vDir=pxA^.GetPos()-GetPos();
					var Quat qRot;
					qRot.FromXYDir(vDir.GetX(),vDir.GetY());
					qRot.RotateZ(Math.Pi());
					pxA^.SecRotAction(qRot,0.01);
				endif;
				pxA^.LinkAction(GetHandle(),xLink,m_avAddonOffsets[i]);
			endif;
		endfor;
	endproc;

	export proc void TransferLinkedObjs(CObjHndl p_xC)
		if(!p_xC.IsValid())then return; endif;
		var CFourCC xLink="NOPE";
		while(m_xAddons.NumEntries()>0)do
			var ^CGameObj pxA = m_xAddons[0].GetObj();
			if(pxA==null)then
				m_xAddons.DeleteEntry(0);
				m_avAddonOffsets.DeleteEntry(0);
				continue;
			endif;
			RemGroupedChildren(pxA^.GetGuid());
			pxA^.TerminateAction();
			pxA^.LinkAction(p_xC,xLink,m_avAddonOffsets[0]);
			m_xAddons.DeleteEntry(0);
			m_avAddonOffsets.DeleteEntry(0);
		endwhile;
		m_xAddons.Clear();
	endproc;
	
	export proc CObjList GetAddons();
		return m_xAddons;
	endproc;
	
endclass;

class CNiFireplace inherit CFireplace
	var bool			m_bEquipped;
	var CObjList		m_xAddons;
	var array vec3		m_avAddonOffsets;
	
	constructor()
		m_bEquipped=false;
	endconstructor;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="NiHq")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			if(iVersion>=1)then
				(pxArc^) << m_bEquipped;
				var int i,iC;
				(pxArc^) << iC;
				m_avAddonOffsets=iC;
				for(i=0) cond(i<iC) iter(i++)do
					(pxArc^) << m_avAddonOffsets[i];
				endfor;
				m_xAddons.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="NiHq";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		(pxArc^) << m_bEquipped;
		var int i,iC=m_avAddonOffsets.NumEntries();
		(pxArc^) << iC;
		for(i=0) cond(i<iC) iter(i++)do
			(pxArc^) << m_avAddonOffsets[i];
		endfor;
		m_xAddons.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		if(m_bBuildingReady)then
			var string sTribe=GetTribeName();
			if(m_xTechTree.GetValueI("Objects/"+sTribe+"/InventObjects/final_stage/invented",0)!=0)then
				BuildAddons();
			endif;
		endif;
	endproc;

	export proc void OnTechTreeChange(ref CStringArray p_rasChanges)
		super.OnTechTreeChange(p_rasChanges);
		var int i,iC=p_rasChanges.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(p_rasChanges[i].Find("InventObjects/age_")!=-1)then
				//CheckAge();
			elseif(p_rasChanges[i].Find("InventObjects/final_stage")!=-1)then
				//CheckAge();
				BuildAddons();
			endif;
		endfor;
	endproc;
	
	proc bool UpdateDestructionFlags()
		if(((GetHitpoints()!=0.0f)&&(GetMaxHitpoints()!=0.0f)))then
			var real fPercentage=GetHitpoints()/(GetMaxHitpoints()/100.0f);
			var int i, iC=m_xAddons.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				if(m_xAddons[i].IsValid())then
					var ^CGameObj pxPart=m_xAddons[i].GetObj();
					if(pxPart==null)then continue; endif;
					if(fPercentage>50.0f)then
						pxPart^.SetDestructLevel(0);
					elseif(fPercentage>25.0f)then
						if(pxPart^.GetDestructLevel()!=1)then
							pxPart^.SetDestructLevel(1);
						endif;
					elseif(pxPart^.GetDestructLevel()!=2)then
						pxPart^.SetDestructLevel(2);
					endif;
				endif;
			endfor;
		endif;
		return super.UpdateDestructionFlags();
	endproc;
	
	proc void BuildAddons()
		if(!m_bEquipped)then
			m_bEquipped=true;
			var CFourCC xLink="NOPE";
			var ^CMirageDeco pxA;
			m_avAddonOffsets.AddEntry({-7.35,-7.86,-2.9});
			m_avAddonOffsets.AddEntry({6.36,-7.94,-2.9});
			var int i, iC=m_avAddonOffsets.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				pxA=cast<CMirageDeco>(CSrvWrap.GetObjMgr()^.CreateObj("ninigi_final_stage_deco_"+i.ToString(),GetOwner(),GetPos(),GetRotation()));
				if(pxA!=null)then
					m_xAddons.AddEntry(pxA^.GetHandle());
					AddGroupedChildren(pxA^.GetGuid());
					var vec3 vDir=pxA^.GetPos()-GetPos();
					var Quat qRot;
					qRot.FromXYDir(vDir.GetX(),vDir.GetY());
					if(i==0)then
						qRot.RotateZ(Math.Pi());
					else
						qRot.RotateZ(Math.Pihalf());
					endif;
					pxA^.SecRotAction(qRot,0.01);
					pxA^.LinkAction(GetHandle(),xLink,m_avAddonOffsets[i]);
				endif;
			endfor;
		endif;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		var CFourCC xLink="NOPE";
		var int i, iC=m_xAddons.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CGameObj pxA=m_xAddons[i].GetObj();
			if(pxA!=null)then
				if(i==2)then
					var vec3 vDir=pxA^.GetPos()-GetPos();
					var Quat qRot;
					qRot.FromXYDir(vDir.GetX(),vDir.GetY());
					qRot.RotateZ(Math.Pi());
					pxA^.SecRotAction(qRot,0.01);
				endif;
				pxA^.LinkAction(GetHandle(),xLink,m_avAddonOffsets[i]);
			endif;
		endfor;
	endproc;

	export proc void TransferLinkedObjs(CObjHndl p_xC)
		if(!p_xC.IsValid())then return; endif;
		var CFourCC xLink="NOPE";
		while(m_xAddons.NumEntries()>0)do
			var ^CGameObj pxA = m_xAddons[0].GetObj();
			if(pxA==null)then
				m_xAddons.DeleteEntry(0);
				m_avAddonOffsets.DeleteEntry(0);
				continue;
			endif;
			RemGroupedChildren(pxA^.GetGuid());
			pxA^.TerminateAction();
			pxA^.LinkAction(p_xC,xLink,m_avAddonOffsets[0]);
			m_xAddons.DeleteEntry(0);
			m_avAddonOffsets.DeleteEntry(0);
		endwhile;
		m_xAddons.Clear();
	endproc;
	
	export proc CObjList GetAddons();
		return m_xAddons;
	endproc;
	
endclass;































class CNonInventGrill inherit CBuilding
	
	var CObjHndl 	m_xLight;
	
	constructor()
	endconstructor;
	
	destructor()
	enddestructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetRallySite(true);
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		UpdateDeliveries();
/*		SetStoneDelivery(true);
		SetWoodDelivery(true);
		SetFoodDelivery(true);
		SetIronDelivery(true);
		SetResinDelivery(true);
		SetBoneDelivery(true);
		SetHideDelivery(true);
*/	endproc;

endclass;

class CTemple inherit CBuilding
	
	var CObjHndl m_xTeslaM;
	var CObjHndl m_xEffect;
	
	export proc void OnInit(bool p_bLoad)
		m_bHealthBuilding=true;
		m_bManaBuilding=true;
		super.OnInit(p_bLoad);
		SetRallySite(true);
		// overwrite types in objquery used for healing
		m_xFunctionUnits.SetType("CHTR");											// ... this are Characters ...
		m_xFunctionUnits.SetType("ANML",true);										// ... this are Animals ...
		m_xFunctionUnits.SetType("VHCL",true);										// ... this are Vehicles ...
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="Templ")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xEffect.DoKArc(pxArc^);
			if(p_pxReaderNode^.GetVersion()>=2)then
				m_xTeslaM.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="Templ";
		var int iVersion=2;
		if(CMirageSrvMgr.SDK())then
			iVersion=1;
		endif;
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,iVersion);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xEffect.DoKArc(pxArc^);
		if(iVersion>=2)then
			m_xTeslaM.DoKArc(pxArc^);
		endif;
		pxWalk^.Close();
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		if(!m_xEffect.IsValid()&&GetClassName()!="hu_magic_cauldron")then
			m_xEffect=AddFX("fx_heal_area",-1.0);
			AddRangedBuff("owner_healing_temple");
		endif;
		var CFourCC xLink;
		if(m_xEffect.IsValid())then
			m_xEffect.GetObj()^.LinkAction(GetHandle(),xLink);
		endif;
		var ^CVirtualProduceUnit pxUnit=cast<CVirtualProduceUnit>(m_xReactor.GetObj());
		if(pxUnit!=null)then
			pxUnit^.SetReady();
		endif;
		pxUnit=cast<CVirtualProduceUnit>(m_xProduceUnit.GetObj());
		if(pxUnit!=null)then
			pxUnit^.SetReady();
		endif;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		var ^CVirtualProduceUnit pxReactor=cast<CVirtualProduceUnit>(GetReactor().GetObj());
		if(pxReactor==null)then
			return super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("/Build/ANML/seas")!=-1||p_sMiscParams.Find("/Build/CHTR/seas")!=-1||p_sMiscParams.Find("/Build/VHCL/seas")!=-1/*||p_sMiscParams.Find("/Upgrades/seas")!=-1*/)then
				if(p_bS)then
					pxReactor^.ActionReactored(p_sMiscParams);
					ActionVPU(p_sMiscParams);
				elseif(GetPQENO() >= GetPQENR() && pxReactor^.IsReady())then
					pxReactor^.ActionReactored(p_sMiscParams);
				else
					ActionVPU(p_sMiscParams);
				endif;
			elseif(p_sMiscParams.Find("/Upgrades/seas")!=-1)then
				ActionVPU(p_sMiscParams);
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		elseif(p_sCommand=="Cancel")then
			CancelAction(p_sMiscParams, p_bS);
//			return;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	export proc bool UpdateGfx()
		var bool bReturn=super.UpdateGfx();
		if(GetClassName()=="seas_laboratory" && !m_xReactor.IsValid())then
			if(m_xTechTree.GetValueB("/Objects/SEAS/InventObjects/"+GetClassName()+"_reactor/invented",false))then
//			if(m_xTechTree.GetValueB("/Objects/SEAS/InventObjects/virtual_reactor/invented",true))then
				if(!m_xProduceUnit.IsValid())then
					CreatePersonalProduceUnit(m_bBuildingReady);
				endif;
				CreateReactor(m_bBuildingReady);
			endif;
		endif;
		return true;
	endproc;
	
	export proc bool StornoLast()
		var ^CVirtualProduceUnit pxReactor=null;
		if(m_xReactor.IsValid())then
			pxReactor=cast<CVirtualProduceUnit>(m_xReactor.GetObj());
		endif;
		if(GetPQENR() > GetPQENO())then
			if(pxReactor==null||!pxReactor^.StornoLast())then
				return super.StornoLast();
			else
				return true;
			endif;
		else
			return super.StornoLast();
		endif;
	endproc;
	
	export proc void ActionVPU(string p_sTTPath)
		var ^CVirtualProduceUnit pxProduceUnit=cast<CVirtualProduceUnit>(GetProduceUnit().GetObj());
		if(pxProduceUnit==null)then
			super.Action(p_sTTPath);
		else
			pxProduceUnit^.Action(p_sTTPath);
		endif;
	endproc;
	
	export proc void CancelAction(string p_sTTPath)
		if(m_xReactor.IsValid())then
			var ^CVirtualProduceUnit pxProduceUnit=cast<CVirtualProduceUnit>(GetProduceUnit().GetObj());
			if(pxProduceUnit==null||!pxProduceUnit^.HasCanceledAction(p_sTTPath))then
				if(m_pxTaskMgr!=null)then
					m_pxTaskMgr^.RemoveAction(p_sTTPath);
				endif;
			endif;
			return;
		else
			return super.CancelAction(p_sTTPath);
		endif;
	endproc;
	
	export proc void CancelAction(string p_sTTPath, bool p_bShift)
		var ^CVirtualProduceUnit pxReactor=null;
//		var bool bRCA=false;
		if(m_xReactor.IsValid())then
			pxReactor=cast<CVirtualProduceUnit>(m_xReactor.GetObj());
			if(pxReactor!=null)then
				if(p_bShift)then
					pxReactor^.CancelAction(p_sTTPath);
					CancelAction(p_sTTPath);
					return;
				elseif(GetPQENR() > GetPQENO())then
					if(pxReactor^.HasCanceledAction(p_sTTPath))then
						return;
					endif;
				endif;
			endif;
		endif;
		if(!HasCanceledAction(p_sTTPath) && pxReactor!=null)then
			pxReactor^.CancelAction(p_sTTPath);
		endif;
	endproc;
	
	export proc void CheckTeslaMachine(CObjHndl p_xRally)
		var string sClass=GetClassName();
//		if(sClass!="seas_laboratory")then m_xTeslaM=CObjHndl.Invalid(); return; endif;
		if(p_xRally.IsValid())then
			var ^CTeslaMachine pxM=cast<CTeslaMachine>(p_xRally.GetObj());
			if(pxM==null)then m_xTeslaM=CObjHndl.Invalid(); return; endif;
//			if(pxM^.GetOwner()!=GetOwner()/*||!pxM^.IsReady()*/)then m_xTeslaM=CObjHndl.Invalid(); return; endif;
			if(!CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxM^.GetOwner(), GetOwner())||!CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxM^.GetOwner())||!pxM^.IsReady())then m_xTeslaM=CObjHndl.Invalid(); return; endif;
			m_xTeslaM=pxM^.GetHandle();
		else
			m_xTeslaM=CObjHndl.Invalid();
		endif;
	endproc;
	
	export proc CObjHndl GetSpawnPos(ref vec3 p_rvPos,ref vec3 p_rvRot)
		if(m_xTeslaM.IsValid()&&m_xTeslaM.GetObj()^.GetConstructLevel()>=4)then
			p_rvPos=m_xTeslaM.GetObj()^.GetPos()+({0.0,1.0,0.0}*m_xTeslaM.GetObj()^.GetRadius());
			p_rvRot=m_xTeslaM.GetObj()^.GetRotation();
			return m_xTeslaM;
		endif;
		return CObjHndl.Invalid();
	endproc;
	
endclass;

class CNPCSeller inherit CBuilding
	
	var CObjHndl m_xTeslaM;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="NPCS")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			if(p_pxReaderNode^.GetVersion()>=1)then
				m_xTeslaM.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		if(!CMirageSrvMgr.SDK())then
			var CFourCC xBase="NPCS";
			var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
			var ^CArc pxArc=^(pxWalk^.GetArc());
			m_xTeslaM.DoKArc(pxArc^);
			pxWalk^.Close();
		endif;
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
	
		if(!p_bLoad)then
			var ^CAttribs pxAttr=GetAttribs();
			if(pxAttr!=null)then
				pxAttr^.SetValue("NPCSeller",true);
			endif;
		endif;
		if(m_xTechTree.GetValueS(GetObjPath()+"/gfx","")=="hc_taverne")then
			if(!IsVisInFOW())then SetVisInFOW(true); endif;
			//if(!GetHideMiniMap())then SetHideMiniMap(true); endif;	//SetHideMiniMap not working with BLDG type objects
		endif;
		SetRallySite(true);
	endproc;

	export proc void CheckTeslaMachine(CObjHndl p_xRally)
		var string sClass=GetClassName();
//		if(sClass!="seas_pub")then m_xTeslaM=CObjHndl.Invalid(); return; endif;
		if(p_xRally.IsValid())then
			var ^CTeslaMachine pxM=cast<CTeslaMachine>(p_xRally.GetObj());
			if(pxM==null)then m_xTeslaM=CObjHndl.Invalid(); return; endif;
//			if(pxM^.GetOwner()!=GetOwner()||!pxM^.IsReady())then m_xTeslaM=CObjHndl.Invalid(); return; endif;
			if(!CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxM^.GetOwner(), GetOwner())||!CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxM^.GetOwner())||!pxM^.IsReady())then m_xTeslaM=CObjHndl.Invalid(); return; endif;
			m_xTeslaM=pxM^.GetHandle();
		else
			m_xTeslaM=CObjHndl.Invalid();
		endif;
	endproc;
	
	export proc CObjHndl GetSpawnPos(ref vec3 p_rvPos,ref vec3 p_rvRot)
		if(m_xTeslaM.IsValid()&&m_xTeslaM.GetObj()^.GetConstructLevel()>=4)then
			p_rvPos=m_xTeslaM.GetObj()^.GetPos()+({0.0,1.0,0.0}*m_xTeslaM.GetObj()^.GetRadius());
			p_rvRot=m_xTeslaM.GetObj()^.GetRotation();
			return m_xTeslaM;
		endif;
		return CObjHndl.Invalid();
	endproc;
	
/*	proc void RecruitNPC(string p_sNPCClass)
	
		var string sNPCClass=p_sNPCClass.Mid(p_sNPCClass.FindRev('/')+1);
	
		var ^CTechTree.CNode pxBuildAction=m_xTechTree.FindNode(p_sNPCClass);
		if(pxBuildAction==null)then return; endif;
	
		var ^CTechTree.CNode pxResults=pxBuildAction^.GetSub("results");
		if(pxResults==null)then return; endif;
	
		var int i, iC=pxResults^.NumSubs();
		var string sTTDesc;
		for(i=0)cond(i<iC)iter(i++)do
			var string sResult=pxResults^.GetSubValue(i);
			var ^CTechTree.CNode pxObject=m_xTechTree.FindNode(sResult);
			if(pxObject==null)then continue; endif;
			sNPCClass=pxObject^.GetName();
			sTTDesc=pxObject^.GetSubValue("description",sNPCClass);
		endfor;
	
		var bool bFree=CNPCMgr.Get().IsAbleToBuyNPC(GetOwner(),sNPCClass);
		if(!bFree)then
			CFeedback.Print(GetOwner(), CFeedback.SYSTEM,"_NT_BldgFailNPCAlreadyHired\t"+sTTDesc);
		endif;
		var CObjHndl xPyCO;
		if(bFree && CRequirementsMgr.Get().CheckConditionsAndPay(this, p_sNPCClass, xPyCO))then
	
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return; endif;
			var ^CPlayer pxPlayer=pxLevel^.GetPlayer(GetOwner());
			if(pxPlayer==null)then return; endif;
			var ^CAttribs pxPlayerAttr=pxPlayer^.GetAttribs();			if(pxPlayerAttr==null)then return; endif;
	
			pxPlayerAttr^.SetValue("virtual_units_"+sNPCClass.GetAt(sNPCClass.GetLength()-1).ToString(), pxPlayerAttr^.GetValueInt("virtual_units_"+sNPCClass.GetAt(sNPCClass.GetLength()-1).ToString())-1);
	
			var	vec3		vPos=GetPos();
			var CFourCC		xProduct="Spwn";
			GetLinkPosWorld(xProduct,vPos);
	
			if(HasAnim("open_gate"))then
				InvokeGenericSCEvent(24,4.0f);
			endif;
	
			if(sNPCClass=="Stina_s0")then
				var ^CFightingObj pxHero=cast<CFightingObj>(CSrvWrap.GetObjMgr()^.CreateObj("special_eusmilus",GetOwner(),vPos));
				if(pxHero!=null)then
					var CGameEvtPtr xEvt=CGameEvtPtr.CreateEvent("CTheLite");
					xEvt.SetObjHandle(0,GetHandle());
					pxHero^.HandleEvent(xEvt);
				endif;
			else
				var ^CFightingObj pxHero=cast<CFightingObj>(CSrvWrap.GetObjMgr()^.CreateObj(sNPCClass,GetOwner(),vPos));
				if(pxHero!=null)then
					var CGameEvtPtr xEvt=CGameEvtPtr.CreateEvent("CTheLite");
					xEvt.SetObjHandle(0,GetHandle());
					pxHero^.HandleEvent(xEvt);
				endif;
			endif;
	
			OnWorkFinished();
			//CreatChar
		endif;
		if(xPyCO.IsValid())then
			CSrvWrap.GetObjMgr()^.DeleteObject(xPyCO.GetObj());
		endif;
	endproc;
*/
endclass;

/*?
	?group 	URS.Scripts.Server.Classes
	?item 	CRecruitPool
	?desc 	This class represents a global Pool of Characters.
			Every Player can access this Pool through Taverns and recruit
			Characters. If a Character was recruited, he will be removed
			from this Pool, so that he disappears in all Tavern of all
			Players.
			The RecruitPool is implemented as a Singleton and holds the
			Data of the Characters currently available. If the Data changes
			the CRecruitPool writes the new Data as strings into the GameAttribs,
			which are accessible to the client.
	?prefix CRecruitPool
?*/
class CRecruitPool
	/*?
	?group 	URS.Scripts.Server.Classes.CRecruitPool
	?item 	CRecruit
	?desc	This class describes a Character. It holds all Data
			needed to generate a CCharacter from this.
	?prefix	CRecruit
	?*/
	class CRecruit
		export var string	m_sCharClassname;			// Name of the Character 		( ex. "Hu_F_Nature_s1"	)
		export var string	m_sCharCaste;				// Caste of the Character		( "nat", "tec", "res"	)
		export var string	m_sCharRace;					// Race of the Character		( "Hu",  "Aje", "Ninigi")
		export var bool 	m_bCharMale;					// Gender of the Character		( true==male / false=female )
		export var int		m_iCharLevel;					// Level of the Character		( 0 - 4 )
	
		export var int		m_iWoodCost;					// Specifies how many Wood - Units it costs to recruit this one
		export var int		m_iFoodCost;					// Specifies how many Food - Units it costs to recruit this one
		export var int		m_iStoneCost;				// Specifies how many Stone- Units it costs to recruit this one
	endclass;
	
	static var ^CRecruitPool ms_pxInstance;				// one and only Instance of this Class
	var array ^CRecruit	 m_apxPool;					// an Array holding the available Chars in the Pool
	
	constructor()
		UpdateGameAttribs();
	endconstructor;
	
	destructor()
		// free the allocated Memory
		if(m_apxPool.NumEntries()!=0)then
			var int i;
			for (i=0) cond (i<m_apxPool.NumEntries()) iter (i++)do
				delete m_apxPool[i];
			endfor;
	
		endif;
	enddestructor;
/*?
	?item 	Get(void)
	?desc	returns the Singleton-Instance as Reference
	?return Reference to the Singleton-Instance
?*/
	export static proc ref CRecruitPool Get()
		if( ms_pxInstance==null )then					// check if there is an Instance
			// if there is no Instance ...
			ms_pxInstance=new CRecruitPool();			// create one
	
			// Create a Timer for the adding of New Chars
			// Each time this Timer ticks a new random Char is added to the Pool
			// REMARK: This Timer is not in the CRecruitPool Class. It's a static Variable in the CHuTavern
			// 			Class.
			CHuTavern.ms_iTimer=CTimeMgr.Get().CreateTimer(CGameTimeSpan.OneSecond() * 120.0 , true);
			CTimeMgr.Get().GetTimer(CHuTavern.ms_iTimer)^.SetEventTemplate(CGameEvtPtr.CreateStringEvent("Timer", "AddChar"));
		endif;
	
		return (ms_pxInstance^);						// returns the Instance
	endproc;

/*?
	?item	ShutStatic(void)
	?desc	Static Method to free the Memory used by the Singleton-Instance
?*/
	export static proc void ShutStatic()
		CTimeMgr.Get().DeleteTimer(CHuTavern.ms_iTimer);	// the Timer have to by deleted ...
		delete ms_pxInstance;							// ... and the Instance too
	endproc;

/*?
	?item 	UpdateGameAttribs(void)
	?desc 	This Method Updates the GameAttribs
			It writes the Data about the available Characters in the Pool in the GameAttribs
			whick can be accessed by the client.
?*/
	proc void UpdateGameAttribs()
	
		var int i;										// loop counter
	
		// Loop through the 8 Slots
		for (i=0) cond (i<8 ) iter (i++)do
			if( i >= m_apxPool.NumEntries() )then		// is there an Entry for Slot No. 'i' in the Pool
				// ... if no, then create the "none" String to singnalize an empty Slot
				var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
				pxLevel^.GetLevelInfo().GetAttribs().SetValue("TavernSlot_"+(i+1).ToString(), "none");
			else
				// ... if there is an Entry ...
				// ... create a String with all Informations. This String then is written to the
				// GameAttribs and can be used by the Client to display what Characters are available
	
				var string sCaste;
				if(m_apxPool[i]^.m_sCharCaste=="nat")then
					sCaste="Nature";
				elseif(m_apxPool[i]^.m_sCharCaste=="res")then
					sCaste="Resource";
				else
					sCaste="Technics";
				endif;
	
				var string sTooltip=m_apxPool[i]^.m_sCharClassname+"\nVolk:  "+m_apxPool[i]^.m_sCharRace+"\nCaste:  "+sCaste;
				if(m_apxPool[i]^.m_bCharMale==true )then sTooltip += "\nGeschlecht: Männlich"; else sTooltip += "\nGeschlecht: Weiblich"; endif;
				sTooltip += "\nLevel:  "+m_apxPool[i]^.m_iCharLevel.ToString();
				sTooltip += "\nKosten: W:"+m_apxPool[i]^.m_iWoodCost.ToString()+"	F:"+m_apxPool[i]^.m_iFoodCost.ToString();
				sTooltip += "	S:"+m_apxPool[i]^.m_iStoneCost.ToString()+"\n";
	
				// Write the created String to GameAttribs
				var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
				pxLevel^.GetLevelInfo().GetAttribs().SetValue("TavernSlot_"+(i+1).ToString(), sTooltip);
			endif;
		endfor;
	endproc;

/*?
	?item	AddRandomChar(void)
	?desc	This is used to Add a new randomly generated Character to the Pool
			If the Pool is full, the Method returns immediatly
?*/
	export proc void AddRandomChar()
	
		if(m_apxPool.NumEntries() >= 8)then
			// Returns if the Pool is full
			return;
		endif;
	
		var ^CRecruit pxRecr=new CRecruit();			// Creates a new CRecruit - Instance
	
		var int iLevel 	= Random.GetInt() % 3;			// generates a Random Level
		var int iRace	= Random.GetInt() % 3;			// generates a Random Race-ID
		var int iCaste =Random.GetInt() % 3;			// generates a Random Caste-ID
	
		var string sRace, sCaste, sName, sGender;			// Strings to hold the Character Informations
		var bool	bMale;

// HACK
		iRace=0;									// This Hack sets the Character-Race always to Hu.
// ENDHACK
	
		// Craete the right Strings from the generated IDs
		if((Random.GetInt() % 2)==0 )then	 bMale=false; sGender="F"; else bMale=true; sGender="M"; endif;
		if(iRace==0)then sRace="Hu"; elseif(iRace==1)then sRace="Aje"; else sRace="Ninigi"; endif;
		if(iCaste==0)then sCaste="Nature"; elseif(iCaste==1)then sCaste="Resource"; else sCaste="Technics"; endif;
	
		// Build a Classname from them
		sName=sRace+"_"+sGender+"_"+ sCaste+"_s"+iLevel.ToString();
	
		// This is an Array with the cost for Characters of
		// a given Level
	
		var array int aiCosts;
		aiCosts.AddEntry(50);
		aiCosts.AddEntry(150);
		aiCosts.AddEntry(300);
		aiCosts.AddEntry(500);
		aiCosts.AddEntry(1000);
	
		// Writes the Cost-Values to the Structure
		pxRecr^.m_iWoodCost 		= aiCosts[iLevel]/2;
		pxRecr^.m_iFoodCost 		= aiCosts[iLevel];
		pxRecr^.m_iStoneCost		= aiCosts[iLevel]/2;
		pxRecr^.m_sCharClassname	= sName;
	
		// Creates the Caste-Strings
		if(sCaste=="Nature")then			pxRecr^.m_sCharCaste	= "nat";
		elseif(sCaste=="Resource")then 	pxRecr^.m_sCharCaste 	= "res";
		else								pxRecr^.m_sCharCaste	= "tec";
	endif;
	
		// Writes the Values to the Structure
		pxRecr^.m_sCharRace	= sRace;
		pxRecr^.m_bCharMale	= bMale;
		pxRecr^.m_iCharLevel= iLevel;
	
		m_apxPool.AddEntry(pxRecr);					// Add this Character to the Pool
	
		// ... and updates the GameAttribs
		UpdateGameAttribs();
	endproc;

/*?
	?item	RecruitCharacter(^CGameObj p_pxObj, int p_iSlot)
	?desc 	This is called, when an Tavern recieves the "Recruit" - GameplayCommand
			This Method checks if it is possible for the Player to recruit this Character and
			returns true, it it is, or false if the Resourceamount is too low, or the Units-Count
			to high
	?param	p_pxObj		Pointer to the Tavern-Object
	?param	p_iSlot		Number of the Slot where the Character is
	?return	true		if the recruition of the Character gpceeded, else false
?*/
	export proc bool RecruitCharacter(^CGameObj p_pxObj, int p_iSlot)
		if( p_iSlot<0||p_iSlot >= m_apxPool.NumEntries() )then
			// if the given Slot is invalid return
			return false;
		endif;
	
		// Gets the Player Attributes
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		var ^CAttribs pxAttr=pxLevel^.GetPlayer(p_pxObj^.GetOwner())^.GetAttribs();
	
		if(pxAttr==null)then							// Check if it is a valid Pointer ...
			// ... returns if it is invalid
			CSrvWrap.LogError("RecruitPool","Could not get Attribs of Player "+p_pxObj^.GetOwner().ToString());
			return false;
		endif;
	
		// Checks the Ressources and Units Count ...
		if( pxAttr^.GetValueInt("wood") <= m_apxPool[p_iSlot]^.m_iWoodCost  ||
			pxAttr^.GetValueInt("food") <= m_apxPool[p_iSlot]^.m_iFoodCost  ||
			pxAttr^.GetValueInt("stone")<= m_apxPool[p_iSlot]^.m_iStoneCost ||
			pxAttr^.GetValueInt("units")+pxAttr^.GetValueInt("virtual_units") >= pxAttr^.GetValueInt("max_units") )then
				//L CSrvWrap.LogInfo("RecruitPool","Cannot recruit the Character.");
				// ... and returns false if it isn't possible to recruit this Character
				return false;
		endif;
	
		// If we are here, it is possible to recruit this Character
		// Removes the Ressource-Cost from the Player
//L		KLog.LogInfo( "DaHo", "CRecruit::RecruitCharacter() needs sample point" );
		pxAttr^.SetValue("wood", pxAttr^.GetValueInt("wood")- m_apxPool[p_iSlot]^.m_iWoodCost);
		pxAttr^.SetValue("food", pxAttr^.GetValueInt("food")- m_apxPool[p_iSlot]^.m_iFoodCost);
		pxAttr^.SetValue("stone", pxAttr^.GetValueInt("stone")- m_apxPool[p_iSlot]^.m_iStoneCost);
		// Adds a Unit to the Unit-Counter
		pxAttr^.SetValue("virtual_units", pxAttr^.GetValueInt("virtual_units") +1);
	
		// Creates a new Object
		var ^CGameObj pxObj=CSrvWrap.GetObjMgr()^.CreateObj(m_apxPool[p_iSlot]^.m_sCharClassname, p_pxObj^.GetOwner(), p_pxObj^.GetPos());
		if(pxObj==null)then		// Checks if it is valid ...
			// ... returns if it's not.
			CSrvWrap.LogError("RecruitPool","Object not created.");
			return false;
		endif;
	
		var ^CCharacter pxChar=cast<CCharacter>(pxObj);		// Casts the Object to a CCharacter ...
		if(pxChar==null)then									// ... checks if the CCharcter-Pointer is valid ...
			// ... returns if it isn't.
			CSrvWrap.LogError("RecruitPool","Cast failed.");
			return false;
		endif;
	
		// Set the craeted Char to the Values specified by the CRecruit
		pxChar^.SetCaste(m_apxPool[p_iSlot]^.m_sCharCaste);
		pxChar^.SetLevelClean(m_apxPool[p_iSlot]^.m_iCharLevel);
		//pxChar^.GetBorn(p_pxObj^.GetHandle());
	
		// Remove the recruited Char from the Pool
		CRecruitPool.Get().RemoveCharFromSlot(p_iSlot);
	
		return true;											// YIPPIE!! We're lucky ;)
	endproc;

/*?
	?item 	RemoveCharFromPool(int p_iSlot)
	?desc 	Removes a Character from the Pool
	?param	p_iSlot			Number of the Slot, which have to be cleared
?*/
	proc void RemoveCharFromSlot(int p_iSlot)
		if(p_iSlot<0||p_iSlot >= m_apxPool.NumEntries() )then	// Checks if the given Slot is valid ...
			return;											// ... returns if it isn't.
		endif;
	
		delete m_apxPool[p_iSlot];								// Free the allocated Heap ...
		m_apxPool.DeleteEntry(p_iSlot);							// ... delete the Array Entry ....
		UpdateGameAttribs();									// ... and update the GameAttribs.
	endproc;

endclass;

/*?
	?group 	URS.Scripts.Server.Classes
	?item 	CHuTavern
	?desc	Describes the Tavern and is inherited from CBuilding.
			The Tavern has a static Timer, which controlls the AddChar-Behaviour. ( The TimeSpan
			until a new Char is generated ).
			The Tavern checks in the OnInit()-Method if there is any Timer Subscribed. If there isn't
			one will be Subscribed. In the Destructor the Timer will be Unsubscribed. So we make sure
			that there is always only one AddChar-Timer, even if there are many Taverns in the Map.
	?prefix	CHuTavern
	?*/
class CHuTavern inherit CBuilding
	
	export static var int ms_iTimer;								// Static Timer-ID to hold the AddChar-Timer of the CRecruitPool
	var ^CGameEvtQueue m_pxQueue;							// A Pointer to the EventQueue
	
	export destructor()
		if(m_pxQueue!=null)then
			// Unsubscribes the Timer if there is Data in the EventQueue - Pointer
			CTimeMgr.Get().GetTimer(ms_iTimer)^.Unsubscribe(m_pxQueue);
		endif;
	enddestructor;
	
	export constructor()
	
	endconstructor;

/*?
		?item	OnInit(bool p_bLoad)
		?desc	This is the initializing Method.
		?param	p_bLoad			true if the Data have to be load, else false
?*/
	export proc void OnInit(bool p_bLoad)
		CRecruitPool.Get();		// this call is needed to make sure that the timer is initialized
	
		super.OnInit(p_bLoad);											// Calls the OnInit()-Method of the Superclass ( CBuilding )
	
		m_pxQueue=GetEvents();										// Initielize the EventQueue-Pointer
	
		if(CTimeMgr.Get().GetTimer(ms_iTimer)^.NumSubscribers() <= 0 )then	 // Check if the Count of Subscribers are at Zero ...
			if(m_pxQueue==null)then
				//L CSrvWrap.LogInfo("Building.Tavern","m_pxQueue==NULL");
			else
				// ... if it is, then Subscribe the Timer
				CTimeMgr.Get().GetTimer(ms_iTimer)^.Subscribe(m_pxQueue);
			endif;
		endif;
		SetRallySite(true);
	
	endproc;

/*?
	?item 	HandleGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams )
	?desc 	This Method Handles the recieved GamePlayCommands.
	?param	p_sCommand		a string describing the Command
	?param	p_pxObject		a possibility to pass a CGameObj to this Function
	?param	p_vPos			a possibility to pass a Position to this Function
	?param	p_sMiscParam	a string containing whatever you want and need
?*/
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		// If p_sCommand is "Recruit", then the wanted SlotNumber mußt be in p_sMiscParams
		if( p_sCommand=="Recruit" )then
			// Handles the Recruit-Command
			CRecruitPool.Get().RecruitCharacter(this, p_sMiscParams.ToInt() );
		else
			// Gives the Command up to the superclass ( in this case CBuilding )
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;

/*?
	?item	HandleEvent(ref CGameEvtPtr	p_rxEvtPtr)
	?desc	Handles the incoming Events
	?param	p_rxEvtPtr		Refernece to the incoming Event to Handle
?*/
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		// then check if it is our AddChar-Timer from the CRecruitPool
		if(p_rxEvtPtr.GetClass().ToString()=="Timer")then
			if(p_rxEvtPtr.GetString()=="AddChar")then
				//L CSrvWrap.LogInfo("Building.Tavern","Timer tickt");
				// If we are here, then the AddChar-Timer has ticked ...
				CRecruitPool.Get().AddRandomChar();						// ... and we have to add a new Random Character
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	
		// Here we perform a check, if there is any AddChar-Timer Subscribed ...
		if(CTimeMgr.Get().GetTimer(ms_iTimer)^.NumSubscribers() <= 0)then
			// ... if no, then do this now.
			CTimeMgr.Get().GetTimer(ms_iTimer)^.Subscribe(m_pxQueue);
		endif;
	endproc;
endclass;

class CLumbermill inherit CBuilding
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		m_bQuickHarvest=true;
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		UpdateDeliveries();
/*		SetWoodDelivery(true);
		SetFoodDelivery(true);
*/	endproc;

endclass;

class CStonemason inherit CBuilding
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		m_bQuickHarvest=true;
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		UpdateDeliveries();
/*		SetStoneDelivery(true);
		SetIronDelivery(true);
*/	endproc;

endclass;

class CHuntingLodge inherit CBuilding
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		m_bQuickHarvest=true;
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		UpdateDeliveries();
/*		SetHideDelivery(true);
		SetFoodDelivery(true);
*/	endproc;

endclass;

class CNinigiLumbermill inherit CBuilding
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		m_bQuickHarvest=true;
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		UpdateDeliveries();
/*		SetWoodDelivery(true);
		SetResinDelivery(true);
*/	endproc;

endclass;

class CNinigi_Dilophosaurus_Nest inherit CBuilding
	
	const real NEST_RADIUS_1 = 70.0f; // the nests territory
	const real NEST_RADIUS_2 = 140.0f; // the nests tolerance zone
	
	var CObjHndl m_xNest;
	var bool m_bNestGrow;
	const real NEST_GROW = 360.0f; // time which after more animal spawns from the nest
	const int NEW_EGGS = 2; // increasement of max spawned animals from the nest
//	var bool m_bTolerated;
	
	export constructor()
		m_bNestGrow=false;
//		m_bTolerated=false;
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="DiNe")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xNest.DoKArc(pxArc^);
			if(p_pxReaderNode^.GetVersion()>=2)then
				(pxArc^) << m_bNestGrow;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		if(!m_bNestGrow)then
			if(HasTimer(NEST_GROW_TIMER))then DeleteTimer(NEST_GROW_TIMER); endif;
			CreateTimer(NEST_GROW_TIMER,CGameTimeSpan.OneSecond()*NEST_GROW,false);
		endif;
		if(m_xNest.IsValid())then return; endif;
		var ^CNest pxNest=cast<CNest>(CSrvWrap.GetObjMgr()^.CreateObj("hu_dilopho_nest_spawn",GetOwner(),GetPos(),GetRotation()));
		if(pxNest!=null)then
			m_xNest=pxNest^.GetHandle();
			AdjustNestAreas(pxNest);
			pxNest^.SetVisible(false);
			var CFourCC xT="NOPE";
			pxNest^.LinkAction(GetHandle(), xT);
		endif;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==NEST_GROW_TIMER)then
				var ^CNest pxN=cast<CNest>(m_xNest.GetObj());
				if(pxN!=null)then
					if(pxN^.ChangeSpawnAmount(NEW_EGGS))then
						m_bNestGrow=true;
					endif;
				else
					DeleteTimer(NEST_GROW_TIMER);
					CreateTimer(NEST_GROW_TIMER,CGameTimeSpan.OneSecond()*NEST_GROW,false);
				endif;
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="DiNe";
		var int iVersion=2;
		if(CMirageSrvMgr.SDK())then
			iVersion=1;
		endif;
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,iVersion);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xNest.DoKArc(pxArc^);
		if(iVersion>=2)then
			(pxArc^) << m_bNestGrow;
		endif;
		pxWalk^.Close();
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		if(!IsBuildMode())then
			SetReady();
		endif;
	endproc;
	
	proc void AdjustNestAreas(^CNest p_pxNest)
		//vE.SetXYZ(10.0f, 10.0f, 0.0f);
		var ^CRegion pxRgn=p_pxNest^.GetActionAreaPtr();
		var vec3 vE; vE.SetXYZ(NEST_RADIUS_1, NEST_RADIUS_1, 0.0f);
		if(pxRgn!=null)then
			pxRgn^.Clear();
			pxRgn^.AddSubRegion(010b, GetPos(), vE);
		endif;
		pxRgn=p_pxNest^.GetSafeAreaPtr();
		if(pxRgn!=null)then
			pxRgn^.Clear();
			pxRgn^.AddSubRegion(010b, GetPos(), vE);
		endif;
		vE.SetXYZ(NEST_RADIUS_2, NEST_RADIUS_2, 0.0f);
		pxRgn=p_pxNest^.GetToleranceAreaForced();
		if(pxRgn!=null)then
			pxRgn^.Clear();
			pxRgn^.AddSubRegion(010b, GetPos(), vE);
		endif;
	endproc;
	
	export proc void Die()
		var ^CNest pxN=cast<CNest>(m_xNest.GetObj());
		if(pxN!=null)then
			pxN^.Die();
		endif;
		super.Die();
	endproc;
	
	export proc string GetReportCode()
		return "defence";
	endproc;
	
endclass;

class CCornfield inherit CGrowingField
	
	export proc bool Register(CObjHndl p_xWorker)
		var bool bRes=super.Register(p_xWorker);
		if(m_xWorker.NumEntries()>0)then
			SetRndInvMaskSingleFlagInv(VIS_FLAG_BLDG_SCARECROW,true);
		endif;
		return(bRes);
	endproc;
	
	export proc bool UnRegister(CObjHndl p_xWorker)
		var bool bRes=super.UnRegister(p_xWorker);
		if(m_xWorker.NumEntries()<=0)then
			SetRndInvMaskSingleFlagInv(VIS_FLAG_BLDG_SCARECROW,false);
		endif;
		return(bRes);
	endproc;
	
endclass;
	
class CGrowingField inherit CUnlimitedBuilding
	
	var int m_iGrowStep;
	
	constructor()
	endconstructor;
	
	destructor()
	enddestructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		m_iGrowStep=0;
		m_bQuickHarvest=true;
		m_iMaxWorker=m_xTechTree.GetValueI(GetObjPath()+"/maxworkers",4);
		SetAttrib("free_worker_slots",m_iMaxWorker.ToString());
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("free_worker_slots",m_iMaxWorker);
		endif;
	endproc;
	
	export proc int GetGrowStep()
		return(m_iGrowStep);
	endproc;
	
	export proc void SetGrowStep(int p_iGrowStep)
		m_iGrowStep=p_iGrowStep;
		if(m_iGrowStep>100)then
			m_iGrowStep=0;
		endif;
	endproc;
	
	export proc void SetPFBlocking()
	endproc;
	
	export proc bool CheckCurResCapacity()
		if(m_sCurRes=="wood")then
			return CheckWoodCapacity();
		else
			return CheckFoodCapacity();
		endif;
	endproc;
	
	export proc bool CurResInvIsFull()
		if(m_sCurRes=="wood")then
			return WoodInvIsFull();
		else
			return FoodInvIsFull();
		endif;
	endproc;
	
	export proc bool CurResInvAdd()
		if(m_sCurRes=="wood")then
			return WoodInvAdd(GetWoodInvSpace());
		else
			return FoodInvAdd(GetFoodInvSpace());
		endif;
	endproc;
	
	export proc void Action(string p_sTTPath)
		if(p_sTTPath.Find("/Upgrades/"+GetClassName())!=-1&&!m_xProduceUnit.IsValid())then
			CreatePersonalProduceUnit(m_bBuildingReady);
		endif;
		var ^CVirtualProduceUnit pxProduceUnit=cast<CVirtualProduceUnit>(GetProduceUnit().GetObj());
		if(pxProduceUnit==null)then
			super.Action(p_sTTPath);
		elseif(!pxProduceUnit^.ActionTowerVPU(p_sTTPath))then
			DeleteVPU();
		endif;
	endproc;
	
	export proc void CancelAction(string p_sTTPath)
		var ^CVirtualProduceUnit pxProduceUnit=cast<CVirtualProduceUnit>(GetProduceUnit().GetObj());
		if(pxProduceUnit==null||!pxProduceUnit^.HasCanceledAction(p_sTTPath))then
			super.CancelAction(p_sTTPath);
		endif;
		DeleteVPU();
	endproc;
	
	export proc bool StornoLast()
		var bool bReturn=super.StornoLast();
		DeleteVPU();
		return bReturn;
	endproc;
	
	export proc void StornoAll()
		super.StornoAll();
		DeleteVPU();
	endproc;
	
	export proc void UpdateGfxFlags()
		var int iMaxWorker=m_xTechTree.GetValueI(GetObjPath()+"/maxworkers",4);
		if(iMaxWorker!=m_iMaxWorker)then
			m_iMaxWorker=iMaxWorker;
			SetAttrib("free_worker_slots",m_iMaxWorker.ToString());
			var ^CAttribs pxAttr=GetAttribs();
			if(pxAttr!=null)then
				pxAttr^.SetValue("free_worker_slots",m_iMaxWorker);
			endif;
		endif;
		super.UpdateGfxFlags();
	endproc;
	
endclass;
	
class CAjeUnlimitedBuilding inherit CUnlimitedBuilding
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
//		m_iMaxWorker=4;
		m_iMaxWorker=m_xTechTree.GetValueI(GetObjPath()+"/maxworkers",4);
		SetAttrib("free_worker_slots",m_iMaxWorker.ToString());
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("free_worker_slots",m_iMaxWorker);
		endif;
	endproc;
	
	export proc void SetPFBlocking()
	endproc;
	
	export proc void UpdateGfxFlags()
		var int iMaxWorker=m_xTechTree.GetValueI(GetObjPath()+"/maxworkers",4);
		if(iMaxWorker!=m_iMaxWorker)then
			m_iMaxWorker=iMaxWorker;
			SetAttrib("free_worker_slots",m_iMaxWorker.ToString());
			var ^CAttribs pxAttr=GetAttribs();
			if(pxAttr!=null)then
				pxAttr^.SetValue("free_worker_slots",m_iMaxWorker);
			endif;
		endif;
	endproc;
	
	export proc void OnWork()
		var string sAnime="deliver";
		DeleteTimer(WORK_ANIM_TIMER_ID);
		CreateTimer(WORK_ANIM_TIMER_ID,CGameTimeSpan.OneSecond()*6.0f,false);
		if((GetCurrentAnimName()!=sAnime||GetCurrentAnimMode()!=3)&&HasAnim(sAnime))then
			SetAnim(sAnime,3);
		endif;
		return;
	endproc;
	
	export proc void StopWorkAnim()
		if(GetCurrentAnimName()=="deliver")then
			EndCurrentLoopAnim();
		endif;
	endproc;
	
endclass;

class CHuPunchingBag inherit CBuilding
	
	export proc void SetPFBlocking()
	endproc;

endclass;
	
class CUnlimitedBuilding inherit CBuilding
	
	var CObjList m_xWorker;
	var int m_iMaxWorker;
	var array string m_asRes;
	var bool m_bAutomatized;
	var real m_fFoodInvCapacity;
	var real m_fFoodInvSpace;
	var real m_fWoodInvCapacity;
	var real m_fWoodInvSpace;
	export var string m_sCurRes;
	var bool m_bNew;
	
	constructor()
		m_bNew=false;
		m_bAutomatized=false;
		m_fFoodInvSpace=0.0;
		m_fWoodInvSpace=0.0;
		m_sCurRes="food";
	endconstructor;
	
	destructor()
	enddestructor;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="ULmd")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xWorker.DoKArc(pxArc^);
			if(p_pxReaderNode^.GetVersion()>=2)then
				(pxArc^)<< m_bAutomatized;
				(pxArc^)<< m_fFoodInvSpace;
			endif;
			if(p_pxReaderNode^.GetVersion()>=3)then
				(pxArc^)<< m_sCurRes;
				(pxArc^)<< m_fWoodInvSpace;
				(pxArc^)<< m_bNew;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		if(!CMirageSrvMgr.SDK())then
			var CFourCC xBase="ULmd";
			var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,3);
			var ^CArc pxArc=^(pxWalk^.GetArc());
			m_xWorker.DoKArc(pxArc^);
			(pxArc^)<< m_bAutomatized;
			(pxArc^)<< m_fFoodInvSpace;
			(pxArc^)<< m_sCurRes;
			(pxArc^)<< m_bNew;
			pxWalk^.Close();
		endif;
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			m_bNew=true;
		endif;
		UpdateTechTree();
		m_bQuickHarvest=true;
//		m_iMaxWorker=2;
		m_iMaxWorker=m_xTechTree.GetValueI(GetObjPath()+"/maxworkers",2);
		SetUnlimitedBuilding(true);
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		// Henry: HACK for old buildings...
		if(GetClassName()=="seas_greenhouse"&&!m_bNew)then
			m_bNew=true;
			var ^CTechTreeDef pxDef=GetTechTreeDef();
			if(pxDef!=null)then
				var string sFood="/Filters/SEAS/Upgrades/seas_greenhouse/seas_food_building";
				if(!pxDef^.HasFilter(sFood))then
					pxDef^.EnableFilter(sFood);
				endif;
			endif;
		endif;
	endproc;
	
	export proc void UpdateGfxFlags()
		var ^CAttribs pxAttr=GetAttribs();
		if(GetClassName()=="seas_greenhouse"&&!m_bAutomatized)then
			var bool bA=CRequirementsMgr.Get().CheckInvention(this, GetOwner(), "seas_automatization", GetTribeName());
			if(bA)then
//			if(true)then
				m_bAutomatized=true;
				SetAttrib("free_worker_slots","0");
				if(pxAttr!=null)then
					pxAttr^.SetValue("free_worker_slots",0);
				endif;
			endif;
		endif;
		var int iMaxWorker=m_xTechTree.GetValueI(GetObjPath()+"/maxworkers",2);
		if(iMaxWorker!=m_iMaxWorker&&!m_bAutomatized)then
			m_iMaxWorker=iMaxWorker;
			SetAttrib("free_worker_slots",(m_iMaxWorker - m_xWorker.NumEntries()).ToString());
			if(pxAttr!=null)then
				pxAttr^.SetValue("free_worker_slots",(m_iMaxWorker - m_xWorker.NumEntries()));
			endif;
		endif;
		CheckAutomatization();
	endproc;
	
	export proc void CheckAutomatization()
		if(!m_bBuildingReady||!m_bAutomatized)then return; endif;
		if(m_pxTaskMgr==null||m_pxTaskMgr^.GetCurTaskName()=="AutomaticHarvest")then
			return;
		endif;
		StopEverything();
		var ^CAutomaticHarvest pxTask=cast<CAutomaticHarvest>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"AutomaticHarvest"));
		if(pxTask==null)then return; endif;
		if(!pxTask^.Init(GetHandle()))then
			pxTask^.GetFactory()^.FreeState(pxTask);
			return;
		endif;
		AddTask(pxTask, false);
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		CheckAutomatization();
	endproc;
	
	export proc void OnTechTreeChange()
		super.OnTechTreeChange();
	endproc;
	
	export proc void OnTechTreeChange(ref CStringArray p_rasChanges)
		super.OnTechTreeChange(p_rasChanges);
		UpdateFoodInventoryCap();
		UpdateWoodInventoryCap();
		UpdateCurrentResource();
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null&&!m_bAutomatized)then
			pxAttr^.SetValue("free_worker_slots", (m_iMaxWorker - m_xWorker.NumEntries()));
		endif;
	endproc;
	
	export proc void UpdateFoodInventoryCap()
		var ^CTechTree.CNode pxResNode=m_xTechTree.FindNode(GetObjPath()+"/ResInvCaps");
		if(pxResNode==null)then return; endif;
		m_fFoodInvCapacity=(m_xTechTree.GetValueR(GetObjPath()+"/ResInvCaps/food",5.0) * GetTechTreeModifier("ResInv",true))+GetTechTreeModifier("ResInv",false);
	endproc;
	
	export proc void UpdateWoodInventoryCap()
		var ^CTechTree.CNode pxResNode=m_xTechTree.FindNode(GetObjPath()+"/ResInvCaps");
		if(pxResNode==null)then return; endif;
		m_fWoodInvCapacity=(m_xTechTree.GetValueR(GetObjPath()+"/ResInvCaps/wood",5.0) * GetTechTreeModifier("ResInv",true))+GetTechTreeModifier("ResInv",false);
	endproc;
	
	export proc void UpdateCurrentResource()
		var string sCR=m_xTechTree.GetValueS(GetObjPath()+"/CurrentResource","food");
		if(m_sCurRes!=sCR)then
			m_sCurRes=sCR;
			var ^CAttribs pxAttr=GetAttribs();
			if(pxAttr!=null)then
				pxAttr^.SetValue("CurrentResource", sCR);
			endif;
			DeleteVPU();
			UpdateTechTree();
		endif;
	endproc;
	
	export proc string GetCurrentResource()
		return m_sCurRes;
	endproc;
	
	export proc real FoodInvCount()
		return m_fFoodInvSpace;
	endproc;
	
	export proc void FoodInvEmpty()
		m_fFoodInvSpace=0.0;
	endproc;
	
	export proc bool FoodInvIsFull()
		if(FoodInvCount()<GetFoodInventorySize())then
			return false;
		else
			return true;
		endif;
	endproc;
	
	export proc real GetFoodInvSpace()
		return (m_fFoodInvCapacity-m_fFoodInvSpace);
	endproc;
	
	export proc real GetFoodInventorySize()
		return m_fFoodInvCapacity;
	endproc;
	
	export proc bool FoodInvAdd(real p_fCount)
		if(!FoodInvIsFull())then
			m_fFoodInvSpace+=p_fCount;
			return(true);
		else
			return(false);
		endif;
	endproc;
	
	export proc void DropAllInFoodInv()
		m_fFoodInvSpace=0.0;
	endproc;
	
	export proc real WoodInvCount()
		return m_fWoodInvSpace;
	endproc;
	
	export proc void WoodInvEmpty()
		m_fWoodInvSpace=0.0;
	endproc;
	
	export proc bool WoodInvIsFull()
		if(WoodInvCount()<GetWoodInventorySize())then
			return false;
		else
			return true;
		endif;
	endproc;
	
	export proc real GetWoodInvSpace()
		return (m_fWoodInvCapacity-m_fWoodInvSpace);
	endproc;
	
	export proc real GetWoodInventorySize()
		return m_fWoodInvCapacity;
	endproc;
	
	export proc bool WoodInvAdd(real p_fCount)
		if(!WoodInvIsFull())then
			m_fWoodInvSpace+=p_fCount;
			return(true);
		else
			return(false);
		endif;
	endproc;
	
	export proc void DropAllInWoodInv()
		m_fWoodInvSpace=0.0;
	endproc;
	
	export proc void UpdateTechTree()
		m_asRes=0;
		var CTechTree xTechTree;
		var string sObjPath=GetObjPath();
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		var ^CPlayer pxPlayer=pxLevel^.GetPlayer(GetOwner());
		if(pxPlayer!=null)then
			xTechTree=GetTechTree();
		endif;
		var ^CTechTree.CNode pxUnlimited=xTechTree.FindNode(sObjPath+"/unlimited");
		if(pxUnlimited!=null)then
			var int i,iC=pxUnlimited^.NumSubs();
			for(i=0)cond(i<iC)iter(i++)do
				if(pxUnlimited^.GetSub(i)^.GetValueI()==1)then
					m_asRes.AddEntry(pxUnlimited^.GetSub(i)^.GetName());
				endif;
			endfor;
		endif;
	endproc;
	
	export proc array string GetResourceArray()
		return m_asRes;
	endproc;
	
	export proc bool Register(CObjHndl p_xWorker)
		if((m_xWorker.NumEntries()<m_iMaxWorker) && (m_xWorker.FindEntry(p_xWorker)==-1))then
//			m_xWorker.AddEntry(p_xWorker);
			m_xWorker.Include(p_xWorker);
			if(p_xWorker.IsValid())then
				var ^CAttribs pxAttr=GetAttribs();
				if(pxAttr!=null)then
					pxAttr^.SetValue("free_worker_slots", (m_iMaxWorker - m_xWorker.NumEntries()));
					pxAttr^.SetValue("worker_list", AddObjGuidToString(pxAttr^.GetValue("worker_list"),p_xWorker));
				endif;
			endif;
			//SetRndInvMaskSingleFlagInv(VIS_FLAG_SCARECROW,true);
			return true;
		else
			return false;
		endif;
	endproc;
	
	export proc int GetWorkerID(CObjHndl p_xWorker)
		return m_xWorker.FindEntry(p_xWorker);
	endproc;
	
	export proc bool UnRegister(CObjHndl p_xWorker)
		if(m_xWorker.FindEntry(p_xWorker)!=-1)then
			m_xWorker.RemEntry(p_xWorker);
			if(p_xWorker.IsValid())then
				var ^CAttribs pxAttr=GetAttribs();
				if(pxAttr!=null)then
					var int iS=m_iMaxWorker - m_xWorker.NumEntries();
					if(m_bAutomatized)then iS=0; endif;
					pxAttr^.SetValue("free_worker_slots",iS);
					pxAttr^.SetValue("worker_list", RemObjGuidFromString(pxAttr^.GetValue("worker_list"),p_xWorker));
				endif;
			endif;
			//SetRndInvMaskSingleFlagInv(VIS_FLAG_SCARECROW,false);
			return true;
		else
			return false;
		endif;
	endproc;
	
	export proc real Mine(real p_fHit, string p_sType)
		if(!IsBuildMode())then
			OnWork();
			if(m_asRes.FindEntry(p_sType)!=-1)then
				return p_fHit;
			endif;
		endif;
		return 0.0;
	endproc;
	
	export proc bool GetWorkerJobPos(CObjHndl p_xWorker,ref vec3 p_rvJob)
		if(GetClassName()=="seas_greenhouse")then
			return false;
		elseif(GetClassName()=="hu_mine"||GetClassName()=="seas_mine")then
			p_rvJob=GetPos();
			return true;
		endif;
		var int iIdx=m_xWorker.FindEntry(p_xWorker);
		if(iIdx<0||m_iMaxWorker>4)then return false; endif;
		var string sPrefix="wo_";
		if(GetClassName()=="ninigi_bamboo_farm")then
			sPrefix="Bl_";
		endif;
		iIdx+=1;
		if(m_iMaxWorker==2)then
			if(iIdx==1)then iIdx=((Random.GetInt()%2)+1);
			elseif(iIdx==2)then iIdx=((Random.GetInt()%2)+3); endif;
		endif;
		var CFourCC xLink=sPrefix+iIdx.ToString();
		if(GetLinkPosWorld(xLink,p_rvJob))then
			return true;
		endif;
		return false;
	endproc;
	
	export proc bool GetAutomatized()
		return m_bAutomatized;
	endproc;
	
	static proc string AddObjGuidToString(string p_sStringList, CObjHndl p_xHandle)
		if(!p_xHandle.IsValid())then return p_sStringList; endif;
		var string sTempString=";"+p_xHandle.GetObj()^.GetGuid().ToString();
		if(p_sStringList.Find(sTempString)!=-1)then return p_sStringList; endif;
		return (p_sStringList+sTempString);
	endproc;
	
	static proc string RemObjGuidFromString(string p_sStringList, CObjHndl p_xHandle)
		if(!p_xHandle.IsValid())then return p_sStringList; endif;
		var string sTempString=";"+p_xHandle.GetObj()^.GetGuid().ToString();
		if(p_sStringList.Find(sTempString)!=-1)then
			p_sStringList.Replace(sTempString,"");
		endif;
		return (p_sStringList);
	endproc;
	
	export proc bool CheckFoodCapacity()
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		var ^CBasePlayer pxPlayer=cast<CBasePlayer>(pxLevel^.GetPlayer(GetOwner()));
		if(pxPlayer==null)then return false; endif;
		if(m_fFoodInvSpace==0.0)then return false; endif;
		var real fOriginalValue=m_fFoodInvSpace;
		var real fReturnValue=pxPlayer^.AddResource("food",m_fFoodInvSpace);
		var real fStatisticValue=fOriginalValue;
		if(fReturnValue!=0.0)then fStatisticValue-=fReturnValue; endif;
		m_fFoodInvSpace=fReturnValue;
		return fReturnValue!=fOriginalValue;
	endproc;
	
	export proc bool CheckWoodCapacity()
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		var ^CBasePlayer pxPlayer=cast<CBasePlayer>(pxLevel^.GetPlayer(GetOwner()));
		if(pxPlayer==null)then return false; endif;
		if(m_fWoodInvSpace==0.0)then return false; endif;
		var real fOriginalValue=m_fWoodInvSpace;
		var real fReturnValue=pxPlayer^.AddResource("wood",m_fWoodInvSpace);
		var real fStatisticValue=fOriginalValue;
		if(fReturnValue!=0.0)then fStatisticValue-=fReturnValue; endif;
		m_fWoodInvSpace=fReturnValue;
		return fReturnValue!=fOriginalValue;
	endproc;
	
endclass;
	
class CScareCrow inherit CBuilding
	
	const real CROW_RADIUS = 60.0f;
	export const real EFFECT_BONUS_AMOUNT = 25.0f;
	const int DRAIN_MANA = 40035;
	const real MANA_DRAIN_INTERVAL = 1.0;
	
	static var array string ms_asTypes;
	
	export constructor()
		if(ms_asTypes.NumEntries()==0)then
			ms_asTypes.AddEntry("ANML");
			ms_asTypes.AddEntry("CHTR");
			ms_asTypes.AddEntry("VHCL");
		endif;
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		m_xFunctionUnits.SetType("ANML");
		m_xFunctionUnits.SetType("CHTR",true);
		m_xFunctionUnits.SetType("VHCL",true);
		m_xLastFunctionTime=CTimeMgr.Get().GetTime();
		m_xSink.m_xOnObjAdd=OnObjAdd;
		m_xSink.m_xOnObjRem=OnObjRem;
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="ScCr")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var CGuid xG;
			pxArc^<< xG;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		if(m_bManaEnabled)then
			m_xLastFunctionTime=CTimeMgr.Get().GetTime();
			CreateTimer(DRAIN_MANA, CGameTimeSpan.OneSecond() * MANA_DRAIN_INTERVAL, true);
			var real fRange=m_xTechTree.GetValueR("MiscValues/Aje/Scarecrow_range",50.0);
		endif;
		if(!HasPersonalRegion())then
			//var vec3 vP;vP.SetXYZ(fRange,fRange,0.0f);
			var vec3 vP;vP.SetXYZ(CROW_RADIUS,CROW_RADIUS,0.0f);
			CreatePersonalRegion("ScareCrow_"+GetName()+"_"+Random.GetInt().ToString(), vP, 010b);
		endif;
	endproc;
	
	proc bool OnObjAdd(CObjHndl p_xHndl)
		if(m_bToBeDeleted)then return false; endif;
		//var real fMalus=m_xTechTree.GetValueR("MiscValues/Aje/Scarecrow_bonus",25.0);
			var ^CFightingObj pxFO=cast<CFightingObj>(p_xHndl.GetObj());
			if(pxFO!=null&&(CSrvWrap.GetDiplomacyMgr().GetIsEnemy(GetOwner(), pxFO^.GetOwner())||CSrvWrap.GetDiplomacyMgr().GetIsEnemy(pxFO^.GetOwner(),GetOwner())))then
				if(ms_asTypes.FindEntry(pxFO^.GetType().AsString())>=0)then
					m_xRegionObjects.Include(p_xHndl);
					//var real fBonus=pxFO^.GetDmg()*0.01f*fMalus;
					pxFO^.SetMirageFlag(CFightingObj.MIRAGE_SCARECROW, true);
//					var real fBonus=pxFO^.GetDmg()*0.01f*EFFECT_BONUS_AMOUNT;
//					var ^CBoniBucket pxBB=pxFO^.GetBoniBucket(CFightingObj.BONUS_DAMAGE);
//					pxBB^.AddEntry("ScareCrow", -fBonus);
//					pxFO^.ForceBoniUpdate();
				endif;
		endif;
		return true;
	endproc;
	
	proc bool OnObjRem(CObjHndl p_xHndl)
		if(m_xRegionObjects.FindEntry(p_xHndl)==-1)then return false; endif;
		m_xRegionObjects.RemEntry(p_xHndl);
		var ^CFightingObj pxFO=cast<CFightingObj>(p_xHndl.GetObj());
//		if(pxFO!=null && CSrvWrap.GetDiplomacyMgr().GetIsEnemy(GetOwner(), pxFO^.GetOwner()))then
		if(pxFO!=null)then
			if(ms_asTypes.FindEntry(pxFO^.GetType().AsString())>=0)then
				pxFO^.SetMirageFlag(CFightingObj.MIRAGE_SCARECROW, false);
//				var ^CBoniBucket pxBB=pxFO^.GetBoniBucket(CFightingObj.BONUS_DAMAGE);
//				pxBB^.RemEntry("ScareCrow");
//				pxFO^.ForceBoniUpdate();
			endif;
		endif;
		return true;
	endproc;
	
	proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==DRAIN_MANA)then
				DrainMana();
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	proc void DrainMana()
		if(!m_bManaEnabled)then
			DeleteTimer(DRAIN_MANA);
			return;
		endif;
		//if(!(GetHitpoints()<GetMaxHitpoints()))then return; endif;
		var CGameTime xNow=CTimeMgr.Get().GetTime();
		var CGameTimeSpan xDT=xNow-m_xLastFunctionTime;
		var real fTime=xDT.GetSecondsF();
		if(fTime==0.0)then return; endif;
		var real fRadius=10.0f;
		var ^CFightingObj.CSpecialAbility pxAb=m_xAbilities.GetAbility("drain_mana", true);
		if(pxAb!=null)then
			var real fRadius=pxAb^.GetValueF("radius");
		else
			return;
		endif;
		m_xLastFunctionTime=xNow;
		var CObjList xUnits;
		CSrvWrap.GetDiplomacyMgr().AddMyEnemiesToSearch(GetOwner(), m_xFunctionUnits, false);
		//CSrvWrap.GetDiplomacyMgr().AddMyFriendsToSearch(GetOwner(), m_xFunctionUnits); //Henry: for testing on own units :)
		m_xFunctionUnits.RegionCircle(GetPos(),fRadius);
		if(!m_xFunctionUnits.Execute(xUnits))then return; endif;
		var int i,iC=xUnits.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFightingObj pxFWalk=cast<CFightingObj>(xUnits[i].GetObj());
			if(pxFWalk!=null)then
				var ^CFightingObj.CSpecialAbility pxAb=m_xAbilities.GetAbility("drain_mana", true);
				if(pxAb!=null)then
					var real fStolenMana=pxFWalk^.DrainEnergy(pxAb^.GetValueF("amount"));
					if(fStolenMana>0.0f)then HealMe(fStolenMana); endif;
				endif;
			endif;
		endfor;
	endproc;
	
	export proc void InitOwnRegion()
		if(!HasPersonalRegion())then
			//var vec3 vP;vP.SetXYZ(fRange,fRange,0.0f);
			var vec3 vP;vP.SetXYZ(CROW_RADIUS,CROW_RADIUS,0.0f);
			CreatePersonalRegion("ScareCrow_"+GetName()+"_"+Random.GetInt().ToString(), vP, 010b);
		endif;
	endproc;
	
	export proc string GetReportCode()
		return "defence";
	endproc;
	
endclass;

class CResiner inherit CUnlimitedBuilding
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetConvertBuilding(true);
	endproc;
	
	export proc real Mine(real p_fHit, string p_sType)
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel==null)then return 0.0; endif;
		var ^CPlayer pxPlayer=pxLevel^.GetPlayer(GetOwner());
		if(pxPlayer==null)then return 0.0; endif;
		var ^CBasePlayer pxBasePlayer=cast<CBasePlayer>(pxPlayer);
		var real fWood=pxBasePlayer^.GetWood().ToReal();
		if(!IsBuildMode())then
			OnWork();
			pxBasePlayer^.AddWood(-((p_fHit+0.5f).ToInt()));
			return Math.Min(p_fHit,(fWood-pxBasePlayer^.GetWood().ToReal())/1.0);
		else
			return 0.0;
		endif;
	endproc;
	
	export proc bool HasWood()
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel==null)then return false; endif;
		var ^CPlayer pxPlayer=pxLevel^.GetPlayer(GetOwner());
		if(pxPlayer==null)then return false; endif;
		var ^CBasePlayer pxBasePlayer=cast<CBasePlayer>(pxPlayer);
		//L KLog.LogSpam("TechTree","CResiner::HasWood()"+(!IsBuildMode() && pxBasePlayer^.GetWood().ToReal()>0.0).ToString());
		return (!IsBuildMode() && pxBasePlayer^.GetWood().ToReal()>0.0 );
	endproc;

endclass;

class CCauldron inherit CBuilding
	
	const real						CAULDRON_RADIUS		=40.0;
	export const string		EFFECT_PATH	="/Filters/Ninigi/Upgrades/ninigi_cauldron/change_weapons";
	const real						CAULDRON_INTERVALL=3.0;
	const real						CAULDRON_DAMAGE=20.0;
	const int							CAULDRON_TIMER=40025;
	
	var string m_sTTPath;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		m_xSink.m_xOnObjAdd=OnObjAdd;
		m_xSink.m_xOnObjRem=OnObjRem;
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		DeleteTimer(CAULDRON_TIMER);
//		CreateTimer(CAULDRON_TIMER,CGameTimeSpan.OneSecond()*CAULDRON_INTERVALL, true);
		if(!HasPersonalRegion())then
			//var real fRange=m_xTechTree.GetValueR("MiscValues/Ninigi/Cauldron_radius",40.0);
			//var vec3 vE;vE.SetXYZ(fRange, fRange, 0.0f);
			var vec3 vE;vE.SetXYZ(CAULDRON_RADIUS, CAULDRON_RADIUS, 0.0f);
			CreatePersonalRegion("NinigiCauldron_"+GetName()+"_"+Random.GetInt().ToString(), vE, 010b);
			AddRangedBuff("owner_fire_arrows");
		endif;
	endproc;
	
	export proc bool CheckCauldronUnit(string p_sClassName)
		if(p_sClassName=="ninigi_archer")then
			return true;
		elseif(p_sClassName=="ninigi_marksman")then
			return true;
		elseif(p_sClassName=="aje_archer")then
			return true;
		elseif(p_sClassName=="hu_archer")then
			return true;
		elseif(p_sClassName=="hu_marksman")then
			return true;
		elseif(p_sClassName=="Bela_s0")then
			return true;
		endif;
		return false;
	endproc;
	
	proc bool OnObjAdd(CObjHndl p_xHndl)
		if(m_bToBeDeleted)then return false; endif;
		var ^CFightingObj pxFO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxFO==null)then return false; endif;
		if(!AuraSharing()&&pxFO^.GetOwner()!=GetOwner())then return false; endif;
		if(CheckCauldronUnit(pxFO^.GetClassName())&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxFO^.GetOwner(), GetOwner())&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxFO^.GetOwner()))then
			m_xRegionObjects.Include(p_xHndl);
			pxFO^.SetEffectFlag(CFightingObj.EFFECT_NINIGI_CAULDRON,true);
		endif;
		return true;
	endproc;
	
	proc bool OnObjRem(CObjHndl p_xHndl)
		if(m_xRegionObjects.FindEntry(p_xHndl)==-1)then return false; endif;
		m_xRegionObjects.RemEntry(p_xHndl);
		var ^CFightingObj pxFO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxFO!=null)then
			pxFO^.SetEffectFlag(CFightingObj.EFFECT_NINIGI_CAULDRON,false);
		endif;
		return true;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==CAULDRON_TIMER)then
//				BurnThemAll();
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	proc void BurnThemAll()
		//if(GetIncapacitated())then return; endif; //Henry: its still burning with or without rammer ;)
		var real fDamageFactor=CAULDRON_DAMAGE;
		var int i,iC=m_xRegionObjects.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFightingObj pxObj=cast<CFightingObj>(m_xRegionObjects[i].GetObj());
			if(pxObj==null)then continue; endif;
			if(pxObj^.GetType()=="BLDG"||pxObj^.GetType()=="NEST")then continue; endif;
			if(!CSrvWrap.GetDiplomacyMgr().GetIsEnemy(GetOwner(), pxObj^.GetOwner()))then continue; endif;
			//if(GetOwner()>-1 && (pxObj^.GetVisibleMask()&(01b<<GetOwner()))==00b)then continue; endif;
//			pxObj^.ClearDamageCache();
			pxObj^.TakeDmg(this, false, fDamageFactor);
		endfor;
	endproc;
	
	export proc void InitOwnRegion()
		if(!HasPersonalRegion())then
			var vec3 vE;vE.SetXYZ(CAULDRON_RADIUS, CAULDRON_RADIUS, 0.0f);
			CreatePersonalRegion("NinigiCauldron_"+GetName()+"_"+Random.GetInt().ToString(), vE, 010b);
			AddRangedBuff("owner_fire_arrows");
		endif;
	endproc;
	
	export proc string GetReportCode()
		return "defence";
	endproc;
	
endclass;

class CTrap inherit CBuilding
	
	class CTrapEffect inherit CEvtSink
	
		var procref<bool, CObjHndl> m_xOnTrapped;
		var procref<bool, CObjHndl> m_xOnTick;
		var procref<bool, CObjHndl> m_xOnReleased;
	
		var CObjHndl m_xTrap;
		var CObjHndl m_xObj;
		var CGameTime m_xStartTime;
		var real m_fDuration;
		var int m_iTimer;
		var bool m_bSkipTarget;
	
		export static proc ^CTrap.CTrapEffect CreateEffect(^CTrap p_pxTrap, CObjHndl p_xObj, procref<bool,CObjHndl> p_xOnTrap, procref<bool,CObjHndl> p_xOnRel, procref<bool, CObjHndl> p_xOnTick)
			if(!p_xObj.IsValid()||p_pxTrap==null)then return null; endif;
			if((p_pxTrap^.m_xIgnoreList.FindEntry(p_xObj)>=0)||(p_pxTrap^.m_xCurTrappedObjs.FindEntry(p_xObj)>=0))then return null; endif;
			var ^CTrapEffect pxRet=new CTrap.CTrapEffect(p_pxTrap, p_xObj, p_xOnTrap, p_xOnRel, p_xOnTick);
			if(pxRet^.m_bSkipTarget)then
				delete pxRet; //delete internally sets pxRet=null
				pxRet=null;
			endif;
			return pxRet;
		endproc;
	
		// for use during loading only
		export static proc ^CTrap.CTrapEffect CreateEffect()
			var ^CTrapEffect pxRet=new CTrap.CTrapEffect();
			return pxRet;
		endproc;
	
		export proc void ReInit()
			if(!m_xOnTrapped.IsNull())then
				if(!m_xOnTrapped.Call(m_xObj))then
					//object can not be trapped -> skip
					m_bSkipTarget=true;
					return;
				endif;
			endif;
			m_iTimer=CTimeMgr.Get().CreateTimer(CGameTimeSpan.OneSecond(), true);
			//m_xStartTime=CTimeMgr.Get().GetTime();
			var ^CTimerObj pxT=CTimeMgr.Get().GetTimer(m_iTimer);
			if(pxT!=null)then
				pxT^.Subscribe(this);
			endif;
		endproc;
	
		constructor(^CTrap p_pxTrap, CObjHndl p_xObj, procref<bool,CObjHndl> p_xOnTrap, procref<bool,CObjHndl> p_xOnRel, procref<bool, CObjHndl> p_xOnTick )
			m_xTrap=p_pxTrap^.GetHandle();
			m_xObj=p_xObj;
			m_fDuration=p_pxTrap^.m_fDuration;
			m_xOnTrapped=p_xOnTrap;
			m_xOnReleased=p_xOnRel;
			m_xOnTick=p_xOnTick;
			m_bSkipTarget=false;
			if(!m_xOnTrapped.IsNull())then
				if(!m_xOnTrapped.Call(m_xObj))then
					m_bSkipTarget=true;
					return;
				endif;
			endif;
			m_iTimer=CTimeMgr.Get().CreateTimer(CGameTimeSpan.OneSecond(), true);
			m_xStartTime=CTimeMgr.Get().GetTime();
			var ^CTimerObj pxT=CTimeMgr.Get().GetTimer(m_iTimer);
			if(pxT!=null)then
				pxT^.Subscribe(this);
			endif;
			p_pxTrap^.m_apxRunningEffects.AddEntry(this);
			p_pxTrap^.m_xCurTrappedObjs.Include(m_xObj);
		endconstructor;
	
		//for use during loading only
		constructor()
		endconstructor;
	
		destructor()
			var ^CTimerObj pxT=CTimeMgr.Get().GetTimer(m_iTimer);
			if(pxT!=null)then
				pxT^.Unsubscribe(this);
				CTimeMgr.Get().DeleteTimer(m_iTimer);
				m_iTimer=-1;
			endif;
		enddestructor;
	
		export proc void Delete()
			if(m_xTrap.IsValid())then
				var ^CTrap pxTrap=cast<CTrap>(m_xTrap.GetObj());
				if(pxTrap!=null)then
					pxTrap^.m_apxRunningEffects.RemEntryUS(this);
				endif;
			endif;
			delete this;
		endproc;
	
		export proc void DoKArc(ref CArc p_rxArc)
			m_xTrap.DoKArc(p_rxArc);
			m_xObj.DoKArc(p_rxArc);
			m_xStartTime.DoKArc(p_rxArc);
			p_rxArc << m_fDuration;
			//p_rxArc << m_iTimer;
			p_rxArc << m_bSkipTarget;
			//p_rxArc << m_xOnTrapped;
			//p_rxArc << m_xOnTick;
			//p_rxArc << m_xOnReleased;
		endproc;
	
		//used to reinit after loading
		export proc void SetProcs(procref<bool,CObjHndl> p_xOnTrap, procref<bool,CObjHndl> p_xOnRel, procref<bool, CObjHndl> p_xOnTick )
			ReleaseProcs();
			m_xOnTrapped=p_xOnTrap;
			m_xOnTick=p_xOnTick;
			m_xOnReleased=p_xOnRel;
		endproc;
		
		export proc void SetProcs(procref<bool,CObjHndl> p_xOnTrap, procref<bool,CObjHndl> p_xOnRel)
			ReleaseProcs();
			m_xOnTrapped=p_xOnTrap;
			m_xOnReleased=p_xOnRel;
		endproc;
		
		export proc void ReleaseProcs()
			m_xOnTrapped.Clear();
			m_xOnReleased.Clear();
			m_xOnTick.Clear();
		endproc;
		
		export proc bool OnPush(ref CEvtPointer  p_rxEP)
			if(!m_xTrap.IsValid())then delete this; return false; endif;
			var CGameTime xNow=CTimeMgr.Get().GetTime();
			if((xNow - m_xStartTime).GetSecondsF() >= m_fDuration||!m_xObj.IsValid())then
				OnRelease();
			else
				if(!m_xOnTick.IsNull())then
					m_xOnTick.Call(m_xObj);
				endif;
			endif;
			return true;
		endproc;
	
		export proc bool OnRelease()
			if(!m_xOnReleased.IsNull())then
				m_xOnReleased.Call(m_xObj);
			endif;
			if(m_xTrap.IsValid())then
				var ^CTrap pxTrap=cast<CTrap>(m_xTrap.GetObj());
				if(pxTrap!=null)then
					pxTrap^.m_xCurTrappedObjs.RemEntry(m_xObj);
					pxTrap^.m_xIgnoreList.Include(m_xObj);
					pxTrap^.m_apxRunningEffects.RemEntryUS(this);
					delete this;
					return true;
				endif;
			endif;
			return true;
		endproc;
		
	endclass;
	
	class CTrapQuery inherit CEvtSink
	
		var bool m_bEnabled;
		var int m_iRegion; ///< handle of region, where to make query
		var bool m_bOnlyEnemies; ///< query affects only enemies of trap's owner
		var CObjQuery m_xQuery;
		var CObjHndl m_xTrap;
		var bool m_bOneTime; ///< query runs only ones
		export var bool m_bAlreadyReleased;	///< indicate trap was already trapped
		var procref<bool, CObjHndl> m_xOnTrap, m_xOnRelease, m_xOnTick;
	
		export constructor(^CTrap p_pxTrap)
			m_iRegion=-1;
			m_bOnlyEnemies=true;
			if(p_pxTrap!=null)then
				m_xTrap=p_pxTrap^.GetHandle();
			endif;
		endconstructor;
	
		export destructor()
			var ^CRegionMgr pxRgnMgr=^(CSrvWrap.GetRegionMgr());
			var ^CRegion pxRgn=pxRgnMgr^.GetRegion(m_iRegion);
			if(pxRgn!=null)then
				pxRgn^.Unsubscribe(this);
				pxRgnMgr^.DeleteRegion(m_iRegion);
			endif;
		enddestructor;
	
		export proc bool GetEnabled()
			return m_bEnabled;
		endproc;
	
		export proc void ReleaseProcs()
			m_xOnTrap.Clear();
			m_xOnRelease.Clear();
			m_xOnTick.Clear();
		endproc;
	
		export proc void SetEnabled(bool p_bEnabled)
			m_bEnabled=p_bEnabled;
			var ^CRegionMgr pxRgnMgr=^(CSrvWrap.GetRegionMgr());
			begin;
				var ^CRegion pxRgn=pxRgnMgr^.GetRegion(m_iRegion);
				if(pxRgn!=null)then
					pxRgn^.Unsubscribe(this);
					pxRgnMgr^.DeleteRegion(m_iRegion);
				endif;
			end;
			if(!m_xTrap.IsValid())then
				m_bEnabled=false;
			endif;
			if(m_bEnabled)then
				var vec3 vR;
				var ^CTrap pxTrap=cast<CTrap>(m_xTrap.GetObj());
				if(pxTrap!=null)then
					vR.SetXYZ(pxTrap^.GetTrapRadius(),pxTrap^.GetTrapRadius(),0.0f);
					m_iRegion=pxRgnMgr^.CreateRegion(pxTrap^.GetName()+"_Region",CSubRegion.RT_Oval,pxTrap^.GetPos(),vR);
					var ^CRegion pxRgn=pxRgnMgr^.GetRegion(m_iRegion);
					if(pxRgn!=null)then
						pxRgn^.SetVolatile();
						// bind region to trap, may be we make moveable traps
						pxRgn^.BindToObj(pxTrap^.GetHandle());
						pxRgn^.Subscribe(this);
					else
						m_bEnabled=false;
					endif;
				endif;
			endif;
		endproc;
	
		export proc void SetOneTime(bool p_bOneTime)
			m_bOneTime=p_bOneTime;
		endproc;
	
		export proc bool GetOneTime()
			return m_bOneTime;
		endproc;
	
		export proc void SetProcs(procref<bool,CObjHndl> p_xOnTrap, procref<bool,CObjHndl> p_xOnRel)
			m_xOnTrap=p_xOnTrap;
			m_xOnRelease=p_xOnRel;
		endproc;
	
		export proc void SetProcs(procref<bool,CObjHndl> p_xOnTrap, procref<bool,CObjHndl> p_xOnRel, procref<bool, CObjHndl> p_xOnTick )
			SetProcs(p_xOnTrap, p_xOnRel);
			m_xOnTick=p_xOnTick;
		endproc;
	
		export proc void SetEnemyOnly(bool p_bValue)
			m_bOnlyEnemies=p_bValue;
		endproc;
	
		export proc void AddType(string p_sType)
			m_xQuery.SetType(p_sType,true);
		endproc;
	
		export proc void ClearTypes()
			m_xQuery.ClearTypes();
		endproc;
	
		proc void UpdateObjQuery()
			m_xQuery.SetOwner(-1,false);
			if(!m_xTrap.IsValid())then
				SetEnabled(false);
				return;
			endif;
			var ^CTrap pxTrap=cast<CTrap>(m_xTrap.GetObj());
			if(pxTrap==null)then return; endif;
			var int i, iC=8;
			var int iOwner=pxTrap^.GetOwner();
			for (i=0) cond(i<iC) iter(++i)do
				// friendly fire is off
				if(i==iOwner)then continue; endif;
				if(!m_bOnlyEnemies||CSrvWrap.GetDiplomacyMgr().GetIsEnemy(iOwner,i))then
					m_xQuery.SetOwner(i, true);
				endif;
			endfor;
			m_xQuery.SetRegion(m_iRegion);
		endproc;
	
		// here comes the notification about changes in the region
		proc bool OnPush(ref CEvtPointer p_rxEP)
			UpdateObjQuery();
			var CObjList xList, xEntered, xLeaved;
			m_xQuery.Execute(xList);
			var bitset dwWasFlagged=0b;
			if(!m_xTrap.IsValid())then
				SetEnabled(false);
				return false;
			endif;
			var ^CTrap pxTrap=cast<CTrap>(m_xTrap.GetObj());
			if(pxTrap==null)then return false; endif;
			var int i, iC=xList.NumEntries();
			for (i=0) cond(i<iC) iter(++i)do
				var ^CFightingObj pxObj=cast<CFightingObj>(xList[i].GetObj());
				if(pxObj==null)then continue; endif;
				if(pxObj^.IsFlyingUnit())then continue; endif;
				if((pxTrap^.m_xIgnoreList.FindEntry(xList[i])<0)&&(pxTrap^.m_xCurTrappedObjs.FindEntry(xList[i])<0)&&(!pxObj^.GetTransportObj().IsValid())&&!pxObj^.GetOnWall())then
					xEntered.Include(xList[i]);
				endif;
			endfor;
			iC=pxTrap^.m_xIgnoreList.NumEntries();
			for (i=0) cond(i<iC) iter(++i)do
				if(xList.FindEntry(pxTrap^.m_xIgnoreList[i])<0)then
					xLeaved.Include(pxTrap^.m_xIgnoreList[i]);
				endif;
			endfor;
			iC=xEntered.NumEntries();
			if(!m_bOneTime||!m_bAlreadyReleased)then
				for(i=0) cond(i<iC) iter(++i)do
					var ^CGameObj pxObj=xEntered[i].GetObj();
					if(pxObj==null)then continue; endif;
					if(CTrap.CTrapEffect.CreateEffect(pxTrap, xEntered[i], m_xOnTrap, m_xOnRelease, m_xOnTick)!=null)then
						//unhide trap only if "trappee" was accepted
//						var int iOwner=pxObj^.GetOwner();
//						if((dwWasFlagged&(01b<<iOwner))==0b)then
//							dwWasFlagged|=01b<<iOwner;
//							if(pxTrap^.GetClassName()!="ninigi_poison_trap")then
//								pxTrap^.TrapFound(iOwner);
//							else
//								pxTrap^.TrapFoundPoison(iOwner);
//							endif;
//						endif;
						if(m_bOneTime)then
							m_bAlreadyReleased=true;
							break;
						endif;
					endif;
				endfor;
			endif;
			iC=xLeaved.NumEntries();
			for (i=0) cond(i<iC) iter(++i)do
				pxTrap^.m_xIgnoreList.RemEntry(xLeaved[i]);
			endfor;
			return true;
		endproc;
		
	endclass;
	
	var bool m_bWasLoaded; //volatile ; for init after loading
	var bool m_bEnableQueryAfterLoading; //volatile ; for init after loading
	export var bool m_bOnHidden;
	
	var ^CTrapQuery m_pxQuery;
	export var array ^CTrapEffect m_apxRunningEffects;
	
	export var CObjList m_xCurTrappedObjs; ///< List of objects currently trapped
	export var CObjList m_xIgnoreList; ///< List of Object to ignore ( ie. Objs trapped and released but in TrapZone )
	
	var real m_fRadius; ///< radius where trap takes effect
	export var real m_fDuration;
	var bool m_bEnableOnReady; ///< trap is usable after build
	const int DELETE_TIMER=222;
	const int DELAY_TIMER=223;
	const int TIMER_ON_HIDE_REVEAL=40184;
	const int TIMER_ON_HIDE_TRIGGERED=40185;
	
	export constructor()
		//m_pxQuery=new CTrapQuery(this); RT#15528 init error of object handle, handle is only valid after objectmanager finished the CreateObj method; moved this line to OnInit
		m_bEnableOnReady=true;
		m_bWasLoaded=false;
		m_bEnableQueryAfterLoading=false;
		m_bOnHidden=false;
	endconstructor;
	
	export destructor()
		delete m_pxQuery;
//		var int i;
//		for(i=0)cond(i<m_apxRunningEffects.NumEntries())iter(i++)do
//			m_apxRunningEffects[i]^.Delete();
//		endfor;
		while(m_apxRunningEffects.NumEntries()>0)do
			if(m_apxRunningEffects[0]!=null)then
				m_apxRunningEffects[0]^.Delete();
			endif;
		endwhile;
	enddestructor;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="Trap")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			// trap query status
			m_bWasLoaded=true;
			pxArc^ << m_bEnableQueryAfterLoading;
			// running trap effects
			var int i, iCountRunningEffects;
			pxArc^ << iCountRunningEffects;
			for(i=0)cond(i<iCountRunningEffects)iter(i++)do
				var ^CTrap.CTrapEffect pxTrapEffect=CTrap.CTrapEffect.CreateEffect();
				pxTrapEffect^.DoKArc(pxArc^);
				m_apxRunningEffects.AddEntry(pxTrapEffect);
			endfor;
			m_xCurTrappedObjs.DoKArc(pxArc^);
			m_xIgnoreList.DoKArc(pxArc^);
			pxArc^ << m_fRadius;
			pxArc^ << m_fDuration;
			pxArc^ << m_bEnableOnReady;
			if(iVersion>=1)then
				pxArc^ << m_bOnHidden;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="Trap"; // Trap base
		var int iVersion=1;
		if(CMirageSrvMgr.SDK())then
			iVersion=0;
		endif;
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,iVersion);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		// trap query status
		var bool bTmp=true;
		if(m_pxQuery!=null)then
			bTmp=m_pxQuery^.GetEnabled();
			// fix trap placed in leveled won't initialze correctly (start)
			// SB#16935
			if(!m_bWasLoaded)then
				var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
				System.Assert(pxLevel!=null);
				if(pxLevel^.IsEditable())then
					bTmp=true; // can't place unfinished traps within leveleditor
				endif;
			endif;
			// fix trap placed in leveled won't initialze correctly (end)
		endif;
		pxArc^ << bTmp;
		// running trap effects
		var int i, iCountRunningEffects=m_apxRunningEffects.NumEntries();
		pxArc^ << iCountRunningEffects;
		for(i=0)cond(i<iCountRunningEffects)iter(i++)do
			m_apxRunningEffects[i]^.DoKArc(pxArc^);
		endfor;
		m_xCurTrappedObjs.DoKArc(pxArc^);
		m_xIgnoreList.DoKArc(pxArc^);
		pxArc^ << m_fRadius;
		pxArc^ << m_fDuration;
		pxArc^ << m_bEnableOnReady;
		if(iVersion>=1)then
			pxArc^ << m_bOnHidden;
		endif;
		pxWalk^.Close();
	endproc;
	
	export proc string GetReleaseAnim()
		return "";
	endproc;
	
	export proc string GetCatchAnim()
		return "";
	endproc;
	
	export proc string GetDieInTrapAnim()
		return "";
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			if(m_xTechTree.GetValueB("/Objects/Ninigi/InventObjects/ninigi_trap_upgrade/invented",false))then
				OnHide();
			endif;
		endif;
		// make traps invisible again if they gone in FOW
		// this shouldn't move to (!p_bLoad) section, because it isn't saved
		SetWallMapObj(true);
		SetIsTrap(true);
		m_pxQuery=new CTrapQuery(this);
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		OnHide();
		if(m_bWasLoaded)then
			m_pxQuery^.SetEnabled(m_bEnableQueryAfterLoading);
		else
//			SetVisibleMask(01b<<GetOwner());
			m_pxQuery^.SetEnabled(m_bEnableOnReady);
		endif;
		SetFOWTempVisible(true);
//		SetFOWTempVisible(false);
	endproc;
	
	export proc void SetTrapRadius(real p_fRadius)
		m_fRadius=p_fRadius;
		m_pxQuery^.SetEnabled(m_pxQuery^.GetEnabled());
	endproc;
	
	export proc real GetTrapRadius()
		return m_fRadius;
	endproc;
	
	export proc string GetTrappedAnim()
		return "";
	endproc;
	
	export proc void TrapFound(int p_iOwner)
		if(GetOwner()==p_iOwner)then return; endif;
		m_bOnHidden=false;
//		var CFightingObj.CCamouflageLayer xLayer;
//		xLayer.SetType("smok");
//		var int iIdx=m_axCamouflageLayers.FindEntry(xLayer);
//		if(iIdx!=-1 && m_axCamouflageLayers[iIdx].IsValid() && !m_axCamouflageLayers[iIdx].IsOffline())then
//			return;
//		endif;
		SwitchTrapCamouflage(false);
		//SetVisibleMask(GetVisibleMask()|(01b<<p_iOwner));
//		SetVisible(true); //see DevTrack: WT8 or StarBugs #14194
	endproc;
	
	export proc void TrapFoundPoison(int p_iOwner)
		if(GetOwner()==p_iOwner)then return; endif;
		if(m_xTechTree.GetValueB("/Objects/Ninigi/InventObjects/ninigi_trap_upgrade/invented",false))then
			return;
		endif;
		m_bOnHidden=false;
		SwitchTrapCamouflage(false);
	endproc;
	
	export proc void Die()
		if(m_pxQuery!=null)then
			m_pxQuery^.SetEnabled(false);
		endif;
		while(m_apxRunningEffects.NumEntries()>0)do
			if(m_apxRunningEffects[0]!=null)then
				m_apxRunningEffects[0]^.OnRelease();
			endif;
		endwhile;
		super.Die();
	endproc;
	
	export proc void ForceRelease()
		while(m_apxRunningEffects.NumEntries()>0)do
			if(m_apxRunningEffects[0]!=null)then
				m_apxRunningEffects[0]^.OnRelease();
			endif;
		endwhile;
	endproc;
	
	export proc bool StartDeleteTimer(real p_fDuration)
		if(HasTimer(DELETE_TIMER))then return false; endif;
		CreateTimer(DELETE_TIMER,CGameTimeSpan.OneSecond() * p_fDuration, false);
		return true;
	endproc;
	
	export proc bool StartDelayTimer(real p_fDuration)
		if(HasTimer(DELAY_TIMER))then return false; endif;
		CreateTimer(DELAY_TIMER,CGameTimeSpan.OneSecond() * p_fDuration, false);
		return true;
	endproc;
	
	export proc void StartHiddenTimer(real p_fDuration)
		if(HasTimer(TIMER_ON_HIDE_REVEAL))then DeleteTimer(TIMER_ON_HIDE_REVEAL); endif;
		CreateTimer(TIMER_ON_HIDE_REVEAL,CGameTimeSpan.OneSecond() * p_fDuration, false);
	endproc;
	
	export proc void StartTriggerTimer(real p_fDuration)
		if(HasTimer(TIMER_ON_HIDE_TRIGGERED)||HasTimer(TIMER_ON_HIDE_REVEAL))then return; endif;
//		if(HasTimer(TIMER_ON_HIDE_TRIGGERED))then DeleteTimer(TIMER_ON_HIDE_TRIGGERED); endif;
		CreateTimer(TIMER_ON_HIDE_TRIGGERED,CGameTimeSpan.OneSecond() * p_fDuration, false);
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==DELETE_TIMER)then
				Die();
				return;
			elseif(p_rxEvtPtr.GetInt(0)==DELAY_TIMER)then
				Activate();
				return;
			elseif(p_rxEvtPtr.GetInt(0)==TIMER_ON_HIDE_REVEAL||p_rxEvtPtr.GetInt(0)==TIMER_ON_HIDE_TRIGGERED)then
				OnHide();
				return;
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		endif;
		super.HandleEvent(p_rxEvtPtr);
	endproc;
	
	export proc void Activate()
		if(HPReachedZero())then return; endif;
		m_xIgnoreList=0;
		m_pxQuery^.m_bAlreadyReleased=false;
		m_pxQuery^.SetEnabled(true);
	endproc;
	
	// do nothing implementation
	export proc bool OnTrap(CObjHndl p_xObj)
		return true;
	endproc;
	
	export proc bool OnRelease(CObjHndl p_xObj)
		return true;
	endproc;
	
	// use it for traps, which holds the objects traped in
	export proc bool OnHoldTrap(CObjHndl p_xHndl)
		if(HPReachedZero())then return false; endif;
		var ^CGameObj pxO=p_xHndl.GetObj();
		if(pxO==null)then return false; endif;
		var ^CFightingObj pxFO=cast<CFightingObj>(pxO);
		if(pxFO!=null)then
			var ^CGameObj pxCurEnemy=pxFO^.GetCurEnemy().GetObj();
			if(pxCurEnemy==this)then
				return false;
			endif;
		endif;
		pxO=pxO^.GetGroupedParentObj();
		var ^CCharacter pxChar=cast<CCharacter>(pxO);
		if(pxChar!=null&&!pxChar^.GetOnWall())then
			var ^CGameObj pxT=pxChar^.GetTransportObj().GetObj();
			if(pxT==null)then
				var bool bTrappedAlready=pxChar^.IsTrapped();
				if(!bTrappedAlready)then
					pxChar^.TerminateAction();
				endif;
				pxChar^.SetTrappedHandle(GetHandle());
			else
				var ^CTransportObj pxA=cast<CTransportObj>(pxT);
				if(pxA!=null)then
					var bool bTrappedAlready=pxA^.IsTrapped();
					if(!bTrappedAlready)then
						pxA^.TerminateAction();
					endif;
					pxA^.SetTrappedHandle(GetHandle());
				endif;
			endif;
		endif;
		var ^CTransportObj pxA=cast<CTransportObj>(pxO);
		if(pxA!=null && pxA^.CanWalk())then
			var bool bTrappedAlready=pxA^.IsTrapped();
			if(!bTrappedAlready)then
				pxA^.TerminateAction();
			endif;
			pxA^.SetTrappedHandle(GetHandle());
		endif;
		if(GetClassName()=="ninigi_poison_trap")then
			if(!m_xTechTree.GetValueB("/Objects/Ninigi/InventObjects/ninigi_trap_upgrade/invented",false))then
				OnReveal();
			endif;
		else
			OnReveal();
		endif;
		//OnReveal();
		return true;
	endproc;
	
	export proc bool OnHoldRelease(CObjHndl p_xHndl)
		var ^CGameObj pxO=p_xHndl.GetObj();
		if(pxO==null)then return false; endif;
		pxO=pxO^.GetGroupedParentObj();
		var ^CCharacter pxChar=cast<CCharacter>(pxO);
		if(pxChar!=null)then
			pxChar^.UntrapHandle(GetHandle());
		endif;
		var ^CTransportObj pxA=cast<CTransportObj>(pxO);
		if(pxA!=null)then
			pxA^.UntrapHandle(GetHandle());
		endif;
		return true;
	endproc;
	
	export proc void Delete()
		if(m_pxQuery!=null)then
			m_pxQuery^.ReleaseProcs();
		endif;
		super.Delete();
	endproc;
	
	export proc void SetPFBlocking()
	endproc;
	
	export proc void OnReveal()
		m_bOnHidden=false;
//		var CFightingObj.CCamouflageLayer xLayer;
//		xLayer.SetType("smok");
//		var int iIdx=m_axCamouflageLayers.FindEntry(xLayer);
//		if(iIdx!=-1 && m_axCamouflageLayers[iIdx].IsValid() && !m_axCamouflageLayers[iIdx].IsOffline())then
////			m_axCamouflageLayers[iIdx].SetDisabled(true);
//			return;
//		endif;
		SwitchTrapCamouflage(false);
//		UpdateCamouflageLayers();
//		var bitset dwBitset=011111111b;
//		SetVisibleMask(dwBitset);
	endproc;
	
	export proc void OnHide()
		m_bOnHidden=true;
//		if(GetDestructLevel()==0)then
		SwitchTrapCamouflage(true);
//		endif;
//		var CFightingObj.CCamouflageLayer xLayer;
//		xLayer.SetType("smok");
//		var int iIdx=m_axCamouflageLayers.FindEntry(xLayer);
//		if(iIdx!=-1)then
//			m_axCamouflageLayers[iIdx].SetDisabled(false);
//		endif;
//		UpdateCamouflageLayers();
//		SetVisibleMask(01b<<GetOwner());
	endproc;
	
	export proc void PlayerRevealed(bool p_bYes)
		return;
	endproc
	
	export proc bool IsItATrap()
		return true;
	endproc
	
	export proc void IgniteBuilding(real p_fDmg, int p_iMaxCount, CObjHndl p_xSource, int p_iSource)
		return;
	endproc;
	
	export proc string GetReportCode()
		return "defence";
	endproc;
	
	export proc bool AuthorizationPicardFourSevenAlphaTango()
		return false;
	endproc;
	
//	export proc void SetDestructLevel(int p_iLvl)
//		if(p_iLvl==0 && GetDestructLevel()!=0 && m_bOnHidden)then
//			SwitchTrapCamouflage(true);
//		endif;
//		super.SetDestructLevel(p_iLvl);
//	endproc;
	
	export proc void Damage(real p_fDamage)
		if(m_bOnHidden)then
			return;
		endif;
		super.Damage(p_fDamage);
	endproc;
	
endclass;

class CPoisonDung inherit CTrap
	
	const real HITPOINTS_COST_PER_SEC=5.0f;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		m_fDuration=1.0f;
		SetTrapRadius(5.0f);
		m_pxQuery^.ClearTypes();
		m_pxQuery^.AddType("CHTR");
		m_pxQuery^.AddType("ANML");
		m_pxQuery^.AddType("VHCL");
		m_pxQuery^.AddType("FGHT");
		m_pxQuery^.AddType("SHIP");
		m_pxQuery^.SetProcs(OnTrap, OnRelease);
		AddRangedBuff("owner_poison");
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		var int i, iCountRunningEffects=m_apxRunningEffects.NumEntries();
		for(i=0)cond(i<iCountRunningEffects)iter(i++)do
			var ^CTrap.CTrapEffect pxTE=m_apxRunningEffects[i];
			if(pxTE!=null)then
				pxTE^.SetProcs(OnTrap,OnRelease);
				pxTE^.ReInit();
			else
				m_apxRunningEffects.DeleteEntry(i);
				i--; iCountRunningEffects--;
				continue;
//				return;
			endif;
		endfor;
	endproc;
	
	export proc bool OnTrap(CObjHndl p_xHndl)
		var ^CFightingObj pxObj=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxObj==null)then return false; endif;
		if(pxObj^.IsFlyingUnit())then return false; endif;
		if(pxObj^.IsWildAnimal()&&pxObj^.GetOwner()==-1&&pxObj^.GetTechTreeAggressiv()!=1)then return false; endif;
		var ^CGameObj pxCurEnemy=pxObj^.GetCurEnemy().GetObj();
		if(pxCurEnemy==this)then
			return false;
		endif;
		if(pxObj^.GetTransportObj().IsValid()||pxObj^.GetOnWall())then return false; endif;
		if(!pxObj^.CanWalk())then return false; endif;
		pxObj^.TakeDmg(this,false);
		if(!m_xTechTree.GetValueB("/Objects/Ninigi/InventObjects/ninigi_trap_upgrade/invented",false))then
			OnReveal();
		endif;
		return true;
	endproc;
	
	export proc bool OnRelease(CObjHndl p_xObj)
		StartTriggerTimer(4.0f);
		return true;
	endproc;
	
endclass;

class CImpResinField inherit CTrap
	
	const real HITPOINTS_COST_PER_SEC=50.0f;
	const real LIFETIME=30.0;
	const int INFECT_TIMER=224;
	const int BURN_TIMER=225;
//	const int NEW_BURN_TIMER=40107;
	
	var bool m_bFired;
	var bool m_bBurning;
	var string m_sPath;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		m_fDuration=1.0f;
		SetTrapRadius(5.0f);
		m_pxQuery^.ClearTypes();
		m_pxQuery^.SetProcs(OnTrap, OnRelease, OnTick);
		if(!p_bLoad)then
			m_bBurning=false;
			m_bFired=false;
		endif;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if((p_sCommand=="Action")&&(p_sMiscParams.Find("/Burn")!=(-1)))then
			StartBurning(p_sMiscParams,true);
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="ImRe";
		var int iVersion=2;
		if(CMirageSrvMgr.SDK())then
			iVersion=1;
		endif;
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,iVersion);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		(pxArc^) << m_sPath;
		(pxArc^) << m_bFired;
		if(iVersion>=2)then
			(pxArc^) << m_bBurning;
		endif;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="ImRe")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			(pxArc^) << m_sPath;
			(pxArc^) << m_bFired;
			if(iVersion>=2)then
				(pxArc^) << m_bBurning;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void StartBurning(string p_sMiscParams, bool p_bAnim)
		m_sPath=p_sMiscParams;
		if(!m_bBurning&&CheckSpecialActionTimer(m_sPath))then
//			AddSpecialActionTimer(m_sPath);
			if(!HasTimer(BURN_TIMER))then
				m_bBurning=true;
				SetGFX("ninigi_resin_field_fire");
				m_pxQuery^.SetEnabled(true);
				if(!HasTimer(INFECT_TIMER))then
					if(p_bAnim)then
						InvokeGenericSCEvent(27,2.5f);
					endif;
					CreateTimer(INFECT_TIMER,CGameTimeSpan.OneSecond() * 1.0, true);
				endif;
				CreateTimer(BURN_TIMER,CGameTimeSpan.OneSecond() * LIFETIME, false);
				OnReveal();
				m_bFired=false;
			endif;
		endif;
	endproc;
	
	proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==INFECT_TIMER )then
				if(!m_bFired)then
					InfectOther();
					m_bFired=true;
				endif;
				OnReveal();
				DoDamage();
				return;
			elseif(p_rxEvtPtr.GetInt(0) ==BURN_TIMER)then
				StopBurning();
				return;
			endif;
		endif;
		super.HandleEvent(p_rxEvtPtr);
	endproc;
	
	proc void InfectOther()
		var CObjQuery xQuery;
		xQuery.SetOwner(GetOwner());
		xQuery.SetClass("ninigi_resin_field");
		xQuery.SetAttribsNeg("CurTask","BuildUpB");
		xQuery.SetAttribsNeg("ReadyForWork",0);
		xQuery.RegionCircle(GetPos(),13.0);
		var CObjList xList;
		if(xQuery.Execute(xList))then
			var int i, iC=xList.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				var ^CImpResinField pxField=cast<CImpResinField>(xList[i].GetObj());
				if(pxField!=null)then
					pxField^.StartBurning(m_sPath,false);
				endif;
			endfor;
		endif;
	endproc;
	
	export proc bool IsAbleToFight()
		return false;
	endproc;
	
	proc void StopBurning()
		m_bBurning=false;
		AddSpecialActionTimer(m_sPath);
		SetGFX("ninigi_resin_field");
		StartTriggerTimer(1.0f);
		m_pxQuery^.SetEnabled(false);
		DeleteTimer(BURN_TIMER);
		DeleteTimer(INFECT_TIMER);
		StartDelayTimer(10.0);
	endproc;
	
	export proc void DoDamage()
		var CObjQuery xQuery;
		CSrvWrap.GetDiplomacyMgr().AddMyEnemiesToSearch(GetOwner(), xQuery);
		xQuery.SetType("ANML");
		xQuery.SetType("BLDG",true);
		xQuery.SetType("CHTR",true);
		xQuery.SetType("SHIP",true);
		xQuery.SetType("VHCL",true);
		xQuery.RegionCircle(GetPos(),GetHitRange());
		var CObjList xList;
		if(xQuery.Execute(xList))then
			var int i,iC=xList.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				var ^CFightingObj pxObj=cast<CFightingObj>(xList[i].GetObj());
				if(pxObj==null)then continue; endif;
//				pxObj^.ClearDamageCache();
				pxObj^.TakeDmg(this,false);
			endfor;
		endif;
	endproc;
	
	export proc void Activate()
		super.Activate();
//		OnHide();
	endproc;
	
	export proc bool OnTrap(CObjHndl p_xHndl)
		return false;
	endproc;
	
	export proc bool OnTick(CObjHndl p_xObj)
		return false;
	endproc;
	
	export proc bool OnRelease(CObjHndl p_xObj)
		return false;
	endproc;
	
	export proc void IgniteBuilding(real p_fDmg, int p_iMaxCount, CObjHndl p_xSource, int p_iSource)
		return;
	endproc;
	
	//Henry: HACK
	export proc void SetGFX(string p_sString)
		if(m_bBurning)then
			super.SetGFX("ninigi_resin_field_fire");
		else
			super.SetGFX("ninigi_resin_field");
		endif;
	endproc;
	
endclass;

class CResinField inherit CTrap

endclass;

class CQuicksand inherit CTrap
	
	const real	LIFETIME			= 30.0f;		// in seconds
	const real	RADIUS				= 10.0f;		// in meter
//	const real	TRAPPED_TIME	= 10.0f;		// in seconds
	const real	TRAPPED_TIME	= 7.0f;		// in seconds
//	const real	LIFETIME			= 10.0f;		// in seconds
//	const real	TRAPPED_TIME	= 5.0f;		// in seconds
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		m_bHidden=true;
		m_fDuration=TRAPPED_TIME;
		SetTrapRadius(RADIUS);
		m_pxQuery^.ClearTypes();
		m_pxQuery^.AddType("CHTR");
		m_pxQuery^.AddType("ANML");
		m_pxQuery^.AddType("VHCL");
		m_pxQuery^.AddType("SHIP");
		m_pxQuery^.SetProcs(OnHoldTrap,OnHoldRelease);
		AddRangedBuff("owner_hold_units");
		SetHitable(false);
		SetSelectable(false);
		if(!p_bLoad)then
			SetVisible(true);
		endif;
		StartDeleteTimer(LIFETIME);
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		var int i, iCountRunningEffects=m_apxRunningEffects.NumEntries();
		for(i=0)cond(i<iCountRunningEffects)iter(i++)do
			var ^CTrap.CTrapEffect pxTE=m_apxRunningEffects[i];
			if(pxTE!=null)then
				pxTE^.SetProcs(OnHoldTrap,OnHoldRelease);
				pxTE^.ReInit();
			else
				m_apxRunningEffects.DeleteEntry(i);
				i--; iCountRunningEffects--;
				continue;
//				return;
			endif;
		endfor;
	endproc;
	
	export proc void IgniteBuilding(real p_fDmg, int p_iMaxCount, CObjHndl p_xSource, int p_iSource)
		return;
	endproc;
	
	export proc bool CreateBuildingCorpse()
		return true;
	endproc;

	export proc string GetReportCode()
		return "";
	endproc;
	
endclass;

class CHuMudPit inherit CTrap
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetTrapRadius(12.0f);
		m_pxQuery^.ClearTypes();
		m_pxQuery^.AddType("CHTR");
		m_pxQuery^.AddType("ANML");
		m_pxQuery^.AddType("VHCL");
		m_pxQuery^.AddType("FGHT");
		m_pxQuery^.SetProcs(OnTrap, OnRelease);
		AddRangedBuff("owner_less_attack_speed");
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		if(m_bBuildingReady)then
			if(GetClassName()=="hu_mud_pit")then
				var vec3 vPos=GetPos();
				vPos.SetZ(CSrvWrap.GetScapeMgr().GetHeight(vPos.GetX(),vPos.GetY())+0.5f);
				SetPos(vPos);
			endif;
		endif;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		var int i, iCountRunningEffects=m_apxRunningEffects.NumEntries();
		for(i=0)cond(i<iCountRunningEffects)iter(i++)do
			var ^CTrap.CTrapEffect pxTE=m_apxRunningEffects[i];
			if(pxTE!=null)then
				pxTE^.SetProcs(OnTrap,OnRelease);
				pxTE^.ReInit();
			else
				m_apxRunningEffects.DeleteEntry(i);
				i--; iCountRunningEffects--;
				continue;
//				return;
			endif;
		endfor;
	endproc;
	
	export proc bool OnTrap(CObjHndl p_xHndl)
		var ^CFightingObj pxObj=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxObj==null)then return false; endif;
		if(pxObj^.IsFlyingUnit())then return false; endif;
		if(pxObj^.IsWildAnimal()&&pxObj^.GetOwner()==-1&&pxObj^.GetTechTreeAggressiv()!=1)then return false; endif;
		var ^CGameObj pxCurEnemy=pxObj^.GetCurEnemy().GetObj();
		if(pxCurEnemy==this)then
			return false;
		endif;
		if(pxObj^.GetTransportObj().IsValid()||pxObj^.GetOnWall())then return false; endif;
		if(!pxObj^.CanWalk())then return false; endif;
		pxObj^.SetBrokenLegs(true,45.0f);
		return true;
	endproc;
	
	export proc bool OnRelease(CObjHndl p_xObj)
		StartTriggerTimer(4.0f);
		return true;
	endproc;
	
endclass;

class CPitfall inherit CTrap
	
	const real DAMAGE=350.0;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetTrapRadius(5.0f);
		m_fDuration=1.0f;
		m_pxQuery^.SetOneTime(true);
		m_pxQuery^.AddType("CHTR");
		m_pxQuery^.AddType("ANML");
		m_pxQuery^.AddType("VHCL");
		m_pxQuery^.AddType("SHIP");
		m_pxQuery^.SetProcs(OnTrap, OnRelease);
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		var int i, iCountRunningEffects=m_apxRunningEffects.NumEntries();
		for(i=0)cond(i<iCountRunningEffects)iter(i++)do
			var ^CTrap.CTrapEffect pxTE=m_apxRunningEffects[i];
			if(pxTE!=null)then
				pxTE^.SetProcs(OnTrap,OnRelease);
				pxTE^.ReInit();
			else
				m_apxRunningEffects.DeleteEntry(i);
				i--; iCountRunningEffects--;
				continue;
//				return;
			endif;
		endfor;
	endproc;
	
	export proc bool OnTrap(CObjHndl p_xHndl)
		var ^CFightingObj pxFight=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxFight==null)then return false; endif;
		if(pxFight^.IsFlyingUnit())then return false; endif;
		if(pxFight^.IsWildAnimal()&&pxFight^.GetOwner()==-1&&pxFight^.GetTechTreeAggressiv()!=1)then return false; endif;
		if(pxFight^.GetTransportObj().IsValid()||pxFight^.GetOnWall())then return false; endif;
		if(!pxFight^.CanWalk())then return false; endif;
		var ^CGameObj pxCurEnemy=pxFight^.GetCurEnemy().GetObj();
		if(pxCurEnemy==this)then
			return false;
		endif;
		if(HasAnim("attack_front"))then
			SetAnim("attack_front",1);
		endif;
		pxFight^.TakeDmg(this,false);
		OnReveal();
		return true;
//		return false;
	endproc;
	
	export proc bool OnRelease(CObjHndl p_xHndl)
		if(m_xTechTree.GetValueB("/Objects/Ninigi/InventObjects/ninigi_trap_upgrade/invented",false))then
			StartDelayTimer(3.0);
		else
			StartDelayTimer(6.0);
		endif;
		m_pxQuery^.SetEnabled(false);
		return true;
	endproc;
	
	export proc string GetTrappedAnim()
		return "idle_4";
	endproc;
	
	proc void Activate()
		if(HasAnim("reload"))then
			SetAnim("reload",1);
		endif;
		super.Activate();
//		OnHide();
		StartTriggerTimer(1.0f);
		return();
	endproc;
	
endclass;

class CMinefield inherit CTrap
	
	const real CENTER_DAMAGE=200.0;
	const real EDGE_DAMAGE=100.0;
	const real RADIUS=10.0;
	const int TIMER_MINE_BOOM=40186;
	var bool m_bHaraKiri;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetTrapRadius(3.0f);
		m_fDuration=1.0f;
		m_pxQuery^.SetOneTime(true);
		m_pxQuery^.AddType("CHTR");
		m_pxQuery^.AddType("ANML");
		m_pxQuery^.AddType("VHCL");
		m_pxQuery^.AddType("SHIP");
		m_pxQuery^.SetProcs(OnTrap, OnRelease);
		m_bHaraKiri=false;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		var int i, iCountRunningEffects=m_apxRunningEffects.NumEntries();
		for(i=0)cond(i<iCountRunningEffects)iter(i++)do
			var ^CTrap.CTrapEffect pxTE=m_apxRunningEffects[i];
			if(pxTE!=null)then
				pxTE^.SetProcs(OnTrap,OnRelease);
				pxTE^.ReInit();
			else
				m_apxRunningEffects.DeleteEntry(i);
				i--; iCountRunningEffects--;
				continue;
//				return;
			endif;
		endfor;
	endproc;
	
	export proc bool OnTrap(CObjHndl p_xHndl)
		var ^CFightingObj pxFO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxFO!=null)then
			if(pxFO^.IsWildAnimal()&&pxFO^.GetOwner()==-1&&pxFO^.GetTechTreeAggressiv()!=1)then return false; endif;
			var ^CGameObj pxCurEnemy=pxFO^.GetCurEnemy().GetObj();
			if(pxCurEnemy==this)then
				return false;
			endif;
		endif;
//		var ^CObjList pxEnemies=CSrvWrap.GetObjMgr()^.GetOwnerEnemyList(GetOwner());
//		if(pxEnemies==null)then return false; endif;
//		var CObjList xList;
//		pxEnemies^.CopySorted(xList,GetPos(),RADIUS);
//		var ^CAreaDamage pxDmg=new CAreaDamage(this, GetPos());
//		var string sSetting=CSrvWrap.GetCurLevel()^.GetLevelInfo().GetAttribs().GetValue("Setting");
//		if(sSetting=="Northland")then
//			sSetting="nor";
//		elseif(sSetting=="Savanna")then
//			sSetting="sav";
//		elseif(sSetting=="Jungle")then
//			sSetting="jng";
//		elseif(sSetting=="Icewaste")then
//			sSetting="ice";
//		elseif(sSetting=="Ashvalley")then
//			sSetting="ash";
//		else
//			sSetting="sav";
//		endif;
//		AddFX("hit_land_"+sSetting+"_explo_big",2.0);
//		SetIsVanished(true);
		SetHitable(false);
		OnReveal();
		Die();
		return true;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==TIMER_MINE_BOOM)then
				DeleteTimer(TIMER_MINE_BOOM);
				Delete();
				return;
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			return super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	export proc void Die()
		if(HasTimer(TIMER_MINE_BOOM))then return; endif;
		if(m_bBuildingReady&&!m_bHaraKiri)then
//			InvokeGenericSCEvent(27,2.0f);
			if(m_xTechTree.GetValueB("/Objects/Ninigi/InventObjects/ninigi_trap_upgrade/invented",false))then
				CMirageSrvMgr.CreateCustomFX(10,GetPos(),true);
			else
				CMirageSrvMgr.CreateCustomFX(9,GetPos(),true);
			endif;
//			var ^CAreaDamage pxDmg=new CAreaDamage(this, "/Objects/Ninigi/Weapons/ninigi_minefield_weapon", GetPos());
			var ^CAreaDamage pxDmg=new CAreaDamage("/Objects/Ninigi/Weapons/ninigi_minefield_weapon", RADIUS, CENTER_DAMAGE, EDGE_DAMAGE, GetOwner(), GetPos(), 10);
//			if(m_pxQuery!=null)then
//				m_pxQuery^.SetEnabled(false);
//			endif;
//			while(m_apxRunningEffects.NumEntries()>0)do
//				if(m_apxRunningEffects[0]!=null)then
//					m_apxRunningEffects[0]^.OnRelease();
//				endif;
//			endwhile;
			CBLDGMgr.Get().RemoveBuilding(this);
			CBLDGMgr.Get().RemoveClass(GetLimitClass(),GetTribeName(),GetOwner());
			if(m_bBuildingReady)then
				CBLDGConditionsMgr.Get().DeleteBuilding(this);
			endif;
			SimpleNewDie();
			CreateTimer(TIMER_MINE_BOOM,CGameTimeSpan.OneSecond()*1.5f,false);
			return;
		else
			return super.Die();
		endif;
	endproc;
	
	export proc void DiePerHarakiri()
		if(IsDestructible())then return; endif;
		m_bHaraKiri=true;
		return super.DiePerHarakiri();
	endproc;
	
//	export proc void Delete()
//		var ^CAreaDamage pxDmg=new CAreaDamage(this, "/Objects/Ninigi/Weapons/ninigi_watermine_weapon", GetPos());
//		super.Delete();
//	endproc;

	export proc bool OnRelease(CObjHndl p_xHndl)
//		StartDelayTimer(4.0);
//		StartTriggerTimer(2.0f);
		m_pxQuery^.SetEnabled(false);
		return true;
	endproc;
	
	export proc string GetTrappedAnim()
		return "idle_4";
	endproc;
	
	proc void Activate()
		super.Activate();
//		OnHide();
	endproc;
	
endclass;

class CSnareTrap inherit CTrap
	
	const real DAMAGE_PER_SECOND=5.0;
	var int m_iState;
	var CObjHndl m_xLastVictimHndl;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		m_xLastVictimHndl=CObjHndl.Invalid();
		SetTrapRadius(3.0f);
		m_fDuration=9999999.0f;
		m_pxQuery^.SetOneTime(true);
		m_pxQuery^.ClearTypes();
		m_pxQuery^.AddType("CHTR");
		m_pxQuery^.SetProcs(OnHoldTrap,OnHoldRelease,OnTick);
		m_iState=0;
		AddRangedBuff("owner_hold_units");
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		var int i, iCountRunningEffects=m_apxRunningEffects.NumEntries();
		for(i=0)cond(i<iCountRunningEffects)iter(i++)do
			var ^CTrap.CTrapEffect pxTE=m_apxRunningEffects[i];
			if(pxTE!=null)then
				pxTE^.SetProcs(OnHoldTrap,OnHoldRelease,OnTick);
				pxTE^.ReInit();
			else
				m_apxRunningEffects.DeleteEntry(i);
				i--; iCountRunningEffects--;
				continue;
//				return;
			endif;
		endfor;
		if(iCountRunningEffects>0)then
			m_pxQuery^.m_bAlreadyReleased=true;
		endif;
	endproc;
	
	export proc void OnActionEnd(bool p_bBroken)
		if(m_iState==0)then
			//hanging anim for trap
			SetAnim("hanging",3);
			if(m_xLastVictimHndl.IsValid())then
				var ^CFightingObj pxFO=cast<CFightingObj>(m_xLastVictimHndl.GetObj());
				//hanging anim for victim
				if(pxFO!=null)then
					pxFO^.SetAnim(GetTrappedAnim(),3);
				endif;
			endif;
		else
			SetAnim("standanim",3);
		endif;
	endproc;
	
	export proc string GetReleaseAnim()
		return "all_snar_trap_end";
	endproc;
	
	export proc string GetCatchAnim()
		return "all_snar_trap_catching";
	endproc;
	
	export proc string GetDieInTrapAnim()
		return "snare_trap_dying";
	endproc;
	
	export proc void SetReady()
		AnimAction("bending");
		m_iState=1;
		super.SetReady();
	endproc;
	
	export proc bool OnHoldRelease(CObjHndl p_xObj)
		m_xLastVictimHndl=CObjHndl.Invalid();
		StartDelayTimer(1.5f);
		AnimAction("bending");
		m_iState=1;
		var ^CCharacter pxChar=cast<CCharacter>(p_xObj.GetObj());
		if(pxChar!=null)then
			pxChar^.ShowWeapons();
			pxChar^.SetAnim(GetReleaseAnim(),1);
		endif;
//		OnHide();
		StartTriggerTimer(1.5f);
		return super.OnHoldRelease(p_xObj);
	endproc;
	
	export proc bool OnHoldTrap(CObjHndl p_xObj)
		if(HPReachedZero())then return false; endif;
		m_xLastVictimHndl=p_xObj;
		AnimAction("catching");
		m_iState=0;
		var ^CGameObj pxO=p_xObj.GetObj();
		if(pxO==null)then return false; endif;
		var ^CFightingObj pxFO=cast<CFightingObj>(pxO);
		if(pxFO!=null)then
			var ^CGameObj pxCurEnemy=pxFO^.GetCurEnemy().GetObj();
			if(pxCurEnemy==this)then
				return false;
			endif;
		endif;
		pxO=pxO^.GetGroupedParentObj();
		var ^CCharacter pxChar=cast<CCharacter>(pxO);
		if(pxChar!=null)then
			var ^CGameObj pxT=pxChar^.GetTransportObj().GetObj();
			if(pxT==null&&!pxChar^.GetOnWall())then
				pxChar^.TerminateAction();
				pxChar^.SetTrappedHandle(GetHandle());
				pxChar^.HideWeapons();
				pxChar^.SetAnim(GetCatchAnim(),1);
				var CFourCC xL="we";
				pxChar^.LinkAction(GetHandle(),xL);
				var vec3 vRot={0.0,0.0,0.0};
				vRot.SetY(3.14f);
				var Quat qRot;
				qRot.FromVec3(vRot);
				pxChar^.SetRot(qRot);
				return true;
			endif;
			OnReveal();
		endif;
		return false;
	endproc;
	
	export proc bool OnTick(CObjHndl p_xObj)
		m_xLastVictimHndl=p_xObj;
		var ^CGameObj pxO=p_xObj.GetObj();
		if(pxO!=null)then
			// deal direct damage to unit in trap and notify this unit who dealt the damage (skulls calculation)
			cast<CFightingObj>(pxO)^.TakeDmg(this,false);
			OnReveal();
			return true;
//		else
//			if(m_iState==0)then
//				StartDelayTimer(1.5f);
//				AnimAction("bending");
//				m_iState=1;
//				StartTriggerTimer(1.5f);
//			endif;
		endif;
		return false;
	endproc;
	
	export proc void TrapFound(int p_iOwner)
		if(GetOwner()==p_iOwner)then return; endif;
		m_bOnHidden=false;
//		if(!m_xLastVictimHndl.IsValid())then
//			var CFightingObj.CCamouflageLayer xLayer;
//			xLayer.SetType("smok");
//			var int iIdx=m_axCamouflageLayers.FindEntry(xLayer);
//			if(iIdx!=-1 && m_axCamouflageLayers[iIdx].IsValid() && !m_axCamouflageLayers[iIdx].IsOffline())then
//				return;
//			endif;
//		endif;
		SwitchTrapCamouflage(false);
//		SetVisible(true);
		return;
	endproc;
	
	export proc void OnReveal()
		m_bOnHidden=false;
//		var CFightingObj.CCamouflageLayer xLayer;
//		if(!m_xLastVictimHndl.IsValid())then
//			xLayer.SetType("smok");
//			var int iIdx=m_axCamouflageLayers.FindEntry(xLayer);
//			if(iIdx!=-1 && m_axCamouflageLayers[iIdx].IsValid() && !m_axCamouflageLayers[iIdx].IsOffline())then
//				return;
//			endif;
//		endif;
		SwitchTrapCamouflage(false);
//		var bitset dwBitset=011111111b;
//		SetVisibleMask(dwBitset);
		return;
	endproc;
	
	proc void Activate()
		super.Activate();
//		OnHide();
	endproc;
	
	export proc string GetTrappedAnim()
		return "all_snar_trap_hanging";
	endproc;

endclass;

class CMarketplace inherit CWarehouse
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
	endproc;

endclass;

class CHarbour inherit CBuilding

//	var CObjList				m_xDockedShips;
	var int								m_iMaxShipsInDock;
	var int								m_iShipsInConstruction;
	var array CObjHndl		m_axDockedShips;
	var int								m_iNumDockedShips;
	var CObjHndl					m_xCraneObj1;
	var CObjHndl					m_xCraneObj2;
	var CObjHndl					m_xHarbourCrane;
	var bool							m_bMarketplace;
	
	var array CTradingOrder	m_axTradingOrders;
	
	export proc void IgniteBuilding(real p_fDmg, int p_iMaxCount, CObjHndl p_xSource, int p_iSource)
		return;
	endproc;
	
	export constructor()
		m_iMaxShipsInDock=1;
		m_axDockedShips=1;
		m_iShipsInConstruction=0;
		m_iNumDockedShips=0;
	endconstructor;
	
	export destructor()
		if(m_xCraneObj1.IsValid())then m_xCraneObj1.GetObj()^.Delete();endif;
		if(m_xCraneObj2.IsValid())then m_xCraneObj2.GetObj()^.Delete();endif;
		if(m_xHarbourCrane.IsValid())then m_xHarbourCrane.GetObj()^.Delete();endif;
	enddestructor;
	
	export proc void OnInit(bool p_bLoad)
		m_bHealthBuilding=true;
		super.OnInit(p_bLoad);
		SetRallySite(true);
		// overwrite types in objquery used for healing
		m_xFunctionUnits.SetType("SHIP"); // ... this are Ships ...
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("IsHarbour", 1);
			pxAttr^.SetValue("fishDelivery",true);
		endif;
		var int iNumDocks=0;
		var vec3 vDummy;
		var CFourCC xLink;
		var int i;
		for(i=1)cond(i<6)iter(i++)do
			xLink="Do_"+i.ToString();
			if(!GetLinkPosObj(xLink, vDummy))then
				iNumDocks=i-1;
				break;
			endif;
		endfor;
		if(iNumDocks<2)then iNumDocks=2; endif;
		//KLog.LogSpam("Harbour", "Number of docks:"+iNumDocks.ToString());
		m_iMaxShipsInDock=iNumDocks;
		m_axDockedShips=iNumDocks;
		for(i=0)cond(i<m_iMaxShipsInDock)iter(i++)do
			m_axDockedShips[i]=CObjHndl.Invalid();
		endfor;
		AddRangedBuff("owner_healing_harbour");
	endproc;
	
	export proc void SetReady()
		if(HasAnim("standanim"))then
			SetAnim("standanim",3);
		endif;
		if(GetTribeName()=="Hu")then
			if(!m_xHarbourCrane.IsValid())then
				var ^CGameObj pxHarbourCrane=CSrvWrap.GetObjMgr()^.CreateObj("hu_harbour_crane",GetOwner(),GetPos());
				if(pxHarbourCrane!=null)then
					m_xHarbourCrane=pxHarbourCrane^.GetHandle();
					var CFourCC xLink="Cr_3";
					pxHarbourCrane^.LinkAction(GetHandle(),xLink);
				endif;
			endif;
		endif;
		UpdateDeliveries();
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("TradeBuilding",1);
		endif;
		super.SetReady();
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="Hrbr"; //Harbour base
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xCraneObj1.DoKArc(pxArc^);
		m_xCraneObj2.DoKArc(pxArc^);
		m_xHarbourCrane.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="Hrbr")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xCraneObj1.DoKArc(pxArc^);
			m_xCraneObj2.DoKArc(pxArc^);
			m_xHarbourCrane.DoKArc(pxArc^);
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void ShipBuildFinished()
		//m_iShipsInConstruction--;
		if(m_iShipsInConstruction<0)then
			m_iShipsInConstruction=0;
			KLog.LogWarn("Harbour", "There is something fishy in the harbour");
		endif;
	endproc;
	
	proc int GetFreeDockIndex()
		var int iIndex=-1;
		var int i;
		for(i=0)cond(i<m_iMaxShipsInDock)iter(i++)do
			if(!m_axDockedShips[i].IsValid())then
				iIndex=i+1;
				break;
			endif;
		endfor;
		//KLog.LogSpam("Harbour", "GetFreeDockIndex:"+iIndex.ToString());
		return iIndex;
	endproc;
	
	export proc bool GetDockPos(ref vec3 po_rvPos, ref Quat po_rqRot)
		var int iIndex=GetFreeDockIndex();
		if(iIndex>0)then
			var CFourCC xLink="Do_"+iIndex.ToString();
			return GetLinkPosRotWorld(xLink, po_rvPos, po_rqRot);
		else
			return false;
		endif;
	endproc;
	
	export proc CFourCC GetDockLink()
		var int iIndex=GetFreeDockIndex();
		if(iIndex>0)then
			var CFourCC xLink="Do_"+iIndex.ToString();
			return xLink;
		else
			var CFourCC xLink="";
			return xLink;
		endif;
	endproc;
	/*
	export proc bool CheckCanBuildAndIncrease(string p_sTTPath)
		if(p_sTTPath.Find("Build/SHIP")!=-1)then
			if(!HasFreeDocks())then
				CSrvWrap.SendGenericEvtToPlayer(GetOwner(), "Feedback\tHarbour is full!");
				return false;
			endif;
			//m_iShipsInConstruction++;
		endif;
		return true;
	endproc;
	
	export proc bool CanDeliver(string p_sClassName)
			if(!HasFreeDocks())then
				return false;
			endif;
		return super.CanDeliver(p_sClassName);
	endproc;
	
	export proc void Action(string p_sTTPath)
		//KLog.LogSpam("Harbour", "Enter Action()"+p_sTTPath);
		if(CheckCanBuildAndIncrease(p_sTTPath))then
			super.Action(p_sTTPath);
		endif;
		return;
	endproc;
	
	export proc void CheckCancelBuildDecrease(string p_sTTPath)
		if(p_sTTPath.Find("Build/SHIP")!=-1)then
			//m_iShipsInConstruction--;
			if(m_iShipsInConstruction<0)then
				m_iShipsInConstruction=0;
			endif;
		endif;
	endproc;
	
	export proc void CancelAction(string p_sTTPath)
		super.CancelAction(p_sTTPath);
		CheckCancelBuildDecrease(p_sTTPath);
	endproc;
	*/
	export proc void StartWorkAnim()
		//if(m_xCraneObj1.IsValid())then SetCraneAnim(m_xCraneObj1,true);endif;
		//if(m_xCraneObj2.IsValid())then SetCraneAnim(m_xCraneObj2,true);endif;
		if(m_xHarbourCrane.IsValid())then SetCraneAnim(m_xHarbourCrane,true);endif;
	endproc;
	
	export proc void StopWorkAnim()
		//if(m_xCraneObj1.IsValid())then SetCraneAnim(m_xCraneObj1,false);endif;
		//if(m_xCraneObj2.IsValid())then SetCraneAnim(m_xCraneObj2,false);endif;
		if(m_xHarbourCrane.IsValid())then SetCraneAnim(m_xHarbourCrane,false);endif;
	endproc;
	
	proc bool SetCraneAnim(CObjHndl p_xCraneHandle, bool p_bStart)
		var ^CGameObj pxCrane=p_xCraneHandle.GetObj();
		if(pxCrane!=null)then
			if(p_bStart)then
				if(pxCrane^.GetCurrentAnimName()!=WORK_ANIM_NAME&&pxCrane^.HasAnim(WORK_ANIM_NAME))then
					pxCrane^.SetAnim(WORK_ANIM_NAME,3);
					return(true);
				else
					return(false);
				endif;
			else
				if(pxCrane^.GetCurrentAnimName()==WORK_ANIM_NAME)then
					pxCrane^.EndCurrentLoopAnim();
					return(true);
				else
					return(false);
				endif;
			endif;
		else
			return(false);
		endif;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(p_sCommand=="SetRallyPoint")then
			var bool bHarbour=false;
			var vec3 vPos=p_vPos;
			var CObjHndl xRallyTarget=CObjHndl.Invalid();
			if(p_pxObject!=null)then
				var string sName=p_pxObject^.GetClassName();
				bHarbour=(sName=="aje_floating_harbour"||sName=="hu_harbour"||sName=="ninigi_harbour"||sName=="seas_carrier");
				var CFourCC xLink="Ex_1";
				if(!p_pxObject^.GetLinkPosWorld(xLink,vPos))then
					vPos=p_pxObject^.GetPos();
				endif;
				xRallyTarget=p_pxObject^.GetHandle();
			endif;
			if(p_vPos.GetZ() > CSrvWrap.GetScapeMgr().GetSeaLevel() && !bHarbour)then
				CSrvWrap.SendGenericEvtToPlayer(GetOwner(), "Feedback\tSet RallyPoint on water!");
			else
				SetRallyPoint(p_vPos,xRallyTarget);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	/*
	export proc bool AddDockedShip(^CGameObj p_pxShip, CFourCC p_xLink)
		//KLog.LogSpam("Harbour", "AddDockedShip() at:"+p_xLink.AsString());
		if(p_pxShip!=null)then
			if(m_iNumDockedShips >= m_iMaxShipsInDock)then return false; endif;
			var string sDock=p_xLink.AsString();
			var int iDock=(sDock.Mid(3)).ToInt() - 1;
			if(iDock<0)then return false; endif;
			if(iDock>=m_iMaxShipsInDock)then return false; endif;
			if(m_axDockedShips[iDock].IsValid())then
				return false;
			endif;
			m_axDockedShips[iDock]=p_pxShip^.GetHandle();
			m_iNumDockedShips++;
			//KLog.LogSpam("Harbour", "AddDockedShip() at:"+iDock.ToString());
			return true;
		endif;
		return false;
	endproc;
	
	export proc void RemDockedShip(^CGameObj p_pxShip)
		if(p_pxShip!=null)then
			var CObjHndl xHandle=p_pxShip^.GetHandle();
			var int i;
			for(i=0)cond(i<m_iMaxShipsInDock)iter(i++)do
				if(m_axDockedShips[i]==xHandle)then
					m_axDockedShips[i]=CObjHndl.Invalid();
					m_iNumDockedShips--;
					var CFourCC xLink="Do_"+(i+1).ToString();
					var vec3 vPos;
					var Quat qRot;
					GetLinkPosRotWorld(xLink, vPos, qRot);
					p_pxShip^.SetPos(vPos);
					p_pxShip^.SetRot(qRot);
					//L KLog.LogSpam("Harbour", "RemDockedShip() at:"+i.ToString());
					return;
				endif;
			endfor;
		endif;
	endproc;
	
	export proc bool HasFreeDocks()
		if(m_iNumDockedShips<m_iMaxShipsInDock)then
			return true;
		endif;
		return false;
	endproc;
*/
endclass;

class CVirtualProduceUnit inherit CBuilding
	
	export var CObjHndl m_xParent;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetCanWalk(false);
		SetCanSwim(false);
		SetCanFly(false);
		SetHitable(false);
		SetSelectable(false);
		SetVisible(false);
		SetPlaceBlocker(false);
		if(!p_bLoad)then
			SetCanFightAttrib(false);
		endif;
	endproc;
	
	proc void OnActionStart()
		return;
	endproc;
	
	export proc void Die()
		Delete();
	endproc;
	
	export proc void Init(CObjHndl p_xParent)
		m_xParent=p_xParent;
		var CFourCC xLink="NONE";
		LinkAction(m_xParent, xLink);
		SetSelectable(false);
		SetVisible(false);
	endproc;
	
	export proc void Init(CObjHndl p_xParent, string p_sParentClass, string p_sTribe)
		m_xParent=p_xParent;
		SetTribeName(p_sTribe);
		// Henry: linking to the parent causes time gap in unitproduction...
		if(p_sParentClass!="seas_barracks" && p_sParentClass!="seas_headquarters" && p_sParentClass!="seas_garage"
		&& p_sParentClass!="seas_laboratory" && p_sParentClass!="seas_fortress" && p_sParentClass!="seas_jail_part_01"
		&& p_sParentClass!="seas_jail_part_02")then
			var CFourCC xLink="NONE";
			LinkAction(p_xParent, xLink);
		endif;
		SetSelectable(false);
		SetVisible(false);
	endproc;
	
	export proc bool IsAbleToWalk()
		return false;
	endproc;
	
	export proc bool IsAbleToFight()
		return false;
	endproc;
	
	export proc void Damage(real p_fDamage)
		return;
	endproc;
	
	export proc void PoisonDamage(real p_fDamage, CObjHndl p_xEnemy, int p_iEnemy)
		return;
	endproc;
	
	export proc void BurnDamage(real p_fDamage, CObjHndl p_xEnemy, int p_iEnemy)
		return;
	endproc;
	
	export proc void ChainDamage(real p_fDamage, int p_iLast, CObjHndl p_xLast)
		return;
	endproc;
	
	export proc void WoundDamage(real p_fDamage, CObjHndl p_xLE, int p_iLE)
		return;
	endproc;
	
	export proc void Action(string p_sTTPath)
//		if(!m_bBuildingReady)then return; endif;
		var CObjHndl xPyCO;
		var CAction.CResourceCosts xCosts;
		var bool bCheck=false;
		var string sBefore, sAfter, sTribe;
		if(CRequirementsMgr.Get().CheckConditionsAndPayLimit(this, p_sTTPath, xPyCO, xCosts, true, sBefore, sAfter, bCheck, sTribe))then
			var ^CAction pxTask= cast<CAction>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"Action"));
//			if(pxTask==null)then return; endif;
//			pxTask^.Init(m_xParent,p_sTTPath, xCosts);
			if(pxTask==null)then return; endif;
			if(!pxTask^.InitReactored(m_xParent, p_sTTPath, xCosts, false, sBefore, sAfter, bCheck, sTribe))then
				pxTask^.GetFactory()^.FreeState(pxTask);
				return;
			endif;
			pxTask^.SetPyCO(xPyCO);
			AddTask(pxTask,true);
		endif;
	endproc;
	
	export proc void ActionReactored(string p_sTTPath)
		var CObjHndl xPyCO;
		var CAction.CResourceCosts xCosts;
		var bool bCheck=false;
		var string sBefore, sAfter, sTribe;
		if(CRequirementsMgr.Get().CheckConditionsAndPayLimit(this, p_sTTPath, xPyCO, xCosts, true, sBefore, sAfter, bCheck, sTribe))then
			var ^CAction pxTask= cast<CAction>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"Action"));
			if(pxTask==null)then return; endif;
			if(!pxTask^.InitReactored(m_xParent, p_sTTPath, xCosts, true, sBefore, sAfter, bCheck, sTribe))then
				pxTask^.GetFactory()^.FreeState(pxTask);
				return;
			endif;
			pxTask^.SetPyCO(xPyCO);
			AddTask(pxTask,true);
		endif;
		return;
	endproc;
	
	export proc bool ActionTowerVPU(string p_sTTPath)
//		if(!m_bBuildingReady)then return false; endif;
		var CObjHndl xPyCO;
		var CAction.CResourceCosts xCosts;
		var bool bCheck=false;
		var string sBefore, sAfter, sTribe;
		if(CRequirementsMgr.Get().CheckConditionsAndPayLimit(this, p_sTTPath, xPyCO, xCosts, true, sBefore, sAfter, bCheck, sTribe))then
			var ^CAction pxTask= cast<CAction>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"Action"));
			if(pxTask==null)then return false; endif;
			if(!pxTask^.InitReactored(m_xParent, p_sTTPath, xCosts, true, sBefore, sAfter, bCheck, sTribe))then
				pxTask^.GetFactory()^.FreeState(pxTask);
				return false;
			endif;
			pxTask^.SetPyCO(xPyCO);
			AddTask(pxTask,true);
		else
			return false;
		endif;
		return true;
	endproc;
	
	export proc void BuildDownParent(string p_sPath)
		if(!m_bBuildingReady)then return; endif;
		if(m_pxTaskMgr==null)then return; endif;
		var int i,iC=m_pxTaskMgr^.NumSubs();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CBuildDownBuilding pxBldDown=cast<CBuildDownBuilding>(m_pxTaskMgr^.GetSubState(i));
			if(pxBldDown!=null)then
				return;
			endif;
		endfor;
		var ^CBuildDownBuilding pxTask=cast<CBuildDownBuilding>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"BldDownB"));
		if(pxTask==null)then return; endif;
		if(pxTask^.InitVPU(m_xParent,p_sPath))then
			AddTask(pxTask,true);
		else
			pxTask^.GetFactory()^.FreeState(pxTask);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="ViPU";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xParent.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="ViPU")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xParent.DoKArc(pxArc^);
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		var string sObjName=GetName();
		var string sParentName="Invalid";
		var string sObjPos=GetPos().ToString();
		if(m_xParent.IsValid())then
			sParentName=m_xParent.GetObj()^.GetName();
		endif;
		var string sMessage ="CVirtualProduceUnit name='"+sObjName+"' parent='"+sParentName+"' pos='"+sObjPos+"'";
		if(!m_xParent.IsValid())then
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			System.Assert(pxLevel!=null);
			if(pxLevel^.IsEditable())then
				Windows.DbgPrint("DETECTED orphant virtual produce unit: "+sMessage);
				if(Windows.MessageBox("Orphant CVirtualProduceUnit detected",sMessage+"\n\n	Delete Object?",050004h)==6)then
					Windows.DbgPrint("DELETED orphant virtual produce unit: "+sMessage);
					Delete();
					return;
				endif;
			endif;
		endif;
		GetFSM()^.Enable(true);
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
//		if(!m_bBuildingReady)then
//			return;
//		else
			super.ReactToGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams, p_bQ, p_bS, p_bA);
//		endif;
	endproc;
	
	export proc CObjHndl GetParent()
		return m_xParent;
	endproc;
	
	export proc void SetPFBlocking()
	endproc;
	
	export proc CObjHndl GetCreatorHandle()
		return m_xParent;
	endproc;
	
	export proc void IgniteBuilding(real p_fDmg, int p_iMaxCount, CObjHndl p_xSource, int p_iSource)
		return;
	endproc;
	
	export proc void BreakTasks()
		if(m_pxTaskMgr!=null)then
			m_pxTaskMgr^.BreakAll();
		endif;
	endproc;
	
endclass;

class CBunker inherit CTower
	
	var CObjList m_xChars;
	var bool m_bAboutToDie; // Henry: it is about to die, passengers shouldn't be mounted
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="BUba"; //Bunker base
		var int iVersion=3;
		if(CMirageSrvMgr.SDK())then
			iVersion=2;
		endif;
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,iVersion);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xChars.DoKArc(pxArc^);
		if(iVersion>=3)then
			pxArc^ << m_bAboutToDie;
		endif;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="BUba")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			if(iVersion>=2)then
				m_xChars.DoKArc(pxArc^);
			endif;
			if(iVersion>=3)then
				pxArc^ << m_bAboutToDie;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetCanWalk(false);
		SetCanSwim(false);
		SetCanFly(false);
		SetRallySite(false);
		if(!p_bLoad)then
			SetTransportClass(1);
		endif;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("max_passengers",m_xTechTree.GetValueI(GetObjPath()+"/max_passengers",4));
		endif;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(p_sMiscParams.Find("/DismountAll")!=-1)then
			DismountAll();
			return;
		elseif(p_sMiscParams.Find("/Dismount")>=0)then
			if(p_pxObject!=null)then
				RemChar(p_pxObject^.GetHandle());
			endif;
		endif;
		super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
	endproc;
	
	export proc void AddChar(CObjHndl p_xO)
		if(m_bAboutToDie)then return; endif;
		if(p_xO.IsValid() && m_xChars.FindEntry(p_xO)<0 && m_xChars.NumEntries()<m_xTechTree.GetValueI(GetObjPath()+"/max_passengers",4))then
			m_xChars.Include(p_xO);
			var ^CCharacter pxC=cast<CCharacter>(p_xO.GetObj());
			if(pxC!=null)then
				var CFourCC xL="NOPE";
				pxC^.LinkAction(GetHandle(), xL);
				pxC^.SetPos(GetPos());
				pxC^.SetVisible(false);
				pxC^.SetSelectable(false);
				pxC^.SetTransportObj(GetHandle());
			endif;
			UpdateCharsAttr();
		endif;
	endproc;
	
	export proc void RemChar(CObjHndl p_xO)
		if(m_xChars.RemEntry(p_xO))then
			var ^CCharacter pxC=cast<CCharacter>(p_xO.GetObj());
			if(pxC!=null)then
				pxC^.SetTransportObj(CObjHndl.Invalid());
				var vec3 vPos=GetPos();
				vPos.SetZ(CSrvWrap.GetScapeMgr().GetHeight(vPos.GetX(),vPos.GetY()));
				pxC^.SetPos(vPos);
				pxC^.SetVisible(true);
				pxC^.SetSelectable(true);
				var vec3 vP;
				CSrvWrap.GetObjMgr()^.GetFreePos(vP,this,GetPos(),null,true,false,false);
//				pxC^.GoTo(vP,true,pxC^.GetDefaultSpeed(),true,true);
				var CFourCC xWalkSet = pxC^.GetWalkSet();
				pxC^.WalkAction(vP, pxC^.GetMaxSpeed(), true, true, null, xWalkSet, true);
			endif;
			UpdateCharsAttr();
		endif;
	endproc;
	
	export proc void DismountAll()
		while(m_xChars.NumEntries() > 0)do
			RemChar(m_xChars[0]);
		endwhile;
	endproc;
	
	proc void UpdateCharsAttr()
		var string sM="";
		var int i, iC=m_xChars.NumEntries();
		for(i=0) cond(i<iC) iter(++i)do
			var ^CGameObj pxO=m_xChars[i].GetObj();
			if(pxO!=null)then
				sM += pxO^.GetGuid().ToString()+"\n";
			endif;
		endfor;
		var ^CAttribs pxA=GetAttribs();
		if(pxA!=null)then
			pxA^.SetValue("passenger_guids", sM);
			pxA^.SetValue("registered_passengers", iC);
		endif;
	endproc;
	
	export proc void UpdateGfxFlags()
		if(GetClassName()=="hu_bunker")then
			var bool bNeosSteelFrameInvented=CRequirementsMgr.Get().CheckInvention(this, GetOwner(), "hu_bunker_upgrade", GetTribeName());
			if(bNeosSteelFrameInvented)then
				var ^CAttribs pxAttr=GetAttribs();
				if(pxAttr!=null)then
					pxAttr^.SetValue("max_passengers",m_xTechTree.GetValueI(GetObjPath()+"/max_passengers",8));
				endif;
			endif;
		endif;
	endproc;
	
	export proc void SetReady()
		super.SetReady();
	endproc;
	
	export proc void Die()
		while(m_xChars.NumEntries() > 0)do
			RemChar(m_xChars[0]);
		endwhile;
		super.Die();
	endproc;
	
	export proc bool AttackEnemy(^CFightingObj p_pxEnemy, vec3 p_vTarget, ref bool p_rbRotated)
		if(IsBuildMode())then return false; endif;
		if(m_xChars.NumEntries() <= 0)then return false; endif;
		if(GetProjectile()!="" && p_pxEnemy!=null)then
			if(p_pxEnemy^.IsFlyingUnit() && !CanShootAir())then return false; endif;
			var int i, iC=m_xChars.NumEntries();
			for(i=0) cond(i<iC) iter(++i)do
				var ^CArrow pxArrow=cast<CArrow>(CSrvWrap.GetObjMgr()^.CreateObj(GetProjectile(),GetOwner(),GetProjectileStartPos()));
				if(pxArrow!=null)then
					pxArrow^.SetXtraDelay(this, p_pxEnemy, 1.0f +0.1f * i.ToReal());
					pxArrow^.LinkAction(GetHandle(),GetProjectileLink());
				endif;
			endfor;
		endif;
		return false;
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy)
		return super.TakeDmg(p_pxEnemy);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile)
		return super.TakeDmg(p_pxEnemy, p_bProjectile);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, real p_fFactor)
		return super.TakeDmg(p_pxEnemy, p_fFactor);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile, real p_fFactor)
		return super.TakeDmg(p_pxEnemy, p_bProjectile, p_fFactor);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile, real p_fFactor, real p_fHitDelay)
		return super.TakeDmg(p_pxEnemy, p_bProjectile, p_fFactor, p_fHitDelay);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile, real p_fFactor, real p_fHitDelay, real p_fArmorPiercing)
		var real fReturn=super.TakeDmg(p_pxEnemy, p_bProjectile, p_fFactor, p_fHitDelay, p_fArmorPiercing);
		if(GetClassName()=="hu_bunker" && fReturn==0.0)then
			//fReturn=10.0;
			fReturn =(m_xTechTree.GetValueR("MiscValues/Hu/Bunker_Damage",5.0));
		endif;
		return fReturn;
	endproc;
	
	export proc void LetLeavePassenger(CObjHndl p_xPassenger, int p_iEvent)
		if(!p_xPassenger.IsValid())then return; endif;
		RemChar(p_xPassenger);
		UnMountEvent(p_xPassenger, p_iEvent);
//		return;
	endproc;
	
	export proc void DiePerHarakiri()
		m_bAboutToDie=true;
		super.DiePerHarakiri();
	endproc;
	
	export proc string GetReportCode()
		return "defence";
	endproc;
	
endclass;

class CSeasCarrier inherit CSwimmingHarbour
	
	var int m_iBuildUpType;
	var ^CBuildUpBase m_pxBuildUp;
	
	export proc void SetReady()
		var ^CVirtualProduceUnit pxUnit=cast<CVirtualProduceUnit>(m_xReactor.GetObj());
		if(pxUnit!=null)then
			pxUnit^.SetReady();
		endif;
		pxUnit=cast<CVirtualProduceUnit>(m_xProduceUnit.GetObj());
		if(pxUnit!=null)then
			pxUnit^.SetReady();
		endif;
		super.SetReady();
		//SB#9309 HOTFIX moved from OnInit because non visible links corrupt selection circle and health bar rendering
		if(m_bBuildingReady && (m_pxBuildUp==null||m_iBuildUpType==CBuildUpBase.TYPE_NONE))then
			m_iBuildUpType=CBuildUpBase.TYPE_WEAPON;
			m_pxBuildUp=CBuildUpFactory.Get().CreateBuildUp(m_iBuildUpType);
			m_pxBuildUp^.SetParent(GetHandle());
			var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("seas_carrier_turret", GetOwner());
			m_pxBuildUp^.AddObj(pxO^.GetHandle(), "we");
			cast<CBuildUpWeapon>(m_pxBuildUp)^.SetWeaponClass(GetClassName());
			cast<CBuildUpWeapon>(m_pxBuildUp)^.SetCanRotate(true);
			//cast<CBuildUpWeapon>(m_pxBuildUp)^.SetAdditionalWeapon(true);
			cast<CBuildUpWeapon>(m_pxBuildUp)^.SetAutoAttack(true);
		endif;
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			var ^CAttribs pxAttr=GetAttribs();
			if(pxAttr!=null)then
				pxAttr^.SetValue("AttackBuilding", true);
			endif;
			SetCanFightAttrib(true);
			m_iBuildUpType=CBuildUpBase.TYPE_NONE;
			m_pxBuildUp=null;
		endif;
	endproc;
	
	export proc bool AttackEnemy(^CFightingObj p_pxEnemy, vec3 p_vTarget, ref bool p_rbRotated)
		if(HasBuildUp())then
			var ^CBuildUpWeapon pxWeapon=cast<CBuildUpWeapon>(GetBuildUp());
			if(pxWeapon!=null)then
				if(GetRightHandWeapon()==GetCurrentWeapon())then
					if(pxWeapon^.AttackEnemy(p_pxEnemy, p_vTarget))then
						if(HasAnim("attack_front_secondary"))then
							SetAnim("attack_front_secondary",1);
						endif;
						return false;
					endif;
				endif;
			endif;
		endif;
		DoCaptainAttackAnim();
		return super.AttackEnemy(p_pxEnemy, p_vTarget, p_rbRotated);
	endproc;
	
	proc void OnDefend(^CGameObj p_pxEnemy)
		if(p_pxEnemy!=null)then
//			ReactToGamePlayCommand("Action",p_pxEnemy, p_pxEnemy^.GetPos(), "/AttackSrv");
			AttackSrv(p_pxEnemy);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="SCar"; //SeasCarrier
		var int iVersion=14;
		if(CMirageSrvMgr.SDK())then
			iVersion=14;
		endif;
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,iVersion);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		(pxArc^) << m_iBuildUpType;
		if(m_iBuildUpType!=CBuildUpBase.TYPE_NONE)then
			m_pxBuildUp^.DoKArc(pxArc^, iVersion);
		endif;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="SCar")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVer=p_pxReaderNode^.GetVersion();
			if(iVer>=1)then
				(pxArc^) << m_iBuildUpType;
				if(m_iBuildUpType!=CBuildUpBase.TYPE_NONE)then
					m_pxBuildUp=CBuildUpFactory.Get().CreateBuildUp(m_iBuildUpType);
					m_pxBuildUp^.SetParent(GetHandle());
					m_pxBuildUp^.DoKArc(pxArc^, iVer);
					//reset buildup because of ivalid sharing of DoKArc version in buildup
					if(iVer==1)then
						m_pxBuildUp^.Kill();
						m_iBuildUpType=CBuildUpBase.TYPE_NONE;
						m_pxBuildUp=null;
					endif;
				endif;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc ^CBuildUpBase GetBuildUp()
		return m_pxBuildUp;
	endproc;
	
	export proc bool HasBuildUp()
		return m_iBuildUpType!=CBuildUpBase.TYPE_NONE;
	endproc;
	
	export proc bool CreateBuildingCorpse()
		if(!m_bBuildingReady)then return true; endif;
		var int iCorpse=Random.GetInt()%2;
		switch(iCorpse)
			case(0)do
				var ^CBuildingCorpse pxGameObj=cast<CBuildingCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("BuildingCorpse",GetOwner(),GetPos(),GetRotation()));
				if(pxGameObj!=null)then
					pxGameObj^.SetSource(this);
					pxGameObj^.Init(GetGfxName(), GetName(), 8.0, GetAge());
				endif;
			endcase;
			case(1)do
				var ^CCarrierSink pxGameObj=cast<CCarrierSink>(CSrvWrap.GetObjMgr()^.CreateObj("seas_carrier_sink",GetOwner(),GetPos(),GetRotation()));
				if(pxGameObj!=null)then
					pxGameObj^.SetSource(this);
					pxGameObj^.Init("seas_carrier", GetName(),10.0);
				endif;
			endcase;
			case default do endcase;
		endswitch;
		return true;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		var ^CVirtualProduceUnit pxReactor=cast<CVirtualProduceUnit>(GetReactor().GetObj());
		if(pxReactor==null)then
			return super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("/Build/ANML/seas")!=-1||p_sMiscParams.Find("/Build/SHIP/seas")!=-1||p_sMiscParams.Find("/Build/VHCL/seas")!=-1 /*|| p_sMiscParams.Find("/Upgrades/seas")!=-1*/)then
				if(p_bS)then
					pxReactor^.ActionReactored(p_sMiscParams);
					ActionVPU(p_sMiscParams);
				elseif(GetPQENO() >= GetPQENR() && pxReactor^.IsReady())then
					pxReactor^.ActionReactored(p_sMiscParams);
				else
					ActionVPU(p_sMiscParams);
				endif;
			elseif(p_sMiscParams.Find("/Upgrades/seas")!=-1)then
				ActionVPU(p_sMiscParams);
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		elseif(p_sCommand=="Cancel")then
			CancelAction(p_sMiscParams, p_bS);
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	export proc bool StornoLast()
		var ^CVirtualProduceUnit pxReactor=null;
		if(m_xReactor.IsValid())then
			pxReactor=cast<CVirtualProduceUnit>(m_xReactor.GetObj());
			endif;
		if(GetPQENR() > GetPQENO())then
			if(pxReactor==null||!pxReactor^.StornoLast())then
				return super.StornoLast();
			else
				return true;
			endif;
		else
			return super.StornoLast();
		endif;
	endproc;
	
	export proc void ActionVPU(string p_sTTPath)
		var ^CVirtualProduceUnit pxProduceUnit=cast<CVirtualProduceUnit>(GetProduceUnit().GetObj());
		if(pxProduceUnit==null)then
			super.Action(p_sTTPath);
		else
			pxProduceUnit^.Action(p_sTTPath);
		endif;
	endproc;
	
	export proc void CancelAction(string p_sTTPath)
		return super.CancelAction(p_sTTPath);
	endproc;
	
	export proc void CancelAction(string p_sTTPath, bool p_bShift)
		var ^CVirtualProduceUnit pxReactor=null;
//		var bool bRCA=false;
		if(m_xReactor.IsValid())then
			pxReactor=cast<CVirtualProduceUnit>(m_xReactor.GetObj());
			if(pxReactor!=null)then
				if(p_bShift)then
					pxReactor^.CancelAction(p_sTTPath);
					CancelAction(p_sTTPath);
					return;
				elseif(GetPQENR() > GetPQENO())then
					if(pxReactor^.HasCanceledAction(p_sTTPath))then
						return;
					endif;
				endif;
			endif;
		endif;
		if(!HasCanceledAction(p_sTTPath) && pxReactor!=null)then
			pxReactor^.CancelAction(p_sTTPath);
		endif;
	endproc;
	
	export proc bool UpdateGfx()
		var bool bReturn=super.UpdateGfx();
		if(GetClassName()=="seas_carrier" && !m_xReactor.IsValid())then
			if(m_xTechTree.GetValueB("/Objects/SEAS/InventObjects/seas_carrier_reactor/invented",false))then
//			if(m_xTechTree.GetValueB("/Objects/SEAS/InventObjects/virtual_reactor/invented",true))then
				CreateReactor(m_bBuildingReady);
			endif;
		endif;
		return true;
	endproc;
	
endclass;

class CSwimmingHarbour inherit CHarbour
	
	var CObjList			m_xTurtles;
	var real					m_fAdditionalHitpoints;
	var real					m_fResInvCaps;
	var real					m_fResInv;
	var array real		m_afResInv;
	var array string	m_asResTable;
	var real					m_fResInvSpace;
	var array real		m_afResInvSpace;
	var bool					m_bDiedOnceAlready;
	
	export constructor()
		m_bDiedOnceAlready=false;
	endconstructor;

	proc void InitResourceInventory()
		m_asResTable=0;
		var string sTribe=GetPlayerTribeName();
		if(sTribe.IsEmpty())then return; endif;
		var int i,iC=m_xTechTree.NumSubs("Resources/"+sTribe);
		for(i=0)cond(i<iC)iter(i++)do
			m_asResTable.AddEntry(m_xTechTree.GetValueS("Resources/"+sTribe+"/"+i.ToString(),""));
		endfor;
	endproc;
	
	export proc real GetResourceInventorySize(string p_sResource)
		var int iIdx=m_asResTable.FindEntry(p_sResource);
		if(iIdx<0||iIdx>=m_afResInvSpace.NumEntries())then return 0.0; endif;
		return m_afResInvSpace[iIdx]+GetBonusSum(CFightingObj.BONUS_MAXRESINV);
	endproc;
	
	export proc real GetResourceInventorySize(int p_iIdx)
		if(p_iIdx<0||p_iIdx>=m_afResInvSpace.NumEntries())then return 0.0; endif;
		return m_afResInvSpace[p_iIdx]+GetBonusSum(CFightingObj.BONUS_MAXRESINV);
	endproc;
	
	export proc void UpdateResourceInventoryCaps()
		var ^CTechTree.CNode pxResNode=m_xTechTree.FindNode(GetObjPath()+"/ResInvCaps");
		if(pxResNode==null)then return; endif;
		m_afResInvSpace=0;
		var int i, iC=m_asResTable.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var real fValue=pxResNode^.GetSubValueF(m_asResTable[i],5.0);
			m_afResInvSpace.AddEntry( ( fValue * GetTechTreeModifier("ResInv",true) )+GetTechTreeModifier("ResInv",false) );
		endfor;
		m_fResInvSpace=(m_xTechTree.GetValueR(GetObjPath()+"/ResInvCaps/food",5.0) * GetTechTreeModifier("ResInv",true))+GetTechTreeModifier("ResInv",false);
	endproc;
	
	export proc real ResInvCount(int p_iType)
		return m_afResInv[p_iType];
	endproc;
	
	export proc void ResInvEmpty(int p_iType)
		m_afResInv[p_iType]=0.0;
	endproc;
	
	export proc bool ResInvIsFull(int p_iType)
		if(ResInvCount(p_iType)<GetResourceInventorySize(p_iType))then
			return false;
		else
			return true;
		endif;
	endproc;
	
	export proc real GetPlainMaxResInv()
		return m_fResInvSpace;
	endproc;
	
	export proc real GetMaxResInv()
		return m_fResInvSpace+GetBonusSum(CFightingObj.BONUS_MAXRESINV);
	endproc;
	
	export proc bool ResInvIsFull(string p_sType)
		var int iIndex=m_asResTable.FindEntry(p_sType);
		if(iIndex!=-1)then
			if(ResInvCount(iIndex)<GetResourceInventorySize(iIndex))then
				return false;
			else
				return true;
			endif;
		endif;
		return false;
	endproc;
	
	export proc bool ResInvIsEmpty(int p_iType)
		if(ResInvCount(p_iType)==0.0)then
			return true;
		else
			return false;
		endif;
	endproc;
	
	export proc bool ResInvIsEmpty(string p_sType)
		var int iIndex=m_asResTable.FindEntry(p_sType);
		if(iIndex!=-1)then
			if(ResInvCount(iIndex)==0.0)then
				return true;
			else
				return false;
			endif;
		endif;
		return false;
	endproc;
	
	export proc real GetResInvSpace(int p_iType)
		return (GetResourceInventorySize(p_iType) - m_afResInv[p_iType]);
	endproc;
	
	export proc real GetResInvSpace(string p_sType)
		var int iIndex=m_asResTable.FindEntry(p_sType);
		if(iIndex!=-1)then
			return (GetResourceInventorySize(iIndex) - m_afResInv[iIndex]);
		endif;
		return 0.0;
	endproc;
	
	export proc bool ResInvAdd(int p_iType, real p_fCount)
		if(!ResInvIsFull(p_iType))then
			m_afResInv[p_iType]+=p_fCount;
			return(true);
		else
			return(false);
		endif;
	endproc;
	
	export proc bool ResInvAdd(string p_sType, real p_fCount)
		var int iIndex=m_asResTable.FindEntry(p_sType);
		if(iIndex!=-1)then
			if(!ResInvIsFull(iIndex))then
				m_afResInv[iIndex]+=p_fCount;
				return(true);
			else
				return(false);
			endif;
		endif;
		return false;
	endproc;
	
	export proc void DropAllInResInv()
		var int i;
		for(i=0)cond(i<m_afResInv.NumEntries())iter(i++)do
			m_afResInv[i]=0.0;
		endfor;
	endproc;
	
	export proc bool CheckInResInvAllPossible(^CGameObj p_pxDelivery)
		if(p_pxDelivery==null)then return false; endif;
		var bool bCheckedIn=false;
		var ^CAttribs pxAttribs=p_pxDelivery^.GetAttribs();
		if(pxAttribs!=null)then
			var int i;
			for(i=0)cond(i<m_afResInv.NumEntries())iter(i++)do
				if(m_afResInv[i]>0.0)then
					var string sResAttrib=m_asResTable[i]+"Delivery";
					if(pxAttribs^.GetValueBool(sResAttrib))then
						if(CheckInResInv(m_asResTable[i]))then
							bCheckedIn=true;
						endif;
					endif;
				endif;
			endfor;
		endif;
		return bCheckedIn;
	endproc;
	
	export proc bool CheckInResInv(string p_sType)
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		var ^CBasePlayer pxPlayer=cast<CBasePlayer>(pxLevel^.GetPlayer(GetOwner()));
		if(pxPlayer==null)then return false; endif;
		var int iIndex=m_asResTable.FindEntry(p_sType);
		if(iIndex==-1)then return false; endif;
		if(m_afResInv[iIndex]==0.0)then return false; endif;
		var real fOriginalValue=m_afResInv[iIndex];
		var real fReturnValue=pxPlayer^.AddResource(p_sType,m_afResInv[iIndex]);
		var real fStatisticValue=fOriginalValue;
		if(fReturnValue!=0.0)then fStatisticValue-=fReturnValue; endif;
		m_afResInv[iIndex]=fReturnValue;
		return fReturnValue!=fOriginalValue;
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
		if(p_pxReaderNode^.GetType()=="SHba")then //obsolete
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			if(iVersion>=1)then
				var int i,iC;
				pxArc^ << iC;
				m_afResInv=iC;
				for(i=0)cond(i<iC)iter(i++)do
					pxArc^ << m_afResInv[i];
				endfor;
			endif;
		elseif(p_pxReaderNode^.GetType()=="SHab")then
			var int iVersion=p_pxReaderNode^.GetVersion();
			if(iVersion>=1)then
				m_xTurtles.DoKArc(pxArc^);
				pxArc^ << m_fAdditionalHitpoints;
			endif;
			if(iVersion>=2)then
				var int i,iC;
				pxArc^ << iC;
				m_afResInv=iC;
				for(i=0)cond(i<iC)iter(i++)do
					pxArc^ << m_afResInv[i];
				endfor;
			endif;
			if(iVersion>=3)then
				pxArc^ << m_bDiedOnceAlready;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="SHab";
		var int iVersion=3;
		if(CMirageSrvMgr.SDK())then
			iVersion=1;
		endif;
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,iVersion);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xTurtles.DoKArc(pxArc^);
		pxArc^ << m_fAdditionalHitpoints;
		if(iVersion>=2)then
			var int i, iC=m_afResInv.NumEntries();
			pxArc^ << iC;
			for(i=0)cond(i<iC)iter(i++)do
				pxArc^ << m_afResInv[i];
			endfor;
		endif;
		if(iVersion>=3)then
			pxArc^ << m_bDiedOnceAlready;
		endif;
		pxWalk^.Close();
	endproc;
	
	export destructor()
		var int i,iC=m_xTurtles.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(!m_xTurtles[i].IsValid())then continue; endif;
			m_xTurtles[i].GetObj()^.Delete();
		endfor;
	enddestructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetInventSite(true);
//		if(GetClassName()=="aje_floating_harbour")then
//			SetCanWalk(true);
//		else
//			SetCanWalk(false);
//		endif;
		SetCanWalk(false);
		SetCanSwim(true);
		SetCanFly(false);
		SetRallySite(true);
		m_afResInv=7;
		m_fResInvCaps=GetTechTreeResourceInvCap();
		if(!p_bLoad)then
			var ^CAttribs pxAttr=GetAttribs();
			if(pxAttr!=null)then
				pxAttr^.SetValue("MovingBuilding",true);
			endif;
			CreatePersonalProduceUnit(false);
			if(GetClassName()=="aje_floating_harbour")then
				SetCanFightAttrib(false);
			endif;
			DropAllInResInv();
		else
			UpdateAdditionalHitpoints();
		endif;
	endproc;
	
	export proc real GetTechTreeResourceInvCap()
		return(m_xTechTree.GetValueR(GetObjPath()+"/ResInvCaps/food",0.0f));
	endproc;
	
	export proc real GetTechTreeHitpoints()
		return super.GetTechTreeHitpoints()+m_fAdditionalHitpoints;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
//		CheckWaterLand();
		if(!IsBuildMode())then SetReady(); endif;
	endproc;
	
	export proc void SetReady()
		var ^CVirtualProduceUnit pxUnit=cast<CVirtualProduceUnit>(m_xProduceUnit.GetObj());
		if(pxUnit!=null)then
			pxUnit^.SetReady();
		endif;
		super.SetReady();
		//SB#16526 HOTFIX moved from OnInit because non visible links corrupt selection circle and health bar rendering
		if(GetClassName()=="aje_floating_harbour" && m_bBuildingReady && m_xTurtles.NumEntries()==0)then
			var ^CGameObj pxObj=CSrvWrap.GetObjMgr()^.CreateObj("aje_floating_harbour_macrolemys",GetOwner());
			var CFourCC xLink="Cr_1";
			pxObj^.FlexLinkAction(GetHandle(),xLink,0.0,{0.0,0.0,0.0},"swim_1");
			AddGroupedChildren(pxObj^.GetGuid());
			m_xTurtles.Include(pxObj^.GetHandle());
	
			pxObj=CSrvWrap.GetObjMgr()^.CreateObj("aje_floating_harbour_macrolemys",GetOwner());
			xLink="Cr_2";
			pxObj^.FlexLinkAction(GetHandle(),xLink,0.0,{0.0,0.0,0.0},"swim_1");
			AddGroupedChildren(pxObj^.GetGuid());
			m_xTurtles.Include(pxObj^.GetHandle());
	
			pxObj=CSrvWrap.GetObjMgr()^.CreateObj("aje_floating_harbour_macrolemys",GetOwner());
			xLink="Cr_3";
			pxObj^.FlexLinkAction(GetHandle(),xLink,0.0,{0.0,0.0,0.0},"swim_1");
			AddGroupedChildren(pxObj^.GetGuid());
			m_xTurtles.Include(pxObj^.GetHandle());
	
			pxObj=CSrvWrap.GetObjMgr()^.CreateObj("aje_floating_harbour_macrolemys",GetOwner());
			xLink="Cr_4";
			pxObj^.FlexLinkAction(GetHandle(),xLink,0.0,{0.0,0.0,0.0},"swim_1");
			AddGroupedChildren(pxObj^.GetGuid());
			m_xTurtles.Include(pxObj^.GetHandle());
		endif;
	endproc;
	
	export proc void UpdateAdditionalHitpoints()
	endproc;
	
	export proc void OnTechTreeChange()
		super.OnTechTreeChange();
	endproc;
	
	export proc void OnTechTreeChange(ref CStringArray p_rasChanges)
		super.OnTechTreeChange(p_rasChanges);
		UpdateAdditionalHitpoints();
		var string sObjPath="/"+GetObjPath();
		var int i;
		for(i=0) cond(i<p_rasChanges.NumEntries()) iter(i++)do
			var string sVal=p_rasChanges[i];
		endfor;
		InitResourceInventory();
		UpdateResourceInventoryCaps();
	endproc;
	
	export proc bool DoesCountInUnitLimit()
		return true;
	endproc;
	
	export proc void Die()
		if(m_bDiedOnceAlready)then return; endif;
		m_bDiedOnceAlready=true;
		super.Die();
		Delete();
	endproc;
	
	export proc void SailToTask(vec3 p_vDest)
		if(!m_bBuildingReady)then return; endif;
		var vec3 vDestination=p_vDest;
		var real fSeaLevel=CSrvWrap.GetScapeMgr().GetSeaLevel();
		var vec3 vPos=GetPos();
		vPos.SetZ(Math.Max(vPos.GetZ(),fSeaLevel));
		SetPos(vPos);
		vDestination.SetZ(fSeaLevel - 1.0);
		GoTo(vDestination,true,GetDefaultSpeed(),true,false);
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		var ^CVirtualProduceUnit pxUnit=cast<CVirtualProduceUnit>(GetProduceUnit().GetObj());
		if(pxUnit==null)then
			if(m_bBuildingReady)then
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
			return;
		endif;
		if(p_sCommand=="setlevel")then
			var bool b=SetLevel(p_sMiscParams.ToInt());
			if(!b)then
				InvalidateAttrib("level");
			endif;
			return;
		elseif(p_sCommand=="Action")then
			if(p_sMiscParams.Find("/Build/SHIP/aje")!=-1)then
				pxUnit^.ReactToGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams, p_bQ, p_bS, p_bA);
				return;
			elseif(p_sMiscParams.Find("/Build/SHIP/seas")!=-1)then
				pxUnit^.ReactToGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams, p_bQ, p_bS, p_bA);
				return;
			elseif(p_sMiscParams.Find("/Build/VHCL/seas")!=-1)then
				pxUnit^.ReactToGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams, p_bQ, p_bS, p_bA);
				return;
			elseif(p_sMiscParams.Find("/Upgrades/aje")!=-1)then
				pxUnit^.ReactToGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams, p_bQ, p_bS, p_bA);
				return;
			elseif(p_sMiscParams.Find("/Upgrades/seas")!=-1)then
				pxUnit^.ReactToGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams, p_bQ, p_bS, p_bA);
				return;
			elseif(p_sMiscParams.Find("LevelUp")!=(-1))then
				var bool b=false;
				var int i;
				for(i=GetLevel()+1)cond(i<5)iter(i++)do
					b=SetLevel(i);
					if(b)then break; endif;
				endfor;
				if(!b)then InvalidateAttrib("level"); endif;
//				var bool b=SetLevel(GetLevel());
//				if(!b)then InvalidateAttrib("level"); endif;
				return;
			elseif(p_sMiscParams.Find("/FishSomewhere")>=0)then
				Fishing(GetPos(),p_bQ,false);
				return;
			endif;
		elseif(p_sCommand=="BuildUp")then
			BuildUp(p_sMiscParams);
			return;
		elseif(p_sCommand=="Fishing")then
			Fishing(p_pxObject, p_bQ);
			return;
		elseif(p_sCommand.Find("SetRallyPoint")!=-1)then
			var CObjHndl xHndl;
			if(p_pxObject!=null)then
				xHndl=p_pxObject^.GetHandle();
			endif;
			SetRallyPoint(p_vPos,xHndl);
			return;
		elseif(p_sCommand=="Cancel")then
			if(pxUnit!=null)then
				pxUnit^.ReactToGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams, p_bQ, p_bS, p_bA);
//				CheckCancelBuildDecrease(p_sMiscParams);
				return;
			endif;
		endif;
		if(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill"||p_sCommand=="StornoLast"||p_sCommand=="StornoAll"||m_bBuildingReady)then
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	export proc void Fishing(^CGameObj p_pxObject, bool p_bQ)
		if(!m_bBuildingReady)then return; endif;
		var ^CFishing pxTask=cast<CFishing>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"Fishing"));
//		if(pxTask==null)then return; endif;
//		pxTask^.Init(GetHandle(),p_pxObject^.GetHandle());
		if(pxTask==null)then return; endif;
		if(!pxTask^.Init(GetHandle(),p_pxObject^.GetHandle()))then
			pxTask^.GetFactory()^.FreeState(pxTask);
			return;
		endif;
		pxTask^.SetUserCommand(true);
		AddTask(pxTask, p_bQ);
	endproc;
	
	export proc void Fishing(vec3 p_vPos, bool p_bQ, bool p_bNext)
		if(p_bQ)then
			StartCustomTask(GetHandle(),"Fishing","Harbour");
			return;
		endif;
		if(!m_bBuildingReady)then return; endif;
		var ^CFishing pxTask=cast<CFishing>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"Fishing"));
//		if(pxTask==null)then return; endif;
//		pxTask^.Init(GetHandle(),p_vPos);
		if(pxTask==null)then return; endif;
		if(!pxTask^.Init(GetHandle(),p_vPos))then
			pxTask^.GetFactory()^.FreeState(pxTask);
			return;
		endif;
		pxTask^.SetUserCommand(true);
		if(p_bNext)then
			AddNextTask(pxTask);
		else
			AddTask(pxTask, false);
		endif;
	endproc;

	export proc bool CreateBuildingCorpse()
		if(!m_bBuildingReady)then return true; endif;
		Random.Seed();
//		if(Random.GetInt()%2==1 && IsInWater())then
		if(Random.GetInt()%2==1)then
			var ^CAjeHarbourSink pxGameObj=cast<CAjeHarbourSink>(CSrvWrap.GetObjMgr()^.CreateObj("aje_harbour_sink",GetOwner(),GetPos(),GetRotation()));
			if(pxGameObj!=null)then
				pxGameObj^.SetSource(this);
				pxGameObj^.Init("aje_floating_harbour", GetName(),10.0);
			endif;
			return true;
		endif;
		return false;
	endproc;
	
//	export proc bool SetRallyPoint(vec3 p_vPoint, CObjHndl p_xTarget)
//		if(!p_xTarget.IsValid()&&p_vPoint=={0.0,0.0,0.0}&&GetRallySite())then
//			return false;
//		endif;
//		return super.SetRallyPoint(p_vPoint, p_xTarget);
//	endproc;
	/*
//	export proc void OnActionEnd(bool p_bBroken)
//		super.OnActionEnd(p_bBroken);
//		CheckWaterLand();
//	endproc;
	
	export proc void SetPos(vec3 p_vPos)
		//somebody beams me around -> I must check my pos for land/water
		super.SetPos(p_vPos);
		CheckWaterLand();
	endproc;
	
	export proc void CheckWaterLand()
		OnAmphibianWaterLandTransition(!IsInWater());
	endproc;

	proc void OnAmphibianWaterLandTransition(bool p_bWaterToLand)
		if(p_bWaterToLand)then
			WaterToLand();
		else
			LandToWater();
		endif;
	endproc;

	export proc void WaterToLand()
		var int i,iC=m_xTurtles.NumEntries();
		var CFourCC xLink;
		for(i=0)cond(i<iC)iter(i++)do
			if(!m_xTurtles[i].IsValid())then continue; endif;
			xLink="Cr_"+(i+1).ToString();
			m_xTurtles[i].GetObj()^.SetGFX("Macrolemys_Land");
			m_xTurtles[i].GetObj()^.FlexLinkAction(GetHandle(),xLink,0.0,{0.0,0.0,0.0},"walk_1");
		endfor;
	endproc;

	export proc void LandToWater()
		var int i,iC=m_xTurtles.NumEntries();
		var CFourCC xLink;
		for(i=0)cond(i<iC)iter(i++)do
			if(!m_xTurtles[i].IsValid())then continue; endif;
			xLink="Cr_"+(i+1).ToString();
			m_xTurtles[i].GetObj()^.SetGFX("Macrolemys_Water");
			m_xTurtles[i].GetObj()^.FlexLinkAction(GetHandle(),xLink,0.0,{0.0,0.0,0.0},"swim_1");
		endfor;
	endproc;
*/
endclass;

class CMagicCauldron inherit CTemple
	
	const real MAGIC_RADIUS=40.0f;
	export const real EFFECT_BONUS_AMOUNT=20.0f;
	static var array string ms_asTypes;
	
	export constructor()
		if(ms_asTypes.NumEntries()==0)then
			ms_asTypes.AddEntry("CHTR");
			ms_asTypes.AddEntry("ANML");
			ms_asTypes.AddEntry("VHCL");
		endif;
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
//		m_bHealthBuilding=true;
		m_bManaBuilding=true;
		super.OnInit(p_bLoad);
		SetRallySite(false);
		m_xFunctionUnits.SetType("CHTR");
		m_xFunctionUnits.SetType("ANML",true);
		m_xFunctionUnits.SetType("VHCL",true);
		m_xSink.m_xOnObjAdd=OnObjAdd;
		m_xSink.m_xOnObjRem=OnObjRem;
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="MgCl")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var CGuid xG;
			pxArc^<< xG;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		//var real fRange=m_xTechTree.GetValueR("MiscValues/Hu/Cauldron_radius",50.0);
		if(!HasPersonalRegion())then
			//var vec3 vE;vE.SetXYZ(fRange, fRange, 0.0f);
			var vec3 vE;vE.SetXYZ(MAGIC_RADIUS, MAGIC_RADIUS, 0.0f);
			CreatePersonalRegion("MagicCauldron_"+GetName()+"_"+Random.GetInt().ToString(), vE, 010b);
			AddRangedBuff("owner_more_damage");
		endif;
	endproc;
	
	proc bool OnObjAdd(CObjHndl p_xHndl)
		if(m_bToBeDeleted)then return false; endif;
		//var real fMagic=m_xTechTree.GetValueR("MiscValues/Hu/Cauldron_bonus",20.0);
		var ^CFightingObj pxFO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxFO==null)then return false; endif;
		if(!AuraSharing()&&pxFO^.GetOwner()!=GetOwner())then return false; endif;
		if(CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxFO^.GetOwner(), GetOwner())&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxFO^.GetOwner()))then
			if(ms_asTypes.FindEntry(pxFO^.GetType().AsString())>=0)then
				m_xRegionObjects.Include(p_xHndl);
				//var real fBonus=pxFO^.GetDmg()*0.01f*fMagic;
//					var real fBonus=pxFO^.GetDmg()*0.01f*EFFECT_BONUS_AMOUNT;
//					var ^CBoniBucket pxBB=pxFO^.GetBoniBucket(CFightingObj.BONUS_DAMAGE);
//					pxBB^.AddEntry("Cauldron", fBonus);
//					pxFO^.ForceBoniUpdate();
				pxFO^.SetMirageFlag(CFightingObj.MIRAGE_MAGIC_CAULDRON, true);
			endif;
		endif;
		return true;
	endproc;
	
	proc bool OnObjRem(CObjHndl p_xHndl)
		if(m_xRegionObjects.FindEntry(p_xHndl)==-1)then return false; endif;
		m_xRegionObjects.RemEntry(p_xHndl);
		var ^CFightingObj pxFO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxFO!=null&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(),pxFO^.GetOwner()))then
			if(ms_asTypes.FindEntry(pxFO^.GetType().AsString())>=0)then
//				var ^CBoniBucket pxBB=pxFO^.GetBoniBucket(CFightingObj.BONUS_DAMAGE);
//				pxBB^.RemEntry("Cauldron");
//				pxFO^.ForceBoniUpdate();
				pxFO^.SetMirageFlag(CFightingObj.MIRAGE_MAGIC_CAULDRON, false);
			endif;
		endif;
		return true;
	endproc;
	
	export proc void InitOwnRegion()
		if(!HasPersonalRegion())then
			var vec3 vE;vE.SetXYZ(MAGIC_RADIUS, MAGIC_RADIUS, 0.0f);
			CreatePersonalRegion("MagicCauldron_"+GetName()+"_"+Random.GetInt().ToString(), vE, 010b);
			AddRangedBuff("owner_more_damage");
		endif;
	endproc;
	
	export proc string GetReportCode()
		return "defence";
	endproc;
	
endclass;

class CSkullProtector inherit CBuilding
	
	//BadGun Tuning: Skull Protector
	const real 	EFFECT_RANGE=30.0f;
	export const string PATH="/Filters/Aje/Upgrades/aje_skull_protector/protect_skulls";
	
	static var array string ms_asTypes;
	
	export constructor()
		if(ms_asTypes.NumEntries()==0)then
			ms_asTypes.AddEntry("CHTR");
			ms_asTypes.AddEntry("ANML");
			ms_asTypes.AddEntry("VHCL");
			ms_asTypes.AddEntry("SHIP");
			ms_asTypes.AddEntry("BLDG");
			ms_asTypes.AddEntry("NEST");
		endif;
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		m_xSink.m_xOnObjAdd=OnObjAdd;
		m_xSink.m_xOnObjRem=OnObjRem;
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="MgCl")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var CGuid xG;
			pxArc^<< xG;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		if(!HasPersonalRegion())then
			var vec3 vE;vE.SetXYZ(EFFECT_RANGE, EFFECT_RANGE, 0.0f);
			CreatePersonalRegion("SkullProtector_"+GetName()+"_"+Random.GetInt().ToString(), vE, 010b);
			//AddRangedBuff("owner_more_damage");
		endif;
	endproc;
	
	proc bool OnObjAdd(CObjHndl p_xHndl)
		if(m_bToBeDeleted)then return false; endif;
		var ^CFightingObj pxFO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxFO==null)then return false; endif;
		if(!AuraSharing()&&pxFO^.GetOwner()!=GetOwner())then return false; endif;
		if(pxFO^.GetClassName()!="aje_skull_protector")then
			if(CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxFO^.GetOwner(), GetOwner())&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxFO^.GetOwner()))then
				pxFO^.SetEffectFlag(CFightingObj.EFFECT_SKULL_PROTECTOR,true);
			endif;
		endif;
		return true;
	endproc;
	
	proc bool OnObjRem(CObjHndl p_xHndl)
		if(m_xRegionObjects.FindEntry(p_xHndl)==-1)then return false; endif;
		m_xRegionObjects.RemEntry(p_xHndl);
		var ^CFightingObj pxFO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxFO!=null && CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxFO^.GetOwner()))then
			pxFO^.SetEffectFlag(CFightingObj.EFFECT_SKULL_PROTECTOR,false);
		endif;
		return true;
	endproc;
	
	export proc void InitOwnRegion()
		if(!HasPersonalRegion())then
			var vec3 vE;vE.SetXYZ(EFFECT_RANGE, EFFECT_RANGE, 0.0f);
			CreatePersonalRegion("SkullProtector_"+GetName()+"_"+Random.GetInt().ToString(), vE, 010b);
		endif;
	endproc;
	
endclass;

class CKennel inherit CBuilding
	
	const real NEST_RADIUS_1 = 70.0f; // the nests territory
	const real NEST_RADIUS_2 = 140.0f; // the nests tolerance zone
	
	var CObjHndl m_xNest;
	var bool m_bNestGrow;
	const real NEST_GROW = 360.0f; // time which after more animal spawns from the nest
	const int NEW_EGGS = 2; // increasement of max spawned animals from the nest
	
	export constructor()
		m_bNestGrow=false;
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="DiKn")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xNest.DoKArc(pxArc^);
			if(p_pxReaderNode^.GetVersion()>=2)then
				(pxArc^) << m_bNestGrow;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		if(!m_bNestGrow)then
			if(HasTimer(NEST_GROW_TIMER))then DeleteTimer(NEST_GROW_TIMER); endif;
			CreateTimer(NEST_GROW_TIMER,CGameTimeSpan.OneSecond()*NEST_GROW,false);
		endif;
		if(m_xNest.IsValid())then return; endif;
		var ^CNest pxNest=cast<CNest>(CSrvWrap.GetObjMgr()^.CreateObj(GetClassName()+"_nest",GetOwner(),GetPos(),GetRotation()));
		if(pxNest!=null)then
			m_xNest=pxNest^.GetHandle();
			AdjustNestAreas(pxNest);
			pxNest^.SetVisible(false);
			var CFourCC xT="NOPE";
			pxNest^.LinkAction(GetHandle(), xT);
		endif;
	
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==NEST_GROW_TIMER)then
				var ^CNest pxN=cast<CNest>(m_xNest.GetObj());
				if(pxN!=null)then
					if(pxN^.ChangeSpawnAmount(NEW_EGGS))then
						m_bNestGrow=true;
					endif;
				else
					DeleteTimer(NEST_GROW_TIMER);
					CreateTimer(NEST_GROW_TIMER,CGameTimeSpan.OneSecond()*NEST_GROW,false);
				endif;
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="DiKn";
		var int iVersion=2;
		if(CMirageSrvMgr.SDK())then
			iVersion=1;
		endif;
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,iVersion);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xNest.DoKArc(pxArc^);
		if(iVersion>=2)then
			(pxArc^) << m_bNestGrow;
		endif;
		pxWalk^.Close();
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		if(!IsBuildMode())then
			SetReady();
		endif;
	endproc;
	
	proc void AdjustNestAreas(^CNest p_pxNest)
		var ^CRegion pxRgn=p_pxNest^.GetActionAreaPtr();
		var vec3 vE; vE.SetXYZ(NEST_RADIUS_1, NEST_RADIUS_1, 0.0f);
		if(pxRgn!=null)then
			pxRgn^.Clear();
			pxRgn^.AddSubRegion(010b, GetPos(), vE);
		endif;
		pxRgn=p_pxNest^.GetSafeAreaPtr();
		if(pxRgn!=null)then
			pxRgn^.Clear();
			pxRgn^.AddSubRegion(010b, GetPos(), vE);
		endif;
		vE.SetXYZ(NEST_RADIUS_2, NEST_RADIUS_2, 0.0f);
		pxRgn=p_pxNest^.GetToleranceAreaForced();
		if(pxRgn!=null)then
			pxRgn^.Clear();
			pxRgn^.AddSubRegion(010b, GetPos(), vE);
		endif;
	endproc;
	
	export proc void Die()
		var ^CNest pxN=cast<CNest>(m_xNest.GetObj());
		if(pxN!=null)then
			pxN^.Die();
		endif;
		super.Die();
	endproc;
	
	export proc string GetReportCode()
		return "defence";
	endproc;
	
endclass;

class CDecoBuilding inherit CBuilding
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetHitable(false);
		SetSelectable(false);
	endproc;
	
	export proc int GetTechTreeAggressiv()
		return -1;
	endproc;
	
	export proc void Damage(real p_fDamage)
		return;
	endproc;
	
	export proc void PoisonDamage(real p_fDamage, CObjHndl p_xEnemy, int p_iEnemy)
		return;
	endproc;
	
	export proc void BurnDamage(real p_fDamage, CObjHndl p_xEnemy, int p_iEnemy)
		return;
	endproc;
	
	export proc void ChainDamage(real p_fDamage, int p_iLast, CObjHndl p_xLast)
		return;
	endproc;
	
	export proc void WoundDamage(real p_fDamage, CObjHndl p_xLE, int p_iLE)
		return;
	endproc;
	
endclass;

class CBuildingCorpse inherit CUniversalCorpse
	
	var string	m_sGfx;
	var int		m_iState;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="BCor")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			pxArc^ << m_iState;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="BCor";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,2);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		pxArc^ << m_iState;
		pxWalk^.Close();
	endproc;
	
	export proc bool ShouldStay(string p_sGfxName)
		if(p_sGfxName=="hcl13_gate")then
			return true;
		elseif(p_sGfxName=="PT_Citywall_Gate_dest")then
			return true;
		elseif(p_sGfxName=="seas_hq_bunker_dest")then
			return true;
		elseif(p_sGfxName=="seas_hq_big_cannon_dest")then
			return true;
		elseif(p_sGfxName=="seas_hq_big_cannon_rotator_dest")then
			return true;
		elseif(p_sGfxName=="seas_hq_defense_turret_dest")then
			return true;
		elseif(p_sGfxName=="seas_hq_machinegun_nest_dest")then
			return true;
		endif;
		return false;
	endproc;
	
	export proc bool IsException()
		var string sBuildingName=GetSourceClass();
		if(sBuildingName=="seas_fortress")then
			return true;
		elseif(sBuildingName=="seas_mg_nest")then
			return true;
		//elseif(sBuildingName=="seas_pub")then
			//return true;
		elseif(sBuildingName=="seas_small_cannon")then
			return true;
		elseif(sBuildingName=="seas_great_cannon")then
			return true;
		elseif(sBuildingName=="seas_great_cannon_rotator")then
			return true;
		endif;
		return false;
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetVisible(true);
	endproc;
	
	export proc void Init(string p_sGfx, string p_sName, real p_fDuration, int p_iAge)
		m_sGfx=p_sGfx;

		if(p_sGfx=="ninigi_large_tower")then
			super.Init("ninigi_smoke_tower_dest", p_sName, p_fDuration);
		else
			super.Init(p_sGfx+"_dest", p_sName, p_fDuration);
		endif;

		m_iState=1;
		SetAge(p_iAge);
	endproc;
	
	export proc void OnPostLoad()
		if(ShouldStay(GetGfxName())&&!IsException())then
			m_iState=0;
			return;
		endif;
		if(m_iState==2||m_iState==1)then
			Delete();
		endif;
	endproc;
	
	export proc void SetGFX(string p_sString)
		super.SetGFX(p_sString);
	endproc;
	
	proc void PlayAnim(int p_iPlayMode)
		AnimAction("destroy");
	endproc;
	
	export proc void OnActionEnd(bool p_bBroken)
		if(m_iState==2)then
			Delete();
		endif;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==TIMER_DELETE)then
				// HACK
				if(ShouldStay(GetGfxName())&&!IsException())then
					m_iState=0;
					return;
				endif;
				//ENDHACK
				m_iState=2;
				var vec3 vP=GetPos();
				vP.SetZ(0.0f);
				MoveAction(vP, 1.0f);
			endif;
		endif;
	endproc;
	
	export destructor()
	enddestructor;

endclass;

class CLaunchPad inherit CBuilding
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
	endproc;
	
	export proc void OnPostLoad()
		if(!CSrvWrap.GetCurLevel()^.IsEditable() && !IsReady()&&GetCurTaskName()!="BuildUpB")then
			BuildUp("/Actions/"+GetTribeName()+"/Build/BLDG/"+GetClassName());
			if(GetClassName()=="ninigi_telescope_tower_ruins")then
				var ^CBuildUpBuilding pxTask=cast<CBuildUpBuilding>(GetCurTask());
				if(pxTask!=null)then
					pxTask^.AddProgress(49.0);
				endif;
			endif;
		endif;
	endproc;

endclass;

class CWarpMgr inherit CEvtSink
	
	static var ^CWarpMgr		ms_pxInst;
	var array CObjHndl			m_axHndlList;
	var CGameTimeSpan				m_xGameOverDuration;
	var int									m_iTimer;
	var bool								m_bWarpGateBuild;
	var array bool					m_abGateReady;
	var CEvtSource					m_xSource;
	
	constructor()
		var CObjHndl xInvalid=CObjHndl.Invalid();
		m_axHndlList.AddEntry(xInvalid);
		m_axHndlList.AddEntry(xInvalid);
		m_axHndlList.AddEntry(xInvalid);
		m_axHndlList.AddEntry(xInvalid);
		m_axHndlList.AddEntry(xInvalid);
		m_axHndlList.AddEntry(xInvalid);
		m_axHndlList.AddEntry(xInvalid);
		m_axHndlList.AddEntry(xInvalid);
		m_xGameOverDuration=600.0;
		m_iTimer=-1;
		m_bWarpGateBuild=false;
		m_abGateReady=8;
	endconstructor;
	
	destructor()
		if(m_iTimer!=-1)then
			CTimeMgr.Get().GetTimer(m_iTimer)^.Unsubscribe(this);
			CTimeMgr.Get().DeleteTimer(m_iTimer);
		endif;
	enddestructor;
	
	export static proc ref CWarpMgr Get()
		if(ms_pxInst==null)then
			ms_pxInst=new CWarpMgr;
		endif;
		return(ms_pxInst^);
	endproc;
	
	export static proc void Kill()
		if(ms_pxInst!=null)then
			delete ms_pxInst;
			ms_pxInst=null;
		endif;
	endproc;
	
	export proc bool Update()
		return CSrvWrap.GetCurLevel()^.GetLevelInfo().GetAttribs().GetValueBool("DimGateAvailable");
	endproc;
	
	export proc void Subscribe(^CEvtSink p_pxSink)
		m_xSource.Subscribe(p_pxSink);
	endproc;
	
	export proc void Unsubscribe(^CEvtSink p_pxSink)
		m_xSource.Unsubscribe(p_pxSink);
	endproc;
	
	proc void MarkForAllStarted(^CWarpGate p_pxTransit)
		//L KLog.LogSpam("CWarpMgr","MarkForAllStarted()");
		var string sPlayerName="unknown";
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel!=null && p_pxTransit!=null)then
			var ^CPlayer pxPlayer=pxLevel^.GetPlayer(p_pxTransit^.GetOwner());
			if(pxPlayer!=null)then
				sPlayerName=pxLevel^.GetLevelInfo().GetPlayerSlot(pxPlayer^.GetPlayerSlotID()).GetName();
			endif;
			//Henry: sound for other players, depending on diplomacy status
			var int i=0;
			for(i=0)cond(i<CGameBase.GetMaxPlayers())iter(i++)do
				if(i==p_pxTransit^.GetOwner())then continue; endif;
				var ^CPlayer pxPlayer=pxLevel^.GetPlayer(i);
				if(pxPlayer==null)then continue; endif;
				if(cast<CAiPlayer>(pxPlayer)!=null)then continue; endif;
				if(CSrvWrap.GetDiplomacyMgr().GetIsFriend(p_pxTransit^.GetOwner(), i))then
					CSrvWrap.SendGenericEvtToPlayer(i, "AllyWarp");
				else
					CSrvWrap.SendGenericEvtToPlayer(i, "EnemWarp");
				endif;
			endfor;
		endif;
		CFeedback.Print(CFeedback.ALL, CFeedback.ATTACK, "_NT_WarpGateStarted\t"+sPlayerName);
	endproc;
	
	proc void MarkForAllFinished(^CWarpGate p_pxTransit)
		//L KLog.LogSpam("CWarpMgr","MarkForAllFinished()");
		var string sPlayerName="unknown";
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel!=null && p_pxTransit!=null)then
			var ^CPlayer pxPlayer=pxLevel^.GetPlayer(p_pxTransit^.GetOwner());
			if(pxPlayer!=null)then
				sPlayerName=pxLevel^.GetLevelInfo().GetPlayerSlot(pxPlayer^.GetPlayerSlotID()).GetName();
//				CSrvWrap.SendGenericEvtToPlayer(p_pxTransit^.GetOwner(), "WarpDone");
			endif;
		endif;
		CFeedback.Print(CFeedback.ALL, CFeedback.ATTACK, "_NT_WarpGateFinished\t"+sPlayerName);
	endproc;
	
	proc void MarkForAllDestroyed(^CWarpGate p_pxTransit)
		//L KLog.LogSpam("CWarpMgr","MarkForAllDestroyed()");
		var string sPlayerName="unknown";
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel!=null && p_pxTransit!=null)then
			var ^CPlayer pxPlayer=pxLevel^.GetPlayer(p_pxTransit^.GetOwner());
			if(pxPlayer!=null)then
				sPlayerName=pxLevel^.GetLevelInfo().GetPlayerSlot(pxPlayer^.GetPlayerSlotID()).GetName();
			endif;
		endif;
		CFeedback.Print(CFeedback.ALL, CFeedback.ATTACK, "_NT_WarpGateDestroyed\t"+sPlayerName);
	endproc;
	
	proc void StartGameOverTimer()
		if(!Update())then return; endif;
		//L KLog.LogSpam("CWarpMgr","StartGameOverTimer()");
		if(m_iTimer==-1)then
			m_iTimer=CTimeMgr.Get().CreateTimer(CGameTimeSpan.OneSecond() * 10.0, true);
			CTimeMgr.Get().GetTimer(m_iTimer)^.Subscribe(this);
		endif;
	endproc;
	
	proc void StopGameOverTimer()
		if(!Update())then return; endif;
		//L KLog.LogSpam("CWarpMgr","StopGameOverTimer()");
		if(m_iTimer==-1)then return; endif;
		var int i, iC=m_axHndlList.NumEntries();
		var bool bAllTransitsDestroyed=true;
		if(!m_bWarpGateBuild)then
			for(i=0)cond(i<iC)iter(i++)do
				if(m_axHndlList[i].IsValid())then
					bAllTransitsDestroyed=false;
					break;
				endif;
			endfor;
		endif;
		if(bAllTransitsDestroyed)then
			CTimeMgr.Get().GetTimer(m_iTimer)^.Unsubscribe(this);
			CTimeMgr.Get().DeleteTimer(m_iTimer);
			m_iTimer=-1;
		endif;
	endproc;
	
	export proc bool OnPush(ref CEvtPointer p_rxEP)
		//L KLog.LogSpam("CWarpMgr","OnPush()");
		CheckTimer();
		return true;
	endproc;
	
	proc void CheckTimer()
		//L KLog.LogSpam("CWarpMgr","CheckTimer()");
		var int i, iC=m_axHndlList.NumEntries();
		var CGameTime xNow=CTimeMgr.Get().GetTime();
		for(i=0)cond(i<iC)iter(i++)do
			if(m_axHndlList[i].IsValid() && m_abGateReady[i])then
				var ^CWarpGate pxGate=cast<CWarpGate>(m_axHndlList[i].GetObj());
				if(pxGate!=null)then
					var CGameTimeSpan xDiff=xNow-pxGate^.m_xStartTime;
					if(xDiff<m_xGameOverDuration)then
					else
						var CEvtPointer xE=CEvtPointer.CreateEvent("WarpGate");
						xE.SetInt(0,i);
						m_xSource.Broadcast(xE);
						m_bWarpGateBuild=true;
						StopGameOverTimer();
						break;
					endif;
				endif;
			endif;
		endfor;
	endproc;
	
	//someone has started a warp gate
	export proc bool Register(CObjHndl p_xHndl)
		if(!Update())then return false; endif;
		//L KLog.LogSpam("CWarpMgr","Register()");
	
		if(!p_xHndl.IsValid())then return false; endif;
	
		var ^CWarpGate pxTransit=cast<CWarpGate>(p_xHndl.GetObj());
		if(pxTransit==null)then return false; endif;
	
		var int iOwner=pxTransit^.GetOwner();
		if(iOwner<0||iOwner>7)then return false; endif;
	
		if(m_axHndlList[iOwner].IsValid())then return false; endif;
	
		m_axHndlList[iOwner]=p_xHndl;
		MarkForAllStarted(pxTransit);
	
		return true;
	
	endproc;
	
	//someone has destroyed a not yet finished warp gate
	export proc bool Unregister(CObjHndl p_xHndl)
		if(!Update())then return false; endif;
		//L KLog.LogSpam("CWarpMgr","Unregister()");
		if(!p_xHndl.IsValid())then return false; endif;
	
		var ^CWarpGate pxTransit=cast<CWarpGate>(p_xHndl.GetObj());
		if(pxTransit==null)then return false; endif;
	
		var int iOwner=pxTransit^.GetOwner();
		if(iOwner<0||iOwner>7)then return false; endif;
	
		if(!(m_axHndlList[iOwner]==p_xHndl))then return false; endif;
	
		m_axHndlList[iOwner]=CObjHndl.Invalid();
		return true;
	endproc;
	
	//someone has finished a warp gate
	export proc bool Finished(CObjHndl p_xHndl)
		if(!Update())then return false; endif;
		//L KLog.LogSpam("CWarpMgr","Finished()");
	
		if(!p_xHndl.IsValid())then return false; endif;
	
		var ^CWarpGate pxTransit=cast<CWarpGate>(p_xHndl.GetObj());
		if(pxTransit==null)then return false; endif;
	
		var int iOwner=pxTransit^.GetOwner();
		if(iOwner<0||iOwner>7)then return false; endif;
	
		if(!(m_axHndlList[iOwner]==p_xHndl))then return false; endif;
	
		m_abGateReady[iOwner]=true;
		StartGameOverTimer();
		MarkForAllFinished(pxTransit);
	
		return true;
	
	endproc;
	
	//someone has destroyed a finished warp gate
	export proc bool Destroyed(CObjHndl p_xHndl)
		if(!Update())then return false; endif;
		//L KLog.LogSpam("CWarpMgr","Destroyed()");
		if(!p_xHndl.IsValid())then return false; endif;
	
		var ^CWarpGate pxTransit=cast<CWarpGate>(p_xHndl.GetObj());
		if(pxTransit==null)then return false; endif;
	
		var int iOwner=pxTransit^.GetOwner();
		if(iOwner<0||iOwner>7)then return false; endif;
	
		if(!(m_axHndlList[iOwner]==p_xHndl))then return false; endif;
	
		m_axHndlList[iOwner]=CObjHndl.Invalid();
	
		m_abGateReady[iOwner]=false;
		StopGameOverTimer();
		MarkForAllDestroyed(pxTransit);
	
		return true;
	endproc;

endclass;

class CWarpGate inherit CBuilding
	
	var CObjList m_xFOWObjs;
	export var CGameTime m_xStartTime;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!CWarpMgr.Get().Register(GetHandle()))then
			Delete();
			return;
		endif;
		if(CMirageSrvMgr.Get().WarpInvisible())then return; endif;
		if(!p_bLoad)then
			var int i, iC=8;
			for(i=0)cond(i<iC)iter(i++)do
				var ^CShowFOWObj pxO=cast<CShowFOWObj>(CSrvWrap.GetObjMgr()^.CreateObj("ShowFOW_Obj",i,GetPos()));
				if(pxO!=null)then
					m_xFOWObjs.Include(pxO^.GetHandle());
					pxO^.SetFOWRange(20.0);
				endif;
			endfor;
		endif;
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="Warp")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xFOWObjs.DoKArc(pxArc^);
			m_xStartTime.DoKArc(pxArc^);
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="Warp";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xFOWObjs.DoKArc(pxArc^);
		m_xStartTime.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;
	
	export proc void SetReadyBuild()
		super.SetReadyBuild();
		m_xStartTime=CTimeMgr.Get().GetTime();
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		if(HasAnim("standanim"))then
			SetAnim("standanim",3);
			SetShowSpeedLines(true);
		endif;
		if(!CWarpMgr.Get().Finished(GetHandle()))then
			Delete();
		endif;
	endproc;
	
	export proc void Die()
		if(m_bBuildingReady)then
			CWarpMgr.Get().Destroyed(GetHandle());
		else
			CWarpMgr.Get().Unregister(GetHandle());
		endif;
		super.Die();
	endproc;
	
	export proc void Delete()
		var int i, iC=m_xFOWObjs.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(m_xFOWObjs[i].IsValid())then
				m_xFOWObjs[i].GetObj()^.Delete();
			endif;
		endfor;
		super.Delete();
	endproc;

endclass;

class CBuildingCost
	
	static var array string 	ms_asBuilding;
	static var array int 	 	ms_aiWood;
	static var array int 	 	ms_aiFood;
	static var array int 	 	ms_aiStone;
	static var array int 	 	ms_aiIron; // Henry: skulls
	
	export static proc void Register(^CGameObj p_pxObj)
		var ^CBuilding pxBldg=cast<CBuilding>(p_pxObj);
		if(p_pxObj==null||pxBldg==null)then
			return;
		endif;
		var string sClass=p_pxObj^.GetClassName();
		var int iIdx=ms_asBuilding.BinarySearch(sClass);
		if(iIdx<0)then
			var string sPath=pxBldg^.GetBuildAction()+"/conditions/rescosts";
			var ^CBasePlayer pxPlayer=CBasePlayer.GetPlayer(p_pxObj^.GetOwner());
			if(pxPlayer!=null)then
				var ^CTechTree.CNode pxCostNode=pxPlayer^.GetPlayerTechTree().FindNode(sPath);
				if(pxCostNode!=null)then
					iIdx=ms_asBuilding.BinaryInsert(sClass);
					ms_aiWood.InsertEntry(iIdx); ms_aiWood[iIdx]=pxCostNode^.GetSubValueI("wood",0);
					ms_aiFood.InsertEntry(iIdx); ms_aiFood[iIdx]=pxCostNode^.GetSubValueI("food",0);
					ms_aiStone.InsertEntry(iIdx); ms_aiStone[iIdx]=pxCostNode^.GetSubValueI("stone",0);
					ms_aiIron.InsertEntry(iIdx); ms_aiIron[iIdx]=pxCostNode^.GetSubValueI("iron",0);
				endif;
			endif;
		endif;
	endproc;
	
	export static proc bool GetCost(string p_sClass, ref int po_riWood, ref int po_riFood, ref int po_riStone, ref int po_riIron)
		var int iIdx=ms_asBuilding.BinarySearch(p_sClass);
		if(iIdx<0)then
			po_riWood=0;
			po_riFood=0;
			po_riStone=0;
			po_riIron=0;
			return false;
		endif;
		po_riWood=ms_aiWood[iIdx];
		po_riFood=ms_aiFood[iIdx];
		po_riStone=ms_aiStone[iIdx];
		po_riIron=ms_aiIron[iIdx];
		return true;
	endproc;
endclass;

class CRepairDesc
	
	static var array string ms_asResNameMapping;
	
	var array real 	m_afOverallCost;
	var array real 	m_afCostPerHP;
	var array real 	m_afBuildingCost;
	
	var array real 	m_afToPay;
	var bool 				m_bValidCost;
	
	var CObjHndl		m_xBuilding;
	
	export constructor()
		if(ms_asResNameMapping.NumEntries()==0)then
			ms_asResNameMapping.AddEntry("wood");
			ms_asResNameMapping.AddEntry("food");
			ms_asResNameMapping.AddEntry("stone");
			ms_asResNameMapping.AddEntry("iron");
		endif;
		m_afOverallCost=4;
		m_afCostPerHP=4;
		m_afBuildingCost=4;
		m_afToPay=4;
	endconstructor;
	
	export proc void Init(CObjHndl p_xObj)
		m_xBuilding=p_xObj;
		if(p_xObj.IsValid())then
			var int iW, iF, iS, iI;
			m_bValidCost=CBuildingCost.GetCost(p_xObj.GetObj()^.GetClassName(), iW, iF, iS, iI);
			if(m_bValidCost)then
				m_afBuildingCost[0]=iW.ToReal()*0.5f;
				m_afBuildingCost[1]=iF.ToReal()*0.5f;
				m_afBuildingCost[2]=iS.ToReal()*0.5f;
				m_afBuildingCost[3]=iI.ToReal()*0.5f;
			endif;
		endif;
	endproc;
	
	export proc bool GetCost(string p_sResource, ref real po_rfOverall, ref real po_rfPerHP)
		po_rfOverall=0.0f;
		po_rfPerHP=0.0f;
		var int iIdx=ms_asResNameMapping.FindEntry(p_sResource);
		if(iIdx<0)then return false; endif;
		po_rfOverall=m_afOverallCost[iIdx];
		po_rfPerHP=m_afCostPerHP[iIdx];
		return true;
	endproc;
	
	export proc void Update()
		if(!m_xBuilding.IsValid())then return; endif;
		var ^CBuilding pxO=cast<CBuilding>(m_xBuilding.GetObj());
		var real fCurHP=pxO^.GetHitpoints();
		var real fMaxHP=pxO^.GetMaxHitpoints();
		if(fCurHP==fMaxHP)then return; endif;
		var real fPercent=fCurHP / (fMaxHP*0.01f);
		if(!m_bValidCost)then
			var int iW, iF, iS, iI;
			m_bValidCost=CBuildingCost.GetCost(pxO^.GetClassName(), iW, iF, iS, iI);
			if(m_bValidCost)then
				m_afBuildingCost[0]=iW.ToReal()*0.5f;
				m_afBuildingCost[1]=iF.ToReal()*0.5f;
				m_afBuildingCost[2]=iS.ToReal()*0.5f;
				m_afBuildingCost[3]=iI.ToReal()*0.5f;
			endif;
		endif;
		var real fW=m_afBuildingCost[0]*(100.0f-fPercent)*0.01f;
		var real fF=m_afBuildingCost[1]*(100.0f-fPercent)*0.01f;
		var real fS=m_afBuildingCost[2]*(100.0f-fPercent)*0.01f;
		var real fI=m_afBuildingCost[3]*(100.0f-fPercent)*0.01f;
		m_afOverallCost[0]=fW;
		m_afOverallCost[1]=fF;
		m_afOverallCost[2]=fS;
		m_afOverallCost[3]=fI;
		var real fDiff=fMaxHP-fCurHP;
		m_afCostPerHP[0]=fW/fDiff;
		m_afCostPerHP[1]=fF/fDiff;
		m_afCostPerHP[2]=fS/fDiff;
		m_afCostPerHP[3]=fI/fDiff;
	endproc;
	
	export proc bool PayForRepair(real p_fHealedHP, bool p_bFreeRepair, int p_iID)
		if(!m_xBuilding.IsValid())then return false; endif;
		if(p_bFreeRepair)then return true; endif;
		var ^CGameObj pxO=m_xBuilding.GetObj();
		//if((CCharacter.ms_iRepairNoCost-2)==pxO^.GetOwner())then return true; endif;
//		if(CMirageSrvMgr.Get().GetRepairNoCost(pxO^.GetOwner()))then return true; endif;
		if(CMirageSrvMgr.Get().GetRepairNoCost(p_iID))then return true; endif;
		var bool bNoRes=false;
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
//		var ^CPlayer pxPlayer=pxLevel^.GetPlayer(pxO^.GetOwner());
		var ^CPlayer pxPlayer=pxLevel^.GetPlayer(p_iID);
		if(pxPlayer!=null)then
			var ^CAttribs pxA=pxPlayer^.GetAttribs();
			if(pxA!=null)then
				var int i, iC=ms_asResNameMapping.NumEntries();
				for(i=0)cond(i<iC)iter(i++)do
					var int iValue=pxA^.GetValueInt(ms_asResNameMapping[i]);
					if(m_afCostPerHP[i]==0.0f)then continue; endif;
					m_afToPay[i] += m_afCostPerHP[i] * p_fHealedHP;
					if(m_afToPay[i]>=1.0f)then
						var int iV=m_afToPay[i].ToInt();
						iValue-=iV;
						m_afToPay[i]-=iV.ToReal();
					endif;
					if(iValue<=0)then
						iValue=0;
						bNoRes=true;
					endif;
					pxA^.SetValue(ms_asResNameMapping[i], iValue);
				endfor;
			endif;
		endif;
		return !bNoRes;
	endproc;
	
	export proc void DoKArc(^CArc p_pxArc, int p_iVersion, bool p_bLoad)
		var int i, iC=ms_asResNameMapping.NumEntries();
		if(p_iVersion<=3 && !p_bLoad)then
			iC=3;
		endif;
		p_pxArc^ << iC;
		m_afOverallCost=iC;
		m_afCostPerHP=iC;
		m_afBuildingCost=iC;
		for(i=0)cond(i<iC)iter(++i)do
			p_pxArc^ << m_afOverallCost[i];
			p_pxArc^ << m_afCostPerHP[i];
			p_pxArc^ << m_afBuildingCost[i];
			p_pxArc^ << m_afToPay[i];
		endfor;
		p_pxArc^ << m_bValidCost;
		m_xBuilding.DoKArc(p_pxArc^);
		if(p_bLoad &&p_iVersion<5)then
			m_afOverallCost.AddEntry(0.0);
			m_afCostPerHP.AddEntry(0.0);
			m_afBuildingCost.AddEntry(0.0);
			m_afToPay.AddEntry(0.0);
		endif;
	endproc;
endclass;

class CScorpionBoss inherit CBuilding
	
	const int TIMER_ATTACK_START	=547;
	const int TIMER_ATTACK_TICK		=548;
	const int TIMER_ATTACK_END		=549;
	const int TIMER_DESTROY			=550;
	
	const int TIMER_OPEN			=551;
	const int TIMER_CLOSE			=552;
	
	var bool			m_bActive,m_bStateChange;
	var int				m_iAttack;
	var int				m_iState;		//3 - full attack
										//2 - 33% dmg
										//1 - 66% attack
	
	var int				m_iHitState;	//3 - attack
										//2 - prepare
										//1 - wait
										//0 - prepare
	
	var CObjHndl		m_xPanelA;
	var CObjHndl		m_xPanelB;
	var CObjHndl		m_xPanelC;
	var CObjList		m_xPanels;
	var int					m_iPrepareCount;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			m_bActive=false;
			m_iAttack=-1;
			m_bStateChange=false;
			SetVisInFOW(true);
			SetHitable(false);
			SetSelectable(false);
			var ^CScorpionPanel pxPanel=cast<CScorpionPanel>(CSrvWrap.GetObjMgr()^.CreateObj("scorpion_panel_a",GetOwner(),GetPos()+{-20.0,20.0,0.0}));
			m_xPanelA=pxPanel^.GetHandle();
			pxPanel^.SetBoss(GetHandle());
			pxPanel^.SetState(2);
			pxPanel=cast<CScorpionPanel>(CSrvWrap.GetObjMgr()^.CreateObj("scorpion_panel_b",GetOwner(),GetPos()+{-20.0,0.0,0.0}));
			m_xPanelB=pxPanel^.GetHandle();
			pxPanel^.SetBoss(GetHandle());
			pxPanel^.SetState(1);
			pxPanel=cast<CScorpionPanel>(CSrvWrap.GetObjMgr()^.CreateObj("scorpion_panel_c",GetOwner(),GetPos()+{-20.0,-20.0,0.0}));
			m_xPanelC=pxPanel^.GetHandle();
			pxPanel^.SetBoss(GetHandle());
			pxPanel^.SetState(0);
			SetAnim("stand_up",0,2);
			m_xPanels.AddEntry(m_xPanelA);
			m_xPanels.AddEntry(m_xPanelB);
			m_xPanels.AddEntry(m_xPanelC);
		endif;
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="ScBo")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			if(iVersion>=1)then
				pxArc^<<m_bActive;
			endif;
			if(iVersion>=2)then
				pxArc^ << m_iAttack;
			endif;
			if(iVersion>=3)then
				pxArc^ << m_iState;
				pxArc^ << m_bStateChange;
				m_xPanelA.DoKArc(pxArc^);
				m_xPanelB.DoKArc(pxArc^);
				m_xPanelC.DoKArc(pxArc^);
			endif;
			if(iVersion==4)then
				var CObjHndl xInvalid;
				xInvalid.DoKArc(pxArc^);
			endif;
			if(iVersion>=5)then
				m_xPanels.DoKArc(pxArc^);
			endif;
			if(iVersion>=6)then
				pxArc^ << m_iPrepareCount;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="ScBo";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,6);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		pxArc^ << m_bActive;
		pxArc^ << m_iAttack;
		pxArc^ << m_iState;
		pxArc^ << m_bStateChange;
		m_xPanelA.DoKArc(pxArc^);
		m_xPanelB.DoKArc(pxArc^);
		m_xPanelC.DoKArc(pxArc^);
		m_xPanels.DoKArc(pxArc^);
		pxArc^ << m_iPrepareCount;
		pxWalk^.Close();
	endproc;
	
	proc void OnDefend(^CGameObj p_pxEnemy)
		if(p_pxEnemy!=null)then
//			ReactToGamePlayCommand("Action",p_pxEnemy, p_pxEnemy^.GetPos(), "/AttackSrv");
			AttackSrv(p_pxEnemy);
		endif;
	endproc;
	
	export proc bool AttackEnemy(^CFightingObj p_pxEnemy, vec3 p_vTarget, ref bool p_rbRotated)
		if(!m_bActive)then return false; endif;
		if(m_bStateChange)then
			if(m_iState==2)then
				SetDestructLevel(1);
			elseif(m_iState==1)then
				SetDestructLevel(2);
			endif;
			StartDestructionAnim();
			m_iAttack=4;
			m_iHitState=0;
			m_bStateChange=false;
			return false;
		endif;
		if(m_iState==4)then
			SetAnim("standanim",1);
			m_iState=3;
			return false;
		endif;
		if(p_pxEnemy!=null)then
			if(m_iPrepareCount>0)then
				Prepare();
				return false;
			endif;
			if(m_iHitState==0)then
				m_iAttack=Random.GetInt()%Math.Max(m_iState,1);
				m_iPrepareCount=1;
				Prepare();
				return false;
			elseif(m_iHitState==1)then
				Wait();
				return false;
			elseif(m_iHitState==2)then
				m_iPrepareCount=1;
				Prepare();
				return false;
			endif;
			m_iHitState=0;
			DeleteTimer(TIMER_ATTACK_START);
			DeleteTimer(TIMER_ATTACK_END);
	
			if(m_iAttack==0)then	//Legs
				if(HasAnim("attack_3"))then
					SetAnim("attack_3",1);
				endif;
				CreateTimer(TIMER_ATTACK_START,CGameTimeSpan.OneSecond()*2.8,false);
				CreateTimer(TIMER_ATTACK_END,CGameTimeSpan.OneSecond()*3.2,false);
				return false;
			endif;
	
			if(m_iAttack==1)then	//Flamethrower
				if(HasAnim("attack_2"))then
					SetAnim("attack_2",1);
				endif;
				CreateTimer(TIMER_ATTACK_START,CGameTimeSpan.OneSecond()*5.2,false);
				CreateTimer(TIMER_ATTACK_END,CGameTimeSpan.OneSecond()*11.0,false);
				return false;
			endif;
	
			if(m_iAttack==2)then	//Scissors
				if(HasAnim("attack_1"))then
					SetAnim("attack_1",1);
				endif;
				CreateTimer(TIMER_ATTACK_START,CGameTimeSpan.OneSecond()*1.0,false);
				CreateTimer(TIMER_ATTACK_END,CGameTimeSpan.OneSecond()*1.4,false);
				return false;
			endif;
		endif;
		return false;
	endproc;
	
	proc void Prepare()
		var string sAnim;
		if(m_iAttack==0)then
			sAnim="prepare_3";
		elseif(m_iAttack==1)then
			sAnim="prepare_2";
		elseif(m_iAttack==2)then
			sAnim="prepare_1";
		endif;
		if(HasAnim(sAnim))then
			SetAnim(sAnim,1);
		endif;
		m_iPrepareCount--;
		m_iHitState++;
	endproc;
	
	proc void Wait()
		var string sAnim="standanim";
		if(HasAnim(sAnim))then
			SetAnim(sAnim,1);
		endif;
		m_iHitState=2;
	endproc;
	
	export proc void SetIdleAnim()
		if(!m_bActive)then return; endif;
		super.SetIdleAnim();
	endproc;
	
	proc void StartDestructionAnim()
		InvokeGenericSCEvent(14,4.0f);
		if(m_iState==3)then
			SetAnim("standanim",1);
		elseif(m_iState==2)then
			SetAnim("destroy_1",1);
		elseif(m_iState==1)then
			SetAnim("destroy_2",1);
		else
			if(HasAnim("dying"))then
				SetAnim("dying",1);
			endif;
		endif;
		//create dest objs, play both dest anims
	endproc;
	
	export proc void UpdateState()
		m_iState--;
		m_bStateChange=true;
		if(m_iState<=0)then
			Die();
		endif;
		DeleteTimer(TIMER_OPEN);
		DeleteTimer(TIMER_CLOSE);
		ClosePanel();
	endproc;
	
	export proc void SetState(int p_iState)
		m_iState=p_iState;
	endproc;
	
	proc void OpenRandomPanel()
		ValidatePanels();
		if(m_xPanels.NumEntries()<=0)then return; endif;
		var int iRandom=Random.GetInt()%m_xPanels.NumEntries();
		var ^CGameObj pxObj=m_xPanels[iRandom].GetObj();
		DeleteTimer(TIMER_OPEN);
		CreateTimer(TIMER_CLOSE,CGameTimeSpan.OneSecond()*25.0, false);
		if(pxObj==null)then return; endif;
		pxObj^.SetHitable(true);
		pxObj^.SetSelectable(true);
		pxObj^.SetAnim("open",1);
	endproc;
	
	proc void ValidatePanels()
		var int i,iC=m_xPanels.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(!m_xPanels[i].IsValid())then
				m_xPanels.DeleteEntry(i);i--;iC--;
			endif;
		endfor;
	endproc;
	
	proc void ClosePanel()
		ValidatePanels();
		var int i,iC=m_xPanels.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CGameObj pxObj=m_xPanels[i].GetObj();
			if(pxObj==null)then continue; endif;
			if(pxObj^.IsHitable())then
				pxObj^.SetHitable(false);
				pxObj^.SetSelectable(false);
				pxObj^.SetAnim("open",2);
			endif;
		endfor;
		DeleteTimer(TIMER_CLOSE);
		CreateTimer(TIMER_OPEN,CGameTimeSpan.OneSecond()*10.0, false);
	endproc;
	
	export proc real GetWeaponDuration()
/*		if(m_iAttack==4)then	//Destruction
			if(m_iState==2)then
				return 16.0;
			else
				return 5.0;
			endif;
		elseif(m_iAttack==0)then
			return 4.0;
		elseif(m_iAttack==1)then
			return 12.0;
		elseif(m_iAttack==2)then
			return 2.8;
		else
			return 2.0;
		endif;

*/		return GetCurrentAnimLength();
	endproc;
	
	proc bool UpdateDestructionFlags()
		if(m_iState==2)then
			SetDestructLevel(1);
		elseif(m_iState==1)then
			SetDestructLevel(2);
		endif;
		return false;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(p_sMiscParams.Find("/JumpOffWall")!=-1)then
			if(!m_bActive)then
				OpenRandomPanel();
				SetState(4);
				OnTechTreeChange();
				var bool bInvalid;
				AttackEnemy(null, GetPos(), bInvalid);
			endif;
			m_bStateChange=false;
			m_bActive=true;
			//AnimAction("");
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	export proc bool FollowEnemy(^CFightingObj p_pxEnemy, bool p_bAttackScape)
		return true;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==TIMER_ATTACK_START)then
				DoDamage();
				DeleteTimer(TIMER_ATTACK_TICK);
				CreateTimer(TIMER_ATTACK_TICK,CGameTimeSpan.OneSecond()*1.0,true);
			elseif(p_rxEvtPtr.GetInt(0)==TIMER_ATTACK_END)then
				DeleteTimer(TIMER_ATTACK_TICK);
			elseif(p_rxEvtPtr.GetInt(0)==TIMER_ATTACK_TICK)then
				DoDamage();
			elseif(p_rxEvtPtr.GetInt(0)==TIMER_OPEN)then
				OpenRandomPanel();
			elseif(p_rxEvtPtr.GetInt(0)==TIMER_CLOSE)then
				ClosePanel();
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	export proc void DoDamage()
		var string sRegionName;
		var real fDamage;
		if(m_iAttack==0)then
			sRegionName="scorpion_legs";
			fDamage=250.0;
		elseif(m_iAttack==1)then
			sRegionName="scorpion_flamethrower";
			fDamage=50.0; //per tick
		elseif(m_iAttack==2)then
			sRegionName="scorpion_scissors";
			fDamage=250.0;
		else
			return;
		endif;
		var ^CRegion pxRegion=CSrvWrap.GetRegionMgr().GetRegion(sRegionName);
		if(pxRegion==null)then return; endif;
		var CObjList xObjList;
		var int i,iC=pxRegion^.NumObjects();
		for(i=0)cond(i<iC)iter(i++)do
			xObjList.AddEntry(pxRegion^.GetObject(i));
		endfor;
		iC=xObjList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFightingObj pxFighter=cast<CFightingObj>(xObjList[i].GetObj());
			if(xObjList[i]==GetHandle())then continue; endif;
			if(pxFighter==null)then continue; endif;
			if(CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxFighter^.GetOwner(), GetOwner()))then continue; endif;
			if(pxFighter^.GetTransportObj().IsValid())then continue; endif;
			if(cast<CScorpionPanel>(pxFighter)!=null)then continue; endif;
			pxFighter^.TakeDirectMeleeDmg(fDamage,GetHandle());
		endfor;
	endproc;
	
	export proc int GetAggressive()
		return GetTechTreeAggressiv();
	endproc;
	
	export proc bool IsAbleToFight()
			return true;
		endproc;

endclass;

class CScorpionPanel inherit CBuilding
	
	var CObjHndl	m_xBoss;
	var int				m_iState;
	
	export proc void SetBoss(CObjHndl p_xBoss)
		m_xBoss=p_xBoss;
	endproc;
	
	export proc void SetState(int p_iState)
		m_iState=p_iState;
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			SetVisInFOW(true);
			SetHitable(false);
			SetSelectable(false);
		endif;
		if(!IsHitable())then
			SetAnim("open",0,0);
		endif;
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="ScPa")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			if(iVersion>=1)then
				pxArc^<<m_iState;
				m_xBoss.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="ScPa";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		pxArc^<<m_iState;
		m_xBoss.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;
	
	export proc void Die()
		if(!IsDead())then
			var ^CScorpionBoss pxBoss=cast<CScorpionBoss>(m_xBoss.GetObj());
			if(pxBoss!=null)then
				pxBoss^.UpdateState();
			endif;
		endif;
		super.Die();
	endproc;

endclass;
