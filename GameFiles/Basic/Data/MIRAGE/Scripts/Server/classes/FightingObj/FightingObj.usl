class CFightingObj inherit CGameObj

	//========================================================================================
	//===START MEMBER CLASSES===============================================================
	//========================================================================================
	
	class CActionObj
	
		var CGameTime m_xStartTime;
		var real m_fDuration;
		export var string m_sTTPath;
		export var procref <bool,string> m_xOnCheckConditions;
		export var procref <void,string> m_xOnStartAction;
	
		export constructor()
		endconstructor;
	
		export destructor()
		enddestructor;
	
		export proc void SetStartTime(CGameTime p_xStartTime)
			m_xStartTime=p_xStartTime;
		endproc;
	
		export proc ref CGameTime GetStartTime()
			return m_xStartTime;
		endproc;
	
		export proc void SetDuration(real p_fDuration)
			m_fDuration=p_fDuration;
		endproc;
	
		export proc ref real GetDuration()
			return m_fDuration;
		endproc;
	
		export proc void SetTTPath(string p_sTTPath)
			m_sTTPath=p_sTTPath;
		endproc;
	
		export proc ref string GetTTPath()
			return m_sTTPath;
		endproc;
	
		export proc bool op_Equal(ref CFightingObj.CActionObj p_rxObj)
			return (m_sTTPath==p_rxObj.m_sTTPath);
		endproc;
	
		export proc bool CheckConditions()
			if(!m_xOnCheckConditions.IsNull())then
				return m_xOnCheckConditions.Call(m_sTTPath);
			else
				return false;
			endif;
		endproc;
	
		export proc void StartAction()
			if(!m_xOnStartAction.IsNull())then
				m_xOnStartAction.Call(m_sTTPath);
			endif;
		endproc;
	
		export proc void DoKArc(ref CArc p_rxArc)
			m_xStartTime.DoKArc(p_rxArc);
			p_rxArc << m_fDuration;
			p_rxArc << m_sTTPath;
		endproc;
	
	endclass;
	
	//========================================================================================
	
	class CDmgTimer
	
		export constructor()
		endconstructor;
	
		export destructor()
			if(m_pxTick!=null)then delete m_pxTick; endif;
		enddestructor;
	
		var CObjHndl	m_xSource;
		var int			m_iTimer;
		var real		m_fDmg;
		var ^CTimerIDTick	m_pxTick;
		var bool		m_bProjectile;
		var real		m_fPoisonDmg;
		var int			m_iMaxTickCount;
		var real		m_fFireDmg;
		var int			m_iMaxBurnCount;

		export proc void Init(int p_iTimer, real p_fDmg, CObjHndl p_xSource, ^CTimerIDTick p_pxTick, bool p_bProjectile, real p_fPoisonDmg, int p_iTickCount, real p_fFireDmg, int p_iBurnCount)
			m_xSource		= p_xSource;
			m_fDmg			= p_fDmg;
			m_iTimer		= p_iTimer;
			m_pxTick		= p_pxTick;
			m_bProjectile	= p_bProjectile;
			m_fPoisonDmg	= p_fPoisonDmg;
			m_iMaxTickCount	= p_iTickCount;
			m_fFireDmg	= p_fFireDmg;
			m_iMaxBurnCount	= p_iBurnCount;
		endproc;
	
		export proc ref int GetTimer()
			return m_iTimer;
		endproc;
	
		export proc ref real GetDmg()
			return m_fDmg;
		endproc;
	
		export proc ref CObjHndl GetSource()
			return m_xSource;
		endproc;
	
		export proc ^CTimerIDTick GetTick()
			return m_pxTick;
		endproc;
	
		export proc ref bool IsProjectile()
			return m_bProjectile;
		endproc;
	
		export proc ref real GetPoisonDmg()
			return m_fPoisonDmg;
		endproc;
	
		export proc ref int GetPoisonMaxTickCount()
			return m_iMaxTickCount;
		endproc;
	
		export proc ref real GetFireDmg()
			return m_fFireDmg;
		endproc;
	
		export proc ref int GetBurnMaxTickCount()
			return m_iMaxBurnCount;
		endproc;
	
		export proc void DoKArc(ref CArc p_rxArc, int p_iVersion)
			m_xSource.DoKArc(p_rxArc);
			p_rxArc << m_iTimer;
			p_rxArc << m_fDmg;
			p_rxArc << m_bProjectile;
			p_rxArc << m_fPoisonDmg;
			p_rxArc << m_iMaxTickCount;
			if(p_iVersion>=22)then
				p_rxArc << m_fFireDmg;
				p_rxArc << m_iMaxBurnCount;
			else
				m_fFireDmg=0.0f;
				m_iMaxBurnCount=0;
			endif;
			if(m_pxTick==null)then
				m_pxTick=new CTimerIDTick();
			endif;
			m_pxTick^.DoKArc(p_rxArc);
		endproc;
	
		export proc void SetParentProcRef(procref <void,int> p_xProcRef)
			if(m_pxTick!=null)then
				m_pxTick^.m_xOnTickID=p_xProcRef;
			endif;
		endproc;
	
	endclass;
	
	//========================================================================================
	
	class CCamouflageLayer
	
		export var CFourCC	m_xType;
		export var int			m_iCount;
		var bool						m_bDisabled;
		var bool						m_bRevealed;
		var bool						m_bBurning;
		export var CObjList	m_xSrcObjs;
	
		export constructor()
			m_bDisabled=false;
			m_bRevealed=false;
			m_bBurning=false;
		endconstructor;
	
		export destructor()
		enddestructor;
	
		export proc bool IsValid()
			return m_iCount>0;
		endproc;
	
		export proc void Inc()
			m_iCount++;
		endproc;
	
		export proc void SetType(string p_sType)
			m_xType=p_sType;
		endproc;
	
		export proc void Dec()
			m_iCount--;
			if(m_iCount<0)then
				m_iCount=0;
			endif;
		endproc;
	
		export proc void SetDisabled(bool p_bValue)
			m_bDisabled=p_bValue;
		endproc;
	
		export proc void SetBurning(bool p_bValue)
			m_bBurning=p_bValue;
		endproc;
	
		export proc void SetRevealed(bool p_bValue)
			m_bRevealed=p_bValue;
		endproc;
	
		export proc bool IsOffline()
			return m_bRevealed||m_bDisabled||m_bBurning;
		endproc;
	
		export proc void AddSrcObj(CObjHndl p_xObj)
			m_xSrcObjs.AddEntry(p_xObj);
		endproc;
	
		export proc void RemSrcObj(CObjHndl p_xObj)
			var int iIdx=m_xSrcObjs.FindEntry(p_xObj);
			if(iIdx!=-1)then
				m_xSrcObjs.DeleteEntry(iIdx);
			endif;
		endproc;
	
		export proc bool op_Equal(string p_sOther)
			if(p_sOther==""||p_sOther.IsEmpty()/*||m_xType==""*/)then return false; endif;
			return (m_xType==p_sOther);
		endproc;
	
		export proc bool op_Equal(ref CFightingObj.CCamouflageLayer p_rxObj)
			if(p_rxObj.m_xType==""/*||m_xType==""*/)then return false; endif;
			return (m_xType==p_rxObj.m_xType);
		endproc;
	
		export proc void DoKArc(ref CArc p_rxArc)
			var int iVersion=2;
			p_rxArc << iVersion;
			var string sType=m_xType.AsString();
			p_rxArc << sType;
			m_xType=sType;
			p_rxArc << m_iCount;
			if(iVersion>=2)then
				p_rxArc << m_bDisabled;
			endif;
		endproc;
	
	endclass;
	
	//========================================================================================
	
	class CPoisonTick inherit CEvtSink
		
		const real FREQUENCY=2.0;
		
		var int					m_iTimer;
		var real				m_fDmgPerTick;
		var int					m_iTickCount;
		var int					m_iMaxTickCount;
		var CObjHndl		m_xSource;
		var int					m_iEnemy;
		
		export var procref <void, real, CObjHndl, int> m_xOnTick;
		export var procref <void> m_xOnDecay;
		
		export constructor()
			m_xOnTick=OnTick;
			m_xOnDecay=OnDecay;
			m_iTimer=-1;
			m_iTickCount=0;
			m_xSource=CObjHndl.Invalid();
			m_iEnemy=-1;
		endconstructor;
		
		export destructor()
			if(m_iTimer!=-1)then
				CTimeMgr.Get().GetTimer(m_iTimer)^.Unsubscribe(this);
				CTimeMgr.Get().DeleteTimer(m_iTimer);
			endif;
			m_xSource=CObjHndl.Invalid();
			m_iEnemy=-1;
		enddestructor;
		
		export proc ref CObjHndl GetSource()
			return m_xSource;
		endproc;
		
		export proc ref int GetEnemy()
			return m_iEnemy;
		endproc;
		
		export proc bool op_LessEqual(real p_fOther)
			return m_fDmgPerTick<=p_fOther;
		endproc;
		
		export proc bool op_LessEqual(int p_iOther)
			return (m_iMaxTickCount-m_iTickCount)<=p_iOther;
		endproc;
		
		export proc bool op_GreaterEqual(real p_fOther)
			return m_fDmgPerTick>=p_fOther;
		endproc;
		
		export proc bool op_GreaterEqual(int p_iOther)
			return (m_iMaxTickCount-m_iTickCount)>=p_iOther;
		endproc;
		
		export proc ref CFightingObj.CPoisonTick op_Assign(ref CFightingObj.CPoisonTick p_rxOther)
			SetPoison(p_rxOther.GetDmgPerTick(), p_rxOther.GetMaxTickCount(), p_rxOther.GetCurTickCount(), p_rxOther.GetSource(), p_rxOther.GetEnemy());
			return(this^);
		endproc;
		
		proc void OnTick(real p_fReal, CObjHndl p_xSource, int p_iEnemy)
		endproc;
		
		proc void OnDecay()
		endproc;
		
		export proc bool OnPush(ref CEvtPointer  p_rxEP)
			if(!m_xOnTick.IsNull())then
				m_xOnTick.Call(m_fDmgPerTick, m_xSource, m_iEnemy);
			endif;
			m_iTickCount++;
			if(m_iTickCount >= m_iMaxTickCount)then
				Reset();
				m_xOnDecay.Call();
			endif;
			return true;
		endproc;
		
		export proc void SetPoison(real p_fDmg, int p_iMaxTickCount, int p_iCurTickCount, CObjHndl p_xSource, int p_iEnemy)
			if(m_iTimer==-1)then
				m_iTimer=CTimeMgr.Get().CreateTimer(CGameTimeSpan.OneSecond() * FREQUENCY, true);
				CTimeMgr.Get().GetTimer(m_iTimer)^.Subscribe(this);
			endif;
			m_fDmgPerTick=p_fDmg;
			m_iMaxTickCount=p_iMaxTickCount;
			m_iTickCount=p_iCurTickCount;
			m_xSource=p_xSource;
			m_iEnemy=p_iEnemy;
		endproc;
		
		export proc ref int GetCurTickCount()
			return m_iTickCount;
		endproc;
		
		export proc int GetTicksLeft()
			return (m_iMaxTickCount - m_iTickCount);
		endproc;
		
		export proc ref int GetMaxTickCount()
			return m_iMaxTickCount;
		endproc;
		
		export proc ref real GetDmgPerTick()
			return m_fDmgPerTick;
		endproc;
		
		export proc void Reset()
			if(m_iTimer!=-1)then
				CTimeMgr.Get().GetTimer(m_iTimer)^.Unsubscribe(this);
				CTimeMgr.Get().DeleteTimer(m_iTimer);
				m_iTimer=-1;
			endif;
			m_iTickCount=0;
			m_iMaxTickCount=0;
			m_fDmgPerTick=0.0;
			m_xSource=CObjHndl.Invalid();
			m_iEnemy=-1;
		endproc;
		
		export proc void DoKArc(ref CArc p_rxArc, int p_iVersion)
			var bool bTimerStart=(m_iTimer==-1);
			p_rxArc << m_iTimer;
			p_rxArc << m_fDmgPerTick;
			p_rxArc << m_iTickCount;
			p_rxArc << m_iMaxTickCount;
			if(m_iTimer!=-1&&bTimerStart)then
				m_iTimer=CTimeMgr.Get().CreateTimer(CGameTimeSpan.OneSecond() * FREQUENCY, true);
				CTimeMgr.Get().GetTimer(m_iTimer)^.Subscribe(this);
			endif;
			if(p_iVersion>=22)then
				m_xSource.DoKArc(p_rxArc);
				p_rxArc << m_iEnemy;
			endif;
		endproc;
	
	endclass;
	
	//========================================================================================
	
	class CFightAnim
	
		export constructor()
			m_bIsComboAnim=false;
			m_bPenetrate=false;
			m_fAngle=0.0;
			m_fSplash=0.0;
			m_fFactor=1.0;
			m_fProjectileTimeOutStart=-1.0;
			m_fProjectileTimeOutEnd=-1.0;
		endconstructor;
	
		export destructor()
		enddestructor;
	
		export proc void Clear()
			m_sAnim="";
			m_fDelay=0.0;
			m_fFactor=1.0;
			m_sFollowAnim="";
			m_fShootDelay=0.0;
			m_bIsComboAnim=false;
			m_bPenetrate=false;
			m_fAngle=0.0;
			m_fSplash=0.0;
			m_fProjectileTimeOutStart=-1.0;
			m_fProjectileTimeOutEnd=-1.0;
		endproc;
	
		export var string	m_sAnim;
		export var real		m_fDelay;
		export var real		m_fFactor;
		export var real		m_fAngle;
		export var real		m_fSplash;
		export var real		m_fShootDelay;
		export var string	m_sFollowAnim;
		export var bool		m_bIsComboAnim;
		export var bool		m_bPenetrate;
		export var real		m_fProjectileTimeOutStart;
		export var real		m_fProjectileTimeOutEnd;
	
	endclass;
	
	//========================================================================================
	
	class CSpecialAbility
	
		class CAbilityData
	
			export constructor()
			endconstructor;
	
			export constructor(string p_sKey)
				m_sKey=p_sKey;
			endconstructor;
	
			export constructor(string p_sKey, string p_sValue)
				m_sKey=p_sKey;
				m_sValue=p_sValue;
			endconstructor;
	
			export constructor(ref CFightingObj.CSpecialAbility.CAbilityData p_rxRhs)
				m_sKey=p_rxRhs.m_sKey;
				m_sValue=p_rxRhs.m_sValue;
			endconstructor;
	
			export proc string GetKey() return m_sKey; endproc;
			export proc string GetValueS() return m_sValue; endproc;
			export proc int GetValueI() return m_sValue.ToInt(); endproc;
			export proc real GetValueF() return m_sValue.ToReal(); endproc;
			export proc bool GetValueB() return m_sValue=="true"; endproc;
	
			export proc void SetKey(string p_sKey) m_sKey=p_sKey; endproc;
			export proc void SetValue(string p_sVal) m_sValue=p_sVal; endproc;
			export proc void SetValue(int p_iVal) m_sValue=p_iVal.ToString(); endproc;
			export proc void SetValue(real p_fVal) m_sValue=p_fVal.ToString(); endproc;
			export proc void SetValue(bool p_bVal) m_sValue=p_bVal.ToString(); endproc;
	
			var string m_sKey;
			var string m_sValue;
	
		endclass;
	
		export constructor()
		endconstructor;
	
		export constructor(string p_sName)
			m_sName=p_sName;
		endconstructor;
	
		export constructor(^CTechTree.CNode p_pxNode)
			Initialize(p_pxNode);
		endconstructor;
	
		export proc bool Initialize(^CTechTree.CNode p_pxNode)
			if(p_pxNode==null)then return false; endif;
			m_axData=0;
			m_sName=p_pxNode^.GetName();
			m_bEnabled=p_pxNode^.GetSubValue("enabled", "false")=="true";
			var ^CTechTree.CNode pxIter=null;
			var int i, iC=p_pxNode^.NumSubs();
			for(i=0) cond(i<iC) iter(++i)do
				pxIter=p_pxNode^.GetSub(i);
				if(pxIter==null||pxIter^.GetName()=="enabled")then continue; endif;
				var ^CAbilityData pxData=^(m_axData.NewEntryRef());
				pxData^.SetKey(pxIter^.GetName());
				pxData^.SetValue(pxIter^.GetValue());
			endfor;
			return true;
		endproc;
	
		proc ^CFightingObj.CSpecialAbility.CAbilityData GetValue(string p_sKey)
			var int i, iC=m_axData.NumEntries();
			for(i=0) cond(i<iC) iter(++i)do
				if(m_axData[i].GetKey()==p_sKey)then
					return ^(m_axData[i]);
				endif;
			endfor;
			return null;
		endproc;
	
		export proc string GetName() return m_sName; endproc;
		export proc bool IsEnabled() return m_bEnabled; endproc;
	
		export proc void SetEnabled(bool p_bOn) m_bEnabled=p_bOn; endproc;
	
		export proc string GetValueS(string p_sKey)
			var ^CAbilityData pxD=GetValue(p_sKey);
			if(pxD!=null)then
				return pxD^.GetValueS();
			endif;
			return "";
		endproc;
	
		export proc int GetValueI(string p_sKey)
			var ^CAbilityData pxD=GetValue(p_sKey);
			if(pxD!=null)then
				return pxD^.GetValueI();
			endif;
			return 0;
		endproc;
	
		export proc real GetValueF(string p_sKey)
			var ^CAbilityData pxD=GetValue(p_sKey);
			if(pxD!=null)then
				return pxD^.GetValueF();
			endif;
			return 0.0f;
		endproc;
	
		export proc bool GetValueB(string p_sKey)
			var ^CAbilityData pxD=GetValue(p_sKey);
			if(pxD!=null)then
				return pxD^.GetValueB();
			endif;
			return false;
		endproc;
	
		var string m_sName;
		var bool m_bEnabled;
		var array CAbilityData m_axData;
	
	endclass;
	
	//========================================================================================
	
	class CSpecialAbilitiesContainer
	
		var array CSpecialAbility m_axAbilities;
	
		export constructor()
		endconstructor;
	
		export proc void Clear()
			m_axAbilities=0;
		endproc;
	
		export proc bool AddAbilities(^CTechTree.CNode p_pxAbsNode)
			if(p_pxAbsNode==null||p_pxAbsNode^.GetName()!="special_abilities")then
				return false;
			endif;
	
			var ^CTechTree.CNode pxIter=null;
			var int i, iC=p_pxAbsNode^.NumSubs();
			for(i=0) cond(i<iC) iter(++i)do
				pxIter=p_pxAbsNode^.GetSub(i);
				if(!m_axAbilities.NewEntryRef().Initialize(pxIter))then
					KLog.LogWarn("Character", "Failed to Initialize Abilities");
					return false;
				endif;
			endfor;
			return true;
		endproc;
	
		export proc bool AddAbilities(^CTechTree.CNode p_pxAbsNode, bool p_bClearFirst)
			if(p_bClearFirst)then Clear(); endif;
			return AddAbilities(p_pxAbsNode);
		endproc;
	
		// Returns the SpecialAbility with passed name. Will be null if no ability with
		// such a name was found.
		export proc ^CFightingObj.CSpecialAbility GetAbility(string p_sName)
			var int i, iC=m_axAbilities.NumEntries();
			for(i=0) cond(i<iC) iter(++i)do
				if(m_axAbilities[i].GetName()==p_sName)then
					return ^(m_axAbilities[i]);
				endif;
			endfor;
			return null;
		endproc;
	
		// Returns the SpecialAbility with passed name. Will be null if no ability with
		// such a name was found. If p_bOnlyIfEnabled is set to true the returned pointer will
		// also be null if the ability is not enabled.
		export proc ^CFightingObj.CSpecialAbility GetAbility(string p_sName, bool p_bOnlyIfEnabled)
			var ^CSpecialAbility pxA=GetAbility(p_sName);
			if(!p_bOnlyIfEnabled||(pxA!=null&&pxA^.IsEnabled()))then
				return pxA;
			endif;
			return null;
		endproc;
	
	endclass;
	
	//========================================================================================
	
	class CPatrolInfo
		
		export var array vec3		m_avWaypoints;
		export var int					m_iMode;
		export var int					m_iCurIdx;
		export var int					m_iLastIdx;
		var int									m_iSpeed;
		var bool								m_bPointReached;
		
		export constructor()
			m_iMode=0;
			m_iLastIdx=-1;
			m_iCurIdx=0;
			m_iSpeed=1;
			m_bPointReached=false;
		endconstructor;
		
		export constructor(ref array vec3 p_ravWaypoints,int p_iMode,int p_iSpeed)
			m_avWaypoints=p_ravWaypoints;
			m_iMode=p_iMode;
			m_iLastIdx=-1;
			m_iCurIdx=0;
			m_iSpeed=p_iSpeed;
			m_bPointReached=false;
		endconstructor;
		
		export proc int GetSpeed()
			return m_iSpeed;
		endproc;
		
		export proc ^vec3 GetNextWaypoint(vec3 p_vCurPos)
			var ^vec3 pvCurWP=null;
			if(m_iCurIdx>=0&&m_iCurIdx<m_avWaypoints.NumEntries())then
				pvCurWP= ^(m_avWaypoints[m_iCurIdx]);
			endif;
			if(pvCurWP==null)then
				return null;
			endif;
			if(!m_bPointReached)then
				return pvCurWP;
			endif;
			if(m_iMode==0)then// 0=1 2 3 4
				m_iCurIdx++;
			elseif(m_iMode==1)then// 1=Circular Patrol ... Ex.: 1 2 3 4 1 2 3 4 1 ....
				m_iCurIdx++;
				m_iCurIdx=(m_iCurIdx%m_avWaypoints.NumEntries());
			else// 2=Linear Patrol ... Ex.: 1 2 3 4 3 2 1 2 3 ....
				if(m_iCurIdx>m_iLastIdx)then
					m_iLastIdx=m_iCurIdx;
					m_iCurIdx++;
					if(m_iCurIdx>=m_avWaypoints.NumEntries())then
						m_iCurIdx=m_iLastIdx-1;
					endif;
				else
					m_iLastIdx=m_iCurIdx;
					m_iCurIdx--;
					if(m_iCurIdx<0)then
						m_iCurIdx=m_iLastIdx+1;
					endif;
				endif;
			endif;
			if(m_iCurIdx>=0&&m_iCurIdx<m_avWaypoints.NumEntries())then
				return ^(m_avWaypoints[m_iCurIdx]);
			endif;
			return null;
		endproc;
		
		export proc void PatrolPointReached()
			m_bPointReached=true;
		endproc;
		
		export proc void DoKArc(ref CArc p_rxArc)
			var int iVersion=1;
			p_rxArc << iVersion;
			var int i,iC=m_avWaypoints.NumEntries();
			p_rxArc << iC;
			m_avWaypoints=iC;
			for(i=0)cond(i<iC)iter(i++)do
				p_rxArc << (m_avWaypoints[i]);
			endfor;
			p_rxArc << m_iMode;
			p_rxArc << m_iCurIdx;
			p_rxArc << m_iLastIdx;
			p_rxArc << m_iSpeed;
			if(iVersion==1)then
				p_rxArc << m_bPointReached;
			endif;
		endproc;
		
	endclass;
	
	//========================================================================================
	
	class CWeaponCache
	
		export constructor()
		endconstructor;
	
		export destructor()
		enddestructor;
	
		export var string		m_sWeaponPath;
		export var int			m_iWeaponSizeClass;
		export var string		m_sProjectile;
		export var real			m_fProjectileFallOff;
		export var real			m_fProjectileSpeed;
		export var real			m_fProjectileJitter;
		export var real			m_fWeaponDuration;
		export var array CFightingObj.CFightAnim	m_axAnims;
	
		export var real			m_fDmg;
		export var real			m_fProtection;
		export var real			m_fRangedProtection;
		export var real			m_fArmorPiercing;
		export var real			m_fMinAttackRange;
		export var bool			m_bPenetration;
		export var real			m_fPenetrationAngle;
		export var real			m_fPenetrationFactor;
		export var real			m_fHitRange;
		export var real			m_fEndDmg;
		export var real			m_fPoisonDmg;
		export var int			m_iPoisonMaxTickCount;
		export var real			m_fAttackRange;
		export var CBonus		m_xAttackBoni;
		export var CBonus		m_xDefenseBoni;
		export var CBonus		m_xRangedDefBoni;
	
		//Henry: to use the same the poison effect against buildings (ofc changing the visual experience ;D)
		export var real			m_fFireDmg;
		export var int			m_iBurnTime;
		//Henry: to get can fight air attrib from techtree
		export var bool			m_bAirWeapon;
	
	endclass;
	
	//========================================================================================
	
	class CTempSortString
	
		export constructor()
		endconstructor;
	
		export destructor()
		enddestructor;
	
		export var string m_sString;
		export var real m_fReal;
	
		export proc bool op_Greater(ref CFightingObj.CTempSortString p_rxOther)
			return (m_fReal<p_rxOther.m_fReal);
		endproc;
	
		export proc void op_Assign(string p_sVal)
			m_sString=p_sVal;
		endproc;
	
		export proc void op_Assign(real p_fVal)
			m_fReal=p_fVal;
		endproc;
	endclass;
	
	//========================================================================================
	
	class CTakeDmgCache
		export var ^CFightingObj	m_pxLastEnemy;
//		export var CObjHndl				m_xLastCachedEnemy;
		export var real						m_fDamage;
		// Henry: new stuff exclusively for buildups
		export var ^CFightingObj	m_pxLastBUOwner;
		export var real						m_fBuildUpDamage;
		export var ^CFightingObj	m_pxLastBUOExtra;
		export var real						m_fBUDExtra;
	endclass;
	
	//========================================================================================
	
	class CEnemyListSorter
	
		export var CObjHndl	m_xObj;
		export var int			m_iType;
		export var int			m_iAttackType;
		export var int			m_iIndex;
		export var bool			m_bCurrentTarget;
		export var bool			m_bInCombatRange;
		export var bool			m_bInPriorityList;
		export var bool			m_bPrioTarget;
		export var int			m_iValue;
		export var real			m_fDmg;
	
		export constructor()
		endconstructor;
	
		export destructor()
		enddestructor;
	
		export proc void CalculateValue()
			//Priorisierung: Units -> Türme/Bunker -> Häuser -> Mauern -> Wracks
			var ^CGameObj pxObj=m_xObj.GetObj();
			var bool bWreckage=false;
			if(pxObj==null)then return; endif;
			var CFourCC xType=pxObj^.GetType();
			var string sClass=pxObj^.GetClassName();
			if(sClass.Find("_wreckage")!=-1)then bWreckage=true; endif;
//			if(cast<CLumberjackWreckage>(pxObj)!=null)then bWreckage=true; endif;
			if(m_iAttackType==1)then
				//building attack unit
//				if(sClass.Find("_wreckage")!=-1)then
				if(bWreckage)then
					m_iType=98;
				elseif(xType=="CHTR"||xType=="ANML"||xType=="VHCL"||xType=="SHIP"||xType=="FIGHT")then
					m_iType=3;
				elseif(xType=="BLDG")then
					if(cast<CTower>(pxObj)!=null)then
						m_iType=0;
					elseif(cast<CWall>(pxObj)!=null)then
						m_iType=2;
					else
						m_iType=1;
					endif;
				else
					m_iType=99;
				endif;
			else
				//standard
				if(bWreckage)then
					m_iType=98;
				elseif(xType=="CHTR"||xType=="ANML"||xType=="VHCL"||xType=="SHIP"||xType=="FIGHT")then
					m_iType=0;
				elseif(xType=="BLDG")then
					if(cast<CTower>(pxObj)!=null)then
						m_iType=1;
					elseif(cast<CWall>(pxObj)!=null)then
						m_iType=3;
					else
						m_iType=2;
					endif;
				else
					m_iType=99;
				endif;
			endif;
			m_iValue=0;
			if(!m_bPrioTarget)then
				m_iValue+=100000;
			endif;
			m_iValue+=(m_iType*10000);
			if(!m_bInPriorityList)then
				m_iValue+=1000;
			endif;
			if(!m_bInCombatRange||!m_bCurrentTarget)then
				m_iValue+=500;
			endif;
			m_iValue+=m_iIndex;
		endproc;
	
		export proc bool op_Greater(ref CFightingObj.CEnemyListSorter p_rxOther)
			return m_iValue > p_rxOther.m_iValue;
		endproc;
	
	endclass;
	
	//========================================================================================
	//===END MEMBER CLASSES=================================================================
	//========================================================================================
	
	//flags from P4://3DLib/Tools/KO/ObjTypes.txt
	export const int VIS_FLAG_BLDG_NIGHTMODE				= 20;
	export const int VIS_FLAG_BLDG_INIGHTMODE				= 17;
	export const int VIS_FLAG_ANML_PARTYCOL					= 5;
	export const int VIS_FLAG_ANML_SADDLE						= 6;
	export const int VIS_FLAG_ANML_HELMET						= 7;
	export const int VIS_FLAG_ANML_ARMOR						= 8;
	export const int VIS_FLAG_ANML_STANDARTE				= 9;
	export const int VIS_FLAG_ANML_ARMORSADDLE			= 10;
	export const int VIS_FLAG_ANML_MISC							= 11;
	export const bitset VIS_FLAG_ANML_PLAYER_ALL		= 00000000000000000000111111100000b;
	
	export const bitset VIS_FLAG_ANML_WOUND_ALL			= 00001111111100000000000000000000b;
	export const int VIS_FLAG_ANML_WOUND_ARMLI			= 20;
	export const int VIS_FLAG_ANML_WOUND_ARMRE			= 21;
	export const int VIS_FLAG_ANML_WOUND_LEGLI			= 22;
	export const int VIS_FLAG_ANML_WOUND_LEGRE			= 23;
	export const int VIS_FLAG_ANML_WOUND_BELLI			= 24;
	export const int VIS_FLAG_ANML_WOUND_BELRE			= 25;
	export const int VIS_FLAG_ANML_WOUND_HEAD				= 26; //das nur wenn der Kopf fehlt
	export const int VIS_FLAG_ANML_WOUND_TAIL				= 27;
	
	export const int VIS_FLAG_BLDG_ECONOMY					= 29;
	export const int VIS_FLAG_BLDG_DEFENSE					= 30;
	export const int VIS_FLAG_BLDG_COMBAT						= 31;
	export const int VIS_FLAG_VHCL_RAM_LOW					= 5;
	export const int VIS_FLAG_VHCL_RAM_HIGH					= 6;
	export const int VIS_FLAG_BLDG_SCARECROW				= 5;
	export const int VIS_FLAG_CHTR_ACTIVATED				= 16; //used for healer staffs
	
	export const bitset EFFECT_NONE									= 0b;
	export const bitset EFFECT_MEGALO_DRUMS					= 01b;
	export const bitset EFFECT_RHINO_PENNANT				= 010b;
	export const bitset EFFECT_CHTR_WARCRY_3				= 0100b;
	export const bitset EFFECT_CHTR_WARCRY_4				= 01000b;
	export const bitset EFFECT_CHTR_WARCRY_5				= 010000b;
	export const bitset EFFECT_WILDBOAR_RAGE				= 0100000b;
	export const bitset EFFECT_MAMMOTH_TRUMPET			= 01000000b;
	export const bitset EFFECT_TRICERATOPS_PAW			= 010000000b;
	export const bitset EFFECT_AJE_WARPAINT_3				= 0100000000b;
	export const bitset EFFECT_AJE_WARPAINT_4				= 01000000000b;
	export const bitset EFFECT_AJE_WARPAINT_5				= 010000000000b;
	export const bitset EFFECT_ITEM_STONED					= 0100000000000b;
	export const bitset EFFECT_ITEM_RING						= 01000000000000b;
	export const bitset EFFECT_ITEM_AMULETT1				= 010000000000000b;
	export const bitset EFFECT_SMOKER_INVIS					= 0100000000000000b;
	export const bitset EFFECT_AJE_CAMOUFLAGE				= 01000000000000000b;
	export const bitset EFFECT_ADA_SLOWHAND_1				= 010000000000000000b;
	export const bitset EFFECT_NO_ANIMAL_AGGRO			= 0100000000000000000b;
	export const bitset EFFECT_NINIGI_CAULDRON			= 01000000000000000000b;
	export const bitset EFFECT_KLEEMANN_AURA				= 010000000000000000000b;
	export const bitset EFFECT_SKULL_PROTECTOR			= 0100000000000000000000b;
	export const bitset EFFECT_KLEEMANN_DAMAGEBOOST	= 01000000000000000000000b;
	export const bitset EFFECT_MAYOR_DOMINANCE			= 010000000000000000000000b;
	export const bitset EFFECT_PARA_DRUMS						= 0100000000000000000000000b;
	export const bitset EFFECT_DAS_ENDE							= 010000000000000000000000000000000b;
	
	export const int	BONUS_MAXHITPOINTS		= 0;
	export const int	BONUS_FOWRANGE			= 1;
	export const int	BONUS_DEFENSE			= 2;
	export const int	BONUS_DAMAGE			= 3;
	export const int	BONUS_MAXRESINV			= 4;
	export const int	BONUS_PRODSPEED_ANML	= 5;
	export const int	BONUS_DEFAULTSPEED		= 6;
	export const int	BONUS_XPGAIN			= 7;
	export const int	BONUS_RANGEDDEFENSE		= 8;
	export const int	BONUS_RANGE				= 9;
	export const int	BONUS_DAMAGE_BLDG		= 10;
	export const int	BONUS_MELEEDAMAGE		= 11;
	export const int	BONUS_RANGEDAMAGE		= 12;
	export const int	BONUS_MAXENERGY=13; // Henry: bonus to maximal mana amount (added here so that it won't be forgotten...)
	export const int	NUM_BONUS_TYPES			= 14;	// << Update this one everytime a new type was added
	export const int	TIMER_EXPLOSION			= 1905;
	
	// values for statistics
//	export const int 	COLLECTED_SKULLS	= 5;
//	export const int  	KILLED_ENEMIES		= 6;
//	export const int 	KILLED_ANIMALS		= 7;
//	export const int 	DESTROYED_BUILDINGS=8;
//	export const int	LOST_UNITS			= 9;
//	export const int	LOST_BUILDINGS		= 10;
//	export const int 	MAX_WORKER			= 16;
//	export const int	COLLECTED_WOOD		= 17;
//	export const int 	COLLECTED_STONE		= 18;
//	export const int	COLLECTED_FOOD		= 19;
	
	export const int	TIMER_AGGRO					=133;
	const int			TIMER_PREAGGRO				=156;
	const int			TIMER_ALARM					=134;
	export const int	TIMER_FLAGS					=135;
	export const int	TIMER_FLAGS2				=137;
	const int			TIMER_GETHITREACTION		=8192;
	const int			TIMER_MAMMOTH_TRUMPET		=460;
	const int			TIMER_TRICERATOPS_PAW		=461;
	const int			TIMER_INVUL					=10;
	const int			TIMER_WEAPON_REMOVE			=15; //Kr1s1m: Added unique timer id for WeaponRemove ACDO
	const int			TIMER_STONED				=23;
	const int			TIMER_FROST					=24;
	const int			TIMER_FROSTIMMUNITY			=25;
	const int			TIMER_DUNDEED				=26;
	const int			TIMER_FINISHINGMOVE			=1337;
	const int			TIMER_ANML_IMMUNITY			=1357;
	const int			TIMER_HELPSHOUT				=268;
	export const int	CAMO_TIMER					=339;
	const int			TIMER_CHECK_HEAL			=783;
	export const int	TIMER_LEVELUP_INV			=579;
	export const int	TIMER_ISGETTINGHEALED		=580;
	export const int	TIMER_ISGETTINGHEALED_FX	=581;
	const int			TIMER_SELFHEAL				=28369;
	
	export const bitset	DIR_INVALID				=00000000h;
	export const bitset	DIR_FRONT				=00000001h;
	export const bitset	DIR_BACK				=00000002h;
	export const bitset	DIR_LEFT				=00000004h;
	export const bitset	DIR_RIGHT				=00000008h;
	export const bitset	DIR_FRONT_LEFT			=00000009h;
	export const bitset	DIR_FRONT_RIGHT			=0000000Ah;
	export const bitset	DIR_BACK_LEFT			=0000000Bh;
	export const bitset	DIR_BACK_RIGHT			=0000000Ch;
	
	//see RT#2341 for details
	const real			FALLOFFCONE_VAL			=0.5;	//bonus range per meter height difference
	
	//maximal path length for autoprod	
	const int			MAX_AUTOPROD_DIST=96;
	
	//flag weapon damage type
	// synchronize with flags in CAttribIcon (Client)
	const bitset dwMELEE_PIERCE	= 000000001b;
	const bitset dwMELEE_POISON	= 000000010b;
	const bitset dwMELEE_AREA	= 000000100b;
	const bitset dwRANGE_PIERCE	= 000001000b;
	const bitset dwRANGE_POISON	= 000010000b;
	const bitset dwRANGE_AREA	= 000100000b;
	const bitset dwMELEE_FIRE	= 001000000b;
	const bitset dwRANGE_FIRE	= 010000000b;
	
	export static var real	ms_fDurationFactor;
	export var real			m_fDurationFactor;
	
	var bitset				m_dwEffectFlags;
	var array int			m_aiEffectFlags;
	
	var CGameTime			m_xLastFunctionTime;	// last Time an automatic Function has been called
	var CObjQuery			m_xFunctionUnits;		// Characters on which the Function is calling
	
	export var array CFightingObj.CWeaponCache	m_axWeaponCaches;
	export var CTakeDmgCache					m_xDmgCache;
	var real						m_fDefenseFactor;
	var real						m_fAttackFactor;
	
	var CRegionSink			m_xSink;
	var CGuid						m_xRegionGuid;
	var CObjList				m_xRegionObjects;
	var CObjHndl				m_xProduceUnit;
	
	var int							m_iLastDamage;
	var CObjHndl				m_xGroup;
	var ^CPatrolInfo		m_pxPatrolInfo;
	
	var CFightingObj.CFightAnim m_xCurrentFightAnim;
	var array CFightingObj.CFightAnim m_axFightAnims;
	var array string m_asFightAnims;
	
//	var int m_iFinishingMoveIdx;
	var array CFightingObj.CActionObj m_axAutoSpecialMoves;
	
	var CFightingObj.CPoisonTick m_xPrimaryPoison;
	var CFightingObj.CPoisonTick m_xSecondaryPoison;
	
	var array CFightingObj.CCamouflageLayer m_axCamouflageLayers;
	
	var ^CWeaponMgr		m_pxWeaponMgr;
	var string				m_sCurrentWeapon;
	
	var real					m_fAlarmRange;
	var real					m_fDamage;
	var real					m_fFOWRange;
	var real					m_fProtection;
	var real					m_fRangedProtection;
	var real					m_fWeaponDuration;
	var real					m_fMinDamage;
	var int						m_iDefaultSpeed;
	var int						m_iMaxSpeed;
	var real					m_fArmorPiercing;
	
	var string				m_sProjectile;
	var string				m_sRealProjectile;
	var real					m_fProjectileDelay;
	var real					m_fProjectileFallOff;
	var real					m_fProjectileSpeed;
	var real					m_fProjectileJitter;
	var bool					m_bPenetration;
	var real					m_fPenetrationAngle;
	var real					m_fPenetrationFactor;
	var real					m_fAttackDirection;
	var real					m_fHitDelay;
	var real					m_fPoisonDmg;
	var int						m_iPoisonMaxTickCount;
	var int						m_iWeaponSizeClass;
	
	var real					m_fAttackRange;
	var real					m_fRealAttackRange;
	var real					m_fSecRangeM;
	var real					m_fRealSecRangeM;
	var real					m_fSecRangeS;
	var real					m_fRealSecRangeS;
	var real					m_fMinAttackRange;
	var real					m_fRealMinAttackRange;
	var real					m_fHitRange;
	var real					m_fRealHitRange;
	var real					m_fEndDmg;
	var int						m_iAttackType;
	
	var real					m_fHitpoints;
	var real					m_fMaxHitpoints;
	
	var real					m_fHitTimeOut;
	
	var CFourCC				m_xWalkSet;
	var CFourCC				m_xHumpWalkSet;
	
	export var CTechTree	m_xTechTree;
	var bool					m_bTechTreeInitialized;
	
	var string				m_sTribe;
	var string				m_sObjPath;
	var string				m_sMyBuildAction;
	var int						m_iLevel;
	var CObjList			m_xPotEnemies;
	var CObjList			m_xPriorityList;
	var vec2					m_vFormationPriority;
	var CObjHndl			m_xTransportObj;
	var bool					m_bIsTrapped;
	var CObjHndl			m_xTrap;
	
	var CObjHndl			m_xReturnEnemy;
	var bool					m_bReturnNoUserBerserkerMode;
	var bool				m_bReturnUserCommand;
	
	var CObjHndl			m_xLastEnemy;
	
	var CObjList			m_xFXObjects;
	
	var bool				m_bStinaSlowhand;
	
	var vec3				m_vRallyPos;
	var CObjHndl			m_xRallyTarget;
	
	var bool				m_bMovableInFight;
	
	var int 				m_iAggressionState;	// 0 - stand ground
												// 1 - defensive, follow enemy in 20m circle
												// 2 - aggressive, follow enemy until death
												// 3 - don't do anything, like aje poisoner used to be (until recently)
												// 4 - aje poisoner's new state
												// -1 - stand ground / defensiv
	
//	export var bool			m_bDoingFinishingMove;
	var bool			m_bDoingFinishingMove;
	export var bool			m_bIsGettingFinished;
	
	var bool				m_bPatrolWalk;
	var bool				m_bStoppingPatrol;
	var bool 				m_bStraightWalkPatrol;
	
	var bool 				m_bAggressionWalk;
	var bool				m_bAggrTNoAnml;
	var vec3				m_vAggressionPos;
	
	var array CDmgTimer		m_axDmgTimer;
	var ^CTimerTick			m_pxTimeOnTick;
	var ^CTimerTick			m_pxTimeOffTick;
	
	var bool				m_bRotateSLEAction;
	var bool				m_bRotateAction;
	
	var bool				m_bIsCheckInUnit;
	
	var bool				m_bFeignDeath;
	var int					m_iInvulnerable;	//object is not vulnerable, TakeDmg and TakeDirectDmg do not affect health -1=off, 0=on;
	var bool				m_bFinished;		//object is kinda dead already, because a finishing move is initialized, all enemies should abort fight with this object
	var bool				m_bIntendedCamouflage;
	var bool				m_bLevelUpInvulnerable;
	
	var array int			m_aiActionTimerIDs;
	var array CActionObj	m_axActionObj;
	
	var int					m_iEntrenchState;	// 0 - not entrenched
												// 1 - entrenched
												// 2 - digging
	
	var vec3 				m_vHitReactionDir;
	export var int			m_iSizeClass;	//0 - can't throw/won't be thrown
											//1 - small (can be thrown/can't trow)	(this is a white JuDo belt)
											//10 - big (can throw/won't be thrown)	(and this is the black one)
	
	var CObjHndl			m_xCurEnemy;
	var CObjHndl			m_xLastFinishingVictim;
	var CGameTime			m_xLastHitDone;
	
	var ^CTaskMgr			m_pxTaskMgr;
	var ^CState				m_pxIdleState;
	
	var CBonus									m_xAttackBoni;
	var CBonus									m_xDefenseBoni;
	var CBonus									m_xRangedDefBoni;
	var array CBoniBucket				m_axBoni;
	export var CSpecialAbilitiesContainer		m_xAbilities;
	
	var bitset				m_dwLastHitDirection;
	
	//Misc flags
	export var bool			m_bIsBerserker;
	var bool						m_bInvisibleFlag;
	var bool						m_bDefensiveMode;
	export var bool			m_bGodMode;
	var bool						m_bRage;
	var bool						m_bIsRageUnit;
	export static var bool	ms_bToggleGodMode; //no need to save
	var bool				m_bScalpsGiven;
	var bool				m_bBLDGResBack;
	var bool				m_bSHIPResBack;
	var bool				m_bWeaponHasChanged;
	var bool				m_bWeaponRemoved;
	var bool				m_bOwnWeaponHasChanged;
	var bool				m_bHelpShoutDefend;
	var CObjHndl			m_xHelpShoutEnemy;
	var bool				m_bLDInvulnerable;
	
	var CGameTime			m_xLastHelpShout;
	export var bool		m_bIsHelpShout;
	var CObjList			m_xHelpDefendEnemies;
	var CObjList			m_xHelpAttackEnemies;
	var CGameTime			m_xChangeTargetTime;
	var real					m_fSelfHealAmount;
	var CObjHndl			m_xInvalid;
	
	//========================================================================================
	//===New member values and etc in MIRAGE by Henry=========================================
	//========================================================================================
	
	var CBuildCosts				m_xCosts;
	
	var bitset						m_dwMirageFlags; //new effectflags for mirage (bitset)
	var array int					m_aiMirageFlags; //number of new mirage flags
	var CGameTime					m_xLastSecFunctionTime; //last time a secondary automatic function in was called (see magiccauldron)
	var CObjQuery					m_xAdditionalFunctionUnits; //Unit types which are affected by an automatic function in MIRAGE (e.g. mana temple effect)
	
	const int TIMER_START_RESIST											= 40000; //timer to balance ninigi icespearman freezing ability
	export const int TIMER_INFORM_ME									= 40007; //test timer, to check different things at certain units (no real use)
	export const int TIMER_GOT_STOLEN									= 40014; //timer for newly tamed animals by seas trainer
	export const int TIMER_PINNED_DOWN								= 40016; //timer for Bela's slowing effect
	const int TIMER_INCAPACITATED											= 40018; //timer for aje rammers new building-incapacitating ability
	export const int TIMER_NO_HEALING									= 40021; //timer for aje throwers new heal disabling ability
	const int REPLENISH_TIMER													= 40022; //timer for automatic mana reprdoducing
	const int TIMER_SANCTIFICATION										= 40024; //timer for wild animals automatic selfhealing ability (without healing fx)
	const int TIMER_WALKING_BOMB											= 40026; //timer for walking bomb action of Miyagi
	const int TIMER_FOUNTAIN_HEALED										= 40027; //timer for units healed by seas well
	const int TIMER_RESURRECT_SAFETY									= 40028; //timer for shamans to be invulnerable at ressuretion end part, to prevent AC bugs
	const int RALLY_ROAR															= 40033; //timer seas titan's bonus timeout
	const int ID_EXPLOSIVES_ROUNDS										= 40034; //timer for seas titan suits rage state
	const int MARKED_FOR_DEATH												= 40036; //timer for ninigi marksman malus timeout
	export const int TIMER_FIREWORK										= 40050; //timer for aje sensor tower to restore smoke effect if necessary
	const int TIMERID_THROWIMMUNE											= 40051; //timer to make unit throwable again
	export const int CEASE_FIRE												= 40062; //timer for monks ability, to allow attacks again
	export const int UNBOARD_CURSE										= 40072; //timer for monks ability, to make transportunits unboardable
	const int TIMER_SUNDERED													= 40001; //timer to end armor sundering effect
	const int TIMER_SHATTERED													= 40081; //timer to end armor shattering effect
	const int TIMER_DEMOTE														= 40082; //timer to demote effect end
	const int TIMER_BLINDNESS													= 40083; //timer to blindness effect end
	const int TIMER_MIRRORING													= 40084; //timer to mirroring effect end
	const int TIMER_BONDS															= 40090; //timer to clear fatal bonds
	const int TIMER_DEAFENED													= 40092; //timer to end deafening effect
	const int TIMER_ISGETTINGCORRUPTED								= 40100; //timer to remove corruption buff
	const int TIMER_ISGETTINGCORRUPTED_FX							= 40101; //timer to remove corruption fx
	const int TIMER_INTIMIDATED												= 40102; //timer to end deafening effect
	const int TIMER_SEDATED														= 40103; //timer to end sedating
	const int TIMER_MOTIVATED													= 40106; //timer to motivation end
	const int TIMER_REGENERATING											= 40110; //timer for automatic selfhealing ability (without healing fx)
	const int TIMER_ISGETTINGREGENED									= 40111; //timer for removing regen rangedbuff
	const int TIMER_FRIGHTENING												= 40115; //timer for removing frightening effect
	const int TIMER_VALOR															= 40116; //timer for removing valor effect
	const int TIMER_GET_UP														= 40143; //timer for getting up
	const int FINISHING_MODE													= 40145; //timer automatically disables finishing mode
	const int TIMER_HERE_I_AM													= 40154; //timer for units of revealed players to send ping to other players
	const int DEFENSE_SHAKE														= 40170; //timer seas titan's defense bonus timeout
	const int TIMER_BROKEN_LEGS												= 40171; //nm titans slowing effect
	const int TIMER_SPEED_RUN													= 40172; //dc titans speed bonus
	const int RALLY_TRUMP															= 40177; //nm mammoth attack freq bonus
	const int TIMER_LACERED														= 40178; //dc scorpion attack defense malus
//	const int TIMER_INSECTS_FX												= 40180; //nm druids insect against ordinary units
		
	export const bitset MIRAGE_EFFECT_NONE						= 0b;
	export const bitset MIRAGE_SKULL_PROTECT					= 01b; //new flag for the aje skull totem (formerly skull protector) this sets the skulls of own and allied units to zero
	export const bitset MIRAGE_SKULL_BOOST						= 010b; //new flag for the aje skull totem (formerly skull protector) which doubles the skulls of enemy units
	export const bitset MIRAGE_SCARECROW							= 0100b; //adds attack penalty to animals
	export const bitset MIRAGE_PSI_DISRUPT						= 01000b; //flag to the ability of the psi disruptorß
	export const bitset MIRAGE_BLINDING_STORM					= 010000b; //flag for sandstorm ability
	export const bitset MIRAGE_MAGIC_CAULDRON					= 0100000b; //adds attack boni to units nearby
	export const bitset MIRAGE_BIG_HORN								= 01000000b; //new flag nm big horn to keep infantry alive
	export const bitset MIRAGE_KING_JAW								= 010000000b; //to the aje tyrannosaurus riders ability which gives a defense malus to enemy units
	export const bitset MIRAGE_SPEAKER								= 0100000000b; //to the seas speakers region which gives a defense boni to allied units
	export const bitset MIRAGE_MOTIVATE								= 01000000000b; //crash rpg fighter lvl3 aura
	export const bitset MIRAGE_THREATEN								= 010000000000b; //crash rpg hunter lvl3 aura
	export const bitset MIRAGE_KEEN_EYES							= 0100000000000b; // less ranged defense
	export const bitset MIRAGE_SAND_TRAP							= 01000000000000b; // sandtrap effect
	export const bitset MIRAGE_DC_BYAKUGAN_3					= 010000000000000b; // dc samurai lvl 3 aura (armor penalty)
	export const bitset MIRAGE_DC_BYAKUGAN_4					= 0100000000000000b; // dc samurai lvl 4 aura (armor penalty)
	export const bitset MIRAGE_DC_BYAKUGAN_5					= 01000000000000000b; // dc samurai lvl 5 aura (armor penalty)
	export const bitset MIRAGE_THE_END								= 010000000000000000000000000000000b;
	
	var real						m_fStrengthGrowing; //to the baby wild animals to show in infopanel reduced attackpower
	var real						m_fEnergyState; //Current mana value
	var real						m_fMaxEnergy; //Maximal mana value a unit can  possess
	var real						m_fReplenishAmount; //the amount of mana which is added to the unit by automatic mana reproducing
	var real						m_fReplenishTime; //the time intervall between each auto mana producing "round"
	var real						m_fManaEatingTime; //atm not used
	var CGameTime				m_xLastReplenishTick; //last time the automatic mana reproducing procedure was called
	
	var int							m_iSupplyCount; //to store the supply value of the unit
	export var int			m_iKillerCount; //to store the number of killed enemies of the unit
	var int							m_iKillerHistory; //to store the number of killed enemies of the unit
	
	var real						m_fTmpMeAttackBoni; //temporarily melee attack bonus
	var real						m_fTmpRaAttackBoni; //temporarily range attack bonus
	
	var real						m_fIceTimeOut; //intervall for freezing time
	var real						m_fImmunityTime; //interval for the immunity time against freezing
	var bool						m_bIceImmunity; //attrib to make unit exception to freezing
	var bool						m_bPoisonImmunity; //attrib to make unit immun against poison
	var real						m_fFreezingTime; //freezing time interwall for each attack of a unit with freeze ability
	
	var real 						m_fFireDmg; //amount of damage caused by fire units (flamethrowers) against buildinga
	var int							m_iBurnTime; //number of rounds to damage building by fire
	var bool						m_bANMLResBack; //attrib to gain enemy animals production costs
	var bool						m_bCHTRResBack; //attrib to gain enemy infantry production costs
	var bool						m_bVHCLResBack; //attrib to gain enemy vehicles production costs
	var real						m_fCuringAmount; //healing amount used by wild animals selfheal ability and etc.
	export var bool			m_bIncapacitated; //attrib which marks the unusable building by the effect of aje rammer
	export var bool			m_bFountainHealed; //attrib which marks units that suffer no damage because they used seas healing well
	export var bool			m_bResurrectSafety; //attrib which marks resurrecting shamans to get not be killed to prevent AC bugs
	export var string		m_sFilter; //techtree filter path to shamans camouflage (needed to disable the filter)
	export var bool			m_bAirWeapon; //attrib if the unit can fight air units
	export var bool			m_bFlyingUnit; //attrib of flying units
	export var bool			m_bFreeHunting;
	export var bool			m_bMirroring;
	export var bool			m_bDemoteEffect;
	export var bool			m_bPlayerRevealed;
	export var bool			m_bSpiritCreated;
	export var bool			m_bTamed;
	export var bool			m_bPinnedDown;
	export var bool			m_bShattered;
	export var bool			m_bSundered;
	export var bool			m_bBlinded;
	export var bool			m_bDeafened;
	export var bool			m_bMarkedForDeath;
	export var bool			m_bCyborgBonus;
	export var bool			m_bExplosiveRounds;
	export var bool			m_bJetpack;
	export var bool			m_bFirework;
	export var bool			m_bCeaseFire;
	export var bool			m_bUnboard;
	export var bool			m_bFrozen;
	export var bool			m_bStimpack;
	export var bool			m_bStolen;
	export var bool			m_bSuicide;
	export var bool			m_bBloodInfect;
	export var bool			m_bEvading;
	export var bool			m_bAILock;
	export var real			m_fMapWidth;
	export var real			m_fMapHeight;
	export var real			m_fWaterLevel;
	var int							m_iPQNEO;
	var int							m_iPQNER;
	var real						m_fSelfRegenerating;
	var real						m_fMaxDef;
	var bool						m_bIsCamouflaged;
	var bool						m_bIsDead;
	var bool						m_bInvalidEnemy;
	var bool						m_bInvalidFighter;
	export var bool			m_bToBeDeleted;
	var string					m_sPerRegName;
	var bool						m_bNoHitReaction;
	var bool						m_bBUAirAttack;
	var string					m_sObjFlag;
	var bool						m_bCostsFromAction;
	var bool						m_bCanTame;
	var real						m_fJawSize;
	var real						m_fFeedFactor;
	var bool						m_bResurrecting;
	var bool						m_bAI;
	var bool						m_bPassingAway;
	var bool						m_bHidingEnemy;
	var bool						m_bUniqueMask;
	var string					m_sStandardDesc;
	var bool						m_bSlaveInvincible;
	var bool						m_bOnTheGround;
	var bool						m_bHPReachedZero;
	var bool						m_bTimeTrap;
	var bool						m_bObjectTrap;
	var bool						m_bThrowDisabled;
	var bool						m_bGameOverKill;
	var bool						m_bNoCorpse;
	var bool						m_bExcludeBuildUp;
	var bool						m_bAttackInFOW;
	var bool						m_bTechtreeSteal;
	var bool						m_bAuraSharing;
	var string					m_sPTName;
	var bool						m_bWildPtera;
	var bool						m_bDefFirstInit;
	export var bool			m_bTitanDefense;
	var bool						m_bBrokenLegs;
	var array real			m_afDamagePortion;
	var bool						m_bDivideSkulls; //index, where the last time reduction stopped (because of healing)
	export var bool			m_bManaEnabled;
	var bool						m_bTurtleOnLand;
	var bool						m_bBiological;
	var real						m_fHealingBoniAbs;
	var real						m_fHealingBoniRel;
	var bool						m_bMeleePenetrate; //units doing aoe damage with their own body, like dr brachio
	export var bool			m_bLacered;
	var bool						m_bLocked; //locked units aren't accepting commands
	var bool						m_bIsWildAnimal;
	export var bool			m_bPBlocker;
	export var bool			m_bThrowImmune; // throw anti-timer active
	export var bool			m_bDarkSwarm; // protected by blinding/sand storm
	var string					m_sProjectileGfx; //for fake projectile models
//	export var bool			m_bSystem; //for dump
	
	var array CToDoEntry			m_axToDoList;
	
	var real m_fBUDamage;
	var real m_fBUEndDamage;
	var string m_sBUProjectile;
	var real m_fBUArmorPiercing;
	var real m_fBUPoisonDmg;
	var int m_iBUPoisonMaxTickCount;
	var real m_fBUFireDmg;
	var int m_iBUBurnTime;
	var bool m_bBUAirWeapon;
	var CBonus m_xBUAttackBoni;
	
	var CFightingObj.CFireTick		m_xPrimaryFire;
	var CFightingObj.CFireTick		m_xSecondaryFire;
	
	var CObjHndl				m_xSacrificer;
	var CObjHndl				m_xSpawningPool;
	var CObjHndl				m_xIntimidate;
	var array CObjHndl	m_axParasites;
	export var CObjHndl	m_xReactor;
	var CObjHndl				m_xHiveMind;
	export var CObjHndl	m_xCorpse;
	var CObjHndl				m_xPotentialTransportObject;
	var int							m_iCmdID;
	var int							m_iOwnerID;
	var CObjList				m_xAttackers;
	var CObjList				m_xBonds;
	var CObjHndl				m_xPrimaryTarget;
	var CObjHndl				m_xTornado;
	
	var CFightingObj.CLethalTick		m_xLethalWoundZero;
	var CFightingObj.CLethalTick		m_xLethalWoundOne;
	var CFightingObj.CLethalTick		m_xLethalWoundTwo;
	var CFightingObj.CLethalTick		m_xLethalWoundThree;
	var CFightingObj.CLethalTick		m_xLethalWoundFour;
	var CFightingObj.CLethalTick		m_xLethalWoundFive;
	var CFightingObj.CLethalTick		m_xLethalWoundSix;
	var CFightingObj.CLethalTick		m_xLethalWoundSeven;
	var CFightingObj.CLethalTick		m_xLethalWoundEight;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="FOba"; //FightingObj base
		var int iVersion=22;
		if(CMirageSrvMgr.SDK())then
			iVersion=21;
		endif;
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,iVersion);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		(pxArc^) << m_iAggressionState;
		(pxArc^) << m_sTribe;
		m_xTransportObj.DoKArc(pxArc^);
		m_xFXObjects.DoKArc(pxArc^);
		var int i, iC=m_aiActionTimerIDs.NumEntries();
		(pxArc^) << iC;
		for(i=0)cond(i<iC)iter(i++)do
			(pxArc^) << m_aiActionTimerIDs[i];
			m_axActionObj[i].DoKArc(pxArc^);
		endfor;
		m_xReturnEnemy.DoKArc(pxArc^);
		var bool bPatrolInfo=(m_pxPatrolInfo!=null);
		(pxArc^) << bPatrolInfo;
		if(bPatrolInfo)then
			m_pxPatrolInfo^.DoKArc(pxArc^);
		endif;
		pxArc^ << m_xRegionGuid;
		m_xProduceUnit.DoKArc(pxArc^);
		m_xRegionObjects.DoKArc(pxArc^);
		if(CSrvWrap.GetGame().IsLevelEd())then
			//flush AggressionPos
			m_vAggressionPos=GetPos();
		endif;
		pxArc^ << m_vAggressionPos;
		pxArc^ << m_bInvisibleFlag;
		pxArc^ << m_bDefensiveMode;
		pxArc^ << m_bGodMode;
		pxArc^ << m_bScalpsGiven;
		pxArc^ << m_bBLDGResBack;
		pxArc^ << m_bSHIPResBack;
		pxArc^ << m_bWeaponHasChanged;
		pxArc^ << m_bOwnWeaponHasChanged;
		m_xLastHelpShout.DoKArc(pxArc^);
		pxArc^ << m_bIsHelpShout;
		m_xHelpDefendEnemies.DoKArc(pxArc^);
		m_xHelpAttackEnemies.DoKArc(pxArc^);
		pxArc^ << m_iEntrenchState;
		m_xCurEnemy.DoKArc(pxArc^);
		m_xLastFinishingVictim.DoKArc(pxArc^);
		pxArc^ << m_bFinished;
		pxArc^ << m_iInvulnerable;
		pxArc^ << m_bFeignDeath;
		pxArc^ << m_bRotateSLEAction;
		pxArc^ << m_bRotateAction;
		pxArc^ << m_bAggressionWalk;
		pxArc^ << m_bAggrTNoAnml;
		pxArc^ << m_bStraightWalkPatrol;
		pxArc^ << m_bStoppingPatrol;
		pxArc^ << m_bPatrolWalk;
		pxArc^ << m_bIsGettingFinished;
		pxArc^ << m_bDoingFinishingMove;
		m_xRallyTarget.DoKArc(pxArc^);
		pxArc^ << m_bStinaSlowhand;
		m_xLastEnemy.DoKArc(pxArc^);
		m_xReturnEnemy.DoKArc(pxArc^);
		pxArc^ << m_bReturnNoUserBerserkerMode;
		pxArc^ << m_bReturnUserCommand;
		pxArc^ << m_bIsTrapped;
		m_xTrap.DoKArc(pxArc^);
		m_xPotEnemies.DoKArc(pxArc^);
		pxArc^ << m_sMyBuildAction;
		pxArc^ << m_sObjPath;
		pxArc^ << m_bTechTreeInitialized;
		m_xPrimaryPoison.DoKArc(pxArc^,iVersion);
		m_xSecondaryPoison.DoKArc(pxArc^,iVersion);
		pxArc^ << m_iLastDamage;
		var bitset dwSavedFXFlags=m_dwEffectFlags&EFFECT_AJE_CAMOUFLAGE;
		pxArc^ << dwSavedFXFlags;
		iC=m_axDmgTimer.NumEntries();
		pxArc^ << iC;
		for(i=0)cond(i<iC)iter(i++)do
			m_axDmgTimer[i].DoKArc(pxArc^, iVersion);
		endfor;
		pxArc^ << m_bHelpShoutDefend;
		pxArc^ << m_bLDInvulnerable;
		iC=m_axCamouflageLayers.NumEntries();
		pxArc^ << iC;
		for(i=0)cond(i<iC)iter(i++)do
			m_axCamouflageLayers[i].DoKArc(pxArc^);
		endfor;
		pxArc^ << m_bIntendedCamouflage;
		pxArc^ << m_iAttackType;
		pxArc^ << m_fHitTimeOut;
		m_xPriorityList.DoKArc(pxArc^);
		m_xChangeTargetTime.DoKArc(pxArc^);
		pxArc^ << m_bRage;
		pxArc^ << m_bIsRageUnit;
		pxArc^ << m_fSelfHealAmount;
		
	//========================================================================================
	//===New member values saved in MIRAGE by Henry===========================================
	//========================================================================================
		
		if(iVersion>=22)then
			pxArc^ << m_xCosts.m_iWood;
			pxArc^ << m_xCosts.m_iStone;
			pxArc^ << m_xCosts.m_iFood;
			pxArc^ << m_xCosts.m_iSkulls;
			pxArc^ << m_bANMLResBack;
			pxArc^ << m_bCHTRResBack;
			pxArc^ << m_bVHCLResBack;
			pxArc^ << m_fStrengthGrowing;
			pxArc^ << m_fCuringAmount;
			m_xLastReplenishTick.DoKArc(pxArc^);
			pxArc^ << m_fEnergyState;
			pxArc^ << m_fMaxEnergy;
			pxArc^ << m_fReplenishAmount;
			pxArc^ << m_fReplenishTime;
			pxArc^ << m_fManaEatingTime;
			//pxArc^ << m_fShieldState;
			//pxArc^ << m_fMaxShieldAmount;
			//pxArc^ << m_fRechargeAmount;
			//pxArc^ << m_fRechargeTime;
			pxArc^ << m_fIceTimeOut;
			pxArc^ << m_fImmunityTime;
			pxArc^ << m_fFreezingTime;
			pxArc^ << m_bIceImmunity;
			pxArc^ << m_bPoisonImmunity;
			pxArc^ << m_bIncapacitated;
			pxArc^ << m_iSupplyCount;
			pxArc^ << m_fTmpMeAttackBoni;
			pxArc^ << m_fTmpRaAttackBoni;
			pxArc^ << m_iKillerCount;
			pxArc^ << m_sFilter;
			m_xPrimaryFire.DoKArc(pxArc^,iVersion);
			m_xSecondaryFire.DoKArc(pxArc^,iVersion);
			pxArc^ << m_bFlyingUnit;
			m_xSacrificer.DoKArc(pxArc^);
			var int ik, iKC=m_axParasites.NumEntries();
			(pxArc^) << iKC;
			for(ik=0) cond(ik<iKC) iter(ik++)do
				m_axParasites[ik].DoKArc(pxArc^);
			endfor;
			pxArc^ << m_bFreeHunting;
			m_xSpawningPool.DoKArc(pxArc^);
			m_xReactor.DoKArc(pxArc^);
			m_xHiveMind.DoKArc(pxArc^);
			pxArc^ << m_bMirroring;
			m_xCorpse.DoKArc(pxArc^);
			pxArc^ << m_iCmdID;
			pxArc^ << m_iOwnerID;
			m_xBonds.DoKArc(pxArc^);
			pxArc^ << m_bDemoteEffect;
			m_xAttackers.DoKArc(pxArc^);
			m_xLethalWoundZero.DoKArc(pxArc^,iVersion);
			m_xLethalWoundOne.DoKArc(pxArc^,iVersion);
			m_xLethalWoundTwo.DoKArc(pxArc^,iVersion);
			m_xLethalWoundThree.DoKArc(pxArc^,iVersion);
			m_xLethalWoundFour.DoKArc(pxArc^,iVersion);
			m_xLethalWoundFive.DoKArc(pxArc^,iVersion);
			m_xLethalWoundSix.DoKArc(pxArc^,iVersion);
			m_xLethalWoundSeven.DoKArc(pxArc^,iVersion);
			m_xLethalWoundEight.DoKArc(pxArc^,iVersion);
			pxArc^ << m_bPlayerRevealed;
			pxArc^ << m_bSpiritCreated;
			pxArc^ << m_bTamed;
			pxArc^ << m_bPinnedDown;
			pxArc^ << m_bShattered;
			pxArc^ << m_bSundered;
			pxArc^ << m_bBlinded;
			pxArc^ << m_bDeafened;
			pxArc^ << m_bMarkedForDeath;
			pxArc^ << m_bCyborgBonus;
			pxArc^ << m_bExplosiveRounds;
			pxArc^ << m_bJetpack;
			pxArc^ << m_bFirework;
			pxArc^ << m_bCeaseFire;
			pxArc^ << m_bUnboard;
			pxArc^ << m_bFrozen;
			pxArc^ << m_bStimpack;
			pxArc^ << m_bStolen;
			pxArc^ << m_bSuicide;
			pxArc^ << m_bBloodInfect;
			pxArc^ << m_bEvading;
			m_xIntimidate.DoKArc(pxArc^);
			pxArc^ << m_iPQNEO;
			pxArc^ << m_iPQNER;
			m_xPotentialTransportObject.DoKArc(pxArc^);
			pxArc^ << m_iKillerHistory;
			pxArc^ << m_bAILock;
			pxArc^ << m_fSelfRegenerating;
			pxArc^ << m_fMaxDef;
			pxArc^ << m_bIsCamouflaged;
			pxArc^ << m_bIsDead;
			pxArc^ << m_bInvalidEnemy;
			pxArc^ << m_bInvalidFighter;
			pxArc^ << m_bToBeDeleted;
			pxArc^ << m_sPerRegName;
			pxArc^ << m_bNoHitReaction;
			pxArc^ << m_bBUAirAttack;
			pxArc^ << m_sObjFlag;
			pxArc^ << m_bCostsFromAction;
			pxArc^ << m_fJawSize;
			pxArc^ << m_fFeedFactor;
			pxArc^ << m_bResurrecting;
			m_xPrimaryTarget.DoKArc(pxArc^);
			pxArc^ << m_bPassingAway;
			pxArc^ << m_bHidingEnemy;
			pxArc^ << m_bUniqueMask;
			pxArc^ << m_bSlaveInvincible;
			iC=m_axToDoList.NumEntries();
			(pxArc^) << iC;
			for(i=0)cond(i<iC)iter(i++)do
				m_axToDoList[i].DoKArc(pxArc^,iVersion);
			endfor;
			pxArc^ << m_bOnTheGround;
			pxArc^ << m_bHPReachedZero;
			pxArc^ << m_bTimeTrap;
			pxArc^ << m_bObjectTrap;
			m_xTornado.DoKArc(pxArc^);
			pxArc^ << m_sPTName;
			pxArc^ << m_bDefFirstInit;
			pxArc^ << m_bTitanDefense;
			pxArc^ << m_bBrokenLegs;
			for(i=0)cond(i<9)iter(i++)do
				(pxArc^) << m_afDamagePortion[i];
			endfor;
			pxArc^ << m_bTurtleOnLand;
			pxArc^ << m_bBiological;
			pxArc^ << m_bMeleePenetrate;
			pxArc^ << m_bLocked;
			pxArc^ << m_bLacered;
			pxArc^ << m_bThrowImmune;
			pxArc^ << m_bDarkSwarm;
			pxArc^ << m_bWeaponRemoved;
		endif;
		pxWalk^.Close();
		xBase="must"; // Henry: for stuff which must be saved...
		iVersion=1;
		pxWalk=p_pxWriterNode^.AddSubChunk(xBase,iVersion);
		pxArc=^(pxWalk^.GetArc());
		if(iVersion>=1)then
			(pxArc^) << m_bPBlocker;
		endif;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="FOba")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
//			CMirageSrvMgr.Debug(GetName()+"'s foba version: '"+(p_pxReaderNode^.GetVersion()).ToString()+"'");
//			iVersion=21;
			if(iVersion>=1)then
				(pxArc^) << m_iAggressionState;
			endif;
			if(iVersion>=2)then
				(pxArc^) << m_sTribe;
			endif;
			if(iVersion>=3)then
				m_xTransportObj.DoKArc(pxArc^);
			endif;
			if(iVersion>=4)then
				m_xFXObjects.DoKArc(pxArc^);
			endif;
			if(iVersion>=5)then
				var int i, iC;
				(pxArc^) << iC;
				for(i=0)cond(i<iC)iter(i++)do
					var int iValue;
					(pxArc^) << iValue;
					m_aiActionTimerIDs.AddEntry(iValue);
					var ^CFightingObj.CActionObj pxObj=^(m_axActionObj.NewEntryRef());
					pxObj^.DoKArc(pxArc^);
				endfor;
			endif;
			if(iVersion>=6)then
				m_xReturnEnemy.DoKArc(pxArc^);
			endif;
			if(iVersion>=7)then
				delete m_pxPatrolInfo;
				var bool bPatrolInfo=false;
				(pxArc^) << bPatrolInfo;
				if(bPatrolInfo)then
					m_pxPatrolInfo=new CPatrolInfo();
					m_pxPatrolInfo^.DoKArc(pxArc^);
				endif;
			endif;
			if(iVersion>=8)then
				pxArc^ << m_xRegionGuid;
				m_xProduceUnit.DoKArc(pxArc^);
				m_xRegionObjects.DoKArc(pxArc^);
			endif;
			if(iVersion>=9)then
				pxArc^ << m_vAggressionPos;
			endif;
			if(iVersion>=10)then
				pxArc^ << m_bInvisibleFlag;
				pxArc^ << m_bDefensiveMode;
				pxArc^ << m_bGodMode;
				pxArc^ << m_bScalpsGiven;
				pxArc^ << m_bBLDGResBack;
				pxArc^ << m_bSHIPResBack;
				pxArc^ << m_bWeaponHasChanged;
				pxArc^ << m_bOwnWeaponHasChanged;
				m_xLastHelpShout.DoKArc(pxArc^);
				pxArc^ << m_bIsHelpShout;
				m_xHelpDefendEnemies.DoKArc(pxArc^);
				m_xHelpAttackEnemies.DoKArc(pxArc^);
				pxArc^ << m_iEntrenchState;
				m_xCurEnemy.DoKArc(pxArc^);
				m_xLastFinishingVictim.DoKArc(pxArc^);
				pxArc^ << m_bFinished;
				pxArc^ << m_iInvulnerable;
				pxArc^ << m_bFeignDeath;
				pxArc^ << m_bRotateSLEAction;
				pxArc^ << m_bRotateAction;
				pxArc^ << m_bAggressionWalk;
				if(iVersion>=19)then pxArc^ << m_bAggrTNoAnml; endif;
				pxArc^ << m_bStraightWalkPatrol;
				pxArc^ << m_bStoppingPatrol;
				pxArc^ << m_bPatrolWalk;
				pxArc^ << m_bIsGettingFinished;
				pxArc^ << m_bDoingFinishingMove;
				m_xRallyTarget.DoKArc(pxArc^);
				pxArc^ << m_bStinaSlowhand;
				m_xLastEnemy.DoKArc(pxArc^);
				m_xReturnEnemy.DoKArc(pxArc^);
				pxArc^ << m_bReturnNoUserBerserkerMode;
				pxArc^ << m_bReturnUserCommand;
				pxArc^ << m_bIsTrapped;
				m_xTrap.DoKArc(pxArc^);
				m_xPotEnemies.DoKArc(pxArc^);
				pxArc^ << m_sMyBuildAction;
				pxArc^ << m_sObjPath;
				pxArc^ << m_bTechTreeInitialized;
				m_xPrimaryPoison.DoKArc(pxArc^,iVersion);
				m_xSecondaryPoison.DoKArc(pxArc^,iVersion);
				pxArc^ << m_iLastDamage;
				if(iVersion>=21)then
					var bitset dwSavedFXFlags;
					pxArc^ << dwSavedFXFlags;
					if((dwSavedFXFlags&EFFECT_AJE_CAMOUFLAGE)!=0d)then
						//KLog.LogWarn("CHP","SavedFX Cam:"+GetName());
						SetEffectFlag(EFFECT_AJE_CAMOUFLAGE, true);
					endif;
				endif;
			endif;
			if(iVersion>=11)then
				var int i,iC;
				pxArc^ << iC;
				for(i=0)cond(i<iC)iter(i++)do
					var ^CDmgTimer pxTimer=^(m_axDmgTimer.NewEntryRef());
					pxTimer^.DoKArc(pxArc^, iVersion);
					pxTimer^.SetParentProcRef(ProvideDmg);
				endfor;
			endif;
			if(iVersion>=12)then
				pxArc^ << m_bHelpShoutDefend;
			endif;
			if(iVersion>=13)then
				pxArc^ << m_bLDInvulnerable;
			endif;
			if(iVersion>=14)then
				var int i,iC;
				pxArc^ << iC;
				m_axCamouflageLayers=iC;
				for(i=0)cond(i<iC)iter(i++)do
					m_axCamouflageLayers[i].DoKArc(pxArc^);
				endfor;
				pxArc^ << m_bIntendedCamouflage;
			endif;
			if(iVersion>=15)then
				pxArc^ << m_iAttackType;
			endif;
			if(iVersion>=16)then
				pxArc^ << m_fHitTimeOut;
			endif;
			if(iVersion>=17)then
				m_xPriorityList.DoKArc(pxArc^);
			endif;
			if(iVersion>=18)then
				m_xChangeTargetTime.DoKArc(pxArc^);
			endif;
			if(iVersion>=20)then
				pxArc^ << m_bRage;
				pxArc^ << m_bIsRageUnit;
				pxArc^ << m_fSelfHealAmount;
			endif;
	
	//========================================================================================
	//===New member values loaded in MIRAGE by Henry==========================================
	//========================================================================================
	
			if(iVersion>=22)then
				pxArc^ << m_xCosts.m_iWood;
				pxArc^ << m_xCosts.m_iStone;
				pxArc^ << m_xCosts.m_iFood;
				pxArc^ << m_xCosts.m_iSkulls;
				pxArc^ << m_bANMLResBack;
				pxArc^ << m_bCHTRResBack;
				pxArc^ << m_bVHCLResBack;
				pxArc^ << m_fStrengthGrowing;
				pxArc^ << m_fCuringAmount;
				m_xLastReplenishTick.DoKArc(pxArc^);
				pxArc^ << m_fEnergyState;
				pxArc^ << m_fMaxEnergy;
				pxArc^ << m_fReplenishAmount;
				pxArc^ << m_fReplenishTime;
				pxArc^ << m_fManaEatingTime;
				pxArc^ << m_fIceTimeOut;
				pxArc^ << m_fImmunityTime;
				pxArc^ << m_fFreezingTime;
				pxArc^ << m_bIceImmunity;
				pxArc^ << m_bPoisonImmunity;
				pxArc^ << m_bIncapacitated;
				pxArc^ << m_iSupplyCount;
				pxArc^ << m_fTmpMeAttackBoni;
				pxArc^ << m_fTmpRaAttackBoni;
				pxArc^ << m_iKillerCount;
				pxArc^ << m_sFilter;
				m_xPrimaryFire.DoKArc(pxArc^,iVersion);
				m_xSecondaryFire.DoKArc(pxArc^,iVersion);
				pxArc^ << m_bFlyingUnit;
				m_xSacrificer.DoKArc(pxArc^);
				var int i,iC;
				(pxArc^) << iC;
				m_axParasites=iC;
				for(i=0)cond(i<iC)iter(i++)do
					m_axParasites[i].DoKArc(pxArc^);
				endfor;
				pxArc^ << m_bFreeHunting;
				m_xSpawningPool.DoKArc(pxArc^);
				m_xReactor.DoKArc(pxArc^);
				m_xHiveMind.DoKArc(pxArc^);
				pxArc^ << m_bMirroring;
				m_xCorpse.DoKArc(pxArc^);
				pxArc^ << m_iCmdID;
				pxArc^ << m_iOwnerID;
				m_xBonds.DoKArc(pxArc^);
				pxArc^ << m_bDemoteEffect;
				m_xAttackers.DoKArc(pxArc^);
				m_xLethalWoundZero.DoKArc(pxArc^,iVersion);
				m_xLethalWoundOne.DoKArc(pxArc^,iVersion);
				m_xLethalWoundTwo.DoKArc(pxArc^,iVersion);
				m_xLethalWoundThree.DoKArc(pxArc^,iVersion);
				m_xLethalWoundFour.DoKArc(pxArc^,iVersion);
				m_xLethalWoundFive.DoKArc(pxArc^,iVersion);
				m_xLethalWoundSix.DoKArc(pxArc^,iVersion);
				m_xLethalWoundSeven.DoKArc(pxArc^,iVersion);
				m_xLethalWoundEight.DoKArc(pxArc^,iVersion);
				pxArc^ << m_bPlayerRevealed;
				pxArc^ << m_bSpiritCreated;
				pxArc^ << m_bTamed;
				pxArc^ << m_bPinnedDown;
				pxArc^ << m_bShattered;
				pxArc^ << m_bSundered;
				pxArc^ << m_bBlinded;
				pxArc^ << m_bDeafened;
				pxArc^ << m_bMarkedForDeath;
				pxArc^ << m_bCyborgBonus;
				pxArc^ << m_bExplosiveRounds;
				pxArc^ << m_bJetpack;
				pxArc^ << m_bFirework;
				pxArc^ << m_bCeaseFire;
				pxArc^ << m_bUnboard;
				pxArc^ << m_bFrozen;
				pxArc^ << m_bStimpack;
				pxArc^ << m_bStolen;
				pxArc^ << m_bSuicide;
				pxArc^ << m_bBloodInfect;
				pxArc^ << m_bEvading;
				m_xIntimidate.DoKArc(pxArc^);
				pxArc^ << m_iPQNEO;
				pxArc^ << m_iPQNER;
				m_xPotentialTransportObject.DoKArc(pxArc^);
				pxArc^ << m_iKillerHistory;
				pxArc^ << m_bAILock;
				pxArc^ << m_fSelfRegenerating;
				pxArc^ << m_fMaxDef;
				pxArc^ << m_bIsCamouflaged;
				pxArc^ << m_bIsDead;
				pxArc^ << m_bInvalidEnemy;
				pxArc^ << m_bInvalidFighter;
				pxArc^ << m_bToBeDeleted;
				pxArc^ << m_sPerRegName;
				pxArc^ << m_bNoHitReaction;
				pxArc^ << m_bBUAirAttack;
				pxArc^ << m_sObjFlag;
				pxArc^ << m_bCostsFromAction;
				pxArc^ << m_fJawSize;
				pxArc^ << m_fFeedFactor;
				pxArc^ << m_bResurrecting;
				m_xPrimaryTarget.DoKArc(pxArc^);
				pxArc^ << m_bPassingAway;
				pxArc^ << m_bHidingEnemy;
				pxArc^ << m_bUniqueMask;
				pxArc^ << m_bSlaveInvincible;
				(pxArc^) << iC;
				for(i=0)cond(i<iC)iter(i++)do
					var ^CFightingObj.CToDoEntry pxObj=^(m_axToDoList.NewEntryRef());
					pxObj^.SetProcRef(OnExecuteNextEntry);
					pxObj^.DoKArc(pxArc^,iVersion);
				endfor;
				pxArc^ << m_bOnTheGround;
				pxArc^ << m_bHPReachedZero;
				pxArc^ << m_bTimeTrap;
				pxArc^ << m_bObjectTrap;
				m_xTornado.DoKArc(pxArc^);
				pxArc^ << m_sPTName;
				pxArc^ << m_bDefFirstInit;
				pxArc^ << m_bTitanDefense;
				pxArc^ << m_bBrokenLegs;
				for(i=0)cond(i<9)iter(i++)do
					(pxArc^) << m_afDamagePortion[i];
				endfor;
				pxArc^ << m_bTurtleOnLand;
				pxArc^ << m_bBiological;
				pxArc^ << m_bMeleePenetrate;
				pxArc^ << m_bLocked;
				pxArc^ << m_bLacered;
				pxArc^ << m_bThrowImmune;
				pxArc^ << m_bDarkSwarm;
				pxArc^ << m_bWeaponRemoved;
			endif;
		elseif(p_pxReaderNode^.GetType()=="must")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			if(p_pxReaderNode^.GetVersion()==1)then
				(pxArc^) << m_bPBlocker;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		UpdateTribeName();
//		if((GetOwner()==2||GetOwner()==3)&&GetClassName()!="Virtual_Produce_Unit")then
//			CreateTimer(TIMER_INFORM_ME, CGameTimeSpan.OneSecond()*5.0, true);
//		endif;
//		if(GetOwner()==0)then
////			PlayerRevealed(true);
//			CreateTimer(TIMER_INFORM_ME, CGameTimeSpan.OneSecond()*5.0, true);
//		endif;
//		if(GetClassName()=="xxx")then
//			CreateTimer(TIMER_INFORM_ME, CGameTimeSpan.OneSecond()*5.0, true);
//		endif;
//		if(GetName()=="xxx")then
//			CreateTimer(TIMER_INFORM_ME, CGameTimeSpan.OneSecond()*20.0, true);
//		endif;
		SetAggressionState(m_iAggressionState);
		m_pxWeaponMgr^.UpdateAll();
		UpdateEquipment();
		UpdateFightFactors();
		if(!m_xRegionGuid.IsNull())then
			var int iIdx=CSrvWrap.GetRegionMgr().FindRegion(m_xRegionGuid);
			if(iIdx>=0)then
				var ^CRegion pxRegion=CSrvWrap.GetRegionMgr().GetRegion(iIdx);
				if(pxRegion!=null)then
					m_xSink.SetRegion(pxRegion);
					pxRegion^.BindToObj(GetHandle());
					m_xSink.Subscribe();
					var ^CAttribs pxAttr=GetAttribs();
					if(pxAttr!=null)then
						pxAttr^.SetValue("RangeMarker","Personal/"+(pxRegion^.GetRadius()).ToString()+";");
					endif;
				endif;
			else
				var CGuid xG; m_xRegionGuid=xG;
			endif;
		endif;
		if(m_xProduceUnit.IsValid())then
			var ^CVirtualProduceUnit pxUnit=cast<CVirtualProduceUnit>(m_xProduceUnit.GetObj());
			if(pxUnit!=null)then
//				pxUnit^.Init(GetHandle());
				pxUnit^.Init(GetHandle(), GetClassName(), GetTribeName());
			endif;
		endif;
		if(m_xReactor.IsValid())then
			var ^CVirtualProduceUnit pxUnit=cast<CVirtualProduceUnit>(m_xReactor.GetObj());
			if(pxUnit!=null)then
				pxUnit^.Init(GetHandle(), GetClassName(), GetTribeName());
			endif;
		endif;
		if(m_xHiveMind.IsValid())then
			var ^CHiveMind pxUnit=cast<CHiveMind>(m_xHiveMind.GetObj());
			if(pxUnit!=null)then
				pxUnit^.Init(GetHandle());
				m_iCmdID=pxUnit^.GetOwner();
			endif;
		endif;
		var ^CInventory pxInv=GetInventory();
		if(pxInv!=null)then
			var int i, iC=pxInv^.Count();
			var CObjList xList;
			for(i=0) cond(i<iC) iter(++i)do
				if(!pxInv^.GetItem(i).IsValid())then continue; endif;
				xList.Include(pxInv^.GetItem(i));
			endfor;
			iC=xList.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				if(xList[i].IsValid())then
					var ^CGameObj pxItem=xList[i].GetObj();
					var ^CItem pxI=cast<CItem>(pxItem);
					if(pxI!=null)then
						RemoveItemPL(pxI^.GetHandle());
						AddItem(pxI^.GetHandle());
					endif;
				endif;
			endfor;
		endif;
		UpdateCamouflageLayers();
//		if(GetName()=="ninigi_archer_71")then
//			CheckEnemyValidity();
//		endif;
//		if((GetType()=="ANML"||GetType()=="BLDG"||GetType()=="CHTR"||GetType()=="SHIP"||GetType()=="VHCL")&&(GetOwner()==2||GetOwner()==3))then
//			Die();
//			return;
//		endif;
	endproc;
	
	export proc void SetLastDamage(int p_iOwner)
		m_iLastDamage=p_iOwner;
	endproc;
	
	export proc int GetLastDamage()
		return m_iLastDamage;
	endproc;
	
	// CHEAT for testing
	export static proc void ToggleGodModeForAllObjects()
		ms_bToggleGodMode=!ms_bToggleGodMode;
		var CObjQuery xQuery;
		var CObjList xList;
		xQuery.Execute(xList);
		var int i,iC=xList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFightingObj pxObj=cast<CFightingObj>(xList[i].GetObj());
			if(pxObj!=null)then
				pxObj^.SetGodMode(ms_bToggleGodMode);
			endif;
		endfor;
	endproc;
	
	export proc void AddItemName(string p_sName)
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			if(p_sName.IsEmpty()&&!pxAttr^.GetValue("inventory_item_name").IsEmpty())then
				RemoveFX("fx_unique_pickup");
			elseif(!p_sName.IsEmpty()&&pxAttr^.GetValue("inventory_item_name").IsEmpty()&&!IsWildAnimal())then
				var CObjHndl xHndl=AddFX("fx_unique_pickup",-1.0);
				var CFourCC xLink;
				xHndl.GetObj()^.LinkAction(GetHandle(),xLink);
				//xHndl.GetObj()^.SetAnim("anim");
			endif;
			pxAttr^.SetValue("inventory_item_name",p_sName);
		endif;
	endproc;
	
	export proc void AddItem(CObjHndl p_xItem)
		var ^CInventory pxInv=GetInventory();
		if(pxInv==null)then return; endif;
		var ^CItem pxItem=cast<CItem>(p_xItem.GetObj());
		if(pxItem==null)then return; endif;
		if(!CArtifactMgr.Get().AddArtifact(GetOwner(),p_xItem))then return; endif;
		pxInv^.AddItem(pxItem^.GetHandle());
		var CFourCC xLink="INVE";
		pxItem^.LinkAction(GetHandle(), xLink);
		pxItem^.SetVisible(false);
		pxItem^.OnTakeItem(this,"normal");
		AddItemName(pxItem^.GetName());
		InvokeGenericSCEvent(38,0.6f);
	endproc;
	
	export proc void RemoveItemPL(CObjHndl p_xItem)
		RemoveItem(p_xItem);
	endproc;
	
	export proc void RemoveItem(CObjHndl p_xItem)
		var ^CInventory pxInv=GetInventory();
		if(pxInv==null)then return; endif;
		var ^CItem pxItem=cast<CItem>(p_xItem.GetObj());
		if(pxItem==null)then return; endif;
		if(!CArtifactMgr.Get().RemoveArtifact(GetOwner(),p_xItem))then /*Do Nothing*/; endif;
		pxInv^.RemItem(pxItem^.GetHandle());
		pxItem^.OnDropped(this);
		pxItem^.TerminateAction();
		AddItemName("");
	endproc;
	
	export proc int AddProdQueueItem(string p_sClass, bool p_bReactor)
		var int iID=-1;
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		var ^CPlayer pxPlayer=pxLevel^.GetPlayer(GetOwner());
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr==null)then return iID; endif;
		var string sAttrib="";
		if(p_bReactor)then
			sAttrib="ReactorProdQueue";
		else
			sAttrib="ProdQueue";
		endif;
		var string sProdQueue=pxAttr^.GetValue(sAttrib);
		if(sProdQueue.GetLength()>400)then return iID;endif;
		if(pxPlayer!=null)then
			var ^CTechTree.CNode pxTTNode=pxPlayer^.GetPlayerTechTree().FindNode(p_sClass);
			if(pxTTNode!=null)then
				iID=pxTTNode^.GetHashValue();
			endif;
		endif;
		if(iID!=-1)then
			if(p_bReactor)then
				m_iPQNER+=1;
			else
				m_iPQNEO+=1;
			endif;
			sProdQueue+=":"+iID.ToString();
			pxAttr^.SetValue(sAttrib,sProdQueue);
		endif;
		return iID;
	endproc;
	
	export proc void RemoveProdQueueItem(int p_iID, bool p_bReactor)
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr==null)then return; endif;
		var string sAttrib="";
		if(p_bReactor)then
			sAttrib="ReactorProdQueue";
		else
			sAttrib="ProdQueue";
		endif;
		var string sProdQueue=pxAttr^.GetValue(sAttrib);
		var array string asTokens;
		sProdQueue.Split(asTokens,":",true);
		var int i,iC=asTokens.NumEntries();
		var string sProdID=p_iID.ToString();
		for(i=0)cond(i<iC)iter(i++)do
			if(asTokens[i]==sProdID)then
				asTokens.DeleteEntry(i);
				sProdQueue="";
				var int iK,iKC=asTokens.NumEntries();
				for(iK=0)cond(iK<iKC)iter(iK++)do
					sProdQueue+=asTokens[iK]+":";
				endfor;
				if(p_bReactor)then
					m_iPQNER=Math.Max(0,(iC-1));
				else
					m_iPQNEO=Math.Max(0,(iC-1));
				endif;
				pxAttr^.SetValue(sAttrib,sProdQueue);
				break;
			endif;
		endfor;
	endproc;
	
	export proc void SetGodMode(bool p_bState)
		m_bGodMode=p_bState;
	endproc;
	
	export proc bool GetGodMode()
		return m_bGodMode;
	endproc;
	
	export proc void ToggleGodMode()
		m_bGodMode=!m_bGodMode;
	endproc;
	
	export proc real GetBonusSum(int p_iType)
		var ^CBoniBucket pxB=GetBoniBucket(p_iType);
		var int i, iC=pxB^.NumEntries();
		var real fSum=0.0f;
		for (i=0) cond(i<iC) iter(++i)do
			fSum += pxB^[i].m_fBonus;
		endfor;
		return fSum;
	endproc;
	
	export proc void ForceBoniUpdate()
		if(GetHitpoints() <= 0.0f)then return; endif;
		ChangeMaxHitpoints(GetTechTreeHitpoints());
		ChangeMaxEnergy(GetTechTreeMaxEnergy()); //set new maximal value of energy amount if from techtree
		UpdateFOW();
		UpdateRangeNDamageInformation();
		AddTemporaryDefenseBoni(GetProtection());
		AddTemporaryRangedDefenseBoni(GetRangedProtection());
		AddTemporaryAttackBoni(GetDmg());
		AddTemporaryMeleeAttackBoni(GetDmg()); //refresh temporarily melee attack bonuses and maluses
		AddTemporaryRangedAttackBoni(GetDmg()); //refresh temporarily ranged attack bonuses and maluses
		AddTemporaryRangeBoni();
		ClearDamageCache();
	endproc;
	
	export proc void AddCamouflageEffect(string p_sType)
		AddCamouflageEffect(p_sType,CObjHndl.Invalid());
	endproc;
	
	export proc void AddCamouflageEffect(string p_sType, CObjHndl p_xSrcObj)
		if(p_sType=="disg")then
			if(HasTimer(CAMO_TIMER))then
				m_bIntendedCamouflage=true;
				return;
			endif;
		endif;
		var bool bUnique=p_sType=="smok"||p_sType=="hero"||p_sType=="dino";
		var CFightingObj.CCamouflageLayer xLayer;
		xLayer.SetType(p_sType);
		var int iIdx=m_axCamouflageLayers.FindEntry(xLayer);
		if(iIdx!=-1)then
			m_axCamouflageLayers[iIdx].Inc();
			m_axCamouflageLayers[iIdx].SetType(p_sType);
			if(p_xSrcObj.IsValid())then
				m_axCamouflageLayers[iIdx].AddSrcObj(p_xSrcObj);
			endif;
			if(!bUnique)then
				m_axCamouflageLayers[iIdx].SetDisabled(m_bPlayerRevealed);
			endif;
		else
			var ^CFightingObj.CCamouflageLayer pxLayer=^(m_axCamouflageLayers.NewEntryRef());
			pxLayer^.Inc();
			pxLayer^.SetType(p_sType);
			if(!bUnique)then
				pxLayer^.SetDisabled(m_bPlayerRevealed);
			endif;
			if(p_xSrcObj.IsValid())then
				pxLayer^.AddSrcObj(p_xSrcObj);
			endif;
		endif;
		UpdateCamouflageLayers();
	endproc;
	
	export proc bool HasCamouflageEffect(string p_sType)
		var CCamouflageLayer xLayer;
		xLayer.SetType(p_sType);
		var int iIdx=m_axCamouflageLayers.FindEntry(xLayer);
		return (iIdx>-1);
	endproc;
	
	export proc bool HasValidCamouflageEffect(string p_sType)
		var CCamouflageLayer xLayer;
		xLayer.SetType(p_sType);
		var int iIdx=m_axCamouflageLayers.FindEntry(xLayer);
		if(iIdx>-1)then
			return (m_axCamouflageLayers[iIdx].IsValid()&&!(m_axCamouflageLayers[iIdx].IsOffline()));
		else
			return false;
		endif;
	endproc;
	
	export proc void RemoveCamouflageEffect(string p_sType)
		RemoveCamouflageEffect(p_sType,CObjHndl.Invalid());
	endproc;
	
	export proc void RemoveCamouflageEffect(string p_sType, CObjHndl p_xSrcObj)
		var CFightingObj.CCamouflageLayer xLayer;
		xLayer.SetType(p_sType);
		var int iIdx=m_axCamouflageLayers.FindEntry(xLayer);
		if(iIdx!=-1)then
			m_axCamouflageLayers[iIdx].Dec();
			if(p_sType=="disg"||p_sType=="dino")then m_axCamouflageLayers[iIdx].m_iCount=0; endif; //don't refcount "disg" (ninigi_ninja)
			m_axCamouflageLayers[iIdx].RemSrcObj(p_xSrcObj);
		endif;
		UpdateCamouflageLayers();
	endproc;
	
	export proc void Reveal()
		var int i,iC=m_axCamouflageLayers.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(m_axCamouflageLayers[i]=="")then
				m_axCamouflageLayers.DeleteEntry(i);i--;iC--;
				continue;
			endif;
			if(m_axCamouflageLayers[i]=="disg")then
				m_axCamouflageLayers.DeleteEntry(i);i--;iC--;
				continue;
			endif;
			if(m_axCamouflageLayers[i]=="entr")then
				m_axCamouflageLayers.DeleteEntry(i);i--;iC--;
				continue;
			endif;
		endfor;
		if(GetEffectFlag(EFFECT_AJE_CAMOUFLAGE))then
//			TerminateAction();
			SetEffectFlag(EFFECT_AJE_CAMOUFLAGE, false);
		endif;
		if(CanDisguise())then
			ResetCamouflageTimer();
			AddCamouflageEffect("disg");
		endif;
		if(IsFeignDeath()&&GetCurTask()!=null)then
			var ^CFeignDeath pxTask=cast<CFeignDeath>(GetCurTask());
			if(pxTask!=null)then
				pxTask^.Break();
			endif;
		endif;
		UpdateCamouflageLayers();
	endproc;
	
	export proc void UpdateCamouflageLayers()
		var bool bCamouflage=false;
		var CFightingObj.CCamouflageLayer xLayer;
//		xLayer.SetType("smok");
		var int i,iC=m_axCamouflageLayers.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if((!m_axCamouflageLayers[i].IsOffline())&&m_axCamouflageLayers[i].IsValid())then
				bCamouflage=true;
				break;
			endif;
		endfor;
//		var bool bUnique=HasCamouflageEffect("smok")||HasCamouflageEffect("hero");
		var bool bUnique=HasValidCamouflageEffect("hero");
		if(HasValidCamouflageEffect("smok"))then
			AddRangedBuff("is_invisible");
			bUnique=true;
		else
			RemoveRangedBuff("is_invisible");
		endif;
		SetUniqueMask(bUnique);
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("camouflage_active",bCamouflage.ToString());
			pxAttr^.SetValue("not_detectable",bUnique);
		endif;
		SetCamouflage(bCamouflage);
		m_bIsCamouflaged=bCamouflage;
		CheckEnemyHiding();
	endproc;
	
	export proc void SetCamouflage(bool p_bValue, bool p_bVisible)
		super.SetCamouflage(p_bValue, p_bVisible);
	endproc;
	
	export proc void SetCamouflage(bool p_bValue)
		if(GetCamouflage()==p_bValue)then return; endif;
		if(GetTransportObj().IsValid()&&!IsOnOpenTransporter())then return; endif;
		if(CanDisguise())then
			var ^CAttribs pxAttr=GetAttribs();
			if(pxAttr!=null)then
				pxAttr^.SetValue("active_disguise",p_bValue);
			endif;
			if(p_bValue)then
				var CObjHndl xHndl=AddFX("fx_ninja_disguise",-1.0);
				AddRangedBuff("is_camouflaged");
				if(xHndl.IsValid())then
					var CFourCC xLink="";
					xHndl.GetObj()^.LinkAction(GetHandle(),xLink);
				endif;
			else
				RemoveFX("fx_ninja_disguise");
				RemoveRangedBuff("is_camouflaged");
			endif;
		endif;
		if(p_bValue&&HasTimer(CAMO_TIMER))then
			return;
		endif;
		super.SetCamouflage(p_bValue);
	endproc;
	
	export proc void OnReveal()
	endproc;
	
	export proc void SwitchTrapCamouflage(bool p_bActivate)
		var string sType="trap";
		var CFightingObj.CCamouflageLayer xLayer;
		xLayer.SetType(sType);
		var int iIdx=m_axCamouflageLayers.FindEntry(xLayer);
		if(iIdx==-1)then
			var ^CFightingObj.CCamouflageLayer pxLayer=^(m_axCamouflageLayers.NewEntryRef());
			pxLayer^.Inc();
			pxLayer^.SetType(sType);
			pxLayer^.SetDisabled(!p_bActivate);
		else
			m_axCamouflageLayers[iIdx].SetDisabled(!p_bActivate);
		endif;
		if(p_bActivate)then
			AddRangedBuff("is_camouflaged");
		else
			RemoveRangedBuff("is_camouflaged");
		endif;
		UpdateCamouflageLayers();
	endproc;
	
	///////
	//	SetEffectFlag()
	///////
	export proc void SetEffectFlag(bitset p_dwFlag, bool p_bOn)
		var int iIndex=-1;
		var bool bClearWpnCache=false, bFight=false;
		if(p_dwFlag==EFFECT_MEGALO_DRUMS)then
			iIndex=0;
			bFight=true;
		elseif(p_dwFlag==EFFECT_RHINO_PENNANT)then
			iIndex=1;
			bFight=true;
		elseif(p_dwFlag==EFFECT_CHTR_WARCRY_3)then
			iIndex=2;
			bFight=true;
		elseif(p_dwFlag==EFFECT_CHTR_WARCRY_4)then
			iIndex=3;
			bFight=true;
		elseif(p_dwFlag==EFFECT_CHTR_WARCRY_5)then
			iIndex=4;
			bFight=true;
		elseif(p_dwFlag==EFFECT_WILDBOAR_RAGE)then
			iIndex=5;
			bFight=true;
		elseif(p_dwFlag==EFFECT_TRICERATOPS_PAW)then
			iIndex=6;
			bFight=true;
		elseif(p_dwFlag==EFFECT_NINIGI_CAULDRON)then
			iIndex=7;
			bFight=true;
		elseif(p_dwFlag==EFFECT_AJE_WARPAINT_3)then
			iIndex=9;
			bFight=true;
		elseif(p_dwFlag==EFFECT_AJE_WARPAINT_4)then
			iIndex=10;
			bFight=true;
		elseif(p_dwFlag==EFFECT_AJE_WARPAINT_5)then
			iIndex=11;
			bFight=true;
		elseif(p_dwFlag==EFFECT_ITEM_STONED)then
			iIndex=12;
		elseif(p_dwFlag==EFFECT_ITEM_RING)then
			iIndex=13;
			bFight=true;
		elseif(p_dwFlag==EFFECT_ITEM_AMULETT1)then
			iIndex=14;
			bFight=true;
		elseif(p_dwFlag==EFFECT_SMOKER_INVIS)then
			if(p_bOn)then
				AddCamouflageEffect("smok");
			else
				RemoveCamouflageEffect("smok");
			endif;
			iIndex=15;
		elseif(p_dwFlag==EFFECT_AJE_CAMOUFLAGE)then
			iIndex=16;
		elseif(p_dwFlag==EFFECT_MAMMOTH_TRUMPET)then
			iIndex=17;
			bFight=true;
		elseif(p_dwFlag==EFFECT_ADA_SLOWHAND_1)then
			iIndex=18;
		elseif(p_dwFlag==EFFECT_NO_ANIMAL_AGGRO)then
			iIndex=19;
		elseif(p_dwFlag==EFFECT_KLEEMANN_AURA)then
			iIndex=20;
		elseif(p_dwFlag==EFFECT_SKULL_PROTECTOR)then
			iIndex=21;
		elseif(p_dwFlag==EFFECT_MAYOR_DOMINANCE)then
			iIndex=22;
			bFight=true;
		elseif(p_dwFlag==EFFECT_PARA_DRUMS)then
			iIndex=23;
			bFight=true;
		endif;
		if(iIndex!=-1)then
			if(p_bOn)then
				if(m_aiEffectFlags[iIndex]==0)then
					//new effect
					if(iIndex==2||iIndex==3||iIndex==4)then
						//warcry
						var ^CGameObj pxObj=AddFX("fx_warcry",2.0).GetObj();
						if(pxObj!=null)then
							var CFourCC xLink;
							pxObj^.LinkAction(GetHandle(),xLink);
						endif;
						pxObj=AddFX("fx_warcry_lite",-1.0).GetObj();
						if(pxObj!=null)then
							var CFourCC xLink;
							pxObj^.LinkAction(GetHandle(),xLink);
						endif;
					elseif(iIndex==9||iIndex==10||iIndex==11||iIndex==22)then
						AddRangedBuff("less_damage");
//					elseif(iIndex==15)then
//						AddCamouflageEffect("smok");
					elseif(iIndex==18)then
						AddRangedBuff("less_attack_speed");
					elseif(iIndex==19)then
						AddRangedBuff("no_animal_aggro");
					elseif(iIndex==21)then
						//skull protector aura effect
						var ^CTechTreeDef pxDef=GetTechTreeDef();
						if(pxDef!=null)then
							pxDef^.EnableFilter(CSkullProtector.PATH);
						endif;
						//AddRangedBuff("");
					endif;
				endif;
				if(bFight)then
					bClearWpnCache=true;
				endif;
				m_aiEffectFlags[iIndex]++;
			else
				m_aiEffectFlags[iIndex]--;
				if(m_aiEffectFlags[iIndex]<=0)then
					//new effect
					if(iIndex==2||iIndex==3||iIndex==4)then
						//warcry
						RemoveFX("fx_warcry");
						RemoveFX("fx_warcry_lite");
					elseif(iIndex==9||iIndex==10||iIndex==11||iIndex==22)then
						RemoveRangedBuff("less_damage");
//					elseif(iIndex==15)then
//						RemoveCamouflageEffect("smok");
					elseif(iIndex==18)then
						RemoveRangedBuff("less_attack_speed");
					elseif(iIndex==19)then
						RemoveRangedBuff("no_animal_aggro");
					elseif(iIndex==21)then
						//skull protector aura effect
						var ^CTechTreeDef pxDef=GetTechTreeDef();
						if(pxDef!=null)then
							pxDef^.DisableFilter(CSkullProtector.PATH);
						endif;
						//AddRangedBuff("");
					endif;
					if(bFight)then
						bClearWpnCache=true;
					endif;
				endif;
				if(iIndex==16)then
//					SetCanFightAttrib(true);
					m_aiEffectFlags[iIndex]=0;
					RemoveRangedBuff("is_camouflaged");
				endif;
				if(iIndex==6||iIndex==17||iIndex==19)then // Henry: tric titan's paw, mammoth's trumpet and Warden's T3
					m_aiEffectFlags[iIndex]=0;
				endif;
			endif;
			if(m_aiEffectFlags[iIndex]>0)then
				m_dwEffectFlags |= p_dwFlag;
				if(iIndex==12)then
					//m_pxTaskMgr^.BreakAll();
				elseif(iIndex==15)then
//					AddRangedBuff("is_invisible");
				elseif(iIndex==16)then
					var string sGfx=GetFakeANMLGfx();
					SetGFX(sGfx);
					if(sGfx!=CMirageSrvMgr.FAKEGFX)then
						var ^CTechTreeDef pxDef=GetTechTreeDef();
						if(pxDef!=null)then
							pxDef^.EnableFilter("/Filters/Aje/Upgrades/xenage/camouflage_stuff");
						endif;
						RemAllLinkGFX();
						SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_PARTYCOL,false);
						SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,false);
						SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_HELMET,false);
						SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMOR,false);
						SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_STANDARTE,false);
						SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMORSADDLE,false);
						if(sGfx!="Kentrosaurus"&&sGfx!="Macrolemys"&&sGfx!="Stegosaurus"&&sGfx!="Mammoth")then
							SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_MISC,false);
						else
							SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_MISC,true);
						endif;
						SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_WOUND_ARMLI,false);
						SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_WOUND_ARMRE,false);
						SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_WOUND_LEGLI,false);
						SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_WOUND_LEGRE,false);
						SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_WOUND_BELLI,false);
						SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_WOUND_BELRE,false);
						SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_WOUND_HEAD,false);
						SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_WOUND_TAIL,false);
					endif;
					begin SetAttribs;
						//needed for AI
						var ^CAttribs pxAttr=GetAttribs();
						if(pxAttr!=null)then
							pxAttr^.SetValue("active_camouflage",true);
						endif;
					end SetAttribs;
					OnTechTreeChange();
					AddRangedBuff("is_camouflaged");
					SetCanFightAttrib(false);
//					AddCamouflageEffect("dino");
					SetHideMiniMap(true);
					m_sStandardDesc="dcamouflage";
					SetTaskDescription(m_sStandardDesc);
					if(HasWalkAction())then
						var vec3 vP = GetCurWalkTarget();
						WalkAction(vP,GetDefaultSpeed());
					endif;
				elseif(iIndex==20)then
					//Kleemann Aura Effect
					var ^CTechTreeDef pxDef=GetTechTreeDef();
					if(pxDef!=null)then
						pxDef^.EnableFilter(CHero.KLEEMANN_AURA_PATH);
					endif;
					AddRangedBuff("more_skulls");
				endif;
			else
				m_aiEffectFlags[iIndex]=0;
				m_dwEffectFlags &= ~p_dwFlag;
				if(iIndex==15)then
//					RemoveRangedBuff("is_invisible");
				elseif(iIndex==16)then
					var ^CTechTreeDef pxDef=GetTechTreeDef();
					if(pxDef!=null)then
						pxDef^.DisableFilter("/Filters/Aje/Upgrades/xenage/camouflage_stuff");
					endif;
					UpdateGfx();
					OnTechTreeChange();
					//Reset normal idle animation for shaman
					begin SetAttribs;
						//needed for AI
						var ^CAttribs pxAttr=GetAttribs();
						if(pxAttr!=null)then
							pxAttr^.SetValue("active_camouflage",false);
						endif;
					end SetAttribs;
					AddSpecialActionTimer("Actions/Aje/Moves/CHTR/camouflage");
//					SetCamouflage(false, false);
					UpdateCamouflageLayers();
					//set normal walking speed again for shaman from tt
					if(HasWalkAction())then
						var vec3 vP=GetCurWalkTarget();
						WalkAction(vP,GetDefaultSpeed());
					endif;
//					RemoveCamouflageEffect("dino");
					SetHideMiniMap(false);
					m_sStandardDesc="";
					SetTaskDescription("");
				elseif(iIndex==20)then
					//Kleemann Aura Effect
					var ^CTechTreeDef pxDef=GetTechTreeDef();
					if(pxDef!=null)then
						pxDef^.DisableFilter(CHero.KLEEMANN_AURA_PATH);
					endif;
					RemoveRangedBuff("more_skulls");
				endif;
			endif;
/*
			if(iIndex==15||iIndex==16)then
				var int iV=m_aiEffectFlags[15] - m_aiEffectFlags[16];
				if(iV==0)then
					return;
				elseif(iV<0)then
					SetCamouflage(true, false);
				else
					SetCamouflage(true);
				endif;
			endif;
*/
			if(iIndex==7)then
				var int iV=m_aiEffectFlags[7];
				var ^CTechTreeDef pxDef=GetTechTreeDef();
				if(iV>0)then
					pxDef^.EnableFilter(CCauldron.EFFECT_PATH);
				else
					pxDef^.DisableFilter(CCauldron.EFFECT_PATH);
				endif;
			endif;
		endif;
		//Updating interface
		UpdateRangeNDamageInformation();
		AddTemporaryAttackBoni(GetDmg());
		//Henry: because melee and ranged attack bonuses are in MIRAGE separately handled
		AddTemporaryMeleeAttackBoni(GetDmg());
		AddTemporaryRangedAttackBoni(GetDmg());
		AddTemporaryDefenseBoni(GetProtection());
		AddTemporaryRangedDefenseBoni(GetRangedProtection());
		if(bClearWpnCache)then
			ClearDamageCache();
		endif;
	endproc;
	
	export proc void AddRangedBuff(string p_sBuff)
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr==null)then return; endif;
		var string sBuffs=pxAttr^.GetValue("BuffDecals");
		var string sSearchBuff=";"+p_sBuff;
		if(sBuffs.Find(sSearchBuff)!=-1)then return; endif;
		sBuffs+=sSearchBuff;
		pxAttr^.SetValue("BuffDecals",sBuffs);
	endproc;
	
	export proc void RemoveRangedBuff(string p_sBuff)
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr==null)then return; endif;
		var string sBuffs=pxAttr^.GetValue("BuffDecals");
		var string sSearchBuff=";"+p_sBuff;
		if(sBuffs.Find(sSearchBuff)==-1)then return; endif;
		sBuffs.Replace(sSearchBuff,"");
		pxAttr^.SetValue("BuffDecals",sBuffs);
	endproc;
	
	export proc void SetOnWall(bool p_bValue)
		super.SetOnWall(p_bValue);
		AddTemporaryRangedDefenseBoni(GetRangedProtection());
	endproc;
	
	export proc string GetCamouflageAnml()
		var string sCreep=(CSrvWrap.GetCurLevel()^.GetLevelInfo().GetGenericData())["Base"].GetValueS("CamCreep","");
		if(!sCreep.IsEmpty())then return sCreep; endif;
		var string sSetting=CSrvWrap.GetCurLevel()^.GetLevelInfo().GetAttribs().GetValue("Setting");
		if(sSetting=="Jungle")then
			return "Parasaurolophus";
		elseif(sSetting=="Northland")then
			return "Megaloceros";
		elseif(sSetting=="Savanna")then
			return "Maiasauria";
		elseif(sSetting=="Ashvalley"||sSetting=="Cave3")then
			return "Iguanodon";
		elseif(sSetting=="Icewaste")then
			return "Megaloceros";
		endif;
		return "";
	endproc;
	
	///////
	//	GetEffectFlag()
	///////
	export proc bool GetEffectFlag(bitset p_dwFlag)
		return ((m_dwEffectFlags & p_dwFlag)==p_dwFlag);
	endproc;
	
	export proc ^CBoniBucket GetBoniBucket(int p_iType)
		return ^m_axBoni[p_iType];
	endproc;
	
	export var CObjList m_xGropWalkMembersTmp;
	
	export proc void OnTaskStarted()
		m_xGropWalkMembersTmp.Clear();
	endproc;
	
	export proc void OnEmptyTaskList()
		m_xGropWalkMembersTmp.Clear();
	endproc;
	
	///////
	//	OnActionStart()
	///////
	export proc void OnActionStart()
		GetFSM()^.Enable(false);
	endproc;
	
	export proc void OnActionPreEnd(bool p_bBroken)
		m_xGropWalkMembersTmp.Clear();
		if(!p_bBroken)then
			var ^CGroupWalk pxGW=GetCurrentGroupWalk();
			if(pxGW!=null)then
				var ^CWalkToPos pxCurWalkTask=cast<CWalkToPos>(GetCurTask());
				if(pxCurWalkTask!=null)then
					var CObjList xObjs;//Execute_Q_Walk
					pxGW^.GetMemberList(m_xGropWalkMembersTmp);
				endif;
			endif;
		endif;
	endproc;
	
	///////
	//	OnActionEnd(bool p_bBroken)
	///////
	export proc void OnActionEnd(bool p_bBroken)
		if(m_bPatrolWalk)then
			if(!p_bBroken)then
				if(m_pxPatrolInfo!=null)then
					m_pxPatrolInfo^.PatrolPointReached();
				endif;
			endif;
			m_bPatrolWalk=false;
		endif;
		var ^CTask pxTask=GetCurTask();
		if(pxTask!=null)then
			if(p_bBroken)then
				pxTask^.ActionCanceled();
			else
				pxTask^.ActionSucceeded();
			endif;
		endif;
		GetFSM()^.Enable(true);
		if(m_bRotateAction)then
			m_bRotateAction=false;
			return;
		endif;
		if(cast<CCharacter>(this)==null&&cast<CAnimal>(this)==null)then
			var bool bSetIdleAnim;
			var ^CTask pxCurTask=GetCurTask();
			if(pxCurTask!=null)then
				bSetIdleAnim=pxCurTask^.OnActionEnd(p_bBroken);
			endif;
			if(bSetIdleAnim&&!IsDead()&&m_fHitpoints>0.0f&&!IsFeignDeath()&&!m_bRotateSLEAction&&!IsGroupWalkPending())then
				SetIdleAnim();
			endif;
		endif;
	endproc;
	
	export proc void SetIdleAnim()
		if(HasAnim("standanim")&&GetCurrentAnimName()!="standanim")then
			SetAnim("standanim",3);
		endif;
	endproc;
	
	///////
	//	ctor
	///////
	constructor()
//		m_bGodMode=false;
		m_xCosts.m_iWood=0;
		m_xCosts.m_iStone=0;
		m_xCosts.m_iFood=0;
		m_xCosts.m_iSkulls=0;
		m_iLastDamage=-1;
//		m_iFinishingMoveIdx=-1;
		m_iInvulnerable=0;
		m_bFinished=false;
		m_bFeignDeath=false;
		m_aiEffectFlags=24;
		m_bInvisibleFlag=false;
		m_xWalkSet="def";
		if(CMirageSrvMgr.Get().NoHumpWalking())then
			m_xHumpWalkSet="def";
		else
			m_xHumpWalkSet="hump";
		endif;
		m_axBoni=NUM_BONUS_TYPES;
		m_pxWeaponMgr=new CWeaponMgr(this);
		SetDead(false);
		m_bDoingFinishingMove=false;
		m_bIsGettingFinished=false;
		m_bBLDGResBack=false;
		m_bSHIPResBack=false;
		m_sMyBuildAction="";
		m_pxTimeOnTick=new CTimerTick();
		m_pxTimeOnTick^.m_xOnTick=ProjectileOn;
		m_pxTimeOffTick=new CTimerTick();
		m_pxTimeOffTick^.m_xOnTick=ProjectileOff;
		m_bIsCheckInUnit=false;
		m_xPrimaryPoison.m_xOnTick=PoisonDamage;
		m_xPrimaryPoison.m_xOnDecay=DecayPoison;
		m_bScalpsGiven=false;
		m_pxPatrolInfo=null;
		m_iAttackType=0;
		m_xChangeTargetTime=CGameTime.GetInvalidTime();
		ResetHitDone();
		ms_fDurationFactor=1.0;
		m_fDurationFactor=1.0;
		m_fDefenseFactor=1.0f;
		m_fAttackFactor=1.0f;
	//========================================================================================
	//===New FightingObject member values defined in MIRAGE by Henry==========================
	//========================================================================================
		m_afDamagePortion=9;
		m_bDivideSkulls=CMirageSrvMgr.Get().DivideSkulls();
		m_bManaEnabled=CMirageSrvMgr.Get().ManaEnabled();
		m_bToBeDeleted=false;
		m_xPrimaryFire.m_xOnTick=BurnDamage;
		m_xPrimaryFire.m_xOnDecay=FireGoneOut;
		m_aiMirageFlags=32;
		m_bANMLResBack=false;
		m_bCHTRResBack=false;
		m_bVHCLResBack=false;
		m_fStrengthGrowing=1.0;
		m_fReplenishTime=0.0;
		m_fManaEatingTime=1.0;
		m_iSupplyCount=0;
		m_fTmpMeAttackBoni=0.0;
		m_fTmpRaAttackBoni=0.0;
		m_iKillerCount=0;
		m_iKillerHistory=0;
		m_bIncapacitated=false;
		m_bFountainHealed=false;
		m_bResurrectSafety=false;
		m_bPoisonImmunity=false;
		m_bIceImmunity=false;
		m_bAirWeapon=false;
		m_bFlyingUnit=false;
		m_bFreeHunting=false;
		m_bMirroring=false;
		m_bDemoteEffect=false;
		m_bPlayerRevealed=false;
		m_bSpiritCreated=false;
		m_bTamed=false;
		m_bPinnedDown=false;
		m_bShattered=false;
		m_bSundered=false;
		m_bBlinded=false;
		m_bDeafened=false;
		m_bMarkedForDeath=false;
		m_bCyborgBonus=false;
		m_bExplosiveRounds=false;
		m_bJetpack=false;
		m_bFirework=false;
		m_bCeaseFire=false;
		m_bUnboard=false;
		m_bFrozen=false;
		m_bStimpack=false;
		m_bStolen=false;
		m_bSuicide=false;
		m_bBloodInfect=false;
		m_bEvading=false;
		m_bAILock=false;
		m_bIsCamouflaged=false;
		m_bIsDead=false;
		m_bInvalidEnemy=false;
		m_bInvalidFighter=false;
		m_bNoHitReaction=false;
		m_bTitanDefense=false;
		m_bBrokenLegs=false;
		m_bWeaponRemoved=false;//Kr1s1m: initialized newly added boolean for weapon removal - by default unit is not disarmed
		m_bLocked=false;
		m_bThrowImmune=false;
		m_bDarkSwarm=false;
		m_bPBlocker=true;
		m_bLacered=false;
		m_iPQNEO=0;
		m_iPQNER=0;
		m_fMapWidth=(CSrvWrap.GetScapeMgr().GetMapWidth()-128).ToReal();
		m_fMapHeight=(CSrvWrap.GetScapeMgr().GetMapHeight()-128).ToReal();
		m_fWaterLevel=CSrvWrap.GetScapeMgr().GetSeaLevel();
//		m_xLethalWoundZero.m_iID=0;
//		m_xLethalWoundOne.m_iID=1;
//		m_xLethalWoundTwo.m_iID=2;
//		m_xLethalWoundThree.m_iID=3;
//		m_xLethalWoundFour.m_iID=4;
//		m_xLethalWoundFive.m_iID=5;
//		m_xLethalWoundSix.m_iID=6;
//		m_xLethalWoundSeven.m_iID=7;
//		m_xLethalWoundEight.m_iID=8;
		m_xLethalWoundZero.m_xOnTick=WoundDamage;
		m_xLethalWoundOne.m_xOnTick=WoundDamage;
		m_xLethalWoundTwo.m_xOnTick=WoundDamage;
		m_xLethalWoundThree.m_xOnTick=WoundDamage;
		m_xLethalWoundFour.m_xOnTick=WoundDamage;
		m_xLethalWoundFive.m_xOnTick=WoundDamage;
		m_xLethalWoundSix.m_xOnTick=WoundDamage;
		m_xLethalWoundSeven.m_xOnTick=WoundDamage;
		m_xLethalWoundEight.m_xOnTick=WoundDamage;
//		m_xLethalWoundZero.m_xOnDecay=LethalWoundCured;
//		m_xLethalWoundOne.m_xOnDecay=LethalWoundCured;
//		m_xLethalWoundTwo.m_xOnDecay=LethalWoundCured;
//		m_xLethalWoundThree.m_xOnDecay=LethalWoundCured;
//		m_xLethalWoundFour.m_xOnDecay=LethalWoundCured;
//		m_xLethalWoundFive.m_xOnDecay=LethalWoundCured;
//		m_xLethalWoundSix.m_xOnDecay=LethalWoundCured;
//		m_xLethalWoundSeven.m_xOnDecay=LethalWoundCured;
//		m_xLethalWoundEight.m_xOnDecay=LethalWoundCured;
		m_fMaxDef=0.99;
		m_sPerRegName="";
		m_sObjFlag="";
		m_bCostsFromAction=false;
		m_bCanTame=false;
		m_bResurrecting=false;
		m_bAI=false;
		m_bPassingAway=false;
		m_bHidingEnemy=false;
		m_bUniqueMask=false;
		m_bSlaveInvincible=false;
		m_sStandardDesc="";
		m_bOnTheGround=false;
		m_bHPReachedZero=false;
		m_bGameOverKill=false;
		m_bNoCorpse=false;
		m_bThrowDisabled=!CMirageSrvMgr.Get().AllowThrow();
		m_bExcludeBuildUp=CMirageSrvMgr.Get().ExcludeBuildUp();
		m_bAttackInFOW=CMirageSrvMgr.Get().AttackInFOW();
		m_bTechtreeSteal=CMirageSrvMgr.Get().TechtreeSteal();
		m_bAuraSharing=CMirageSrvMgr.Get().AuraSharing();
		m_bDefFirstInit=false;
		m_bTurtleOnLand=false;
		m_bBiological=false;
		m_bMeleePenetrate=false;
		m_fHealingBoniAbs=0.0;
		m_fHealingBoniRel=1.0;
//		m_bSystem=false;
//		CMirageSrvMgr.Debug("constructing: '"+GetName()+"'");
	endconstructor;
	
	///////
	//	dtor
	///////
	destructor()
		m_axDmgTimer=0;
		delete m_pxWeaponMgr;
		delete m_pxTimeOnTick;
		delete m_pxTimeOffTick;
		//delete m_pxTaskMgr;
		delete m_pxPatrolInfo;
		if(HasTimer(TIMER_FINISHINGMOVE))then
			DeleteTimer(TIMER_FINISHINGMOVE);
		endif;
		while(m_axToDoList.NumEntries()>0)do
			m_axToDoList.DeleteEntry(0);
		endwhile;
/*
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel!=null)then
			var ^CPlayer pxPlayer=pxLevel^.GetPlayer(GetOwner());
			if(pxPlayer!=null)then
				pxPlayer^.SendPlayerLostUnitEvent(GetType(),GetClassName());
			endif;
		endif;
*/
	enddestructor;
	
	export proc ^CWeaponMgr GetWeaponMgr()
		return m_pxWeaponMgr;
	endproc;
	
	///////
	//	HandleHealing()
	///////
	export proc void HandleHealing()
	endproc;
	
	export proc void SetGroup(CObjHndl p_xGroup)
		m_xGroup=p_xGroup;
	endproc;
	
	export proc CObjHndl GetGroup()
		return m_xGroup;
	endproc;
	
	//transportclass:
	//0 - 1 rider only
	//1 - 1 rider and infantry
	//2 - 1 rider and any unit except sizeclass 2
	export proc void SetTransportClass(int p_iSize)
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null&&pxAttr^.GetValueInt("transportclass")!=p_iSize)then
			pxAttr^.SetValue("transportclass",p_iSize);
		endif;
	endproc;
	
	export proc real GetLongRangeFireDelay()
		return 1.0f;
	endproc;
	
	export proc real GetLongRangeFireSpeed()
		return 30.0f;
	endproc;
	
	export proc real GetLongRangeFireFalloff()
		return -10.0f;
	endproc;
	
	export proc bool IsFeignDeath()
		return m_bFeignDeath;
	endproc;
	
	export proc void SetFeignDeath(bool p_bDeath)
		m_bFeignDeath=p_bDeath;
		CheckEnemyHiding();
		CheckFighterValidity();
	endproc;
	
	export proc ref int GetInvulnerable()
		return m_iInvulnerable;
	endproc;
	
	export proc void SetInvulnerable(int p_iInvulnerable)
		m_iInvulnerable=p_iInvulnerable;
	endproc;
	
	export proc void SetLDInvulnerable(bool p_bValue)
		m_bLDInvulnerable=p_bValue;
	endproc;
	
	export proc bool GetLDInvulnerable()
		return m_bLDInvulnerable;
	endproc;
	
	export proc void StartANMLImmunityTimer()
		//Badgun Tuning: Warden Special Move
		var real fTime=10.0; //Henry: to boost Wardens t3 special ability (more duration)
		DeleteTimer(TIMER_ANML_IMMUNITY);
		CreateTimer(TIMER_ANML_IMMUNITY,CGameTimeSpan.OneSecond()*fTime,false);
	endproc;
	
	export proc ref bool GetFinished()
		return m_bFinished;
	endproc;
	
	export proc void SetFinished(bool p_bFinished)
		m_bFinished=p_bFinished;
	endproc;
	
	export proc bool DoesAreaDamage()
		var real fHitrange=m_xTechTree.GetValueR(GetCurrentWeapon()+"/hitrange", 0.0f);
		return fHitrange > 0.0f;
	endproc;
	
	export proc void SetGettingFinished(bool p_bValue)
		m_bIsGettingFinished=p_bValue;
		if(!p_bValue)then
			DeleteTimer(TIMER_FINISHINGMOVE);
			SetDead(false);
		endif;
		CheckEnemyValidity();
		CheckFighterValidity();
		if(p_bValue&&!HasTimer(TIMER_FINISHINGMOVE))then
			CreateTimer(TIMER_FINISHINGMOVE,CGameTimeSpan.OneSecond() * 0.5, false);
		endif;
	endproc;
	
	export proc void SetTrappedGfx(string p_sClass, real p_fDuration)
		var ^CLifeTimeObj pxObj=cast<CLifeTimeObj>(CSrvWrap.GetObjMgr()^.CreateObj("trapped_effect",GetOwner(),GetPos()));
		if(pxObj!=null)then
			var int iFrame=(Math.Clamp(GetCollisionRadius()/5.0,0.0,1.0)).ToInt();
			pxObj^.SetGFX(p_sClass);
			if(pxObj^.HasAnim("grow"))then
				pxObj^.SetAnim("grow",0,iFrame);
			endif;
//			if(pxObj^.HasAnim("grow"))then
//				pxObj^.InvokeGenericSCEvent(11,1.0f);
//			endif;
			var CFourCC xLink="NOPE";
			pxObj^.LinkAction(GetHandle(),xLink);
			pxObj^.SetKillTimer(p_fDuration, GetHandle());
		endif;
	endproc;
	
	///////
	//	SetTrapped()
	///////
	export proc void SetTrappedHandle(CObjHndl p_xTrapHndl)
		var bool bObjectTrap=p_xTrapHndl.IsValid();
		if(bObjectTrap)then
//			TerminateAction();
			var ^CTrapped pxTask=cast<CTrapped>(FindTaskByName("Trapped",false));
			if(pxTask!=null)then
				if(pxTask^.AddTrapObject(p_xTrapHndl))then
					m_bObjectTrap=true;
				endif;
				return;
			endif;
			pxTask= cast<CTrapped>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(), "Trapped"));
			if(pxTask==null)then return; endif;
			if(!pxTask^.Init(GetHandle(), p_xTrapHndl))then
				m_xTrap=CObjHndl.Invalid();
				m_bObjectTrap=false;
				pxTask^.GetFactory()^.FreeState(pxTask);
				return;
			else
				m_bObjectTrap=true;
				m_xTrap=p_xTrapHndl;
				TerminateAction();
			endif;
			pxTask^.SetUserCommand(false);
			var ^CFinishingMove pxMove=cast<CFinishingMove>(GetCurTask());
			if(pxMove!=null)then
				pxMove^.EndTask();
			endif;
			SetTaskImmediate(pxTask);
//		else
//			TerminateAction();
		endif;
	endproc;
	
	export proc void SetTrappedBool(bool p_bTrapped)
//		m_bIsTrapped=p_bTrapped;
		if(p_bTrapped)then
//			var ^CTrapped pxTask=cast<CTrapped>(GetCurTask());
			var ^CTrapped pxTask=cast<CTrapped>(FindTaskByName("Trapped",false));
			if(pxTask!=null)then
				if(pxTask^.SetSelfTrapped())then
					m_bIsTrapped=true;
				endif;
				return;
			endif;
			pxTask= cast<CTrapped>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(), "Trapped"));
			if(pxTask==null)then return; endif;
			if(!pxTask^.Init(GetHandle(), GetHandle()))then
				pxTask^.GetFactory()^.FreeState(pxTask);
				return;
			else
				m_bIsTrapped=true;
				TerminateAction();
			endif;
			pxTask^.SetUserCommand(false);
			var ^CFinishingMove pxMove=cast<CFinishingMove>(GetCurTask());
			if(pxMove!=null)then
				pxMove^.EndTask();
			endif;
			SetTaskImmediate(pxTask);
		else
			m_bIsTrapped=false;
			TerminateAction();
		endif;
	endproc;
	
	export proc void SetTrappedTime(real p_fDuration)
//		var ^CTrapped pxTask=cast<CTrapped>(GetCurTask());
		var ^CTrapped pxTask=cast<CTrapped>(FindTaskByName("Trapped",false));
		if(pxTask!=null)then
			if(pxTask^.AddTimedTrapEffect(p_fDuration))then
				m_bTimeTrap=true;
			endif;
			return;
		endif;
		if(p_fDuration>0.0f)then
			var ^CTrapped pxTask= cast<CTrapped>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(), "Trapped"));
			if(pxTask==null)then return; endif;
			pxTask^.Init(GetHandle(), p_fDuration);
			if(!pxTask^.Init(GetHandle(), p_fDuration))then
				pxTask^.GetFactory()^.FreeState(pxTask);
//				m_bTimeTrap=false;
				return;
			else
				m_bTimeTrap=true;
				TerminateAction();
			endif;
			pxTask^.SetUserCommand(false);
			var ^CFinishingMove pxMove=cast<CFinishingMove>(GetCurTask());
			if(pxMove!=null)then
				pxMove^.EndTask();
			endif;
			SetTaskImmediate(pxTask);
		endif;
	endproc;
	
	export proc void SetDundeed(real p_fDuration)
		DeleteTimer(TIMER_DUNDEED);
		if(p_fDuration>0.0)then
			m_bIsTrapped = true;
			CreateTimer(TIMER_DUNDEED,CGameTimeSpan.OneSecond() * p_fDuration, false);
		else
			m_bIsTrapped = false;
		endif;
	endproc;
	
	export proc void StartPatrol(ref array vec3 p_ravWaypoints,int p_iPatrolMode, int p_iSpeed)
		if(m_xTransportObj.IsValid())then return; endif;
		StartPatrol(p_ravWaypoints, p_iPatrolMode, p_iSpeed, false);
	endproc;
	
	export proc void StartPatrol(ref array vec3 p_ravWaypoints,int p_iPatrolMode, int p_iSpeed, bool p_bStraightWalk)
		m_bStoppingPatrol=false;
		m_bStraightWalkPatrol=p_bStraightWalk;
		var int iLastIdx,iCurIdx;
		if(m_pxPatrolInfo!=null)then
			iLastIdx=m_pxPatrolInfo^.m_iLastIdx;
			iCurIdx=m_pxPatrolInfo^.m_iCurIdx;
		endif;
		delete m_pxPatrolInfo;
		m_pxPatrolInfo=new CPatrolInfo(p_ravWaypoints,p_iPatrolMode,p_iSpeed);
		m_pxPatrolInfo^.m_iLastIdx=iLastIdx;
		m_pxPatrolInfo^.m_iCurIdx=iCurIdx;
		CPDF();
	endproc;
	
	export proc void AddPatrolPoint(vec3 p_vPos, int p_iSpeed)
		var array vec3 avPos;
		if(m_pxPatrolInfo!=null)then
			avPos=m_pxPatrolInfo^.m_avWaypoints;
		endif;
		var int iMode=2;
		var int iNum=avPos.NumEntries();
		if(iNum>0)then
			if((avPos[iNum-1]-p_vPos).AbsSquare()<25.0)then
				avPos[iNum-1]=p_vPos;
			elseif((avPos[0]-p_vPos).AbsSquare()<36.0)then
				iMode=1;
				avPos[0]=p_vPos;
			else
				avPos.AddEntry(p_vPos);
			endif;
		else
			var vec3 vCurPos=GetCurWalkTarget();
			if(vCurPos=={0.0,0.0,0.0})then
				vCurPos=GetPos();
			endif;
			if(m_bFlyingUnit)then
				vCurPos.SetZ(Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vCurPos.GetX(),vCurPos.GetY()),m_fWaterLevel));
			endif;
			avPos.AddEntry(vCurPos);
			avPos.AddEntry(p_vPos);
		endif;
		StartPatrol(avPos,iMode,p_iSpeed);
	endproc;
	
	export proc void StopPatrol()
		if(m_bStoppingPatrol==true)then return; endif; //prevent endless recursion
		m_bStoppingPatrol=true;
		Notify("Notify=LastWaypoint");
		delete m_pxPatrolInfo;
		m_pxPatrolInfo=null;
		UpdatePatrolTargetAttribs();
	endproc;
	
	export proc void Dump(string p_sString)
		if(GetClassName()=="aje_ankylosaurus")then
			//KLog.LogSpam("JaNe",GetName()+" "+p_sString);
		endif;
	endproc;
	
	export proc void CheckPatrol()
		if(!CanWalk()&&!CanSwim()&&!CanFly())then return; endif;
		var bool bFly=true;
		if(m_pxPatrolInfo==null)then
			if(m_vAggressionPos.AbsSquare()<1.0||GetOnWall())then
				Flight();
				return;
			endif;
			var real fSqDist=(GetPos()-m_vAggressionPos).AbsSquare();
			var real fSqRadius=GetCollisionRadius();
			fSqRadius*=fSqRadius;
			if(fSqDist>=(fSqRadius*1.5))then
				var array vec3 avPos; avPos.AddEntry(m_vAggressionPos);
				bFly=false;
				StartPatrol(avPos,0,GetDefaultSpeed());
			endif;
		endif;
		if(m_pxPatrolInfo!=null)then
			bFly=false;
			var ^vec3 pvNextPoint=m_pxPatrolInfo^.GetNextWaypoint(GetPos());
			if(pvNextPoint==null)then
				if(m_pxPatrolInfo^.m_iMode==0)then
					StopPatrol();
				else
					//endless patrol mode
					return;
				endif;
			else
				m_bAggressionWalk=(m_bStraightWalkPatrol==false);
				UpdateAggressionPos(pvNextPoint^);
				m_bPatrolWalk=true;
				GoTo(pvNextPoint^, false, m_pxPatrolInfo^.GetSpeed(), true, true);
				return;
			endif;
		endif;
		if(m_bMovableInFight&&Random.GetInt()%50==13&&!HasWalkAction())then
			var bool bUnitCollision=CheckUnitCollision();
			//KLog.LogWarn("CHP","CP:"+GetName()+" "+bUnitCollision.ToString());
			if(bUnitCollision)then
				var real fD=Random.MTRandF(Math.Pi()*2.0f);
				var vec3 vO;vO.SetXYZ(Math.Sin(fD),Math.Cos(fD),0.0f);
				GoTo(GetPos()+vO,false,GetDefaultSpeed(),true,false);
				bFly=false;
			endif;
		endif;
		if(bFly)then
			Flight();
		endif;
	endproc;
	
	///////
	//	IsTrapped()
	///////
	export proc bool IsTrapped()
//		return m_xTrap.IsValid() && m_bIsTrapped;
		return m_bTimeTrap || m_bObjectTrap || m_bIsTrapped;
	endproc;
	
	export proc CObjHndl GetTrapHandle()
		return m_xTrap;
	endproc;
	
	export proc void SetTaskImmediate(^CTask p_pxTask)
		if(m_pxTaskMgr!=null)then
			m_pxTaskMgr^.SetTaskImmediate(p_pxTask);
		endif;
	endproc;
	
	export proc void AddNextTask(^CTask p_pxTask)
		if(m_pxTaskMgr!=null)then
			m_pxTaskMgr^.AddNextTask(p_pxTask);
		endif;
	endproc;
	
	export proc void AddTask(^CTask p_pxTask,bool p_bQueue)
		if(p_pxTask^.IsUserCommand())then
			AnnounceState(p_pxTask^.GetName());
			var ^CFight pxFight=cast<CFight>(p_pxTask);
			if(pxFight==null||!pxFight^.GetNoUserBerserkerMode())then
				StopPatrol();
			endif;
		endif;
		if(m_pxTaskMgr!=null)then
			if(p_bQueue)then
				m_pxTaskMgr^.AddTask(p_pxTask);
			else
				m_pxTaskMgr^.SetTask(p_pxTask);
			endif;
		endif;
	endproc;
	
	export proc void BreakEveryTask()
		AnnounceState("");
		if(m_pxTaskMgr!=null)then
			m_pxTaskMgr^.BreakAll();
		endif;
	endproc;
	
	export proc void BreakCurrentTask()
//		AnnounceState("");
		if(m_pxTaskMgr!=null)then
			m_pxTaskMgr^.BreakCurrent();
		endif;
	endproc;
	
	///////
	//	HandleEvent()
	///////
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==CActFlight.ms_xAttackEvt)then
			// Henry: do nothing
		elseif(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(UpdateSpecialActions(iTimerID))then
				ReWriteActionAttribs();
			elseif(iTimerID==TIMER_MAMMOTH_TRUMPET )then
				DeleteTimer(TIMER_MAMMOTH_TRUMPET);
				SetEffectFlag(EFFECT_MAMMOTH_TRUMPET, false);
				ForceBoniUpdate();
			elseif(iTimerID==TIMER_TRICERATOPS_PAW )then
				DeleteTimer(TIMER_TRICERATOPS_PAW);
				SetEffectFlag(EFFECT_TRICERATOPS_PAW, false);
			elseif(iTimerID==TIMER_PREAGGRO )then
				PreCheckForEnemies();
			elseif(iTimerID==TIMER_AGGRO )then
				ExamineEnemies(false, GetAggressionState()!=1 && GetAggressionState()!=-1 && GetAggressionState()!=3 && GetAggressionState()!=4);
			elseif(iTimerID==TIMER_FLAGS )then
				HandleHealing();
//				ExamineFlags();
			elseif(iTimerID==TIMER_FLAGS2 )then
//				HandleHealing();
				ExamineFlags();
			elseif(iTimerID==TIMER_GETHITREACTION )then
				DeleteTimer(TIMER_GETHITREACTION);
				DoGetHitReaction();
			elseif(iTimerID==TIMER_ALARM )then
				if(GetCurTaskName()!="Fight")then
					ExamineEnemies(true, GetAggressionState()!=1 && GetAggressionState()!=-1 && GetAggressionState()!=3 && GetAggressionState()!=4);
				endif;
			elseif(iTimerID==TIMER_INVUL )then
				DeleteTimer(TIMER_INVUL);
				SetLDInvulnerable(false);
			elseif(iTimerID==TIMER_WEAPON_REMOVE )then
				DeleteTimer(TIMER_WEAPON_REMOVE);
				RemoveAllWeapons(false); //Kr1s1m: After the timer has finished, the WeaponRemove effect is reversed
			elseif(iTimerID==TIMER_STONED)then
				DeleteTimer(TIMER_STONED);
				SetEffectFlag(EFFECT_ITEM_STONED, false);
			elseif(iTimerID==TIMER_FROST)then
				DeleteTimer(TIMER_FROST);
				SetIcedFlag(false);
				SetFroozenEffect(false);
			elseif(iTimerID==TIMER_FROSTIMMUNITY)then
				DeleteTimer(TIMER_FROSTIMMUNITY);
				SetIcedFlag(false); //Henry: to prevent bugs like zz' bufficon won't disappear etc xD
				SetFroozenEffect(false);
			elseif(iTimerID==TIMER_EXPLOSION)then
				DeleteTimer(TIMER_EXPLOSION);
				Delete();
			elseif(iTimerID==TIMER_DUNDEED)then
				DeleteTimer(TIMER_DUNDEED);
				SetDundeed(-1.0);
			elseif(iTimerID==TIMER_FINISHINGMOVE)then
				DeleteTimer(TIMER_FINISHINGMOVE);
				SetDead(false);
//				SetDyingInTPO(GetTransportObj().IsValid());
				m_bPassingAway=GetTransportObj().IsValid();
				Die();
			elseif(iTimerID==TIMER_ANML_IMMUNITY)then
				DeleteTimer(TIMER_ANML_IMMUNITY);
			elseif(iTimerID==TIMER_HELPSHOUT)then
				DeleteTimer(TIMER_HELPSHOUT);
				if(GetHealingRadius()>0.0)then
					var ^CCharacter pxChar=cast<CCharacter>(this);
					if(pxChar!=null)then
						if(pxChar^.SomeoneToHeal(false))then
							TerminateAction();
							pxChar^.HealUnits(false);
						endif;
					endif;
				else
					AddEnemy(m_xHelpShoutEnemy, m_bHelpShoutDefend);
				endif;
				m_bHelpShoutDefend=false;
				m_xHelpShoutEnemy=CObjHndl.Invalid();
			elseif(iTimerID==CAMO_TIMER)then
				DeleteTimer(CAMO_TIMER);
				if(m_bIntendedCamouflage)then
					m_bIntendedCamouflage=false;
					AddCamouflageEffect("disg");
					UpdateCamouflageLayers();
				endif;
			elseif(iTimerID==TIMER_LEVELUP_INV)then
				DeleteTimer(TIMER_LEVELUP_INV);
				m_bLevelUpInvulnerable=false;
			elseif(iTimerID==TIMER_ISGETTINGHEALED)then
				DeleteTimer(TIMER_ISGETTINGHEALED);
				RemoveRangedBuff("is_getting_healed");
			elseif(iTimerID==TIMER_ISGETTINGHEALED_FX)then
				DeleteTimer(TIMER_ISGETTINGHEALED_FX);
				RemoveFX("fx_heal_passive");
			elseif(iTimerID==TIMER_SELFHEAL)then
				HealMe(m_fSelfHealAmount);
	
	//========================================================================================
	//===New FightingObject timers in MIRAGE by Henry=========================================
	//========================================================================================
	
			elseif(iTimerID==TIMER_INFORM_ME)then //Henry: to give any type of information using feedbacks (no real use)
//				CFeedback.Print(GetOwner(), CFeedback.ATTACK, InformHenry(), GetPos());
//				Damage(999999.0);
				CFeedback.Print(4, CFeedback.ATTACK, InformHenry(), GetPos());
			elseif(iTimerID==TIMER_GOT_STOLEN)then //remove mark from newly tamed animals
				m_bStolen=false;
			elseif(iTimerID==TIMER_NO_HEALING)then //removes no healing mark from units damaged by aje thrower
				SetBloodInfection(false, 0.0);
			elseif(iTimerID==TIMER_PINNED_DOWN)then //removes slowdown mark from units
				SetPinnedDown(false,0.0f);
			elseif(iTimerID==TIMER_BROKEN_LEGS)then //removes slowdown mark from units
				SetBrokenLegs(false,0.0f);
			elseif(iTimerID==TIMER_SPEED_RUN)then //removes bonus speed from seismo
				SetSpeedRun(false,0.0f,CSeismosaurus.SPEED_RUN_PATH);
			elseif(iTimerID==TIMER_INCAPACITATED)then //removes incapacitation mark, fx and zz' bufficon from buildings affected by aje rammers ability
				DeleteTimer(TIMER_INCAPACITATED);
				SetIncapacitated(false);
//				m_bIncapacitated=false;
				RemoveFX("building_incapacitation_fx");
				RemoveRangedBuff("is_held");
			elseif(iTimerID==TIMER_SANCTIFICATION)then //calls the selfheal procedure for wild animals to heal them a little bit (animals in nature should have a regenerative ability, not just stay all day long injured (and not only by eating!...)) ;D
				DeleteTimer(TIMER_SANCTIFICATION);
				CureMe(m_fCuringAmount);
				if(!HasFullHP())then
					CreateTimer(TIMER_SANCTIFICATION, CGameTimeSpan.OneSecond() * 1.0, false);
				endif;
			elseif(iTimerID==TIMER_REGENERATING)then
				RegenMe(m_fSelfRegenerating);
			elseif(iTimerID==REPLENISH_TIMER)then //automatically restores a certain amount of spellcasters mana 
				Replenish(GetReplenishAmount());
			elseif(iTimerID==TIMER_START_RESIST)then //starts the immunity time, during which the unit can't be freezed (by ice spearman, Tarna, Liopleurodon)
				DeleteTimer(TIMER_START_RESIST);
				StartIceImmunity();
			elseif(iTimerID==TIMER_WALKING_BOMB)then //Henry: makes the choosen one explode... ;)
				MakeThemPay();
			elseif(iTimerID==TIMER_FOUNTAIN_HEALED)then //Henry: makes unit vulnerable again
				DeleteTimer(TIMER_FOUNTAIN_HEALED);
				m_bFountainHealed=false;
			elseif(iTimerID==TIMER_RESURRECT_SAFETY)then //Henry: makes shaman vulnerable again
				DeleteTimer(TIMER_RESURRECT_SAFETY);
				m_bResurrectSafety=false;
			elseif(iTimerID==RALLY_ROAR)then
				SetCyborgEffect(false,0.0);
			elseif(iTimerID==ID_EXPLOSIVES_ROUNDS)then
				Damage(15.0f);
				m_iLastDamage=GetOwner();
//				new CAreaDamage(10.0f,100.0f,50.0f,GetOwner(),GetPos(),"RYNO");
				new CAreaDamage(10.0f,100.0f,50.0f,GetOwner(),GetPos());
			elseif(iTimerID==MARKED_FOR_DEATH)then //Henry: removes ranged defense malus from victim
				SetMarkedForDeath(false,0.0);
			elseif(iTimerID==TIMER_FIREWORK)then //Henry: to restore smoke effect if necessary
//				if(m_bPlayerRevealed&&GetType()!="BLDG")then return; endif;
				SetFireworkEffect(false,0.0);
			elseif(iTimerID==CEASE_FIRE)then //Henry: to allow fighting again
				SetPeaceTime(false,0.0);
			elseif(iTimerID==UNBOARD_CURSE)then //Henry: to allow boarding again
				SetUnboard(false,0.0);
			elseif(iTimerID==TIMER_SUNDERED)then
				SetSundered(false, 0.0);
			elseif(iTimerID==TIMER_SHATTERED)then
				SetShattered(false, 0.0);
			elseif(iTimerID==TIMER_LACERED)then
				SetLacerated(false, 0.0);
			elseif(iTimerID==TIMER_BLINDNESS)then
				SetBlinded(false, 0.0);
			elseif(iTimerID==TIMER_DEAFENED)then
				SetDeafened(false, 0.0);
			elseif(iTimerID==TIMER_MIRRORING)then
				m_bMirroring=false;
			elseif(iTimerID==DEFENSE_SHAKE)then
				SetTitanDefense(false,0.0);
			elseif(iTimerID==TIMER_MOTIVATED)then
				var ^CBoniBucket pxBBDef=GetBoniBucket(CFightingObj.BONUS_DEFENSE), pxBBRangeDef=GetBoniBucket(CFightingObj.BONUS_RANGEDDEFENSE), pxBBAtk=GetBoniBucket(CFightingObj.BONUS_DAMAGE);
				if(pxBBDef!=null)then
					pxBBDef^.RemEntry("motivate_def");
				endif;
				if(pxBBRangeDef!=null)then
					pxBBRangeDef^.RemEntry("motivate_rdef");
				endif;
				if(pxBBAtk!=null)then
					pxBBAtk^.RemEntry("motivate_atk");
				endif;
				ForceBoniUpdate();
				UpdateWeaponBoni();
				UpdateRangeNDamageInformation();
			elseif(iTimerID==TIMER_DEMOTE)then
//				m_bDemoteEffect=false;
				SetDemoteEffect(false,0.0);
			elseif(iTimerID==TIMER_BONDS)then
				m_xBonds.Clear();
			elseif(iTimerID==TIMER_ISGETTINGCORRUPTED)then
				DeleteTimer(TIMER_ISGETTINGCORRUPTED);
				RemoveRangedBuff("is_getting_corrupted");
			elseif(iTimerID==TIMER_ISGETTINGCORRUPTED_FX)then
				DeleteTimer(TIMER_ISGETTINGCORRUPTED_FX);
				RemoveFX("Downgrade_Animal_Fx");
			elseif(iTimerID==TIMER_INTIMIDATED)then
				DeleteTimer(TIMER_INTIMIDATED);
				m_xIntimidate=CObjHndl.Invalid();
			elseif(iTimerID==TIMER_ISGETTINGREGENED)then
				DeleteTimer(TIMER_ISGETTINGREGENED);
				RemoveRangedBuff("is_getting_healed");
			elseif(iTimerID==TIMER_FRIGHTENING)then
				DeleteTimer(TIMER_FRIGHTENING);
				ActivateCustomFilterAndUpdate(false,CNinigiTriceratops.FRIGHTENING_PATH);
				RemoveRangedBuff("lower_fighting_rate");
			elseif(iTimerID==TIMER_VALOR)then
				DeleteTimer(TIMER_VALOR);
				ActivateCustomFilterAndUpdate(false,CParasaurolophus.VALOR_PATH);
				RemoveRangedBuff("higher_fighting_rate");
			elseif(iTimerID==RALLY_TRUMP)then
				DeleteTimer(RALLY_TRUMP);
				ActivateCustomFilterAndUpdate(false,CMammoth.RALLY_PATH);
				RemoveRangedBuff("higher_fighting_freq");
			elseif(iTimerID==TIMER_GET_UP)then
				DeleteTimer(TIMER_GET_UP);
				m_bOnTheGround=false;
			elseif(iTimerID==TIMERID_THROWIMMUNE)then //Henry: to make unit throwable again
				m_bThrowImmune=false;
			elseif(iTimerID==TIMER_SEDATED)then
				SetSedated(false,0.0);
			elseif(iTimerID==FINISHING_MODE)then
				m_bDoingFinishingMove=false;
			elseif(iTimerID==TIMER_HERE_I_AM)then
				HereIAm();
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		elseif(p_rxEvtPtr.GetClass()=="Fight")then
			m_bIsHelpShout=true;
			if(!HasTimer(TIMER_HELPSHOUT))then
				var CObjHndl xEnemy=p_rxEvtPtr.GetObjHandle(0);
				if(GetAggressionState()!=-1 && GetAggressionState()!=3 && GetAggressionState()!=4 && xEnemy.IsValid() && xEnemy.GetObj()^.GetOwner()!=GetOwner() && !GetCamouflage() && GetClassName().Find("_worker")==-1)then
					CreateTimer(TIMER_HELPSHOUT, CGameTimeSpan.OneSecond()*0.1, false);
					m_bHelpShoutDefend=p_rxEvtPtr.GetBool(1);
					m_xHelpShoutEnemy=xEnemy;
				endif;
			endif;
		elseif(p_rxEvtPtr.GetClass()=="CTheLite")then
			var ^CTheLite pxTask=cast<CTheLite>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"CTheLite"));
			if(pxTask==null)then return; endif;
			if(pxTask^.Init(GetHandle(), p_rxEvtPtr.GetObjHandle(0)))then
				pxTask^.SetUserCommand(true);
				AddTask(pxTask,true);
			else
				pxTask^.GetFactory()^.FreeState(pxTask);
			endif;
		elseif(p_rxEvtPtr.GetClass()=="FrstStrk")then
			OnDoFirstStrike(p_rxEvtPtr.GetFloat(0));
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	export proc void OnDoFirstStrike(real p_fTimeToHit)
		//Warning! this Event is send synchronously, from inside the AdvanceAction
		//so don't break it
		//var CGameTime xHitTime=CTimeMgr.Get().GetTime()+CGameTimeSpan.OneSecond()*(p_fTimeToHit);
		//damage must be invoked at xHitTime
		//KLog.LogWarn("CHP","OnDoFirstStrike "+p_fTimeToHit.ToString());
		if(m_pxTaskMgr!=null)then
			var ^CFight pxFightTask=cast<CFight>(m_pxTaskMgr^.GetCurTask());
			if(pxFightTask!=null)then
				var ^CFightingObj pxEnemy=cast<CFightingObj>(pxFightTask^.GetEnemy().GetObj());
				if(pxEnemy!=null)then
					if(m_xTechTree.GetValueI(GetObjPath()+"/fsm",0)==1)then
						CreateProjectileAndShoot(pxEnemy, pxEnemy^.GetPos());
					else
						pxEnemy^.TakeDmg(this,false,1.5,p_fTimeToHit);
					endif;
					//KLog.LogWarn("CHP","OnDoFirstStrike --> Hit!!!!!!!!!!!!");
				endif;
				pxFightTask^.ResetFollowTimer();
			endif;
		endif;
	endproc;
	
	export proc void UpdateDeliveries()
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr==null)then return; endif;
		var array string asRes;
		asRes.AddEntry("food");
		asRes.AddEntry("wood");
		asRes.AddEntry("stone");
		asRes.AddEntry("iron");
		asRes.AddEntry("resin");
		asRes.AddEntry("hide");
		asRes.AddEntry("bone");
		m_bIsCheckInUnit=false;
		var ^CTechTree.CNode pxObjNode=m_xTechTree.FindNode(GetObjPath()+"/delivery");
		var bool bValid=pxObjNode!=null;
		var int i, iC=asRes.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(bValid)then
				var ^CTechTree.CNode pxNode=pxObjNode^.GetSub(asRes[i]);
				if(pxNode!=null&&pxObjNode^.GetSubValueB(asRes[i]))then
					pxAttr^.SetValue(asRes[i]+"Delivery",true);
					m_bIsCheckInUnit=true;
				else
					pxAttr^.SetValue(asRes[i]+"Delivery",false);
				endif;
			else
				pxAttr^.SetValue(asRes[i]+"Delivery",false);
			endif;
		endfor;
	endproc;
	
	//mainly for CBuilding but maybe for Aje_Resource_Collector etc. too
	export proc void AcceptDeliveries()
		if(!m_bIsCheckInUnit)then return; endif;
		if(!HasAnim("deliver"))then return; endif;
		if(m_pxTaskMgr==null)then return; endif;
		var ^CTask pxTask=m_pxTaskMgr^.GetCurTask();
		var ^CAcceptDeliveries pxAccept;
		if(pxTask!=null)then
			pxAccept=cast<CAcceptDeliveries>(pxTask);
			if(pxAccept==null)then return; endif;
		endif;
		if(pxAccept==null)then
			pxAccept=cast<CAcceptDeliveries>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"AcceptDe"));
			if(pxAccept==null)then return; endif;
			var bool bR=pxAccept^.Init(GetHandle());
			if(bR)then
				AddTask(pxAccept,false);
			else
				pxAccept^.GetFactory()^.FreeState(pxAccept);
			endif;
		else
			pxAccept^.AddAnimLoop();
		endif;
	endproc;
	
	///////
	//	OnGetFormationInfoAttackRange()
	///////
	export proc real OnGetFormationInfoAttackRange()
		return GetAttackRange();
	endproc;
	
	///////
	//	OnGetFormationInfoHitpoints()
	///////
	export proc real OnGetFormationInfoHitpoints()
		return m_fHitpoints;
	endproc;
	
	///////
	//	OnGetFormationInfoSpeed()
	///////
	export proc real OnGetFormationInfoSpeed()
		return GetMaxSpeed().ToReal();
	endproc;
	
	///////
	//	GetCurEnemy()
	///////
	export proc CObjHndl GetCurEnemy()
		return m_xCurEnemy;
	endproc;
	
	///////
	//	SetCurEnemy()
	///////
	export proc void SetCurEnemy(CObjHndl p_xHndl)
		m_xCurEnemy=p_xHndl;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			if(p_xHndl.IsValid())then
				pxAttr^.SetValue("CurEnemy",p_xHndl.AsInt());
			else
				pxAttr^.SetValue("CurEnemy",-1);
			endif;
		endif;
		m_xHelpDefendEnemies.Clear();
		m_xHelpAttackEnemies.Clear();
	endproc;
	
	export proc void ReturnToFight()
		if(m_pxTaskMgr==null)then return; endif;
		var ^CTask pxTask=m_pxTaskMgr^.GetCurTask();
		if(pxTask!=null)then
			pxTask^.EndTask();
		endif;
		InvokeFightTask(CObjHndl.Invalid(), m_vAggressionPos, m_bReturnUserCommand, false, m_bReturnNoUserBerserkerMode);
	endproc;
	
	export proc void MemorizeCurrentFightState(CObjHndl p_xCurEnemy, bool p_bUserCommand, bool p_bNoUserBerserkerMode)
		if(IsInFight())then
			if(m_pxTaskMgr!=null)then
				var ^CFight pxTask=cast<CFight>(m_pxTaskMgr^.GetCurTask());
				if(pxTask!=null)then
					m_bReturnUserCommand=pxTask^.IsUserCommand();
					m_bReturnNoUserBerserkerMode=pxTask^.GetNoUserBerserkerMode();
					m_xReturnEnemy=m_xCurEnemy;
				endif;
			endif;
		elseif(p_xCurEnemy.IsValid())then
			m_bReturnUserCommand=p_bUserCommand;
			m_bReturnNoUserBerserkerMode=p_bNoUserBerserkerMode;
			m_xReturnEnemy=p_xCurEnemy;
		else
			m_bReturnUserCommand=true;
			m_bReturnNoUserBerserkerMode=false;
			m_xReturnEnemy.FromInt(-1);
		endif;
	endproc;
	
	export proc void SetFollowFailed(bool p_bFailed)
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("FollowFailed",p_bFailed);
		endif;
	endproc;
	
	export proc bool InvalidateTechTree()
		if(m_xProduceUnit.IsValid())then
			var ^CGameObj pxGameObj=m_xProduceUnit.GetObj();
			if(pxGameObj!=null)then
				pxGameObj^.InvalidateTechTreeCache();
			endif;
		endif;
		if(m_xReactor.IsValid())then
			var ^CGameObj pxGameObj=m_xReactor.GetObj();
			if(pxGameObj!=null)then
				pxGameObj^.InvalidateTechTreeCache();
			endif;
		endif;
		InvalidateTechTreeCache();
		m_xTechTree=GetTechTree();
		return true;
	endproc;
	
	///////
	//	OnInit()
	///////
	export proc void OnInit(bool p_bLoad)
//		CMirageSrvMgr.Debug("oninit foba 1: '"+GetName()+"'");
		if(!m_bDefFirstInit)then
			if(!CMirageSrvMgr.SDK())then
				m_bDefFirstInit=true;
			endif;
			if(m_bDefFirstInit&&CSrvWrap.GetGame().GetType()==2)then
				var int iTempO=GetOwner();
				var ^CBasePlayer pxOwner=CBasePlayer.GetPlayer(iTempO);
				if(pxOwner==null)then
					var ^CLevelInfoHost pxLevelInfo=^(CSrvWrap.GetCurLevel()^.GetLevelInfo());
					var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
					var ^CPropDB.CNode pxTeams=pxGenericDB^.FindNode("ClientSettings/DefendTeams",false);
					if(pxTeams!=null)then
						var array string asTeams;
						var array int aiDefenders;
						var string sTeams=pxTeams^.Value();
						if(sTeams!="")then
							sTeams.Split(asTeams,":",true);
							var int j, jC=Math.Clamp(asTeams.NumEntries(),1,8);
							for(j=0)cond(j<jC)iter(j++)do
								if(Math.Clamp(asTeams[j].ToInt(),1,2)==1)then
									aiDefenders.AddEntry(j);
								endif;
							endfor;
							if(aiDefenders.FindEntry(iTempO)!=-1)then
								jC=aiDefenders.NumEntries();
								for(j=0)cond(j<jC)iter(j++)do
									if(aiDefenders[j]!=iTempO)then
										pxOwner=CBasePlayer.GetPlayer(aiDefenders[j]);
										if(pxOwner!=null)then
											SetOwner(aiDefenders[j]);
											break;
										endif;
									endif;
								endfor;
							endif;
						endif;
					endif;
				endif;
			endif;
		endif;
		super.OnInit(p_bLoad);
		m_iOwnerID=super.GetOwner();
		m_iCmdID=m_iOwnerID;
		if(!p_bLoad)then
			m_bGodMode=false;
			m_bGodMode=CMirageSrvMgr.Get().GetGodMode(m_iOwnerID);
		endif;
		var ^CBasePlayer pxPlayer=CBasePlayer.GetPlayer(m_iOwnerID);
		if(pxPlayer!=null&&pxPlayer^.IsRevealed()&&ShallBeRevealedAutomaticaly())then
			PlayerRevealed(true);
		endif;
		m_fMaxDef=CMirageSrvMgr.Get().GetMaxDef();
		// Henry: to make testing easier
		All4One(); //Henry: to set some attribs from techtree...
		InitEvents();
		var ^CFSM pxFSM=GetFSM();
		if(pxFSM==null)then
			pxFSM=InitFSM();
			m_pxTaskMgr=cast<CTaskMgr>(CSrvWrap.GetUSLFactoryMgr().CreateState(pxFSM,"TaskMgr"));
			if(m_pxTaskMgr!=null)then
				m_pxTaskMgr^.SetOwner(GetHandle());
			endif;
		else
			m_pxTaskMgr=cast<CTaskMgr>(pxFSM^.FindSubStateRecursive("TaskMgr"));
			if(m_pxTaskMgr!=null)then
				m_pxTaskMgr^.SetOwner(GetHandle());
			endif;
		endif;
		SetDmg(0.0);
		SetMinDmg(0.0);
		SetEndDmg(0.0f);
		SetHitRange(0.0f);
		SetMovableInFight(true);
		SetCanWalk(true);
		DeleteTimer(TIMER_PREAGGRO);
		UpdateAggressive();
		UpdateFOW();
		var ^CLevel pxLvl=CSrvWrap.GetCurLevel();
		if(pxLvl!=null)then
			var ^CPlayer pxPlayer=pxLvl^.GetPlayer(GetOwner());
			if(pxPlayer!=null)then
				var ^CAiPlayer pxAiPlayer=cast<CAiPlayer>(pxPlayer);
				m_bAI=pxAiPlayer!=null;
			endif;
		endif;
		if(!p_bLoad)then
			CreateTimer(TIMER_FLAGS, CGameTimeSpan.OneSecond() * 1.0, true);
			CreateTimer(TIMER_FLAGS2, CGameTimeSpan.OneSecond() * 20.0, true);
			if(GetClassName()=="aje_poisoner" && !m_bAI)then
//				SetAggressionState(5);
				SetAggressionState(1);
			elseif(GetClassName()=="aje_resource_collector" || GetClassName()=="ninigi_parasaurolophus_drums")then
				SetAggressionState(1);
			else
				SetAggressionState(2);
			endif;
			UpdateCamouflageLayers();
			begin RallyPoint;
				var CFourCC xLink="Ex_1";
				var vec3 vPos=GetPos();
				if(!GetLinkPosWorld(xLink,vPos))then
					vPos=GetCustomRallyPos();
				endif;
				var CObjHndl xInvalid;
				SetRallyPoint(vPos,xInvalid);
			end RallyPoint;
			m_vAggressionPos=GetPos();
		else
			var ^CAttribs pxAttribs=GetAttribs();
			if(pxAttribs!=null)then
				m_vRallyPos.FromString(pxAttribs^.GetValue("RallyPoint"));
			endif;
		endif;
		m_vFormationPriority={0.0,0.0};
		InitTechTreeDef();
		m_pxWeaponMgr^.UpdateAll();
		UpdateEquipment();
		GetBestWeapon(null, true);
		UpdateWeaponBoni();
		UpdateRangeNDamageInformation();
		AddTemporaryAttackBoni(GetDmg());
		//Henry: because melee and ranged attack bonuses are in MIRAGE separately handled
		AddTemporaryMeleeAttackBoni(GetDmg());
		AddTemporaryRangedAttackBoni(GetDmg());
		AddTemporaryDefenseBoni(GetProtection());
		AddTemporaryRangedDefenseBoni(GetRangedProtection());
		m_bIsHelpShout=false;
		m_bIsBerserker=false;
//		if(GetClassName()=="hu_berserker"&&!CMirageSrvMgr.Get().DisableBerserking())then
//			m_bIsBerserker=true;
//		endif;
		if(m_vAggressionPos=={0.0,0.0,0.0}||!CSrvWrap.GetCurLevel()^.GetLevelInfo().IsSaveGame())then
			UpdateAggressionPos(GetPos());
		endif;
		var string sObjPath=GetObjPath();
		var CTechTree xTT=GetTechTree();
		var ^CTechTree.CNode pxNode=xTT.FindNode(sObjPath+"/special_abilities");
		m_xAbilities.AddAbilities(pxNode, true);
//		m_iFinishingMoveIdx=CFinishingMoveMgr.Get().FindFighter(GetClassName());
		if(p_bLoad)then
			m_pxIdleState=pxFSM^.FindSubStateRecursive("idle");
		endif;
		if(m_pxIdleState==null)then
			m_pxIdleState=CSrvWrap.GetUSLFactoryMgr().CreateState(pxFSM,"idle");
		endif;
		if(m_pxIdleState!=null)then
			m_pxIdleState^.m_xOnEnter=OnIdleEnter;
			m_pxIdleState^.m_xOnTick=OnIdleTick;
			m_pxIdleState^.m_xOnLeave=OnIdleLeave;
		endif;
		if(m_pxTaskMgr!=null)then
			m_pxTaskMgr^.m_xOnChangeToIdleState=OnChangeToIdleState;
			m_pxTaskMgr^.SetReturnState(m_pxIdleState);
		endif;
		if(pxFSM^.GetCurState()==null)then
			pxFSM^.ChangeState(m_pxIdleState);
		endif;
		// fix for unsaved CFX objects (start)
		if(p_bLoad)then
			var int i,iC=m_xFXObjects.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				var ^CFX pxCFX=cast<CFX>(m_xFXObjects[i].GetObj());
				if(pxCFX!=null)then
					pxCFX^.SetParent(GetHandle());
				endif;
			endfor;
		endif;
		// fix for unsaved CFX objects (end)
		// fix for unsaved CVirtualProduceUnits objects (start)
		if(p_bLoad)then
			if(m_xProduceUnit.IsValid())then
				var ^CVirtualProduceUnit pxUnit=cast<CVirtualProduceUnit>(m_xProduceUnit.GetObj());
				if(pxUnit!=null)then
					pxUnit^.Init(GetHandle(), GetClassName(), GetTribeName());
//					pxUnit^.Init(GetHandle());
				endif;
			endif;
			if(m_xReactor.IsValid())then
				var ^CVirtualProduceUnit pxUnit=cast<CVirtualProduceUnit>(m_xReactor.GetObj());
				if(pxUnit!=null)then
					pxUnit^.Init(GetHandle(), GetClassName(), GetTribeName());
				endif;
			endif;
			if(m_xHiveMind.IsValid())then
				var ^CHiveMind pxUnit=cast<CHiveMind>(m_xHiveMind.GetObj());
				if(pxUnit!=null)then
					m_iCmdID=pxUnit^.GetOwner();
					pxUnit^.Init(GetHandle());
				endif;
			endif;
		endif;
		m_xWalkSet="defn";
		if(!HasWalkSet(m_xWalkSet))then m_xWalkSet="def"; endif;
		SetDefaultWalkSet(GetWalkSet());
		// fix for unsaved CVirtualProduceUnits objects (end)
		if(!p_bLoad)then
			//Henry: to set at gamestart the mana values for spellcasters and set the supply capacity of the produced unit
			SetManaOnInit();
			m_iSupplyCount=CMirageSrvMgr.Get().GetSupply(GetClassName());
		endif;
//		var ^CAttribs pxAttribs=GetAttribs();
//		if(pxAttribs!=null)then
//			pxAttribs^.SetValue("overlord", m_iCmdID);
//		endif;
		CheckFighterValidity();
		CheckEnemyValidity();
		m_bCanTame=m_xTechTree.GetValueI(GetObjPath()+"/can_tame",0)==1;
		UpdatePTName();
		if(GetClassName()=="Pteranodon")then
			m_bWildPtera=true;
		else
			m_bWildPtera=false;
		endif;
//		if(m_bDoingFinishingMove)then
//			CreateTimer(FINISHING_MODE,CGameTimeSpan.OneSecond() * 10.0f, false);
//		endif;
		//Henry: for testing purposes

////		if(GetClassName()=="tesla_s0")then
//		if(GetName()=="ninigi_saltasaurus_archer_0")then
////			CreateTimer(TIMER_INFORM_ME, CGameTimeSpan.OneSecond()*1.0, true);
//			CreateTimer(TIMER_INFORM_ME, CGameTimeSpan.OneSecond()*30.0, false);
//		endif;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("obj_radius",GetRadius());
		endif
	endproc;
	
	export proc void OnChangeToIdleState(string p_sTaskName)
	endproc;
	
	export proc void OnIdleEnter(^CState p_pxFrom, ^CState p_pxTo)
	endproc;
	
	export proc void OnIdleTick(int p_iTime)
		CheckPatrol();
	endproc;
	
	export proc void OnIdleLeave(^CState p_pxFrom, ^CState p_pxTo)
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null&&pxAttr^.GetValue("CurTask")=="Idle")then
			pxAttr^.SetValue("CurTask","");
		endif;
		SetTaskDescription(m_sStandardDesc);
	endproc;
	
	export proc int AddAutoSpecialMove(string p_sTTPath)
		var CFightingObj.CActionObj xActionObj;
		xActionObj.SetTTPath(p_sTTPath);
		return m_axAutoSpecialMoves.AddEntry(xActionObj);
	endproc;
	
	export proc bool CheckSpecialMoves(^CFightingObj p_pxEnemy, bool p_bOnOpenTrp)
		if(p_pxEnemy!=null)then
			m_xCurEnemy=p_pxEnemy^.GetHandle();
		endif;
		var string sPath;
		var int i, iC=m_axAutoSpecialMoves.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			sPath=m_axAutoSpecialMoves[i].GetTTPath();
			if(p_bOnOpenTrp && sPath.Find("burst_arrow")==-1 && sPath.Find("multishot")==-1)then continue; endif;
			if(m_axAutoSpecialMoves[i].CheckConditions()&&CheckSpecialActionTimer(sPath,true))then
				m_axAutoSpecialMoves[i].StartAction();
				return true;
			endif;
		endfor;
		return false;
	endproc;
	
	export proc void UpdateAttribs(bool p_bLoad)
		var ^CAttribs pxAttribs=GetAttribs();
		if(pxAttribs==null)then return; endif;
		if(!p_bLoad)then
			pxAttribs^.SetValue("hitpoints",m_fHitpoints);
			pxAttribs^.SetValue("maxhitpoints",m_fMaxHitpoints);
			pxAttribs^.SetValue("tribe",m_sTribe);
			pxAttribs^.SetValue("RallyPoint", m_vRallyPos.ToString());
			pxAttribs^.SetValue("level",m_iLevel);
	//========================================================================================
	//===New member values saved into unitattribs in MIRAGE by Henry==========================
	//========================================================================================
			pxAttribs^.SetValue("energystate",m_fEnergyState);
			pxAttribs^.SetValue("maxenergyamount",m_fMaxEnergy);
			pxAttribs^.SetValue("replenishamount",m_fReplenishAmount);
			pxAttribs^.SetValue("replenishtime",m_fReplenishTime);
			pxAttribs^.SetValue("supply",m_iSupplyCount);
			pxAttribs^.SetValue("InCapacitated",m_bIncapacitated);
			pxAttribs^.SetValue("killercount",m_iKillerCount);
//			pxAttribs^.SetValue("overlord", m_iCmdID);
		else
			m_fHitpoints=pxAttribs^.GetValueFloat("hitpoints");
			m_fMaxHitpoints=pxAttribs^.GetValueFloat("maxhitpoints");
			m_sTribe=pxAttribs^.GetValue("tribe");
			m_vRallyPos.FromString(pxAttribs^.GetValue("RallyPoint"));
			m_iLevel=pxAttribs^.GetValueInt("level");
	//========================================================================================
	//===New member values loaded from unitattribs in MIRAGE by Henry=========================
	//========================================================================================
			m_fEnergyState=pxAttribs^.GetValueFloat("energystate");
			m_fMaxEnergy=pxAttribs^.GetValueFloat("maxenergyamount");
			m_fReplenishTime=pxAttribs^.GetValueFloat("replenishtime");
			m_fReplenishAmount=pxAttribs^.GetValueFloat("replenishamount");
			//m_iSupplyCount=pxAttribs^.GetValueInt("supply");
			pxAttribs^.SetValue("supply",m_iSupplyCount);
			m_bIncapacitated=pxAttribs^.GetValueBool("InCapacitated");
			m_iKillerCount=pxAttribs^.GetValueInt("killercount");
			var string sProdQueue=pxAttribs^.GetValue("ProdQueue");
			var array string asTokens,asRT;
			sProdQueue.Split(asTokens,":",true);
			m_iPQNEO=asTokens.NumEntries();
			sProdQueue=pxAttribs^.GetValue("ReactorProdQueue");
			sProdQueue.Split(asRT,":",true);
			m_iPQNER=asRT.NumEntries();
			SetLevelFilter(false);
			SetLevelFilter(true);
		endif;
		var string sCN=pxAttribs^.GetValue("coded_name");
		if(sCN=="")then
			sCN=CMirageSrvMgr.Get().GetCodeFromName(GetName(),GetClassName());
			pxAttribs^.SetValue("coded_name",sCN);
		endif;
		UpdateDestructionFlags();
	endproc;
	
	export proc CObjHndl GetProduceUnit()
		return m_xProduceUnit;
	endproc;
	
	export proc void CreatePersonalProduceUnit()
		CreatePersonalProduceUnit(true);
	endproc;
	
	export proc void CreatePersonalProduceUnit(bool p_bSetReady)
		var ^CVirtualProduceUnit pxUnit=cast<CVirtualProduceUnit>(CSrvWrap.GetObjMgr()^.CreateObj("Virtual_Produce_Unit",GetOwner(),GetPos()));
		if(pxUnit!=null)then
//			pxUnit^.Init(GetHandle());
			pxUnit^.Init(GetHandle(), GetClassName(), GetTribeName());
			m_xProduceUnit=pxUnit^.GetHandle();
			if(p_bSetReady)then
				pxUnit^.SetReady();
			endif;
		endif;
	endproc;
	
	proc void CreatePersonalRegion(string p_sRegionClass, vec3 p_vDimension, bitset p_dwType)
		if(m_bToBeDeleted||!m_xRegionGuid.IsNull())then return; endif;
		var ^CRegionMgr pxRM=^(CSrvWrap.GetRegionMgr());
		if(pxRM!=null)then
			var int iIdx=pxRM^.CreateRegion(p_sRegionClass, p_dwType, GetPos(), p_vDimension);
			if(iIdx>=0)then
				m_sPerRegName=p_sRegionClass;
				var ^CRegion pxRegion=pxRM^.GetRegion(iIdx);
				m_xRegionGuid=pxRegion^.GetGUID();
				m_xSink.SetRegion(pxRegion);
				pxRegion^.BindToObj(GetHandle());
				m_xSink.Subscribe();
				var ^CAttribs pxAttr=GetAttribs();
				if(pxAttr!=null)then
					pxAttr^.SetValue("RangeMarker","Personal/"+(p_vDimension.GetX()).ToString()+";");
				endif;
			endif;
		endif;
	endproc;
	
	proc void DeletePersonalRegion()
		RemoveBuff();
		if(!m_xRegionGuid.IsNull())then
			var ^CRegionMgr pxRM=^(CSrvWrap.GetRegionMgr());
			if(pxRM!=null)then
				var int iIdx=CSrvWrap.GetRegionMgr().FindRegion(m_xRegionGuid);
				if(iIdx>=0)then
					var ^CRegion pxRegion=pxRM^.GetRegion(iIdx);
					m_xSink.Unsubscribe();
					if(pxRegion!=null)then
						pxRegion^.Unbind();
					endif;
					m_xSink.DeleteRegion();
					var CGuid xNew;
					m_xRegionGuid=xNew;
					m_sPerRegName="";
				elseif(m_sPerRegName!="")then
					var ^CRegion pxRegion=pxRM^.GetRegion(m_sPerRegName);
					if(pxRegion!=null)then
						m_xSink.Unsubscribe();
						pxRegion^.Unbind();
						m_xSink.DeleteRegion();
						var CGuid xNew;
						m_xRegionGuid=xNew;
						m_sPerRegName="";
					endif;
				endif;
			endif;
			var ^CAttribs pxAttr=GetAttribs();
			if(pxAttr!=null)then
				pxAttr^.SetValue("RangeMarker","");
			endif;
		endif;
	endproc;
	
	proc bool HasPersonalRegion()
		return !m_xRegionGuid.IsNull();
	endproc;
	
	export proc bool DoesCountInUnitLimit()
		return true;
	endproc;
	
	export proc void AddUnit()
		var bool bIsSupplyOn=CMirageSrvMgr.Get().UseSupply();
		if(m_iOwnerID<0)then return; endif;
		if(!DoesCountInUnitLimit())then return; endif;
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		var ^CPlayer pxPlayer=pxLevel^.GetPlayer(m_iOwnerID);
		if(pxPlayer==null)then return; endif;
		var ^CBasePlayer pxBPl=cast<CBasePlayer>(pxPlayer);
		if(pxBPl==null)then return; endif;
		var ^CAttribs pxPlAttr=pxPlayer^.GetAttribs();
		if(pxPlAttr==null)then return; endif;
		var int iUnits=pxPlAttr^.GetValueInt("units");
		var int iSupply=pxPlAttr^.GetValueInt("supply");
		var string sLvlAttr="objects_lvl_"+m_iLevel.ToString();
		pxBPl^.SetAttribs(sLvlAttr,pxPlAttr^.GetValueInt(sLvlAttr)+1);
//		if(bIsSupplyOn)then
			iSupply += CMirageSrvMgr.Get().GetSupply(GetClassName());
//		endif;
		iUnits++;
		pxPlAttr^.SetValue("units",iUnits);
		pxPlAttr^.SetValue("supply",iSupply);
//		pxBPl^.SetAttribs("units",iUnits);
//		pxBPl^.SetAttribs("supply",iSupply);
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("unit_count",true);
		endif;
	endproc;
	
	export proc void RemoveUnit()
		var bool bIsSupplyOn=CMirageSrvMgr.Get().UseSupply();
		if(m_iOwnerID<0)then return; endif;
		if(!DoesCountInUnitLimit())then return; endif;
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		var ^CPlayer pxPlayer=pxLevel^.GetPlayer(m_iOwnerID);
		if(pxPlayer==null)then return; endif;
		var ^CBasePlayer pxBPl=cast<CBasePlayer>(pxPlayer);
		if(pxBPl==null)then return; endif;
		var ^CAttribs pxPlAttr=pxPlayer^.GetAttribs();
		if(pxPlAttr==null)then return; endif;
		var int iUnits=pxPlAttr^.GetValueInt("units");
		var int iSupply=pxPlAttr^.GetValueInt("supply");
		var string sLvlAttr="objects_lvl_"+m_iLevel.ToString();
		pxBPl^.SetAttribs(sLvlAttr,pxPlAttr^.GetValueInt(sLvlAttr)-1);
//		if(bIsSupplyOn)then
			//decrase players population by the lost units supply capacity
			iSupply -= CMirageSrvMgr.Get().GetSupply(GetClassName());
//		endif;
		iUnits--;
		pxPlAttr^.SetValue("units",iUnits);
		pxPlAttr^.SetValue("supply",iSupply);
//		pxBPl^.SetAttribs("units",iUnits);
//		pxBPl^.SetAttribs("supply",iSupply);
		var ^CAttribs pxAttr=GetAttribs();
	endproc;
	
	export proc bool UpdateDestructionFlags()
		if(GetConstructLevel()<4)then return false; endif;
		if((GetHitpoints()!=GetMaxHitpoints())&&((GetHitpoints()!=0.0f)&&(GetMaxHitpoints()!=0.0f)))then
			var real fPercentage=GetHitpoints()/(GetMaxHitpoints()/100.0f);
			if(fPercentage<=25.0f)then
				if(GetDestructLevel()!=2)then
					if(GetDestructLevel()<2)then
						InvokeGenericSCEvent(14,4.0f);
					endif;
					SetDestructLevel(2);
				endif;
				return(true);
			elseif(fPercentage<=50.0f)then
				if(GetDestructLevel()!=1)then
					if(GetDestructLevel()<1)then
						InvokeGenericSCEvent(14,4.0f);
					endif;
					SetDestructLevel(1);
				endif;
				return(true);
			else
				SetDestructLevel(0);
				return(true);
			endif;
		endif;
		return(true);
	endproc;
	
	proc void StartTT()
		SetStartFilter(true);
	endproc;
	
	proc void SetStartFilter(bool p_bEnable)
		m_xTechTree=GetTechTree();
		// object TT
		var string sStartTT=m_xTechTree.GetValueS(GetObjPath()+"/StartTT","");
		var ^CTechTreeDef pxDef=GetTechTreeDef();
		if( !sStartTT.IsEmpty()&&pxDef!=null)then
			if(p_bEnable)then
				pxDef^.EnableFilter(sStartTT);
			else
				pxDef^.DisableFilter(sStartTT);
			endif;
		endif;
		// player TT
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel!=null)then
			var ^CPlayer pxPlayer=pxLevel^.GetPlayer(GetOwner());
			if(pxPlayer!=null)then
				sStartTT=m_xTechTree.GetValueS(GetObjPath()+"/GlobalStartTT","");
				if(!sStartTT.IsEmpty())then
					if(p_bEnable)then
						pxPlayer^.GetPlayerTechTreeDef().EnableFilter(sStartTT);
					else
						pxPlayer^.GetPlayerTechTreeDef().DisableFilter(sStartTT);
					endif;
				endif;
				//Henry: for hero pool
				var string sGameTT=m_xTechTree.GetValueS(GetObjPath()+"/ServerStartTT","");
				var bool bPool=CMirageSrvMgr.Get().HeroPool();
				if(bPool&&!sGameTT.IsEmpty())then
					var ^CPlayer pxPlyr;
					var int i, iC=8;
					for(i=0)cond(i<iC)iter(++i)do
						//if(GetOwner()==i)then continue; endif;
						pxPlyr=pxLevel^.GetPlayer(i);
						if(pxPlyr==null)then continue; endif;
						var ^CTechTreeDef pxTechTreeDef=^(pxPlyr^.GetPlayerTechTreeDef());
						if(pxTechTreeDef!=null)then
							if(p_bEnable)then
								pxPlyr^.GetPlayerTechTreeDef().EnableFilter(sGameTT);
							else
								pxPlyr^.GetPlayerTechTreeDef().DisableFilter(sGameTT);
							endif;
						endif;
					endfor;
				endif;
			endif;
		endif;
	endproc;
	
	proc void SetNewStartFilterOwner(int p_iOwner)
		// player TT
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel!=null)then
			var ^CPlayer pxPlayerOld=pxLevel^.GetPlayer(GetOwner());
			var ^CPlayer pxPlayerNew=pxLevel^.GetPlayer(p_iOwner);
			if(pxPlayerOld!=null&&pxPlayerNew!=null)then
				var string sStartTT=m_xTechTree.GetValueS(GetObjPath()+"/GlobalStartTT","");
				if(!sStartTT.IsEmpty())then
					pxPlayerNew^.GetPlayerTechTreeDef().EnableFilter(sStartTT);
					pxPlayerOld^.GetPlayerTechTreeDef().DisableFilter(sStartTT);
				endif;
			endif;
		endif;
	endproc;
	
	///////
	//	UpdateSpecialActions()
	///////
	proc bool UpdateSpecialActions(ref int p_riTimerID)
		if(m_aiActionTimerIDs.NumEntries()==0)then
			return false;
		endif;
		var int iTimer=m_aiActionTimerIDs.FindEntry(p_riTimerID);
		if(iTimer==-1)then
			return false;
		else
			if(m_aiActionTimerIDs.NumEntries()!=m_axActionObj.NumEntries())then
				CSrvWrap.LogWarning("FightingObj","m_aiActionTimerIDs & m_axActionObj have different NumEntries!");
			endif;
			m_aiActionTimerIDs.DeleteEntryUS(iTimer);
			m_axActionObj.DeleteEntryUS(iTimer);
		endif;
		return true;
	endproc;
	
	///////
	//	AddSpecialActionTimer()
	///////
	export proc bool AddSpecialActionTimer(string p_sTTPath)
		if(!CheckManaAndPay(p_sTTPath))then return false; endif;
		var int iTimerID;
		var CActionObj xActionObj;
		xActionObj.SetTTPath(p_sTTPath);
		var int iIndex=m_axActionObj.FindEntry(xActionObj);
		if(iIndex==-1)then
			var real fDuration=m_xTechTree.GetValueR(p_sTTPath+"/duration",5.0);
			xActionObj.SetDuration(fDuration);
			xActionObj.SetStartTime(CTimeMgr.Get().GetTime());
			var bool bFine=false;
			repeat
				iTimerID=(Random.GetInt()%50)+300;
				bFine=m_aiActionTimerIDs.FindEntry(iTimerID)==-1;
				bFine=bFine&&!HasTimer(iTimerID);
			until(bFine)endrepeat;
			CreateTimer(iTimerID, CGameTimeSpan.OneSecond()*fDuration,false);
			m_aiActionTimerIDs.AddEntry(iTimerID);
			m_axActionObj.AddEntry(xActionObj);
			//L CSrvWrap.LogSpam("FightingObj","iTimerID="+iTimerID.ToString()+" "+p_sTTPath+" ("+m_axActionObj.NumEntries().ToString()+")");
		else
			return false;
		endif;
		ReWriteActionAttribs();
		return true;
	endproc;
	
	export proc bool CheckSpecialActionTimer(string p_sTTPath, ^CGameObj p_pxObject, bool p_bCheckObj)
		if(p_pxObject!=null)then
			var string sClass=p_pxObject^.GetClassName();
			var ^CTechTree.CNode pxSecondary=m_xTechTree.FindNode(p_sTTPath+"/secondaryexcludes");
			if(pxSecondary!=null)then
				var int i, iC=pxSecondary^.NumSubs();
				for(i=0)cond(i<iC)iter(i++)do
					if(pxSecondary^.GetSub(i)^.GetValue()==sClass)then
						return false;
					endif;
				endfor;
			endif;
			pxSecondary=m_xTechTree.FindNode(p_sTTPath+"/secondaryclasses");
			if(pxSecondary!=null)then
				var bool bContinue=false;
				var int i, iC=pxSecondary^.NumSubs();
				for(i=0)cond(i<iC)iter(i++)do
					if(pxSecondary^.GetSub(i)^.GetValue()==sClass)then
						bContinue=true;
						break;
					endif;
				endfor;
				if(!bContinue)then return false; endif;
			endif;
		elseif(p_bCheckObj)then
			return false;
		endif;
		return CheckSpecialActionTimer(p_sTTPath);
	endproc;
	
	export proc bool CheckSpecialActionTimer(string p_sTTPath)
		return CheckSpecialActionTimer(p_sTTPath, false);
	endproc;
	
	export proc bool CheckSpecialActionTimer(string p_sTTPath, bool p_bSkipVis)
		if(!CheckMana(p_sTTPath))then return false; endif;
		var ^CTechTree.CNode pxAction=m_xTechTree.FindNode(p_sTTPath);
		if(!CheckLevelCondition(pxAction))then return false; endif;
		if(!CheckTribes(pxAction))then return false; endif;
//		if(pxAction==null)then return false; endif;
		if(!pxAction^.IsVisible())then return false; endif;
		if(!p_bSkipVis&&pxAction^.GetSubValueI("visibility", 1)!=1)then return false; endif;
		if(pxAction^.GetSubValueI("disabled", 0)==1)then return false; endif;
		var ^CTechTree.CNode pxActNode=m_xTechTree.FindNode(p_sTTPath+"/locations");
		if(pxActNode==null)then return false; endif;
		var bool bFound=false;
		var int i, iC=pxActNode^.NumSubs();
		for(i=0)cond(i<iC)iter(++i)do
			var ^CTechTree.CNode pxSub=pxActNode^.GetSub(i);
			if(pxSub^.GetValue().Find(GetClassName())>=0||pxSub^.GetValue().Right(4)==GetType().AsString())then
				var ^CTechTree.CNode pxLocalFlags=pxSub^.GetSub("localflags");
				if(pxLocalFlags!=null)then
					var int j,iJC=pxLocalFlags^.NumSubs();
					for(j=0)cond(j<iJC)iter(j++)do
						if(pxLocalFlags^.GetSub(j)^.GetValueI()==1&&pxLocalFlags^.GetSub(j)^.GetName()==m_sObjFlag)then
							bFound=true;
							break;
						endif;
					endfor;
				else
					bFound=true;
				endif;
				if(bFound)then
					break;
				endif;
			endif;
		endfor;
		if(!bFound)then return false; endif;
		var CActionObj xActionObj;
		xActionObj.SetTTPath(p_sTTPath);
		return m_axActionObj.FindEntry(xActionObj)==-1;
	endproc;
	
	///////
	//	GetSpecialActionTimerInfo()
	///////
	export proc bool GetSpecialActionTimerInfo(string p_sTTPath,ref CGameTime p_rxStartTime,ref real p_rfDuration)
		var int i,iC=m_axActionObj.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(m_axActionObj[i].GetTTPath()!=p_sTTPath)then continue; endif;
			p_rxStartTime=m_axActionObj[i].GetStartTime();
			p_rfDuration=m_axActionObj[i].GetDuration();
			return true;
		endfor;
		return false;
	endproc;
	
	///////
	//	AddSpecialActionTimer()
	///////
	export proc bool AddSpecialActionTimerPrecisely(string p_sTTPath,CGameTime p_xStartTime,real p_fDuration)
		var int iTimerID;
		var CActionObj xActionObj;
		xActionObj.SetTTPath(p_sTTPath);
		var int iIndex=m_axActionObj.FindEntry(xActionObj);
		if(iIndex==-1)then
			xActionObj.SetDuration(p_fDuration);
			xActionObj.SetStartTime(p_xStartTime);
			var bool bFine=false;
			repeat
				iTimerID=(Random.GetInt()%50)+300;
				bFine=m_aiActionTimerIDs.FindEntry(iTimerID)==-1;
				bFine=bFine&&!HasTimer(iTimerID);
			until(bFine)endrepeat;
			var real fDur=Math.Max(1.0,p_fDuration-((CTimeMgr.Get().GetTime()-p_xStartTime).GetSecondsF()));
			CreateTimer(iTimerID, CGameTimeSpan.OneSecond()*fDur,false);
			m_aiActionTimerIDs.AddEntry(iTimerID);
			m_axActionObj.AddEntry(xActionObj);
		else
			return false;
		endif;
		ReWriteActionAttribs();
		return true;
	endproc;
	
	export proc bool HasSpecialActionTimer(string p_sPath)
		var int i,iC=m_axActionObj.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(m_axActionObj[i].GetTTPath()!=p_sPath)then continue; endif;
			return true;
		endfor;
		return false;
	endproc;
	
	///////
	//	ResetSpecialActionTimer()
	///////
	export proc bool ResetSpecialActionTimer(string p_sTTPath)
		var int i,iC=m_axActionObj.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(m_axActionObj[i].GetTTPath()!=p_sTTPath)then continue; endif;
			m_aiActionTimerIDs.DeleteEntry(i);
			m_axActionObj.DeleteEntry(i);
			break;
		endfor;
		ReWriteActionAttribs();
		return true;
	endproc;
	
	///////
	//	ResetSpecialActionTimer()
	///////
	export proc bool ResetAllSpecialActionTimers()
		var int i,iC=m_axActionObj.NumEntries();
		for(i=(iC-1))cond(i>=0)iter(i--)do
			m_aiActionTimerIDs.DeleteEntry(i);
			m_axActionObj.DeleteEntry(i);
		endfor;
		ReWriteActionAttribs();
		if(iC>0)then
			InvokeGenericSCEvent(8,4.0f);
		endif;
		return true;
	endproc;
	
	export proc bool ResetAllSpecialActionTimersButOne(string p_sTTPath)
		var int i,iC=m_axActionObj.NumEntries();
		var bool bFound=false;
		for(i=(iC-1))cond(i>=0)iter(i--)do
			if(m_axActionObj[i].GetTTPath()==p_sTTPath)then continue; endif;
			bFound=true;
			m_aiActionTimerIDs.DeleteEntry(i);
			m_axActionObj.DeleteEntry(i);
		endfor;
		ReWriteActionAttribs();
		if(bFound)then
			InvokeGenericSCEvent(8,4.0f);
		endif;
		return true;
	endproc;
	
	///////
	//	ResetSpecialActionTimer()
	///////
	export proc bool StartAllSpecialActionTimers()
//		var int i,iC=m_axActionObj.NumEntries();
//		for(i=(iC-1))cond(i>=0)iter(i--)do
//			m_aiActionTimerIDs.DeleteEntry(i);
//			m_axActionObj.DeleteEntry(i);
//		endfor;
		var bool bFound=false;
		var CTechTree xTT=GetTechTree();
		var ^CTechTree.CNode pxActions=xTT.FindNode("Actions/"+GetTribeName()+"/Moves/"+GetType().AsString());
		if(pxActions!=null)then
			var int i,iC=pxActions^.NumSubs();
			for(i=0)cond(i<iC)iter(i++)do
				var ^CTechTree.CNode pxAction=pxActions^.GetSub(i);
				if(pxAction==null)then continue; endif;
				if(pxAction^.GetSubValueI("duration")<=0)then continue; endif;
				if(AddSpecialActionTimerSpecial(pxAction^.GetAbsPath())&&!bFound)then
					bFound=true;
				endif;
			endfor;
		endif;
//		ReWriteActionAttribs();
		if(bFound)then
			InvokeGenericSCEvent(8,4.0f);
		endif;
		return bFound;
	endproc;
	
	export proc bool AddSpecialActionTimerSpecial(string p_sTTPath)
		var ^CTechTree.CNode pxAction=m_xTechTree.FindNode(p_sTTPath);
		if(pxAction==null)then return false; endif;
		if(!pxAction^.IsVisible())then return false; endif;
		if(pxAction^.GetSubValueI("visibility", 1)!=1)then return false; endif;
		if(pxAction^.GetSubValueI("disabled", 0)==1)then return false; endif;
		var ^CTechTree.CNode pxActNode=m_xTechTree.FindNode(p_sTTPath+"/locations");
		if(pxActNode==null)then return false; endif;
		var bool bFound=false;
		var int i, iC=pxActNode^.NumSubs();
		for(i=0)cond(i<iC)iter(++i)do
			var ^CTechTree.CNode pxSub=pxActNode^.GetSub(i);
			if(pxSub^.GetValue().Find(GetClassName())>=0||pxSub^.GetValue().Right(4)==GetType().AsString())then
				var ^CTechTree.CNode pxLocalFlags=pxSub^.GetSub("localflags");
				if(pxLocalFlags!=null)then
					var int j,iJC=pxLocalFlags^.NumSubs();
					for(j=0)cond(j<iJC)iter(j++)do
						if(pxLocalFlags^.GetSub(j)^.GetValueI()==1&&pxLocalFlags^.GetSub(j)^.GetName()==m_sObjFlag)then
							bFound=true;
							break;
						endif;
					endfor;
				else
					bFound=true;
				endif;
				if(bFound)then
					break;
				endif;
			endif;
		endfor;
		if(!bFound)then return false; endif;
		var int iTimerID;
		var CActionObj xActionObj;
		xActionObj.SetTTPath(p_sTTPath);
		var int iIndex=m_axActionObj.FindEntry(xActionObj);
		if(iIndex!=-1&&HasTimer(m_aiActionTimerIDs[iIndex]))then
			DeleteTimer(m_aiActionTimerIDs[iIndex]);
		endif;
		var real fDuration=m_xTechTree.GetValueR(p_sTTPath+"/duration",5.0);
		var bool bFine=false;
		repeat
			iTimerID=(Random.GetInt()%50)+300;
			bFine=m_aiActionTimerIDs.FindEntry(iTimerID)==-1;
			bFine=bFine&&!HasTimer(iTimerID);
		until(bFine)endrepeat;
		CreateTimer(iTimerID, CGameTimeSpan.OneSecond()*fDuration,false);
		if(iIndex==-1)then
			xActionObj.SetDuration(fDuration);
			xActionObj.SetStartTime(CTimeMgr.Get().GetTime());
			m_aiActionTimerIDs.AddEntry(iTimerID);
			m_axActionObj.AddEntry(xActionObj);
		else
			m_aiActionTimerIDs[iIndex]=iTimerID;
			m_axActionObj[iIndex].SetDuration(fDuration);
			m_axActionObj[iIndex].SetStartTime(CTimeMgr.Get().GetTime());
		endif;
		ReWriteActionAttribs();
		return true;
	endproc;
	
	///////
	//	RewriteActionAttribs()
	///////
	proc void ReWriteActionAttribs()
		var string sSend;
		var string sActions;
		//var CPropDB xDB;
		var int i, iC=m_aiActionTimerIDs.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CTechTree.CNode pxTTNode=m_xTechTree.FindNode(m_axActionObj[i].GetTTPath());
			if(pxTTNode!=null)then
				sSend += pxTTNode^.GetHashValue().ToString()+"|"+m_axActionObj[i].GetStartTime().ToString()+"|"+m_axActionObj[i].GetDuration().ToString()+"\n";
				sActions += pxTTNode^.GetName()+"\n";
			endif;
		endfor;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("SpecialActionCounters",sSend);
			pxAttr^.SetValue("SpecialActionNames",sActions);
		endif;
	endproc;
	
	export proc ref CObjHndl AddFX(string p_sFX, real p_fTime)
		return AddFX(p_sFX, p_fTime, GetPos());
	endproc;
	
	export proc ref CObjHndl AddFX(string p_sFX, real p_fTime, vec3 p_vPos)
		if(IsMarkedForDelete())then return m_xInvalid; endif;
		var int iIndex;
		var bool bAlreadyExists=false;
		var int i, iC=m_xFXObjects.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFX pxObj=cast<CFX>(m_xFXObjects[i].GetObj());
			if(pxObj!=null&&pxObj^.GetFXClass()==p_sFX)then
				bAlreadyExists=true;
				iIndex=i;
				break;
			endif;
		endfor;
		if(!bAlreadyExists)then
			var ^CFX pxFX=cast<CFX>(CSrvWrap.GetObjMgr()^.CreateObj(p_sFX,GetOwner(),p_vPos,GetRotation()));
			if(pxFX!=null)then
				iIndex=m_xFXObjects.Include(pxFX^.GetHandle());
				if(p_fTime>0.0)then
					pxFX^.SetTimer(p_fTime);
				endif;
				pxFX^.SetFXClass(p_sFX);
				pxFX^.SetParent(GetHandle());
			endif;
		endif;
		return m_xFXObjects[iIndex];
	endproc;
	
	export proc bool RemoveFX(string p_sFX)
		var int i, iC=m_xFXObjects.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFX pxObj=cast<CFX>(m_xFXObjects[i].GetObj());
			if(pxObj!=null&&pxObj^.GetFXClass()==p_sFX)then
				m_xFXObjects.DeleteEntry(i);
				pxObj^.Delete();
				return true;
			endif;
		endfor;
		return false;
	endproc;
	
	export proc void ClearFX()
		var int i;
		for(i=0)cond(i<m_xFXObjects.NumEntries())iter(i++)do
			var ^CFX pxObj=cast<CFX>(m_xFXObjects[i].GetObj());
			m_xFXObjects.DeleteEntry(i);
			if(pxObj!=null)then
				pxObj^.Delete();
			endif;
			i--;
		endfor;
	endproc;
	
	///////
	//	SetOwner()
	///////
	export proc void SetOwner(int p_iNewOwner)
		RemoveUnit();
		SetNewStartFilterOwner(p_iNewOwner);
		super.SetOwner(p_iNewOwner);
		RetainConsciousness();
		m_iOwnerID=p_iNewOwner;
		AddUnit();
		if(m_xProduceUnit.IsValid())then
			m_xProduceUnit.GetObj()^.SetOwner(p_iNewOwner);
		endif;
		if(m_xReactor.IsValid())then
			m_xReactor.GetObj()^.SetOwner(p_iNewOwner);
		endif;
		OnTechTreeChange();
		UpdatePTName();
	endproc;
	
	/*?
		?item GetLevel()
		?desc Get level of character
		?return Level of character
	?*/
	export proc int GetLevel()
		return(m_iLevel);
	endproc;
	
	proc bool CompareTechTreeLevel(int p_iLevel)
		return p_iLevel<=(GetLevel()+1);
	endproc;
	
	proc void SetLevelFilter(bool p_bEnable)
		var string sSearch="Filters/"+GetTribeName()+"/Upgrades/"+GetClassName()+"/Lvl"+(m_iLevel+1).ToString();
		SetLevelFilter(p_bEnable, sSearch);
	endproc;
	
	proc void SetLevelFilter(bool p_bEnable, string p_sPath)
		if(m_iLevel>0)then
			var bool bFS=CMirageSrvMgr.Get().FreeSpecials();
			var bool bSDK=CMirageSrvMgr.SDK();
			var string sSearch=p_sPath;
			var array string asFilters;
			var int i, iC=CTechTreeMgr.Get().NumEntries();
			for(i=0)cond(i<iC)iter(++i)do
				var string sP=CTechTreeMgr.Get().GetFilterPath(i);
				if(sP.Find(sSearch)>=0)then
					asFilters.AddEntry(sP);
				endif;
			endfor;
			var ^CPlayer pxPlayer=CSrvWrap.GetCurLevel()^.GetPlayer(GetOwner());
			if(pxPlayer!=null||bSDK)then
				iC= asFilters.NumEntries();
				for(i=0)cond(i<iC)iter(++i)do
					var ^CTechTreeDef pxTTDef=GetTechTreeDef();
					if(asFilters[i].Find("_Bonus")<0)then
						if((p_bEnable&&bFS&&asFilters[i].Find("_tt")>0)||bSDK)then
							continue;
						endif;
						pxTTDef=^(pxPlayer^.GetPlayerTechTreeDef());
					endif;
					if(p_bEnable)then
						pxTTDef^.EnableFilter(asFilters[i]);
					else
						pxTTDef^.DisableFilter(asFilters[i]);
					endif;
				endfor;
			endif;
			if(m_iLevel==4)then
				if(pxPlayer!=null)then
					if(p_bEnable)then
						pxPlayer^.GetPlayerTechTreeDef().EnableFilter("Filters/"+GetTribeName()+"/Upgrades/"+GetClassName()+"/Chief_Bonus");
					else
						pxPlayer^.GetPlayerTechTreeDef().DisableFilter("Filters/"+GetTribeName()+"/Upgrades/"+GetClassName()+"/Chief_Bonus");
					endif;
				endif;
			endif;
			if(GetInventory()!=null)then
				GetInventory()^.SetSize(1);
			endif;
		endif;
	endproc;
	
	/*?
		?item SetLevel(int)
		?desc set level of character, make particle effects
		?param int new level
		?return true if changed
	?*/
//	export proc bool SetLevel(int p_iLevel)
//		return SetLevel(p_iLevel, false);
//	endproc;
	
//	export proc bool SetLevel(int p_iLevel, bool p_bForce)
	export proc bool SetLevel(int p_iLevel)
		if(m_iLevel==p_iLevel)then return true; endif;
		var bool bDemoting=p_iLevel<m_iLevel;
		if(m_bDemoteEffect&&!bDemoting)then return false; endif;
		if(bDemoting)then
			if(!IsLevelAcceptable(p_iLevel))then return false; endif;
		endif;
		var int iOldLevel=m_iLevel;
		var bool bIsSupplyOn=CMirageSrvMgr.Get().UseSupply();
		if((p_iLevel<0)||(p_iLevel>4))then return false; endif;
		var CObjHndl xDelete;
		var bool bDelPyCO=false;
		var string sPyCO;
		begin CheckLevelLimit;
			var CObjList xPreSpirits;
			var CObjQuery xQ;
			xQ.SetOwner(GetOwner());
			xQ.SetAttribsPos("level",p_iLevel);
			xQ.SetAttribsPos("pre_spirit",true);
			xQ.SetType("PyCO");
			var int iCount;
			if(xQ.Execute(xPreSpirits))then
				xDelete=GetWorstSpiritToReplace(xPreSpirits,sPyCO,iCount);
			endif;
			var array int aiMaxUnits;
			aiMaxUnits.AddEntry(25);
			aiMaxUnits.AddEntry(15);
			aiMaxUnits.AddEntry(8);
			aiMaxUnits.AddEntry(3);
			aiMaxUnits.AddEntry(1);
			var ^CLevelInfoHost pxLevelInfo=^(CSrvWrap.GetCurLevel()^.GetLevelInfo());
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxLevelNode=^((pxGenericDB^)["PlayerSettings/Player_"+GetOwner().ToString()+"/Restrictions/Chars/Level"+(p_iLevel+1).ToString()]);
			var int iVirtualUnits;
			var int iACBonus=0;
			var ^CAttribs pxPlAttr=CSrvWrap.GetCurLevel()^.GetPlayer(GetOwner())^.GetAttribs();
			if(pxPlAttr!=null)then
				iVirtualUnits=pxPlAttr^.GetValueInt("virtual_units_"+p_iLevel.ToString());
				iACBonus=Math.Max(0,pxPlAttr^.GetValueInt("ac_bonus_"+p_iLevel.ToString()));
			endif;
			var CObjQuery xQuery;
			xQuery.SetOwner(GetOwner());
			xQuery.SetType("CHTR");
			xQuery.SetType("ANML",true);
			xQuery.SetType("VHCL",true);
			xQuery.SetType("SHIP",true);
			xQuery.SetType("BLDG",true);
			xQuery.SetAttribsPos("level",p_iLevel);
			xQuery.SetAttribsPos("unit_count",true);
			if(pxLevelNode!=null&&!bIsSupplyOn)then
				aiMaxUnits[p_iLevel]=pxLevelNode^.GetValueI("Max",aiMaxUnits[p_iLevel])+iACBonus;
			endif;
//			var ^CAiPlayer pxAiPlayer=cast<CAiPlayer>(CSrvWrap.GetCurLevel()^.GetPlayer(GetOwner()));
//			if(pxAiPlayer!=null)then
//				var ^CLevelInfo.CPlayerSlot pxPlayerSlot=pxAiPlayer^.GetPlayerSlot();
//				if(pxPlayerSlot!=null)then
//					var int iDff=pxPlayerSlot^.GetValueInt("Difficulty");
//					if(iDff==7)then
//						aiMaxUnits[0]+=4;
//						aiMaxUnits[1]+=3;
//						aiMaxUnits[2]+=2;
//						aiMaxUnits[3]+=0;
//						aiMaxUnits[4]+=0;
//					elseif(iDff==8)then
//						aiMaxUnits[0]+=10;
//						aiMaxUnits[1]+=7;
//						aiMaxUnits[2]+=4;
//						aiMaxUnits[3]+=1;
//						aiMaxUnits[4]+=0;
//					elseif(iDff==9)then
//						aiMaxUnits[0]+=20;
//						aiMaxUnits[1]+=10;
//						aiMaxUnits[2]+=8;
//						aiMaxUnits[3]+=3;
//						aiMaxUnits[4]+=0;
//					endif;
//				endif;
//			endif;
			//Henry: to disable the change from levels settings
			var CObjList xList;
			xQuery.Execute(xList);
//			var int i,iC=xList.NumEntries();
//			for(i=0)cond(i<iC)iter(i++)do
//			endfor;
			if(bIsSupplyOn)then
				// do nothing
			elseif((xList.NumEntries()+iVirtualUnits)>=aiMaxUnits[p_iLevel])then
				return false;
			elseif((xList.NumEntries()+iVirtualUnits+iCount)>=aiMaxUnits[p_iLevel])then
				bDelPyCO=true;
			endif;
		end CheckLevelLimit;
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel==null)then return false; endif;
		var ^CAttribs pxPlAttr=pxLevel^.GetPlayer(GetOwner())^.GetAttribs();
		if(pxPlAttr==null)then return false; endif;
		var int iValue=pxPlAttr^.GetValueInt("iron");
		var int iCosts =0;
		begin CheckLevelResources;
			if(p_iLevel>m_iLevel)then
//				var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
//				var ^CAttribs pxPlAttr=pxLevel^.GetPlayer(GetOwner())^.GetAttribs();
//				var int iValue=pxPlAttr^.GetValueInt("iron");
//				var int iCosts =0;
				var int i, iC=p_iLevel - m_iLevel;
				for(i=0)cond(i<iC)iter(i++)do
					iCosts += pxPlAttr^.GetValueInt("foodcost_lvl_"+(m_iLevel+i+1).ToString());
				endfor;
				if(iValue<iCosts)then
					return false;
				endif;
			endif;
		end CheckLevelResources;
		if(!SetLevelClean(p_iLevel))then return false; endif;
		if(!bDemoting)then
			iValue-=iCosts;
			pxPlAttr^.SetValue("iron",iValue);
		endif;
		GetBestWeapon(null, true); //update current weapon
		if(iOldLevel<p_iLevel)then
			DoLevelUpAnim();
			FullHeal();
			SetDestructLevel(0); // RT#15411
		elseif(bDemoting)then
			SetDemoteEffect(true,60.0f);
		endif;
		if(bDelPyCO && xDelete.IsValid())then
			GetAttribs()^.SetValue("ac_successor",sPyCO);
			var vec3 vTmp;
			xDelete.GetObj()^.HandleGamePlayCommand("remove_pre_pyco",null,vTmp,"");
		endif;
		return true;
	endproc;
	
	export proc bool SetLevelClean(int p_iLevel)
		var bool bDemoting=p_iLevel<m_iLevel;
		if(m_bDemoteEffect&&!bDemoting)then return false; endif;
//		var ^CBasePlayer pxBPl=CBasePlayer.GetPlayer(m_iOwnerID);
//		if(pxBPl==null)then return false; endif;
//		var ^CAttribs pxPlAttr=pxBPl^.GetAttribs();
//		if(pxPlAttr==null)then return false; endif;
		if(GetAttribs()^.GetValueBool("unique"))then
			SetFormationPriorityCenter2Side(0.0);
		else
			SetFormationPriorityCenter2Side(1.0 - (p_iLevel.ToReal()/5.0));
		endif;
		if(m_iLevel==p_iLevel)then return false; endif;
		if((p_iLevel<0)||(p_iLevel>4))then return false; endif;
		SetLevelFilter(false);
		if(cast<CHero>(this)==null)then
			SetLevelFilter(false,"Filters/"+GetTribeName()+"/Upgrades/AllNonHeroes/Lvl"+(m_iLevel+1).ToString());
		endif;
		if(DoesCountInUnitLimit())then
			var ^CBasePlayer pxBPl=CBasePlayer.GetPlayer(m_iOwnerID);
			if(pxBPl!=null)then
				var ^CAttribs pxPlAttr=pxBPl^.GetAttribs();
				if(pxPlAttr!=null)then
				var string sLvlAttr="objects_lvl_"+m_iLevel.ToString();
				pxBPl^.SetAttribs(sLvlAttr,pxPlAttr^.GetValueInt(sLvlAttr)-1);
				sLvlAttr="objects_lvl_"+p_iLevel.ToString();
				pxBPl^.SetAttribs(sLvlAttr,pxPlAttr^.GetValueInt(sLvlAttr)+1);
				endif;
			endif;
		endif;
		m_iLevel=p_iLevel;
		SetLevelFilter(true);
		if(cast<CHero>(this)==null)then
			SetLevelFilter(true,"Filters/"+GetTribeName()+"/Upgrades/AllNonHeroes/Lvl"+(m_iLevel+1).ToString());
		endif;
		GetAttribs()^.SetValue("level",m_iLevel);
		var ^CInventory pxInventory=GetInventory();
		if(pxInventory!=null)then
			pxInventory^.SetSize(1);
		endif;
		GetWeaponMgr()^.UpdateAll();
		OnTechTreeChange();
		return true;
	endproc;
	
	export proc void DoLevelUpAnim()
		var string sCurTask=GetCurTaskName();
		if(!GetTransportObj().IsValid()&&!GetOnWall()&&!IsTrapped()&&sCurTask!="Jetpack"&&sCurTask!="Jumpjet"&&sCurTask!="Finish"&&sCurTask!="SpecSuitJ"&&sCurTask!="PilotFly")then
			var string sAnim="level_up";
			if(HasAnim(sAnim))then
				AnimAction(sAnim);
			endif;
		endif;
		if(HasTimer(TIMER_LEVELUP_INV))then
			DeleteTimer(TIMER_LEVELUP_INV);
		endif;
		m_bLevelUpInvulnerable=true;
		CreateTimer(CFightingObj.TIMER_LEVELUP_INV, CGameTimeSpan.OneSecond()*1.5, false);
		InvokeGenericSCEvent(35,1.0f);
	endproc;
	
	export proc void SetUnique(bool p_bUnique)
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			var bool bUnique=pxAttr^.GetValueBool("unique");
			if(bUnique!=p_bUnique)then
				pxAttr^.SetValue("unique",p_bUnique);
			endif;
		endif;
	endproc;
	
	///////
	//	GetHitpoints()
	///////
	export proc real GetHitpoints()
		return(m_fHitpoints);
	endproc;
	
	export proc real GetMaxHitpoints()
		return m_fMaxHitpoints;
	endproc;
	
	proc void SetMaxHitpoints(real p_fMaxHitpoints)
		m_fMaxHitpoints=p_fMaxHitpoints;
		UpdateHitpoints();
	endproc;
	
	export proc void SetHitpoints(real p_fHitpoints)
		if(m_fHitpoints!=p_fHitpoints)then
			if(m_bDivideSkulls)then
				var real fDiff=m_fHitpoints-p_fHitpoints;
				if(fDiff>0.0)then
					var int i;
					for(i=0)cond(i<9)iter(i++)do
						m_afDamagePortion[i]=Math.Max(m_afDamagePortion[i]-fDiff,0.0);
					endfor;
				endif;
			endif;
			m_fHitpoints=p_fHitpoints;
			UpdateHitpoints();
		endif;
	endproc;
	
	export proc bool IsSeriouslyInjured()
		return (m_fHitpoints<(m_fMaxHitpoints*0.5f));
	endproc;
	
	///////
	//	GetPlayerTribeName()
	//	this returns a tribe of the player if one present.
	///////
	export proc string GetPlayerTribeName()
		var ^CBasePlayer pxBasePlayer=CBasePlayer.GetPlayer(GetOwner());
		if(pxBasePlayer!=null)then
			return pxBasePlayer^.m_sTribe;
		endif;
		return "";
	endproc
	
	///////
	//	GetTribeName()
	//	this can vary from players tribe
	///////
	export proc string GetTribeName()
		if(m_sTribe.IsEmpty())then
			m_sTribe=GetPlayerTribeName();
			var ^CAttribs pxAttribs=GetAttribs();
			if(pxAttribs!=null)then
				pxAttribs^.SetValue("tribe",m_sTribe);
			endif;
		endif;
		return m_sTribe;
	endproc
	
	proc void OnObjClassChange()
		UpdateObjPath();
	endproc;
	
	///////
	//	GetBestWeapon()
	///////
	export proc void GetBestWeapon()
		GetBestWeapon(null, true);
	endproc;
	
	export proc void GetBestWeapon(^CFightingObj p_pxEnemy, bool p_bUpdate)
		if(p_bUpdate)then
			m_pxWeaponMgr^.UpdateAll();
		endif;
		UpdateEquipment();
	endproc;
	
	proc bool CompareCaste(string p_sCastes)
		return true;
	endproc;
	
	proc bool MustHaveUser()
		return true;
	endproc;
	
	///////
	//	ExamineFlags()
	///////
	export proc void ExamineFlags()
		if(GetOwner()==-1)then return; endif;
		if(m_xTechTree.GetValueI("/Objects/"+GetPlayerTribeName()+"/InventObjects/BLDG_res_back/invented", 0)!=0)then
			m_bBLDGResBack=true;
		else
			m_bBLDGResBack=false;
		endif;
		if(m_xTechTree.GetValueI("/Objects/"+GetPlayerTribeName()+"/InventObjects/SHIP_res_back/invented", 0)!=0)then
			m_bSHIPResBack=true;
		else
			m_bSHIPResBack=false;
		endif;
		//Henry: to make possible more awesome Global bonuses for heroes :D
		if(m_xTechTree.GetValueI("/Objects/"+GetPlayerTribeName()+"/InventObjects/ANML_res_back/invented", 0)!=0)then
			m_bANMLResBack=true;
		else
			m_bANMLResBack=false;
		endif;
		if(m_xTechTree.GetValueI("/Objects/"+GetPlayerTribeName()+"/InventObjects/CHTR_res_back/invented", 0)!=0)then
			m_bCHTRResBack=true;
		else
			m_bCHTRResBack=false;
		endif;
		if(m_xTechTree.GetValueI("/Objects/"+GetPlayerTribeName()+"/InventObjects/VHCL_res_back/invented", 0)!=0)then
			m_bVHCLResBack=true;
		else
			m_bVHCLResBack=false;
		endif;
		var int iOwner=GetOwner()+1;
		CMirageSrvMgr.Get().SetANMLResBack(iOwner, m_bANMLResBack);
		CMirageSrvMgr.Get().SetBLDGResBack(iOwner, m_bBLDGResBack);
		CMirageSrvMgr.Get().SetCHTRResBack(iOwner, m_bCHTRResBack);
		CMirageSrvMgr.Get().SetSHIPResBack(iOwner, m_bSHIPResBack);
		CMirageSrvMgr.Get().SetVHCLResBack(iOwner, m_bVHCLResBack);
	endproc;
	
	///////
	//	UpdateGfxFlags()
	///////
	export proc void UpdateGfxFlags()
	endproc;
	
	///////
	//	UpdateFormationAttribs()
	///////
	proc void UpdateFormationAttribs()
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr==null)then return; endif;
		if(!CanSwim()&&!CanWalk()&&!CanFly())then return; endif;
		var real fTTFormPosY=m_xTechTree.GetValueR(GetObjPath()+"/formation_pos",-1.0f);
		var real fDmg = GetDmg();
		var real fRange = m_fAttackRange;
		var real fDef = GetProtection();
		var real fRangedDef = GetRangedProtection();
		var real fHP = GetMaxHitpoints();
		var real fY;
		var real fX;
		var real fEG = GetMaxEnergy();
		//get relative hitpoints including defense
		fX=(100.0 * fHP) / (Math.Clamp((100.0-fDef),1.0,100.0));
		fX=1.0 - Math.Min(fX / 3000.0,1.0);
		fY=((fRange+1.0f)/75.0f)-fDmg/10000.0f;
		if(fTTFormPosY>=0.0f)then fY=fTTFormPosY; endif;
		fY=Math.Clamp(fY,0.0f,1.0f);
		//KLog.LogWarn("CHP",GetName()+" X:"+fX.ToString()+" Y:"+fY.ToString()+" Dmg:"+fDmg.ToString());
		if(fX!=pxAttr^.GetValueFloat("formation_x"))then
			pxAttr^.SetValue("formation_x",fX);
		endif;
		if(fY!=pxAttr^.GetValueFloat("formation_y"))then
			pxAttr^.SetValue("formation_y",fY);
		endif;
	endproc;
	
	///////
	//	UpdateAggressionPos()
	///////
	export proc void UpdateAggressionPos(vec3 p_vPos)
		m_vAggressionPos=p_vPos;
	endproc;
	
	export proc void SetPos(vec3 p_vPos)
		UpdateAggressionPos(p_vPos);
		super.SetPos(p_vPos);
	endproc;
	
	///////
	//	GetTechTreeHitpoints()
	///////
	export proc real GetTechTreeHitpoints()
		var string sObjPath=GetObjPath();
		var real fHitpoints=m_xTechTree.GetValueR(sObjPath+"/hitpoints",100.0);
		if(m_bIsWildAnimal)then
			fHitpoints+=GetWildAnimalHPBonus(GetLevel());
		endif;
		fHitpoints *= GetTechTreeModifier("Hitpoints",true);
		fHitpoints += GetTechTreeModifier("Hitpoints",false);
		fHitpoints *= GetClassTechTreeModifier("Hitpoints",true);
		fHitpoints += GetClassTechTreeModifier("Hitpoints",false);
		return fHitpoints;
	endproc;
	
	///////
	//	Healing Stuff
	///////
	
	export proc real GetHealingRadius()
		var ^CFightingObj.CSpecialAbility pxA=m_xAbilities.GetAbility("heal", true);
		var real fValue=-1.0;
		if(pxA!=null)then
			fValue=pxA^.GetValueF("radius");
		endif;
		var ^CAttribs pxAttr=GetAttribs();
		if(GetType()!="BLDG"&&pxAttr!=null)then
			var bool bValue=(fValue>0.0);
			if(pxAttr^.GetValueBool("healer")!=bValue)then
				pxAttr^.SetValue("healer",bValue);
			endif;
		endif;
		return fValue;
	endproc;
	
	export proc real GetHealingAmount(^CFightingObj p_pxTarget)
		var ^CFightingObj.CSpecialAbility pxA=m_xAbilities.GetAbility("heal", true);
		if(pxA==null)then return 0.0; endif;
		//if(m_xTechTree.GetValueI("MiscValues/"+GetPlayerTribeName()+"/No_Healing",0)>0)then return 0.0; endif;
		var real fMod=p_pxTarget^.GetMaxHitpoints() * pxA^.GetValueF("mod") * 0.01;
		var real fAmount= (pxA^.GetValueF("amount") * GetTechTreeModifier("Healing",true))+GetTechTreeModifier("Healing",false);
		return fAmount+fMod;
	endproc;
	
	///////
	//	GetTechTreeValueR()
	///////
	export proc real GetTechTreeValueR(string p_sName, real p_fDefValue)
		var string sObjPath=GetObjPath();
		return(m_xTechTree.GetValueR(sObjPath+"/"+p_sName,p_fDefValue));
	endproc;
	
	export proc int GetTechTreeValueI(string p_sName, int p_iDefValue)
		var string sObjPath=GetObjPath();
		return(m_xTechTree.GetValueI(sObjPath+"/"+p_sName,p_iDefValue));
	endproc;
	
	export proc real GetSelfTimeFactor()
		var real fFactor=m_xTechTree.GetValueR(GetObjPath()+"/timefactor",2.0);
		if(fFactor<=0.0)then
			fFactor=2.0;
		endif;
		return fFactor;
	endproc;
	
	///////
	//	GetTechTreeFlags()
	///////
	export proc void GetTechTreeFlags(ref array string p_rasFlags)
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		var ^CPlayer pxPlayer=pxLevel^.GetPlayer(GetOwner());
		p_rasFlags=0;
		if(pxPlayer!=null)then
			var string sObjPath=GetObjPath();
			var int i;
			for(i=0)cond(i<m_xTechTree.NumSubs(sObjPath+"/flags"))iter(i++)do
				p_rasFlags.AddEntry(m_xTechTree.GetSubAbsPath(sObjPath+"/flags",i));
			endfor;
		else
			CSrvWrap.LogError("FightingObj","GetTechTreeFlags(): Player invalid! Returning no flags!" );
		endif;
	endproc;
	
	///////
	//	GetTechTreeAggressive()
	///////
	export proc int GetTechTreeAggressiv()
		var string sObjPath=GetObjPath();
		//CSrvWrap.LogError("Aggressiv",sObjPath);
		return(m_xTechTree.GetValueI(sObjPath+"/aggressive",0));
	endproc;
	
	///////
	//	GetDirection() - returns direction front,back,left,right
	///////
	export proc bitset GetDirection(vec3 p_vDir)
		var real fLength=p_vDir.Abs();
		if(fLength<0.0001)then return DIR_INVALID; endif;
		p_vDir/=fLength;
		var Quat qRot=GetRot();
		qRot.InvertU();
		qRot.VecRotateU(p_vDir);
		var bool bX=Math.Abs(p_vDir.GetX())>Math.Abs(p_vDir.GetY());
		if(bX)then
			if(p_vDir.GetX()>0.0f)then
				return DIR_LEFT;
			else
				return DIR_RIGHT;
			endif;
		else
			if(p_vDir.GetY()>0.0f)then
				return DIR_FRONT;
			else
				return DIR_BACK;
			endif;
		endif;
	endproc;
	
	///////
	//	GetDirection() - returns direction front,back,left,right,frontleft,frontright,backleft,backright
	///////
	export proc bitset GetDirection8(vec3 p_vDir)
		p_vDir.SetZ(0.0);
		var real fLength=p_vDir.Abs();
		if(fLength<0.0001)then return DIR_INVALID; endif;
		p_vDir/=fLength;
		var Quat qRot=GetRot();
		qRot.InvertU();
		qRot.VecRotateU(p_vDir);
		var real fCP1=0.92387953f; //cos(PI/4-PI/8)
		var real fCP2=0.382683432; //cos(PI/4-PI/8+PI/4)
		var real fX=p_vDir.GetX();
		var real fY=p_vDir.GetY();
		var bool bXN,bYN;
		if(fX<0.0)then bXN=true;fX=-fX; else bXN=false; endif;
		if(fY<0.0)then bYN=true;fY=-fY; else bYN=false; endif;
		var int iQuad;
		if(bXN&&!bYN)then iQuad=0; elseif(!bXN&&!bYN)then iQuad=1; elseif(!bXN&&bYN)then iQuad=2; else iQuad=3; endif;
		var int iXA;
		if(fX>fCP1)then iXA=0; elseif(fX>fCP2)then iXA=1; else iXA=2; endif;
		switch(iQuad)
			case(0)do
				switch(iXA)
					case(0)do return DIR_RIGHT;		endcase;
					case(1)do return DIR_FRONT_RIGHT;	endcase;
					case default do return DIR_FRONT;	endcase;
				endswitch;
			endcase;
			case(1)do
				switch(iXA)
					case(0)do return DIR_LEFT;			endcase;
					case(1)do return DIR_FRONT_LEFT;	endcase;
					case default do return DIR_FRONT;	endcase;
				endswitch;
			endcase;
			case(2)do
				switch(iXA)
					case(0)do return DIR_LEFT;			endcase;
					case(1)do return DIR_BACK_LEFT;	endcase;
					case default do return DIR_BACK;	endcase;
				endswitch;
			endcase;
			case default do
				switch(iXA)
					case(0)do return DIR_RIGHT;		endcase;
					case(1)do return DIR_BACK_RIGHT;	endcase;
					case default do return DIR_BACK;	endcase;
				endswitch;
			endcase;
		endswitch;
	endproc;
	
	///////
	//	GetTaskMgr()
	///////
	export proc ^CTaskMgr GetTaskMgr()
		return m_pxTaskMgr;
	endproc;
	
	export proc ^CTask GetCurTask()
		if(m_pxTaskMgr!=null)then
			return m_pxTaskMgr^.GetCurTask();
		endif;
		return null;
	endproc;
	
	export proc string GetCurTaskName()
		if(m_pxTaskMgr!=null)then
			return m_pxTaskMgr^.GetCurTaskName();
		endif;
		return "";
	endproc;
	
	///////
	//	DoGetHitReaction()
	///////
	proc void DoGetHitReaction()
		if(m_bNoHitReaction)then return; endif;
		if(ResistantToThrow())then return; endif;
		if(GetOnWall())then return; endif;
		var string sHitAnim="hit_back";
		if(!HasAnim(sHitAnim))then return; endif;
		var bitset dwDir=GetDirection(m_vHitReactionDir);
//		if(dwDir==DIR_FRONT)then sHitAnim="hit_front";
//		elseif(dwDir==DIR_BACK)then sHitAnim="hit_back";
//		elseif(dwDir==DIR_LEFT)then sHitAnim="hit_left";
//		elseif(dwDir==DIR_RIGHT)then sHitAnim="hit_right";
//		else
////			CSrvWrap.LogError("FightingObj","invalid direction vector: "+m_vHitReactionDir.ToString());
//			return;
//		endif;
		var vec3 vImpulse=m_vHitReactionDir;
		//L CSrvWrap.LogSpam("FightingObj","Hier passiert der Bug: "+vImpulse.ToString()+" "+GetName());
		var string sGetUpAnim="getting_up";
		if(m_fHitpoints<=0.0f||IsDead())then
			sGetUpAnim="";
		endif;
		if(m_bResurrecting)then
//			var ^CTask pxTask=m_pxTaskMgr^.GetCurTask();
//			if(pxTask!=null)then
//				if(pxTask^.Break())then
//					pxTask^.EndTask();
//				endif;
//			endif;
			if(m_pxTaskMgr!=null)then
				m_pxTaskMgr^.BreakAll();
			endif;
		endif;
		FallActionDest(GetPos()+vImpulse,sHitAnim,sGetUpAnim,0.0);
		ToTheGround(3.0);
	endproc;
	
	///////
	//	SetHitReactionTimer()
	///////
	export proc void SetHitReactionTimer(real p_fSecs,vec3 p_vDir)
		if(IsJetPackOn() || IsFlyingUnit() || GetOnWall())then return; endif;
		var string sCurTask=GetCurTaskName();
		if(sCurTask=="Jetpack" || sCurTask=="SpecSuitJ" || sCurTask=="PilotFly")then return; endif;
		if(HasTimer(TIMER_GETHITREACTION))then return; endif; //gibt's schon
		CreateTimer(TIMER_GETHITREACTION, CGameTimeSpan.OneSecond()*p_fSecs,false);
		m_vHitReactionDir=p_vDir;
	endproc;
	
	export proc void OnKill()
		if(m_bScalpsGiven)then return; endif;
		var int iOwner=m_iLastDamage+1;
		if(GetType()=="ANML"&&CMirageSrvMgr.Get().GetANMLResBack(iOwner))then
			GrantResources(m_iLastDamage,1.0);
		endif;
		if(GetType()=="BLDG"&&CMirageSrvMgr.Get().GetBLDGResBack(iOwner))then
			GrantResources(m_iLastDamage,1.0);
		endif;
		if(GetType()=="CHTR"&&CMirageSrvMgr.Get().GetCHTRResBack(iOwner))then
			GrantResources(m_iLastDamage,1.0);
		endif;
		if(GetType()=="SHIP"&&CMirageSrvMgr.Get().GetSHIPResBack(iOwner))then
			GrantResources(m_iLastDamage,1.0);
		endif;
		if(GetType()=="VHCL"&&CMirageSrvMgr.Get().GetVHCLResBack(iOwner))then
			GrantResources(m_iLastDamage,0.5);
		endif;
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		var ^CStatisticMgr pxStatisticMgr=^(pxLevel^.GetStatisticMgr());
		var CGameTime xTime=CTimeMgr.Get().GetTime();
		iOwner=GetOwner();
		CSrvWrap.GetGameLogger().Log("UnitLost",iOwner.ToString(),GetClassName());
		if(iOwner>-1)then
			var ^CBasePlayer pxOwner=CBasePlayer.GetPlayer(iOwner);
			if(pxOwner!=null)then
				pxOwner^.SetLastDamage(m_iLastDamage);
			endif;
		endif;
		// give skulls
		var ^CBasePlayer pxEnemyBasePlayer=cast<CBasePlayer>(pxLevel^.GetPlayer(m_iLastDamage));
//		var ^CBasePlayer pxOwner=cast<CBasePlayer>(CSrvWrap.GetCurLevel()^.GetPlayer(GetOwner()));
		if((pxEnemyBasePlayer!=null/*||pxOwner!=null*/) /*&& m_iLastDamage!=GetOwner()*/)then
			var int iScalpValue=GetScalpValue()+GetKillerCount()-m_iKillerHistory;
//			if(GetMirageFlag(MIRAGE_SKULL_PROTECT))then
////				pxOwner^.AddScalps(iScalpValue);
//			elseif(m_iLastDamage!=GetOwner())then
			if(m_bDivideSkulls)then
				var real fTotal=0.0f, fHighest=0.0f;
				var int i, iC=9, iHighest=0;
				var array int aiIDs;
				for(i=1)cond(i<iC)iter(i++)do
					if((i!=(iOwner+1))&&(m_afDamagePortion[i]>0.0)&&(!CMirageSrvMgr.ms_abSkipAtDivision[i]))then
						fTotal+=m_afDamagePortion[i];
						aiIDs.AddEntry(i);
						if(m_afDamagePortion[i]>fHighest)then
							fHighest=m_afDamagePortion[i];
							iHighest=i;
						endif;
					endif;
				endfor;
				iC=aiIDs.NumEntries();
				if(iC>0)then
					var int iTmp, iStarting=iScalpValue;
					var ^CBasePlayer pxEBP;
					for(i=0)cond(i<iC)iter(i++)do
						iTmp=(Math.Round((iStarting.ToReal())*(m_afDamagePortion[aiIDs[i]]/fTotal))).ToInt();
						if(iTmp>iScalpValue)then iTmp=iScalpValue; endif;
						pxEBP=cast<CBasePlayer>(pxLevel^.GetPlayer((aiIDs[i]-1)));
						if(pxEBP!=null)then
							pxEBP^.AddScalps(iTmp);
						endif;
						iScalpValue-=iTmp;
					endfor;
					if(iScalpValue>0)then
						if(!CMirageSrvMgr.ms_abSkipAtDivision[m_iLastDamage+1])then
							pxEnemyBasePlayer^.AddScalps(iScalpValue);
						else
							pxEBP=cast<CBasePlayer>(pxLevel^.GetPlayer((iHighest-1)));
							if(pxEBP!=null)then
								pxEBP^.AddScalps(iScalpValue);
							endif;
						endif;
					endif;
					if(pxEnemyBasePlayer^.IsDefender())then
						SlayerBonus(pxEnemyBasePlayer,CMirageSrvMgr.ms_fBounty);
					endif;
				else
					if(m_iLastDamage!=iOwner)then
						if(pxEnemyBasePlayer^.IsDefender())then
							SlayerBonus(pxEnemyBasePlayer,CMirageSrvMgr.ms_fBounty);
						endif;
						pxEnemyBasePlayer^.AddScalps(iScalpValue);
					endif;
				endif;
			else
				if(m_iLastDamage!=iOwner)then
					if(pxEnemyBasePlayer^.IsDefender())then
						SlayerBonus(pxEnemyBasePlayer,CMirageSrvMgr.ms_fBounty);
					endif;
					pxEnemyBasePlayer^.AddScalps(iScalpValue);
				endif;
			endif;
			if(IsTradeUnit()&&(m_iLastDamage!=iOwner))then
				var int iFood=0,iWood=0,iStone=0;
				GetLastResis(iFood,iWood,iStone);
				pxEnemyBasePlayer^.AddResource("food",iFood.ToReal(),false);
				pxEnemyBasePlayer^.AddResource("wood",iWood.ToReal(),false);
				pxEnemyBasePlayer^.AddResource("stone",iStone.ToReal(),false);
//				pxEnemyBasePlayer^.AddFood(iFood);
//				pxEnemyBasePlayer^.AddWood(iWood);
//				pxEnemyBasePlayer^.AddStone(iStone);
			endif;
			m_bScalpsGiven=true;
//			pxStatisticMgr^.AddSample( CStatisticSample.Collected_Skulls.ToInt(), m_iLastDamage, GetScalpValue() );
		endif;
		//IDEA: give different killercount values depending on attribs, like size, maxhitpoints, etc
		if(m_xLastEnemy.IsValid()/*&&m_xLastEnemy.GetObj()!=null*/)then
			var ^CFightingObj pxFObj =cast<CFightingObj>(m_xLastEnemy.GetObj());
			if(pxFObj!=null)then
				pxFObj^.AddKillerCount(1);
			endif;
		endif;
		// store our death in the statistics
		if((iOwner==-1)&&(GetType()=="ANML"))then
			pxStatisticMgr^.AddSample( CStatisticSample.KilledAnimals.ToInt(), m_iLastDamage, 1 );
		elseif(GetType()=="BLDG")then
			if(m_iLastDamage!=iOwner)then
				pxStatisticMgr^.AddSample( CStatisticSample.RazedBuildings.ToInt(), m_iLastDamage, 1 );
			endif;
			var string sTribe=GetTribeName();
			var string sObjClass=GetClassName();
			var string sCategory="";
			var string sPath="/Actions/"+sTribe+"/Build/BLDG/"+sObjClass+"/locations/0/uiposition/subcat";
			sCategory=GetTechTree().GetValueS(sPath,"default");
			if(sCategory=="ECON" /* Testen ob das Gebäude ECON ist */ )  then
				pxStatisticMgr^.AddSample(CStatisticSample.EcoBuildings.ToInt(), iOwner, -1);
			endif;
			if(sCategory=="COMB"/* Testen ob das Gebäude COMB ist */ )  then
				pxStatisticMgr^.AddSample(CStatisticSample.MilBuildings.ToInt(), iOwner, -1);
			endif;
			if(sCategory=="DEFE" /* Testen ob das Gebäude DEFE ist */ )then
				if(GetClassName().Find("palisade")==-1)then
					pxStatisticMgr^.AddSample(CStatisticSample.DefBuildings.ToInt(), iOwner, -1);
				endif;
			endif;
		else
			if(m_iLastDamage!=iOwner)then
				if(CountInStatistic())then
					pxStatisticMgr^.AddSample(CStatisticSample.KilledEnemies.ToInt(), m_iLastDamage, 1);
				endif;
			endif;
			if(DoesCountInUnitLimit())then
				if(CountInStatistic())then
					pxStatisticMgr^.AddUnit(iOwner, GetClassName(), GetType(), -1);
				endif;
			endif;
		endif;
	endproc;
	
	export proc void Damage(real p_fDamage)
		if(m_bGodMode||m_bCeaseFire)then return;endif;
		if(m_bSlaveInvincible)then return;endif;
		if(m_bLevelUpInvulnerable)then return; endif;
		if(HasTimer(TIMER_ANML_IMMUNITY))then return; endif;
		//Henry: to make unit invincible in other cases as well
		if(m_bStolen)then return; endif;
		if(m_bFountainHealed||m_bResurrectSafety)then return; endif;
		if(GetType()=="ANML"&&HasTimer(TIMER_SANCTIFICATION))then
			DeleteTimer(TIMER_SANCTIFICATION);
			if(!IsInFight())then
				CreateTimer(TIMER_SANCTIFICATION, CGameTimeSpan.OneSecond() * 5.0, false);
			endif;
		endif;
		HPReduction(Math.Max(Math.Ceil(p_fDamage*m_fDefenseFactor),1.0), m_iLastDamage);
	endproc;
	
	///////
	//	TakeDmg()
	///////
	export proc void ClearDamageCache()
		m_xDmgCache.m_pxLastEnemy=null;
		m_xDmgCache.m_fDamage=0.0;
		m_xDmgCache.m_pxLastBUOwner=null;
		m_xDmgCache.m_fBuildUpDamage=0.0;
		m_xDmgCache.m_pxLastBUOExtra=null;
		m_xDmgCache.m_fBUDExtra=0.0;
		m_bWeaponHasChanged=true;
		m_bOwnWeaponHasChanged=true;
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy)
		if(p_pxEnemy!=null)then
			return TakeDmg(p_pxEnemy, !(p_pxEnemy^.GetProjectile().IsEmpty()), p_pxEnemy^.GetAttackFactor(), p_pxEnemy^.GetHitDelay());
		endif;
		return TakeDmg(p_pxEnemy, false, 1.0);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile)
		if(p_pxEnemy!=null)then
			return TakeDmg(p_pxEnemy, p_bProjectile, p_pxEnemy^.GetAttackFactor(), p_pxEnemy^.GetHitDelay());
		endif;
		return TakeDmg(p_pxEnemy, p_bProjectile, 1.0);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy,real p_fFactor)
		if(p_pxEnemy!=null)then
			return TakeDmg(p_pxEnemy, !(p_pxEnemy^.GetProjectile().IsEmpty()), p_fFactor, p_pxEnemy^.GetHitDelay());
		endif;
		return TakeDmg(p_pxEnemy, false, p_fFactor, 0.7);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile, real p_fFactor)
		if(p_pxEnemy!=null)then
			return TakeDmg(p_pxEnemy, p_bProjectile, p_fFactor, p_pxEnemy^.GetHitDelay());
		endif;
		return TakeDmg(p_pxEnemy, p_bProjectile, p_fFactor, 0.7);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile, real p_fFactor, real p_fHitDelay)
		if(p_pxEnemy!=null)then
			return TakeDmg(p_pxEnemy, p_bProjectile, p_fFactor, p_fHitDelay, p_pxEnemy^.GetArmorPiercing());
		endif;
		return TakeDmg(p_pxEnemy, p_bProjectile, p_fFactor, p_fHitDelay, 0.0);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile, real p_fFactor, real p_fHitDelay, real p_fArmorpiercing)
		if(p_bProjectile && m_bDarkSwarm)then return 0.0; endif;
		if(GetEffectFlag(EFFECT_AJE_CAMOUFLAGE))then
			TerminateAction();
			SetEffectFlag(EFFECT_AJE_CAMOUFLAGE, false);
		endif;
		if(p_pxEnemy==null)then return 0.0; endif;
		//Kr1s1m: invulnerable units should not take damage:
		//if(p_pxEnemy^.GetInvulnerable() > 0 || p_pxEnemy^.GetLDInvulnerable())then return 0.0; endif;
		if(GetOnWall())then return 0.0; endif;
		//Henry: flying unit won't suffer damage by units which can't fight air (TODO: make a bigger and better list of those units...)
		if((m_bFlyingUnit&&!p_pxEnemy^.CanShootAir())||GetTransportObj().IsValid())then
			return 0.0;
		endif;
		if(HasTimer(TIMER_ANML_IMMUNITY))then
//			if(p_pxEnemy^.GetType()=="ANML")then
				return 0.0;
//			endif;
		endif;
		UpdateFightFactors();
		var real fDamage=0.0f;
		if(m_xDmgCache.m_pxLastEnemy==p_pxEnemy&&m_xDmgCache.m_fDamage>0.0f&&!p_pxEnemy^.WeaponHasChanged()&&!OwnWeaponHasChanged())then
			fDamage=m_xDmgCache.m_fDamage;
		else
//			if(cast<CCharacter>(this)!=null&&(cast<CCharacter>(this)^.GetTransportObj().IsValid()||cast<CCharacter>(this)^.GetOnWall()))then return 0.0f; endif;
			var real fDmg=0.0f;
			//Henry: the next lines are a little bit extended to allow usage some new Modifications blocks in techtree (like giving a unit a certain bonus/malus against types of enemies, and not only by changing every weapons bonus section...)
			if(!p_bProjectile)then
				fDmg=/*p_fFactor * */((p_pxEnemy^.AddTemporaryAttackBoni(p_pxEnemy^.GetDmg())+(p_pxEnemy^.AddTemporaryMeleeAttackBoni(p_pxEnemy^.GetDmg())-p_pxEnemy^.GetDmg()))
				* (1.0+(p_pxEnemy^.GetAttackBoni().GetBonus(GetType().AsString(),GetClassName())/ 100.0)))
				* p_pxEnemy^.GetTechTreeModifier("Damage_"+GetType().AsString(), true)+p_pxEnemy^.GetTechTreeModifier("Damage_"+GetType().AsString(), false);
			else
				fDmg=/*p_fFactor * */((p_pxEnemy^.AddTemporaryAttackBoni(p_pxEnemy^.GetDmg())+(p_pxEnemy^.AddTemporaryRangedAttackBoni(p_pxEnemy^.GetDmg())-p_pxEnemy^.GetDmg()))
				* (1.0+(p_pxEnemy^.GetAttackBoni().GetBonus(GetType().AsString(),GetClassName())/ 100.0)))
				* p_pxEnemy^.GetTechTreeModifier("Damage_"+GetType().AsString(), true)+p_pxEnemy^.GetTechTreeModifier("Damage_"+GetType().AsString(), false);
			endif;
			if(GetType()=="BLDG")then
				var real fBldgBonus=p_pxEnemy^.GetBonusSum(BONUS_DAMAGE_BLDG);
				if(fBldgBonus>0.0f)then
					var int iTmp=fDmg.ToInt();
					fDmg *= (1.0f+fBldgBonus*0.01f);
					if(fDmg.ToInt()==iTmp)then fDmg+=0.5f; endif;
				endif;
			endif;
			var real fDefense;
//			var real fArmorPiercing=p_pxEnemy^.GetArmorPiercing();
			var real fArmorPiercing=p_fArmorpiercing;
//			if(p_pxEnemy^.GetProjectile().IsEmpty())then
//				fDefense=fDmg * Math.Clamp((AddTemporaryDefenseBoni(Math.Max(0.0,(GetProtection()-fArmorPiercing)))+((GetDefenseBoni().GetBonus(p_pxEnemy^.GetType().AsString(),p_pxEnemy^.GetClassName())*GetTechTreeModifier("Defence_"+p_pxEnemy^.GetType().AsString(), true)+GetTechTreeModifier("Defence_"+p_pxEnemy^.GetType().AsString(), false))))*0.01, 0.0f, 1.0f);
//			else
//				fDefense=fDmg * Math.Clamp(AddTemporaryRangedDefenseBoni(Math.Max(0.0,(GetRangedProtection()-fArmorPiercing))) * 0.01, 0.0f, 1.0f);
//			endif;
			// Henry: at old method additional defense can be calculated, even if the armor piercing is maximal
			var real fMaxDef=m_fMaxDef*100.0f;
			if(!p_bProjectile)then
				fDefense=fDmg * Math.Clamp(((Math.Clamp(0.0, AddTemporaryDefenseBoni(GetProtection()),fMaxDef)-fArmorPiercing)+((GetDefenseBoni().GetBonus(p_pxEnemy^.GetType().AsString(),p_pxEnemy^.GetClassName())*GetTechTreeModifier("Defence_"+p_pxEnemy^.GetType().AsString(), true)+GetTechTreeModifier("Defence_"+p_pxEnemy^.GetType().AsString(), false))))*0.01, 0.0f, m_fMaxDef);
			else
//				fDefense=fDmg * Math.Clamp((Math.Clamp(0.0, AddTemporaryRangedDefenseBoni(GetRangedProtection()),fMaxDef)-fArmorPiercing) * 0.01, 0.0f, m_fMaxDef);
				fDefense=fDmg * Math.Clamp(((Math.Clamp(0.0, AddTemporaryRangedDefenseBoni(GetRangedProtection()),fMaxDef)-fArmorPiercing)+((GetRangedDefenseBoni().GetBonus(p_pxEnemy^.GetType().AsString(),p_pxEnemy^.GetClassName())*GetTechTreeModifier("RangedDef_"+p_pxEnemy^.GetType().AsString(), true)+GetTechTreeModifier("RangedDef_"+p_pxEnemy^.GetType().AsString(), false)))) * 0.01, 0.0f, m_fMaxDef);
			endif;
			fDamage=fDmg-fDefense;
			fDamage=fDamage*p_pxEnemy^.m_fAttackFactor;
			m_xDmgCache.m_pxLastEnemy=p_pxEnemy;
			m_xDmgCache.m_fDamage=fDamage;
			if(fDamage>0.0f)then
				CFeedbackEventMgr.Get().AddAttackEvent(GetHandle(),GetOwner());
			endif;
		endif;
		fDamage*=p_fFactor;
		//Henry: Tarna and aje liopleurodon gets freezing ability too
		if(p_pxEnemy^.GetClassName()=="ninigi_icespearman"||p_pxEnemy^.GetClassName()=="Tarna_s0"/*||p_pxEnemy^.GetClassName()=="aje_liopleurodon"*/)then
			SetIced(p_pxEnemy^.GetGlacialEpoch(),p_pxEnemy^.GetIceMelting());
		endif;
	
//		if(m_bMirroring)then
//			if(fDamage>0.0f)then
//				p_pxEnemy^.MirrorDmg(fDamage, p_fHitDelay, GetHandle(), p_pxEnemy^.GetProjectile()!="", p_pxEnemy^.GetPoisonDmg(), p_pxEnemy^.GetPoisonMaxTickCount(), p_pxEnemy^.GetFireDmg(), p_pxEnemy^.GetBurnTime());
//			endif;
//			return 0.0;
//		endif;
//		if(m_bEvading)then
//			if(!GetPenetration()&&fDamage>0.0f&&p_pxEnemy^.GetProjectile().IsEmpty())then
//				p_pxEnemy^.MirrorDmg(GetDmg(), p_fHitDelay, GetHandle(), false, 0.0, 0, 0.0, 0);
//			endif;
//			return 0.0;
//		endif;
		if(fDamage<=0.0f)then return 0.0; endif;
		//SetDmgTimer
//		if(GetType()=="ANML"||GetType()=="CHTR")then
		if(m_bBiological)then
			var ^CFightingObj.CSpecialAbility pxAb=p_pxEnemy^.m_xAbilities.GetAbility("chunk_flesh", true);
			if(pxAb!=null)then
				p_pxEnemy^.HealMe(fDamage*pxAb^.GetValueF("amount"),false);
			endif;
		endif;
		var ^CTimerIDTick pxTick=new CTimerIDTick();
		pxTick^.m_xOnTickID=ProvideDmg;
		if(p_fHitDelay>0.0)then
			pxTick^.SetTimer(p_fHitDelay);
		endif;
		m_axDmgTimer.NewEntryRef().Init(pxTick^.GetTimer(), fDamage, p_pxEnemy^.GetHandle(), pxTick, p_bProjectile, p_pxEnemy^.GetPoisonDmg(), p_pxEnemy^.GetPoisonMaxTickCount(), p_pxEnemy^.GetFireDmg(), p_pxEnemy^.GetBurnTime());
		//m_axDmgTimer.NewEntryRef().Init(pxTick^.GetTimer(), fDamage, p_pxEnemy^.GetHandle(), pxTick, p_pxEnemy^.GetProjectile()!="", p_pxEnemy^.GetPoisonDmg(), p_pxEnemy^.GetPoisonMaxTickCount());
		if(p_fHitDelay<=0.0)then
			ProvideDmg(-1);
		endif;
		return 0.0;
	endproc;
	
	export proc void ProvidePoison(real p_fDmg, int p_iMaxCount, CObjHndl p_xSource, int p_iSource)
		if(m_bSlaveInvincible)then return; endif;
		if(IsPoisonImmun())then return; endif;
//		// Henry: ships are taken out, so that dustrider krono and co. can be poisoned
		if(GetType()=="BLDG"||GetType()=="NEST"||GetType()=="VHCL")then return; endif;
//		if(GetType()=="BLDG"||GetType()=="NEST"||GetType()=="VHCL"||GetType()=="SHIP")then return; endif;
		AddRangedBuff("is_poisoned");
		SetPoisonedFlag(true);
		//strong enough to be primary?
		if(m_xPrimaryPoison<=p_fDmg)then
			if(m_xPrimaryPoison>=m_xSecondaryPoison.GetTicksLeft())then
				m_xSecondaryPoison=m_xPrimaryPoison;
			endif;
			m_xPrimaryPoison.SetPoison(p_fDmg, p_iMaxCount, 0, p_xSource, p_iSource);
		//long enough to be secondary?
		elseif(m_xSecondaryPoison<=p_iMaxCount)then
			m_xSecondaryPoison.SetPoison(p_fDmg, p_iMaxCount, 0, p_xSource, p_iSource);
		else
		endif;
	endproc;
	
	proc void DecayPoison()
		if(m_xSecondaryPoison <= 0)then
			RemoveRangedBuff("is_poisoned");
			SetPoisonedFlag(false);
			return;
		endif;
		m_xPrimaryPoison=m_xSecondaryPoison;
		m_xSecondaryPoison.Reset();
	endproc;
	
	export proc ref bool CheckGrantResourcesBLDG()
		return m_bBLDGResBack;
	endproc;
	
	export proc ref bool CheckGrantResourcesSHIP()
		return m_bSHIPResBack;
	endproc;
	
//	export proc void GrantResources(int p_iPlayer)
//		if(IsDead())then return; endif;
//		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
//		if(pxLevel==null)then return; endif;
//		var ^CPlayer pxPlayer=pxLevel^.GetPlayer(p_iPlayer);
//		if(pxPlayer==null)then return; endif;
//		var ^CAttribs pxPlAttr=pxPlayer^.GetAttribs();
//		if(pxPlAttr==null)then return; endif;
//		var ^CBasePlayer pxBasePlayer=cast<CBasePlayer>(pxPlayer);
//		if(pxBasePlayer==null)then return; endif;
//		var CTechTree xPlayerTechTree=pxPlayer^.GetPlayerTechTree();
//		var ^CTechTree.CNode pxPlayerResources=xPlayerTechTree.FindNode("Resources/"+pxBasePlayer^.m_sTribe);
//		if(pxPlayerResources==null)then return; endif;
//		var CTechTreeDef xTTDef;
//		var ^CTechTreeMgr pxTTMgr=CSrvWrap.GetGame().GetTechTreeMgr();
//		var CTechTree xTT=pxTTMgr^.GetTechTree(xTTDef);
//		var ^CTechTree.CNode pxBuildAction=xTT.FindNode(GetBuildAction()+"/conditions");
//		if(pxBuildAction==null)then
//			return;
//		endif;
//		var ^CTechTree.CNode pxResCosts=pxBuildAction^.GetSub("rescosts");
//		if(pxResCosts==null)then return; endif;
//		var int i, iC=pxPlayerResources^.NumSubs();
//		for(i=0)cond(i<iC)iter(i++)do
//			var string sResName=pxPlayerResources^.GetSub(i)^.GetValue();
//			var int iValue=pxResCosts^.GetSubValueI(sResName,0);
//			if(iValue!=0)then
//				var int iPlValue=pxPlAttr^.GetValueInt(sResName);
//				var int iPlMaxValue=pxPlAttr^.GetValueInt("max_"+sResName);
//				//if(iPlValue<iPlMaxValue||CMirageSrvMgr.Get().ResourcesUnlimited())then
//					//pxPlAttr^.SetValue(sResName, Math.Min(iPlValue+iValue, iPlMaxValue));
//					pxPlAttr^.SetValue(sResName, iPlValue+iValue);
//				//endif;
//			endif;
//		endfor;
//	endproc;
	
	export proc void GrantResources(int p_iPlayer)
		GrantResources(p_iPlayer, 1.0f);
	endproc;
	
	export proc void GrantResources(int p_iPlayer, real p_fAmount)
		if(IsDead())then return; endif;
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel==null)then return; endif;
		var ^CBasePlayer pxPlayer=cast<CBasePlayer>(pxLevel^.GetPlayer(p_iPlayer));
		if(pxPlayer==null)then return; endif;
		var ^CAttribs pxPlAttr=pxPlayer^.GetAttribs();
		if(pxPlAttr==null)then return; endif;
		if(!m_bCostsFromAction)then
			UpdateBuildCosts();
		endif;
		var ^CLevelInfoHost pxLevelInfo=CSrvWrap.GetLevelInfo(false);
		if(pxLevelInfo!=null)then
			var ^CLevelInfo.CPlayerSlot pxPlSlot=pxLevelInfo^.GetOwnerPlayerSlot(GetOwner());
			if(pxPlSlot!=null)then
				pxPlayer^.AddResource("food",m_xCosts.m_iFood.ToReal()*p_fAmount,false);
				pxPlayer^.AddResource("wood",m_xCosts.m_iWood.ToReal()*p_fAmount,false);
				pxPlayer^.AddResource("stone",m_xCosts.m_iStone.ToReal()*p_fAmount,false);
				pxPlayer^.AddResource("iron",m_xCosts.m_iSkulls.ToReal()*p_fAmount,false);
//				pxPlayer^.AddWood(m_xCosts.m_iWood);
//				pxPlayer^.AddStone(m_xCosts.m_iStone);
//				pxPlayer^.AddFood(m_xCosts.m_iFood);
//				pxPlayer^.AddSkulls(m_xCosts.m_iSkulls);
			endif;
		endif;
	endproc;
	
	export proc void SlayerBonus(^CBasePlayer p_pxB, real p_fPercent)
		if(IsDead())then return; endif;
		if(p_pxB==null)then return; endif;
		var ^CAttribs pxA=p_pxB^.GetAttribs();
		if(pxA==null)then return; endif;
		if(!m_bCostsFromAction)then
			UpdateBuildCosts();
		endif;
		var ^CLevelInfoHost pxLevelInfo=CSrvWrap.GetLevelInfo(false);
		if(pxLevelInfo!=null)then
			var ^CLevelInfo.CPlayerSlot pxPlSlot=pxLevelInfo^.GetOwnerPlayerSlot(GetOwner());
			if(pxPlSlot!=null)then
				p_pxB^.AddResource("food",(m_xCosts.m_iFood.ToReal())*p_fPercent,false);
				p_pxB^.AddResource("wood",(m_xCosts.m_iWood.ToReal())*p_fPercent,false);
				p_pxB^.AddResource("stone",(m_xCosts.m_iStone.ToReal())*p_fPercent,false);
				p_pxB^.AddResource("iron",(m_xCosts.m_iSkulls.ToReal())*p_fPercent,false);
			endif;
		endif;
	endproc;
	
	export proc void SetBuildAction(string p_sAction)
		m_sMyBuildAction=p_sAction;
	endproc;
	
	export proc ref string GetBuildAction()
		if(m_sMyBuildAction.IsEmpty())then
			var string sBuildPath="/Actions/"+GetTribeName()+"/Build/"+GetType().AsString()+"/"+CMirageSrvMgr.Get().GetBuildAction(GetClassName());
			//var string sBuildPath="/Actions/"+GetTribeName()+"/Build/"+GetType().AsString()+"/"+GetClassName();
			if(m_xTechTree.FindNode(sBuildPath)!=null)then
				m_sMyBuildAction=sBuildPath;
			endif;
		endif;
		return m_sMyBuildAction;
	endproc;
	
	export proc void InvokeAreaThrow(ref vec3 p_rvPos,real p_fRange)
//		InvokeAreaThrow(p_rvPos,p_fRange,GetOwner(),m_iSizeClass);
		InvokeAreaThrow(p_rvPos,p_fRange,GetOwner(),GetWeaponSizeClass());
	endproc;
	
	export proc bool CheckMaxAutoprodDist(CObjHndl p_xObj)
		if(!p_xObj.IsValid())then return false; endif;
		if(MAX_AUTOPROD_DIST<=0)then return true; endif; //disabled
		var vec3 vDest=p_xObj.GetObj()^.GetPos();
		return CSrvWrap.GetPathfinder().CheckShortPathDist(GetOwner(),GetPos(),vDest,MAX_AUTOPROD_DIST);
	endproc;
	
	export proc bool CheckMaxAutoprodDist(vec3 p_vPos)
		if(MAX_AUTOPROD_DIST<=0)then return true; endif; //disabled
		return CSrvWrap.GetPathfinder().CheckShortPathDist(GetOwner(),GetPos(),p_vPos,MAX_AUTOPROD_DIST);
	endproc;
	
	export static proc void InvokeAreaThrow(ref vec3 p_rvPos,real p_fRange,int p_iOwner,int p_iSizeClass)
		var CObjList xEnemies;
		var CObjQuery xQuery;
		var int iOwner=p_iOwner;
		//if(iOwner<0||true)then
		if(iOwner<0)then
			//xQuery.SetOwner(-1);
			xQuery.SetType("CHTR");
			xQuery.SetType("ANML",true);
			xQuery.RegionCircle(p_rvPos,p_fRange);
			xQuery.Execute(xEnemies);
		else
			CSrvWrap.GetDiplomacyMgr().AddMyEnemiesToSearch(p_iOwner, xQuery, false);
			xQuery.SetOwner(-1, true);
			xQuery.SetType("CHTR");
			xQuery.SetType("ANML",true);
			xQuery.RegionCircle(p_rvPos, p_fRange);
			xQuery.Execute(xEnemies);
/*
			var ^CObjList pxList=CSrvWrap.GetObjMgr()^.GetOwnerEnemyList(iOwner);
			if(pxList!=null)then
				pxList^.CopySorted(xEnemies,p_rvPos,p_fRange);
			endif;
*/
		endif;
		if(xEnemies.NumEntries()==0)then return; endif;
		InvokeAreaThrow(p_rvPos,xEnemies,p_iSizeClass);
	endproc;
	
	export static proc void InvokeAreaThrow(ref vec3 p_rvPos,ref CObjList p_rxEnemies,int p_iSizeClass)
		if(p_rxEnemies.NumEntries()==0)then return; endif;
		var vec3 vPT=p_rvPos;
		var int i;
		p_rxEnemies.SortDistance(vPT,true); //begin with farthest, because of getfreepos
		for(i=0) cond(i<p_rxEnemies.NumEntries()) iter(i++)do
			var ^CFightingObj pxEnemy=cast<CFightingObj>(p_rxEnemies[i].GetObj());
			if(pxEnemy!=null&&pxEnemy^.m_iSizeClass>0&&!pxEnemy^.ResistantToThrow())then
				var real fStr;
				if(CalcSizeClassAreaThrow(p_iSizeClass,pxEnemy^.m_iSizeClass,fStr))then
					if(!pxEnemy^.GetTransportObj().IsValid()&&!pxEnemy^.IsJetPackOn()&&!pxEnemy^.IsFlyingUnit())then
//					if(!pxEnemy^.GetTransportObj().IsValid()&&!pxEnemy^.IsFlyingUnit())then
						if(pxEnemy^.GetOnWall())then continue; endif;
						var vec3 vPE=pxEnemy^.GetPos();
						var vec3 vDir=vPE-vPT;
						var real fDist=vDir.Abs();
						if(fDist>0.0)then vDir/=fDist; endif;
						var real fDelay=fDist/20.0;
						var string sCurTask=pxEnemy^.GetCurTaskName();
						if(pxEnemy^.HasAnim("hit_back")&&(sCurTask!="Jetpack")&&(sCurTask!="SpecSuitJ")&&(sCurTask!="PilotFly"))then
							var string sAct=pxEnemy^.GetActionDesc();
							if(sAct!="CActFall")then
								if(pxEnemy^.GetResurrecting())then pxEnemy^.BreakEveryTask(); endif;
								pxEnemy^.m_bThrowImmune=true;
								pxEnemy^.CreateTimer(TIMERID_THROWIMMUNE, CGameTimeSpan.OneSecond()*5.0f, false);
								pxEnemy^.FallActionDest(vPE+vDir*fStr,"hit_back","getting_up",0.0);
								pxEnemy^.ToTheGround(3.0);
							endif;
						endif;
					endif;
				endif;
			endif;
		endfor;
	endproc;
	
	export static proc bool CalcSizeClassAreaThrow(int p_iFighterSize,int p_iEnemySize,ref real po_rfStrength)
		var int iSzDiff=p_iFighterSize-p_iEnemySize;
		if(iSzDiff<3) 			then return false; endif; //Gr÷¯enunterschied<3 Stufen -> keine Reaktion
		if(p_iFighterSize==0) 	then return false; endif; //Fighter hat  0 -> keine Reaktion
		if(p_iEnemySize==0) 	then return false; endif; //Enemy hat  0 -> keine Reaktion
		//po_rfStrength - So weit wird der Gegner weggeschleudert
		var real fStrengthJitter=0.3;	//Zufällige Abweichung der Stärke um +30%
		switch(iSzDiff)
		//******************************* TUNING **********************************//
			case (3)do po_rfStrength=2.0; endcase;
			case (4)do po_rfStrength=3.5; endcase;
			case (5)do po_rfStrength=4.0; endcase;
			case (6)do po_rfStrength=5.5; endcase;
			case (7)do po_rfStrength=6.0; endcase;
			case (8)do po_rfStrength=7.0; endcase;
			case (9)do po_rfStrength=8.0; endcase;
		//******************************* /TUNING **********************************//
			case default do KLog.LogError("FightingObj","CalcSizeClassAreaThrow(...) invalid sizeclass diff:"+iSzDiff.ToString()+" "+p_iFighterSize.ToString()+"/"+p_iEnemySize.ToString()); return false; endcase;
		endswitch;
		if(iSzDiff>9)then po_rfStrength=8.0; endif;
		po_rfStrength+=Random.MTRandF(po_rfStrength*fStrengthJitter);
		return true;
	endproc;
	
	export static proc bool CalcSizeClassThrow(int p_iFighterSize,int p_iEnemySize,ref real po_rfStrength)
		var int iSzDiff=p_iFighterSize-p_iEnemySize;
		if(iSzDiff<3) 			then return false; endif; //Gr÷¯enunterschied<3 Stufen -> keine Reaktion
		if(p_iFighterSize==0) 	then return false; endif; //Fighter hat  0 -> keine Reaktion
		if(p_iEnemySize==0) 	then return false; endif; //Enemy hat  0 -> keine Reaktion
		var real fChance;	//Chance f³r den Wurf 0.0=0%	1.0=100%
		//po_rfStrength - So weit wird der Gegner weggeschleudert
		var real fStrengthJitter=0.2;	//Zufõllige Abweichung der Stõrke um +20%
		switch(iSzDiff)
		//******************************* TUNING **********************************//
			case (3)do fChance=0.02; po_rfStrength=1.0; endcase;
			case (4)do fChance=0.04; po_rfStrength=1.5; endcase;
			case (5)do fChance=0.06; po_rfStrength=2.0; endcase;
			case (6)do fChance=0.08; po_rfStrength=2.5; endcase;
			case (7)do fChance=0.10; po_rfStrength=3.0; endcase;
			case (8)do fChance=0.20; po_rfStrength=4.0; endcase;
			case (9)do fChance=0.30; po_rfStrength=5.0; endcase;
		//******************************* /TUNING **********************************//
			case default do KLog.LogError("FightingObj","CalcSizeClassThrow(...) invalid sizeclass diff:"+iSzDiff.ToString()); return false; endcase;
		endswitch;
//		if(iSzDiff>9)then po_rfStrength=6.0; endif;
		if(iSzDiff>9)then
			po_rfStrength=5.0;
//			po_rfStrength=Math.Clamp((iSzDiff.ToReal()*0.5)+1.0,6.0,10.0);
			fChance=Math.Clamp((iSzDiff.ToReal()*0.03)+0.05,0.35,10.0);
		endif;
		if(fChance<=Random.MTRandF())then
			return false;
		endif; //nicht getroffen
		po_rfStrength+=Random.MTRandF(po_rfStrength*fStrengthJitter);
		return true;
	endproc;
	
	proc void ProvideDmg(int p_iID)
		var int i, iC=m_axDmgTimer.NumEntries();
		var int iIndex=-1;
		for(i=0)cond(i<iC)iter(i++)do
			if(m_axDmgTimer[i].GetTimer()!=p_iID)then continue; endif;
			iIndex=i;
			break;
		endfor;
		if(iIndex==-1)then return; endif;
		var CObjHndl xDamageTick=CObjHndl.Invalid();
		var int iLastEnemy=-1;
		var ^CFightingObj pxEnemy=cast<CFightingObj>(m_axDmgTimer[iIndex].GetSource().GetObj());
		var real fDmg=m_axDmgTimer[iIndex].GetDmg();
		var real fPoisonDmg=m_axDmgTimer[iIndex].GetPoisonDmg();
		var int iPoisonMaxTickCount=m_axDmgTimer[iIndex].GetPoisonMaxTickCount();
		var real fFlameDamage=m_axDmgTimer[iIndex].GetFireDmg();
		var int iFlameTime=m_axDmgTimer[iIndex].GetBurnMaxTickCount();
		if(m_axDmgTimer[iIndex].IsProjectile())then
			if(GetEffectFlag(EFFECT_ITEM_RING))then
				fDmg *= 0.5f;
			endif;
		endif;
		if(GetEffectFlag(EFFECT_ITEM_AMULETT1))then
			fDmg *= 0.5f;
		endif;
		if(pxEnemy==null&&!m_axDmgTimer[iIndex].IsProjectile())then return; endif;
		if(GetInvulnerable()<=0&&!GetLDInvulnerable())then
			if(pxEnemy!=null)then
				xDamageTick=pxEnemy^.GetEnemyHandle();
				iLastEnemy=pxEnemy^.GetOwner();
				m_xLastEnemy=pxEnemy^.GetEnemyHandle();
			endif;
			var bool bDefense=true;
			if(m_pxTaskMgr!=null)then
				var ^CTask pxTask=m_pxTaskMgr^.GetCurTask();
				if(cast<CFlee>(pxTask)!=null)then bDefense=false; endif;
				if(pxEnemy!=null&&bDefense)then
					if(HasTimer(TIMER_PREAGGRO)&&!HasTimer(TIMER_AGGRO))then
						ActivateAggroTimer();
					endif;
					AddEnemy(pxEnemy^.GetHandle(), true);
					pxTask=m_pxTaskMgr^.GetCurTask(); //OnDefend can delete pxTask!!!
				endif;
			endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel!=null)then
				var ^CPlayer pxPlayer=pxLevel^.GetPlayer(GetOwner());
				if(pxPlayer!=null)then
					var ^CBasePlayer pxBasePlayer=cast<CBasePlayer>(pxPlayer);
					if(pxBasePlayer!=null)then
						if(pxEnemy!=null)then
							pxBasePlayer^.IWasAttacked(GetHandle(), pxEnemy^.GetHandle(),pxEnemy^.GetOwner()!=-1);
						endif;
					endif;
				endif;
			endif;
			begin DamageAction;
				if(pxEnemy!=null&&fDmg>=1.0f)then
					var vec3 vPT=GetPos();
					var vec3 vPE=pxEnemy^.GetPos();
					var vec3 vDir=vPT-vPE;
					if(vDir.Abs()>0.0001f)then
						vDir.Normalize();
						vDir.SetZ(vDir.GetZ()+0.5);
						vDir.Normalize();
						var real fThrowStrength=0.0;
						var bool bThrow;
//						if(pxEnemy^.GetClassName()=="aje_rammer")then
//							bThrow=CalcRammerThrow(pxEnemy^.GetLevel(),m_iSizeClass,fThrowStrength);
//						else
//						var bool bThrow=CalcSizeClassThrow(pxEnemy^.m_iSizeClass,m_iSizeClass,fThrowStrength);
							bThrow=CalcSizeClassThrow(pxEnemy^.GetWeaponSizeClass(),m_iSizeClass,fThrowStrength);
//						endif;
						if(bThrow)then
							if(GetTransportObj().IsValid())then
								bThrow=false;
							endif;
							//Fallback: RT#6740
//							if(cast<CCharacter>(this)==null&&cast<CAnimal>(this)==null)then
							if(cast<CCharacter>(this)==null&&cast<CAnimal>(this)==null&&cast<CVehicle>(this)==null)then
								bThrow=false;
							endif;
						endif;
						//var int iSizeClassDiff=(pxEnemy^.m_iSizeClass-m_iSizeClass);
						var bool bSlide=false; //((iSizeClassDiff>=0)&&(Random.GetInt()<(32768/10+iSizeClassDiff*32768/5)));  //10%+iSizeClassDiff*20%
						//var bool bThrow=((iSizeClassDiff>=1)&&(Random.GetInt()<32768/10)); //10%
						begin AlwaysThrowEnemy;
							var int iAlwaysThrowEnemy;
							CSettings.Get("Game/GamePlayOptions/AlwaysThrowEnemy",iAlwaysThrowEnemy);
							if(iAlwaysThrowEnemy!=0)then
								bThrow=true;
							endif;
						end AlwaysThrowEnemy;
						if(ResistantToThrow()||GetOnWall())then
							bThrow=false;
						endif;
						if(bThrow)then
							SetHitReactionTimer(0.4f,vDir*fThrowStrength);
						else
							if(bSlide)then
								//var real fLength=fDmg*0.1f;
								//if(fLength>0.8f)then fLength=0.8f; endif;
								//vDir*=fLength;
								var real fLength=0.6f;
								if(m_iSizeClass==2)then fLength=1.3f;
								elseif(m_iSizeClass==3)then fLength=2.5f; endif;
								SecondaryActionGetHit(vDir,0.75f);	//this is a secondary action and doesn't affect the main action
							endif;
							//KLog.LogError("CHP","hit_reaction");
							//var bitset dwDir=GetDirection8(vDir);
							var bitset dwDir=GetDirection(vDir*-1.0);
							var bitset dwEvt=CObjBase.TSCEvent.EID_Invalid; //invalid events will be skipped
							m_dwLastHitDirection=dwDir;
							if(!m_axDmgTimer[iIndex].IsProjectile())then
								if(dwDir==DIR_FRONT)		then dwEvt=CObjBase.TSCEvent.EID_HitReactionOVLAnim_F; endif;
								if(dwDir==DIR_BACK)		then dwEvt=CObjBase.TSCEvent.EID_HitReactionOVLAnim_B; endif;
								if(dwDir==DIR_LEFT)		then dwEvt=CObjBase.TSCEvent.EID_HitReactionOVLAnim_L; endif;
								if(dwDir==DIR_RIGHT)		then dwEvt=CObjBase.TSCEvent.EID_HitReactionOVLAnim_R; endif;
//								if(dwDir==DIR_BACK_LEFT) 	then dwEvt=CObjBase.TSCEvent.EID_HitReactionOVLAnim_BL; endif;
//								if(dwDir==DIR_BACK_RIGHT) 	then dwEvt=CObjBase.TSCEvent.EID_HitReactionOVLAnim_BR; endif;
//								if(dwDir==DIR_FRONT_LEFT) 	then dwEvt=CObjBase.TSCEvent.EID_HitReactionOVLAnim_FL; endif;
//								if(dwDir==DIR_FRONT_RIGHT)	then dwEvt=CObjBase.TSCEvent.EID_HitReactionOVLAnim_FR; endif;
								if(GetType()!="BLDG"&&GetType()!="VHCL"&&GetType()!="SHIP")then
									//blood effect+hit reaction
									if(!m_xTrap.IsValid())then
										InvokeSCEvent(dwEvt,3.0f);
									endif;
								endif;
								//material effect
								pxEnemy^.InvokeGenericSCEvent(37,0.2f);
							endif;
						endif;
					endif;
				endif;
			end DamageAction;
			begin ItemHandling;
				if(pxEnemy!=null)then
					var string sCur=pxEnemy^.GetCurrentWeapon();
					if(sCur.Find("Items")>=0)then
						var ^CWeaponMgr pxMgr=pxEnemy^.GetWeaponMgr();
						var int iIdx=pxMgr^.FindWeapon(sCur);
						var ^CWeaponDesc pxWeapon=pxMgr^.GetWeapon(iIdx);
						if(pxWeapon!=null&&pxWeapon^.IsSpecialWeapon())then
							pxWeapon^.GetSpecialWeapon()^.OnHit(this);
						endif;
					endif;
				endif;
			end ItemHandling;
			var real fPotentialDmg=Math.Max(Math.Ceil(fDmg),1.0);
			var int iEnemyOwner=-1;
			if(pxEnemy!=null)then
				iEnemyOwner=pxEnemy^.GetOwner();
				m_iLastDamage=pxEnemy^.GetOwner();
			endif;
			if(pxEnemy!=null)then
				var ^CFightingObj.CSpecialAbility pxAb=pxEnemy^.m_xAbilities.GetAbility("drain_life", true);
				if(pxAb!=null)then
					pxEnemy^.HealMe(fDmg*pxAb^.GetValueF("amount"),false);
				endif;
			endif;
			var real fPotentialHitpoints=m_fHitpoints - fPotentialDmg;
			if(fPotentialHitpoints<=0.0&&!IsDead())then
//				if(GetType()=="SHIP"&&pxEnemy!=null&&pxEnemy^.CheckGrantResourcesSHIP())then
//					GrantResources(iEnemyOwner);
//				endif;
//				if(GetType()=="BLDG"&&pxEnemy!=null&&pxEnemy^.CheckGrantResourcesBLDG())then
//					GrantResources(iEnemyOwner);
//				endif;
//				//Henry: Let's try to expand the possibilities (=
//				if(GetType()=="ANML"&&pxEnemy!=null&&pxEnemy^.CheckGrantResourcesANML())then
//					GrantResources(iEnemyOwner);
//				endif;
//				if(GetType()=="CHTR"&&pxEnemy!=null&&pxEnemy^.CheckGrantResourcesCHTR())then
//					GrantResources(iEnemyOwner);
//				endif;
//				if(GetType()=="VHCL"&&pxEnemy!=null&&pxEnemy^.CheckGrantResourcesVHCL())then
//					GrantResources(iEnemyOwner);
//				endif;
//				//Sonderscripting
//				if(GetClassName()=="aje_resource_collector"&&pxEnemy^.CheckGrantResourcesBLDG())then
//					GrantResources(iEnemyOwner);
//				endif;
			endif;
			if(fPoisonDmg>0.0&&iPoisonMaxTickCount>0)then
				ProvidePoison(fPoisonDmg, iPoisonMaxTickCount, xDamageTick, iLastEnemy);
			endif;
			if(fFlameDamage>0.0&&iFlameTime>0)then
				IgniteBuilding(fFlameDamage, iFlameTime, xDamageTick, iLastEnemy);
			endif;
			if(CanDisguise())then
				ResetCamouflageTimer();
			endif;
			if(!IsAbleToFight())then ShoutForHelp(false);endif;
			Damage(fDmg);
		endif;
		m_axDmgTimer.DeleteEntryUS(iIndex);
	endproc;
	
	export proc void ResetCamouflageTimer()
		DeleteTimer(CAMO_TIMER);
		CreateTimer(CAMO_TIMER, CGameTimeSpan.OneSecond() * 10.0, false);
	endproc;
	
	export proc bool CanDisguise()
		var string sCN=GetClassName();
		if(sCN=="ninigi_muraeno_submarine")then
			return true;
		endif;
		if((sCN=="aje_assassin"||sCN=="hu_killer"||sCN=="ninigi_icespearman"||sCN=="seas_sniper")&&CRequirementsMgr.Get().CheckInvention(this, GetOwner(), "rougemask", GetTribeName()))then
			return true;
		endif;
		if(sCN=="ninigi_ninja"&&CRequirementsMgr.Get().CheckInvention(this, GetOwner(), "disguise", GetTribeName()))then
			return true;
		endif;
		//Henry: enable a new upgrade for seas submarine to cloak
		if(sCN=="seas_submarine"&&CRequirementsMgr.Get().CheckInvention(this, GetOwner(), "seas_cloak", GetTribeName()))then
			return true;
		endif;
		return false;
	endproc;
	
	export proc int GetScalpValue()
		var real fScalps=m_xTechTree.GetValueR(GetObjPath()+"/scalps",5.0);
		if(m_bIsWildAnimal)then
			fScalps+=GetWildAnimalSkullBonus(GetLevel());
		endif;
		fScalps *= GetTechTreeModifier("Skulls",true);
		fScalps += GetTechTreeModifier("Skulls",false);
		return Math.Round(fScalps).ToInt();
	endproc;
	
	///////
	// TriggerTimer
	//////
	export proc void TriggerTimer(string p_sAction, real p_fSecs)
		//Kr1s1m: Added a switch by p_sAction and WeaponRemove case to it
		if(p_sAction == "WeaponRemove")then
			CreateTimer(TIMER_WEAPON_REMOVE, CGameTimeSpan.OneSecond() * p_fSecs, false);
			RemoveAllWeapons(true);
		elseif(p_sAction == "Invulnerability")then
			CreateTimer(TIMER_INVUL, CGameTimeSpan.OneSecond() * p_fSecs, false);
			SetLDInvulnerable(true);
		endif;
	endproc;
	
	///////
	//	TakeDIrectDmg()
	///////
 
	//Henry: extended these procedures a little bit to allow killer to increase his killercount
	export proc void TakeDirectDmg(real p_fDmg, CObjHndl p_xEnemy)
		TakeDirectDmg(p_fDmg, 0.0, p_xEnemy);
	endproc;
	
	export proc void TakeDirectDmg(real p_fDmg, real p_fArmorPiercing, CObjHndl p_xEnemy)
		if(GetInvulnerable()<=0&&!GetLDInvulnerable() && !m_bDarkSwarm)then
			//if(p_xEnemy.IsValid())then m_xLastEnemy=p_xEnemy; endif;
			m_xLastEnemy=p_xEnemy;
			var real fDef=Math.Clamp((AddTemporaryRangedDefenseBoni(GetRangedProtection())-p_fArmorPiercing) / 100.0, 0.0f, m_fMaxDef);
			var real fDefense=p_fDmg * fDef;
			Damage(p_fDmg-fDefense);
		endif;
	endproc;
	
	export proc void TakeDirectDmg(real p_fDmg, real p_fArmorPiercing, int p_iDmgDealer, CObjHndl p_xEnemy)
		m_iLastDamage=p_iDmgDealer;
		TakeDirectDmg(p_fDmg,p_fArmorPiercing, p_xEnemy);
	endproc;
	
	///////
	//	TakeDIrectDmg()
	//  Use p_iDmgDealer to set the player who deals the damage (because this lucky fellow wants to have his skulls)
	///////
	export proc void TakeDirectDmg(real p_fDmg,int p_iDmgDealer, CObjHndl p_xEnemy)
		m_iLastDamage=p_iDmgDealer;
		TakeDirectDmg(p_fDmg,p_xEnemy);
	endproc;
	
	///////
	//	TakeDIrectDmg()
	///////
	export proc void TakeDirectMeleeDmg(real p_fDmg, CObjHndl p_xEnemy)
		TakeDirectMeleeDmg(p_fDmg, 0.0, p_xEnemy);
	endproc;
		
	///////
	//	TakeDIrectDmg()
	///////
	export proc void TakeDirectMeleeDmg(real p_fDmg, real p_fArmorPiercing, CObjHndl p_xEnemy)
		if(GetInvulnerable()<=0&&!GetLDInvulnerable())then
			//if(p_xEnemy.IsValid())then m_xLastEnemy=p_xEnemy; endif;
			m_xLastEnemy=p_xEnemy;
			var real fProt=GetProtection();
			var real fDef=Math.Clamp((AddTemporaryDefenseBoni(GetProtection())-p_fArmorPiercing) / 100.0, 0.0f, m_fMaxDef);
			var real fDefense=p_fDmg * fDef;
			Damage(p_fDmg-fDefense);
		endif;
	endproc;
	
	export proc void TakeDirectMeleeDmg(real p_fDmg,int p_iDmgDealer, CObjHndl p_xEnemy)
		m_iLastDamage=p_iDmgDealer;
		TakeDirectMeleeDmg(p_fDmg, p_xEnemy);
	endproc;
	
	export proc void TakeDirectMeleeDmg(real p_fDmg,real p_fArmorPiercing,int p_iDmgDealer, CObjHndl p_xEnemy)
		m_iLastDamage=p_iDmgDealer;
		TakeDirectMeleeDmg(p_fDmg,p_fArmorPiercing, p_xEnemy);
	endproc;
	
	export proc void OnAttack(^CGameObj p_pxEnemy)
		OnDefend(p_pxEnemy);
	endproc;
	
	///////
	//	OnDefend()
	///////
	export proc void OnDefend(^CGameObj p_pxEnemy)
		if(GetInvisibleFlag())then return; endif;
		if(m_iAggressionState==-1)then return; endif;
		if(p_pxEnemy!=null)then
			var ^CFightingObj pxEnemy=cast<CFightingObj>(p_pxEnemy);
			if(pxEnemy!=null)then
				if(GetOwner()==-1&&pxEnemy^.IsItATrap())then
					return;
				endif;
			endif;
//			HandleGamePlayCommand("Action",p_pxEnemy,p_pxEnemy^.GetPos(),"/AttackSrv");
			AttackSrv(p_pxEnemy);
		endif;
	endproc;
	
	export proc void AddEnemy(CObjHndl p_xEnemy, bool p_bDefend)
		m_xPotEnemies.Include(p_xEnemy);
		if(p_bDefend)then
			m_xHelpDefendEnemies.Include(p_xEnemy);
		else
			m_xHelpAttackEnemies.Include(p_xEnemy);
		endif;
		if(!IsInFight()&&(p_bDefend||GetAggressionState()!=1) && GetAggressionState()!=3 && GetAggressionState()!=4)then
			ExamineEnemies(false, false);
		endif;
	endproc;
	
	///////
	//	PreCheckForEnemies()
	///////
	export proc void PreCheckForEnemies()
		var int iOwner=GetOwner();
		if(iOwner<0)then return; endif;
		var ^CObjList pxEnemies=CSrvWrap.GetObjMgr()^.GetOwnerEnemyList(iOwner);
		if(pxEnemies==null)then return; endif;
		var real fRange=GetAlarmRange();
		if(GetAttackRange()>fRange)then
			//CSrvWrap.LogWarning("FightingObj",GetName()+": AttackRange greater than AlarmRange!");
			fRange=GetAttackRange();
		endif;
		fRange+=50.0f;
		var CObjList xEnemies;
		pxEnemies^.CopySorted(xEnemies,GetPos(),fRange);
		var ^CFightingObj pxEnemy=null;
		var ^CAttribs pxAttribs=null;
		var int i, iC=xEnemies.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(!xEnemies[i].IsValid())then continue; endif;
			pxEnemy=cast<CFightingObj>(xEnemies[i].GetObj());
			if(pxEnemy!=null)then
				pxAttribs=pxEnemy^.GetAttribs();
				if(pxAttribs!=null)then
					if(pxAttribs^.GetValueBool("active_disguise")||pxAttribs^.GetValueBool("active_camouflage")||pxEnemy^.GetNeutralObject())then
						xEnemies.DeleteEntry(i);
						i--;iC--;
					elseif((GetClassName()=="darwin_s0"||GetEffectFlag(EFFECT_NO_ANIMAL_AGGRO)||CMirageSrvMgr.Get().GetNeutralToWildAnimals(GetOwner()))&&(pxEnemy^.GetType()=="ANML"||pxEnemy^.GetType()=="NEST")&&pxEnemy^.GetOwner()==-1)then
						xEnemies.DeleteEntry(i);
						i--;iC--;
					elseif((pxEnemy^.IsFlyingUnit()&&!m_bAirWeapon&&!m_bBUAirAttack)||(m_bFlyingUnit&&!pxEnemy^.IsFlyingUnit()&&GetProjectile().IsEmpty()&&!m_bWildPtera))then
						xEnemies.DeleteEntry(i);
						i--;iC--;
					elseif(pxEnemy^.PeaceTime())then
						xEnemies.DeleteEntry(i);
						i--;iC--;
					endif;
				endif;
			endif;
		endfor;
		if(xEnemies.NumEntries()<1)then return; endif;
		var int iNearest=xEnemies.FindNearest(GetPos(),fRange);
		var int iFOWNearest=xEnemies.FindNearest(GetPos(),GetFOWRange());
		if(iNearest!=-1 /*AI:||/* m_xPriorityList.NumEntries()>0*/)then
			ActivateAggroTimer();
		else
			DeleteTimer(TIMER_AGGRO);
		endif;
		if(iFOWNearest==-1)then
			SetAlarmed(false);
		endif;
	endproc;
	
	export proc void UpdateFightFactors()
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		var ^CPlayer pxPlayer=pxLevel^.GetPlayer(GetOwner());
		if(pxPlayer!=null)then
			m_fDefenseFactor=pxPlayer^.GetPlayerDefenseFactor();
			m_fAttackFactor=pxPlayer^.GetPlayerAttackFactor();
		else
			m_fDefenseFactor=1.0f;
			m_fAttackFactor=1.0f;
		endif;
	endproc;
	
	///////
	//	ExamineEnemies()
	///////
	
	export proc bool ExamineEnemies(bool p_bAlarm)
		return ExamineEnemies(p_bAlarm, true);
	endproc;
	
	export proc bool ExamineEnemies(bool p_bAlarm, bool p_bFillEnemyList)
		//FightingObj is trying to determine, which enemy to attack...
		var CObjList xEnemies;
		var CObjList xAlarmEnemies;
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		var ^CPlayer pxPlayer=pxLevel^.GetPlayer(GetOwner());
		UpdateFightFactors();
		if(p_bFillEnemyList)then
			FillEnemyList(xEnemies,xAlarmEnemies);
		endif;
		if(m_xCurEnemy.IsValid())then
			m_xPotEnemies.Include(m_xCurEnemy);
		endif;
		var CObjHndl xNextTarget;
		if(m_xPotEnemies.NumEntries()<=0 /*AI:&&m_xPriorityList.NumEntries()<=0*/)then
			if(xEnemies.NumEntries()==0)then
				if(xAlarmEnemies.NumEntries()==0)then
					if(p_bAlarm)then
						SetAlarmed(false);
					endif;
					return false;
				else
					SetAlarmed(true,xAlarmEnemies[0]);
					return false;
				endif;
			endif;
		endif;
		xEnemies.Include(m_xPotEnemies);
		/*AI:
		var int i,iC=m_xPriorityList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFightingObj pxObj=cast<CFightingObj>(m_xPriorityList[i].GetObj());
			if(pxObj==null)then
				m_xPriorityList.DeleteEntry(i);
				i--; iC--;
			else
				xEnemies.Include(m_xPriorityList[i]);
				m_vAggressionPos=pxObj^.GetPos();
				break;
			endif;
		endfor;
		*/
		var CObjHndl xOptimalTarget;
		if(GetAttribs()!=null)then
			xOptimalTarget.FromInt(GetAttribs()^.GetValueInt("OptimalTarget"));
			if(xOptimalTarget.IsValid())then
				xEnemies.Include(xOptimalTarget);
			endif;
		endif;
		if(!SortEnemyList(xEnemies, GetAttackRange(), GetRealMinAttackRange()>0.0, true))then return false; endif;
		SetAlarmed(false);
		if(xEnemies.NumEntries()>0)then
			xNextTarget=xEnemies[0];
		endif;
		var bool bFoundEnemy=false;
		if(xNextTarget.IsValid())then  //if iC==0, xNextTarget is null
			if(m_xCurEnemy.IsValid() //Er kämpft bereits gegen jemanden...
				&& !(xNextTarget==m_xCurEnemy))then //Das neue Ziel ist ungleich dem gegenwärtigen Ziel
				var ^CFightingObj pxFO=cast<CFightingObj>(xNextTarget.GetObj());
				if(!IsInCombatRange(pxFO, false))then
					var CGameTime xNow=CTimeMgr.Get().GetTime();
					if(m_xChangeTargetTime==CGameTime.GetInvalidTime())then
						m_xChangeTargetTime=xNow;
						return bFoundEnemy;
					endif;
					if((xNow-m_xChangeTargetTime).GetSecondsF()<2.0)then
						return bFoundEnemy;
					endif;
				endif;
			endif;
			m_xChangeTargetTime=CGameTime.GetInvalidTime();
			if(m_xHelpDefendEnemies.FindEntry(xNextTarget)==-1)then
				m_xHelpAttackEnemies.Include(xNextTarget);
			endif;
			OnAttack(xNextTarget.GetObj());
			bFoundEnemy=true;
		endif;
		m_xPotEnemies.Clear();
		return bFoundEnemy;
	endproc;
	
	export proc bool SortEnemyList(ref CObjList p_rxList, real p_fAttackRange, bool p_bSortMinAttackRange, bool p_bAttackOwn)
		var array CFightingObj.CEnemyListSorter axList;
		var real fAlarmRng = GetAlarmRange()*2.0;
		var real fAttackRange = p_fAttackRange;
		var real fCalcRange=(fAlarmRng+fAttackRange)*(fAlarmRng+fAttackRange);
		var bool bSelfWaterMelee=(!CanWalk()&&CanSwim()&&(m_fAttackRange<1.0));
		//Henry: addition because of the new aje aquatic unit
		var bool bTorpedo=(GetClassName()=="seas_submarine")||(GetClassName()=="ninigi_muraeno_submarine")||(GetClassName()=="aje_mosasaurus");
		var int iOwner=GetOwner();
		var int iOptimalTarget=-2;
		if(GetAttribs()!=null)then
			iOptimalTarget=GetAttribs()^.GetValueInt("OptimalTarget");
		endif;
		var int i, iC=p_rxList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFightingObj pxObj=cast<CFightingObj>(p_rxList[i].GetObj());
			if(pxObj==null)then continue; endif;
			if(pxObj^.IsFlyingUnit()&&!m_bAirWeapon&&!m_bBUAirAttack)then continue; endif;
			if(m_bFlyingUnit&&!pxObj^.IsFlyingUnit()&&GetProjectile().IsEmpty()&&!m_bWildPtera)then continue; endif;
			if(pxObj^.IsMarkedForDelete())then continue; endif;
			if(pxObj^.InvalidEnemy())then continue; endif;
			if(pxObj^.HidingEnemy()&&!IsDetector())then continue; endif;
			if(iOwner!=-1&&iOwner==pxObj^.GetOwner())then continue; endif;
			if(IsTrapped())then continue; endif;
			if(pxObj^.GetEffectFlag(EFFECT_AJE_CAMOUFLAGE)&&!(p_rxList[i]==m_xCurEnemy))then continue; endif;
//			if(pxObj^.GetEffectFlag(EFFECT_AJE_CAMOUFLAGE))then
//				if(GetOwner()==-1&&GetGfxName()==pxObj^.GetGfxName())then continue;
//				elseif(GetOwner()!=-1&&!(p_rxList[i]==m_xCurEnemy))then continue; endif;
//				endif;
			var bool bInPriorityList=m_xPriorityList.FindEntry(p_rxList[i])!=-1;
			if(!bInPriorityList&&cast<CWall>(pxObj)!=null&&!(p_rxList[i]==m_xCurEnemy))then continue; endif;
			if(!bInPriorityList&&cast<CGate>(pxObj)!=null&&!(p_rxList[i]==m_xCurEnemy))then
				if(GetOwner()==-1)then
					continue;
				elseif(cast<CGate>(pxObj)^.IsOpen())then
					continue;
				endif;
			endif;
			if(pxObj^.GetClassName()=="pirate_boss")then
				var ^CPirateBoss pxBoss=cast<CPirateBoss>(pxObj);
				if(pxBoss!=null)then
					p_rxList.Include(pxBoss^.GetSegel());
					p_rxList.Include(pxBoss^.GetHeck());
					p_rxList.Include(pxBoss^.GetBug());
					iC=p_rxList.NumEntries();
				endif;
				continue;
			endif;
			if(pxObj^.GetClassName()=="pirate_boss_cannons")then continue; endif;
//			if(pxObj^.GetClassName()=="ninigi_pirate_boss_ship")then
//				var ^CPirateShip pxBossShip=cast<CPirateShip>(pxObj);
//				if(pxBossShip!=null)then
//					p_rxList.Include(pxBossShip^.GetSegel());
//					p_rxList.Include(pxBossShip^.GetHeck());
//					p_rxList.Include(pxBossShip^.GetBug());
//					iC=p_rxList.NumEntries();
//				endif;
//				continue;
//			endif;
			if(pxObj^.GetClassName().Find("ninigi_pirate_ship_cannons")>=0)then continue; endif;
			if(pxObj^.GetClassName().Find("ninigi_pirate_ship_")!=-1)then continue; endif;
			if(iOwner>-1&&(pxObj^.GetVisibleMask()&(01b<<iOwner))==00b )then continue; endif; //SB#16733 units should not see objects invisible for their owner
			var bool bWasAttacked=(m_xPotEnemies.FindEntry(p_rxList[i])!=-1);
			if(!bWasAttacked&&(bSelfWaterMelee||bTorpedo))then
				var bool bHarbour=cast<CHarbour>(pxObj)!=null;
				var real fHeight=CSrvWrap.GetScapeMgr().GetHeight(pxObj^.GetPos().GetX(),pxObj^.GetPos().GetY());
				var real fSeaLevel=m_fWaterLevel;
				if(!bTorpedo)then fSeaLevel+=1.7; else fSeaLevel-=0.5; endif;
				if(!bHarbour&&(fHeight>fSeaLevel))then continue; endif;
			endif;
			var int iObjOwner=pxObj^.GetOwner();
			if(!p_bAttackOwn&&iOwner==iObjOwner)then
				continue;
			endif;
			if(iOwner!=-1&&iObjOwner!=-1&&iOwner!=iObjOwner)then
				if(!CSrvWrap.GetDiplomacyMgr().GetIsEnemy(iOwner, pxObj^.GetOwner()))then continue; endif;
			endif;
			var bool bNeutralEnemy=false;
			var bool bWildAnimal=(iOwner==-1);
			var bool bEnemyWildAnimal=(iObjOwner==-1);
			if(!bInPriorityList&&bEnemyWildAnimal)then
				if(pxObj^.GetAggressive()!=1||bWildAnimal)then
					if(bWasAttacked)then
						bNeutralEnemy=true;
					elseif(AttackWildTarget(pxObj))then
						return false;
					else
						continue;
					endif;
				endif;
			endif;
			var bool bInRange=(m_vAggressionPos-pxObj^.GetPos()).Abs2S() <= fCalcRange;
//			var bool bWildAnimal=(iOwner==-1);
//			var bool bEnemyWildAnimal=(iObjOwner==-1);
			if(!bInPriorityList&&!bWildAnimal&&!bInRange&&!m_bAggressionWalk)then continue; endif;
			//Ai doesn't want to attack wild animals on aggro walk, this could be solved high level, but would cost much more performance and is not timing consistent
			if(bEnemyWildAnimal&&m_bAggressionWalk&&m_bAggrTNoAnml)then continue; endif;
			var ^CFightingObj.CEnemyListSorter pxSorter=^(axList.NewEntryRef());
			pxSorter^.m_xObj=p_rxList[i];
			pxSorter^.m_iIndex=i;
			pxSorter^.m_iAttackType=GetAttackType();
			pxSorter^.m_bCurrentTarget=p_rxList[i]==m_xCurEnemy; //PrioritiyList?
			pxSorter^.m_bInCombatRange=IsInCombatRange(pxObj, false);
			pxSorter^.m_bInPriorityList=bInPriorityList;
			pxSorter^.m_bPrioTarget=p_rxList[i].AsInt()==iOptimalTarget;
			pxSorter^.m_fDmg=pxObj^.GetDmg();
			pxSorter^.CalculateValue();
		endfor;
		axList.QSort();
		p_rxList=0;
		if(p_bSortMinAttackRange)then
			var real fSecondaryS=GetSecondaryRangeS();
			var real fSecondaryM=GetSecondaryRangeM();
			var real fMinAttackRange=GetRealMinAttackRange();
			var real fCollisionRadius=GetCollisionRadius();
			fSecondaryS+=fCollisionRadius+2.0f;
			fSecondaryM+=fCollisionRadius+2.0f;
			fAttackRange+=fCollisionRadius+2.0f;
			fMinAttackRange+=fCollisionRadius+2.0f;
			var real fProjFallOffCone;
			if(!GetRealProjectile().IsEmpty())then
				fProjFallOffCone=GetProjectileFallOffCone();
			endif;
			var CObjList xMinRangeTargets;
			iC=axList.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				var ^CFightingObj pxEnemy=cast<CFightingObj>(axList[i].m_xObj.GetObj());
				fSecondaryM=fMinAttackRange;
				var int iRng=IsInCombatRangeAttackZone(pxEnemy,fSecondaryS,fSecondaryM,fAttackRange,fProjFallOffCone);
				if(iRng<=2)then
					xMinRangeTargets.AddEntry(pxEnemy^.GetHandle());
					continue;
				endif;
				p_rxList.AddEntry(pxEnemy^.GetHandle());
			endfor;
			if(!GetSecondaryWeaponS().IsEmpty()||!GetSecondaryWeaponM().IsEmpty())then
				p_rxList.Include(xMinRangeTargets);
			endif;
		else
			iC=axList.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				p_rxList.AddEntry(axList[i].m_xObj);
			endfor;
		endif;
		return true;
	endproc;
	
	///////
	//	FillEnemyList()
	///////
	
	export proc void FillEnemyList(ref CObjList p_rxDirectList, ref CObjList p_rxAlarmList)
		var string sString;
		var int iOwner=GetOwner();
		if(iOwner<0)then return; endif;
		var ^CObjList pxEnemies=CSrvWrap.GetObjMgr()^.GetOwnerEnemyList(iOwner);
		if(pxEnemies==null)then return; endif;
		// TODO:
		CSrvWrap.GetObjMgr()^.FilterOwnerEnemyList(pxEnemies);
		FilterEnemyListCustom(pxEnemies^);
		/*
		var int i, iC=pxEnemies^.NumEntries();
		for(i=0) cond(i<iC) iter(++i)do
			var ^CGameObj pxO=pxEnemies^[i].GetObj();
			if(pxO==null||pxO^.GetType()=="OTHR")then
				pxEnemies^.DeleteEntry(i--);--iC;
			endif;
		endfor;
		*/
		var real fMaxRange = GetAttackRange();
		var real fAlarmRange = GetAlarmRange();
		//Dump("GetRightHandWeapon()="+GetRightHandWeapon());
		//Dump("fMaxRange="+fMaxRange.ToString());
		//Dump("fAlarmRange="+fAlarmRange.ToString());
		if(GetRealProjectile()!="")then
			var vec3 vCenter=GetProjectileStartPos();
			if(fAlarmRange > fMaxRange)then
				var real fFallOff=GetProjectileFallOffCone(fAlarmRange);
				pxEnemies^.CopySortedCone(p_rxAlarmList,vCenter,fFallOff,Math.Max(fAlarmRange,30.0f));
				p_rxAlarmList.CopySortedCone(p_rxDirectList,vCenter,fFallOff,fMaxRange);
			else
				var real fFallOff =GetProjectileFallOffCone(fMaxRange);
				pxEnemies^.CopySortedCone(p_rxDirectList,vCenter,fFallOff,Math.Max(fMaxRange,30.0f));
				p_rxDirectList.CopySortedCone(p_rxAlarmList,vCenter,fFallOff,fAlarmRange);
			endif;
		else
			pxEnemies^.CopySorted2D(p_rxAlarmList,GetPos(),fAlarmRange);
			p_rxAlarmList.CopySorted2D(p_rxDirectList,GetPos(),Math.Max(fMaxRange,30.0f));
		endif;
		if((m_bFlyingUnit&&GetProjectile().IsEmpty()&&!m_bWildPtera)||!m_bAirWeapon)then
			var int i, iC=p_rxDirectList.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				if(p_rxDirectList[i].IsValid())then
					var ^CFightingObj pxQuestion=cast<CFightingObj>(p_rxDirectList[i].GetObj());
					if(pxQuestion!=null)then
						if((pxQuestion^.IsFlyingUnit()&&!m_bAirWeapon&&!m_bBUAirAttack)||(m_bFlyingUnit&&!pxQuestion^.IsFlyingUnit()&&GetProjectile().IsEmpty()&&!m_bWildPtera))then
							p_rxDirectList.DeleteEntry(i--);
							--iC;
						endif;
					endif;
				endif;
			endfor;
		endif;
	endproc;
	
	export proc bool IsInCombatRange(^CFightingObj p_pxEnemy)
		var CObjHndl xInvalid; var bool bInvalid;
		return IsInCombatRange(p_pxEnemy,bInvalid,xInvalid);
	endproc;
	
	export proc bool IsInCombatRange(^CFightingObj p_pxEnemy, bool p_bUpdateWeapons)
		var CObjHndl xInvalid; var bool bInvalid;
		return IsInCombatRange(p_pxEnemy,bInvalid,xInvalid, GetAttackRange(),p_bUpdateWeapons);
	endproc;
	
	export proc bool IsInCombatRange(^CFightingObj p_pxEnemy, ref bool po_rbInMinRange, ref CObjHndl p_rxLastMinRangeTarget)
		return IsInCombatRange(p_pxEnemy,po_rbInMinRange,p_rxLastMinRangeTarget,GetAttackRange());
	endproc;
	
	export proc bool IsInCombatRange(^CFightingObj p_pxEnemy, ref bool po_rbInMinRange, ref CObjHndl p_rxLastMinRangeTarget, real p_fAttackRange)
		return IsInCombatRange(p_pxEnemy,po_rbInMinRange,p_rxLastMinRangeTarget,p_fAttackRange,true);
	endproc;
	
	export proc bool IsInCombatRange(^CFightingObj p_pxEnemy, ref bool po_rbInMinRange, ref CObjHndl p_rxLastMinRangeTarget, real p_fAttackRange, bool p_bUpdateWeapons)
		var ^CFightingObj pxEnemy =p_pxEnemy;
		var bool bIgnoreHeight=false;
		var bool bAirTarget=false;
		var vec3 vFighterPos;
		var vec3 vEnemyPos;
		var vec3 vLastEnemyPos;
		var real fFightDistance=pxEnemy^.GetCollisionRadius();
		var real fCollRadiusFighter=GetCollisionRadius();
		if(pxEnemy^.GetClassName()=="carrier_launch_pad")then
			fFightDistance=pxEnemy^.GetRadius();
			fCollRadiusFighter+=(fFightDistance*0.7);
			bIgnoreHeight=true;
		elseif(pxEnemy^.GetClassName().Find("_zeppelin")!=-1)then
			bIgnoreHeight=true;
			bAirTarget=true;
		elseif(GetClassName()=="Pteranodon"||GetClassName()=="Archaeopteryx")then
			bIgnoreHeight=true;
		elseif(pxEnemy^.IsFlyingUnit())then
			bAirTarget=true;
		endif;
		vFighterPos=GetPos();
		vEnemyPos=pxEnemy^.GetPos();
		vLastEnemyPos=pxEnemy^.GetLastPos();
		if((vFighterPos-vEnemyPos).Abs2S()>(vFighterPos-vLastEnemyPos).Abs2S())then
			vEnemyPos=vLastEnemyPos;
		endif;
		var real fSecondaryS=GetSecondaryRangeS();
		var real fSecondaryM=GetSecondaryRangeM();
		var real fAttackRange=p_fAttackRange;
		var real fMinAttackRange=GetRealMinAttackRange();
		var bool bMinAttackRange=fMinAttackRange>0.0;
//		fAttackRange+=fCollRadiusFighter/*+2.0f*/;
		fSecondaryS+=fCollRadiusFighter+2.0f;
		fSecondaryM+=fCollRadiusFighter+2.0f;
		fMinAttackRange+=fCollRadiusFighter;
		var bool bPrimProj=false;
		var real fProjFallOffCone=0.0;
		if(!GetRealProjectile().IsEmpty())then
			fProjFallOffCone=GetProjectileFallOffCone();
			bPrimProj=true;
			fAttackRange+=GetCollisionRadiusInner();
			fMinAttackRange-=pxEnemy^.GetCollisionRadiusInner();
		elseif(GetPenetration()&&m_fAttackRange>5.0)then
			bPrimProj=true;
			fAttackRange+=GetCollisionRadiusInner();
		else
			fAttackRange+=fCollRadiusFighter+2.0f;
		endif;
		if(fAttackRange>0.0f&&fAttackRange<4.0f)then fAttackRange=4.0f; endif; //primary minimum
		var vec3 vDir=vFighterPos-vEnemyPos;
		var real fDist=vDir.Abs2();
		var real fZFighter=GetPos().GetZ();
		var real fZEnemy=pxEnemy^.GetPos().GetZ();
		var real fZDiff=Math.Abs(fZEnemy-fZFighter);
		var real fHeight;
		if(fZFighter>fZEnemy)then
			fHeight=pxEnemy^.GetSize().GetZ();
		else
			fHeight=GetSize().GetZ();
		endif;
		fHeight=Math.Min(7.0,fHeight);
		var bool bHeightOk=(fZDiff<fHeight)||bIgnoreHeight;
		if(bHeightOk||bPrimProj)then
			//if(fDist<=fSecondaryS+fFightDistance||fDist<=fSecondaryM+fFightDistance||fDist<=fAttackRange+fFightDistance)then
				if(bMinAttackRange)then
					fSecondaryM=fMinAttackRange;
				endif;
				var int iRng=IsInCombatRangeAttackZone(pxEnemy,fSecondaryS,fSecondaryM,fAttackRange,fProjFallOffCone);
				//KLog.LogWarn("JaNe","IsInCR: "+GetName()+" "+p_pxEnemy^.GetName()+" D:"+fDist.ToString()+" ZF:"+fZFighter.ToString()+" ZE:"+fZEnemy.ToString()+" AR:"+fAttackRange.ToString()+" "+fProjFallOffCone.ToString()+" "+vDir.Abs2ConeS(fProjFallOffCone).ToString()+" R:"+iRng.ToString());
				if((iRng!=3||(!bPrimProj))&&cast<CBuilding>(this)==null&&cast<CBuilding>(pxEnemy)==null)then
					if(!CheckLineOfSightFight(pxEnemy,fDist))then
						//KLog.LogWarn("CHP","LOS Check failed");
						return false;
					endif;
				endif;
//				if(iRng!=0&&IsOnOpenTransporter())then
				if(iRng!=0)then
					if(IsOnOpenTransporter()||bAirTarget)then
						iRng=3;
					endif;
				endif;
				//KLog.LogWarn("CHP","B:"+iRng.ToString()+" D:"+fDist.ToString(2)+" AR:"+fAttackRange.ToString(2)+" FO:"+fProjFallOffCone.ToString(2));
				if(iRng==0)then return false; endif; //out of range
				if(iRng==3)then //primary/long range
					if(GetRightHandWeapon()!=GetCurrentWeapon()&&p_bUpdateWeapons)then
						UpdateWeapons(GetRightHandWeapon());
						pxEnemy^.ClearDamageCache();
					endif;
					return true;
				endif;
				if(!bHeightOk)then return false; endif; //out of range
				if(iRng==1)then //short range
					if(fSecondaryS>0.0&&GetSecondaryWeaponS()!=GetCurrentWeapon()&&p_bUpdateWeapons)then
						UpdateWeapons(GetSecondaryWeaponS());
						pxEnemy^.ClearDamageCache();
					endif;
					return true;
				endif;
				if(iRng==2)then //medium range
					if(bMinAttackRange)then
						po_rbInMinRange=true;
						if(p_rxLastMinRangeTarget==p_pxEnemy^.GetHandle())then
							if(fSecondaryS>0.0&&GetSecondaryWeaponS()!=GetCurrentWeapon()&&p_bUpdateWeapons)then
								UpdateWeapons(GetSecondaryWeaponS());
								pxEnemy^.ClearDamageCache();
							endif;
						else
							p_rxLastMinRangeTarget=p_pxEnemy^.GetHandle();
						endif;
						return false;
					elseif(fSecondaryM>0.0&&GetSecondaryWeaponM()!=GetCurrentWeapon()&&p_bUpdateWeapons)then
						UpdateWeapons(GetSecondaryWeaponM());
						pxEnemy^.ClearDamageCache();
					endif;
					return true;
				endif;
			//endif;
		endif;
		return false;
	endproc;
	
	export proc bool IsInScapeCombatRange(vec3 p_vAttackPos, ref bool po_rbInMinRange)
		var vec3 vFighterPos;
		var vec3 vEnemyPos=p_vAttackPos;
		var real fCollRadiusFighter=GetCollisionRadius();
		vFighterPos=GetPos();
		var real fSecondaryS=GetSecondaryRangeS();
		var real fSecondaryM=GetSecondaryRangeM();
		var real fAttackRange=GetAttackRange();
		var real fMinAttackRange=GetRealMinAttackRange();
		var bool bMinAttackRange=fMinAttackRange>0.0;
		fSecondaryS+=fCollRadiusFighter+2.0f;
		fSecondaryM+=fCollRadiusFighter+2.0f;
		fAttackRange+=fCollRadiusFighter+2.0f;
		fMinAttackRange+=fCollRadiusFighter;
		if(fAttackRange>0.0f&&fAttackRange<4.0f)then fAttackRange=4.0f; endif; //primary minimum
		var bool bPrimProj=false;
		var real fProjFallOffCone=0.0;
		if(!GetRealProjectile().IsEmpty())then
			fProjFallOffCone=GetProjectileFallOffCone();
			bPrimProj=true;
		endif;
		var real fDist=(vFighterPos-vEnemyPos).Abs2();
		if(bPrimProj||GetPenetration())then
			if(fDist>fAttackRange)then
				if(GetRightHandWeapon()!=GetCurrentWeapon())then
					UpdateWeapons(GetRightHandWeapon());
				endif;
				return false;
			endif;
			if(bMinAttackRange)then
				fSecondaryM=fMinAttackRange;
			endif;
			if(fDist>fSecondaryM)then
				if(GetRightHandWeapon()!=GetCurrentWeapon())then
					UpdateWeapons(GetRightHandWeapon());
				endif;
				return true;
			endif;
			if(fDist<=fSecondaryS)then
				if(GetSecondaryWeaponS()!=GetCurrentWeapon())then
					UpdateWeapons(GetSecondaryWeaponS());
				endif;
				if(bMinAttackRange)then
					po_rbInMinRange=true;
					return false;
				else
					return true;
				endif;
			endif;
			if(fDist<=fSecondaryM)then
				if(bMinAttackRange)then
					if(fSecondaryS>0.0&&GetSecondaryWeaponS()!=GetCurrentWeapon())then
						UpdateWeapons(GetSecondaryWeaponS());
					endif;
					po_rbInMinRange=true;
					return false;
				else
					if(GetSecondaryWeaponM()!=GetCurrentWeapon())then
						UpdateWeapons(GetSecondaryWeaponM());
					endif;
					return true;
				endif;
			endif;
			if(fDist<=fSecondaryM)then
				if(GetSecondaryWeaponS()!=GetCurrentWeapon())then
					UpdateWeapons(GetSecondaryWeaponS());
				endif;
				return true;
			endif;
		endif;
		return false;
	endproc;
	
	export proc int GetAttackType()
		return m_iAttackType;
	endproc;
	
	export proc void SetAttackType(int p_iType)
		//0	-	normal attack unit
		//1	-	unit against buildings
		m_iAttackType=p_iType;
	endproc;
	
	///////
	//	SetDmg()
	///////
	export proc void SetDmg(real p_fDmg)
		m_fDamage=p_fDmg;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("damage", Math.Ceil(m_fDamage).ToInt());
		endif;
	endproc;
	
	///////
	//	GetDmg()
	///////
	export proc real GetDmg()
		return m_fDamage;
	endproc;
	
	export proc ref real GetPoisonDmg()
		return m_fPoisonDmg;
	endproc;
	
	export proc void SetPoisonDmg(real p_fDmg)
		m_fPoisonDmg=p_fDmg;
	endproc;
	
	export proc ref int GetPoisonMaxTickCount()
		return m_iPoisonMaxTickCount;
	endproc;
	
	export proc void SetPoisonMaxTickCount(int p_iTickCount)
		m_iPoisonMaxTickCount=p_iTickCount;
	endproc;
	
	export proc void SetWeaponSizeClass(int p_iWeaponSizeClass)
		m_iWeaponSizeClass=p_iWeaponSizeClass;
	endproc;
	
	export proc int GetWeaponSizeClass()
		return m_iWeaponSizeClass;
	endproc;
	
	export proc void SetHitRange(real p_fHitRange)
		m_fHitRange=p_fHitRange;
	endproc;
	
	export proc ref real GetHitRange()
		return m_fHitRange;
	endproc;
	
	export proc void SetRealHitRange(real p_fHitRange)
		m_fRealHitRange=p_fHitRange;
	endproc;
	
	export proc ref real GetRealHitRange()
		return m_fRealHitRange;
	endproc;
	
	export proc void SetEndDmg(real p_fEndDmg)
		m_fEndDmg=p_fEndDmg;
	endproc;
	
	export proc ref real GetEndDmg()
		return m_fEndDmg;
	endproc;
	
	///////
	//	SetFormationPriorityFront2Back()
	///////
	export proc void SetFormationPriorityFront2Back(real p_fFront)
		m_vFormationPriority.SetY(p_fFront);
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("formation_y",p_fFront);
		endif;
	endproc;
	
	///////
	//	SetFormationPriorityCenter2Side()
	///////
	export proc void SetFormationPriorityCenter2Side(real p_fCenter)
		m_vFormationPriority.SetX(p_fCenter);
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("formation_x",p_fCenter);
		endif;
	endproc;
	
	///////
	//	GetFormationPriority()
	///////
	export proc ref vec2 GetFormationPriority()
		return m_vFormationPriority;
	endproc;
	
	///////
	//	SetMinDmg()
	///////
	export proc void SetMinDmg(real p_fDmg)
		m_fMinDamage=p_fDmg;
	endproc;
	
	///////
	//	SetProtection()
	///////
	export proc void SetProtection(real p_fProt)
		m_fProtection=p_fProt;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("defense",(m_fProtection+0.5).ToInt());
		endif;
	endproc;
	
	///////
	//	GetProtection()
	///////
	export proc ref real GetProtection()
		return m_fProtection;
	endproc;
	
	///////
	//	SetRangedProtection()
	///////
	export proc void SetRangedProtection(real p_fProt)
		m_fRangedProtection=p_fProt;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("rangeddefense",(m_fRangedProtection+0.5).ToInt());
		endif;
	endproc;
	
	///////
	//	GetProtection()
	///////
	export proc ref real GetRangedProtection()
		return m_fRangedProtection;
	endproc;
	
	///////
	//	IsDead()
	///////
	export proc bool IsDead()
//		return m_bIsDead;
		var ^CAttribs pxAttribs=GetAttribs();
		if(pxAttribs!=null)then
			return pxAttribs^.GetValueBool("dead");
		endif;
		return false;
//		return m_bIsDead;
	endproc;
	
	export proc void SetDead(bool p_bValue)
		var ^CAttribs pxAttribs=GetAttribs();
		if(pxAttribs!=null)then
			pxAttribs^.SetValue("dead",p_bValue);
		endif;
		m_bIsDead=true;
		CheckEnemyValidity();
		CheckFighterValidity();
	endproc;
	
	///////
	//	ChangeMaxHitpoints()
	///////
	export proc void ChangeMaxHitpoints(real p_fNewMax)
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel==null||pxLevel^.IsEditable())then
			return;
		endif;
		var real fRate;
		if(m_fMaxHitpoints==0.0)then
			fRate=1.0;
		else
			fRate=m_fHitpoints / m_fMaxHitpoints;
		endif;
		m_fMaxHitpoints=p_fNewMax+GetBonusSum(BONUS_MAXHITPOINTS);
		m_fHitpoints=m_fMaxHitpoints * fRate;
		UpdateHitpoints();
	endproc;
	
	///////
	//	AddHitpoints()
	///////
	export proc void AddHitpoints(real p_fAdd)
		var real fOld=m_fHitpoints;
		m_fHitpoints=Math.Clamp((m_fHitpoints+p_fAdd),0.0,m_fMaxHitpoints);
		if(m_bDivideSkulls&&fOld<m_fMaxHitpoints)then
			var real fDiff=m_fHitpoints-fOld;
			var int i;
			for(i=0)cond(i<9)iter(i++)do
				m_afDamagePortion[i]=Math.Max(m_afDamagePortion[i]-fDiff,0.0);
			endfor;
		endif;
		UpdateHitpoints();
	endproc;
	
	///////
	//	SetTransportObj()
	///////
	export proc void SetTransportObj(CObjHndl p_xHndl)
		m_xTransportObj=p_xHndl;
		if(m_xTransportObj.IsValid())then
			RemoveCamouflageEffect("disg");
			GetAttribs()^.SetValue("transporter_guid", m_xTransportObj.GetObj()^.GetGuid().ToString());
			GetAttribs()^.SetValue("transport_name", m_xTransportObj.GetObj()^.GetClassName());
		else
			GetAttribs()^.SetValue("transporter_guid","");
			GetAttribs()^.SetValue("transport_name", "");
			var Quat qR; qR.SetIdentity();
			SetAdditionalRot(qR);
			UpdateCamouflageLayers();
			LeavingTPOAftermath();
		endif;
	endproc;
	
	///////
	//	GetTransportObj()
	///////
	export proc CObjHndl GetTransportObj()
		return m_xTransportObj;
	endproc;
	
	///////
	//	UpdateHitpoints()
	///////
	export proc void UpdateHitpoints()
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("hitpoints",m_fHitpoints);
			pxAttr^.SetValue("maxhitpoints",m_fMaxHitpoints);
		endif;
		SetDefaultWalkSet(GetWalkSet());
		if(m_fHitpoints<=0.0)then
			if(!m_bHPReachedZero)then
				m_bHPReachedZero=true;
//				SetDyingInTPO(GetTransportObj().IsValid());
				m_bPassingAway=GetTransportObj().IsValid();
				Die();
			endif;
		endif;
		DoHPRelatedStuff();
		//If building
		if(GetType()=="BLDG")then
			//and not under construction
			if(!(GetConstructLevel()<4))then
				UpdateDestructionFlags();
			endif;
		elseif(GetType()=="SHIP"||GetType()=="VHCL")then
			UpdateDestructionFlags();
		endif;
		if(!IsDead()&&GetRageUnit())then
			//Henry: to boost a little infantry and wildboars rage ability
//			if((m_fHitpoints*3.0)<=m_fMaxHitpoints)then
			if((m_fHitpoints*(7.0/3.0))<=m_fMaxHitpoints)then
				if(!m_bRage)then
					var ^CTechTreeDef pxTDef=GetTechTreeDef();
					if(pxTDef!=null)then
						pxTDef^.EnableFilter("/Filters/Hu/Upgrades/xenage/wild_boar_rage");
						//L KLog.LogSpam("JaNe",GetName()+" EnableFilter");
					endif;
					m_bRage=true;
					ForceBoniUpdate();
				endif;
			else
				if(m_bRage)then
					m_bRage=false;
					var ^CTechTreeDef pxTDef=GetTechTreeDef();
					if(pxTDef!=null)then
						pxTDef^.DisableFilter("/Filters/Hu/Upgrades/xenage/wild_boar_rage");
						//L KLog.LogSpam("JaNe",GetName()+" DisableFilter");
					endif;
					ForceBoniUpdate();
				endif;
			endif;
		endif;
	endproc;
	
	export proc void UpdateRageUnit()
	endproc;
	
	export proc ref CFourCC GetWalkSet()
		if((IsSeriouslyInjured()||m_bSuicide||m_bPinnedDown||m_bBrokenLegs)&&HasWalkSet(m_xHumpWalkSet))then
			return m_xHumpWalkSet;
		else
			return m_xWalkSet;
		endif;
	endproc;
	
	export proc ref CFourCC GetHumpWalkSet()
		if(HasWalkSet(m_xHumpWalkSet))then
			return m_xHumpWalkSet;
		else
			return m_xWalkSet;
		endif;
	endproc;
	
	///////
	//	Die()
	///////
	export proc void Die()
		if(!IsDead())then
//			SetDyingInTPO(GetTransportObj().IsValid());
			m_bPassingAway=GetTransportObj().IsValid();
			var ^CAttribs pxAttr=GetAttribs();
			if(HasTimer(TIMER_WALKING_BOMB))then DeleteTimer(TIMER_WALKING_BOMB); endif;
			if(m_xTransportObj.IsValid())then
				var ^CTransportObj pxObj=cast<CTransportObj>(m_xTransportObj.GetObj());
				if(pxObj!=null)then
					pxObj^.OnDismount(GetHandle(),true,GetPos());
				endif;
				var ^CBunker pxBunker=cast<CBunker>(m_xTransportObj.GetObj());
				if(pxBunker!=null)then
					pxBunker^.RemChar(GetHandle());
				endif;
				var ^CSeasFortress pxFortress=cast<CSeasFortress>(m_xTransportObj.GetObj());
				if(pxFortress!=null)then
					pxFortress^.RemChar(GetHandle());
				endif;
			endif;
			var CFourCC xType=GetType();
			if(m_xProduceUnit.IsValid())then
				var ^CVirtualProduceUnit pxO=cast<CVirtualProduceUnit>(m_xProduceUnit.GetObj());
				if(pxO!=null)then pxO^.Die(); endif;
				m_xProduceUnit.FromInt(-1);
			endif;
			if(m_xReactor.IsValid())then
				var ^CVirtualProduceUnit pxO=cast<CVirtualProduceUnit>(m_xReactor.GetObj());
				if(pxO!=null)then pxO^.Die(); endif;
				m_xReactor.FromInt(-1);
			endif;
			if(m_xHiveMind.IsValid())then
				var ^CHiveMind pxO=cast<CHiveMind>(m_xHiveMind.GetObj());
				if(pxO!=null)then pxO^.Delete(); endif;
				m_xHiveMind.FromInt(-1);
				m_iCmdID=m_iOwnerID;
			endif;
			if(ShallBeResurrectable())then
				CreateSpirit();
			endif;
			m_fHitpoints=0.0f;
			if(xType=="BLDG")then
				SetExploTimer();
				if(GetTribeName()=="Ninigi")then
					if(m_xTechTree.GetValueI("/Objects/"+GetTribeName()+"/InventObjects/Explode/invented",0)!=0)then
						AuthorizationPicardFourSevenAlphaTango(); //:)
					endif;
				endif;
				SetDead(true);
			else
				SetDead(true);
				Delete();
			endif;
			var int iUISex=-1;
			var int iEvent=CMirageSrvMgr.Get().GetDieAck(GetClassName(), iUISex);
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel!=null&&iEvent!=-1&&DoesCountInUnitLimit())then
				if(GetOwner()!=-1)then
					var ^CPlayer pxPlayer=pxLevel^.GetPlayer(GetOwner());
					if(pxPlayer!=null&&cast<CAiPlayer>(pxPlayer)==null)then
						CSrvWrap.SendGenericEvtToPlayer(GetOwner(), "died\t"+iEvent.ToString()+ "\t"+iUISex.ToString());
					endif;
				endif;
			endif;
		endif;
	endproc;
	
	export proc bool SelfDestruct()
		return(true);
	endproc;
	
	export proc void DiePerHarakiri()
		if(m_bSlaveInvincible)then return; endif;
		if(IsDestructible())then return; endif;
//		SetDyingInTPO(GetTransportObj().IsValid());
		m_bPassingAway=GetTransportObj().IsValid();
		OnKill();
		Die();
	endproc;
	
	proc bool SetExploTimer();
		CreateTimer(TIMER_EXPLOSION, CGameTimeSpan.OneSecond() * 1.0, true);
		return(true);
	endproc;
	
	///////
	//	DieFastAndSilent()
	///////
	export proc void DieFastAndSilent()
//		SetDyingInTPO(GetTransportObj().IsValid());
		m_bPassingAway=GetTransportObj().IsValid();
		OnKill();
		if(m_xProduceUnit.IsValid())then
			var ^CVirtualProduceUnit pxO=cast<CVirtualProduceUnit>(m_xProduceUnit.GetObj());
			if(pxO!=null)then pxO^.Die(); endif;
			m_xProduceUnit.FromInt(-1);
		endif;
		if(m_xReactor.IsValid())then
			var ^CVirtualProduceUnit pxO=cast<CVirtualProduceUnit>(m_xReactor.GetObj());
			if(pxO!=null)then pxO^.Die(); endif;
			m_xReactor.FromInt(-1);
		endif;
		if(!IsDead())then
			if(HasTransportBuildUp())then
				Evacuate();
			endif;
			if(ShallBeResurrectable())then
				CreateSpirit();
			endif;
			m_fHitpoints=0.0f;
			SetVisible(false);
			SetDead(true);
			Delete();
		endif;
	endproc;
	
	///////
	//	DieFastAndSilent()
	///////
	export proc void DieFastAndSilentSL() // Henry: for killing cheater's stuff at gamestart (SL=Start Location)
		if(m_xProduceUnit.IsValid())then
			var ^CVirtualProduceUnit pxO=cast<CVirtualProduceUnit>(m_xProduceUnit.GetObj());
			if(pxO!=null)then pxO^.Die(); endif;
			m_xProduceUnit.FromInt(-1);
		endif;
		if(m_xReactor.IsValid())then
			var ^CVirtualProduceUnit pxO=cast<CVirtualProduceUnit>(m_xReactor.GetObj());
			if(pxO!=null)then pxO^.Die(); endif;
			m_xReactor.FromInt(-1);
		endif;
		if(!IsDead())then
			m_fHitpoints=0.0f;
			SetVisible(false);
			SetDead(true);
			Delete();
		endif;
	endproc;
	
	export proc void DieInTransport(int p_iLastDamage,CObjHndl p_xLastEnemy)
		m_iLastDamage=p_iLastDamage;
		m_xLastEnemy=p_xLastEnemy;
		DieFastAndSilent();
	endproc;
	
	export proc bool AuthorizationPicardFourSevenAlphaTango()
		//new CAreaDamage(20.0f,500.0f,100.0f,GetOwner(),GetPos(),7);
		CreateCustomFX(1,GetPos(),true);
		new CAreaDamage("Objects/Ninigi/Weapons/ninigi_dynamite",25.0f,500.0f,300.0f,GetOwner(),GetPos(),7);
		return(true);
	endproc;
	
	///////
	//	Delete()
	///////
	export proc void Delete()
		m_bToBeDeleted=true;
		var int ik=m_axParasites.NumEntries();
		if(ik>0)then
			var int iKC=ik;
			for(ik=0)cond(ik<iKC)iter(ik++)do
				var CObjHndl xParasite=m_axParasites[ik];
				if(xParasite.IsValid())then
					var ^CParasite pxParasite=cast<CParasite>(xParasite.GetObj());
					if(pxParasite!=null)then
						pxParasite^.Removement();
						m_axParasites.DeleteEntry(ik);
						ik--;iKC--;
					endif;
				endif;
			endfor
		endif;
		if(m_xGroup.IsValid())then
			var ^CGroupObj pxGroup=cast<CGroupObj>(m_xGroup.GetObj());
			if(pxGroup!=null)then
				pxGroup^.RemMember(GetHandle());
			endif;
		endif;
		var ^CInventory pxInv=GetInventory();
		if(pxInv!=null)then
			var int i, iC=pxInv^.Count();
			var CObjList xList;
			for(i=0) cond(i<iC) iter(++i)do
				if(!pxInv^.GetItem(i).IsValid())then continue; endif;
				xList.Include(pxInv^.GetItem(i));
			endfor;
			iC=xList.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				if(xList[i].IsValid())then
					var ^CGameObj pxItem=xList[i].GetObj();
					var ^CItem pxI=cast<CItem>(pxItem);
					if(pxI!=null)then
						RemoveItem(pxI^.GetHandle());
					endif;
				endif;
			endfor;
			pxInv^.Clear();
		endif;
		SetStartFilter(false);
		if(m_pxTaskMgr!=null)then
			m_pxTaskMgr^.BreakAll();
				/*if(m_pxTaskMgr^.GetCurTask()!=null)then
					m_pxTaskMgr^.GetCurTask()^.BreakAll();
				endif;*/
		endif;
		DeletePersonalRegion();
		SetLevelFilter(false);
		if(cast<CHero>(this)==null&&m_iLevel==4)then
			SetLevelFilter(false,"Filters/"+GetTribeName()+"/Upgrades/AllNonHeroes/Lvl"+(m_iLevel+1).ToString());
		endif;
		RemoveUnit();
		ClearFX();
		super.Delete();
	endproc;
	
	///////
	//	SetrReaction()
	///////
	export proc void SetReaction(real p_fDmg)
		if(p_fDmg>0.0)then
			Damage(p_fDmg);
		elseif(p_fDmg<0.0)then
			HealMe(p_fDmg,false);
			//L CSrvWrap.LogSpam("Shotgun","Name: "+GetName()+" Hitpoints after Hit: "+m_fHitpoints.ToString());
		endif;
	endproc;
	
	export proc real GetAttackDirection()
		return m_fAttackDirection;
	endproc;
	
	export proc void SetAttackDirection(real p_fDirection)
		m_fAttackDirection=p_fDirection;
	endproc;
	
	export proc void RotateToEnemy(^CFightingObj p_pxEnemy, vec3 p_vPos)
		RotateToEnemy(p_pxEnemy,p_vPos,"",0.0);
	endproc;
	
	export proc void RotateToEnemy(^CFightingObj p_pxEnemy, vec3 p_vPos, string p_sOverlayAnim, real p_fOverlayRatio)
		if(GetTransportObj().IsValid())then return; endif;
		var Quat qRot;
		if(p_pxEnemy!=null)then
			qRot=GetAngleToQ(p_pxEnemy);
		else
			qRot=GetAngleToQ(p_vPos);
		endif;
		m_bRotateAction=true;
		if(!p_sOverlayAnim.IsEmpty()&&HasAnim(p_sOverlayAnim))then
			RotateAction(qRot,p_sOverlayAnim,p_fOverlayRatio);
		else
			RotateAction(qRot);
		endif;
	endproc;
	
	export proc real GetAngleToR(^CGameObj p_pxTarget)
		return GetAngleToR(p_pxTarget^.GetPos());
	endproc;
	
	export proc real GetAngleToR(vec3 p_vPos)
		var vec3 vDir=(p_vPos - GetPos()).GetNormalized();
		vDir.RotZ(GetAttackDirection());
		var Quat qRot;
		qRot.FromXYDir(vDir.GetX(), vDir.GetY());
		var Quat qRotDiff=qRot/GetRot();
		var vec3 vRot;
		qRotDiff.ToVec3(vRot);
		return Math.Abs(vRot.GetZ());
	endproc;
	
	export proc Quat GetAngleToQ(^CGameObj p_pxTarget)
		return GetAngleToQ(p_pxTarget^.GetPos());
	endproc;
	
	export proc Quat GetAngleToQ(vec3 p_vPos)
		var vec3 vDir=(p_vPos - GetPos()).GetNormalized();
		vDir.RotZ(GetAttackDirection());
		var Quat qRot;
		qRot.FromXYDir(vDir.GetX(), vDir.GetY());
		return qRot;
	endproc;
	
	proc bool StartFireworks(string p_sTTPath, bool p_bQ)
		if(GetClassName()!="ninigi_monk")then return(false);endif;
		if(CheckSpecialActionTimer(p_sTTPath))then
			var ^CFireworks pxTask=cast<CFireworks>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"Firework"));
			if(pxTask==null)then return false; endif;
			if(pxTask^.Init(GetHandle(),p_sTTPath))then
				pxTask^.SetUserCommand(true);
				AddTask(pxTask,p_bQ);
				return true;
			endif;
			pxTask^.GetFactory()^.FreeState(pxTask);
			return false;
		else
			return(false);
		endif;
	endproc;
	
	proc bool StartSweepingBlow(string p_sTTPath, bool p_bQ)
		if(CheckSpecialActionTimer(p_sTTPath))then
			var ^CSweepingBlow pxTask=cast<CSweepingBlow>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"SwpBlow"));
			if(pxTask==null)then return false; endif;
			var bool bReturn=pxTask^.Init(GetHandle());
			if(bReturn)then
				pxTask^.SetUserCommand(true);
				AddTask(pxTask,p_bQ);
			else
				pxTask^.GetFactory()^.FreeState(pxTask);
			endif;
			return bReturn;
		else
			return(false);
		endif;
	endproc;
	
	export proc void SetHitDone()
		m_xLastHitDone=CTimeMgr.Get().GetTime();
	endproc;
	
	export proc void ResetHitDone()
		m_xLastHitDone=CGameTime.GetInvalidTime();
	endproc;
	
	export proc bool CanDoNextHit(real p_fDuration)
		if(m_xLastHitDone==CGameTime.GetInvalidTime())then
			return true;
		endif;
		return (CTimeMgr.Get().GetTime()-m_xLastHitDone).GetSecondsF()>p_fDuration;
	endproc;
	
	///////
	//	AttackEnemy()
	///////
	export proc bool AttackEnemy(^CFightingObj p_pxEnemy, vec3 p_vTarget, ref bool p_rbRotated)
		if(GetIncapacitated())then return false; endif;
		//if(p_pxEnemy!=null)then
			if(p_pxEnemy!=null)then
//				if(p_pxEnemy^.GetTransportObj().IsValid())then return false; endif;
				if(p_pxEnemy^.IsFlyingUnit()&&!CanShootAir())then return false; endif;
			endif;
			if(GetType()=="ANML" /*&& GetOwner()==-1*/&&HasTimer(TIMER_SANCTIFICATION))then
				DeleteTimer(TIMER_SANCTIFICATION);
			endif;
			var string sProj=GetProjectile();
			var string sFAnim=GetNextFightAnim();
			if(sFAnim.IsEmpty())then sFAnim="attack_front"; endif;
			var bool bProj=!sProj.IsEmpty();
			var bool bFAnim=!sFAnim.IsEmpty();
			begin Rotate;
				var real fAngle;
				if(p_pxEnemy!=null)then
					fAngle=GetAngleToR(p_pxEnemy);
				else
					fAngle=GetAngleToR(p_vTarget);
				endif;
				if(!bProj&&bFAnim)then
					if(GetPenetration()&&fAngle>(Math.Pi()/16.0f))then
						RotateToEnemy(p_pxEnemy, p_vTarget, sFAnim, 0.5);
						DoCaptainAttackAnim();
						p_rbRotated=true;
					elseif(fAngle>Math.Pi()/8.0)then
						RotateToEnemy(p_pxEnemy, p_vTarget, sFAnim, 0.5);
						DoCaptainAttackAnim();
						p_rbRotated=true;
						return true;
					endif;
				else
					//normal rotate
					if(fAngle>Math.Pi()/4.0||(GetPenetration()&&fAngle>Math.Pi()/16.0f))then
						RotateToEnemy(p_pxEnemy, p_vTarget);
						p_rbRotated=true;
						return false;
					endif;
				endif;
			end Rotate;
			if(GetPenetration()||GetAttackPenetrate())then
				Penetrate(p_pxEnemy,p_vTarget);
				if(sFAnim!=""&&HasAnim(sFAnim))then
					SetAnim(sFAnim,1);
				endif;
				return false;
			elseif(bProj)then
				CreateProjectileAndShoot(p_pxEnemy, p_vTarget);
				if(sFAnim!=""&&HasAnim(sFAnim))then
					SetAnim(sFAnim,1);
				endif;
				DoCaptainAttackAnim();
				return false;
			elseif(bFAnim)then
				if(sFAnim!=""&&HasAnim(sFAnim))then
					SetAnim(sFAnim,1);
				endif;
				DoCaptainAttackAnim();
			endif;
		//endif;
		return true;
	endproc;
	
	export proc void DoCaptainAttackAnim()
	endproc;
	
	export proc void Penetrate(^CFightingObj p_pxEnemy)
//		Penetrate(p_pxEnemy^.GetPos());
		if(p_pxEnemy!=null)then
			Penetrate(p_pxEnemy^.GetPos(),p_pxEnemy^.GetOwner(),p_pxEnemy^.GetHandle());
		else
			Penetrate(GetPos());
		endif;
	endproc;
	
	export proc void Penetrate(^CFightingObj p_pxEnemy, vec3 p_vPos)
		if(p_pxEnemy!=null)then
//			Penetrate(p_pxEnemy^.GetPos());
			Penetrate(p_pxEnemy^.GetPos(),p_pxEnemy^.GetOwner(),p_pxEnemy^.GetHandle());
		else
			Penetrate(p_vPos);
		endif;
	endproc;
	
	export proc void Penetrate(vec3 p_vPos)
		var CObjList xList;
		UpdateFightFactors();
		GetPenetratedObjs(p_vPos, GetAttackRange(), xList, GetPenetrationAngle());
		var int i, iC=xList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			//wild animal with penetrating attack would kill itself
			if(xList[i]==GetHandle())then continue; endif;
			var ^CFightingObj pxFight=cast<CFightingObj>(xList[i].GetObj());
			if(pxFight!=null)then
//				//Henry: in mirage i noticed that trex titans areadamage kills units on mounts...
//				if(pxFight^.GetTransportObj().IsValid())then continue; endif;
//				if(!pxFight^.IsHitable())then continue; endif;
				pxFight^.ClearDamageCache(); // Henry: recalculation is required in certain cases (like if a brachio is attacking 3 units and the brach suddenly gets powerboost, but the WeaponHasChanged condition will be set to false after the first unit does TakeDmg(...) and the other 2 are still using their DamageCache...
				var real fReaction=pxFight^.TakeDmg(this, false);
				if(m_bMeleePenetrate)then
					SetReaction(fReaction);
				endif;
			endif;
		endfor;
	endproc;
	
	export proc void Penetrate(^CFightingObj p_pxEnemy, real p_fAngle)
		var CObjList xList;
		UpdateFightFactors();
		GetPenetratedObjs(p_pxEnemy^.GetPos(), GetAttackRange(), xList, p_fAngle);
		var int i, iC=xList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			//wild animal with penetrating attack would kill itself
			if(xList[i]==GetHandle())then continue; endif;
			var ^CFightingObj pxFight=cast<CFightingObj>(xList[i].GetObj());
			if(pxFight!=null)then
				//Henry: in mirage i noticed that trex titans areadamage kills units on mounts...
//				if(pxFight^.GetTransportObj().IsValid())then continue; endif;
//				if(!pxFight^.IsHitable())then continue; endif;
				pxFight^.ClearDamageCache(); // Henry: recalculation is required in certain cases (like if a brachio is attacking 3 units and the brach suddenly gets powerboost, but the WeaponHasChanged condition will be set to false after the first unit does TakeDmg(...) and the other 2 are still using their DamageCache...
				var real fReaction=pxFight^.TakeDmg(this, false);
				if(m_bMeleePenetrate)then
					SetReaction(fReaction);
				endif;
			endif;
		endfor;
	endproc;
	
	export proc void GetPenetratedObjs(vec3 p_vTarget, real p_fRadius, ref CObjList p_rxObjs, real p_fAngle)
		var string sOwn=GetClassName();
		var bool bWorld=GetOwner()==-1;
		var CObjQuery xQuery;
		CSrvWrap.GetDiplomacyMgr().AddMyEnemiesToSearch(GetOwner(), xQuery);
		xQuery.SetOwner(-1,true);
		var real fDist=(p_vTarget-GetPos()).Abs2();
		//xQuery.SetOwner(0,true);
		var vec3 vPos=GetPos();
		xQuery.RegionCircle(vPos, Math.Max(p_fRadius*2.0, fDist*1.5));
		var CObjList xL;
		xQuery.Execute(xL);
		p_fAngle*=0.5;
		p_fAngle=(Math.Pi()/180.0)*p_fAngle;
		p_fRadius+=GetCollisionRadius()+2.0f;
		var vec3 vDir=(p_vTarget - vPos);
		var int i, iC=xL.NumEntries();
		for(i=0) cond(i<iC) iter(++i)do
			//wild animal with penetrating attack would kill itself
			if(xL[i]==GetHandle())then continue; endif;
			var ^CFightingObj pxO=cast<CFightingObj>(xL[i].GetObj());
			if(pxO!=null)then
				if(bWorld && pxO^.GetOwner()==-1 && (pxO^.GetClassName()==sOwn || pxO^.GetType()=="NEST"))then continue; endif;
				var vec3 vDirEnemy=(pxO^.GetPos()-vPos);
				var real fEnemyRadius=pxO^.GetCollisionRadiusInner();
				var real fEnemyDistSquare=vDirEnemy.AbsSquare();
				//KLog.LogSpam("JaNe",pxO^.GetName()+" "+((fEnemyRadius+p_fRadius)*(fEnemyRadius+p_fRadius)).ToString()+" vs. "+fEnemyDistSquare.ToString());
				//KLog.LogSpam("JaNe","fEnemyRadius="+fEnemyRadius.ToString()+" and p_fRadius="+p_fRadius.ToString()+" vs. fEnemyDistSquare="+Math.Sqrt(fEnemyDistSquare).ToString());
				if((fEnemyRadius+p_fRadius)*(fEnemyRadius+p_fRadius)<fEnemyDistSquare)then
					continue;
				endif;
				var real fAngle=vDir.AngBetweenXY(vDirEnemy);
				//KLog.LogSpam("JaNe","fAngle="+fAngle.ToString()+" vs. p_fAngle="+p_fAngle.ToString());
				if(fAngle>p_fAngle)then
					continue;
				endif;
				//Henry: in mirage i noticed that trex titans areadamage kills units on mounts...
				if(pxO^.GetTransportObj().IsValid()||pxO^.GetOnWall())then continue; endif;
				if(!pxO^.IsHitable())then continue; endif;
				p_rxObjs.Include(xL[i]);
			endif;
		endfor;
	endproc;
	
	export proc void EndFight()
		UpdateWeapons(GetRightHandWeapon());
//		if(CanDisguise())then
		if(GetClassName()!="ninigi_ninja" && CanDisguise())then
			ResetCamouflageTimer();
			AddCamouflageEffect("disg");
		endif;
		//Henry: to start self regenaration of wild animals if they don't fight
		if(GetType()=="ANML"/*&&GetOwner()==-1*/)then
			var ^CFightingObj.CSpecialAbility pxAb=m_xAbilities.GetAbility("sanctification", true);
			if(pxAb!=null)then
				CreateTimer(TIMER_SANCTIFICATION, CGameTimeSpan.OneSecond() * 3.0, false);
				m_fCuringAmount=pxAb^.GetValueF("amount");
			endif;
		endif;
		SetIdleAnim();
	endproc;
	
	export proc void OnStartFight()
	endproc;
	
	export proc string GetFirstStrikeAnim()
		return "";
	endproc;
	
	export proc bool FollowEnemy(^CFightingObj p_pxEnemy, bool p_bAttackScape)
		if(!IsAbleToWalk())then return false; endif;
		var bool bNoUserCommand=false;
		if(m_pxTaskMgr!=null)then
			var ^CTask pxTask=m_pxTaskMgr^.GetCurTask();
			if(pxTask!=null)then
				bNoUserCommand=!pxTask^.IsUserCommand();
			endif;
			if(bNoUserCommand&&GetAggressionState()<=0 || GetAggressionState()==3 || GetAggressionState()==4)then
				return false;
			endif;
		else
			return false;
		endif;
		if(m_bDoingFinishingMove)then return false; endif;
		var bool bPos						= false;
		var bool bValidEnemy		= false;
		var bool bFarFromDest		= false;
		var real fAlarmRng=GetAlarmRange()*2.0;
		fAlarmRng += GetAttackRange();
		if(p_pxEnemy!=null)then
			bPos=(m_vAggressionPos-p_pxEnemy^.GetPos()).Abs2() > fAlarmRng;
			bValidEnemy=true;
		endif;
		bFarFromDest=(m_vAggressionPos-GetPos()).Abs2S()>2.0;
		var CFourCC xWalkSet;
		var real fAttackRange;
		if(GetSecondaryWeaponS()==GetCurrentWeapon())then
			fAttackRange=GetSecondaryRangeS();
		elseif(GetSecondaryWeaponM()==GetCurrentWeapon())then
			fAttackRange=GetSecondaryRangeM();
		else
			fAttackRange=GetAttackRange()-2.0f;
		endif;
		if(m_fAttackRange<1.0)then
			fAttackRange=0.0; //GetCollisionRadius()+0.1;
		endif;
		var real fPFallOff=0.0;
		if(!GetProjectile().IsEmpty())then
			if(GetRightHandWeapon()==GetCurrentWeapon())then
				fPFallOff=GetProjectileFallOffCone();
			endif;
		endif;
		if(fPFallOff>0.0)then
			fAttackRange+=GetCollisionRadiusInner();
		else
			fAttackRange+=GetCollisionRadius();
		endif;
		if(bValidEnemy)then
			var ^CWall pxWall=cast<CWall>(p_pxEnemy);
			var ^CTower pxTower=cast<CTower>(p_pxEnemy);
			if(bNoUserCommand)then
				if(m_bAggressionWalk)then
					TerminateAction();
					var CGameObj.CAdvanceActionParams xAWAP;
					xAWAP.m_fMinDistance=fAttackRange;
					xAWAP.m_iPrefSpeed=GetMaxSpeed();
					xAWAP.m_fProjectileFallOff=fPFallOff;
					xAWAP.m_bStopOnLostTarget=bNoUserCommand;
					if(GetOnWall())then
						AdvanceWallAction(p_pxEnemy^.GetHandle(),xAWAP,!p_pxEnemy^.GetOnWall(),bNoUserCommand);
					else
						AdvanceAction(p_pxEnemy^.GetHandle(),xAWAP);
					endif;
					return true;
				elseif(GetAggressionState()>0)then
					if(bPos /*&& GetAggressionState()==1*/&&!m_bAggressionWalk)then
						if(bFarFromDest)then
							if(GetOnWall())then
								WallWalkAction(m_vAggressionPos,true,GetDefaultSpeed(),false);
							else
								WalkAction(m_vAggressionPos,GetDefaultSpeed(),true);
							endif;
							return false;
						endif;
					else
						var real fDist=(p_pxEnemy^.GetPos()-GetPos()).Abs();
						if(fDist>fAlarmRng-2.0f)then
							return false;
						endif;
						TerminateAction();
						var CGameObj.CAdvanceActionParams xAWAP;
						xAWAP.m_fMinDistance=fAttackRange;
						xAWAP.m_iPrefSpeed=GetMaxSpeed();
						xAWAP.m_xWalkSet=GetWalkSet();
						xAWAP.m_fMaxRange=fAlarmRng;
						xAWAP.m_vRootPos=m_vAggressionPos;
						xAWAP.m_fProjectileFallOff=fPFallOff;
						xAWAP.m_bStopOnLostTarget=bNoUserCommand;
						if(GetOnWall())then
							AdvanceWallAction(p_pxEnemy^.GetHandle(),xAWAP,!p_pxEnemy^.GetOnWall(),bNoUserCommand);
						else
							AdvanceAction(p_pxEnemy^.GetHandle(),xAWAP);
						endif;
						return true;
					endif;
				elseif(bFarFromDest)then
					if(GetOnWall())then
						WallWalkAction(m_vAggressionPos,true,GetDefaultSpeed(),false);
					else
						WalkAction(m_vAggressionPos,GetDefaultSpeed(),true);
					endif;
				endif;
				return false;
			else
				TerminateAction();
				var CGameObj.CAdvanceActionParams xAWAP;
				xAWAP.m_fMinDistance=fAttackRange;
				xAWAP.m_iPrefSpeed=GetMaxSpeed();
				xAWAP.m_sFirstStrike=GetFirstStrikeAnim();
				xAWAP.m_fProjectileFallOff=fPFallOff;
				xAWAP.m_bStopOnLostTarget=bNoUserCommand;
				if(GetOnWall()||p_pxEnemy^.GetOnWall())then
					if(!GetOnWall()&&p_pxEnemy^.GetOnWall()&&!GetProjectile().IsEmpty())then
						AdvanceAction(p_pxEnemy^.GetHandle(),xAWAP);
					else
						AdvanceWallAction(p_pxEnemy^.GetHandle(),xAWAP,!p_pxEnemy^.GetOnWall(),!bNoUserCommand);
					endif;
				else
					AdvanceAction(p_pxEnemy^.GetHandle(),xAWAP);
				endif;
				return true;
			endif;
		else
			if(p_bAttackScape)then
				var CGameObj.CAdvanceActionParams xAWAP;
				xAWAP.m_fMinDistance=fAttackRange;
				xAWAP.m_iPrefSpeed=GetMaxSpeed();
				xAWAP.m_fProjectileFallOff=fPFallOff;
				xAWAP.m_vGoalOffset=m_vAggressionPos;
				xAWAP.m_bStopOnLostTarget=bNoUserCommand;
				if(GetOnWall())then
					AdvanceWallAction(CObjHndl.Invalid(),xAWAP, false, false);
				else
					AdvanceAction(CObjHndl.Invalid(),xAWAP);
				endif;
				return true;
			elseif(bFarFromDest)then
				if(GetOnWall())then
					WallWalkAction(m_vAggressionPos,true,GetDefaultSpeed(),false);
				else
					WalkAction(m_vAggressionPos,GetDefaultSpeed(),true);
				endif;
			elseif(m_bAggressionWalk)then
				m_bAggressionWalk=false;
				m_bAggrTNoAnml=false;
			endif;
			return false;
		endif;
	endproc;
	
//	###########################################################################################################
//	#### NEW FIGHTINGOBJ PROCS ################################################################################
//	###########################################################################################################
	
	export proc void SetAggressionWalk(bool p_bAggressionWalk)
		SetAggressionWalk(p_bAggressionWalk,false);
	endproc;
	
	export proc void SetAggressionWalk(bool p_bAggressionWalk,bool p_bAggrTNoAnml)
		m_bAggressionWalk=p_bAggressionWalk;
		m_bAggrTNoAnml=p_bAggrTNoAnml;
	endproc;
	
	///////
	//	IsAbleToWalk()
	///////
	export proc bool IsAbleToWalk()
		//return (CanWalk()||CanSwim()||CanFly())&&!m_bIsTrapped&&!GetTransportObj().IsValid()&&!(m_bPinnedDown&&GetType()=="CHTR");
		return (CanWalk()||CanSwim()||CanFly())&&!m_bIsTrapped&&!GetTransportObj().IsValid();
	endproc;
	
	export proc bool WouldBeAbleToWalk()
		return ((CanWalk()||CanSwim()||CanFly())&&!m_bIsTrapped&&!GetTransportObj().IsValid());
	endproc;
	
	///////
	//	GoTo()
	///////
	export proc void GoTo(vec3 p_vPos, bool p_bUserCommand, int p_iSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption)
		GoTo(p_vPos,p_bUserCommand,p_iSpeed,p_bUsePathfinder,p_bHeightAdaption,false);
	endproc;
	
	///////
	//	GoTo()
	///////
	export proc void GoTo(vec3 p_vPos, bool p_bUserCommand, int p_iSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption, bool p_bOnWall)
		GoTo(p_vPos,p_bUserCommand,p_iSpeed,p_bUsePathfinder,p_bHeightAdaption,p_bOnWall, false);
	endproc;
	
	///////
	//	GoTo()
	///////
	export proc void GoTo(vec3 p_vPos, bool p_bUserCommand, int p_iSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption, bool p_bOnWall, bool p_bQueued)
		GoTo(p_vPos,p_bUserCommand,p_iSpeed,p_bUsePathfinder,p_bHeightAdaption,p_bOnWall, p_bQueued, true);
	endproc;
	
	///////
	//	GoTo()
	///////
	export proc void GoTo(vec3 p_vPos, bool p_bUserCommand, int p_iSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption, bool p_bOnWall, bool p_bQueued, bool p_bUseMaterial)
		if(!IsAbleToWalk()/*||GetEffectFlag(CFightingObj.EFFECT_ITEM_STONED)*/)then
			return;
		endif;
		if(p_bUserCommand)then
			if(CMirageSrvMgr.Get().GetResetRallyPoint(GetOwner()))then
				var CObjHndl xInvalid;
				var vec3 vPos(0,0,0);
				SetRallyPoint(vPos,xInvalid);
			endif;
			AnnounceState("walk");
		endif;
		var bool bNewUserCmd=p_bUserCommand;
		var bool bOldUserCmd=false;
		if(m_pxTaskMgr==null)then return; endif;
		var ^CTask pxCurTask=m_pxTaskMgr^.GetCurTask();
		if(pxCurTask!=null)then
			bOldUserCmd=pxCurTask^.IsUserCommand();
		endif;
		if(!bNewUserCmd&&bOldUserCmd)then return; endif;
		m_bIsHelpShout=false;
		if(bNewUserCmd)then
			m_bAggressionWalk=false;
			m_bAggrTNoAnml=false;
		endif;
		UpdateAggressionPos(p_vPos);
		begin UpdateRider;
			var ^CTransportObj pxTransport=cast<CTransportObj>(this);
			if(pxTransport!=null)then
				var ^CObjList pxPassengers=^(pxTransport^.GetPassengers());
				if(pxPassengers!=null)then
					var int i, iC=pxPassengers^.NumEntries();
					for(i=0)cond(i<iC)iter(i++)do
						var ^CFightingObj pxFight=cast<CFightingObj>(pxPassengers^[i].GetObj());
						if(pxFight!=null)then
							pxFight^.UpdateAggressionPos(p_vPos);
						endif;
					endfor;
				endif;
			endif;
		end UpdateRider;
		var bool bAdd=p_bQueued;
		if(IsFeignDeath())then
//			var ^CFeignDeath pxT=cast<CFeignDeath>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(), "FeignDth"));
//				pxT^.Init(GetHandle(), false, "dummy");
//				pxT^.SetUserCommand(p_bUserCommand);
//				AddTask(pxT,false);
			var ^CFeignDeath pxT=cast<CFeignDeath>(GetCurTask());
			if(pxT!=null)then
				pxT^.Break();
				bAdd=true;
			endif;
		endif;
		var ^CWalkToPos pxTask=cast<CWalkToPos>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"Walk2Pos"));
		if(pxTask==null)then return; endif;
		var bool bR=pxTask^.Init(GetHandle(),p_vPos,p_iSpeed,p_bUsePathfinder,p_bHeightAdaption,p_bOnWall, p_bUseMaterial);
		if(bR)then
			pxTask^.SetUserCommand(p_bUserCommand);
			AddTask(pxTask, bAdd);
		else
			pxTask^.GetFactory()^.FreeState(pxTask);
		endif;
	endproc;
	
	export proc void GoTo(CObjHndl p_xTarget, ref CGameObj.CAdvanceActionParams p_rxParams, bool p_bUserCommand, bool p_bQueued)
		if(!IsAbleToWalk()/*||GetEffectFlag(CFightingObj.EFFECT_ITEM_STONED)*/)then
			return;
		endif;
		if(p_bUserCommand)then
			if(CMirageSrvMgr.Get().GetResetRallyPoint(GetOwner()))then
				var CObjHndl xInvalid;
				var vec3 vPos(0,0,0);
				SetRallyPoint(vPos,xInvalid);
			endif;
			AnnounceState("walk");
		endif;
		var bool bNewUserCmd=p_bUserCommand;
		var bool bOldUserCmd=false;
		if(m_pxTaskMgr==null)then return; endif;
		var ^CTask pxCurTask=m_pxTaskMgr^.GetCurTask();
		if(pxCurTask!=null)then
			bOldUserCmd=pxCurTask^.IsUserCommand();
		endif;
		if(!bNewUserCmd&&bOldUserCmd)then return; endif;
		m_bIsHelpShout=false;
		if(bNewUserCmd)then
			m_bAggressionWalk=false;
			m_bAggrTNoAnml=false;
		endif;
		var vec3 vPos;
		if(p_xTarget.IsValid())then
			vPos=p_xTarget.GetObj()^.GetPos();
		else
			vPos=p_rxParams.m_vGoalOffset;
		endif;
		UpdateAggressionPos(vPos);
		begin UpdateRider;
			var ^CTransportObj pxTransport=cast<CTransportObj>(this);
			if(pxTransport!=null)then
				var ^CObjList pxPassengers=^(pxTransport^.GetPassengers());
				if(pxPassengers!=null)then
					var int i, iC=pxPassengers^.NumEntries();
					for(i=0)cond(i<iC)iter(i++)do
						var ^CFightingObj pxFight=cast<CFightingObj>(pxPassengers^[i].GetObj());
						if(pxFight!=null)then
							pxFight^.UpdateAggressionPos(vPos);
						endif;
					endfor;
				endif;
			endif;
		end UpdateRider;
		var bool bAdd=p_bQueued;
		if(IsFeignDeath())then
//			var ^CFeignDeath pxT=cast<CFeignDeath>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(), "FeignDth"));
//			if(pxT!=null)then
//				pxT^.Init(GetHandle(), false, "dummy");
//				pxT^.SetUserCommand(p_bUserCommand);
//				AddTask(pxT,false);
			var ^CFeignDeath pxT=cast<CFeignDeath>(GetCurTask());
			if(pxT!=null)then
				pxT^.Break();
				bAdd=true;
			endif;
		endif;
		var ^CWalkToPos pxTask=cast<CWalkToPos>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"Walk2Pos"));
		if(pxTask==null)then return; endif;
		var bool bR=pxTask^.Init(GetHandle(), p_xTarget, p_rxParams);
		if(bR)then
			pxTask^.SetUserCommand(p_bUserCommand);
			AddTask(pxTask, bAdd);
		else
			pxTask^.GetFactory()^.FreeState(pxTask);
		endif;
	endproc;
	
	///////
	//	GoTo()
	///////
	export proc void GoToObj(CObjHndl p_xTarget, bool p_bUserCommand, bool p_bQueued)
		if(!IsAbleToWalk()/*||GetEffectFlag(CFightingObj.EFFECT_ITEM_STONED)*/)then
			return;
		endif;
		if(!p_xTarget.IsValid())then
			return;
		endif;
		var ^CGameObj pxObj=p_xTarget.GetObj();
		if(p_bUserCommand)then
			AnnounceState("walk");
		endif;
		var bool bNewUserCmd=p_bUserCommand;
		var bool bOldUserCmd=false;
		if(m_pxTaskMgr==null)then return; endif;
		var ^CTask pxCurTask=m_pxTaskMgr^.GetCurTask();
		if(pxCurTask!=null)then
			bOldUserCmd=pxCurTask^.IsUserCommand();
		endif;
		if(!bNewUserCmd&&bOldUserCmd)then return; endif;
		m_bIsHelpShout=false;
		if(bNewUserCmd)then
			m_bAggressionWalk=false;
			m_bAggrTNoAnml=false;
		endif;
		UpdateAggressionPos(pxObj^.GetPos());
		begin UpdateRider;
			var ^CTransportObj pxTransport=cast<CTransportObj>(this);
			if(pxTransport!=null)then
				var ^CObjList pxPassengers=^(pxTransport^.GetPassengers());
				if(pxPassengers!=null)then
					var int i, iC=pxPassengers^.NumEntries();
					for(i=0)cond(i<iC)iter(i++)do
						var ^CFightingObj pxFight=cast<CFightingObj>(pxPassengers^[i].GetObj());
						if(pxFight!=null)then
							pxFight^.UpdateAggressionPos(pxObj^.GetPos());
						endif;
					endfor;
				endif;
			endif;
		end UpdateRider;
		var bool bAdd=p_bQueued;
		if(IsFeignDeath())then
//			var ^CFeignDeath pxT=cast<CFeignDeath>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(), "FeignDth"));
//			if(pxT!=null)then
//				pxT^.Init(GetHandle(), false, "dummy");
//				pxT^.SetUserCommand(p_bUserCommand);
//				AddTask(pxT,false);
			var ^CFeignDeath pxT=cast<CFeignDeath>(GetCurTask());
			if(pxT!=null)then
				pxT^.Break();
				bAdd=true;
			endif;
		endif;
		var ^CWalkToObj pxTask=cast<CWalkToObj>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"Walk2Obj"));
		if(pxTask==null)then return; endif;
		var bool bR=pxTask^.Init(GetHandle(), p_xTarget);
		if(bR)then
			pxTask^.SetUserCommand(p_bUserCommand);
			AddTask(pxTask, bAdd);
		else
			pxTask^.GetFactory()^.FreeState(pxTask);
		endif;
	endproc;
	
	///////
	//	IsAbleToFight()
	///////
	export proc bool IsAbleToFight()
		return GetDmg()>0.0;
	endproc;
	
	export proc void SetCanFightAttrib(bool p_bCanFight)
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("can_attack", p_bCanFight);
		endif;
	endproc;
	
	export proc bool IsInFight()
		if(m_pxTaskMgr==null)then return false; endif;
		var ^CTask pxTask=m_pxTaskMgr^.GetCurTask();
		if(pxTask==null)then return false; endif;
		var ^CFight pxFight=cast<CFight>(pxTask);
		var ^CFinishingMove pxFinish=cast<CFinishingMove>(pxTask);
		return (pxFight!=null||pxFinish!=null);
	endproc;
	
	export proc bool IsReallyInFight()
		if(m_pxTaskMgr==null)then return false; endif;
		var ^CTask pxTask=m_pxTaskMgr^.GetCurTask();
		if(pxTask==null)then return false; endif;
		var ^CFight pxFight=cast<CFight>(pxTask);
		if(pxFight!=null)then
			return !(pxFight^.JustEndingIt());
		endif;
		var ^CFinishingMove pxFinish=cast<CFinishingMove>(pxTask);
		return pxFinish!=null;
	endproc;
	
	proc void InvokeFightTask(CObjHndl p_xTarget,vec3 p_vPos,bool p_bUserCommand)
		InvokeFightTask(p_xTarget, p_vPos, p_bUserCommand, false);
	endproc;
	
	proc void InvokeFightTask(CObjHndl p_xTarget,vec3 p_vPos, bool p_bUserCommand, bool p_bAddTask)
		InvokeFightTask(p_xTarget, p_vPos, p_bUserCommand, p_bAddTask, false);
	endproc;
	
	proc void InvokeFightTask(CObjHndl p_xTarget,vec3 p_vPos, bool p_bUserCommand, bool p_bAddTask, bool p_bNoUserBerserkerMode)
		if(m_xReturnEnemy.IsValid())then
			p_xTarget=m_xReturnEnemy;
			m_xReturnEnemy.FromInt(-1);
		endif;
		if(!p_xTarget.IsValid()&&p_bUserCommand&&!p_bNoUserBerserkerMode&&GetRealHitRange()<=0.0&&!GetPenetration())then
			if(!IsInFight())then
//				HandleGamePlayCommand("Action", null, p_vPos, "/AggressiveTarget");
				AggressiveSrv(p_vPos);
			endif;
			return;
		endif;
		if(p_xTarget==GetHandle())then return; endif;
		if(m_pxTaskMgr==null)then return; endif;
		var ^CTask pxCur=m_pxTaskMgr^.GetCurTask();
		var ^CFight pxTask=cast<CFight>(pxCur);
		// already in fight, update target
		if(!p_bAddTask||pxTask==null)then
			if(p_xTarget.IsValid())then
				GetWeaponMgr()^.GetBestWeapon(cast<CFightingObj>(p_xTarget.GetObj()), true);
			endif;
		endif;
		if(!p_bUserCommand&&m_iAggressionState==0)then
			var ^CFightingObj pxEnemy=cast<CFightingObj>(p_xTarget.GetObj());
			var bool bInvalid;
			var CObjHndl xInvalid;
			if(pxEnemy!=null&&!IsInCombatRange(pxEnemy, false))then
				return;
			endif;
		endif;
		if(pxTask!=null&&!p_bAddTask)then
			if(p_bUserCommand&&!p_bNoUserBerserkerMode)then
				m_bAggressionWalk=false;
				UpdateAggressionPos(p_vPos);
			endif;
			pxTask^.SetNoUserBerserkerMode(p_bNoUserBerserkerMode);
			pxTask^.SetUserCommand(p_bUserCommand);
			pxTask^.UpdateEnemy(p_xTarget, p_vPos);
			m_xCurEnemy=p_xTarget;
		else
			if(p_bUserCommand&&!p_bNoUserBerserkerMode)then
				m_bAggressionWalk=false;
				UpdateAggressionPos(p_vPos);
			endif;
			pxTask=cast<CFight>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(), "Fight"));
			if(pxTask!=null)then
				var bool bHBUAW=false;
				if(!pxTask^.Init(GetHandle(), p_xTarget, p_vPos, bHBUAW))then
					pxTask^.GetFactory()^.FreeState(pxTask);
					if(bHBUAW)then GoAfterTarget(p_xTarget); endif;
					return;
				endif;
				pxTask^.SetUserCommand(p_bUserCommand);
				pxTask^.SetNoUserBerserkerMode(p_bNoUserBerserkerMode);
				if(p_bUserCommand&&!p_bAddTask)then
					AddTask(pxTask,false);
				elseif(!p_bAddTask)then
					SetTaskImmediate(pxTask);
				else
					AddTask(pxTask,true);
				endif;
				m_xCurEnemy=p_xTarget;
			endif;
		endif;
	endproc;
	
	export proc bool IsBerserking()
		return IsInFight()&&m_bIsBerserker&&IsBerserkTarget(m_xCurEnemy.GetObj());
	endproc;
	
	export proc bool IsBerserkTarget(^CGameObj p_pxObj)
		if(p_pxObj==null)then return false; endif;
		if(p_pxObj^.GetType()=="BLDG")then return false; endif;
		if(p_pxObj^.GetType()=="ANML"&&p_pxObj^.GetOwner()==-1)then return false; endif;
		if(p_pxObj^.GetType()=="NEST")then return false; endif;
		return true;
	endproc;
	
	///////
	//	Fight()
	///////
	export proc void Fight(^CGameObj p_pxTarget, vec3 p_vPos, bool p_bUserCommand, bool p_bQ)
		var bool bNewUserCmd=p_bUserCommand;
		var bool bOldUserCmd=false;
		var bool bAlreadyInFight=false;
		var bool bAlreadyInAction=false;
		var bool bNoUserBerserkerMode=false;
		
		var ^CLevelInfoHost pxLevelInfo=^(CSrvWrap.GetCurLevel()^.GetLevelInfo());
		var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
		var string sLevelName = (pxGenericDB^)["Base/LevelName"].Value();
		
		if(!IsAbleToFight()||GetIncapacitated())then //Henry: incapacitated buildings can't fight
			return;
		endif;
		if(m_pxTaskMgr==null)then return; endif;
		var ^CTask pxCurTask=m_pxTaskMgr^.GetCurTask();
		if(pxCurTask!=null)then
			bOldUserCmd=pxCurTask^.IsUserCommand();
			bAlreadyInFight=IsInFight();
			bAlreadyInAction=(cast<CAction>(pxCurTask)!=null);//IsPerformingAction();
		endif;
		if(m_bIsBerserker&&IsBerserkTarget(p_pxTarget))then
			if(!bNewUserCmd)then
				bNoUserBerserkerMode=true;
			endif;
			bNewUserCmd=true;
		endif;
		if(!bNewUserCmd&&bOldUserCmd)then
			return;
		endif;
		var bool bAdd=false;
		if(IsFeignDeath())then
//			var ^CFeignDeath pxT=cast<CFeignDeath>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(), "FeignDth"));
//			if(pxT!=null)then
//				pxT^.Init(GetHandle(), false, "dummy");
//				pxT^.SetUserCommand(p_bUserCommand);
//				AddTask(pxT,false);
			var ^CFeignDeath pxT=cast<CFeignDeath>(GetCurTask());
			if(pxT!=null)then
				pxT^.Break();
				bAdd=true;
			endif;
		endif;
		if(p_pxTarget!=null)then
			var ^CFightingObj pxFO=cast<CFightingObj>(p_pxTarget);
			if(pxFO!=null)then
				if(pxFO^.PeaceTime())then return; endif;
//				if(pxFO^.IsFeignDeath())then
//					if(bNewUserCmd)then
//						var ^CAnimal pxA=null;
//						if(pxFO^.GetType()!="ANML")then
//							if(pxFO^.GetTransportObj().IsValid())then
//								pxA=cast<CAnimal>(pxFO^.GetTransportObj().GetObj());
//							endif;
//						else
//							pxA=cast<CAnimal>(pxFO);
//						endif;
//						if(pxA!=null)then
//							pxA^.FeignDeathTask(false, "dummy");
//						endif;
//					else
//						return;
//					endif;
//				endif;
			endif;
			if(GetType()=="CHTR")then
				var ^CCharacter pxC=cast<CCharacter>(this);
				if(pxC^.GetTransportObj().IsValid()&&!pxC^.IsOnOpenTransporter())then
					var ^CFightingObj pxTransporter=cast<CFightingObj>(pxC^.GetTransportObj().GetObj());
					if(pxTransporter!=null)then
						if(pxTransporter^.IsTrapped())then return; endif;
					endif;
					if(!pxTransporter^.GetTransportObj().IsValid())then
//						pxTransporter^.HandleGamePlayCommand("Action", p_pxTarget, p_pxTarget^.GetPos(),"/AttackSrv");
						pxTransporter^.AttackSrv(p_pxTarget);
						return;
					else
						return;
					endif;
				endif;
			endif;
			m_xCurEnemy=p_pxTarget^.GetHandle();
			if(bNewUserCmd)then
				if(GetOwner()!=p_pxTarget^.GetOwner()&&!CMirageSrvMgr.Get().AllowAttackOwnStuff())then
					var bool bIsMultiplayerGame=false;
					var string sPlayerNameAttacker="unknown (attacker)";
					var string sPlayerNameDefender="unknown (defender)";
					var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
					if(pxLevel!=null)then
						var CLevelInfo xLevelInfo=pxLevel^.GetLevelInfo();
						bIsMultiplayerGame=xLevelInfo.IsMultiplayer();
						if(GetOwner()>=0)then
							var ^CPlayer pxPlayerAttacker=pxLevel^.GetPlayer(GetOwner());
							if(pxPlayerAttacker!=null)then
								sPlayerNameAttacker=xLevelInfo.GetPlayerSlot(pxPlayerAttacker^.GetPlayerSlotID()).GetName();
							endif;
						endif;
						if(p_pxTarget^.GetOwner()>=0)then
							var ^CPlayer pxPlayerDefender=pxLevel^.GetPlayer(p_pxTarget^.GetOwner());
							if(pxPlayerDefender!=null)then
								sPlayerNameDefender=xLevelInfo.GetPlayerSlot(pxPlayerDefender^.GetPlayerSlotID()).GetName();
							endif;
						endif;
					endif;
					if(!CSrvWrap.GetDiplomacyMgr().GetIsEnemy( p_pxTarget^.GetOwner(), GetOwner() )&&p_pxTarget^.GetOwner()>=0&&GetOwner()>=0)then
						//singleplayer: don't allow to attack a friend (either player is friend of target or target is friend of player)
						//multiplayer: no friends no more.
						if((sLevelName =="Single 01"||sLevelName =="Single 02"||
							sLevelName =="Single 03"||sLevelName =="SIngle 04"||
							sLevelName =="Single 05"||sLevelName =="Single 06"||
							sLevelName =="Single 07"||sLevelName =="Single 08"||
							sLevelName =="Single 09"||sLevelName =="Single 10"||
							sLevelName =="Single 11"||sLevelName =="Single 12"||
							sLevelName =="Single 13"||sLevelName =="Single 14"||
							sLevelName =="Single 15"||sLevelName =="Single 16"||
							sLevelName =="Single B41"||sLevelName =="Single B42"||
							sLevelName =="Single B43") &&
						(CSrvWrap.GetDiplomacyMgr().GetIsFriend(p_pxTarget^.GetOwner(), GetOwner())||
						CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), p_pxTarget^.GetOwner())))then
							CFeedback.Print(GetOwner(), CFeedback.INFO, "_NT_DiplAttackNonEnemyIsNotAllowed\t"+sPlayerNameDefender, p_pxTarget^.GetPos());
							return; // don't allow to attack in single player mode
						elseif(!bIsMultiplayerGame &&
						(CSrvWrap.GetDiplomacyMgr().GetIsFriend(p_pxTarget^.GetOwner(), GetOwner())||
						CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), p_pxTarget^.GetOwner())))then
							CFeedback.Print(GetOwner(), CFeedback.INFO, "_NT_DiplAttackNonEnemyIsNotAllowed\t"+sPlayerNameDefender, p_pxTarget^.GetPos());
							return; // don't allow to attack in single player mode
						elseif(bIsMultiplayerGame && pxFO!=null && AiOwner() && pxFO^.AiOwner())then
							return; // don't let stupid AI turn on each other in multiplayer
						else
//							if(CSrvWrap.GetGame().GetAttribInt("DiplomacyLocked")!=0&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), p_pxTarget^.GetOwner()))then
							if(CMirageSrvMgr.Get().DiploLocked()&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), p_pxTarget^.GetOwner())&&!CMirageSrvMgr.Get().PhantomMode())then
								CFeedback.Print(GetOwner(), CFeedback.INFO, "_NT_DiplAttackNonEnemyIsNotAllowed\t"+sPlayerNameDefender, p_pxTarget^.GetPos());
								return; // don't allow to attack in single player mode
							endif;
							var int iMe=GetOwner(), iOther=p_pxTarget^.GetOwner();
							var ^CBasePlayer pxPlayerAttacker=CBasePlayer.GetPlayer(iMe);
							var ^CBasePlayer pxPlayerDefender=CBasePlayer.GetPlayer(iOther);
							var bool bDeny=false, bOk=false;
							if(pxPlayerDefender!=null&&pxPlayerAttacker!=null)then
								bOk=true;
								bDeny=pxPlayerAttacker^.GetMaster()==iOther;
							endif;
							CSrvWrap.GetDiplomacyMgr().SetRelation(iOther, iMe, 0); //Enemy
							if(!bDeny)then
								CSrvWrap.GetDiplomacyMgr().SetRelation(iMe, iOther, 0);
							endif;
							if(bOk)then
								if(!bDeny)then
									pxPlayerAttacker^.SetDiplomacySilent(iOther, 0, false);
								endif;
								pxPlayerDefender^.SetDiplomacy(iMe, 0);
							endif;
							//if(!bIsMultiplayerGame)then  endif; // make self hostile towards target in singleplayer because one can not change diplomacy
							//send feedback to all players
							if(GetOwner()!=p_pxTarget^.GetOwner())then
								CFeedback.Print(CFeedback.ALL, CFeedback.DIPLOMACY, "_NT_DiplChangeEnemyAttacked\t"+sPlayerNameAttacker+"\t"+sPlayerNameDefender, p_pxTarget^.GetPos());
								//CSrvWrap.SendGenericEvtToPlayer(GetOwner(), "NewEnemy");
							endif;
							if(bDeny)then
								return;
							endif;
						endif;
					endif;
				endif;
			endif;
			if(bAlreadyInFight&&bNewUserCmd)then
				InvokeFightTask(m_xCurEnemy,p_vPos,bNewUserCmd, bAdd||p_bQ, bNoUserBerserkerMode);
			elseif(bAlreadyInAction)then
				return;
			else
				InvokeFightTask(m_xCurEnemy,p_vPos,bNewUserCmd, bAdd||p_bQ, bNoUserBerserkerMode);
			endif;
		else
			InvokeFightTask(CObjHndl.Invalid(), p_vPos, p_bUserCommand, bAdd||p_bQ, bNoUserBerserkerMode);
		endif;
	endproc;
	
//	###########################################################################################################
//	#### NEW FIGHTINGOBJ PROCS ################################################################################
//	###########################################################################################################
	
	///////
	//	ShoutForHelp()
	///////
	export proc void ShoutForHelp(bool p_bForced)
		var CGameTime xNow=CTimeMgr.Get().GetTime();
		if(!p_bForced)then
			var real fDuration=7.0;
			if(GetHitpoints()<GetMaxHitpoints())then
				fDuration=3.0;
			endif;
			if((xNow-m_xLastHelpShout).GetSecondsF()<fDuration)then
				return;
			endif;
		endif;
		var bool bDefend=true;
		var CObjHndl xEnemy;
		if(m_xHelpDefendEnemies.NumEntries()>0)then
			xEnemy=m_xHelpDefendEnemies[0];
		elseif(m_xHelpAttackEnemies.NumEntries()>0)then
			xEnemy=m_xHelpAttackEnemies[0];
			bDefend=false;
		else
			xEnemy=m_xCurEnemy;
			bDefend=false;
		endif;
		if(m_pxTaskMgr==null)then return; endif;
		var ^CTask pxTask=m_pxTaskMgr^.GetCurTask();
		if(pxTask!=null&&pxTask^.IsUserCommand())then return; endif;
		var CObjQuery xFriendSearch;
		var CObjList xFriends;
		var int i;
		xFriendSearch.SetOwner(GetOwner());
		xFriendSearch.RegionCircle(GetPos(),GetAlarmRange()*1.1);
		var CObjList xBuildings;
		if(GetOwner()==-1&&GetType()=="ANML")then
			xFriendSearch.SetClass(GetClassName());
		else
			xFriendSearch.SetType("CHTR");
			xFriendSearch.SetType("VHCL",true);
			xFriendSearch.SetType("ANML",true);
			if(xEnemy.IsValid()&&xEnemy.GetObj()^.GetType()=="SHIP")then
				xFriendSearch.SetType("SHIP",true);
			endif;
			if(GetTribeName()=="SEAS")then
				var CObjQuery xFriendBLDGSearch;
				xFriendBLDGSearch.SetOwner(GetOwner());
				xFriendBLDGSearch.RegionCircle(GetPos(),GetAlarmRange()*1.1);
				xFriendBLDGSearch.SetClass("seas_carrier");
				xFriendBLDGSearch.Exclude(GetHandle());
				xFriendBLDGSearch.Execute(xBuildings);
			endif;
		endif;
		xFriendSearch.Exclude(GetHandle());
		var CGameEvtPtr xEvt=CGameEvtPtr.CreateEvent("Fight");
		xEvt.SetObjHandle(0,xEnemy);
		xEvt.SetBool(1,bDefend);
		if(xFriendSearch.Execute(xFriends)||xBuildings.NumEntries()>0)then
			xFriends.Include(xBuildings);
			var int iC=xFriends.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				var ^CFightingObj pxFriend=cast<CFightingObj>(xFriends[i].GetObj());
				if(pxFriend==null)then continue; endif;
				if(!bDefend&&pxFriend^.GetAggressionState()==1)then continue; endif;
				if(pxFriend^.m_bIsHelpShout)then continue; endif;
				if(!pxFriend^.IsAbleToFight())then continue; endif;
				var ^CTask pxTask=pxFriend^.GetCurTask();
				if(pxTask!=null&&pxTask^.IsUserCommand())then continue; endif;
				pxFriend^.HandleEvent(xEvt);
			endfor;
		endif;
		m_xLastHelpShout=xNow;
		PlayHelpSound(xEnemy.GetObj(),xFriends);
		m_bIsHelpShout=false;
		m_xHelpDefendEnemies.Clear();
		m_xHelpAttackEnemies.Clear();
	endproc;
	
	proc bool PlayHelpSound(^CGameObj p_pxEnemy,CObjList p_xFriends)
		if(p_pxEnemy==null)then return(false);endif;
		//Different sounds can be played depending on the combatants and helpers.
		//Somehow it doensn't work...
		//Somehow? DbgView is overflowing with error Msgs!
		// Urs.Shared.GameObj WARN :3D Sound event not found: FX_AnimalHelpCryGeneric
		//PlaySound("FX_AnimalHelpCryGeneric"); //64 Byte Traffic
		InvokeGenericSCEvent(25,0.1f); //3 Byte Traffic
		return(true);
	endproc;
	
	///////
	//	SetAttrib()
	///////
	export proc void SetAttrib(string p_sName, string p_sValue)
		if(p_sName=="hitpoints")then
			m_fHitpoints=p_sValue.ToInt().ToReal();
		elseif(p_sName=="maxhitpoints")then
			m_fMaxHitpoints=p_sValue.ToInt().ToReal();
		elseif(p_sName=="tribe")then
			m_sTribe=p_sValue;
		elseif(p_sName=="level")then
			m_iLevel=p_sValue.ToInt();
		//Henry: to store new member values in unitattribs
		elseif(p_sName=="energy")then
			m_fEnergyState=p_sValue.ToInt().ToReal();
		elseif(p_sName=="maxenergy")then
			m_fMaxEnergy=p_sValue.ToInt().ToReal();
		elseif(p_sName=="replenishtime")then
			m_fReplenishTime=p_sValue.ToInt().ToReal();
		elseif(p_sName=="replenishamount")then
			m_fReplenishAmount=p_sValue.ToInt().ToReal();
		else
			super.SetAttrib(p_sName,p_sValue);
		endif;
	endproc;
	
	///////
	//	SetMovableInFight()
	///////
	export proc void SetMovableInFight(bool p_bMove)
		m_bMovableInFight=p_bMove;
	endproc;
	
	///////
	//	GetMovableInFight()
	///////
	export proc bool GetMovableInFight()
		return m_bMovableInFight;
	endproc;
	
	///////
	//	UpdateAggressive()
	///////
	proc void UpdateAggressive()
		//-1 - friedlich
		//0 - neutral
		//1 - aggressiv
		var int iAggressiv=GetTechTreeAggressiv();
		if(iAggressiv==1)then
			if(!HasTimer(TIMER_PREAGGRO))then
				var real fJitter=0.9+Random.MTRandF(0.2); //jitter by +- 10%
				CreateTimer(TIMER_PREAGGRO, CGameTimeSpan.OneSecond() * 7.0f * fJitter, true);
			endif;
			if(GetOwner()==-1)then
				SetAggressive(true);
			endif;
		else
			SetAggressive(false);
			if(HasTimer(TIMER_PREAGGRO))then
				DeleteTimer(TIMER_PREAGGRO);
			endif;
			if(HasTimer(TIMER_AGGRO))then
				DeleteTimer(TIMER_AGGRO);
			endif;
		endif;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("anml_aggressive_type",iAggressiv);
		endif;
	endproc;
	
	///////
	//	ActivateAggroTimer()
	///////
	proc void ActivateAggroTimer()
		if(!HasTimer(TIMER_AGGRO))then
			var ^CCharacter pxC=cast<CCharacter>(this);
			if(pxC!=null&&pxC^.GetTransportObj().IsValid()&&!pxC^.IsOnOpenTransporter())then
				return;
			endif;
			var real fJitter=0.9+Random.MTRandF(0.2);
			CreateTimer(TIMER_AGGRO, CGameTimeSpan.OneSecond()*3.0f*fJitter, true);
		endif;
	endproc;
	
	///////
	//	GetAggressive()
	///////
	export proc int GetAggressive()
		return GetTechTreeAggressiv();
	endproc;
	
	///////
	//	SetAlarmed()
	///////
	export proc void SetAlarmed(bool p_bStatus)
		SetAlarmed(p_bStatus, CObjHndl.Invalid());
	endproc;
	
	export proc void SetAlarmed(bool p_bStatus, CObjHndl p_xObj)
		//Henry: disable little red exclamation mark if the unit is disguised (see aje shaman, ninigi ninja)
		if(p_xObj.IsValid())then
			var ^CFightingObj pxFight=cast<CFightingObj>(p_xObj.GetObj());
			if(pxFight!=null)then
				var ^CAttribs pxAttribs=pxFight^.GetAttribs();
				if(pxAttribs!=null)then
					if(pxAttribs^.GetValueBool("active_disguise")||pxAttribs^.GetValueBool("active_camouflage")||pxFight^.GetNeutralObject())then return; endif;
				endif;
			endif;
		endif;
		if(GetAggressive()>=0)then
			//L CSrvWrap.LogInfo("FightingObj","SetAlarmed("+p_bStatus.ToString()+")");
			var ^CAttribs pxAttr=GetAttribs();
			if(pxAttr!=null)then
				pxAttr^.SetValue("alarmed",p_bStatus);
			endif;
			SetAlarmSign(p_bStatus);
			if(p_bStatus)then
				if(GetType()=="ANML"&&GetOwner()==-1)then
					if(!IsInFight()&&(m_pxTaskMgr^.GetCurTask()==null||m_pxTaskMgr^.GetCurTask()==m_pxIdleState||m_pxTaskMgr^.GetCurTask()^.GetName()=="Walk2Pos"))then
						SetThreatTask(p_xObj);
					endif;
				elseif(!HasAction()&&m_pxTaskMgr^.GetCurTask()==m_pxIdleState||m_pxTaskMgr^.GetCurTask()==null)then
					SetThreatTask(p_xObj);
				endif;
//				var vec3 vOffset={0.0,0.0,0.0};
//				vOffset.SetZ(GetSize().GetZ()+1.0);
//				var ^CSign pxNewObj=cast<CSign>(CSrvWrap.GetObjMgr()^.CreateObj("Alarm_Sign",GetOwner(),GetPos()+vOffset,GetRotation()));
//				pxNewObj^.SetCountDown(5.0, GetHandle());
				var ^CCharacter pxC=cast<CCharacter>(this);
				if(pxC!=null&&pxC^.GetTransportObj().IsValid())then
					return;
				endif;
				if(!HasTimer(TIMER_ALARM))then
					CreateTimer(TIMER_ALARM, CGameTimeSpan.OneSecond() * 10.0, false);
				endif;
			endif;
		endif;
	endproc;
	
	export proc void SetThreatTask(CObjHndl p_xHndl)
		if(!GetThreatAnim().IsEmpty())then
			var ^CAlarmed pxTask=cast<CAlarmed>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(), "Alarmed"));
			if(pxTask==null)then return; endif;
			var bool bR=pxTask^.Init(GetHandle(),p_xHndl);
			if(bR)then
				pxTask^.SetUserCommand(false);
				AddTask(pxTask,false);
			else
				pxTask^.GetFactory()^.FreeState(pxTask);
			endif;
		endif;
	endproc;
	
	export proc string GetThreatAnim()
		return "menace";
	endproc;
	
	export proc void SetInvisibleFlag(bool p_bStatus)
		m_bInvisibleFlag=p_bStatus;
	endproc;
	
	export proc ref bool GetInvisibleFlag()
		return m_bInvisibleFlag;
	endproc;
	
	///////
	//	SetProjectile()
	///////
	export proc void SetProjectile(string p_sArrow)
		m_sProjectile=p_sArrow;
		var ^CAttribs pxA=GetAttribs();
		if(pxA!=null)then
			pxA^.SetValue("projectile", p_sArrow);
		endif;
	endproc;
	
	///////
	//	SetProjectileGfx()
	///////
	export proc void SetProjectileGfx(string p_sModel)
		m_sProjectileGfx=p_sModel;
	endproc;
	
	///////
	//	GetProjectile()
	///////
	export proc ref string GetProjectile()
		return m_sProjectile;
	endproc;
	
	///////
	//	GetProjectileGfx()
	///////
	export proc ref string GetProjectileGfx()
		return m_sProjectileGfx;
	endproc;
	
	export proc bool NextJob(CObjHndl p_xTarget, CObjList p_xIgnoreBuildUps)
		if(m_pxTaskMgr==null)then return false; endif;
		if(!p_xTarget.IsValid())then return false; endif;
		var int i,iC=m_pxTaskMgr^.NumSubs();
		for(i=1)cond(i<iC)iter(i++)do
			if(m_pxTaskMgr^.GetSubState(i)^.GetName()=="BuildUp")then
				return false;
			endif;
		endfor;
		var ^CBuilding pxBuilding=cast<CBuilding>(p_xTarget.GetObj());
		if(pxBuilding!=null && pxBuilding^.GetClassName().Find("_portal_terminus")!=-1 && pxBuilding^.IsReady() && CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxBuilding^.GetOwner())&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxBuilding^.GetOwner(), GetOwner()))then
			EnterPortal(pxBuilding,false,pxBuilding^.GetPos());
			return true;
		endif;
		GoTo(p_xTarget.GetObj()^.GetPos(), true, GetDefaultSpeed(), true, true);
		return true;
	endproc;
	
	export proc void SetRealProjectile(string p_sArrow)
		m_sRealProjectile=p_sArrow;
	endproc;
	
	export proc ref string GetRealProjectile()
		return m_sRealProjectile;
	endproc;
	
	export proc ^CArrow CreateProjectileAndShoot(^CFightingObj p_pxEnemy, vec3 p_vPos)
		var string sProj=GetProjectile()+GetWeaponMgr()^.GetRightHVariationPostfix();
		return CreateProjectileAndShoot(p_pxEnemy, p_vPos, sProj);
	endproc;
	
	export proc ^CArrow CreateProjectileAndShoot(^CFightingObj p_pxEnemy, vec3 p_vPos, string p_sProjectileType)
		var ^CArrow pxArrow=cast<CArrow>(CSrvWrap.GetObjMgr()^.CreateObj(p_sProjectileType,GetOwner(),GetProjectileStartPos()));
		if(pxArrow!=null)then
			if(p_pxEnemy==null)then
				var real fPrev=p_vPos.GetZ();
				var real fScapeZ=CSrvWrap.GetScapeMgr().GetHeight(p_vPos.GetX(), p_vPos.GetY());
				p_vPos.SetZ(fScapeZ);
				//p_vPos.SetZ(fScapeZ+5.0);
				pxArrow^.SetAttackScape(this, p_vPos);
			else
				pxArrow^.Set(this, p_pxEnemy);
			endif;
		endif;
		var string sClassName=GetClassName();
		if(sClassName=="seas_rocketman"||sClassName=="ninigi_mortar"||sClassName=="shooter_lvl3")then
			InvokeGenericSCEvent(36,2.5f);
		endif;
		return pxArrow;
	endproc;
	
	export proc bool CreateProjectileAndShootBuildUp(^CFightingObj p_pxEnemy, vec3 p_vPos, ^CBuildUpWeapon p_pxBuildUp)
		if(p_pxBuildUp==null)then return false; endif;
		var string sProj=p_pxBuildUp^.GetProjectile()+GetWeaponMgr()^.GetRightHVariationPostfix();
		if(sProj.IsEmpty())then
			return false;
		endif;
		var ^CArrow pxArrow=cast<CArrow>(CSrvWrap.GetObjMgr()^.CreateObj(sProj,GetOwner(),p_pxBuildUp^.GetProjectileStartPos()));
		if(pxArrow!=null)then
			if(p_pxEnemy==null)then
				pxArrow^.SetAttackScape(this, p_vPos);
			else
				pxArrow^.Set(this, p_pxEnemy, p_pxBuildUp);
			endif;
			return true;
		endif;
		return false;
	endproc;
	
	export proc real GetProjectileDelay()
		return m_xCurrentFightAnim.m_fShootDelay;
		//return m_fProjectileDelay;
	endproc;
	
	export proc void SetProjectileDelay(real p_fDelay)
		m_fProjectileDelay=p_fDelay;
	endproc;
	
	export proc ref real GetProjectileFallOff()
		return m_fProjectileFallOff;
	endproc;
	
	export proc void SetProjectileFallOff(real p_fFallOff)
		m_fProjectileFallOff=p_fFallOff;
	endproc;
	
	export proc ref real GetProjectileSpeed()
		return m_fProjectileSpeed;
	endproc;
	
	export proc void SetProjectileSpeed(real p_fSpeed)
		m_fProjectileSpeed=p_fSpeed;
	endproc;
	
	export proc void SetProjectileJitter(real p_fJitter)
		m_fProjectileJitter=p_fJitter;
	endproc;
	
	export proc real GetProjectileJitter()
		return m_fProjectileJitter;
	endproc;
	
	export proc void SetPenetration(bool p_bPenetration)
		m_bPenetration=p_bPenetration;
	endproc;
	
	export proc void SetPenetrationAngle(real p_fPenetrationAngle)
		m_fPenetrationAngle=p_fPenetrationAngle;
	endproc;
	
	export proc ref bool GetPenetration()
		return m_bPenetration;
	endproc;
	
	export proc ref real GetPenetrationAngle()
		return m_fPenetrationAngle;
	endproc;
	
	export proc vec3 GetProjectileStartPos()
		var vec3 vPos;
		if(!GetLinkPosWorld(GetProjectileLink(), vPos))then
			var vec3 vSize=GetSize();
			vPos=GetPos();
			vPos.SetZ(vPos.GetZ()+vSize.GetZ()*0.7);
		endif;
		return vPos;
	endproc;
	
	export proc vec3 GetProjectileStartPos(int p_iIdx)
		return GetPos();
	endproc;
	
	export proc CFourCC GetProjectileLink()
		var CFourCC xL="Proj";
		return xL;
	endproc;
	
	export proc real GetProjectileFallOffCone(real p_fRange)
		return FALLOFFCONE_VAL/Math.Max(p_fRange,0.01f);
	endproc;
	
	export proc real GetProjectileFallOffCone()
		return FALLOFFCONE_VAL/Math.Max(GetAttackRange(),0.01f);
	endproc;
	
	///////
	//	ShowWeapons()
	///////
	export proc void ShowWeapons()
	endproc;
	
	export proc void UpdateWeaponsGfx()
	endproc;
	
	///////
	//	HideWeapons()
	///////
	export proc void HideWeapons()
	endproc;
	
	///////
	//	GetWeaponDuration()
	///////
	export proc real GetWeaponDuration()
		return m_fWeaponDuration;
		//return (m_fWeaponDuration*ms_fDurationFactor);
	endproc;
	
	///////
	//	SetWeaponDuration()
	///////
	export proc void SetWeaponDuration(real p_fDuration)
		m_fWeaponDuration=p_fDuration;
	endproc;
	
	///////
	//	GetWeaponDuration()
	///////
	export proc ref real GetHitDelay()
		return m_xCurrentFightAnim.m_fDelay;
	endproc;
	
	///////
	//	GetAttackPenetrate()
	///////
	export proc ref bool GetAttackPenetrate()
		return m_xCurrentFightAnim.m_bPenetrate;
	endproc;
	
	///////
	//	GetAttackAngle()
	///////
	export proc ref real GetAttackAngle()
		return m_xCurrentFightAnim.m_fAngle;
	endproc;
	
	///////
	//	GetAttackSplash()
	///////
	export proc ref real GetAttackSplash()
		return m_xCurrentFightAnim.m_fSplash;
	endproc;
	
	///////
	//	GetAttackFactor()
	///////
	export proc ref real GetAttackFactor()
		return m_xCurrentFightAnim.m_fFactor;
	endproc;
	
	///////
	//	SetWeaponDuration()
	///////
	export proc void SetHitDelay(real p_fHitDelay)
		m_fHitDelay=p_fHitDelay;
	endproc;
	
	///////
	//	GetAggresionState()
	///////
	export proc int GetAggressionState()
		if(!IsAbleToFight())then
			return 1;
		endif;
		return m_iAggressionState;
	endproc;
	
	///////
	//	SetAggessionState()
	///////
	export proc void SetAggressionState(int p_iState)
		if(m_iAggressionState==4)then return; endif;
		m_iAggressionState=p_iState;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("AggressionState",m_iAggressionState);
		endif;
		if(p_iState==3)then
			m_xReturnEnemy=CObjHndl.Invalid();
			m_xCurEnemy=CObjHndl.Invalid();
		endif;
	endproc;
	
	///////
	//	GetMinAttackRange()
	///////
	export proc ref real GetMinAttackRange()
		return m_fMinAttackRange;
	endproc;
	
	export proc void SetMinAttackRange(real p_fValue)
		m_fMinAttackRange=p_fValue;
	endproc;
	
	export proc ref real GetRealMinAttackRange()
		return m_fRealMinAttackRange;
	endproc;
	
	export proc void SetRealMinAttackRange(real p_fValue)
		m_fRealMinAttackRange=p_fValue;
	endproc;
	
	///////
	//	GetAttackRange()
	///////
	export proc real GetAttackRange()
		var real fRad=GetRadius();
		if(GetType()=="CHTR")then
			fRad=2.0f; //RT#6302
		endif;
		if(!GetRealProjectile().IsEmpty())then
			fRad=0.0; //long range
		endif;
		m_fRealAttackRange=m_fAttackRange+fRad;
		if(m_bDarkSwarm)then
			return 2.0f;
		endif;
		return (m_fRealAttackRange)+AddTemporaryRangeBoni();
	endproc;
	
	///////
	//	SetAttackRange()
	///////
	export proc void SetAttackRange(real p_fRange)
		m_fAttackRange=p_fRange;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("range",(m_fAttackRange+0.5).ToInt());
			pxAttr^.SetValue("range_marker",GetAttackRangeForMarker());
		endif;
		SetAlarmRange(Math.Clamp(GetAttackRange()+8.0,32.0,GetFOWRange()));
	endproc;
	
	export proc real GetAttackRangeForMarker()
		if(!IsAbleToFight())then return 0.0f; endif;
		var real fRad=GetRadius();
		if(GetType()=="CHTR")then
			fRad=2.0f;
		endif;
		if(!GetRealProjectile().IsEmpty())then
			fRad=0.0;
		endif;
		m_fRealAttackRange=m_fAttackRange+fRad;
		if(m_bDarkSwarm)then
			return 2.0f;
		endif;
		return (m_fRealAttackRange)+AddTemporaryRangeBoni();
	endproc;
	
	export proc ref real GetSecondaryRangeM()
		var real fRad=GetRadius();
		if(GetType()=="CHTR")then
			fRad=1.5f;
		endif;
		m_fRealSecRangeM=m_fSecRangeM+fRad;
		return (m_fRealSecRangeM);
	endproc;
	
	export proc ref real GetSecondaryRangeS()
		var real fRad=GetRadius();
		if(GetType()=="CHTR")then
			fRad=1.5f;
		endif;
		m_fRealSecRangeS=m_fSecRangeS+fRad;
		return (m_fRealSecRangeS);
	endproc;
	
	export proc void SetSecondaryRangeM(real p_fRange)
		m_fSecRangeM=p_fRange;
	endproc;
	
	export proc void SetSecondaryRangeS(real p_fRange)
		m_fSecRangeS=p_fRange;
	endproc;
	
	///////
	//	SetFOWRange()
	///////
	export proc void SetFOWRange(real p_fRange)
		var real fFow=p_fRange+GetBonusSum(BONUS_FOWRANGE);
		m_fFOWRange=fFow;
		if(m_bBlinded)then
			fFow=1.0;
		endif;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			if(pxAttr^.GetValueFloat("FowRange")!=fFow)then
				pxAttr^.SetValue("FowRange",fFow);
			endif;
		endif;
		SetFOW(fFow);
		if(m_xHiveMind.IsValid())then
			var ^CGameObj pxHM=GetHiveMind().GetObj();
			if(pxHM!=null)then
				pxHM^.SetFOW(fFow);
			endif;
		endif;
	endproc;
	
	///////
	//	GetFOWRange()
	///////
//	export proc ref real GetFOWRange()
	export proc real GetFOWRange()
		if(m_bBlinded)then
			return 1.0;
		endif;
		return m_fFOWRange;
	endproc;
	
	export proc ref real GetArmorPiercing()
		return m_fArmorPiercing;
	endproc;
	
	export proc void SetArmorPiercing(real p_fValue)
		m_fArmorPiercing=p_fValue;
	endproc;
	
	export proc ref real GetAlarmRange()
		return m_fAlarmRange;
	endproc;
	
	export proc void PickUp(CObjHndl p_xItem,bool p_bQueue)
		if(!IsAbleToWalk())then return; endif;
		var CFourCC xType=GetType();
		if(xType!="ANML"&&xType!="CHTR"&&xType!="VHCL")then return; endif;
		var ^CPickUp pxTask=cast<CPickUp>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"PickUp"));
		if(pxTask==null)then return; endif;
		var bool bR=pxTask^.Init(GetHandle(),p_xItem);
		if(bR)then
			pxTask^.SetUserCommand(true);
			AddTask(pxTask,p_bQueue);
		else
			pxTask^.GetFactory()^.FreeState(pxTask);
		endif;
	endproc;
	
	export proc void DropItem(CGuid p_xGuid, vec3 p_vDropPos,bool p_bQueue)
		var ^CDropItem pxTask=cast<CDropItem>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"DropItem"));
		if(pxTask==null)then return; endif;
		var bool bR=pxTask^.Init(GetHandle(),p_xGuid, p_vDropPos);
		if(bR)then
			pxTask^.SetUserCommand(true);
			AddTask(pxTask,p_bQueue);
		else
			pxTask^.GetFactory()^.FreeState(pxTask);
		endif;
	endproc;
	
	export proc void UseItem(^CGameObj p_pxObject)
		if(p_pxObject!=null)then
			var ^CInventory pxInv=GetInventory();
			if(pxInv==null)then return; endif;
			var int i, iC=pxInv^.Count();
			for(i=0) cond(i<iC) iter(++i)do
				if(pxInv^.GetItem(i)==p_pxObject^.GetHandle())then
					(cast<CItem>(p_pxObject))^.OnUsed(this);
					break;
				endif;
			endfor;
		endif;
	endproc;
	
	///////
	//	SetAlarmRange()
	///////
	export proc void SetAlarmRange(real p_fRange)
		m_fAlarmRange=p_fRange;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("alarm_range",(GetAlarmRange()+0.5).ToInt());
			var real fRange=m_fAlarmRange;
			if(!IsAbleToFight())then
				fRange=0.0f;
			endif;
			pxAttr^.SetValue("alarm_range_marker",fRange);
		endif;
	endproc;
	
	export proc bool InitFinishingMove(^CGameObj p_pxFighter, ^CGameObj p_pxEnemy);
//		if(!CMirageSrvMgr.Get().UseFinishingMoves())then return false; endif;
		if(p_pxFighter==null||p_pxEnemy==null)then return false; endif;
		var ^CFightingObj pxFighter=cast<CFightingObj>(p_pxFighter);
		var ^CFightingObj pxEnemy=cast<CFightingObj>(p_pxEnemy);
		if(pxFighter==null||pxEnemy==null)then return false; endif;
		if(!(pxFighter^.GetCurEnemy()==pxEnemy^.GetHandle()))then return false; endif;
		if(pxEnemy^.m_bIsGettingFinished)then return false; endif;
//		if(pxEnemy^.GetMirageFlag(CFightingObj.MIRAGE_BIG_HORN))then return false; endif;
		var string sClass=pxFighter^.GetClassName();
		var string sEnemyClass=pxEnemy^.GetClassName();
		var string sExecutor=pxFighter^.GetFinishingClass(false);
		var string sVictim=pxEnemy^.GetFinishingClass(true);
		if(sClass==""||sEnemyClass=="")then return false; endif;
//		if(m_iFinishingMoveIdx==-1)then return false; endif;
		if(m_bDoingFinishingMove)then return false; endif;
		if(m_xLastFinishingVictim==m_xCurEnemy)then return false; endif;
		//Henry: HACK for brachio transporter and for others just in case, because there are rumors of bugs, like heroes vanished because of finishing move of their transporter (should be tested if it works...)
		if(pxEnemy^.HasTransportBuildUp())then
			pxEnemy^.Evacuate();
		endif;
		//END HACK
//		var ^CFinishingMoveMgr.CMoveDef pxMove=CFinishingMoveMgr.Get().FindMove(m_iFinishingMoveIdx,p_pxEnemy);
		var ^CFinishingMoveMgr.CMoveDef pxMove=CFinishingMoveMgr.Get().FindMove(sExecutor,sVictim,sClass,sEnemyClass);
		if(pxMove==null)then
			return false;
		endif;
		var ^CFinishingMove pxTask= cast<CFinishingMove>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(), "Finish"));
		if(pxTask==null)then return false; endif;
		var bool bReturn=pxTask^.Init(GetHandle(),m_xCurEnemy,pxMove^);
		if(bReturn)then
			pxTask^.SetUserCommand(true);
			SetTaskImmediate(pxTask);
			m_xLastFinishingVictim=m_xCurEnemy;
		else
			GetFSM()^.FreeStateDelayed(pxTask);
		endif;
		return bReturn;
	endproc;
	
	///////
	//	GetNextFightAnim()
	///////
	export proc string GetNextFightAnim()
		if(m_asFightAnims.NumEntries()>0)then
			var string sFollow=m_xCurrentFightAnim.m_sFollowAnim;
			if(sFollow!="")then
				var int i, iC=m_axFightAnims.NumEntries();
				for(i=0)cond(i<iC)iter(i++)do
					if(m_axFightAnims[i].m_sAnim==sFollow)then
						m_xCurrentFightAnim=m_axFightAnims[i];
						break;
					endif;
				endfor;
			else
				var int iCount=m_axFightAnims.NumEntries();
				var int iRandom;
				repeat
					iRandom=Random.GetInt()%iCount;
				until(!m_axFightAnims[iRandom].m_bIsComboAnim)endrepeat;
				m_xCurrentFightAnim=m_axFightAnims[iRandom];
			endif;
		else
			m_xCurrentFightAnim.Clear();
		endif;
		return GetFightAnim();
	endproc;
	
	export proc string GetFightAnim()
		return m_xCurrentFightAnim.m_sAnim;
	endproc;
	
	export proc ref real GetProjectileOn()
		return m_xCurrentFightAnim.m_fProjectileTimeOutStart;
	endproc;
	
	export proc ref real GetProjectileOff()
		return m_xCurrentFightAnim.m_fProjectileTimeOutEnd;
	endproc;
	
	export proc void SetProjectileOnTimer()
		var real fTimeOut=GetProjectileOn();
		if(fTimeOut>0.0)then
			m_pxTimeOnTick^.SetTimer(fTimeOut);
		endif;
	endproc;
	
	export proc void SetProjectileOffTimer()
		var real fTimeOut=GetProjectileOff();
		if(fTimeOut>0.0)then
			m_pxTimeOffTick^.SetTimer(fTimeOut);
		endif;
	endproc;
	
	export proc void ProjectileOn()
		if(GetProjectile().IsEmpty())then return; endif;
		var CFourCC xLink=GetProjectileLink();
		var vec3 vP;
		if(GetLinkPosObj(xLink, vP))then
			SetLinkGFX(xLink,GetProjectileGfx()+GetWeaponMgr()^.GetRightHVariationPostfix());
		endif;
	endproc;
	
	export proc void ProjectileOff()
		if(GetProjectile().IsEmpty())then return; endif;
		var CFourCC xLink=GetProjectileLink();
		var vec3 vP;
		if(GetLinkPosObj(xLink, vP))then
			RemLinkGFX(xLink);
		endif;
	endproc;
	
	///////
	//	SetFightAnim()
	///////
	export proc void SetFightAnim(ref CFightingObj.CFightAnim p_rxAnim)
		ClearFightAnims();
		AddFightAnim(p_rxAnim);
	endproc;
	
	export proc void ClearFightAnims()
		m_asFightAnims=0;
		m_axFightAnims=0;
		m_xCurrentFightAnim.Clear();
	endproc;
	
	///////
	//	AddFightAnim()
	///////
	export proc void AddFightAnim(string p_sAnim)
		m_asFightAnims.AddEntry(p_sAnim);
	endproc;
	
	export proc void AddFightAnim(ref CFightingObj.CFightAnim p_rxAnim)
		m_asFightAnims.AddEntry(p_rxAnim.m_sAnim);
		m_axFightAnims.AddEntry(p_rxAnim);
		m_xCurrentFightAnim=p_rxAnim;
	endproc;
	
	export proc void UpdateTechTree()
	endproc;
	
	///////
	//	UpdateEquipment()
	///////
	export proc void UpdateEquipment()
		var string sWeapon=GetRightHandWeapon();
		var string sWeaponM=GetSecondaryWeaponM();
		var string sWeaponS=GetSecondaryWeaponS();
		UpdateWeapons(sWeapon);
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr==null)then return; endif;
		if(pxAttr^.GetValue("Equip_Slot_0")!=sWeapon)then
			pxAttr^.SetValue("Equip_Slot_0",sWeapon);
		endif;
		if(pxAttr^.GetValue("Equip_Slot_1")!=sWeaponM)then
			pxAttr^.SetValue("Equip_Slot_1",sWeaponM);
		endif;
		if(pxAttr^.GetValue("Equip_Slot_2")!=sWeaponS)then
			pxAttr^.SetValue("Equip_Slot_2",sWeaponS);
		endif;
		m_bWeaponHasChanged=true;
		m_bOwnWeaponHasChanged=true;
	endproc;
	
	export proc bool Disarmed()
		return m_bWeaponRemoved;
	endproc;
	
	export proc bool WeaponHasChanged()
		if(m_bWeaponHasChanged)then
			m_bWeaponHasChanged=false;
			return true;
		endif;
		return false;
	endproc;
	
	export proc bool OwnWeaponHasChanged()
		if(m_bOwnWeaponHasChanged)then
			m_bOwnWeaponHasChanged=false;
			return true;
		endif;
		return false;
	endproc;
	
	export proc void UpdateWeapons(string p_sPrimaryWeapon)
		var bool bWeaponChanged=p_sPrimaryWeapon!=m_sCurrentWeapon;
		var int i, iC=m_axWeaponCaches.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFightingObj.CWeaponCache pxCache=^(m_axWeaponCaches[i]);
			if(pxCache^.m_sWeaponPath==p_sPrimaryWeapon)then
				ReloadWeaponCache(pxCache);
				if(bWeaponChanged)then
					UpdateWeaponsGfx();
				endif;
				UpdateRangeNDamageInformation();
				return;
			endif;
		endfor;
		m_sCurrentWeapon=p_sPrimaryWeapon;
		if(bWeaponChanged)then
			UpdateWeaponsGfx();
		endif;
		var ^CTechTree.CNode pxNode=m_xTechTree.FindNode(p_sPrimaryWeapon);
		if(pxNode==null)then return; endif;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			if(pxAttr^.GetValue("Cur_Weapon")!=m_sCurrentWeapon)then
				pxAttr^.SetValue("Cur_Weapon",m_sCurrentWeapon);
			endif;
		endif;
		ClearFightAnims();
		SetProjectile("");
		SetProjectileGfx("");
		SetWeaponDuration(0.5);
		var real fDmg=0.0f;
		var real fMinDmg=0.0f;
		var real fProtect=0.0f;
		var real fRangedProtect=0.0f;
		var real fEndDmg=0.0f;
		var real fHitrange=0.0f;
		var real fAttackRange=0.0f;
		var real fPoisonDmg=0.0;
		var int iPoisonMaxTickCount=0;
		var bool bPenetration=false;
		var bool bProjectile=false;
		var real fPenetrationAngle=0.0;
		var real fPenetrationFactor=0.0;
		var real fMinAttackRange=0.0;
		var real fArmorPiercing=0.0;
		var int iWeaponSizeClass=0;
		//Henry: for flamethrowers
		var real fFireDmg=0.0;
		var int iBurnTime=0;
		var bool bAirWeapon=false;
		var array ^CTechTree.CNode apxNodes;
		if(pxAttr!=null)then
			var int iNumProjectiles;
			iWeaponSizeClass=pxNode^.GetSubValueI("unit_size",0);
			var ^CTechTree.CNode pxProjectiles=pxNode^.GetSub("Projectile");
			if(pxProjectiles!=null)then
				iNumProjectiles=pxProjectiles^.NumSubs();
				if(iNumProjectiles > 0)then
					bProjectile=true;
					var string sProj=pxProjectiles^.GetSubValue("0");
					SetProjectile(sProj);
					SetProjectileGfx(pxProjectiles^.GetSubValue("1",sProj));
					SetProjectileFallOff(pxNode^.GetSubValueF("bulletfalloff",0.0));
					SetProjectileSpeed(pxNode^.GetSubValueF("bulletspeed",0.0));
					SetProjectileJitter(pxNode^.GetSubValueF("jitter",0.0));
					if(p_sPrimaryWeapon==GetRightHandWeapon())then
						SetRealProjectile(GetProjectile());
					endif;
				endif;
			endif;
			apxNodes.AddEntry(pxNode);
			var real fFrequency=pxNode^.GetSubValueF("frequency");
			if(fFrequency==0.0)then
				fFrequency=1.0;
			endif;
			var real fDuration=(60.0/fFrequency);
			fDuration *= GetTechTreeModifier("WeaponDuration",true);
			fDuration += GetTechTreeModifier("WeaponDuration",false);
			fDuration *= GetAICheatModifier();
			SetWeaponDuration(fDuration);
			var ^CTechTree.CNode pxAnims=pxNode^.GetSub("Animations");
			if(pxAnims!=null)then
				var int i, iC=pxAnims^.NumSubs();
				for(i=0) cond(i<iC) iter(++i)do
					var ^CTechTree.CNode pxCurAnim=pxAnims^.GetSub(i);
					if(pxCurAnim!=null)then
						var CFightingObj.CFightAnim xAnim;
						xAnim.m_sAnim=pxCurAnim^.GetValue();
						xAnim.m_fDelay=pxCurAnim^.GetSubValueF("delay",0.0);
						xAnim.m_fFactor=pxCurAnim^.GetSubValueF("factor",1.0);
						xAnim.m_fAngle=pxCurAnim^.GetSubValueF("angle",0.0);
						xAnim.m_fSplash=pxCurAnim^.GetSubValueF("splash",0.0)/100.0f;
						xAnim.m_sFollowAnim=pxCurAnim^.GetSubValue("followanim");
						xAnim.m_bIsComboAnim=pxCurAnim^.GetSubValueB("combo",false);
						xAnim.m_bPenetrate=pxCurAnim^.GetSubValueB("penetrate",false);
						xAnim.m_fShootDelay=pxCurAnim^.GetSubValueF("shootdelay",0.0);
						xAnim.m_fProjectileTimeOutStart=pxCurAnim^.GetSubValueF("projectile_on",0.0);
						xAnim.m_fProjectileTimeOutEnd=pxCurAnim^.GetSubValueF("projectile_off",0.0);
						AddFightAnim(xAnim);
					endif;
				endfor;
			endif;
			var string sLH=GetLeftHandWeapon();
			var string sAr=GetArmor();
			apxNodes.AddEntry(m_xTechTree.FindNode(sLH));
			apxNodes.AddEntry(m_xTechTree.FindNode(sAr));
			var int i, iC =apxNodes.NumEntries();
			for (i=0) cond(i<iC) iter(++i)do
				var ^CTechTree.CNode pxCur=apxNodes[i];
				fDmg += pxCur^.GetSubValueF("damage");
				if(m_bIsWildAnimal)then
					fDmg += GetWildAnimalAttackBonus(GetLevel());
				endif;
				fMinDmg += pxCur^.GetSubValueF("mindamage",5.0);
				fProtect += pxCur^.GetSubValueF("defense");
				fRangedProtect += pxCur^.GetSubValueF("rangeddefense");
				fEndDmg += pxCur^.GetSubValueF("enddamage",0.0);
				fPoisonDmg += pxCur^.GetSubValueF("poison_damage",0.0);
//				fArmorPiercing = Math.Max(fArmorPiercing, pxCur^.GetSubValueF("armorpiercing"));
				var real fMax=m_fMaxDef*100.0f;
				fArmorPiercing = Math.Clamp(pxCur^.GetSubValueF("armorpiercing",0.0),fArmorPiercing,fMax);
				fMinAttackRange = Math.Max(fMinAttackRange, pxCur^.GetSubValueF("minattackrange",0.0));
				fHitrange = Math.Max(fHitrange, pxCur^.GetSubValueF("hitrange",0.0));
				fAttackRange = Math.Max(fAttackRange, pxCur^.GetSubValueF("range"));
				iPoisonMaxTickCount = Math.Max(iPoisonMaxTickCount, pxCur^.GetSubValueI("poison_tick_count",0));
				bPenetration = bPenetration||pxCur^.GetSubValueI("penetration",0)==1;
				fPenetrationAngle = Math.Max(fPenetrationAngle, pxCur^.GetSubValueF("penetration_angle",0.0));
				fPenetrationFactor = Math.Max(fPenetrationFactor, (pxCur^.GetSubValueF("penetration_factor",0.0)/100.0f));
				//Henry: for flamethrowers to get values from techtree
				fFireDmg += pxCur^.GetSubValueF("fire_damage",0.0);
				iBurnTime = Math.Max(iBurnTime, pxCur^.GetSubValueI("fire_tick_count",0));
				bAirWeapon = bAirWeapon||pxCur^.GetSubValueB("airweapon",false);
			endfor;
			if(bProjectile)then
				fDmg *= GetTechTreeModifier("ranged_damage",true);
				fDmg += GetTechTreeModifier("ranged_damage",false);
			else
				fDmg *= GetTechTreeModifier("melee_damage",true);
				fDmg += GetTechTreeModifier("melee_damage",false);
			endif;
			SetDmg(fDmg * GetTechTreeModifier("Damage",true)+GetTechTreeModifier("Damage",false));
			SetMinDmg(fMinDmg);
			var real fMaxDef=m_fMaxDef*100.0f;
			SetProtection(Math.Clamp(fProtect * GetTechTreeModifier("Defence",true)+GetTechTreeModifier("Defence",false), 0.0f, fMaxDef));
			SetRangedProtection(Math.Clamp(fRangedProtect * GetTechTreeModifier("RangedDefence",true)+GetTechTreeModifier("RangedDefence",false), 0.0f, fMaxDef));
			SetArmorPiercing(fArmorPiercing);
			SetMinAttackRange(fMinAttackRange);
			SetPenetration(bPenetration);
			SetPenetrationAngle(fPenetrationAngle);
			SetPenetrationFactor(fPenetrationFactor);
			SetHitRange(fHitrange);
			SetEndDmg(fEndDmg);
			SetPoisonDmg(fPoisonDmg);
			SetPoisonMaxTickCount(iPoisonMaxTickCount);
			SetWeaponSizeClass(iWeaponSizeClass);
			//Henry: for flamethrowers
			SetFireDmg(fFireDmg);
			SetBurnTime(iBurnTime);
			//Henry: to set can fight air attrib
			SetCanFightAir(bAirWeapon);
			if(p_sPrimaryWeapon==GetRightHandWeapon())then
				SetAttackRange(fAttackRange * GetTechTreeModifier("Range",true)+GetTechTreeModifier("Range",false));
				SetRealMinAttackRange(fMinAttackRange);
				SetRealHitRange(fHitrange);
			endif;
		endif;
		UpdateWeaponBoni();
		AddWeaponCache();
		UpdateRangeNDamageInformation();
	endproc;
	
	export proc real GetAICheatModifier()
		var real fValue=1.0;
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel==null)then return fValue; endif;
		var ^CAiPlayer pxPlayer=cast<CAiPlayer>(pxLevel^.GetPlayer(GetOwner()));
		if(pxPlayer==null)then return fValue; endif;
		var ^CLevelInfo.CPlayerSlot pxPlayerSlot=pxPlayer^.GetPlayerSlot();
		if(pxPlayerSlot==null)then return fValue; endif;
		var int iDiff=pxPlayerSlot^.GetValueInt("Difficulty");
		if(iDiff>=9)then
			fValue=0.9;
		elseif(iDiff>=8)then
			fValue=0.95;
		endif;
		return fValue;
	endproc;
	
	proc void ClearWeaponCache()
		m_axWeaponCaches=0;
	endproc;
	
	proc void AddWeaponCache()
		var ^CFightingObj.CWeaponCache pxWeapon=^(m_axWeaponCaches.NewEntryRef());
		pxWeapon^.m_sWeaponPath=m_sCurrentWeapon;
		pxWeapon^.m_iWeaponSizeClass=m_iWeaponSizeClass;
		pxWeapon^.m_sProjectile=m_sProjectile;
		pxWeapon^.m_fProjectileFallOff=m_fProjectileFallOff;
		pxWeapon^.m_fProjectileSpeed=m_fProjectileSpeed;
		pxWeapon^.m_fProjectileJitter=m_fProjectileJitter;
		pxWeapon^.m_fWeaponDuration=m_fWeaponDuration;
		pxWeapon^.m_axAnims=m_axFightAnims;
		pxWeapon^.m_fDmg=m_fDamage;
		pxWeapon^.m_fProtection=m_fProtection;
		pxWeapon^.m_fRangedProtection=m_fRangedProtection;
		pxWeapon^.m_fArmorPiercing=m_fArmorPiercing;
		pxWeapon^.m_fMinAttackRange=m_fMinAttackRange;
		pxWeapon^.m_bPenetration=m_bPenetration;
		pxWeapon^.m_fPenetrationAngle=m_fPenetrationAngle;
		pxWeapon^.m_fPenetrationFactor=m_fPenetrationFactor;
		pxWeapon^.m_fHitRange=m_fHitRange;
		pxWeapon^.m_fEndDmg=m_fEndDmg;
		pxWeapon^.m_fPoisonDmg=m_fPoisonDmg;
		pxWeapon^.m_iPoisonMaxTickCount=m_iPoisonMaxTickCount;
		pxWeapon^.m_fAttackRange=m_fAttackRange;
		pxWeapon^.m_xAttackBoni=m_xAttackBoni;
		pxWeapon^.m_xDefenseBoni=m_xDefenseBoni;
		pxWeapon^.m_xRangedDefBoni=m_xRangedDefBoni;
		//Henry: for flamethrowers
		pxWeapon^.m_fFireDmg=m_fFireDmg;
		pxWeapon^.m_iBurnTime=m_iBurnTime;
		//Henry: against flying units
		pxWeapon^.m_bAirWeapon=m_bAirWeapon;
	endproc;
	
	proc void ReloadWeaponCache(^CFightingObj.CWeaponCache p_pxWeapon)
		m_sCurrentWeapon=p_pxWeapon^.m_sWeaponPath;
		m_iWeaponSizeClass=p_pxWeapon^.m_iWeaponSizeClass;
		m_sProjectile=p_pxWeapon^.m_sProjectile;
		m_fProjectileFallOff=p_pxWeapon^.m_fProjectileFallOff;
		m_fProjectileSpeed=p_pxWeapon^.m_fProjectileSpeed;
		m_fProjectileJitter=p_pxWeapon^.m_fProjectileJitter;
		m_fWeaponDuration=p_pxWeapon^.m_fWeaponDuration;
/*
		ClearFightAnims();
		var int i, iC=p_pxWeapon^.m_axAnims.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			AddFightAnim(p_pxWeapon^.m_axAnims[i]);
		endfor;
*/
		m_axFightAnims=p_pxWeapon^.m_axAnims;
		SetDmg(p_pxWeapon^.m_fDmg);
		SetProtection(p_pxWeapon^.m_fProtection);
		SetRangedProtection(p_pxWeapon^.m_fRangedProtection);
		m_fArmorPiercing=p_pxWeapon^.m_fArmorPiercing;
		m_fMinAttackRange=p_pxWeapon^.m_fMinAttackRange;
		m_bPenetration=p_pxWeapon^.m_bPenetration;
		m_fPenetrationAngle=p_pxWeapon^.m_fPenetrationAngle;
		m_fPenetrationFactor=p_pxWeapon^.m_fPenetrationFactor;
		m_fHitRange=p_pxWeapon^.m_fHitRange;
		m_fEndDmg=p_pxWeapon^.m_fEndDmg;
		m_fPoisonDmg=p_pxWeapon^.m_fPoisonDmg;
		m_iPoisonMaxTickCount=p_pxWeapon^.m_iPoisonMaxTickCount;
		m_fAttackRange=p_pxWeapon^.m_fAttackRange;
		m_xAttackBoni=p_pxWeapon^.m_xAttackBoni;
		m_xDefenseBoni=p_pxWeapon^.m_xDefenseBoni;
		m_xRangedDefBoni=p_pxWeapon^.m_xRangedDefBoni;
		//Henry: for flamethrowers
		m_fFireDmg=p_pxWeapon^.m_fFireDmg;
		m_iBurnTime=p_pxWeapon^.m_iBurnTime;
		//Henry: against flying units
		m_bAirWeapon=p_pxWeapon^.m_bAirWeapon;
	endproc;
	
	///////
	//	UpdateSizeClass()
	///////
	proc void UpdateSizeClass()
		m_iSizeClass=m_xTechTree.GetValueI(GetObjPath()+"/unit_size",0);
	endproc;
	
	export proc int GetSizeClass()
		return m_iSizeClass;
	endproc;
	
	///////
	//	UpdateSpeed()
	///////
	proc void UpdateSpeed()
		var int iOldMaxSpeed=GetMaxSpeed();
		var int iNewMaxSpeed=m_xTechTree.GetValueI(GetObjPath()+"/maxspeed",2);
		var int iDefSpeed=m_xTechTree.GetValueI(GetObjPath()+"/defaultspeed",2);
		if(m_bPinnedDown||m_bBrokenLegs||m_bTurtleOnLand||GetMirageFlag(MIRAGE_SAND_TRAP))then
			iNewMaxSpeed=1;
			iDefSpeed=1;
		endif;
		SetDefaultSpeed(iDefSpeed);
		SetMaxSpeed(iNewMaxSpeed);
//		if(iNewMaxSpeed!=iOldMaxSpeed)then
		if(iNewMaxSpeed<iOldMaxSpeed)then
			if(HasWalkAction())then
				TerminateAction();
			endif;
		endif;
	endproc;
	
	///////
	//	GetDefaultSpeed()
	///////
	export proc int GetDefaultSpeed()
		//KLog.LogSpam("TechTree","GetDefaultSpeed() defaultspeed="+m_iDefaultSpeed.ToString());
//		return Math.Clamp(m_iDefaultSpeed.ToReal()+GetBonusSum(CFightingObj.BONUS_DEFAULTSPEED), 1.0f, GetMaxSpeed().ToReal()).ToInt();
		return m_iDefaultSpeed;
	endproc;
	
	///////
	//	SetDefaultSpeed()
	///////
	export proc void SetDefaultSpeed(int p_iSpeed)
		m_iDefaultSpeed=p_iSpeed;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr==null)then return; endif;
		if(pxAttr^.GetValueInt("defspeed")!=p_iSpeed)then
			pxAttr^.SetValue("defspeed",p_iSpeed);
		endif;
	endproc;
	
	///////
	//	GetMaxSpeed()
	///////
	export proc int GetMaxSpeed()
		//L KLog.LogSpam("TechTree","GetMaxSpeed() maxspeed="+m_iMaxSpeed.ToString());
		return m_iMaxSpeed;
	endproc;
	
	///////
	//	SetMaxSpeed()
	///////
	export proc void SetMaxSpeed(int p_iSpeed)
		m_iMaxSpeed=p_iSpeed;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr==null)then return; endif;
		if(pxAttr^.GetValueInt("maxspeed")!=p_iSpeed)then
			pxAttr^.SetValue("maxspeed",p_iSpeed);
		endif;
	endproc;
	
	///////
	//	GetLeftHandWeapon()
	///////
	export proc string GetLeftHandWeapon()
		return m_pxWeaponMgr^.GetLeftHandWeapon();
	endproc;
	
	///////
	//	GetRightHandWeapon()
	///////
	export proc string GetRightHandWeapon()
		//return m_sRightHandWeapon;
		return m_pxWeaponMgr^.GetRightHandWeapon();
	endproc;
	
	export proc string GetCurrentWeapon()
		return m_sCurrentWeapon;
	endproc;
	
	export proc string GetSecondaryWeaponM()
		//return m_sSecondaryWeaponM;
		return m_pxWeaponMgr^.GetSecondaryWeaponM();
	endproc;
	
	export proc string GetSecondaryWeaponS()
		//return m_sSecondaryWeaponS;
		return m_pxWeaponMgr^.GetSecondaryWeaponS();
	endproc;
	
	///////
	//	GetArmor()
	///////
	export proc string GetArmor()
		//return m_sArmor;
		return m_pxWeaponMgr^.GetArmor();
	endproc;
	
	///////
	//	UpdateWepaonBoni()
	///////
	export proc void UpdateWeaponBoni()
		m_xAttackBoni.Clear();
		m_xDefenseBoni.Clear();
		m_xRangedDefBoni.Clear();
		AddBoni(GetCurrentWeapon()+"/AttackBonus",m_xAttackBoni);
		AddBoni(GetLeftHandWeapon()+"/AttackBonus",m_xAttackBoni);
		AddBoni(GetArmor()+"/AttackBonus",m_xAttackBoni);
		AddBoni(GetCurrentWeapon()+"/DefenseBonus",m_xDefenseBoni);
		AddBoni(GetLeftHandWeapon()+"/DefenseBonus",m_xDefenseBoni);
		AddBoni(GetArmor()+"/DefenseBonus",m_xDefenseBoni);
		AddBoni(GetCurrentWeapon()+"/RangedDefBonus",m_xRangedDefBoni);
		AddBoni(GetLeftHandWeapon()+"/RangedDefBonus",m_xRangedDefBoni);
		AddBoni(GetArmor()+"/RangedDefBonus",m_xRangedDefBoni);
		if(GetEffectFlag(EFFECT_ITEM_AMULETT1))then
			m_xDefenseBoni.AddBonus("Type", "ANML", 15.0f);
		endif;
		ClearDamageCache();
	endproc;
	
	///////
	//	AddBoni()
	///////
	export proc void AddBoni(string p_sPath, ref CBonus p_rxBonus)
		var int i;
		for(i=0)cond(i<m_xTechTree.NumSubs(p_sPath+"/Type"))iter(i++)do
			var string sPath=m_xTechTree.GetSubAbsPath(p_sPath+"/Type",i);
			var real fBonus=m_xTechTree.GetValueR(sPath,0.0);
			sPath=sPath.Mid(sPath.FindRev('/')+1);
			//L KLog.LogSpam("TechTree","AddBoni: sPath="+sPath);
			p_rxBonus.AddBonus("Type",sPath, fBonus);
		endfor;
		for(i=0)cond(i<m_xTechTree.NumSubs(p_sPath+"/Class"))iter(i++)do
			var string sPath=m_xTechTree.GetSubAbsPath(p_sPath+"/Class",i);
			var real fBonus=m_xTechTree.GetValueR(sPath,0.0);
			sPath=sPath.Mid(sPath.FindRev('/')+1);
			//L KLog.LogSpam("TechTree","AddBoni: sPath="+sPath);
			p_rxBonus.AddBonus("Class",sPath, fBonus);
		endfor;
	endproc;
	
	///////
	//	GetAttackBoni()
	///////
	export proc ref CBonus GetAttackBoni()
		return m_xAttackBoni;
	endproc;
	
	///////
	//	AddTemporaryAttackBoni()
	///////
	export proc real CalcAttackBoni(real p_fDamage)
		var real fValue=p_fDamage;
		/*
		if(GetTribeName()=="Aje")then
			//relative values
			//absolut values
		elseif(GetTribeName()=="Hu")then
			//relative values
			//absolut values
		elseif(GetTribeName()=="Ninigi")then
			//relative values
			//absolut values
		elseif(GetTribeName()=="SEAS")then
			//relative values
			//absolut values
		endif;
		*/
		//Henry: immunity for aje triceratops
		if(GetEffectFlag(EFFECT_MAMMOTH_TRUMPET))then
			fValue *= 0.8;
		endif;
		if(GetEffectFlag(EFFECT_TRICERATOPS_PAW))then
			fValue *= 0.5;
		endif;
		if(GetEffectFlag(EFFECT_CHTR_WARCRY_5))then
			fValue *= 1.3;
		elseif(GetEffectFlag(EFFECT_CHTR_WARCRY_4))then
			fValue *= 1.2;
		elseif(GetEffectFlag(EFFECT_CHTR_WARCRY_3))then
			fValue *= 1.15;
		endif;
		if(GetEffectFlag(EFFECT_AJE_WARPAINT_5))then
//			fValue *= 0.75;
			fValue *= (1.0/1.3);
		elseif(GetEffectFlag(EFFECT_AJE_WARPAINT_4))then
//			fValue *= 0.8;
			fValue *= (1.0/1.2);
		elseif(GetEffectFlag(EFFECT_AJE_WARPAINT_3))then
//			fValue *= 0.85;
			fValue *= (1.0/1.15);
		endif;
		if(GetEffectFlag(EFFECT_MAYOR_DOMINANCE))then
			fValue *= 0.8;
		endif;
		if(GetEffectFlag(EFFECT_WILDBOAR_RAGE))then
			fValue *= 1.15;
		endif;
		if(GetEffectFlag(EFFECT_MEGALO_DRUMS))then
			fValue *= 1.2;
		endif;
		if(GetEffectFlag(EFFECT_PARA_DRUMS))then
			fValue *= 1.2;
		endif;
		if(m_bCyborgBonus)then
			fValue *= 1.5;
		endif;
		if(GetMirageFlag(MIRAGE_MOTIVATE))then
			fValue *= 1.2;
		endif;
		if(GetMirageFlag(MIRAGE_THREATEN))then
			fValue *= (1.0/1.2);
		endif;
		fValue += GetBonusSum(BONUS_DAMAGE);
		return fValue;
	endproc
	
	export proc real AddTemporaryAttackBoni(real p_fDamage)
		var real fValue=CalcAttackBoni(p_fDamage);
		RemoveRangedBuff("more_damage");
		RemoveRangedBuff("less_damage");
		if(fValue>p_fDamage)then
			AddRangedBuff("more_damage");
		elseif(fValue<p_fDamage)then
			AddRangedBuff("less_damage");
		endif;
		return fValue;
	endproc;
	
	///////
	//	AddTemporaryDefenseBoni()
	///////
	export proc real AddTemporaryDefenseBoni(real p_fProtection)
		var real fValue=p_fProtection;
//		if(GetTribeName()=="Aje")then
//			// nix :(
//		endif;
		if(GetEffectFlag(EFFECT_RHINO_PENNANT))then
			fValue += 20.0;
		endif;
		if(GetMirageFlag(MIRAGE_SPEAKER))then
			fValue += 20.0;
		endif;
		if(GetMirageFlag(MIRAGE_KING_JAW))then
			fValue -= 20.0;
		endif;
		if(GetMirageFlag(MIRAGE_DC_BYAKUGAN_5))then
			fValue -= 30.0;
		elseif(GetMirageFlag(MIRAGE_DC_BYAKUGAN_4))then
			fValue -= 20.0;
		elseif(GetMirageFlag(MIRAGE_DC_BYAKUGAN_3))then
			fValue -= 15.0;
		endif;
		if(m_bFrozen)then
			fValue += 0.0;
//			fValue += 30.0;
		endif;
		if(m_bTitanDefense)then
			fValue += 30.0;
		endif;
		if(m_bMarkedForDeath)then
			fValue -= 30.0;
		endif;
		if(m_bLacered)then
			fValue -= 20.0;
		endif;
		fValue += GetBonusSum(BONUS_DEFENSE);
		if(m_bSundered)then
			fValue=0.0;
		endif;
		if(fValue<0.0f)then fValue =0.0f; endif; //Henry: because negative bonus doesn't bring anything (see TakeDmg(^CFightingObj p_pxEnemy, real p_fFactor,real p_fHitDelay) > Math.Clamp(AddTemporaryRangedDefenseBoni(Math.Max(0.0,(GetRangedProtection()-fArmorPiercing))) * 0.01, 0.0f, 0.99f))
		var real fMaxDef=m_fMaxDef*100.0f;
		if(fValue > fMaxDef)then fValue=fMaxDef; endif;
		//TODO: (Henry) change takedmg to allow negative armor?...
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			var int iValue;
			if(fValue<p_fProtection)then
				iValue=Math.Floor(fValue-p_fProtection).ToInt();
			else
				iValue=Math.Ceil(fValue-p_fProtection).ToInt();
			endif;
			pxAttr^.SetValue("TmpDefenseBoni",iValue);
		endif;
		RemoveRangedBuff("more_defense");
		RemoveRangedBuff("less_defense");
		if(fValue>p_fProtection)then
			AddRangedBuff("more_defense");
		elseif(fValue<p_fProtection)then
			AddRangedBuff("less_defense");
		endif;
		if(m_bSundered)then
			return 0.0;
		endif;
		return fValue;
	endproc;
	
	export proc real AddTemporaryRangeBoni()
		var real fVal=GetBonusSum(BONUS_RANGE);
		var ^CAttribs pxA=GetAttribs();
		if(pxA!=null)then
			var string sCaste=pxA^.GetValue("caste");
			if(GetOnWall()&&(sCaste=="nat"||sCaste=="tec"))then
				fVal += m_xTechTree.GetValueR("MiscValues/"+GetPlayerTribeName()+"/Range_On_Wall",0.0);
			endif;
			if(pxA^.GetValueInt("TmpRangeBoni")!=fVal.ToInt())then
				pxA^.SetValue("TmpRangeBoni",fVal.ToInt());
			endif;
		endif;
		RemoveRangedBuff("more_range");
		RemoveRangedBuff("less_range");
		if(fVal>0.0)then
			AddRangedBuff("more_range");
		elseif(fVal<0.0)then
			AddRangedBuff("less_range");
		endif;
		return fVal;
	endproc;
	
	export proc real AddTemporaryRangedDefenseBoni(real p_fProtection)
		var real fValue=p_fProtection;
		fValue += GetBonusSum(BONUS_RANGEDDEFENSE);
		// add wall defense bonus
//		if(GetOnWall())then
//			fValue += m_xTechTree.GetValueR("MiscValues/"+GetPlayerTribeName()+"/Defence_On_Wall",0.0);
//		endif;
		if(GetMirageFlag(MIRAGE_SPEAKER))then
			fValue += 20.0;
		endif;
		if(m_bFrozen)then
//			fValue += 30.0;
			fValue += 0.0;
		endif;
		if(m_bMarkedForDeath)then
			fValue -= 30.0;
		endif;
		if(GetMirageFlag(MIRAGE_KEEN_EYES))then
			fValue -= 20.0;
		endif;
		if(GetMirageFlag(MIRAGE_DC_BYAKUGAN_5))then
			fValue -= 30.0;
		elseif(GetMirageFlag(MIRAGE_DC_BYAKUGAN_4))then
			fValue -= 20.0;
		elseif(GetMirageFlag(MIRAGE_DC_BYAKUGAN_3))then
			fValue -= 15.0;
		endif;
		if(m_bTitanDefense)then
			fValue += 30.0;
		endif;
		if(m_bLacered)then
			fValue -= 20.0;
		endif;
		if(m_bShattered)then
			fValue=0.0;
		endif;
		if(fValue<0.0f)then fValue =0.0f; endif; //Henry: because negative bonus doesn't bring anything (see TakeDmg(^CFightingObj p_pxEnemy, real p_fFactor,real p_fHitDelay) > Math.Clamp(AddTemporaryRangedDefenseBoni(Math.Max(0.0,(GetRangedProtection()-fArmorPiercing))) * 0.01, 0.0f, 0.99f))
		var real fMaxDef=m_fMaxDef*100.0f;
		if(fValue > fMaxDef)then fValue=fMaxDef; endif;
		//TODO: (Henry) change takedmg to allow negative armor?...
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			var int iValue;
			if(fValue<p_fProtection)then
				iValue=Math.Floor(fValue-p_fProtection).ToInt();
			else
				iValue=Math.Ceil(fValue-p_fProtection).ToInt();
			endif;
			pxAttr^.SetValue("TmpRangedDefenseBoni",iValue);
		endif;
		RemoveRangedBuff("more_armor");
		RemoveRangedBuff("less_armor");
		if(fValue>p_fProtection)then
			AddRangedBuff("more_armor");
		elseif(fValue<p_fProtection)then
			AddRangedBuff("less_armor");
		endif;
		if(m_bShattered)then
			return 0.0;
		endif;
		return fValue;
	endproc;
	
	///////
	//	GetDefenseBoni()
	///////
	export proc ref CBonus GetDefenseBoni()
		return m_xDefenseBoni;
	endproc;
	
	///////
	//	GetObjPath()
	///////
	export proc string GetObjPath()
		return m_sObjPath;
	endproc;
	
	///////
	//	UpdateObjPath()
	///////
	proc void UpdateObjPath()
		var string sTribe=GetTribeName();
		if(sTribe.IsEmpty())then return; endif;
		var string sClassName=GetClassName();
		var ^CTechTree.CNode pxObjNode=m_xTechTree.FindNode("Objects/"+sTribe+"/"+GetType().AsString()+"/"+sClassName);
		if(pxObjNode==null)then
			var ^CTechTree.CNode pxTribeNode=m_xTechTree.FindNode("Objects/"+sTribe);
			if(pxTribeNode==null)then return; endif;
			pxObjNode=pxTribeNode^.FindNodeRecursiveByName(sClassName);
		endif;
		if(pxObjNode==null)then return; endif;
		m_sObjPath=pxObjNode^.GetAbsPath();
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("ObjPath",m_sObjPath);
		endif;
		//KLog.LogWarn("CHP","ObjPath: "+m_sObjPath);
	endproc;
	
	///////
	//	OnTechTreeChange()
	///////
	export proc void OnTechTreeChange(ref CStringArray p_rasChanges)
//		CSrvWrap.LogInfo("CaOr",GetName()+"::OnTechTreeChange(ref CTechTreeMgr.TTTFilterList)");
		m_xTechTree=GetTechTree();
		All4One();
		ExamineFlags();
		if(!m_bTechTreeInitialized)then
			UpdateObjPath();
		endif;
		if(!m_sObjPath.IsEmpty())then
			m_bTechTreeInitialized=true;
		endif;
		var string sTribe=GetTribeName();
		if(sTribe.IsEmpty())then return;endif;
		var string sAllWeaponPath="/Objects/"+sTribe+"/Weapons/";
		var string sObjPath="/"+GetObjPath();
		var string sInventObjPath="/Objects/"+sTribe+"/InventObjects/";
		var string sModPath= "/Modifications/"+sTribe+"/"+GetType().AsString();
		var string sModClassPath= "/Modifications/"+sTribe+"/"+GetClassName();
		var int i,iC;
		var bool bWeaponChanged=false;
		var int iOps=0;
		var bool bUpdate_Mods=false;
		var bool bUpdate_HP=false;
		var bool bUpdate_EG=false;
		var bool bUpdate_Gfx=false;
		var bool bUpdate_FOW=false;
		var bool bUpdate_Boni=false;
		var bool bUpdate_Attribs=false;
		var bool bUpdateRageUnit=false;
		var bool bSpecialAbilities=false;
		var bool bManaUser=false;
		for(i=0) cond(i<p_rasChanges.NumEntries()) iter(i++)do
			var string sVal=p_rasChanges[i];
			//CSrvWrap.LogError("FightingObj",i.ToString()+":"+sVal);
			if(sVal.Find("/ForceWeaponUpdate")!=-1)then
				bWeaponChanged=true;
				bUpdateRageUnit=true;
				bSpecialAbilities=true;
				bManaUser=true;
			elseif(!bWeaponChanged&&sVal.Find(sAllWeaponPath)!=-1)then
				var string sTmp=sVal;
				sTmp.Replace(sAllWeaponPath,"");
				sTmp=sTmp.Left(sTmp.Find("/"));
				sTmp=sAllWeaponPath+sTmp;
				var ^CTechTree.CNode pxWeapon=m_xTechTree.FindNode(sTmp);
				if(pxWeapon==null)then continue; endif;
				var ^CTechTree.CNode pxUsers=pxWeapon^.GetSub("Users");
				if(pxUsers==null)then continue; endif;
				if(pxUsers^.FindNodeRecursiveByValue(GetClassName())==null)then continue; endif;
				bWeaponChanged=true;
			elseif((sModPath.Find(sVal)!=-1)||(sVal.Find(sModPath)!=-1)||(sModClassPath.Find(sVal)!=-1)||(sVal.Find(sModClassPath)!=-1))then
				bWeaponChanged=true;
				bUpdate_HP=true;
				bUpdate_EG=true;
				bUpdate_FOW=true;
				bUpdate_Mods=true;
			elseif((sVal.Find(sObjPath)!=-1)||(sObjPath.Find(sVal)!=-1))then
				bUpdate_Attribs=true;
				bUpdate_Mods=true;
				bUpdate_Gfx=true;
				bUpdate_FOW=true;
				bUpdate_HP=true;
				bUpdate_EG=true;
				if(sVal.Find("special_abilities")!=1)then
					bSpecialAbilities=true;
				endif;
				if(sVal.Find("mana_user")!=1)then
					var string sObjPath=GetObjPath();
					var bool bManaProducer=(m_xTechTree.GetValueI(sObjPath+"/mana_user",0)>0);
					if(bManaProducer)then
						bManaUser=true;
					endif;
				endif;
				// copied from TransportObj.usl
				var ^CTechTree.CNode pxFlags=m_xTechTree.FindNode(GetObjPath()+"/flags");
				if(pxFlags!=null)then
					var int i,iC=pxFlags^.NumSubs();
					var ^CAttribs pxAttr=GetAttribs();
					if(pxAttr!=null)then
						if(iC>0)then
							if(pxFlags^.GetSub(0)!=null)then
								m_sObjFlag=pxFlags^.GetSub(0)^.GetName();
								pxAttr^.SetValue("ObjFlag",pxFlags^.GetSub(0)^.GetName());
								if(GetProduceUnit().IsValid())then
									var ^CAttribs pxAttr=GetProduceUnit().GetObj()^.GetAttribs();
									if(pxAttr!=null)then
										pxAttr^.SetValue("ObjFlag",pxFlags^.GetSub(0)^.GetName());
									endif;
								endif;
							endif;
						else
							m_sObjFlag="";
							pxAttr^.SetValue("ObjFlag","");
						endif;
					endif;
				endif;
				if(sVal.Right(6)=="_bonus")then
					var int iIdx=sVal.FindRev('/');
					if(iIdx>=0)then
						var int iVal=m_xTechTree.GetValueI(sVal, -1);
						var string sBonus=sVal.Mid(iIdx+1);
						sBonus.Replace("_bonus","");
						var ^CBoniBucket pxBB=null;
						if(sBonus.Find("bldgdamage")>=0)then
							pxBB=GetBoniBucket(CFightingObj.BONUS_DAMAGE_BLDG);
						elseif(sBonus.Find("rangedamage")>=0)then
							pxBB=GetBoniBucket(CFightingObj.BONUS_RANGEDAMAGE);
						elseif(sBonus.Find("meleedamage")>=0)then
							pxBB=GetBoniBucket(CFightingObj.BONUS_MELEEDAMAGE);
						elseif(sBonus.Find("damage")>=0)then
							pxBB=GetBoniBucket(CFightingObj.BONUS_DAMAGE);
						elseif(sBonus.Find("rangeddefense")>=0)then
							pxBB=GetBoniBucket(CFightingObj.BONUS_RANGEDDEFENSE);
						elseif(sBonus.Find("defense")>=0)then
							pxBB=GetBoniBucket(CFightingObj.BONUS_DEFENSE);
						elseif(sBonus.Find("range")>=0)then
							pxBB=GetBoniBucket(CFightingObj.BONUS_RANGE);
						endif;
						if(pxBB!=null)then
							if(iVal>0)then
								pxBB^.AddEntry(sBonus, iVal.ToReal());
							else
								pxBB^.RemEntry(sBonus);
							endif;
							bUpdate_Boni=true;
						endif;
					endif;
				endif;
			elseif((sInventObjPath.Find(sVal)!=-1)||(sVal.Find(sInventObjPath)!=-1))then
				bUpdate_Gfx=true;
			endif;
			if((sVal.Find("wild_boar_rage")!=1)||(sVal.Find("infantry_rage")!=1))then
				bUpdateRageUnit=true;
			endif;
		endfor;
		if(bUpdate_HP)then
			iOps++;
			ChangeMaxHitpoints(GetTechTreeHitpoints());
			var ^CAttribs pxAttr=GetAttribs();
			if(pxAttr!=null)then
				pxAttr^.SetValue("skulls",GetScalpValue());
			endif;
			m_fJawSize=GetTechTreeJawSize();
			m_fFeedFactor=GetTechTreeFeedFactor();
		endif;
		if(bUpdate_EG)then
			iOps++;
			ChangeMaxEnergy(GetTechTreeMaxEnergy());
			var ^CAttribs pxAttr=GetAttribs();
			if(pxAttr!=null)then
				pxAttr^.SetValue("maxenergy",GetMaxEnergy());
			endif;
		endif;
		if(bUpdate_Attribs)then
			iOps++;
			UpdateSpeed();
			UpdateAggressive();
			UpdateSizeClass();
		endif;
		if(bUpdate_Mods)then
			iOps++;
			UpdateMods();
		endif;
		if(bUpdate_Gfx)then
			iOps++;
			UpdateGfx();
			UpdateGfxFlags();
		endif;
		if(bUpdate_FOW)then
			iOps++;
			UpdateFOW();
		endif;
		if(bUpdate_Boni)then
			iOps++;
			ForceBoniUpdate();
			UpdateWeaponBoni();
			UpdateRangeNDamageInformation();
		endif;
		if(bWeaponChanged)then
			iOps++;
			ClearWeaponCache();
			GetBestWeapon(null, true);
			UpdateWeaponBoni();
			UpdateRangeNDamageInformation();
			AddTemporaryAttackBoni(GetDmg());
			AddTemporaryMeleeAttackBoni(GetDmg());
			AddTemporaryRangedAttackBoni(GetDmg());
			AddTemporaryDefenseBoni(GetProtection());
			AddTemporaryRangedDefenseBoni(GetRangedProtection());
			UpdateWeaponsGfx();
		endif;
		if(bUpdateRageUnit)then
			UpdateRageUnit();
		endif;
		if(bWeaponChanged||bUpdate_Boni||bUpdate_Mods||bUpdate_HP||bUpdate_Attribs)then
			UpdateFormationAttribs();
		endif;
		UpdateDeliveries();
//		KLog.LogWarn("CaOr","TTChange "+iOps.ToString()+" "+GetName());
		var ^CTechTree.CNode pxNode=m_xTechTree.FindNode(m_sObjPath+"/special_abilities");
		m_xAbilities.AddAbilities(pxNode, true);
		if(bSpecialAbilities)then
			var ^CFightingObj.CSpecialAbility pxAb=m_xAbilities.GetAbility("self_heal", true);
			DeleteTimer(TIMER_SELFHEAL);
			if(pxAb!=null)then
				CreateTimer(TIMER_SELFHEAL, CGameTimeSpan.OneSecond() * 1.0, true);
				m_fSelfHealAmount=pxAb^.GetValueF("amount");
			endif;
			var ^CFightingObj.CSpecialAbility pxReg=m_xAbilities.GetAbility("regenerating", true);
			DeleteTimer(TIMER_REGENERATING);
			if(pxReg!=null)then
				CreateTimer(TIMER_REGENERATING, CGameTimeSpan.OneSecond() * 1.0, true);
				m_fSelfRegenerating=pxReg^.GetValueF("amount");
			endif;
			var ^CFightingObj.CSpecialAbility pxSanc=m_xAbilities.GetAbility("sanctification", true);
			DeleteTimer(TIMER_SANCTIFICATION);
			if(pxSanc!=null)then
				if(!IsInFight())then
					CreateTimer(TIMER_SANCTIFICATION, CGameTimeSpan.OneSecond() * 1.0, false);
				endif;
				m_fCuringAmount=pxSanc^.GetValueF("amount");
			endif;
			var ^CFightingObj.CSpecialAbility pxHeal=m_xAbilities.GetAbility("heal", true);
			if(pxHeal!=null)then
				var real fValue=pxHeal^.GetValueF("radius");
				var ^CAttribs pxAttr=GetAttribs();
				if(pxAttr!=null)then
					pxAttr^.SetValue("HealingMarker",fValue);
				endif;
				if(GetType()!="BLDG"&&pxAttr!=null)then
					var bool bValue=(fValue>0.0);
					if(pxAttr^.GetValueBool("healer")!=bValue)then
						pxAttr^.SetValue("healer",bValue);
					endif;
				endif;
			else
				var ^CAttribs pxAttr=GetAttribs();
				if(pxAttr!=null)then
					pxAttr^.SetValue("HealingMarker",0.0f);
				endif;
			endif;
		endif;
		if(bManaUser)then
			SetMana();
		endif;
		m_bCanTame=m_xTechTree.GetValueI(GetObjPath()+"/can_tame",0)==1;
	endproc;
	
	///////
	//	OnTechTreeChange()
	///////
	export proc void OnTechTreeChange()
		var CStringArray asArray;
		asArray.AddEntry("/ForceWeaponUpdate");
		asArray.AddEntry("/Objects/");
	
		OnTechTreeChange(asArray);
	endproc;
	
	export proc void UpdateRangeNDamageInformation()
		var real fMAXREAL=100000000.0f;
		var real fMINREAL=-100000000.0f;
		var real fMinRange=fMAXREAL;
		var real fMaxRange=fMINREAL;
		var real fRangeDmg=fMINREAL;
		var real fMeleeDmg=fMINREAL;
		var real fSecondaryDmg=fMINREAL;
		var bitset dwDmgType=0b;
		var real fRangeDur=0.0;
		var real fMeleeDur=0.0;
		var real fRangePiercing=0.0;
		var real fMeleePiercing=0.0;
		var string sBuildUp="";
		var int iMSlot=-1;
		var int iRSlot=-1;
		var string sWeaponL=GetRightHandWeapon();
		var string sWeaponM=GetSecondaryWeaponM();
		var string sWeaponS=GetSecondaryWeaponS();
		var string sClass=GetClassName();
		if(!sWeaponL.IsEmpty())then
			var ^CTechTree.CNode pxWeaponL=m_xTechTree.FindNode(sWeaponL);
			if(pxWeaponL!=null)then
				var ^CTechTree.CNode pxWeaponL_Projectiles=pxWeaponL^.GetSub("Projectile");
				if(pxWeaponL_Projectiles!=null&&pxWeaponL_Projectiles^.NumSubs()>0)then // long range weapon is a projectile weapon
					fMaxRange=Math.Max(fMaxRange,pxWeaponL^.GetSubValueF("range",fMINREAL));
					fMaxRange=fMaxRange*GetTechTreeModifier("Range",true)+GetTechTreeModifier("Range",false);
					if(m_bDarkSwarm)then
						fMaxRange=1.0f;
					endif;
					fMinRange=Math.Min(fMinRange,pxWeaponL^.GetSubValueF("minattackrange",0.0));
					fRangeDmg=pxWeaponL^.GetSubValueF("damage",fMINREAL);
					fRangeDmg *= GetTechTreeModifier("Damage",true);
					fRangeDmg += GetTechTreeModifier("Damage",false);
					fRangeDmg *= GetTechTreeModifier("ranged_damage",true);
					fRangeDmg += GetTechTreeModifier("ranged_damage",false);
					var real fRFrequency=pxWeaponL^.GetSubValueF("frequency");
					if(fRFrequency==0.0)then
						fRFrequency=1.0;
					endif;
					fRangeDur=(60.0/fRFrequency);
					fRangeDur *= GetTechTreeModifier("WeaponDuration",true);
					fRangeDur += GetTechTreeModifier("WeaponDuration",false);
					fRangeDur *= GetAICheatModifier();
					iRSlot=0;
					if(pxWeaponL^.GetSubValueF("poison_damage",0.0f)>0.0f)then
						dwDmgType |= dwRANGE_POISON;
					endif;
					if(pxWeaponL^.GetSubValueF("fire_damage",0.0f)>0.0f)then
						dwDmgType |= dwRANGE_FIRE;
					endif;
					if(pxWeaponL^.GetSubValueF("hitrange",0.0f)>0.0f)then
						dwDmgType |= dwRANGE_AREA;
					endif;
					if(pxWeaponL^.GetSubValueI("penetration",0)==1)then
						dwDmgType |= dwRANGE_AREA;
					endif;
					if(pxWeaponL^.GetSubValueF("armorpiercing",0.0f)>0.0f)then
						dwDmgType |= dwRANGE_PIERCE;
						fRangePiercing=Math.Min(pxWeaponL^.GetSubValueF("armorpiercing",0.0), m_fMaxDef*100.0f);
					endif;
					if(!sWeaponS.IsEmpty())then
						var ^CTechTree.CNode pxWeaponS=m_xTechTree.FindNode(sWeaponS);
						iMSlot=2;
						if(sWeaponM==GetCurrentWeapon())then
							pxWeaponS=m_xTechTree.FindNode(sWeaponM);
							iMSlot=1;
						endif;
						if(pxWeaponS!=null)then
							//fMaxRange=Math.Max(fMaxRange,pxWeaponS^.GetSubValueF("range",fMINREAL));
							fMinRange=Math.Min(fMinRange,pxWeaponS^.GetSubValueF("minattackrange",0.0));
							fMeleeDmg=pxWeaponS^.GetSubValueF("damage",fMINREAL);
							fMeleeDmg *= GetTechTreeModifier("Damage",true);
							fMeleeDmg += GetTechTreeModifier("Damage",false);
							fMeleeDmg *= GetTechTreeModifier("melee_damage",true);
							fMeleeDmg += GetTechTreeModifier("melee_damage",false);
							var real fMFrequency=pxWeaponS^.GetSubValueF("frequency");
							if(fMFrequency==0.0)then
								fMFrequency=1.0;
							endif;
							fMeleeDur=(60.0/fMFrequency);
							fMeleeDur *= GetTechTreeModifier("WeaponDuration",true);
							fMeleeDur += GetTechTreeModifier("WeaponDuration",false);
							fMeleeDur *= GetAICheatModifier();
							if(pxWeaponS^.GetSubValueF("poison_damage",0.0f)>0.0f)then
								dwDmgType |= dwMELEE_POISON;
							endif;
							if(pxWeaponS^.GetSubValueF("fire_damage",0.0f)>0.0f)then
								dwDmgType |= dwMELEE_FIRE;
							endif;
							if(pxWeaponS^.GetSubValueF("hitrange",0.0f)>0.0f)then
								dwDmgType |= dwMELEE_AREA;
							endif;
							if(pxWeaponS^.GetSubValueI("penetration",0)==1)then
								dwDmgType |= dwMELEE_AREA;
							endif;
							if(pxWeaponS^.GetSubValueF("armorpiercing",0.0f)>0.0f)then
								dwDmgType |= dwMELEE_PIERCE;
								fMeleePiercing=Math.Min(pxWeaponS^.GetSubValueF("armorpiercing",0.0), m_fMaxDef*100.0f);
							endif;
						endif;
					elseif(sClass=="ninigi_seismosaurus")then
						var ^CTransportObj pxTransport=cast<CTransportObj>(this);
						if(pxTransport!=null)then
							fSecondaryDmg=0.0f;
							var int i, iC=pxTransport^.NumAdditionalBuildUps();
							for(i=0)cond(i<iC)iter(i++)do
								if(pxTransport^.HasAdditionalBuildUp(i))then
									var ^CBuildUpWeapon pxWeapon=cast<CBuildUpWeapon>(pxTransport^.GetAdditionalBuildUp(i));
									if(pxWeapon!=null)then
										var real fSingleDmg=pxWeapon^.GetDmg();
										if(pxWeapon^.GetPoisonDmg()>0.0f)then
											dwDmgType |= dwMELEE_POISON;
										endif;
										if(pxWeapon^.GetFireDmg()>0.0f)then
											dwDmgType |= dwMELEE_FIRE;
										endif;
										if(pxWeapon^.GetHitRange()>0.0f)then
											dwDmgType |= dwMELEE_AREA;
										endif;
										if(pxWeapon^.GetPenetration())then
											dwDmgType |= dwMELEE_AREA;
										endif;
										if(pxWeapon^.GetArmorPiercing()>0.0f)then
											dwDmgType |= dwMELEE_PIERCE;
											fMeleePiercing=pxWeapon^.GetArmorPiercing();
										endif;
										if(fSingleDmg>0.0f)then
											fSecondaryDmg += fSingleDmg;
										endif;
										if(i==0)then
											sBuildUp=pxWeapon^.GetWeapon();
											iMSlot=3;
											fMeleeDur=pxWeapon^.GetWeaponDuration();
										endif;
										//break;
									endif;
								endif;
							endfor;
						endif;
					endif;
				else
					if(GetType()=="ANML"||GetType()=="SHIP")then
						var ^CTransportObj pxTransport=cast<CTransportObj>(this);
						if(pxTransport!=null)then
							fRangeDmg=0.0f;
							var int i, iC=pxTransport^.NumAdditionalBuildUps();
							for(i=0)cond(i<iC)iter(i++)do
								if(pxTransport^.HasAdditionalBuildUp(i))then
									var ^CBuildUpWeapon pxWeapon=cast<CBuildUpWeapon>(pxTransport^.GetAdditionalBuildUp(i));
									if(pxWeapon!=null)then
										var real fSingleDmg=pxWeapon^.GetDmg();
//										fRangeDmg=pxWeapon^.GetDmg();
//										fSingleDmg *= GetTechTreeModifier("Damage",true);
//										fSingleDmg += GetTechTreeModifier("Damage",false);
//										fSingleDmg *= GetTechTreeModifier("ranged_damage",true);
//										fSingleDmg += GetTechTreeModifier("ranged_damage",false);
										if(pxWeapon^.GetPoisonDmg()>0.0f)then
											dwDmgType |= dwRANGE_POISON;
										endif;
										if(pxWeapon^.GetFireDmg()>0.0f)then
											dwDmgType |= dwRANGE_FIRE;
										endif;
										if(pxWeapon^.GetHitRange()>0.0f)then
											dwDmgType |= dwRANGE_AREA;
										endif;
										if(pxWeapon^.GetPenetration())then
											dwDmgType |= dwRANGE_AREA;
										endif;
										if(pxWeapon^.GetArmorPiercing()>0.0f)then
											dwDmgType |= dwRANGE_PIERCE;
											fRangePiercing=pxWeapon^.GetArmorPiercing();
										endif;
										if(fSingleDmg>0.0f)then
											fRangeDmg += fSingleDmg;
										endif;
										if(i==0)then
											sBuildUp=pxWeapon^.GetWeapon();
											iRSlot=3;
											fRangeDur=pxWeapon^.GetWeaponDuration();
										endif;
										//break;
									endif;
								endif;
							endfor;
						endif;
					endif;
					if(GetRightHandWeapon()!=GetCurrentWeapon()&&m_xTechTree.FindNode(m_sCurrentWeapon)!= null)then
						pxWeaponL=m_xTechTree.FindNode(m_sCurrentWeapon);
					endif;
					fMaxRange=Math.Max(fMaxRange,pxWeaponL^.GetSubValueF("range",fMINREAL));
//					fMaxRange=fMaxRange*GetTechTreeModifier("Range",true)+GetTechTreeModifier("Range",false);
					if(m_bDarkSwarm)then
						fMaxRange=1.0f;
					endif;
					fMinRange=Math.Min(fMinRange,pxWeaponL^.GetSubValueF("minattackrange",0.0));
					fMeleeDmg=pxWeaponL^.GetSubValueF("damage",fMINREAL);
					fMeleeDmg *= GetTechTreeModifier("Damage",true);
					fMeleeDmg += GetTechTreeModifier("Damage",false);
					fMeleeDmg *= GetTechTreeModifier("melee_damage",true);
					fMeleeDmg += GetTechTreeModifier("melee_damage",false);
					var real fMFrequency=pxWeaponL^.GetSubValueF("frequency");
					if(fMFrequency==0.0)then
						fMFrequency=1.0;
					endif;
					fMeleeDur=(60.0/fMFrequency);
					fMeleeDur *= GetTechTreeModifier("WeaponDuration",true);
					fMeleeDur += GetTechTreeModifier("WeaponDuration",false);
					fMeleeDur *= GetAICheatModifier();
					iMSlot=0;
					if(pxWeaponL^.GetSubValueF("poison_damage",0.0f)>0.0f)then
						dwDmgType |= dwMELEE_POISON;
					endif;
					if(pxWeaponL^.GetSubValueF("fire_damage",0.0f)>0.0f)then
						dwDmgType |= dwMELEE_FIRE;
					endif;
					if(pxWeaponL^.GetSubValueF("hitrange",0.0f)>0.0f)then
						dwDmgType |= dwMELEE_AREA;
					endif;
					if(pxWeaponL^.GetSubValueI("penetration",0)==1)then
						dwDmgType |= dwMELEE_AREA;
					endif;
					if(pxWeaponL^.GetSubValueF("armorpiercing",0.0f)>0.0f)then
						dwDmgType |= dwMELEE_PIERCE;
						fMeleePiercing=Math.Min(pxWeaponL^.GetSubValueF("armorpiercing",0.0), m_fMaxDef*100.0f);
					endif;
				endif;
			endif;
		endif;
		m_fTmpMeAttackBoni=0.0;
		m_fTmpRaAttackBoni=0.0;
		if(fMinRange >= fMAXREAL)then
			fMinRange=0.0f;
		endif;
		if(fMaxRange<0.0f)then
			fMaxRange=0.0f;
		endif;
		if(fMeleeDmg<0.0f)then
			fMeleeDmg=0.0f;
		endif;
		if(fRangeDmg<0.0f)then
			fRangeDmg=0.0f;
		endif;
		if(fSecondaryDmg<0.0f)then
			fSecondaryDmg=0.0f;
		endif;
		UpdateWeaponAttribs(fMinRange, fMaxRange, fMeleeDmg, fRangeDmg, fSecondaryDmg, fMeleeDur, fRangeDur, fMeleePiercing, fRangePiercing, dwDmgType.ToInt(), iMSlot, iRSlot, sBuildUp);
	endproc;
	
	export proc void UpdateWeaponAttribs(real p_fMinRange, real p_fMaxRange, real p_fMeleeDmg, real p_fRangeDmg, real p_fSecondaryDmg, real p_fMeleeDur, real p_fRangeDur, real p_fMeleePiercing, real p_fRangePiercing, int p_iDamageType, int p_iMSlot, int p_iRSlot, string p_sSlot3)
		var real fTmpMeleeBonus=0.0;
		var int iTmpMeleeBonus=0;
		if(p_fMeleeDmg>0.0f)then
			fTmpMeleeBonus=(CalcMeleeAttackBoni(p_fMeleeDmg)-p_fMeleeDmg);
			fTmpMeleeBonus += (CalcAttackBoni(p_fMeleeDmg)-p_fMeleeDmg);
			m_fTmpMeAttackBoni=fTmpMeleeBonus;
			if(fTmpMeleeBonus<0.0)then
				iTmpMeleeBonus=Math.Floor(fTmpMeleeBonus).ToInt();
			else
				iTmpMeleeBonus=Math.Ceil(fTmpMeleeBonus).ToInt();
			endif;
		elseif(p_fSecondaryDmg>0.0f)then
			fTmpMeleeBonus=(CalcRangeAttackBoni(p_fSecondaryDmg)-p_fSecondaryDmg);
			fTmpMeleeBonus += (CalcAttackBoni(p_fSecondaryDmg)-p_fSecondaryDmg);
			m_fTmpMeAttackBoni=fTmpMeleeBonus;
			if(fTmpMeleeBonus<0.0)then
				iTmpMeleeBonus=Math.Floor(fTmpMeleeBonus).ToInt();
			else
				iTmpMeleeBonus=Math.Ceil(fTmpMeleeBonus).ToInt();
			endif;
		endif;
		var real fTmpRangeBonus=0.0;
		var int iTmpRangeBonus=0;
		if(p_fRangeDmg>0.0f)then
			fTmpRangeBonus=(CalcRangeAttackBoni(p_fRangeDmg) - p_fRangeDmg);
			fTmpRangeBonus += (CalcAttackBoni(p_fRangeDmg)-p_fRangeDmg);
			m_fTmpRaAttackBoni=fTmpRangeBonus;
			if(fTmpRangeBonus<p_fRangeDmg)then
				iTmpRangeBonus=Math.Floor(fTmpRangeBonus).ToInt();
			else
				iTmpRangeBonus=Math.Ceil(fTmpRangeBonus).ToInt();
			endif;
		endif;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("min_attackrange",Math.Ceil(p_fMinRange).ToInt());
			pxAttr^.SetValue("max_attackrange",Math.Ceil(p_fMaxRange).ToInt());
			pxAttr^.SetValue("meleedamage",Math.Ceil(p_fMeleeDmg).ToInt());
			pxAttr^.SetValue("rangedamage",Math.Ceil(p_fRangeDmg).ToInt());
			pxAttr^.SetValue("secondarydamage",Math.Ceil(p_fSecondaryDmg).ToInt());
			pxAttr^.SetValue("TmpMeleeAttackBoni",iTmpMeleeBonus);
			pxAttr^.SetValue("TmpRangeAttackBoni",iTmpRangeBonus);
			pxAttr^.SetValue("damagetype",p_iDamageType);
//			pxAttr^.SetValue("rangeduration",p_fRangeDur);
//			pxAttr^.SetValue("meleeduration",p_fMeleeDur);
			if(p_fRangeDur>0.0f)then
				pxAttr^.SetValue("rangeduration",(60.0/p_fRangeDur));
			else
				pxAttr^.SetValue("rangeduration",0.0f);
			endif;
			if(p_fMeleeDur>0.0f)then
				pxAttr^.SetValue("meleeduration",(60.0/p_fMeleeDur));
			else
				pxAttr^.SetValue("meleeduration",0.0f);
			endif;
			pxAttr^.SetValue("range_piercing",p_fRangePiercing);
			pxAttr^.SetValue("melee_piercing",p_fMeleePiercing);
			pxAttr^.SetValue("Equip_Slot_3",p_sSlot3);
			pxAttr^.SetValue("meleeslot",p_iMSlot);
			pxAttr^.SetValue("rangeslot",p_iRSlot);
		endif;
	endproc;
	
	///////
	//	UpdateGfx()
	///////
	export proc bool UpdateGfx()
		if(GetEffectFlag(EFFECT_AJE_CAMOUFLAGE)||m_iEntrenchState==1)then return true; endif;
		//KLog.LogSpam("TechTree","UpdateGfx: "+m_xTechTree.GetValueS(GetObjPath()+"/gfx","")+" =?= "+GetGfxName());
		var string sGFX=m_xTechTree.GetValueS(GetObjPath()+"/gfx","");
		if(sGFX.IsEmpty())then return false; endif;
		if(sGFX!=GetGfxName())then
			SetGFX(sGFX);
			m_xWalkSet="defn";
			if(!HasWalkSet(m_xWalkSet))then m_xWalkSet="def"; endif;
			SetDefaultWalkSet(GetWalkSet());
			return true;
		endif;
		return false;
	endproc;
	
	///////
	//	UpdateFOW()
	///////
	proc void UpdateFOW()
//		var string s="/Lvl_"+(GetLevel()+1).ToString();
		var real fFOW=m_xTechTree.GetValueR(GetObjPath()+"/FOW",20.0)*GetTechTreeModifier("FOW",true)+GetTechTreeModifier("FOW",false);
		SetFOWRange(fFOW);
	endproc;
	
	export proc void UpdateMods()
		// Overload this
	endproc;
	
	///////
	//	GetTechTreeModifier()
	///////
	export proc real GetTechTreeModifier(string p_sType, bool p_bRelative)
		var string sPath="/Modifications/";
		sPath += GetTribeName()+"/";
		sPath += GetType().AsString()+"/";
		sPath += p_sType+"/";
		// boeser HACK :)
		sPath += "tec_";
		var real fValue;
		if(p_bRelative)then
			sPath += "rel";
			fValue=1.0;
		else
			sPath += "abs";
			fValue=0.0;
		endif;
		return(m_xTechTree.GetValueR(sPath,fValue));
	endproc;
	
	export proc real GetClassTechTreeModifier(string p_sType, bool p_bRelative)
		var string sPath="/Modifications/";
		sPath += GetTribeName()+"/";
		sPath += GetClassName()+"/";
		sPath += p_sType;
		var real fValue;
		if(p_bRelative)then
			sPath += "/rel";
			fValue=1.0;
		else
			sPath += "/abs";
			fValue=0.0;
		endif;
		return(m_xTechTree.GetValueR(sPath,fValue));
	endproc;
	
	export proc real GetTechTreeActionModifier(string p_sClass, string p_sType)
		var string sTempClass=p_sClass;
		var string sClass=sTempClass.Mid(sTempClass.FindRev('/')+1);
		sTempClass.Delete(sTempClass.FindRev('/'),sClass.GetLength()+1);
		var string sType=sTempClass.Mid(sTempClass.FindRev('/')+1);
		var string sSort;
		if(sType!="Invent")then
			sTempClass.Delete(sTempClass.FindRev('/'),sType.GetLength()+1);
			sSort=sTempClass.Mid(sTempClass.FindRev('/')+1);
			sTempClass.Delete(sTempClass.FindRev('/'),sSort.GetLength()+1);
		else
			sSort=sType;
		endif;
		var string sPath="/Modifications/"+GetPlayerTribeName()+"/"+sSort;
		if(sSort=="Build")then
			sPath += "/"+sType;
		endif;
		sPath += "/"+p_sType;
		return m_xTechTree.GetValueR(sPath,1.0);
	endproc;
	
	export proc void HandleEditorCommand(string p_sCommand,^CGameObj p_pxObject,vec3 p_vPos,string p_sMiscParams)
		if(p_sCommand=="LE_SetTTFilters")then
			var ^CTechTreeDef pxTTDef=GetTechTreeDef();
			if(pxTTDef==null)then return; endif;
			pxTTDef^.ClearFilters();
			var array string asFilter;
			p_sMiscParams.Split(asFilter,"\n",true);
			var int i,iC=asFilter.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				pxTTDef^.EnableFilter(asFilter[i]);
			endfor;
		elseif(p_sCommand=="LE_SetLevel")then
			var int iLvl=p_sMiscParams.ToInt();
			SetLevelClean(iLvl);
		elseif(p_sCommand=="SetPFBBlocking")then
			var bool bBlock=p_sMiscParams=="true";
			m_bPBlocker=bBlock;
			var ^CAttribs pxA=GetAttribs();
			if(pxA==null)then pxA=InitAttribs(); endif;
			if(pxA!=null)then
				pxA^.SetValue("blocker",bBlock);
			endif;
			if(bBlock)then
				CSrvWrap.GetPathfinder().AddPFBlocker(this);
			else
				CSrvWrap.GetPathfinder().RemPFBlocker(this);
			endif;
			SetPlaceBlocker(bBlock);
		else
			super.HandleEditorCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams);
		endif;
	endproc;
	
	proc bool GiveCommandsToTransportObj(string p_sCommand, string p_sMiscParams)
		var ^CGameObj pxTransportObj=GetTransportObj().GetObj();
		if(pxTransportObj!=null)then
			if(p_sCommand=="Cancel")then return true; endif;
		endif;
		return false;
	endproc;
	
	proc void SetDefensiveMode(string p_sMiscParams)
		var ^CTechTreeDef pxTTDef=GetTechTreeDef();
		if(pxTTDef==null)then return; endif;
		var bool bOn=m_bDefensiveMode=p_sMiscParams.Find("mode_on")>=0;
		var CTechTree xTT=GetTechTree();
		var ^CTechTree.CNode pxAction=xTT.FindNode(p_sMiscParams);
		if(pxAction!=null)then
			var ^CTechTree.CNode pxRes=pxAction^.GetSub("results");
			if(pxRes!=null)then
				var int i, iC=pxRes^.NumSubs();
				for(i=0) cond(i<iC) iter(++i)do
					if(bOn)then
						pxTTDef^.EnableFilter(pxRes^.GetSub(i)^.GetValue());
					else
						pxTTDef^.DisableFilter(pxRes^.GetSub(i)^.GetValue());
					endif;
				endfor;
				m_bDefensiveMode=bOn;
			endif;
		endif;
		if(bOn)then
			var CObjHndl xMode=AddFX("fx_defensive_mode", -1.0);
			var CFourCC xLink;
			if(xMode.IsValid())then
				xMode.GetObj()^.LinkAction(GetHandle(),xLink);
			endif;
		else
			RemoveFX("fx_defensive_mode");
		endif;
		OnTechTreeChange();
		// HACK
		if(HasWalkAction())then
			var vec3 vP=GetCurWalkTarget();
			WalkAction(vP,GetDefaultSpeed());
		endif;
		// ENDHACK
	endproc;
	
	export proc void AbortTask()
		BreakEveryTask();
		TerminateAction();
	endproc;
	
	export proc void TriggerAbortTask()
		if(m_xTransportObj.IsValid())then return; endif;
		AbortTask();
	endproc;
	
	proc bool ProcessTTFilter(^CGameObj p_pxObj, string p_sTTP, bool p_bSetFilter)
		if(p_pxObj==null)then
			//L KLog.LogSpam("MaZi","p_pxObj==null");
			return false;
		endif;
		if(p_pxObj^.GetType()!="ANML")then
			//L KLog.LogSpam("MaZi","p_pxObj^.GetType()!=\"ANML\"");
			return false;
		endif;
		var CTechTree xTechTree=p_pxObj^.GetTechTree();
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		var int iOwner=p_pxObj^.GetOwner();
		var ^CPlayer pxPlayer=pxLevel^.GetPlayer(iOwner);
		var int i=0;
		var string sResult="Start";
		var string sResultPath="Start";
		while(sResultPath!="")do
			sResult=p_sTTP+"/results/"+i.ToString();
			sResultPath=xTechTree.GetValueS(sResult,"");
			var string sResultClass=xTechTree.GetValueS(sResult+"/class","");
			var string sType=xTechTree.GetValueS(sResult+"/type", "deactivate");
			var ^CTechTreeDef pxTechTreeDef;
			if(sResultClass=="local")then
				pxTechTreeDef=p_pxObj^.GetTechTreeDef();
			else
				pxTechTreeDef=^(pxPlayer^.GetPlayerTechTreeDef());
			endif;
			if(p_bSetFilter)then
				if(pxTechTreeDef!=null)then
					if(sType=="deactivate")then
						pxTechTreeDef^.DisableFilter(sResultPath);
						//KLog.LogSpam("MaZi", "DisableFilter("+sResultPath+") - "+sResultClass+"/"+sType);
					else
						pxTechTreeDef^.EnableFilter(sResultPath);
						//KLog.LogSpam("MaZi", "EnableFilter("+sResultPath+") - "+sResultClass+"/"+sType);
					endif;
				endif;
			endif;
			++i;
			sResultPath=xTechTree.GetValueS(p_sTTP+"/results/"+i.ToString(),"");
		endwhile;
		return true;
	endproc;
	
	export proc void AutoScout()
		if(!IsAbleToWalk())then return; endif;
		var ^CAutoScout pxTask=cast<CAutoScout>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"AutoScou"));
		if(pxTask==null)then return; endif;
		var bool bR=pxTask^.Init(GetHandle(), GetPos());
		if(bR)then
			pxTask^.SetUserCommand(false);
			AddTask(pxTask,false);
		else
			pxTask^.GetFactory()^.FreeState(pxTask);
		endif;
	endproc;
	
	///////
	//	HandleGamePlayCommand()
	///////
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(!IsDead())then
			// p_bQ isn't used by CFightingObj::HandleGamePlayCommand yet, remove comment if you plan to use it!!!
			// SB#16564
			if(GetIncapacitated()&&(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill")&&!(p_sCommand=="Cancel"||p_sCommand=="StornoLast"||p_sCommand=="StornoAll"))then return; endif;
			if(m_xTransportObj.IsValid()&&!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/LeaveTransport")>=0))then return; endif;
			if(p_sCommand=="Attack"||p_sCommand=="Fight")then
				if(p_pxObject!=null)then
					Fight(p_pxObject, p_pxObject^.GetPos(), true, p_bQ);
				endif;
			elseif(p_sCommand=="Kill")then
				DiePerHarakiri();
			elseif(p_sCommand=="PickUp")then
				if(p_pxObject!=null&&CArtifactMgr.Get().IsAllowedToPickUpItem(GetOwner(),p_pxObject^.GetClassName()))then
					PickUp(p_pxObject^.GetHandle(),p_bQ);
				endif;
			elseif(p_sCommand=="SetRallyPoint")then
				var CObjHndl xHndl;
				if(p_pxObject!=null)then
					xHndl=p_pxObject^.GetHandle();
				endif;
				//L KLog.LogSpam("Pickpoint","Recieved Vec3 FightingObj: "+p_vPos.ToString());
				var vec3 vPos;
				if(p_sMiscParams=="")then
					vPos=p_vPos;
				else
					vPos.FromString(p_sMiscParams);
				endif;
				//L KLog.LogSpam("Pickpoint","Tunneled vec3 is: "+p_sMiscParams+" ("+vPos.ToString()+")");
				SetRallyPoint(vPos,xHndl);
			elseif(p_sCommand=="CTheLite")then
				var ^CTheLite pxTask=cast<CTheLite>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"CTheLite"));
				if(pxTask!=null)then
					if(pxTask^.Init(GetHandle(), p_vPos))then
						AddTask(pxTask,true);
					else
						pxTask^.GetFactory()^.FreeState(pxTask);
					endif;
				endif;
			elseif(p_sCommand=="setlevel")then
				var bool b=SetLevel(p_sMiscParams.ToInt());
				if(!b)then
					InvalidateAttrib("level"); // if level was not changed, make sure client receives old level again
				endif;
			elseif(p_sCommand=="setlevelcheat")then
				SetLevelClean(Math.Min(GetLevel()+1,4));
			elseif(p_sCommand=="setlevelcheatai")then
				SetLevelClean(Math.Clamp(p_sMiscParams.ToInt(), 0, 4));
			elseif(p_sCommand=="upgradecheatai")then
				ProcessTTFilter(this, p_sMiscParams, true);
			elseif(p_sCommand=="Dock")then
				if(p_pxObject!=null)then
					GoToObj(p_pxObject^.GetHandle(),true, false);
				endif;
				//HandleWalkCommand(p_vPos, p_sMiscParams);
			elseif(p_sCommand=="EnterPortal")then
				if(p_pxObject!=null)then
					EnterPortal(p_pxObject, p_bQ, p_vPos);
				endif;
			elseif(p_sCommand=="Action")then
				if(p_sMiscParams.Find("/GoAway")!=-1)then
					// go away only if not on wall
					if(!GetOnWall()&&!GetTransportObj().IsValid())then
						GoTo(p_vPos, false, GetDefaultSpeed(), true, true, false, true);
					endif;
				elseif(p_sMiscParams.Find("LevelUp")!=(-1))then
					var bool b=false;
					var int i;
					for(i=GetLevel()+1)cond(i<5)iter(i++)do
						b=SetLevel(i);
						if(b)then break; endif;
					endfor;
					if(!b)then InvalidateAttrib("level"); endif;
//					var bool b=SetLevel(GetLevel()+1);
//					if(!b)then InvalidateAttrib("level"); endif;
				elseif(p_sMiscParams.Find("/Walk")>=0)then
					HandleWalkCommand(p_vPos, p_sMiscParams);
				elseif(p_sMiscParams.Find("/SetPos")>=0)then
					SetPos(p_vPos);
				elseif(p_sMiscParams.Find("/AddPriorityTarget")!=-1)then
					if(IsAbleToFight()&&p_pxObject!=null)then
						AddPriorityTarget(p_pxObject^.GetHandle());
					endif;
				elseif(p_sMiscParams.Find("/ClearPriorityList")!=-1)then
					ClearPriorityList();
				elseif(p_sMiscParams.Find("/AttackSrv")!=-1)then
					Fight(p_pxObject,p_vPos,false,false);
				elseif(p_sMiscParams.Find("/Attack")!=-1)then
					if(IsAbleToFight()||IsSiegeUnit())then
						Fight(p_pxObject,p_vPos,true,p_bQ);
					else
						var CGameObj.CAdvanceActionParams xParams;
						var CObjHndl xTarget;
						if(p_pxObject!=null)then
							xTarget=p_pxObject^.GetHandle();
						else
							xParams.m_vGoalOffset=p_vPos;
						endif;
						xParams.m_iPrefSpeed=GetMaxSpeed();
						var int iPos=p_sMiscParams.Find("/RangeToWalk=");
						if(iPos!=-1)then
							var string sParam=p_sMiscParams.Mid(iPos);
							var real fParam=(sParam.Mid(sParam.Find("=")+1)).ToReal();
//							if(fParam==49999.0)then fParam=GetFOWRange()/2.0; endif;
							xParams.m_fMinDistance=fParam;
						else
							xParams.m_fMinDistance=GetFOWRange()/2.0;
						endif;
						GoTo(xTarget,xParams, true, false);
					endif;
				elseif(p_sMiscParams.Find("/FountainHeal")>=0)then
					FountainHeal(p_pxObject,p_bQ);
				elseif(p_sMiscParams.Find("/SeasWellHeal")>=0)then
					SeasWellHeal(p_pxObject,p_bQ);
				elseif(p_sMiscParams.Find("/BoardTransporter")!=-1)then
					BoardTransport(p_pxObject, p_vPos, true, p_sMiscParams, true, p_bQ);
				elseif(p_sMiscParams.Find("/MountThatUnit")!=-1)then
					MountThatUnit(p_pxObject, p_vPos, true, p_sMiscParams, p_bQ);
				elseif(p_sMiscParams.Find("/HuntAnimals")>=0)then
					HuntAnimals(GetPos());
				elseif(p_sMiscParams.Find("/AggroState_")!=-1)then
					var string sMode=p_sMiscParams.Mid(p_sMiscParams.FindRev('_')+1);
					if(!m_bIsBerserker)then
						SetAggressionState(sMode.ToInt());
					endif;
				elseif(p_sMiscParams.Find("/AggressiveTarget")!=-1)then
					if(m_pxTaskMgr!=null)then
						var ^CTask pxTask=m_pxTaskMgr^.GetCurTask();
						if(pxTask!=null)then
							if(pxTask^.Break())then
								pxTask^.EndTask();
							endif;
						endif;
					endif;
					UpdateAggressionPos(p_vPos);
					m_bAggressionWalk=true;
					m_bAggrTNoAnml=false;
					if(p_sMiscParams.Find("/AggrTNoAnml")!=-1)then m_bAggrTNoAnml=true; endif;
					var array vec3 avPos; avPos.AddEntry(p_vPos);
					StartPatrol(avPos, 0, GetDefaultSpeed());
					CheckPatrol();
				elseif(p_sMiscParams.Find("/Kill")!=-1)then
					DiePerHarakiri();
				elseif(p_sMiscParams.Find("/AutoScout")!=-1)then
					AutoScout();
				elseif(p_sMiscParams.Find("/Notify")>=0)then
					Notify(p_sMiscParams);
				elseif(p_sMiscParams.Find("/Stop")>=0)then
					StopEverything();
				elseif(p_sMiscParams.Find("/defensive_mode")>=0)then
					if(CheckSpecialActionTimer(p_sMiscParams))then
						SetDefensiveMode(p_sMiscParams);
					endif;
				elseif(p_sMiscParams.Find("/LeaveTransport")>=0&&m_xTransportObj.IsValid())then
					var ^CFightingObj pxTransport=cast<CFightingObj>(m_xTransportObj.GetObj());
					if(pxTransport!=null/*&&!pxTransport^.IsTrapped()*//*&&!pxTransport^.GetTransportObj().IsValid()*/)then
						pxTransport^.LetLeavePassenger(GetHandle(),p_sMiscParams.Right(2).ToInt());
					endif;
				else
					super.HandleGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams);
				endif;
			elseif(p_sCommand=="Cancel")then
				CancelAction(p_sMiscParams);
			elseif(p_sCommand=="StornoLast")then
				StornoLast();
			elseif(p_sCommand=="StornoAll")then
				StornoAll();
			elseif(p_sCommand=="ReleaseItem")then
				ReleaseItem(p_sMiscParams,p_bQ);
			elseif(p_sCommand=="Execute_Q_Walk")then
				var CObjHndl xInitiator;
				xInitiator.FromInt(p_sMiscParams.ToInt());
				if(xInitiator==GetHandle())then
					//we are already starting the new Task, invoke walkaction
					var ^CWalkToPos pxCurWalkTask=cast<CWalkToPos>(GetCurTask());
					if(pxCurWalkTask!=null)then pxCurWalkTask^.InvokeWalkAction(); endif;
				else
					if(m_pxTaskMgr!=null&&m_pxTaskMgr^.NumSubs()>=2)then
						var ^CWalkToPos pxTask=cast<CWalkToPos>(m_pxTaskMgr^.GetSubState(1));
						if(pxTask!=null&&pxTask^.GetTargetPos()==p_vPos)then
							//KLog.LogWarn("CHP","Execute_Q_Walk: "+GetName());
							m_pxTaskMgr^.StopCurTask();
						endif;
					endif;
				endif;
			elseif(p_sCommand=="MarchToWar")then
				if(m_pxTaskMgr!=null)then
					var ^CTask pxTask=m_pxTaskMgr^.GetCurTask();
					if(pxTask!=null)then
						if(pxTask^.Break())then
							pxTask^.EndTask();
						endif;
					endif;
				endif;
				UpdateAggressionPos(p_vPos);
				m_bAggressionWalk=true;
				m_bAggrTNoAnml=false;
				if(p_sMiscParams.Find("/AggrTNoAnml")!=-1)then
					m_bAggrTNoAnml=true;
					p_sMiscParams.Replace("/AggrTNoAnml","");
				endif;
				var array vec3 avPos; avPos.AddEntry(p_vPos);
				var int iSpeed=Math.Clamp(p_sMiscParams.ToInt(),1,GetMaxSpeed());
				StartPatrol(avPos, 0, iSpeed);
				CheckPatrol();
			else
				super.HandleGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams);
			endif;
		else
			CSrvWrap.LogInfo("FightingObj","HandleGamePlayCommand: Object is dead, it cannot do anything!");
		endif;
	endproc;
	
	export proc void AddPriorityTarget(CObjHndl p_xTarget)
		m_xPriorityList.AddEntry(p_xTarget);
		/*AI:
		if(!IsInFight())then
			ExamineEnemies(false, false);
		endif;
		*/
	endproc;
	
	export proc void ClearPriorityList()
		m_xPriorityList.Clear();
	endproc;
	
	export proc void StopEverything()
		if(m_pxTaskMgr!=null)then
			m_pxTaskMgr^.BreakAll();
			if(HasWalkAction())then
				TerminateAction();
			endif;
			if(m_pxPatrolInfo!=null)then
				delete m_pxPatrolInfo;
				m_pxPatrolInfo=null;
			endif;
		endif;
		m_bFreeHunting=false;
		UpdateAggressionPos(GetPos());
	endproc;
	
	export proc void CancelAction(string p_sTTPath)
		if(m_pxTaskMgr!=null)then
			m_pxTaskMgr^.RemoveAction(p_sTTPath);
		endif;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("CurTask","none");
			pxAttr^.SetValue("CurProcessObj","");
			pxAttr^.SetValue("CurProcess",0);
		endif;
	endproc;
	
	proc void Notify(string p_sMiscParams)
		var bool bQ=false;
		var string sDest="";
		var array string asToks;
		p_sMiscParams.Split(asToks, "/", true);
		var int i, iC=asToks.NumEntries();
		for(i=0) cond(i<iC) iter(++i)do
			var array string asDef;
			asToks[i].Split(asDef, "=", true);
			if(asDef.NumEntries()==1)then
				if(asDef[0].Find("Queued")>=0)then
					bQ=true;
				endif;
			elseif(asDef.NumEntries()==2)then
				if(asDef[0].Find("Notify")>=0)then
					sDest=asDef[1];
				endif;
			endif;
		endfor;
		var ^CNotify pxTask=cast<CNotify>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"Notify"));
		if(pxTask!=null)then
			var bool bR=pxTask^.Init(GetHandle(), sDest);
			if(bR)then
				pxTask^.SetUserCommand(true);
				AddTask(pxTask, bQ);
			else
				pxTask^.GetFactory()^.FreeState(pxTask);
			endif;
		endif;
	endproc;
	
	export proc void HandleWalkCommand(vec3 p_vPos, string p_sMiscParams)
		var bool bQ=false;
		var bool bPatrol=false;
		var int iSpeed=GetMaxSpeed();
		var bool bUseMaterial=true;
		var bool bUsePF=true;
		var bool bHeightAdapt=true;
		if(p_vPos!={0.0,0.0,0.0})then
			UpdateAggressionPos(p_vPos);
			var array string asToks;
			p_sMiscParams.Split(asToks, "/", true);
			var int i, iC=asToks.NumEntries();
			for(i=0) cond(i<iC) iter(++i)do
				var array string asDef;
				asToks[i].Split(asDef, "=", true);
				if(asDef.NumEntries()==1)then
					if(asDef[0].Find("Queued")>=0)then
						bQ=true;
					endif;
					if(asDef[0].Find("Patrol")>=0)then
						bPatrol=true;
					endif;
					if(asDef[0].Find("NoPF")>=0)then
						bUsePF=false;
					endif;
					if(asDef[0].Find("NoHeightAdapt")>=0)then
						bHeightAdapt=false;
					endif;
				elseif(asDef.NumEntries()==2)then
					if(asDef[0].Find("Speed")>=0)then
						iSpeed=asDef[1].ToInt();
					endif;
					if(asDef[0].Find("UseMaterial")>=0)then
						bUseMaterial=asDef[1]!="false";
					endif;
				endif;
			endfor;
			if(bPatrol)then
				AddPatrolPoint(p_vPos,iSpeed);
			else
				GoTo(p_vPos, true, iSpeed, bUsePF, bHeightAdapt, false, bQ, bUseMaterial);
			endif;
		endif;
		UpdateWalkTargetAttribs();
		UpdatePatrolTargetAttribs();
	endproc;
	
	export proc void UpdateWalkTargetAttribs()
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr==null||m_pxTaskMgr==null)then return; endif;
		var array vec3 avPos;
		var int i,iC=m_pxTaskMgr^.NumSubs();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CWalkToPos pxTask=cast<CWalkToPos>(m_pxTaskMgr^.GetSubState(i));
			if(pxTask==null)then continue; endif;
			if(pxTask^.GetTargetPos()=={0.0,0.0,0.0})then continue; endif;
			avPos.AddEntry(pxTask^.GetTargetPos());
		endfor;
		var string sTargets;
		iC=Math.Min(avPos.NumEntries(),10);
		for(i=0)cond(i<iC)iter(i++)do
			sTargets+=avPos[i].ToString()+"|";
		endfor;
		pxAttr^.SetValue("WalkTargets",sTargets);
	endproc;
	
	export proc void UpdatePatrolTargetAttribs()
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr==null)then return; endif;
		var array vec3 avPos;
		if(m_pxPatrolInfo!=null)then
			avPos=m_pxPatrolInfo^.m_avWaypoints;
		endif;
		var string sTargets;
		var int i,iC=Math.Min(avPos.NumEntries(),10);
		for(i=0)cond(i<iC)iter(i++)do
			sTargets+=avPos[i].ToString()+"|";
		endfor;
		pxAttr^.SetValue("PatrolTargets",sTargets);
	endproc;
	
	export proc bool SetRallyPoint(vec3 p_vPoint, CObjHndl p_xTarget)
		var vec3 vPos=p_vPoint;
		m_xRallyTarget=CObjHndl.Invalid();
		var ^CGameObj pxRallyTarget=p_xTarget.GetObj();
		var ^CFightingObj pxRTFO=cast<CFightingObj>(p_xTarget.GetObj());
		var ^CAttribs pxAttr=GetAttribs();
		if(pxRTFO!=null)then
			var CFourCC xLink="Ex_1";
			if(!pxRTFO^.GetLinkPosWorld(xLink,vPos))then
				vPos=pxRTFO^.GetCustomRallyPos();
			endif;
			m_xRallyTarget=p_xTarget;
		elseif(pxRallyTarget!=null)then
			var CFourCC xLink="Ex_1";
			if(!pxRallyTarget^.GetLinkPosWorld(xLink,vPos))then
				vPos=pxRallyTarget^.GetPos()+({0.0,1.0,0.0}*pxRallyTarget^.GetRadius());
			endif;
			m_xRallyTarget=p_xTarget;
//		else
//			var bitset dwLT=CObjMgrHost.GFPLT_Land;
//			if(pxAttr!=null)then
//				var bool bHarbour=pxAttr^.GetValueBool("fishDelivery");
//				if(bHarbour)then
//					dwLT=CObjMgrHost.GFPLT_Water;
//				endif;
//			endif;
		endif;
		if(vPos!={0.0,0.0,0.0})then
			var real fHeight=CSrvWrap.GetScapeMgr().GetHeight(vPos.GetX(), vPos.GetY());
			var real fSeaHeight=m_fWaterLevel;
			if(fSeaHeight>fHeight)then
				fHeight=fSeaHeight;
			endif;
			vPos.SetZ(fHeight);
		endif;
		if(pxAttr!=null)then
			pxAttr^.SetValue("RallyPoint", vPos.ToString());
			pxAttr^.Invalidate("RallyPoint"); // if rallypoint was not changed, make sure client receives old rallypoint again
		endif;
		m_vRallyPos=vPos;
		CheckTeslaMachine(m_xRallyTarget);
		CheckDestination(m_xRallyTarget);
		UpdateRallyTarget();
		return(true);
	endproc;
	
	export proc vec3 GetRallyPosition(int p_iPrevention)
//		if(p_iPrevention>10)then return {0.0,0.0,0.0}; endif;
		if(p_iPrevention>10)then return m_vRallyPos; endif;
		if(m_xRallyTarget.IsValid())then
			var ^CBuilding pxBuilding=cast<CBuilding>(m_xRallyTarget.GetObj());
			if(pxBuilding!=null)then
				if(pxBuilding^.GetClassName().Find("_portal_terminus")!=-1)then
					return pxBuilding^.GetCustomRallyPos();
				else
					return pxBuilding^.GetRallyPosition(p_iPrevention+1);
				endif;
			endif;
		endif;
		return m_vRallyPos;
	endproc;
	
	export proc ref CObjHndl GetRallyTarget()
		return m_xRallyTarget;
	endproc;
	
	export proc void UpdateRallyTarget()
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			var int i=-1;
			if(m_xRallyTarget.IsValid())then
				i=m_xRallyTarget.AsInt();
			endif;
			pxAttr^.SetValue("CurRally",i);
		endif;
	endproc;
	
	proc void SetRageUnit(bool p_bValue)
		m_bIsRageUnit=p_bValue;
	endproc;
	
	proc bool GetRageUnit()
		return m_bIsRageUnit;
	endproc;
	
	export proc void SetRallySite(bool p_bRally)
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr==null)then return; endif;
		if(p_bRally)then
			pxAttr^.SetValue("IsRallySite",1);
		else
			pxAttr^.SetValue("IsRallySite",0);
		endif;
	endproc;
	
	export proc bool GetRallySite()
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr==null)then return false; endif;
		return (pxAttr^.GetValueInt("IsRallySite")==1);
	endproc;
	
	export proc void HealMe(real p_fAddHitpoints)
		HealMe(p_fAddHitpoints,true);
	endproc;
	
	export proc void HealMe(real p_fAddHitpoints, bool p_bUseArtifact)
		if(m_bBloodInfect)then return; endif;
		AddRangedBuff("is_getting_healed");
		if(GetHitpoints()<GetMaxHitpoints())then
			DeleteTimer(TIMER_ISGETTINGHEALED_FX);
			CreateTimer(TIMER_ISGETTINGHEALED_FX,CGameTimeSpan.OneSecond() * 2.5, false);
			var CObjHndl xHndl=AddFX("fx_heal_passive",-1.0);
			var CFourCC xLink;
			if(xHndl.IsValid())then
				xHndl.GetObj()^.LinkAction(GetHandle(),xLink);
			endif;
		endif;
		AddHealingBoni(p_fAddHitpoints);
		DeleteTimer(TIMER_ISGETTINGHEALED);
		CreateTimer(TIMER_ISGETTINGHEALED,CGameTimeSpan.OneSecond() * 2.5, false);
		if((GetHitpoints()+p_fAddHitpoints) > GetMaxHitpoints())then
			SetHitpoints(GetMaxHitpoints());
			return;
		endif;
		SetHitpoints((GetHitpoints()+p_fAddHitpoints));
	endproc;
	
	export proc void CheckHealingBoni()
		m_fHealingBoniRel = (m_xTechTree.GetValueR("MiscValues/"+GetPlayerTribeName()+"/Healing_Bonus_rel",0.0));
		m_fHealingBoniAbs = (m_xTechTree.GetValueI("MiscValues/"+GetPlayerTribeName()+"/Healing_Bonus_abs",0)).ToReal();
	endproc;
	
	export proc void AddHealingBoni(ref real p_rfBoni)
		p_rfBoni *= m_fHealingBoniRel;
		p_rfBoni += m_fHealingBoniAbs;
	endproc;
	
	export proc void FullHeal()
		ResetDamagePortion();
		SetHitpoints(GetMaxHitpoints());
	endproc;
	
	export proc void FountainHeal(^CGameObj p_pxO, bool p_bQ)
		if(p_pxO!=null)then
			//Henry: do not try to fountainheal flying units ;)
			if(IsJetPackOn()||m_bFlyingUnit)then
//			if(IsFlyingUnit())then
				GoTo(p_pxO^.GetPos(), true, GetDefaultSpeed(), true, true, GetOnWall(), false, true);
				return;
			endif;
			if(m_bBloodInfect)then return; endif;
			var ^CFountainHeal pxFH=cast<CFountainHeal>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"FntnHeal"));
			if(pxFH!=null)then
				var bool bR=pxFH^.Init(GetHandle(), p_pxO^.GetHandle());
				if(bR)then
					pxFH^.SetUserCommand(true);
					AddTask(pxFH, p_bQ);
				else
					pxFH^.GetFactory()^.FreeState(pxFH);
				endif;
			endif;
		endif;
	endproc;
	
	export proc int GetTransportClass()
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			return pxAttr^.GetValueInt("transportclass");
		endif;
		return 0;
	endproc;
	
	export proc void BoardTransport(^CGameObj p_pxTransport, vec3 p_vPos, bool p_bUserCommand, string p_sParams)
		return BoardTransport(p_pxTransport, p_vPos, p_bUserCommand, p_sParams, true, false);
	endproc;
	
	export proc void BoardTransport(^CGameObj p_pxTransport, vec3 p_vPos, bool p_bUserCommand, string p_sParams, bool p_bGoTo, bool p_bQ)
		if(GetTransportObj().IsValid())then return; endif;
		if(m_bSlaveInvincible&&GetClassName()=="aje_resource_collector")then return; endif;
		if(p_pxTransport==null)then
			GoTo(p_vPos, true, GetDefaultSpeed(), true, p_bQ, GetOnWall(), false, true);
			return;
		endif;
		var ^CFightingObj pxFO=cast<CFightingObj>(p_pxTransport);
		if(pxFO!=null&&pxFO^.GetTransportObj().IsValid())then
			pxFO=cast<CFightingObj>(pxFO^.GetTransportObj().GetObj());
		endif;
		if(pxFO==null)then
			GoTo(p_vPos, true, GetDefaultSpeed(), true, p_bQ, GetOnWall(), false, true);
			return;
		endif;
		var int i1=pxFO^.GetOwner(), i2=GetOwner();
		if(i1!=i2)then
			var bool bAlliance = Math.Min(CSrvWrap.GetDiplomacyMgr().GetRelation(i1,i2),CSrvWrap.GetDiplomacyMgr().GetRelation(i2,i1))==2;
			if(!CMirageSrvMgr.Get().DiploLocked()||!bAlliance)then
				if(p_bGoTo)then
					GoTo(p_vPos, true, GetDefaultSpeed(), true, p_bQ, GetOnWall(), false, true);
				endif;
				return;
			endif;
		endif;
		if(IsJetPackOn()||m_bFlyingUnit)then
//		if(IsFlyingUnit())then
			GoTo(p_vPos, true, GetDefaultSpeed(), true, p_bQ, GetOnWall(), false, true);
			return;
		endif;
		var ^CTransportObj pxObj=cast<CTransportObj>(pxFO);
		if(pxObj==null)then
//		if(pxObj==null||pxObj^.GetTransportObj().IsValid())then
			GoTo(p_vPos, true, GetDefaultSpeed(), true, p_bQ, GetOnWall(), false, true);
			return;
		endif;
//		if(pxObj^.GetTransportClass()!=2&&GetGfxName()=="babbage_mobile_suit")then
//			GoTo(p_vPos, true, GetDefaultSpeed(), true, p_bQ, GetOnWall(), false, true);
//			return;
//		endif;
/*
		if(pxObj^.GetClassName().Find("_zeppelin")!=-1&&GetClassName()=="aje_resource_collector")then
			GoTo(p_vPos, true, GetDefaultSpeed(), true, p_bQ, GetOnWall(), false, true);
			return;
		endif;
*/
		if(pxObj^.HasUnboardEffect())then
			GoTo(p_vPos, true, GetDefaultSpeed(), true, p_bQ, GetOnWall(), false, true);
			return;
		endif;
		var int iSelfType=GetTransportClass();
		var int iTransporterType=pxObj^.GetTransportClass();
		var string sTaskName=GetCurTaskName();
		if(iTransporterType<=iSelfType)then
			if(sTaskName!="BoardTra")then
				GoTo(p_vPos, true, GetDefaultSpeed(), true, p_bQ, GetOnWall(), false, true);
			endif;
			return;
		endif;
		var ^CShip pxShip=cast<CShip>(this);
		if(pxShip!=null)then
			if(sTaskName!="BoardTra")then
				GoTo(p_vPos, true, GetDefaultSpeed(), true, p_bQ, GetOnWall(), false, true);
			endif;
			return;
		endif;
		var bool bQ=false;
		if(p_sParams.Find("/Queued")!=-1)then
			bQ=true;
		endif;
		if(pxObj^.NumFreeSeats()<NeededSpaceInTransport())then
			if(sTaskName!="BoardTra"&&sTaskName!="BoardPas")then
				GoTo(p_vPos, true, GetDefaultSpeed(), true, p_bQ, GetOnWall(), false, true);
			endif;
			return;
		endif;
		var ^CManagedBoardingPassenger pxTask=cast<CManagedBoardingPassenger>(GetCurTask());
		if(pxTask!=null)then
			if(bQ)then
				return;
			else
				BreakEveryTask();
			endif;
		endif;
		pxTask=cast<CManagedBoardingPassenger>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"BoardPas"));
		if(pxTask!=null)then
			pxTask^.SetUserCommand(true);
			if(pxTask^.Init(GetHandle(),pxFO^.GetHandle()))then
				AddTask(pxTask,bQ);
			else
				pxTask^.GetFactory()^.FreeState(pxTask);
			endif;
		endif;
	endproc;
	
	export proc void MountThatUnit(^CGameObj p_pxUnit, vec3 p_vPos, bool p_bUserCommand, string p_sParams, bool p_bQ)
		if(p_pxUnit==null)then return; endif;
		var ^CFightingObj pxUnit=cast<CFightingObj>(p_pxUnit);
		if(pxUnit==null)then return; endif;
		if(pxUnit^.IsLocked())then return; endif;
		if(pxUnit^.GetType()=="BLDG" || pxUnit^.GetType()=="SHIP")then return; endif;
		if(GetClassName().Find("_portal_terminus")!=-1)then
			pxUnit^.EnterPortal(this, p_bQ, p_vPos, false);
		elseif(GetClassName()=="hu_bunker"||GetClassName()=="seas_fortress")then
			var ^CCharacter pxChar=cast<CCharacter>(pxUnit);
			if(pxChar!=null)then
				pxChar^.EnterBunker(this, p_bQ, false);
			endif;
		else
			pxUnit^.BoardTransport(this, p_vPos, p_bUserCommand, p_sParams, false, p_bQ);
		endif;
	endproc;
	
	export proc void StopBoarding()
		if(m_pxTaskMgr==null)then return; endif;
		var ^CManagedBoardingPassenger pxPasTask=cast<CManagedBoardingPassenger>(m_pxTaskMgr^.GetCurTask());
		var ^CManagedBoardingTransporter pxTraTask=cast<CManagedBoardingTransporter>(m_pxTaskMgr^.GetCurTask());
		if(pxPasTask!=null)then
			BreakEveryTask();
		elseif(pxTraTask!=null)then
			BreakCurrentTask();
		endif;
	endproc;
	
	export proc int NeededSpaceInTransport()
		return 1;
	endproc;
	
	export proc bool IsOnShip()
		return (m_xTransportObj.IsValid()&&m_xTransportObj.GetObj()^.GetType()=="SHIP");
	endproc;
	
	export proc bool IsOnOpenTransporter()
		return false;
	endproc;
	
	export proc void SetTaskDescription(string p_sDesc)
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null&&pxAttr^.GetValue("TaskDescription")!=p_sDesc)then
			pxAttr^.SetValue("TaskDescription",p_sDesc);
		endif;
	endproc;
	
	///////
	//	Rotate2Obj()
	///////
	export proc void Rotate2Obj(CObjHndl p_xObj)
		var ^CGameObj pxObj=p_xObj.GetObj();
		if(pxObj==null)then return; endif;
		var vec3 vDir=pxObj^.GetPos()-GetPos();
		var Quat qTRot;
		qTRot.FromXYDir(vDir.GetX(),vDir.GetY());
		RotateAction(qTRot);
	endproc;
	
	export proc void SetTrumpetEffect()
		if(GetType()=="BLDG")then return; endif;
		//TUNING: Duration of trumpet effect
		var real fDuration=15.0;
		DeleteTimer(TIMER_MAMMOTH_TRUMPET);
		SetEffectFlag(EFFECT_MAMMOTH_TRUMPET, true);
		ForceBoniUpdate();
		CreateTimer(TIMER_MAMMOTH_TRUMPET,CGameTimeSpan.OneSecond() * fDuration, false);
	endproc;
	
	export proc void SetStoned(real p_fDuration)
		TerminateAction();
		SetTrappedTime(p_fDuration);
		DeleteTimer(TIMER_STONED);
		SetEffectFlag(EFFECT_ITEM_STONED, true);
		CreateTimer(TIMER_STONED, CGameTimeSpan.OneSecond() * p_fDuration, false);
	endproc;
	
	export proc void SetIced(real p_fDuration,real p_fResistStart)
		if(m_bSlaveInvincible)then return; endif;
		if(GetType()=="NEST"||GetType()=="BLDG")then return; endif;
		if(IsIceImmun())then return; endif;
		var real fImmunityTime=GetImmunityTime();
		if(HasTimer(TIMER_FROST))then
			DeleteTimer(TIMER_FROST);
		endif;
		if(HasTimer(TIMER_FROSTIMMUNITY))then
			return;
		endif;
		SetIcedFlag(true);
		SetTrappedTime(p_fDuration);
		SetFroozenEffect(true);
		CreateTimer(TIMER_FROST,CGameTimeSpan.OneSecond()*p_fDuration, false);
		if(fImmunityTime!=0.0&&p_fResistStart!=0.0)then
			if(!HasTimer(TIMER_START_RESIST)&&!HasTimer(TIMER_FROSTIMMUNITY))then
				CreateTimer(TIMER_START_RESIST,CGameTimeSpan.OneSecond()*p_fResistStart, false);
			endif;
		endif;
	endproc;
	
	export proc void SetPawEffect()
		//TUNING: Duration of trumpet effect
		var real fDuration=15.0;
		DeleteTimer(TIMER_TRICERATOPS_PAW);
		SetEffectFlag(EFFECT_TRICERATOPS_PAW, true);
		CreateTimer(TIMER_TRICERATOPS_PAW,CGameTimeSpan.OneSecond() * fDuration, false);
	endproc;
	
	export proc real GetProdSpeedFactor(CFourCC p_xType)
		if(p_xType=="ANML")then
			var real fS=GetBonusSum(CFightingObj.BONUS_PRODSPEED_ANML);
			if(fS==0.0f)then
				return 1.0f;
			endif;
			return fS;
		else
			return 1.0f;
		endif;
	endproc;
	
	export proc ^CAttribs GetPlayerAttribs()
		var ^CLevel pxCurLevel=CSrvWrap.GetCurLevel();
		if(pxCurLevel==null)then return null; endif;
		var ^CPlayer pxP=pxCurLevel^.GetPlayer(GetOwner());
		if(pxP==null)then return null; endif;
		return pxP^.GetAttribs();
	endproc;
	
	export proc bool CanHarvest()
		var bool bResult=m_xTechTree.GetValueB(GetObjPath()+"/can_harvest",false);
		bResult=(bResult&&!GetTransportObj().IsValid());
		return(bResult);
	endproc;
	
	export proc bool CanHarvestRes(string p_sResis)
		var bool bResult=m_xTechTree.GetValueI(GetObjPath()+"/ResInvCaps/"+p_sResis,0)>0;
		bResult=(bResult&&!GetTransportObj().IsValid());
		return(bResult);
	endproc;
	
	export proc bool CanBuild()
		var bool bResult=m_xTechTree.GetValueB(GetObjPath()+"/can_build",false);
		bResult=(bResult&&!GetTransportObj().IsValid());
		return(bResult);
	endproc;
	
	export proc void CreateSpirit()
		if(m_bGameOverKill)then return; endif;
		if(!DoesCountInUnitLimit())then
			return;
		endif;
		var string sPath=GetObjPath();
		if(m_xTechTree.GetValueB(sPath+"/nospirit",false))then
			return;
		endif;
		if(CMirageSrvMgr.Get().UseOldSpirits())then
			CreateOldSpirit();
		else
			CreateNewSpirit();
		endif;
	endproc;
	
	export proc void CreateOldSpirit()
//		if(!DoesCountInUnitLimit())then
//			return;
//		endif;
//		var string sPath=GetObjPath();
//		if(m_xTechTree.GetValueB(sPath+"/nospirit",false))then return; endif;
		var ^CSpirit pxSpirit=CSrvWrap.GetSpiritMgr().CreateSpirit();
		if(pxSpirit==null)then return; endif;
		var string sID, sDurations, sStarts, sDeath=CTimeMgr.Get().GetTime().ToString();
		var int i, iC=m_aiActionTimerIDs.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CTechTree.CNode pxTTNode=m_xTechTree.FindNode(m_axActionObj[i].GetTTPath());
			if(pxTTNode!=null)then
//				sID+=m_axActionObj[i].GetTTPath())+"|";
//				sID+=pxTTNode^.GetName()+"|";
				sID+=pxTTNode^.GetHashValue().ToString()+"|";
				sDurations+=m_axActionObj[i].GetDuration().ToString()+"|";
				sStarts+=m_axActionObj[i].GetStartTime().ToString()+"|";
			endif;
		endfor;
		RegisterSpirit(pxSpirit^.GetHandle(),GetKillerCount(),m_iKillerCount+m_iKillerHistory,m_xCorpse,sID,sDurations,sStarts,sDeath);
		var ^CAttribs pxAttr=GetAttribs();
		var vec3 vPos=GetPos();
		vPos.SetZ(Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vPos.GetX(),vPos.GetY()),m_fWaterLevel));
		pxSpirit^.SetPos(vPos);
		pxSpirit^.SetOwner(GetOwner());
		pxSpirit^.SetRotation(GetRotation());
		pxSpirit^.SetRadius(GetRadius());
		var CTechTree xTechTree=GetTechTree();
		var string sObjPath=m_sObjPath;
		if(pxAttr!=null)then
			sObjPath=pxAttr^.GetValue("ObjPath");
		endif;
		if(!sObjPath.IsEmpty())then
			pxSpirit^.SetDescription(sObjPath);
//			var string sDescription=xTechTree.GetValueS(sObjPath+"/description",GetClassName());
			//pxSpirit^.SetDescription(sDescription);
		endif:
		pxSpirit^.SetClass(GetClassName());
		var int iLevel=m_iLevel;
		if(pxAttr!=null)then
			iLevel=pxAttr^.GetValueInt("level");
		endif;
		pxSpirit^.SetLevel(iLevel);
		var real fMaxHP=m_fMaxHitpoints;
		if(pxAttr!=null)then
			fMaxHP=pxAttr^.GetValueFloat("maxhitpoints");
		endif;
		pxSpirit^.SetMaxHP(fMaxHP.ToInt());
		var ^CTechTreeDef pxTTDef=GetTechTreeDef();
		var CStringArray asTTFilters;
		if(pxTTDef!=null)then
			var int i, iC=pxTTDef^.NumEntries();
			for(i=0) cond(i<iC) iter(++i)do
				asTTFilters.AddEntry(pxTTDef^.GetFilter(i));
			endfor;
			var ^CPlayer pxPlayer=CSrvWrap.GetCurLevel()^.GetPlayer(GetOwner());
			if(pxPlayer!=null)then
				pxTTDef=^(pxPlayer^.GetPlayerTechTreeDef());
				if(pxTTDef!=null)then
					iC=pxTTDef^.NumEntries();
					var string sPF;
					for(i=0)cond(i<iC)iter(++i)do
						sPF=pxTTDef^.GetFilter(i);
						if(sPF.Find("_RemoveMe")!=-1||sPF.Find("BuildDown")!=-1||(sPF.Find("Upgrades/aje_resource_collector")==-1&&sPF.Find("Upgrades/aje_rodeo")==-1&&sPF.Find("Upgrades/aje_small_farm")==-1&&sPF.Find("Upgrades/aje_temple")==-1&&sPF.Find("Upgrades/aje_weapons_builder")==-1&&sPF.Find("Upgrades/hu_arena")==-1&&sPF.Find("Upgrades/hu_lumberjack_cottage")==-1&&sPF.Find("Upgrades/hu_small_animal_farm")==-1&&sPF.Find("Upgrades/hu_stone_quarry")==-1&&sPF.Find("Upgrades/hu_temple")==-1&&sPF.Find("Upgrades/hu_weapons_smith")==-1&&sPF.Find("Upgrades/ninigi_animal_farm")==-1&&sPF.Find("Upgrades/ninigi_dojo")==-1&&sPF.Find("Upgrades/ninigi_hunting_lodge")==-1&&sPF.Find("Upgrades/ninigi_lumbermill")==-1&&sPF.Find("Upgrades/ninigi_stone_quarry")==-1&&sPF.Find("Upgrades/ninigi_temple")==-1&&sPF.Find("Upgrades/ninigi_weapon_maker")==-1&&sPF.Find("Upgrades/seas_barracks")==-1&&sPF.Find("Upgrades/seas_carrier")==-1&&sPF.Find("Upgrades/seas_laboratory")==-1&&sPF.Find("Upgrades/seas_garage")==-1&&sPF.Find("Upgrades/seas_headquarters/seas_better_tools")==-1&&sPF.Find("Upgrades/seas_small_tent")==-1))then continue; endif;
						if(GetClassName()=="aje_resource_collector"&&sPF.Find("Upgrades/aje_resource_collector")!=-1)then continue; endif;
						asTTFilters.AddEntry(sPF);
					endfor;
				endif;
			endif;
			pxSpirit^.SetTTFilters(asTTFilters);
		endif;
	endproc;
	
	//========================================================================================
	//===New FightingObj procedures in MIRAGE by Henry========================================
	//========================================================================================
	
	export proc void CreateNewSpirit()
//		if(!DoesCountInUnitLimit())then
//			return;
//		endif;
		var int iPID=GetOwner();
		if(iPID<0||iPID>7)then return; endif;
		var string sPath=GetObjPath();
//		if(m_xTechTree.GetValueB(sPath+"/nospirit",false))then return; endif;
		var ^CBasePlayer pxBase=CBasePlayer.GetPlayer(GetOwner());
		if(pxBase==null)then return; endif;
//		var ^CMrgSprt pxMS=cast<CMrgSprt>(CSrvWrap.GetObjMgr()^.CreateObj("mrg_sprt",GetOwner(),GetPos(),GetRotation()));
//		var ^CMrgSprt pxMS=cast<CMrgSprt>(CSrvWrap.GetObjMgr()^.CreateObj("mrg_sprt",-1,GetPos(),GetRotation()));
		var ^CMrgSprt pxMS=cast<CMrgSprt>(CSrvWrap.GetObjMgr()^.CreateObj("mrg_sprt_"+iPID.ToString(),-1,GetPos(),GetRotation()));
		if(pxMS==null)then return; endif;
		var string sID, sDurations, sStarts, sDeath=CTimeMgr.Get().GetTime().ToString();
		var int i, iC=m_aiActionTimerIDs.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CTechTree.CNode pxTTNode=m_xTechTree.FindNode(m_axActionObj[i].GetTTPath());
			if(pxTTNode!=null)then
				sID+=pxTTNode^.GetHashValue().ToString()+"|";
				sDurations+=m_axActionObj[i].GetDuration().ToString()+"|";
				sStarts+=m_axActionObj[i].GetStartTime().ToString()+"|";
			endif;
		endfor;
		var ^CAttribs pxAttr=GetAttribs();
		var vec3 vPos=GetPos();
		vPos.SetZ(Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vPos.GetX(),vPos.GetY()),m_fWaterLevel));
		var CTechTree xTechTree=GetTechTree();
		var string sObjPath=m_sObjPath;
		if(pxAttr!=null)then
			sObjPath=pxAttr^.GetValue("ObjPath");
		endif;
		if(!sObjPath.IsEmpty())then
			pxMS^.SetDescriptionClass(sObjPath,GetClassName(),GetOwner());
		endif;
		var real fMaxHP=m_fMaxHitpoints;
		if(pxAttr!=null)then
			fMaxHP=pxAttr^.GetValueFloat("maxhitpoints");
		endif;
		pxMS^.SetHP(fMaxHP.ToInt());
		var ^CTechTreeDef pxTTDef=GetTechTreeDef();
		var array string asTTFilters;
		if(pxTTDef!=null)then
			var int i, iC=pxTTDef^.NumEntries();
			for(i=0) cond(i<iC) iter(++i)do
				asTTFilters.AddEntry(pxTTDef^.GetFilter(i));
			endfor;
			pxTTDef=^(pxBase^.GetPlayerTechTreeDef());
			if(pxTTDef!=null)then
				iC=pxTTDef^.NumEntries();
				var string sPF;
				for(i=0)cond(i<iC)iter(++i)do
					sPF=pxTTDef^.GetFilter(i);
					if(sPF.Find("_RemoveMe")!=-1||sPF.Find("BuildDown")!=-1||(sPF.Find("Upgrades/aje_resource_collector")==-1&&sPF.Find("Upgrades/aje_rodeo")==-1&&sPF.Find("Upgrades/aje_small_farm")==-1&&sPF.Find("Upgrades/aje_temple")==-1&&sPF.Find("Upgrades/aje_weapons_builder")==-1&&sPF.Find("Upgrades/hu_arena")==-1&&sPF.Find("Upgrades/hu_lumberjack_cottage")==-1&&sPF.Find("Upgrades/hu_small_animal_farm")==-1&&sPF.Find("Upgrades/hu_stone_quarry")==-1&&sPF.Find("Upgrades/hu_temple")==-1&&sPF.Find("Upgrades/hu_weapons_smith")==-1&&sPF.Find("Upgrades/ninigi_animal_farm")==-1&&sPF.Find("Upgrades/ninigi_dojo")==-1&&sPF.Find("Upgrades/ninigi_hunting_lodge")==-1&&sPF.Find("Upgrades/ninigi_lumbermill")==-1&&sPF.Find("Upgrades/ninigi_stone_quarry")==-1&&sPF.Find("Upgrades/ninigi_temple")==-1&&sPF.Find("Upgrades/ninigi_weapon_maker")==-1&&sPF.Find("Upgrades/seas_barracks")==-1&&sPF.Find("Upgrades/seas_carrier")==-1&&sPF.Find("Upgrades/seas_laboratory")==-1&&sPF.Find("Upgrades/seas_garage")==-1&&sPF.Find("Upgrades/seas_headquarters/seas_better_tools")==-1&&sPF.Find("Upgrades/seas_small_tent")==-1))then continue; endif;
					if(GetClassName()=="aje_resource_collector"&&sPF.Find("Upgrades/aje_resource_collector")!=-1)then continue; endif;
					asTTFilters.AddEntry(sPF);
				endfor;

			endif;
		endif;
		pxMS^.Initialize(GetRot(), GetPos(), GetRotation(), GetClassName(), GetLevel(), GetOwner(), false, GetAggressionState(), 0, GetKillerCount(), GetKillerCount()+GetKillerHistory(), m_xCorpse, sID, sDurations, sStarts, sDeath, m_xTechTree.GetValueR(sPath+"/reanim_time",25.0f), m_xTechTree.GetValueR(sPath+"/spirit_life",120.0f), asTTFilters, m_xTechTree.GetValueS(sPath+"/soul_form","fx_ghost_sml"), m_xTechTree.GetValueR(sPath+"/ascension",0.25f), GetRadius(), m_xTechTree.GetValueI(sPath+"/research",0),GetName(),(!CMirageSrvMgr.Get().UseSupply()&&pxBase^.CreateSpiritCards()&&!m_bAI));
	endproc;
	
	export proc void SetLastEnemy(CObjHndl p_xEnemy) //needed to increase the killercount of the last enemy (which has sent this unit to the abyss ^^)
		m_xLastEnemy=p_xEnemy;
	endproc;
	
	export proc bool SetMirageFlag(bitset p_dwFlag, bool p_bOn) //to mark units affected by new abilities in MIRAGE ;)
		var int iIndex=-1;
		var bool bClearWpnCache=false, bFight=false;
		if(p_dwFlag==MIRAGE_SKULL_PROTECT)then
			iIndex=0;
		elseif(p_dwFlag==MIRAGE_SKULL_BOOST)then
			iIndex=1;
		elseif(p_dwFlag==MIRAGE_SCARECROW)then
			iIndex=2;
			bFight=true;
		elseif(p_dwFlag==MIRAGE_PSI_DISRUPT)then
			iIndex=3;
		elseif(p_dwFlag==MIRAGE_BLINDING_STORM)then
			iIndex=4;
		elseif(p_dwFlag==MIRAGE_MAGIC_CAULDRON)then
			iIndex=5;
			bFight=true;
		elseif(p_dwFlag==MIRAGE_BIG_HORN)then
			iIndex=6;
		elseif(p_dwFlag==MIRAGE_KING_JAW)then
			iIndex=7;
			bFight=true;
		elseif(p_dwFlag==MIRAGE_SPEAKER)then
			iIndex=8;
			bFight=true;
		elseif(p_dwFlag==MIRAGE_MOTIVATE)then
			iIndex=9;
			bFight=true;
		elseif(p_dwFlag==MIRAGE_THREATEN)then
			iIndex=10;
			bFight=true;
		elseif(p_dwFlag==MIRAGE_KEEN_EYES)then
			iIndex=11;
			bFight=true;
		elseif(p_dwFlag==MIRAGE_SAND_TRAP)then
			iIndex=12;
		elseif(p_dwFlag==MIRAGE_DC_BYAKUGAN_3)then
			iIndex=13;
			bFight=true;
		elseif(p_dwFlag==MIRAGE_DC_BYAKUGAN_4)then
			iIndex=14;
			bFight=true;
		elseif(p_dwFlag==MIRAGE_DC_BYAKUGAN_5)then
			iIndex=15;
			bFight=true;
		endif;
		if(iIndex!=-1)then
			if(p_bOn)then
				if(m_aiMirageFlags[iIndex]==0)then
					if(iIndex==0)then
						var ^CTechTreeDef pxDef=GetTechTreeDef();
						if(pxDef!=null)then
							pxDef^.EnableFilter(CAjeSkullController.PROTECT_PATH);
						endif;
					endif;
					if(iIndex==1)then
						var ^CTechTreeDef pxDef=GetTechTreeDef();
						if(pxDef!=null)then
							pxDef^.EnableFilter(CAjeSkullController.BOOST_PATH);
						endif;
					endif;
					if(iIndex==2)then
						var real fBonus=GetDmg()*0.01f*CScareCrow.EFFECT_BONUS_AMOUNT;
						var ^CBoniBucket pxBB=GetBoniBucket(CFightingObj.BONUS_DAMAGE);
						pxBB^.AddEntry("ScareCrow", -fBonus);
					endif;
					if(iIndex==3)then
						var ^CTechTreeDef pxDef=GetTechTreeDef();
						if(pxDef!=null)then
							pxDef^.EnableFilter(CSeasPsiDisruptor.DISRUPT_PATH);
							AddRangedBuff("slower_fighting_rate");
						endif;
					endif;
					if(iIndex==5)then
						var real fBonus=GetDmg()*0.01f*CMagicCauldron.EFFECT_BONUS_AMOUNT;
						var ^CBoniBucket pxBB=GetBoniBucket(CFightingObj.BONUS_DAMAGE);
						pxBB^.AddEntry("Cauldron", fBonus);
					endif;
					if(iIndex==9)then
						//crash rpg motivate
						var ^CGameObj pxObj=AddFX("fx_motivate",2.0).GetObj();
						if(pxObj!=null)then
							var CFourCC xLink;
							pxObj^.LinkAction(GetHandle(),xLink);
						endif;
						pxObj=AddFX("fx_motivate_lite",-1.0).GetObj();
						if(pxObj!=null)then
							var CFourCC xLink;
							pxObj^.LinkAction(GetHandle(),xLink);
						endif;
					endif;
					if(iIndex==10)then
						AddRangedBuff("less_damage");
					endif;
					if(iIndex==12)then
						var ^CTechTreeDef pxDef=GetTechTreeDef();
						if(pxDef!=null)then
							pxDef^.EnableFilter(CSandTrap.SAND_PATH);
							AddRangedBuff("slower_fighting_rate");
						endif;
					endif;
					if(bFight)then
						bClearWpnCache=true;
					endif;
				endif;
				m_aiMirageFlags[iIndex]++;
			else
				m_aiMirageFlags[iIndex]--;
				if(m_aiMirageFlags[iIndex]==0)then
					if(iIndex==0)then
						var ^CTechTreeDef pxDef=GetTechTreeDef();
						if(pxDef!=null)then
							pxDef^.DisableFilter(CAjeSkullController.PROTECT_PATH);
						endif;
					endif;
					if(iIndex==1)then
						var ^CTechTreeDef pxDef=GetTechTreeDef();
						if(pxDef!=null)then
							pxDef^.DisableFilter(CAjeSkullController.BOOST_PATH);
						endif;
					endif;
					if(iIndex==2)then
						var ^CBoniBucket pxBB=GetBoniBucket(CFightingObj.BONUS_DAMAGE);
						pxBB^.RemEntry("ScareCrow");
					endif;
					if(iIndex==3)then
						var ^CTechTreeDef pxDef=GetTechTreeDef();
						if(pxDef!=null)then
							pxDef^.DisableFilter(CSeasPsiDisruptor.DISRUPT_PATH);
							RemoveRangedBuff("slower_fighting_rate");
						endif;
					endif;
					if(iIndex==5)then
						var ^CBoniBucket pxBB=GetBoniBucket(CFightingObj.BONUS_DAMAGE);
						pxBB^.RemEntry("Cauldron");
					endif;
					if(iIndex==9)then
						//crash rpg motivate
						RemoveFX("fx_motivate");
						RemoveFX("fx_motivate_lite");
					endif;
					if(iIndex==10)then
						RemoveRangedBuff("less_damage");
					endif;
					if(iIndex==12)then
						var ^CTechTreeDef pxDef=GetTechTreeDef();
						if(pxDef!=null)then
							pxDef^.DisableFilter(CSandTrap.SAND_PATH);
							RemoveRangedBuff("slower_fighting_rate");
						endif;
					endif;
					if(bFight)then
						bClearWpnCache=true;
					endif;
				endif;
			endif;
			if(m_aiMirageFlags[iIndex]>0)then
				m_dwMirageFlags |= p_dwFlag;
				if(iIndex==2)then
//					AddRangedBuff("aschnabar");
				elseif(iIndex==4)then
					m_bDarkSwarm=true;
					AddRangedBuff("sandstorm");
				endif;
			else
				m_aiMirageFlags[iIndex]=0;
				m_dwMirageFlags &= ~p_dwFlag;
				if(iIndex==2)then
//					RemoveRangedBuff("aschnabar");
				elseif(iIndex==4)then
					m_bDarkSwarm=false;
					RemoveRangedBuff("sandstorm");
					if(m_xCurEnemy.IsValid()&&m_xCurEnemy.GetObj()!=null&&IsInFight())then
						Fight(m_xCurEnemy.GetObj(), m_xCurEnemy.GetObj()^.GetPos(), true, false);
					elseif(!(GetOwner()==-1&&IsWildAnimal()))then
						ExamineEnemies(true, true);
					endif;
				endif;
			endif;
		endif;
		if(iIndex==2||iIndex==5)then
			ForceBoniUpdate();
		endif;
		if(iIndex==12)then
			var bool bStart=false;
			var vec3 vP;
			if(HasWalkAction())then
				bStart=true;
				vP=GetCurWalkTarget();
			endif;
			UpdateSpeed();
			if(bStart)then
				WalkAction(vP,GetMaxSpeed());
			endif;
		endif;
		UpdateRangeNDamageInformation();
		AddTemporaryAttackBoni(GetDmg());
		AddTemporaryMeleeAttackBoni(GetDmg());
		AddTemporaryRangedAttackBoni(GetDmg());
		AddTemporaryDefenseBoni(GetProtection());
		AddTemporaryRangedDefenseBoni(GetRangedProtection());
		if(bClearWpnCache)then
			ClearDamageCache();
		endif;
		return true;
	endproc;
	
	///////
	//	GetMirageFlag()
	///////
	
	export proc bool GetMirageFlag(bitset p_dwFlag) //check if the unit holds the mark of a certain effect
		return ((m_dwMirageFlags & p_dwFlag)==p_dwFlag);
	endproc;
	
	export proc bool GetNoHealing()
		return m_bBloodInfect;
	endproc;
	
	//Kr1s1m: We wanted to have the functionality to disarm a fighting object, for example a tower, or unit, through a trigger
	export proc void RemoveAllWeapons(bool p_bEnable)
		//Kr1s1m: operation is reversible, trying to enable or disable twice in a row does nothing (on-off switch)
		if(p_bEnable == m_bWeaponRemoved)then return; endif;
		if(!p_bEnable)then //Kr1s1m: If we want to reverse the disarm effect...
			ForceGeneralUpdate(); //Kr1s1m: ...we restore all weapon data from TT and reload the caches and the weapon manager
	        //UpdateFightFactors();
		else //Kr1s1m: In case that we want to apply the disarm effect:
			//Kr1s1m: First we stop the attack animations
			ClearFightAnims();
			//Kr1s1m: Second, we set all weapon related fields to their null value
			begin ClearWeapons;
				SetProjectile("");
				SetProjectileGfx("");
				SetDmg(0.0f);
				SetMinDmg(0.0f);
				SetEndDmg(0.0f);
				SetProtection(0.0f);
				SetRangedProtection(0.0f);
				SetHitRange(0.0f);
				SetRealHitRange(0.0f);
				SetAttackRange(0.0f);
				SetWeaponDuration(0.0f);
				SetPenetrationAngle(0.0f);
				SetPenetrationFactor(0.0f);
				SetMinAttackRange(0.0f);
				SetRealMinAttackRange(0.0f);
				SetArmorPiercing(0.0f);
				SetPoisonDmg(0.0f);
				SetFireDmg(0.0f);
				SetPenetration(false);
				SetCanFightAir(false);
				SetPoisonMaxTickCount(0);
				SetBurnTime(0);
				SetWeaponSizeClass(0);
				m_pxWeaponMgr^.ClearAllWeapons();
				ClearWeaponCache();
				ClearDamageCache();
			end ClearWeapons;
			//Kr1s1m: Third, we erase the cleared weapon manager from the heap memory, and re-allocate it
			begin RestoreWeaponMgr;
				delete m_pxWeaponMgr;
				m_pxWeaponMgr = new CWeaponMgr(this);
			end RestoreWeaponMgr;
		endif;
		//Kr1s1m: Last, we raise up the necessary flags
		m_bWeaponHasChanged = true;
		m_bOwnWeaponHasChanged = true;
		m_bWeaponRemoved = p_bEnable;
	endproc;
	
	export proc void ForceGeneralUpdate()
		m_pxWeaponMgr^.UpdateAll();
		UpdateEquipment();
		UpdateWeaponBoni();
		ForceBoniUpdate();
		UpdateRangeNDamageInformation();
		AddTemporaryAttackBoni(GetDmg());
		AddTemporaryMeleeAttackBoni(GetDmg());
		AddTemporaryRangedAttackBoni(GetDmg());
		AddTemporaryDefenseBoni(GetProtection());
		AddTemporaryRangedDefenseBoni(GetRangedProtection());
	endproc;
	
	export proc real CalcMeleeAttackBoni(real p_fDamage)
		var real fValue=p_fDamage;
		fValue += GetBonusSum(BONUS_MELEEDAMAGE);
		return fValue;
	endproc
	
	export proc real AddTemporaryMeleeAttackBoni(real p_fDamage)
		var real fValue=CalcMeleeAttackBoni(p_fDamage);
		RemoveRangedBuff("more_melee_damage");
		RemoveRangedBuff("less_melee_damage");
		var real fBoniSum=fValue-p_fDamage;
		if(fBoniSum>0.0)then
			AddRangedBuff("more_melee_damage");
		elseif(fBoniSum<0.0)then
			AddRangedBuff("less_melee_damage");
		endif;
		return fValue;
	endproc;
	
	export proc real CalcRangeAttackBoni(real p_fDamage)
		var real fValue=p_fDamage;
		if(GetEffectFlag(EFFECT_NINIGI_CAULDRON))then
			fValue *= 1.25;
		endif;
		fValue += GetBonusSum(BONUS_RANGEDAMAGE);
		return fValue;
	endproc
	
	export proc real AddTemporaryRangedAttackBoni(real p_fDamage)
		var real fValue=CalcRangeAttackBoni(p_fDamage);
		RemoveRangedBuff("mehr_pfeiffen");
		RemoveRangedBuff("weniger_pfeiffen");
		var real fBoniSum=fValue-p_fDamage;
		if(fBoniSum>0.0)then
			AddRangedBuff("mehr_pfeiffen");
		elseif(fBoniSum<0.0)then
			AddRangedBuff("weniger_pfeiffen");
		endif;
		return fValue;
	endproc;
	
	//Henry: called from StartLocation.usl, ActionFactory.usl
	export proc void AcceptModification(string p_sType) //HACK to enable buying several types of aje units which can be converted into different modes (e.g. brachio, ankylo, stego)
		//Henry: old method, getting the filters from techtree. good because it doesn't need to be updated separately. but if the corresponding techtree nodes gets invisible (like brach catapult antiaction filter is enabled) it becomes unusable
		/*
		m_xTechTree=GetTechTree();
		var string sStartTT=m_xTechTree.GetValueS(GetObjPath()+"/StartTT"+p_sType,"");
		var ^CTechTreeDef pxDef=GetTechTreeDef();
		if(!sStartTT.IsEmpty()&&pxDef!=null)then
			var string sAction=sStartTT;
			var ^CTechTree.CNode pxResult=m_xTechTree.FindNode(sStartTT+"/results");
			if(pxResult!=null)then
				var int i, iC=pxResult^.NumSubs();
				for(i=0)cond(i<iC)iter(i++)do
					var string sClass=pxResult^.GetSub(i)^.GetSubValue("class");
					var bool bActivate=pxResult^.GetSub(i)^.GetSubValue("type")=="activate";
					var ^CTechTreeDef pxTechTreeDef;
					if(sClass=="local")then
						pxTechTreeDef=GetTechTreeDef();
					else
						var ^CPlayer pxPlayer=CSrvWrap.GetCurLevel()^.GetPlayer(GetOwner());
						pxTechTreeDef=^(pxPlayer^.GetPlayerTechTreeDef());
					endif;
					if(bActivate)then
						pxTechTreeDef^.EnableFilter(pxResult^.GetSub(i)^.GetValue());
					else
						pxTechTreeDef^.DisableFilter(pxResult^.GetSub(i)^.GetValue());
					endif;
				endfor;
			endif;
		endif;
		*/
		var array string asPaths, asTypes;
		CMirageSrvMgr.RetrieveFilters(GetClassName(), p_sType, asPaths, asTypes);
		var int i, iC=Math.Min(asPaths.NumEntries(), asTypes.NumEntries()); // Henry fool proof...
		if(iC<1)then return; endif;
		var ^CTechTreeDef pxTechTreeDef=GetTechTreeDef();;
		for(i=0)cond(i<iC)iter(i++)do
			if(asTypes[i]=="activate")then
				pxTechTreeDef^.EnableFilter(asPaths[i]);
			else
				pxTechTreeDef^.DisableFilter(asPaths[i]);
			endif;
		endfor;
	endproc;
	
	export proc void ResetToStandard(string p_sPath)
		m_xTechTree=GetTechTree();
		var ^CTechTreeDef pxDef=GetTechTreeDef();
		if(!p_sPath.IsEmpty()&&pxDef!=null)then
			var string sAction=p_sPath;
			var ^CTechTree.CNode pxResult=m_xTechTree.FindNode(p_sPath+"/results");
			if(pxResult!=null)then
				var int i, iC=pxResult^.NumSubs();
				for(i=0)cond(i<iC)iter(i++)do
					var string sClass=pxResult^.GetSub(i)^.GetSubValue("class");
					var bool bActivate=pxResult^.GetSub(i)^.GetSubValue("type")=="activate";
					var ^CTechTreeDef pxTechTreeDef;
					if(sClass=="local")then
						pxTechTreeDef=GetTechTreeDef();
					else
						var ^CPlayer pxPlayer=CSrvWrap.GetCurLevel()^.GetPlayer(GetOwner());
						pxTechTreeDef=^(pxPlayer^.GetPlayerTechTreeDef());
					endif;
					if(bActivate)then
						pxTechTreeDef^.EnableFilter(pxResult^.GetSub(i)^.GetValue());
					else
						pxTechTreeDef^.DisableFilter(pxResult^.GetSub(i)^.GetValue());
					endif;
				endfor;
			endif;
		endif;
	endproc;
	
	export proc void AddFlyingHeight(vec3 p_vPos, real p_fSpeed)
		return;
	endproc;
	
	export proc void PutIntoPlace(vec3 p_vPos)
		SetPos(p_vPos);
		return;
	endproc;
	
	///////
	//	Energy Staff
	///////
	export proc void DecraseHP(real p_fHitpoints) //decrease hp by a certain amount
		m_fHitpoints -= p_fHitpoints;
		UpdateHitpoints();
	endproc;
	
	export proc real GetEnergy() //calls the current amount of mana
		return m_fEnergyState;
	endproc;
	
	export proc real GetMaxEnergy() //calls the maximal amount of mana
		return m_fMaxEnergy;
	endproc;
	
	export proc real GetReplenishAmount() //calls the value to automatic mana reproducing
		return m_fReplenishAmount;
	endproc;
	
	export proc real GetReplenishTime() //calls the time intervall between each automatic mana reproduction
		return m_fReplenishTime;
	endproc;
	
	proc void SetMaxEnergy(real p_fMaxEnergy) //set the maximal amount of mana a unit can have
		if(!GetManaUser())then return; endif;
		m_fMaxEnergy=p_fMaxEnergy;
		UpdateEnergy();
	endproc;
	
	proc void SetMaxEnergyOnInit(real p_fMaxEnergy) //set maximal mana a unit can have at OnInit...
		if(!GetManaUser())then return; endif;
		m_fMaxEnergy=p_fMaxEnergy;
	endproc;
	
	export proc void SetEnergy(real p_fEnergy) //set the units mana amount
		if(m_fEnergyState!=p_fEnergy)then
			m_fEnergyState=p_fEnergy;
			UpdateEnergy();
		endif;
	endproc;
	
	export proc void SetEnergyOnInit(real p_fEnergy) //set the units mana amount at OnInit
		m_fEnergyState=p_fEnergy;
	endproc;
	
	///////
	//	ChangeMaxEnergy()
	///////
	export proc void ChangeMaxEnergy(real p_fNewMax)
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel==null||pxLevel^.IsEditable())then
			return;
		endif;
		if(!GetManaUser())then return; endif;
		m_fMaxEnergy=p_fNewMax+GetBonusSum(BONUS_MAXENERGY);
		UpdateEnergy();
	endproc;
	
	///////
	//	AddEnergy()
	///////
	export proc void AddEnergy(real p_fAdd)
		m_fEnergyState=Math.Clamp((m_fEnergyState+p_fAdd),0.0,m_fMaxEnergy);
		UpdateEnergy();
	endproc;
	
	///////
	//	IncreaseEnergy()
	///////
	export proc void IncreaseEnergy(real p_fIncr)
		if(m_fEnergyState<m_fMaxEnergy)then
			if(!((m_fEnergyState+p_fIncr)>m_fMaxEnergy))then
				m_fEnergyState += p_fIncr;
			else
				m_fEnergyState=m_fMaxEnergy;
			endif;
		endif;
		UpdateEnergy();
	endproc;
	
	///////
	//	DecreaseEnergy()
	///////
	export proc void DecreaseEnergy(real p_fIncr)
		if(m_fEnergyState>0.0)then
			if(!((m_fEnergyState - p_fIncr)<0.0))then
				m_fEnergyState -= p_fIncr;
			else
				m_fEnergyState=0.0;
			endif;
		endif;
		UpdateEnergy();
	endproc;
	
	///////
	//	ChangeReplenishAmount()
	///////
	export proc void ChangeReplenishAmount(real p_fNewAmount)
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel==null||pxLevel^.IsEditable())then
			return;
		endif;
		m_fReplenishAmount=p_fNewAmount;
		UpdateEnergy();
	endproc;
	
	///////
	//	ChangeReplenishTime()
	///////
	export proc void ChangeReplenishTime(real p_fNewTime)
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel==null||pxLevel^.IsEditable())then
			return;
		endif;
		m_fReplenishTime=p_fNewTime;
		UpdateEnergy();
	endproc;
	
	export proc bool CheckMana(string p_sTTPath) //Check if a spellcaster has enough mana to do a certain action, if yes returns true
		if(!m_bManaEnabled)then
			return true;
		endif;
		var real fMana=m_xTechTree.GetValueR(p_sTTPath+"/manacosts",0.0);
		if(fMana<=0.0)then return true; endif;
		//if(m_fMaxEnergy<=0.0)then return false; endif;
		if(fMana>m_fEnergyState)then return false; endif;
		return true;
	endproc;
	
	export proc bool CheckManaAndPay(string p_sTTPath) //Check if a spellcaster has enough mana to do a certain action, if yes, then decrases his curent mana, and returns true
		if(!m_bManaEnabled)then
			return true;
		endif;
		var real fMana=m_xTechTree.GetValueR(p_sTTPath+"/manacosts",0.0);
		if(fMana<=0.0)then return true; endif;
		//if(m_fMaxEnergy<=0.0)then return false; endif;
		if(fMana>m_fEnergyState)then return false; endif;
		if(fMana>0.0)then
			m_fEnergyState -=fMana;
			UpdateEnergy();
		endif;
		return true;
	endproc;
	
	export proc void PayBackMana(string p_sTTPath) //restores the subtracted mana for the spellcaster if the action has been broken (mainly used at Resurrection)
		if(m_fMaxEnergy<=0.0)then return; endif;
		var real fMana=m_xTechTree.GetValueR(p_sTTPath+"/manacosts",0.0);
		if(fMana>0.0)then
			AddEnergy(fMana);
		endif;
	endproc;
	
	proc void SetReplenishAmount(real p_fReplenishAmount) //set the amount which by the mana of spellcasters should be restored via the automata mana reproduction
		if(m_fReplenishAmount!=p_fReplenishAmount)then
			m_fReplenishAmount=p_fReplenishAmount;
		endif;
		UpdateEnergy();
	endproc;
	
	proc void SetReplenishAmountOnInit(real p_fReplenishAmount) //set the amount which by the mana of spellcasters should be restored via the automatic mana reproduction at OnInit
		m_fReplenishAmount=p_fReplenishAmount;
	endproc;
	
	proc void SetReplenishTime(real p_fReplenishTime) //set the time interwall between each automata call of mana automatic reproduction
		if(m_fReplenishTime!=p_fReplenishTime)then
			m_fReplenishTime=p_fReplenishTime;
		endif;
		UpdateEnergy();
	endproc;
	
	proc void SetReplenishTimeOnInit(real p_fReplenishTime) //set the time interwall between each automata call of mana automatic reproduction at OnInit
		m_fReplenishTime=p_fReplenishTime;
	endproc;
	
	export proc void CureMe(real p_fAddHitpoints)
		//AddRangedBuff("is_getting_healed");
		if(m_bBloodInfect)then return; endif;
		if((GetHitpoints()+p_fAddHitpoints) > GetMaxHitpoints())then
			SetHitpoints(GetMaxHitpoints());
			return;
		endif;
		SetHitpoints((GetHitpoints()+p_fAddHitpoints));
	endproc;
	
	export proc void RegenMe(real p_fAddHitpoints)
		if(GetMaxHitpoints()<=GetHitpoints())then return; endif;
		AddRangedBuff("is_getting_healed");
		DeleteTimer(TIMER_ISGETTINGREGENED);
		CreateTimer(TIMER_ISGETTINGREGENED,CGameTimeSpan.OneSecond() * 2.5, false);
		if((GetHitpoints()+p_fAddHitpoints) > GetMaxHitpoints())then
			SetHitpoints(GetMaxHitpoints());
			return;
		endif;
		SetHitpoints((GetHitpoints()+p_fAddHitpoints));
	endproc;
	
	export proc void FullReplenish()
		SetEnergy(GetMaxEnergy());
	endproc;
	
	export proc void FeedBack(int p_iDmgDealer)
		if(GetInvulnerable()<=0&&!GetLDInvulnerable())then
			var real fFeedback=m_fEnergyState;
			SetEnergy(0.0);
			m_iLastDamage=p_iDmgDealer;
			Damage(fFeedback);
		endif;
	endproc;
	
	proc void EMP()
		if(m_fMaxEnergy>0.0)then
			SetEnergy(0.0);
		endif;
	endproc;
	
	export proc void AddMana(real p_fAddManaPoints)
		if((GetEnergy()+p_fAddManaPoints) > GetMaxEnergy())then
			SetEnergy(GetMaxEnergy());
			return;
		endif;
		SetEnergy((GetEnergy()+p_fAddManaPoints));
	endproc;
	
	export proc void SeasWellHeal(^CGameObj p_pxO, bool p_bQ)
		if(p_pxO!=null)then
			//Henry: do not try to wellheal flying units ;)
			if(IsJetPackOn()||m_bFlyingUnit)then
//			if(IsFlyingUnit())then
				GoTo(p_pxO^.GetPos(), true, GetDefaultSpeed(), true, true, GetOnWall(), false, true);
				return;
			endif;
			if(m_bBloodInfect)then return; endif;
			var ^CSeasWellHeal pxTask =cast<CSeasWellHeal>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"SWHeal"));
			if(pxTask!=null)then
				var bool bR=pxTask^.Init(GetHandle(), p_pxO^.GetHandle());
				if(bR)then
					pxTask^.SetUserCommand(true);
					AddTask(pxTask, p_bQ);
				else
					pxTask^.GetFactory()^.FreeState(pxTask);
				endif;
			endif;
		endif;
	endproc;
	
	export proc void SetIncapacitated(real p_fDuration)
		if(m_bSlaveInvincible)then return; endif;
		if(HasTimer(TIMER_INCAPACITATED))then DeleteTimer(TIMER_INCAPACITATED); endif;
		SetIncapacitated(true);
//		m_bIncapacitated=true;
		CreateTimer(TIMER_INCAPACITATED, CGameTimeSpan.OneSecond() * p_fDuration, false);
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("InCapacitated",m_bIncapacitated);
		endif;
		AddRangedBuff("is_held");
		var CObjHndl xHndl=AddFX("building_incapacitation_fx",-1.0);
		if(xHndl.IsValid())then
			var CFourCC xLink="NOPE";
			xHndl.GetObj()^.LinkAction(GetHandle(),xLink);
		endif;
	endproc;
	
	export proc bool GetIncapacitated()
		return m_bIncapacitated;
	endproc;
	
	export proc void SetIncapacitated(bool p_bYes)
		m_bIncapacitated=p_bYes;
		CheckFighterValidity();
	endproc;
	
	//========================================================================================
	//===Flying Units and etc=================================================================
	//========================================================================================
	
	export proc void SetCanFightAir(bool p_bAirWeapon)
		m_bAirWeapon=p_bAirWeapon;
	endproc;
	
	export proc bool CanShootAir()
		return m_bAirWeapon;
	endproc;
	
	export proc bool HasBuildUpAirWeapons()
		return m_bBUAirAttack;
	endproc;
	
	export proc void SetBuildUpAirWeapons(bool p_bOn)
		m_bBUAirAttack=p_bOn;
	endproc;
	
	export proc void SetTBUAW(bool p_bOn)
	endproc;
	
	export proc bool IsFlyingUnit()
		return m_bFlyingUnit;
	endproc;
	
	//========================================================================================
	//===End of flying======================================================================
	//========================================================================================
	
	//========================================================================================
	//===BuildUpWeaponStuff===================================================================
	//========================================================================================
	
	export proc real GetBUDmg()
		return m_fBUDamage;
	endproc;
	
	export proc real GetBUEndDmg()
		return m_fBUEndDamage;
	endproc;
	
	export proc ref real GetBUPoisonDmg()
		return m_fBUPoisonDmg;
	endproc;
	
	export proc ref int GetBUPoisonMaxTickCount()
		return m_iBUPoisonMaxTickCount;
	endproc;
	
	export proc bool CanBUShootAir()
		return m_bBUAirWeapon;
	endproc;
	
	export proc ref string GetBUProjectile()
		return m_sBUProjectile;
	endproc;
	
	export proc ref real GetBUArmorPiercing()
		return m_fBUArmorPiercing;
	endproc;
	
	export proc ref real GetBUFireDmg()
		return m_fBUFireDmg;
	endproc;
	
	export proc ref int GetBUBurnTime()
		return m_iBUBurnTime;
	endproc;
	
	export proc ref CBonus GetBUAttackBoni()
		return m_xBUAttackBoni;
	endproc;
	
	export proc void UpdateBUWeapons(real p_fDmg, real p_fEndDmg, real p_fAP, string p_sProj, real p_fPD, int p_iPTC, real p_fFD, int p_iBTC, bool p_bAW)
		m_fBUDamage=p_fDmg;
		m_fBUEndDamage=p_fEndDmg;
		m_sBUProjectile=p_sProj;
		m_fBUArmorPiercing=p_fAP;
		m_fBUPoisonDmg=p_fPD;
		m_iBUPoisonMaxTickCount=p_iPTC;
		m_fBUFireDmg=p_fFD;
		m_iBUBurnTime=p_iBTC;
		m_bBUAirWeapon=p_bAW;
	endproc;
	
	export proc void SetBUProjectile(string p_sArrow)
		m_sBUProjectile=p_sArrow;
	endproc;
	
	export proc void SetBUArmorPiercing(real p_fValue)
		m_fBUArmorPiercing=p_fValue;
	endproc;
	
	export proc void SetBUShootAir(bool p_bYes)
		m_bBUAirWeapon=p_bYes;
	endproc;
	
	export proc void SetBUPoisonDmg(real p_fDmg)
		m_fBUPoisonDmg=p_fDmg;
	endproc;
	
	export proc void SetBUPoisonMaxTickCount(int p_iTickCount)
		m_iBUPoisonMaxTickCount=p_iTickCount;
	endproc;
	
	export proc void SetBUFireDmg(real p_fDmg)
		m_fBUFireDmg=p_fDmg;
	endproc;
	
	export proc void SetBUBurnTime(int p_iBurningCount)
		m_iBUBurnTime=p_iBurningCount;
	endproc;
	
	export proc void UpdateBUWeaponBoni(string p_sNode)
		m_xBUAttackBoni.Clear();
		AddBoni(p_sNode+"/AttackBonus",m_xBUAttackBoni);
	endproc;
	
	//========================================================================================
	//===Expanding and Balancing freezing ability===========================================
	//========================================================================================
	
	export proc void All4One()  //set freezing attribs, etc ;D
		SetIceImmunity();
		SetPoisonImmunity();
		SetImmunityTime();
		SetIceAge();
		SetMeltdownTime();
		CheckAirTicket();
		CheckBiological();
		CheckMeleePenetrate();
		CheckHealingBoni();
		CheckWildAnimal();
	endproc;
	
	export proc void SetIceImmunity()		//set the time immunity attrib, if true, unit can't be freezed
		var bool bIceImmunity;
		var string sIceImmunity=m_xTechTree.GetValueS(GetObjPath()+"/ice_immunity","false");
		if(sIceImmunity=="false")then
			bIceImmunity=false;
		elseif(sIceImmunity=="true")then
			bIceImmunity=true;
		else
			bIceImmunity=false;
		endif;
		m_bIceImmunity=bIceImmunity;
	endproc;
	
//Henry: to get poison immunity from tt
	export proc void SetPoisonImmunity()		//set the time poison-immunity attrib, if true, unit can't be poisoned, even if its classtype should be (ANML or CHTR)
		var bool bPoisonImmunity;
		var string sPoisonImmunity=m_xTechTree.GetValueS(GetObjPath()+"/poison_immunity","false");
		if(sPoisonImmunity=="false")then
			bPoisonImmunity=false;
		elseif(sPoisonImmunity=="true")then
			bPoisonImmunity=true;
		else
			bPoisonImmunity=false;
		endif;
		m_bPoisonImmunity=bPoisonImmunity;
	endproc;
	
	export proc bool IsPoisonImmun()
		return m_bPoisonImmunity;
	endproc;
	
//Henry: to get flying attrib from tt
	export proc void CheckAirTicket()
		var bool bFlyingUnit;
		var string sFlyingUnit=m_xTechTree.GetValueS(GetObjPath()+"/flying_unit","false");
		if(sFlyingUnit=="false")then
			bFlyingUnit=false;
		elseif(sFlyingUnit=="true")then
			bFlyingUnit=true;
		else
			bFlyingUnit=false;
		endif;
		if(m_bFlyingUnit==bFlyingUnit)then return; endif;
		m_bFlyingUnit=bFlyingUnit;
		var ^CAttribs pxA=GetAttribs();
		if(pxA!=null)then
			pxA^.SetValue("flying_unit", m_bFlyingUnit);
		endif;
	endproc;
	
//Henry: to check if its a biological unit (like muraeno ships)
	export proc void CheckBiological()
		m_bBiological=GetType()=="ANML"||GetType()=="CHTR"||m_xTechTree.GetValueR(GetObjPath()+"/spirit_life",0.0f)>0.0f;
	endproc;
	
//Henry: to check if its doing aoe damage in close combat with its own body (dr brach for example)
	export proc void CheckMeleePenetrate()
		m_bMeleePenetrate=m_xTechTree.GetValueI(GetObjPath()+"/melee_penetrate",0)==1;
	endproc;
	
	export proc void SetImmunityTime() //set the time of ice-immunity, this time long the unit can't be freezed (only if enemy hasn't unlimited freezing...)
		var real fImmunityTime;
		if(GetOwner()==-1)then
			fImmunityTime=m_xTechTree.GetValueR(GetObjPath()+"/immunity_time",8.0);
		else
			fImmunityTime=m_xTechTree.GetValueR(GetObjPath()+"/immunity_time",10.0);
		endif;
		if(Math.Ceil(fImmunityTime).ToInt()<0)then
			fImmunityTime=0.0f;
		endif;
		m_fImmunityTime=fImmunityTime;
	endproc;
	
	export proc void SetIceAge()		//set the the time of freezing duration, how long an enemy unit will be freezed after an attack (if its 0, then unit can't freeze enemy)
		var real fFreezingTime=m_xTechTree.GetValueR(GetObjPath()+"/freezing_time",2.5);
		if(Math.Ceil(fFreezingTime).ToInt()<0)then
			fFreezingTime=0.0f;
		endif;
		m_fFreezingTime=fFreezingTime;
	endproc;
	
	export proc void SetMeltdownTime()		//set the the time of iced time, after this ice-immunity starts (if its 0, then freezing is unlimited...)
		var real fIceTimeOut=m_xTechTree.GetValueR(GetObjPath()+"/ice_timeout",10.0);
		if(Math.Ceil(fIceTimeOut).ToInt()<0)then
			fIceTimeOut=0.0f;
		endif;
		m_fIceTimeOut=fIceTimeOut;
	endproc;
	
	export proc bool IsIceImmun()
		return m_bIceImmunity;
	endproc;
	
	export proc real GetImmunityTime()
		return m_fImmunityTime;
	endproc;
	
	export proc real GetGlacialEpoch()
		return m_fFreezingTime;
	endproc;
	
	export proc real GetIceMelting()
		return m_fIceTimeOut;
	endproc;
	
	export proc void StartIceImmunity() //this starts the ice-immunity period (unit can't be freezed in this timeperiod)
		var real fImmunityTime=GetImmunityTime();
		if(fImmunityTime==0.0)then return; endif;
		CreateTimer(TIMER_FROSTIMMUNITY,CGameTimeSpan.OneSecond()*fImmunityTime, false);
		SetIcedFlag(false);
		SetFroozenEffect(false);
	endproc;
	
	//========================================================================================
	//===End of Balancing freezing ability==================================================
	//========================================================================================
	
	export proc real GetGrowUpValue()
		return 1.0;
	endproc;
	
	export proc void GrowUp()
		UpdateRangeNDamageInformation();
	endproc;
	
	export proc int GetSupplyCount() //calls the unit supply capacity
		return m_iSupplyCount;
	endproc;
	
	export proc void SetSupplyCount(int p_iNewSCount) //not used but this could change the supply value of a unit (don't use this without a procedure, which changes the players population)
		m_iSupplyCount=p_iNewSCount;
	endproc;
	
	export proc int GetKillerCount() //calls the number of killed enemies by this unit
		return m_iKillerCount;
	endproc;
	
	export proc int GetKillerHistory() //returns the number of kills before resurrection(s)
		return m_iKillerHistory;
	endproc;
	
	export proc void AddKillerCount(int p_iAdd) //add to the killer count of a unit, if it was the killed units last enemy (option to increase the count more than one...)
		m_iKillerCount += p_iAdd;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("killercount",m_iKillerCount);
//			pxAttr^.SetValue("skulls",GetScalpValue());
			if(CMirageSrvMgr.Get().BonusSkulls())then
				pxAttr^.SetValue("TmpSkullsBoni",Math.Max(m_iKillerCount-m_iKillerHistory,0));
			endif;
		endif;
		if(GetOwner()==-1)then
			if(IsWildAnimal()&&GetLevel()<4)then
				if(m_iKillerCount>125)then
					SetLevelClean(4);
				elseif(m_iKillerCount>85)then
					SetLevelClean(3);
				elseif(m_iKillerCount>50)then
					SetLevelClean(2);
				elseif(m_iKillerCount>20)then
					SetLevelClean(1);
				endif;
			endif;
		endif;
/*
		ForceBoniUpdate();
		UpdateWeaponBoni();
		UpdateRangeNDamageInformation();
		AddTemporaryAttackBoni(GetDmg());
		AddTemporaryMeleeAttackBoni(GetDmg());
		AddTemporaryRangedAttackBoni(GetDmg());
		AddTemporaryDefenseBoni(GetProtection());
		AddTemporaryRangedDefenseBoni(GetRangedProtection());
*/
	endproc;
	
	export proc void SetKillerCount(int p_iNewKCount) //to set killercount freely
		m_iKillerCount=p_iNewKCount;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("killercount",p_iNewKCount);
			if(CMirageSrvMgr.Get().BonusSkulls())then
				pxAttr^.SetValue("TmpSkullsBoni",Math.Max(m_iKillerCount-m_iKillerHistory,0));
			endif;
		endif;
	endproc;
	
	export proc void SetKillerHistory(int p_iNKH)
		m_iKillerHistory=p_iNKH;
		if(CMirageSrvMgr.Get().BonusSkulls())then
			var ^CAttribs pxAttr=GetAttribs();
			if(pxAttr!=null)then
				pxAttr^.SetValue("TmpSkullsBoni",Math.Max(m_iKillerCount-m_iKillerHistory,0));
			endif;
		endif;
	endproc;
	
	export proc void SetKillerNumbers(int p_iNKC,int p_iNKH)
		m_iKillerCount=p_iNKC;
		m_iKillerHistory=p_iNKH;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("killercount",p_iNKC);
			if(CMirageSrvMgr.Get().BonusSkulls())then
				pxAttr^.SetValue("TmpSkullsBoni",Math.Max(m_iKillerCount-m_iKillerHistory,0));
			endif;
		endif;
	endproc;
	
	///////
	//	UpdateMana
	///////
	export proc void UpdateEnergy()
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("energystate",m_fEnergyState);
			pxAttr^.SetValue("maxenergyamount",m_fMaxEnergy);
			pxAttr^.SetValue("replenishamount",m_fReplenishAmount);
			pxAttr^.SetValue("replenishtime",m_fReplenishTime);
		endif;
		if(m_fMaxEnergy>0.0)then
//			SetReplenishTime(GetTechTreeReplenishTime());
			pxAttr^.SetValue("replenishtime",m_fReplenishTime);
			if(HasTimer(REPLENISH_TIMER))then
				StopReplenishTimer();
			endif;
			if(m_fEnergyState!=m_fMaxEnergy)then
				StartReplenishTimer();
			else
				StopReplenishTimer();
			endif;
		else
			StopReplenishTimer();
		endif;
	endproc;
	
	///////
	//	GetTechTreeMaximumEnergy()
	///////
	
	export proc real GetTechTreeMaxEnergy()
		var string sObjPath=GetObjPath();
		var real fMaxEnergy=m_xTechTree.GetValueR(sObjPath+"/max_energy",0.0);
		fMaxEnergy *= GetTechTreeModifier("MaxEnergy",true);
		fMaxEnergy += GetTechTreeModifier("MaxEnergy",false);
		fMaxEnergy *= GetClassTechTreeModifier("MaxEnergy",true);
		fMaxEnergy += GetClassTechTreeModifier("MaxEnergy",false);
		return fMaxEnergy;
	endproc;
	
	export proc real GetTechTreeMaxEnergyOnInit()
		var string sObjPath;
		var string sTribe=GetPlayerTribeName();
		if(sTribe.IsEmpty())then return 100.0f; endif;
		var CTechTree xTechTree=GetTechTree();
		var string sClassName=GetClassName();
		var ^CTechTree.CNode pxObjNode=xTechTree.FindNode("Objects/"+sTribe+"/"+GetType().AsString()+"/"+sClassName);
		if(pxObjNode==null)then
			var ^CTechTree.CNode pxTribeNode=xTechTree.FindNode("Objects/"+sTribe);
			if(pxTribeNode==null)then return 100.0f; endif;
			pxObjNode=pxTribeNode^.FindNodeRecursiveByName(sClassName);
		endif;
		if(pxObjNode==null)then return 100.0f; endif;
		sObjPath=pxObjNode^.GetAbsPath();
		var real fMaxEnergy=xTechTree.GetValueR(sObjPath+"/max_energy",0.0);
		fMaxEnergy *= GetTechTreeModifier("MaxEnergy",true);
		fMaxEnergy += GetTechTreeModifier("MaxEnergy",false);
		fMaxEnergy *= GetClassTechTreeModifier("MaxEnergy",true);
		fMaxEnergy += GetClassTechTreeModifier("MaxEnergy",false);
		return fMaxEnergy;
	endproc;
	
	///////
	//	GetTechTreeStartingEnergy()
	///////
	
	export proc real GetTechTreeStartingEnergy()
		var string sObjPath=GetObjPath();
		var real fStartEnergy=m_xTechTree.GetValueR(sObjPath+"/starting_energy",0.0);
		fStartEnergy *= GetTechTreeModifier("StartEnergy",true);
		fStartEnergy += GetTechTreeModifier("StartEnergy",false);
		fStartEnergy *= GetClassTechTreeModifier("StartEnergy",true);
		fStartEnergy += GetClassTechTreeModifier("StartEnergy",false);
		return fStartEnergy;
	endproc;
	
	export proc real GetTechTreeStartingEnergyOnInit()
		var string sObjPath;
		var string sTribe=GetPlayerTribeName();
		if(sTribe.IsEmpty())then return 15.0f; endif;
		var CTechTree xTechTree=GetTechTree();
		var string sClassName=GetClassName();
		var ^CTechTree.CNode pxObjNode=xTechTree.FindNode("Objects/"+sTribe+"/"+GetType().AsString()+"/"+sClassName);
		if(pxObjNode==null)then
			var ^CTechTree.CNode pxTribeNode=xTechTree.FindNode("Objects/"+sTribe);
			if(pxTribeNode==null)then return 16.0f; endif;
			pxObjNode=pxTribeNode^.FindNodeRecursiveByName(sClassName);
		endif;
		if(pxObjNode==null)then return 17.0f; endif;
		sObjPath=pxObjNode^.GetAbsPath();
		var real fStartEnergy=xTechTree.GetValueR(sObjPath+"/starting_energy",8.0);
		fStartEnergy *= GetTechTreeModifier("StartEnergy",true);
		fStartEnergy += GetTechTreeModifier("StartEnergy",false);
		fStartEnergy *= GetClassTechTreeModifier("StartEnergy",true);
		fStartEnergy += GetClassTechTreeModifier("StartEnergy",false);
		return fStartEnergy;
	endproc;
	
	///////
	//	GetTechTreeReplenishAmount()
	///////
	
	export proc real GetTechTreeReplenishAmount()
		var string sObjPath=GetObjPath();
		var real fReplenishAmount=m_xTechTree.GetValueR(sObjPath+"/replenish_step",0.0);
		fReplenishAmount *= GetTechTreeModifier("ReplenishAmount",true);
		fReplenishAmount += GetTechTreeModifier("ReplenishAmount",false);
		fReplenishAmount *= GetClassTechTreeModifier("ReplenishAmount",true);
		fReplenishAmount += GetClassTechTreeModifier("ReplenishAmount",false);
		return fReplenishAmount;
	endproc;
	
	export proc real GetTechTreeReplenishAmountOnInit()
		var string sObjPath;
		var string sTribe=GetPlayerTribeName();
		if(sTribe.IsEmpty())then return 7.0f; endif;
		var CTechTree xTechTree=GetTechTree();
		var string sClassName=GetClassName();
		var ^CTechTree.CNode pxObjNode=xTechTree.FindNode("Objects/"+sTribe+"/"+GetType().AsString()+"/"+sClassName);
		if(pxObjNode==null)then
			var ^CTechTree.CNode pxTribeNode=xTechTree.FindNode("Objects/"+sTribe);
			if(pxTribeNode==null)then return 7.0f; endif;
			pxObjNode=pxTribeNode^.FindNodeRecursiveByName(sClassName);
		endif;
		if(pxObjNode==null)then return 7.0f; endif;
		sObjPath=pxObjNode^.GetAbsPath();
		var real fReplenishAmount=xTechTree.GetValueR(sObjPath+"/replenish_step",7.0);
		fReplenishAmount *= GetTechTreeModifier("ReplenishAmount",true);
		fReplenishAmount += GetTechTreeModifier("ReplenishAmount",false);
		fReplenishAmount *= GetClassTechTreeModifier("ReplenishAmount",true);
		fReplenishAmount += GetClassTechTreeModifier("ReplenishAmount",false);
		return fReplenishAmount;
	endproc;
	
	///////
	//	GetTechTreeReplenishTime()
	///////
	
	export proc real GetTechTreeReplenishTime()
		var string sObjPath=GetObjPath();
		var real fReplenishTime=m_xTechTree.GetValueR(sObjPath+"/replenish_time",20.0);
		fReplenishTime *= GetTechTreeModifier("ReplenishTime",true);
		fReplenishTime += GetTechTreeModifier("ReplenishTime",false);
		fReplenishTime *= GetClassTechTreeModifier("ReplenishTime",true);
		fReplenishTime += GetClassTechTreeModifier("ReplenishTime",false);
		return fReplenishTime;
	endproc;
	
	export proc real GetTechTreeReplenishTimeOnInit()
		var string sObjPath;
		var string sTribe=GetPlayerTribeName();
		if(sTribe.IsEmpty())then return 20.0f; endif;
		var CTechTree xTechTree=GetTechTree();
		var string sClassName=GetClassName();
		var ^CTechTree.CNode pxObjNode=xTechTree.FindNode("Objects/"+sTribe+"/"+GetType().AsString()+"/"+sClassName);
		if(pxObjNode==null)then
			var ^CTechTree.CNode pxTribeNode=xTechTree.FindNode("Objects/"+sTribe);
			if(pxTribeNode==null)then return 20.0f; endif;
			pxObjNode=pxTribeNode^.FindNodeRecursiveByName(sClassName);
		endif;
		if(pxObjNode==null)then return 20.0f; endif;
		sObjPath=pxObjNode^.GetAbsPath();
		var real fReplenishTime=xTechTree.GetValueR(sObjPath+"/replenish_time",20.0);
		fReplenishTime *= GetTechTreeModifier("ReplenishTime",true);
		fReplenishTime += GetTechTreeModifier("ReplenishTime",false);
		fReplenishTime *= GetClassTechTreeModifier("ReplenishTime",true);
		fReplenishTime += GetClassTechTreeModifier("ReplenishTime",false);
		return fReplenishTime;
	endproc;
	
	export proc bool StartReplenishTimer()
		if(!GetManaUser())then return false; endif;
		if(HasTimer(REPLENISH_TIMER))then return false; endif;
		if(m_fMaxEnergy<=0.0)then return false; endif;
		m_xLastReplenishTick=CTimeMgr.Get().GetTime();
		CreateTimer(REPLENISH_TIMER, CGameTimeSpan.OneSecond()*m_fReplenishTime, false);
		return true;
	endproc;
	
	export proc void StopReplenishTimer()
		if(!HasTimer(REPLENISH_TIMER))then return; endif;
		DeleteTimer(REPLENISH_TIMER);
	endproc;
	
	proc void Replenish(real p_fEnergyAmount)
		IncreaseEnergy(p_fEnergyAmount);
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("energystate",m_fEnergyState.ToInt().ToReal());
		endif;
	endproc;
	
	export proc void StartManaEating()
		if(!m_bManaEnabled)then return; endif;
		if(HasTimer(REPLENISH_TIMER))then StopReplenishTimer(); endif;
	endproc;
	
	export proc void StopManaEating()
		if(!m_bManaEnabled)then return; endif;
		UpdateEnergy();
	endproc;
	
	export proc void EatMana(real p_fEnergyAmount)
		if(!m_bManaEnabled)then return; endif;
		if(!GetManaUser())then return; endif;
		DecreaseEnergy(p_fEnergyAmount);
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("energystate",m_fEnergyState.ToInt().ToReal());
		endif;
	endproc;
	
	export proc real DrainEnergy(real p_fEnergy)
		var real fResult=0.0f;
		if(!GetManaUser())then return fResult; endif;
		if(!m_bManaEnabled)then return fResult; endif;
		if(m_fEnergyState > 0.0f&&m_fMaxEnergy > 0.0f)then
			if(!((m_fEnergyState - p_fEnergy)<=0.0f))then
				m_fEnergyState -= p_fEnergy;
				fResult=p_fEnergy;
			else
				fResult=m_fEnergyState;
				m_fEnergyState=0.0;
			endif;
			UpdateEnergy();
		endif;
		return fResult;
	endproc;
	
	///////
	//	Initialize Mana System
	///////
	
	export proc void SetMana()
		SetReplenishTime(GetTechTreeReplenishTime());
		SetReplenishAmount(GetTechTreeReplenishAmount());
		SetMaxEnergy(GetTechTreeMaxEnergy());
	endproc;
	
	export proc void SetManaOnInit()
		SetReplenishTimeOnInit(GetTechTreeReplenishTimeOnInit());
//		SetReplenishAmountOnInit(GetTechTreeReplenishAmountOnInit());
//		SetMaxEnergyOnInit(GetTechTreeMaxEnergyOnInit());
		SetEnergyOnInit(GetTechTreeStartingEnergyOnInit());
	endproc;
	
	export proc real GetManaRadius() //get users mana aura radius; used by (Tarna and) manatemple buildings (see magiccauldron)
		var ^CFightingObj.CSpecialAbility pxA=m_xAbilities.GetAbility("give_mana", true);
		var real fValue=-1.0;
		if(pxA!=null)then
			fValue=pxA^.GetValueF("radius");
		endif;
		return fValue;
	endproc;
	
	export proc real GetManaAmount(^CFightingObj p_pxTarget) //get user mana aura value; used by Tarna and manatemple buildings (see magiccauldron)
		var ^CFightingObj.CSpecialAbility pxA=m_xAbilities.GetAbility("give_mana", true);
		if(pxA==null||p_pxTarget==null)then return 0.0; endif;
		var real fMod=p_pxTarget^.GetMaxEnergy() * pxA^.GetValueF("mod") * 0.01;
		var real fAmount=(pxA^.GetValueF("amount") * GetTechTreeModifier("ManaPresent",true))+GetTechTreeModifier("ManaPresent",false);
		return fAmount+fMod;
	endproc;
	
	export proc int GetTechTreeSupplyCount() //calls supply count from techtree
		var string sClassName=GetClassName();
		//var int iSupplyCount=0;
		var int iSupplyCount=CMirageSrvMgr.Get().GetSupply(GetClassName());
		return iSupplyCount;
	endproc;
	
	export proc int GetTechTreeUnitRequirement() //calls needed unit number for epoch upgrade from techtree
		var CTechTree xTechTree=GetTechTree();
		var string sClassName=GetClassName();
		var int iUnitReq=0;
		iUnitReq=xTechTree.GetValueI("UnitRequirements/"+GetPlayerTribeName()+"/"+sClassName,0);
		return iUnitReq;
	endproc;
	
	export proc ref bool CheckGrantResourcesANML() //Henry: consrtuction cost of enemy unit given to the killer
		return m_bANMLResBack;
	endproc;
	
	export proc ref bool CheckGrantResourcesCHTR() //Henry: consrtuction cost of enemy unit given to the killer
		return m_bCHTRResBack;
	endproc;
	
	export proc ref bool CheckGrantResourcesVHCL() //Henry: consrtuction cost of enemy unit given to the killer
		return m_bVHCLResBack;
	endproc;
	
	//Henry: those are used for flamethrowers
	export proc ref real GetFireDmg()
		return m_fFireDmg;
	endproc;
	
	export proc void SetFireDmg(real p_fDmg)
		m_fFireDmg=p_fDmg;
	endproc;
	
	export proc ref int GetBurnTime()
		return m_iBurnTime;
	endproc;
	
	export proc void SetBurnTime(int p_iBurningCount)
		m_iBurnTime=p_iBurningCount;
	endproc;
	
	export proc bool GetTamed() //Henry: check if the unit has been newly tamed (stolen better said)
		return m_bTamed;
	endproc;
	
	export proc void SetTamed(bool p_bTamed)
		m_bTamed=p_bTamed;
	endproc;
	
	export proc void FountainOfYouth(real p_fTime) //Henry: to make unit invincible after drinking from the healing well
		m_bFountainHealed=true;
		Detoxification();
		p_fTime *= 0.1f;
		if(HasTimer(TIMER_FOUNTAIN_HEALED))then
			DeleteTimer(TIMER_FOUNTAIN_HEALED);
		endif;
		CreateTimer(CFightingObj.TIMER_FOUNTAIN_HEALED, CGameTimeSpan.OneSecond()*p_fTime, false);
	endproc;
	
	export proc void SecureResurrector() //Henry: to prevent bugs caused by shaman getting killer while resurrection
		m_bResurrectSafety=true;
		if(HasTimer(TIMER_RESURRECT_SAFETY))then
			DeleteTimer(TIMER_RESURRECT_SAFETY);
		endif;
		CreateTimer(CFightingObj.TIMER_RESURRECT_SAFETY, CGameTimeSpan.OneSecond()*5.0, false);
	endproc;
	
	export proc void SetResurrecting(bool p_bResurrecting)
		m_bResurrecting=p_bResurrecting;
	endproc;
	
	export proc bool GetResurrecting()
		return m_bResurrecting;
	endproc;
	
	export proc void IgniteBuilding(real p_fDmg, int p_iMaxCount, CObjHndl p_xSource, int p_iSource)
		if(CMirageSrvMgr.Get().DisableBurning())then return; endif;
		if(m_bSlaveInvincible)then return; endif;
//		if(GetFireProof())then return; endif;
		if(GetType()!="BLDG")then return; endif;
		AddRangedBuff("is_burning");
		// Henry: HACK for performance, since buildings can't be poisoned, the implemented system can be used here instead
		SetPoisonedFlag(true);
		// Henry: burning buildings shouldn't be invisible
		var CFightingObj.CCamouflageLayer xLayer;
		xLayer.SetType("smok");
		var int iIdx=m_axCamouflageLayers.FindEntry(xLayer);
		if(iIdx!=-1&&m_axCamouflageLayers[iIdx].IsValid())then
			m_axCamouflageLayers[iIdx].SetBurning(true);
			UpdateCamouflageLayers();
		endif;
		//strong enough to be primary?
		if(m_xPrimaryFire<=p_fDmg)then
			if(m_xPrimaryFire>=m_xSecondaryFire.GetTicksLeft())then
				m_xSecondaryFire=m_xPrimaryFire;
			endif;
			m_xPrimaryFire.SetFire(p_fDmg, p_iMaxCount, 0, p_xSource, p_iSource);
		//long enough to be secondary?
		elseif(m_xSecondaryFire<=p_iMaxCount)then
			m_xSecondaryFire.SetFire(p_fDmg, p_iMaxCount, 0, p_xSource, p_iSource);
		else
		endif;
	endproc;
	
	export proc void FireGoneOut()
		if(m_xSecondaryFire <= 0)then
		//Henry: new concept -> fire souldn't expire like poison, but will be minimized only
			//IgniteBuilding(1.0f,10);
			RemoveRangedBuff("is_burning");
			SetPoisonedFlag(false);
			var CFightingObj.CCamouflageLayer xLayer;
			xLayer.SetType("smok");
			var int iIdx=m_axCamouflageLayers.FindEntry(xLayer);
			if(iIdx!=-1)then
				m_axCamouflageLayers[iIdx].SetBurning(false);
				UpdateCamouflageLayers();
			endif;
			return;
		endif;
		m_xPrimaryFire=m_xSecondaryFire;
		m_xSecondaryFire.Reset();
	endproc;
	
	export proc void Detoxification()
		m_xSecondaryPoison.Reset();
		m_xPrimaryPoison.Reset();
		RemoveRangedBuff("is_poisoned");
		SetPoisonedFlag(false);
	endproc;
	
	export proc void FireExtinguish()
		m_xSecondaryFire.Reset();
		m_xPrimaryFire.Reset();
		RemoveRangedBuff("is_burning");
		SetPoisonedFlag(false);
		var CFightingObj.CCamouflageLayer xLayer;
		xLayer.SetType("smok");
		var int iIdx=m_axCamouflageLayers.FindEntry(xLayer);
		if(iIdx!=-1)then
			m_axCamouflageLayers[iIdx].SetBurning(false);
			UpdateCamouflageLayers();
		endif;
	endproc;
	
	export proc bool IsBurning()
		return m_xPrimaryFire>=1;
	endproc;
	
	export proc void DoLevelDownAnim()
		InvokeGenericSCEvent(28,1.0f);
	endproc;
	
	export proc void DarkRitual(real p_fTimer, CObjHndl p_xSacrificer)
		m_bSuicide=true;
		AddRangedBuff("dark_ritual");
		m_xSacrificer=p_xSacrificer;
		SetDefaultWalkSet(GetWalkSet());
		if(HasWalkAction())then
			var vec3 vP=GetCurWalkTarget();
			WalkAction(vP,GetMaxSpeed());
		endif;
		if(HasTimer(TIMER_WALKING_BOMB))then DeleteTimer(TIMER_WALKING_BOMB); endif;
		CreateTimer(TIMER_WALKING_BOMB, CGameTimeSpan.OneSecond()*p_fTimer, false);
	endproc;
	
	export proc void DarkRitualSimple(CObjHndl p_xSacrificer)
		m_xSacrificer=p_xSacrificer;
//		if(HasTimer(TIMER_WALKING_BOMB))then DeleteTimer(TIMER_WALKING_BOMB); endif;
//		CreateTimer(TIMER_WALKING_BOMB, CGameTimeSpan.OneSecond()*p_fTimer, false);
		new CAreaDamage(m_xSacrificer,GetCollisionRadius()+30.0f,GetMaxHitpoints()*0.9f,GetMaxHitpoints()*0.6f,GetOwner(),GetPos(),10);
		CreateCustomFX(0,GetPos(),false);
		SetLastEnemy(m_xSacrificer);
		SetLastDamage(GetOwner());
		//Henry: TODO: integrate explosives rounds and seas robot bomb to stack damage
		if(!IsDead())then
			m_fHitpoints=0.0f;
			SetVisible(false);
			SetDead(true);
			Delete();
		endif;
	endproc;
	
	proc void MakeThemPay()
		//new CAreaDamage(GetCollisionRadius()+30.0f,GetHitpoints()*0.45f,GetHitpoints()*0.25f,GetOwner(),GetPos(),10);
		new CAreaDamage(m_xSacrificer,GetCollisionRadius()+30.0f,GetMaxHitpoints()*0.45f,GetMaxHitpoints()*0.25f,GetOwner(),GetPos(),10);
		CreateCustomFX(0,GetPos(),false);
		SetLastEnemy(m_xSacrificer);
		SetLastDamage(GetOwner());
		//Henry: TODO: integrate explosives rounds and seas robot bomb for stack damage
		if(!IsDead())then
			m_fHitpoints=0.0f;
			SetVisible(false);
			SetDead(true);
			Delete();
		endif;
	endproc;
	
	export proc void CreateCustomFX(int p_iIndex, vec3 p_vPos, bool p_bGroundLevel)
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel!=null)then
			if(p_bGroundLevel)then
				var real fHeight=CSrvWrap.GetScapeMgr().GetHeight(p_vPos.GetX(),p_vPos.GetY());
				p_vPos.SetZ(fHeight);
			endif;
			var int i;
			for(i=0)cond(i<8)iter(i++)do
				var ^CPlayer pxPlayer=pxLevel^.GetPlayer(i);
				if(pxPlayer!=null)then
					var ^CAiPlayer pxAiPl=cast<CAiPlayer>(pxPlayer);
					if(pxAiPl==null)then
						CSrvWrap.SendGenericEvtToPlayer(i, "mrg\t"+p_iIndex.ToString()+"\t" +p_vPos.ToString());
					endif;
				endif;
			endfor;
		endif;
	endproc;
	
	export proc void HarakiriFastAndSilent()
//		SetDyingInTPO(GetTransportObj().IsValid());
		m_bPassingAway=GetTransportObj().IsValid();
		OnKill();
		if(m_xProduceUnit.IsValid())then
			var ^CVirtualProduceUnit pxO=cast<CVirtualProduceUnit>(m_xProduceUnit.GetObj());
			if(pxO!=null)then pxO^.Die(); endif;
			m_xProduceUnit.FromInt(-1);
		endif;
		if(m_xReactor.IsValid())then
			var ^CVirtualProduceUnit pxO=cast<CVirtualProduceUnit>(m_xReactor.GetObj());
			if(pxO!=null)then pxO^.Die(); endif;
			m_xReactor.FromInt(-1);
		endif;
		if(!IsDead())then
			if(HasTransportBuildUp())then
				Evacuate();
			endif;
			if(ShallBeResurrectable())then
				CreateSpirit();
			endif;
			m_fHitpoints=0.0f;
			SetVisible(false);
			SetDead(true);
			Delete();
		endif;
	endproc;
	
	export proc real TakeDmgFromBuildup(^CFightingObj p_pxEnemy, real p_fFactor, real p_fHitDelay)
		if(p_pxEnemy==null)then return 0.0; endif;
		if(m_bDarkSwarm)then return 0.0; endif;
		if(GetOnWall())then return 0.0; endif;
//		if(p_pxEnemy^.GetBUProjectile().IsEmpty())then return 0.0; endif;
		if(GetEffectFlag(EFFECT_AJE_CAMOUFLAGE))then
			TerminateAction();
			SetEffectFlag(EFFECT_AJE_CAMOUFLAGE, false);
		endif;
		if((IsFlyingUnit()&&!p_pxEnemy^.CanBUShootAir())||GetTransportObj().IsValid())then
			return 0.0;
		endif;
		if(HasTimer(TIMER_ANML_IMMUNITY))then
//			if(p_pxEnemy^.GetType()=="ANML")then
				return 0.0;
//			endif;
		endif;
		UpdateFightFactors();
		var real fDamage=0.0f;
		if(m_xDmgCache.m_pxLastBUOwner==p_pxEnemy&&m_xDmgCache.m_fBuildUpDamage>0.0f&&!p_pxEnemy^.WeaponHasChanged()&&!OwnWeaponHasChanged())then
			fDamage=m_xDmgCache.m_fBuildUpDamage;
		else
//			if(cast<CCharacter>(this)!=null&&(cast<CCharacter>(this)^.GetTransportObj().IsValid()||cast<CCharacter>(this)^.GetOnWall()))then return 0.0f; endif;
			var real fDmg=0.0f;
			fDmg=/*p_fFactor * */((p_pxEnemy^.AddTemporaryAttackBoni(p_pxEnemy^.GetBUDmg())+(p_pxEnemy^.AddTemporaryRangedAttackBoni(p_pxEnemy^.GetBUDmg())-p_pxEnemy^.GetBUDmg()))
			* (1.0+(p_pxEnemy^.GetBUAttackBoni().GetBonus(GetType().AsString(),GetClassName())/ 100.0)))
			* p_pxEnemy^.GetTechTreeModifier("Damage_"+GetType().AsString(), true)+p_pxEnemy^.GetTechTreeModifier("Damage_"+GetType().AsString(), false);
			if(GetType()=="BLDG")then
				var real fBldgBonus=p_pxEnemy^.GetBonusSum(BONUS_DAMAGE_BLDG);
				if(fBldgBonus>0.0f)then
					var int iTmp=fDmg.ToInt();
					fDmg *= (1.0f+fBldgBonus*0.01f);
					if(fDmg.ToInt()==iTmp)then fDmg+=0.5f; endif;
				endif;
			endif;
			var real fDefense;
			var real fArmorPiercing=p_pxEnemy^.GetBUArmorPiercing();
			var real fMaxDef=m_fMaxDef*100.0f;
//			fDefense=fDmg * Math.Clamp((Math.Clamp(AddTemporaryRangedDefenseBoni(GetRangedProtection()),0.0,fMaxDef)-fArmorPiercing) * 0.01, 0.0f, m_fMaxDef);
			fDefense=fDmg * Math.Clamp(((Math.Clamp(0.0, AddTemporaryRangedDefenseBoni(GetRangedProtection()),fMaxDef)-fArmorPiercing)+((GetRangedDefenseBoni().GetBonus(p_pxEnemy^.GetType().AsString(),p_pxEnemy^.GetClassName())*GetTechTreeModifier("RangedDef_"+p_pxEnemy^.GetType().AsString(), true)+GetTechTreeModifier("RangedDef_"+p_pxEnemy^.GetType().AsString(), false)))) * 0.01, 0.0f, m_fMaxDef);
			fDamage=fDmg-fDefense;
			fDamage=fDamage*p_pxEnemy^.m_fAttackFactor;
			m_xDmgCache.m_pxLastBUOwner=p_pxEnemy;
			m_xDmgCache.m_fBuildUpDamage=fDamage;
		endif;
		fDamage*=p_fFactor;
		if(fDamage>0.0f)then
			CFeedbackEventMgr.Get().AddAttackEvent(GetHandle(),GetOwner());
		endif;
//		if(m_bEvading)then
//			return 0.0;
//		endif;
//		if(m_bMirroring)then
//			if(fDamage>0.0f)then
//				p_pxEnemy^.MirrorDmg(fDamage, p_fHitDelay, GetHandle(), p_pxEnemy^.GetBUProjectile()!="", p_pxEnemy^.GetBUPoisonDmg(), p_pxEnemy^.GetBUPoisonMaxTickCount(), p_pxEnemy^.GetBUFireDmg(), p_pxEnemy^.GetBUBurnTime());
//			endif;
//			return 0.0;
//		endif;
		if(fDamage<=0.0f)then
			return 0.0;
		endif;
		//SetDmgTimer
		var ^CTimerIDTick pxTick=new CTimerIDTick();
		pxTick^.m_xOnTickID=ProvideDmg;
		if(p_fHitDelay>0.0)then
			pxTick^.SetTimer(p_fHitDelay);
		endif;
		m_axDmgTimer.NewEntryRef().Init(pxTick^.GetTimer(), fDamage, p_pxEnemy^.GetHandle(), pxTick, p_pxEnemy^.GetBUProjectile()!="", p_pxEnemy^.GetBUPoisonDmg(), p_pxEnemy^.GetBUPoisonMaxTickCount(), p_pxEnemy^.GetBUFireDmg(), p_pxEnemy^.GetBUBurnTime());
		if(p_fHitDelay<=0.0)then
			ProvideDmg(-1);
		endif;
		return 0.0;
	endproc;
	
	export proc real TakeDmgFromBuildupExtra(^CFightingObj p_pxEnemy, real p_fFactor, real p_fHitDelay)
		if(p_pxEnemy==null)then return 0.0; endif;
		if(m_bDarkSwarm)then return 0.0; endif;
		if(GetOnWall())then return 0.0; endif;
		if(GetEffectFlag(EFFECT_AJE_CAMOUFLAGE))then
			TerminateAction();
			SetEffectFlag(EFFECT_AJE_CAMOUFLAGE, false);
		endif;
		if((IsFlyingUnit()&&!p_pxEnemy^.CanBUShootAir())||GetTransportObj().IsValid())then
			return 0.0;
		endif;
		if(HasTimer(TIMER_ANML_IMMUNITY))then
			return 0.0;
		endif;
		UpdateFightFactors();
		var real fDamage=0.0f;
		if(m_xDmgCache.m_pxLastBUOExtra==p_pxEnemy&&m_xDmgCache.m_fBUDExtra>0.0f&&!p_pxEnemy^.WeaponHasChanged()&&!OwnWeaponHasChanged())then
			fDamage=m_xDmgCache.m_fBUDExtra;
		else
			var real fDmg=0.0f;
			fDmg=/*p_fFactor * */((p_pxEnemy^.AddTemporaryAttackBoni(p_pxEnemy^.GetBUDmg())+(p_pxEnemy^.AddTemporaryRangedAttackBoni(p_pxEnemy^.GetBUDmg())-p_pxEnemy^.GetBUDmg()))
			* (1.0+(p_pxEnemy^.GetBUAttackBoni().GetBonus(GetType().AsString(),GetClassName())/ 100.0)))
			* p_pxEnemy^.GetTechTreeModifier("Damage_"+GetType().AsString(), true)+p_pxEnemy^.GetTechTreeModifier("Damage_"+GetType().AsString(), false);
			if(GetType()=="BLDG")then
				var real fBldgBonus=p_pxEnemy^.GetBonusSum(BONUS_DAMAGE_BLDG);
				if(fBldgBonus>0.0f)then
					var int iTmp=fDmg.ToInt();
					fDmg *= (1.0f+fBldgBonus*0.01f);
					if(fDmg.ToInt()==iTmp)then fDmg+=0.5f; endif;
				endif;
			endif;
			var real fDefense;
			var real fArmorPiercing=p_pxEnemy^.GetBUArmorPiercing();
			var real fMaxDef=m_fMaxDef*100.0f;
			fDefense=fDmg * Math.Clamp(((Math.Clamp(0.0, AddTemporaryRangedDefenseBoni(GetRangedProtection()),fMaxDef)-fArmorPiercing)+((GetRangedDefenseBoni().GetBonus(p_pxEnemy^.GetType().AsString(),p_pxEnemy^.GetClassName())*GetTechTreeModifier("RangedDef_"+p_pxEnemy^.GetType().AsString(), true)+GetTechTreeModifier("RangedDef_"+p_pxEnemy^.GetType().AsString(), false)))) * 0.01, 0.0f, m_fMaxDef);
			fDamage=fDmg-fDefense;
			fDamage=fDamage*p_pxEnemy^.m_fAttackFactor;
			m_xDmgCache.m_pxLastBUOExtra=p_pxEnemy;
			m_xDmgCache.m_fBUDExtra=fDamage;
		endif;
		fDamage*=p_fFactor;
		if(fDamage>0.0f)then
			CFeedbackEventMgr.Get().AddAttackEvent(GetHandle(),GetOwner());
		endif;
		if(fDamage<=0.0f)then
			return 0.0;
		endif;
		var ^CTimerIDTick pxTick=new CTimerIDTick();
		pxTick^.m_xOnTickID=ProvideDmg;
		if(p_fHitDelay>0.0)then
			pxTick^.SetTimer(p_fHitDelay);
		endif;
		m_axDmgTimer.NewEntryRef().Init(pxTick^.GetTimer(), fDamage, p_pxEnemy^.GetHandle(), pxTick, p_pxEnemy^.GetBUProjectile()!="", p_pxEnemy^.GetBUPoisonDmg(), p_pxEnemy^.GetBUPoisonMaxTickCount(), p_pxEnemy^.GetBUFireDmg(), p_pxEnemy^.GetBUBurnTime());
		if(p_fHitDelay<=0.0)then
			ProvideDmg(-1);
		endif;
		return 0.0;
	endproc;
	
	export proc void SetFakeANMLGfx(string p_sGfx)
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("fake_gfx",p_sGfx);
		endif;
	endproc;
	
	export proc string GetFakeANMLGfx()
		var string sGfx = "Iguanodon";
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			sGfx=pxAttr^.GetValue("fake_gfx");
		endif;
		return sGfx;
	endproc;
	
	export proc void SetFakeANMLFilter(string p_sFilter)
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("fake_filter",p_sFilter);
		endif;
	endproc;
	
	export proc string GetFakeANMLFilter()
		var string sFilter="/Filters/Aje/Upgrades/aje_shaman/camouflage_iguanodon";
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			sFilter=pxAttr^.GetValue("fake_filter");
		endif;
		return sFilter;
	endproc;
	
	export proc int GetHPPercent()
		var int iLevel=0;
		if((GetHitpoints()!=0.0f)&&(GetMaxHitpoints()!=0.0f))then
			var real fPercentage=GetHitpoints()/(GetMaxHitpoints()/100.0);
			if(fPercentage>=100.0f)then
				return iLevel;
			elseif(fPercentage<=10.0f)then
				iLevel=9;
			elseif(fPercentage<=20.0f)then
				iLevel=8;
			elseif(fPercentage<=30.0f)then
				iLevel=7;
			elseif(fPercentage<=40.0f)then
				iLevel=6;
			elseif(fPercentage<=50.0f)then
				iLevel=5;
			elseif(fPercentage<=60.0f)then
				iLevel=4;
			elseif(fPercentage<=70.0f)then
				iLevel=3;
			elseif(fPercentage<=80.0f)then
				iLevel=2;
			elseif(fPercentage<=90.0f)then
				iLevel=1;
			endif;
		endif;
		return iLevel;
	endproc;
	
	export proc bool HasFullHP()
		return GetHitpoints()>=GetMaxHitpoints();
	endproc;
	
	export proc void JetPackOn()
	endproc;
	
	export proc void JetPackOff()
	endproc;
	
	export proc bool IsJetPackOn()
		return false;
	endproc;
	
	export proc bool JetPackChange()
		return false;
	endproc;
	
	export proc bool IsTradeUnit()
		var string sName=GetClassName();
		if(sName=="aje_trade_dino"||sName=="hu_cart"||sName=="ninigi_cart"||sName=="seas_trade_dino"||sName=="aje_muraenosaurus"||sName=="seas_muraenosaurus")then
			return true;
		elseif((sName=="hu_fishing_boat"||sName=="ninigi_fishing_boat")&&CRequirementsMgr.Get().CheckInvention(this, GetOwner(), "trade_ship", GetTribeName()))then
			return true;
		endif;
		return false;
	endproc;
	
	export proc void RefreshRangeNDamageInformation()
		UpdateRangeNDamageInformation();
	endproc;
	
	export proc void Release()
	endproc;
	
	export proc void StopEverythingAndRest()
		if(m_pxTaskMgr!=null)then
			m_pxTaskMgr^.BreakAll();
		endif;
		if(GetClassName()=="hu_druid"||GetClassName()=="aje_shaman"||GetClassName()=="ninigi_monk"||GetClassName()=="seas_medic")then
			SetRndInvMaskSingleFlagInv(CFightingObj.VIS_FLAG_CHTR_ACTIVATED,false);
		endif;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("CurTask","Idle");
		endif;
	endproc;
	
	export proc void EnterPortal(^CGameObj p_pxBuilding, bool p_bQ, vec3 p_vPos)
		EnterPortal(p_pxBuilding, p_bQ, p_vPos, true);
	endproc;
	
	export proc void EnterPortal(^CGameObj p_pxBuilding, bool p_bQ, vec3 p_vPos, bool p_bGoTo)
		if(GetTransportObj().IsValid()||GetType()=="SHIP")then return; endif;
		if(p_pxBuilding==null)then
			GoTo(p_vPos, true, GetDefaultSpeed(), true, p_bQ, GetOnWall(), false, true);
			return;
		endif;
		var int i1=p_pxBuilding^.GetOwner(), i2=GetOwner();
		if(i1!=i2)then
//			GoTo(p_vPos, true, GetDefaultSpeed(), true, true, GetOnWall(), false, true);
//			return;
			var bool bAlliance = Math.Min(CSrvWrap.GetDiplomacyMgr().GetRelation(i1,i2),CSrvWrap.GetDiplomacyMgr().GetRelation(i2,i1))==2;
			if(!CMirageSrvMgr.Get().DiploLocked()||!bAlliance)then
				if(p_bGoTo)then
					GoTo(p_vPos, true, GetDefaultSpeed(), true, p_bQ, GetOnWall(), false, true);
				endif;
				return;
			endif;
		endif;
		var ^CPortalTerminus pxObj=cast<CPortalTerminus>(p_pxBuilding);
		if(pxObj==null)then
			GoTo(p_vPos, true, GetDefaultSpeed(), true, p_bQ, GetOnWall(), false, true);
			return;
		elseif(!pxObj^.IsFunctionable())then
			GoTo(p_vPos, true, GetDefaultSpeed(), true, p_bQ, GetOnWall(), false, true);
			return;
		endif;
//		if(IsJetPackOn()||m_bFlyingUnit)then
////		if(IsFlyingUnit()||GetTransportClass()==2)then
//			GoTo(p_vPos, true, GetDefaultSpeed(), true, true, GetOnWall(), false, true);
//			return;
//		endif;
		var ^CEnterPortal pxTask=cast<CEnterPortal>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"EntrPortal"));
		if(pxTask!=null)then
			if(pxTask^.Init(GetHandle(), p_pxBuilding^.GetHandle()))then
				pxTask^.SetUserCommand(true);
				AddTask(pxTask, p_bQ);
			else
				pxTask^.GetFactory()^.FreeState(pxTask);
			endif;
		endif;
	endproc;
	
	export proc bool IsWildAnimal()
		return m_bIsWildAnimal;
	endproc;
	
	export proc void CheckWildAnimal()
		var string sClassName=GetClassName();
		var CTechTreeDef xTTDef;
		var ^CTechTreeMgr pxTTMgr=CSrvWrap.GetGame().GetTechTreeMgr();
		var CTechTree xTT=pxTTMgr^.GetTechTree(xTTDef);
		var ^CTechTree.CNode pxWorldAnimals=xTT.FindNode("Objects/World/ANML/"+sClassName);
		if(pxWorldAnimals!=null)then
			m_bIsWildAnimal=true;
		else
			m_bIsWildAnimal=false;
		endif;
	endproc;
	
	proc real GetWildAnimalAttackBonus(int p_iLevel)
		switch(p_iLevel)
			case(1)do return 10.0; endcase;
			case(2)do return 20.0; endcase;
			case(3)do return 40.0; endcase;
			case(4)do return 80.0; endcase;
			case default do return 0.0; endcase;
		endswitch;
	endproc;
	
	proc real GetWildAnimalHPBonus(int p_iLevel)
		switch(p_iLevel)
			case(1)do return 100.0; endcase;
			case(2)do return 300.0; endcase;
			case(3)do return 600.0; endcase;
			case(4)do return 1100.0; endcase;
			case default do return 0.0; endcase;
		endswitch;
	endproc;
	
	proc real GetWildAnimalSkullBonus(int p_iLevel)
		switch(p_iLevel)
			case(1)do return 5.0; endcase;
			case(2)do return 15.0; endcase;
			case(3)do return 25.0; endcase;
			case(4)do return 45.0; endcase;
			case default do return 0.0; endcase;
		endswitch;
	endproc;
	
	export proc bool ShowAnmlMiscFlag()
		var string sGfx=GetGfxName();
		if(sGfx=="Stegosaurus"||sGfx=="Kentrosaurus"||sGfx=="Macrolemys_Land"||sGfx=="macrolemys_land"||sGfx=="Macrolemys_Water"||sGfx=="macrolemys_water"||sGfx=="Mammoth"/*||sGfx=="Parasaurolophus"*/||sGfx=="Macrolemyd_Land"||sGfx=="macrolemyd_land"||sGfx=="Macrolemyd_Water"||sGfx=="macrolemyd_water")then
			return true;
		endif;
		return false;
	endproc;
	
	export proc void ReWritePrepareActions(string p_sName, bool p_bAdd)
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr==null)then return; endif;
		if(p_sName.IsEmpty())then return; endif;
		var string sNewValue="";
		if(p_bAdd)then
			var string sPrepare=pxAttr^.GetValue("PrepareActionNames");
			if(!sPrepare.IsEmpty())then
				var array string asActions;
				sPrepare.Split(asActions, "\n", true);
				if(asActions.FindEntry(p_sName)!=-1)then return; endif;
				asActions.AddEntry(p_sName);
				var int i, iC=asActions.NumEntries();
				for(i=0)cond(i<iC)iter(++i)do
					sNewValue += asActions[i]+"\n";
				endfor;
			else
				sNewValue += p_sName+"\n";
			endif;
			pxAttr^.SetValue("PrepareActionNames",sNewValue);
		else
			var string sPrepare=pxAttr^.GetValue("PrepareActionNames");
			if(!sPrepare.IsEmpty())then
				var array string asActions;
				sPrepare.Split(asActions, "\n", true);
				var int iEntry=asActions.FindEntry(p_sName);
				if(iEntry!=-1)then
					asActions.DeleteEntry(iEntry);
					var int i, iC=asActions.NumEntries();
					for(i=0)cond(i<iC)iter(++i)do
						sNewValue += asActions[i]+"\n";
					endfor;
					pxAttr^.SetValue("PrepareActionNames",sNewValue);
				endif;
			endif;
		endif;
	endproc;
	
	export proc bool IsHealing()
		return false;
	endproc;
	
	export proc bool AddParasite(CObjHndl p_xParasite)
		if(!p_xParasite.IsValid())then return false; endif;
		if(m_axParasites.FindEntry(p_xParasite)==-1)then
			m_axParasites.AddEntry(p_xParasite);
			return true;
		endif;
		return false;
	endproc;
	
	export proc bool RemParasite(CObjHndl p_xParasite)
		if(!p_xParasite.IsValid())then return false; endif;
		var int i=m_axParasites.FindEntry(p_xParasite);
		if(i!=-1)then
			m_axParasites.DeleteEntry(i);
			if(m_axParasites.NumEntries()<1)then
				RemoveRangedBuff("parasite_host");
			endif;
			return true;
		endif;
		return false;
	endproc;
	
	export proc void UpdateAttacker(^CFightingObj p_pxEnemy)
		if(m_pxTaskMgr==null)then return; endif;
		var ^CTask pxTask=m_pxTaskMgr^.GetCurTask();
		var bool bDefense=true;
		if(cast<CFlee>(pxTask)!=null)then bDefense=false; endif;
		if(p_pxEnemy!=null&&bDefense)then
			if(HasTimer(TIMER_PREAGGRO)&&!HasTimer(TIMER_AGGRO))then
				ActivateAggroTimer();
			endif;
			AddEnemy(p_pxEnemy^.GetHandle(), true);
			pxTask=m_pxTaskMgr^.GetCurTask();
		endif;
		if(!IsAbleToFight())then ShoutForHelp(false);endif;
	endproc;
	
	export proc bool PeaceTime()
		return m_bCeaseFire;
	endproc;
	
	export proc bool HasUnboardEffect()
		return m_bUnboard;
	endproc;
	
	export proc bool GetNeutralObject()
		return false;
	endproc;
	
	export static proc void ShakeZone(ref vec3 p_rvPos,ref CObjList p_rxEnemies)
		if(p_rxEnemies.NumEntries()==0)then return; endif;
		var vec3 vPT=p_rvPos;
		if(vPT=={0.0,0.0,0.0})then return; endif;
		var int i;
		p_rxEnemies.SortDistance(vPT,true);
		for(i=0)cond(i<p_rxEnemies.NumEntries())iter(i++)do
			var ^CFightingObj pxEnemy=cast<CFightingObj>(p_rxEnemies[i].GetObj());
			if(pxEnemy!=null&&pxEnemy^.m_iSizeClass>0&&!pxEnemy^.ResistantToThrow()||!pxEnemy^.GetOnWall())then
				if(!pxEnemy^.GetTransportObj().IsValid()&&!pxEnemy^.IsJetPackOn()&&!pxEnemy^.IsFlyingUnit())then
//				if(!pxEnemy^.GetTransportObj().IsValid()&&!pxEnemy^.IsFlyingUnit())then
					var string sCurTask=pxEnemy^.GetCurTaskName();
					if(pxEnemy^.HasAnim("hit_back")&&(sCurTask!="Jetpack")&&(sCurTask!="SpecSuitJ")&&(sCurTask!="PilotFly"))then
						var string sAct=pxEnemy^.GetActionDesc();
						if(sAct!="CActFall")then
							if(pxEnemy^.GetResurrecting())then pxEnemy^.BreakEveryTask(); endif;
							pxEnemy^.m_bThrowImmune=true;
							pxEnemy^.CreateTimer(TIMERID_THROWIMMUNE, CGameTimeSpan.OneSecond()*5.0f, false);
							pxEnemy^.FallActionDest(pxEnemy^.GetPos(), "hit_back", "getting_up", 0.0);
							pxEnemy^.ToTheGround(3.0);
						endif;
					endif;
				endif;
			endif;
		endfor;
	endproc;
	
	export proc void Evacuate()
		return;
	endproc;
	
	export proc string GetTtGfx()
		return m_xTechTree.GetValueS(GetObjPath()+"/gfx","");
	endproc;
	
	export proc string GetFakeGfx()
		var string sGfx="seas_temple_paving_tiles_01";
		if(GetTribeName()=="SEAS")then
			sGfx="seas_hq_paving_tiles_02";
		endif;
		return sGfx;
	endproc;
	
	export proc bool GetManaUser()
		return (m_xTechTree.GetValueI(GetObjPath()+"/mana_user",0)>0);
	endproc;
	
	export proc void ThrowBack()
		return;
	endproc;
	
	proc void HuntAnimals(vec3 p_vPos)
		if(p_vPos=={0.0,0.0,0.0})then m_bFreeHunting=false; return; endif;
		m_bFreeHunting=true;
		var real fRadius=100.0f;
		var CObjQuery xHuntSearch;
		xHuntSearch.SetOwner(-1);
		xHuntSearch.SetType("ANML");
		if(GetClassName().Find("_worker")!=-1)then
			xHuntSearch.SetAttribsPos("anml_aggressive_type",-1);
		else
			xHuntSearch.SetAttribsNeg("anml_aggressive_type",1);
		endif;
		xHuntSearch.SetAttribsNeg("camouflage_anml",1);
		var CObjList xPrey;
		xHuntSearch.SetVisibility(GetOwner(),true);
		xHuntSearch.RegionCircle(p_vPos,fRadius);
		if(xHuntSearch.Execute(xPrey))then
			xPrey.SortDistance(p_vPos);
			while(xPrey.NumEntries()>0)do
				if(!xPrey[0].IsValid())then
					xPrey.DeleteEntry(0);
					continue;
				endif;
				var ^CFightingObj pxCandidat=cast<CFightingObj>(xPrey[0].GetObj());
				if(pxCandidat!=null&&pxCandidat^.IsBaby())then
					xPrey.DeleteEntry(0);
					continue;
				endif;
				var CObjHndl xInvalid;
				var bool bMinRange=false;
				var bool bCheck=IsInCombatRange(pxCandidat,bMinRange,xInvalid,GetAttackRange(),true);
				if(bMinRange)then
					xPrey.DeleteEntry(0);
					continue;
				endif;
				//Fight(xPrey[0].GetObj(),xPrey[0].GetObj()^.GetPos(),true);
				UpdateAggressionPos(xPrey[0].GetObj()^.GetPos());
				ReactToGamePlayCommand("Action",xPrey[0].GetObj(),xPrey[0].GetObj()^.GetPos(),"/Attack",false,false,false);
				//HandleGamePlayCommand("Attack",xPrey[0].GetObj(),xPrey[0].GetObj()^.GetPos(),"");
				return;
			endwhile;
		else
			m_bFreeHunting=false;
			return;
		endif;
		m_bFreeHunting=false;
		return;
	endproc;
	
	export proc bool FreeHunting()
		if(GetTransportObj().IsValid())then
			m_bFreeHunting=false;
		endif;
		return m_bFreeHunting;
	endproc;
	
	export proc void FreeHunt(bool p_bHunting)
		m_bFreeHunting=p_bHunting;
	endproc;
	
	export proc bool IsDunding()
		return HasTimer(TIMER_DUNDEED);
	endproc;
	
	export proc void AddTraderBoni(ref real p_rfBoni)
		p_rfBoni *= (m_xTechTree.GetValueR("MiscValues/"+GetPlayerTribeName()+"/Trader_Bonus_rel",0.0));
		p_rfBoni += (m_xTechTree.GetValueI("MiscValues/"+GetPlayerTribeName()+"/Trader_Bonus_abs",0)).ToReal();
	endproc;
	
	export proc void AddDrawbarBoni(ref real p_rfBoni)
		if(CMirageSrvMgr.Get().GetBoomingEconomy(GetOwner()))then
			p_rfBoni *= 1.5f;
		endif;
	endproc;
	
	export proc bool HasHidingEffect()
		var array string asLayers;
//		asLayers.AddEntry("hero");
		asLayers.AddEntry("smok");
		asLayers.AddEntry("disg");
		asLayers.AddEntry("entr");
		asLayers.AddEntry("trap");
		var int i, iC=asLayers.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var CCamouflageLayer xLayer;
			xLayer.SetType(asLayers[i]);
			var int iIdx=m_axCamouflageLayers.FindEntry(xLayer);
			if(iIdx>-1)then
				if(!m_axCamouflageLayers[iIdx].IsValid()||m_axCamouflageLayers[iIdx].IsOffline())then
					continue;
				else
					return true;
				endif;
			endif;
		endfor;
		return false;
	endproc;
	
	export proc void UpdateAllLinkedPassengers()
		return;
	endproc;
	
	export proc void SetSpawningPool(CObjHndl p_xSpawningPool)
		m_xSpawningPool=p_xSpawningPool;
	endproc;
	
	export proc CObjHndl GetSpawningPool()
		return m_xSpawningPool;
	endproc;
	
	export proc ^CFightingObj GetSpawner()
//		return cast<CFightingObj>(m_xSpawningPool.GetObj());
		if(m_xSpawningPool.IsValid())then
			return cast<CFightingObj>(m_xSpawningPool.GetObj());
		endif;
		return null;
	endproc;
	
	export proc CObjHndl GetEnemyHandle()
		return GetHandle();
	endproc;
	
	export proc CObjHndl GetCreatorHandle()
		return GetHandle();
	endproc;
	
	export proc void SetIntimidate(CObjHndl p_xUnit)
		m_xIntimidate=p_xUnit;
	endproc;
	
	export proc CObjHndl GetIntimidate()
		return m_xIntimidate;
	endproc;
	
	export proc void PoisonDamage(real p_fDamage, CObjHndl p_xEnemy, int p_iEnemy)
		if(m_bGodMode)then return;endif;
		if(m_bSlaveInvincible)then return;endif;
		//Kr1s1m: units which have invulnerable flag set by ACDO trigger used to be damaged by poison ticks
		if(m_iInvulnerable > 0 || m_bLDInvulnerable)then return; endif;
		if(m_bLevelUpInvulnerable)then return; endif;
		if(m_bStolen||IsFeignDeath())then return; endif;
		if(m_bFountainHealed||m_bResurrectSafety)then return; endif;
		m_xLastEnemy=p_xEnemy;
		m_iLastDamage=p_iEnemy;
		if(GetType()=="ANML"&&HasTimer(TIMER_SANCTIFICATION))then
			DeleteTimer(TIMER_SANCTIFICATION);
			if(!IsInFight())then
				CreateTimer(TIMER_SANCTIFICATION, CGameTimeSpan.OneSecond() * 5.0, false);
			endif;
		endif;
//		SpreadDamage(p_fDamage);
		if(m_bBloodInfect)then
			p_fDamage*=2.0f;
		endif;
		HPReduction(Math.Max(Math.Ceil(p_fDamage*m_fDefenseFactor),1.0), p_iEnemy);
	endproc;
	
	export proc void BurnDamage(real p_fDamage, CObjHndl p_xEnemy, int p_iEnemy)
		if(m_bGodMode)then return;endif;
		if(m_bSlaveInvincible)then return;endif;
		//Kr1s1m: buildings which have invulnerable flag set by ACDO trigger used to be damaged by fire ticks
		if(m_iInvulnerable > 0 || m_bLDInvulnerable)then return; endif;
		if(m_bLevelUpInvulnerable)then return; endif;
		m_xLastEnemy=p_xEnemy;
		m_iLastDamage=p_iEnemy;
		HPReduction(Math.Max(Math.Ceil(p_fDamage*m_fDefenseFactor),1.0), p_iEnemy);
	endproc;
	
	export proc bool CanBeFinished(CObjHndl p_xCur,CObjHndl p_xLast)
		if(!CMirageSrvMgr.Get().UseFinishingMoves())then return false; endif;
		if(IsBaby())then return false; endif;
		var CObjHndl xEnemy=p_xCur;
		var ^CFightingObj pxEnemy;
		var int i=0,iC=2;
		if(p_xCur==p_xLast)then
			iC=1;
		endif;
		for(i=0)cond(i<iC)iter(i++)do
			if(i==1)then xEnemy=p_xLast; endif;
			if(!xEnemy.IsValid())then continue; endif;
			if(xEnemy.GetObj()==null)then continue; endif;
			pxEnemy=cast<CFightingObj>(xEnemy.GetObj());
			if(pxEnemy==null)then continue; endif;
			if(pxEnemy^.GetTransportObj().IsValid()||pxEnemy^.InvalidEnemy())then
				continue;
			endif;
			var real fMinRange=GetCollisionRadius()+pxEnemy^.GetCollisionRadius()+10.0f;
			var real fZone=fMinRange * fMinRange;
			var real fDistance=(pxEnemy^.GetPos() - GetPos()).Abs2S();
			if(fDistance > fZone)then
				continue;
			endif; //too far away
			if(pxEnemy^.InitFinishingMove(pxEnemy, this))then
				return true;
			endif;
		endfor;
		return false;
	endproc;
	
	export proc string GetFinishingClass(bool p_bVictim)
		var string sClass=m_xTechTree.GetValueS(GetObjPath()+"/FinishingClass","");
		if(sClass.Find("Infantry_")!=-1&&p_bVictim)then
			sClass="Infantry_all";
		endif
		return sClass;
	endproc;
	
	export proc bool StornoLast()
		var bool bReturn, bVR=false;
		if(m_pxTaskMgr!=null)then
			bReturn=m_pxTaskMgr^.Storno(false);
		endif;
		if(!m_xProduceUnit.IsValid())then return bReturn; endif;
		var ^CVirtualProduceUnit pxUnit=cast<CVirtualProduceUnit>(m_xProduceUnit.GetObj());
		if(pxUnit!=null)then
			bVR=pxUnit^.StornoLast();
		endif;
		return (bReturn||bVR);
	endproc;
	
	export proc void StornoAll()
		if(m_pxTaskMgr!=null)then
			m_pxTaskMgr^.Storno(true);
		endif;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("CurTask","none");
			pxAttr^.SetValue("CurProcessObj","");
			pxAttr^.SetValue("CurProcess",0);
		endif;
		if(m_xReactor.IsValid())then
			var ^CVirtualProduceUnit pxUnit=cast<CVirtualProduceUnit>(m_xReactor.GetObj());
			if(pxUnit!=null)then
				pxUnit^.StornoAll();
			endif;
		endif;
		if(!m_xProduceUnit.IsValid())then return; endif;
		var ^CVirtualProduceUnit pxUnit=cast<CVirtualProduceUnit>(m_xProduceUnit.GetObj());
		if(pxUnit!=null)then
			pxUnit^.StornoAll();
		endif;
	endproc;
	
	export proc void BuildUpKeeperAttack()
		return;
	endproc;
	
	export proc bool HasTechTreeFlag(string p_sFlag)
		var string sObjPath=GetObjPath();
		if(sObjPath=="")then return false; endif;
		var ^CTechTree.CNode pxTTNode=m_xTechTree.FindNode(sObjPath+"/flags/"+p_sFlag);
		if(pxTTNode!=null)then return true; endif;
		return false;
	endproc;
	
	export proc CObjHndl GetReactor()
		return m_xReactor;
	endproc;
	
	export proc void CreateReactor(bool p_bSetReady)
		var ^CVirtualProduceUnit pxUnit=cast<CVirtualProduceUnit>(CSrvWrap.GetObjMgr()^.CreateObj("Virtual_Produce_Unit",GetOwner(),GetPos()));
		if(pxUnit!=null)then
			pxUnit^.Init(GetHandle(), GetClassName(), GetTribeName());
			m_xReactor=pxUnit^.GetHandle();
			if(p_bSetReady)then
				pxUnit^.SetReady();
			endif;
		endif;
	endproc;
	
	export proc int GetProdQueueQuantity(bool p_bReactor)
		if(p_bReactor)then
			return Math.Max(0,m_iPQNER);
		else
			return Math.Max(0,m_iPQNEO);
		endif;
	endproc;
	
	export proc void ReleaseItem(string p_sItemName, bool p_bQ)
		if(CMirageSrvMgr.Get().DisableArtifactRelease())then
			if(GetClassName()!="Miyagi_s0")then
				return;
			endif;
		endif;
		var ^CInventory pxInv=GetInventory();
		if(pxInv==null)then return; endif;
		var ^CItem pxItem=cast<CItem>(CSrvWrap.GetObjMgr()^.GetObjByName(p_sItemName));
		if(pxItem==null)then return; endif;
		if(p_bQ)then
			StartCustomTask(pxItem^.GetHandle(),"ReleaseItem", "");
			return;
		endif;
		if(!CArtifactMgr.Get().RemoveArtifact(GetOwner(),pxItem^.GetHandle()))then /*Do Nothing*/; endif;
		pxInv^.RemItem(pxItem^.GetHandle());
		pxItem^.OnDroppedItem(this,true,"normal",false);
		pxItem^.TerminateAction();
		if(HasAnim("put_down"))then
			AnimAction("put_down");
		endif;
		AddItemName("");
	endproc;
	
	export proc void SetAttribAction(string p_sAttrib, string p_sValue, bool p_bReactor)
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			var string sAttr="";
			if(p_bReactor)then
				sAttr=("Reactor"+p_sAttrib);
			else
				sAttr=p_sAttrib;
			endif;
			pxAttr^.SetValue(sAttr, p_sValue);
		endif;
	endproc;
	
	export proc void SetAttribAction(string p_sAttrib, int p_iValue, bool p_bReactor)
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			var string sAttr="";
			if(p_bReactor)then
				sAttr=("Reactor"+p_sAttrib);
			else
				sAttr=p_sAttrib;
			endif;
			pxAttr^.SetValue(sAttr, p_iValue);
		endif;
	endproc;
	
	export proc bool HasCanceledAction(string p_sTTPath)
		if(m_pxTaskMgr!=null)then
			return m_pxTaskMgr^.CanRemoveAction(p_sTTPath);
		endif;
		return false;
	endproc;
	
	export proc void HandleGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams)
//		if(p_pxObject!=null)then
//			CMirageSrvMgr.Debug("gpc CFightingObj: "+GetName()+" "+p_sCommand+" "+p_sMiscParams+" "+p_vPos.ToString()+" "+p_pxObject^.GetName());
//		else
//			CMirageSrvMgr.Debug("gpc CFightingObj: "+GetName()+" "+p_sCommand+" "+p_sMiscParams+" "+p_vPos.ToString());
//		endif;
		if(m_bLocked && p_sMiscParams.Find("/ToggleLocked")==-1 && p_sMiscParams.Find("/LeaveTransport")==-1)then
			if(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)then
				InvalidateAttrib("level");
			endif;
			return;
		endif;
		if(p_sMiscParams.Find("/ToggleLocked")!=-1)then
			ToggleLocked();
			return;
		endif;
//		if(m_bDeafened)then return; endif;
		var string sAct=GetActionDesc();
		if(((sAct=="CActFall" && m_bOnTheGround)||m_bDeafened)&&!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill")&&!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/Dismount")!=-1)&&!(p_sMiscParams.Find("/crash_rpg_levelup")!=-1))then
			return;
		endif;
		var string sCommand=p_sCommand;
		var bool bQ=false, bS=false, bA=false;
		if(sCommand.Left(2)=="Q_")then
			bQ=true;
			sCommand.Delete(0,2);
		endif;
		if(sCommand.Left(2)=="S_")then
			bS=true;
			sCommand.Delete(0,2);
		endif;
		if(sCommand.Find("_AILock")!=-1)then
			bA=true;
			sCommand.Replace("_AILock","");
		endif;
		ReactToGamePlayCommand(sCommand,p_pxObject,p_vPos,p_sMiscParams,bQ,bS,bA);
	endproc;
	
	export proc CObjHndl GetHiveMind()
		return m_xHiveMind;
	endproc;
	
	export proc void TakeControlOver(int p_iID, real p_fTime)
		if(m_xHiveMind.IsValid())then
			RetainConsciousness();
		endif;
		var ^CAttribs pxAttr=GetAttribs();
		var ^CHiveMind pxUnit=cast<CHiveMind>(CSrvWrap.GetObjMgr()^.CreateObj("overlord",p_iID,GetPos()));
		if(pxUnit!=null&&pxAttr!=null)then
			pxUnit^.Init(GetHandle());
			m_xHiveMind=pxUnit^.GetHandle();
			m_iCmdID=pxUnit^.GetOwner();
			pxUnit^.SetFOW(m_fFOWRange);
		endif;
	endproc;
	
	export proc void RetainConsciousness()
		var ^CHiveMind pxUnit=cast<CHiveMind>(m_xHiveMind.GetObj());
		if(pxUnit!=null)then
			pxUnit^.Delete();
			m_xHiveMind.FromInt(-1);
		endif;
		m_iCmdID=m_iOwnerID;
	endproc;
	
	export proc void ClearFightState()
		m_xReturnEnemy=CObjHndl.Invalid();
		m_xCurEnemy=CObjHndl.Invalid();
		PreCheckForEnemies();
	endproc;
	
	export proc void MirrorDmg(real p_fDamage, real p_fHitDelay, CObjHndl p_xEnemy, bool p_bProjectile, real p_fPoison, int p_iPoison, real p_fFire, int p_iFire)
		if(!p_xEnemy.IsValid())then return; endif;
		var ^CTimerIDTick pxTick=new CTimerIDTick();
		pxTick^.m_xOnTickID=ProvideDmg;
		if(p_fHitDelay>0.0)then
			pxTick^.SetTimer(p_fHitDelay);
		endif;
		m_axDmgTimer.NewEntryRef().Init(pxTick^.GetTimer(), p_fDamage, p_xEnemy, pxTick, p_bProjectile, p_fPoison, p_iPoison, p_fFire, p_iFire);
		if(p_fHitDelay<=0.0)then
			ProvideDmg(-1);
		endif;
	endproc;
	
	export proc void Reanimated(bool p_bAnim)
		if(p_bAnim)then
			if(HasAnim("faked_death"))then
				AnimAction("faked_death");
			elseif(HasAnim("getting_up"))then
				AnimAction("getting_up");
			elseif(HasAnim("waking"))then
				AnimAction("waking");
			elseif(HasAnim("getup"))then
				AnimAction("getup");
			elseif(HasAnim("take_off"))then
				SetSLEAnim("take_off",10,true,true);
			elseif(HasAnim("dying"))then
				SetAnim("dying",2);
			endif;
		endif;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("reanimated",1);
		endif;
	endproc;
	
	export proc void RegisterSpirit(int p_iSpirit,int p_iKillerCount,int p_iKillerHistory,CObjHndl p_xHandle,string p_sID,string p_sDur,string p_sStart,string p_sDeath)
		if(CMirageSrvMgr.ms_pxPoolMixer!=null)then
			CMirageSrvMgr.ms_pxPoolMixer^.RegisterSpirit(p_iSpirit,p_iKillerCount,p_iKillerHistory,p_xHandle,p_sID,p_sDur,p_sStart,p_sDeath);
		endif;
	endproc;
	
	export proc void SetCmdID(int p_iID)
		m_iCmdID=p_iID;
//		var ^CAttribs pxAttribs=GetAttribs();
//		if(pxAttribs!=null)then
//			pxAttribs^.SetValue("overlord", p_iID);
//		endif;
	endproc;
	
	export proc int GetCmdID()
		return m_iCmdID;
	endproc;
	
	export proc int GetRealOwner()
		return m_iOwnerID;
	endproc;
	
	export proc bool IsUnavailable()
		if(m_bAILock)then return true; endif;
		if(m_bDeafened)then return true; endif;
		return false;
	endproc;
	
	export proc void SetPlayerAttribs(string p_sName, int p_iValue)
		var ^CLevel pxCurLevel=CSrvWrap.GetCurLevel();
		if(pxCurLevel==null)then return; endif;
		var ^CPlayer pxP=pxCurLevel^.GetPlayer(GetOwner());
		if(pxP==null)then return; endif;
		var ^CAttribs pxAttr=pxP^.GetAttribs();
		if(pxAttr==null)then return; endif;
		pxAttr^.SetValue(p_sName, p_iValue);
	endproc;
	
	export proc void SetTribeName(string p_sTribe)
		m_sTribe=p_sTribe;
		var ^CAttribs pxAttribs=GetAttribs();
		if(pxAttribs!=null)then
			pxAttribs^.SetValue("tribe",m_sTribe);
		endif;
	endproc
	
	export proc void SpreadDamage(real p_fDamage)
		var int i, iC=m_xBonds.NumEntries();
		if(iC<1)then return; endif;
		var ^CFightingObj pxF;
		var real fFactor=0.2;
		p_fDamage *= fFactor;
		for(i=0)cond(i<iC)iter(i++)do
			if(!m_xBonds[i].IsValid())then m_xBonds.DeleteEntry(i); i--; iC--; continue; endif;
			pxF=cast<CFightingObj>(m_xBonds[i].GetObj());
			if(pxF==null)then m_xBonds.DeleteEntry(i); i--; iC--; continue; endif;
//			if(m_xBonds[i]==GetHandle())then continue; endif;
			pxF^.ChainDamage(p_fDamage, m_iLastDamage, m_xLastEnemy);
		endfor;
	endproc;
	
	export proc void ChainDamage(real p_fDamage, int p_iLast, CObjHndl p_xLast)
		if(m_bGodMode||m_bCeaseFire)then return;endif;
		if(m_bSlaveInvincible)then return;endif;
		if(HasTimer(TIMER_ANML_IMMUNITY))then return; endif;
		if(m_bLevelUpInvulnerable)then return; endif;
		if(m_bStolen||IsFeignDeath())then return; endif;
		if(m_bFountainHealed||m_bResurrectSafety)then return; endif;
		if(GetType()=="ANML"&&HasTimer(TIMER_SANCTIFICATION))then
			DeleteTimer(TIMER_SANCTIFICATION);
			if(!IsInFight())then
				CreateTimer(TIMER_SANCTIFICATION, CGameTimeSpan.OneSecond() * 5.0, false);
			endif;
		endif;
		m_iLastDamage=p_iLast;
		m_xLastEnemy=p_xLast;
		HPReduction(Math.Max(Math.Ceil(p_fDamage*m_fDefenseFactor),1.0), p_iLast);
	endproc;
	
	export proc void AddBondedUnits(CObjList p_xList, real p_fDuration)
		m_xBonds.Validate();
		if(HasTimer(TIMER_BONDS))then
			DeleteTimer(TIMER_BONDS);
		endif;
		var ^CFightingObj pxFO;
		var int i, iC=p_xList.NumEntries();
		for(i=0)cond(i<iC)iter(++i)do
			if(!p_xList[i].IsValid())then continue; endif;
			if(p_xList[i]==GetHandle())then continue; endif;
			if(m_xBonds.FindEntry(p_xList[i])!=-1)then continue; endif;
			pxFO=cast<CFightingObj>(p_xList[i].GetObj());
			if(p_xList[i].GetObj()^.GetOwner()!=GetOwner())then continue; endif;
			m_xBonds.AddEntry(p_xList[i]);
		endfor;
		CreateTimer(TIMER_BONDS,CGameTimeSpan.OneSecond()*p_fDuration, false);
	endproc;
	
	export proc void SetDemoteEffect(bool p_bOn,real p_fDuration)
		var string sFX="Downgrade_Animal_Fx";
		if(m_bDemoteEffect&&!p_bOn)then
			RemoveFX(sFX);
			RemoveRangedBuff("degraded");
		endif;
		m_bDemoteEffect=p_bOn;
		if(HasTimer(TIMER_DEMOTE))then
			DeleteTimer(TIMER_DEMOTE);
		endif;
		if(p_bOn)then
			AddRangedBuff("degraded");
			var CObjHndl xHndl=AddFX(sFX,p_fDuration);
			if(xHndl.IsValid())then
				var CFourCC xLink;
				xHndl.GetObj()^.LinkAction(GetHandle(),xLink,{0.0,0.0,3.0});
			endif;
		endif;
		if(p_bOn&&p_fDuration>0.0)then
			CreateTimer(TIMER_DEMOTE, CGameTimeSpan.OneSecond()*p_fDuration, false);
		endif;
	endproc;
	
	export proc void ActivateMirroring(bool p_bOn, real p_fDuration)
		RemoveFX("Dismount_Char_Fx");
		m_bMirroring=p_bOn;
		m_bOwnWeaponHasChanged=true;
		if(p_bOn)then
			var CObjHndl xHndl=AddFX("Dismount_Char_Fx", p_fDuration);
			if(xHndl.IsValid())then
				var CFourCC xLink;
				xHndl.GetObj()^.LinkAction(GetHandle(),xLink,{0.0,0.0,0.75});
			endif;
		endif;
	endproc
	
	export proc void ActivateEvading(bool p_bOn, real p_fDuration)
		RemoveFX("Confirmping_Build_Character_Fx");
		m_bEvading=p_bOn;
		m_bOwnWeaponHasChanged=true;
		if(p_bOn)then
			var CObjHndl xHndl=AddFX("Confirmping_Build_Character_Fx", p_fDuration);
			if(xHndl.IsValid())then
				var CFourCC xLink;
//				xHndl.GetObj()^.LinkAction(GetHandle(),xLink,{0.0,0.0,0.75});
				xHndl.GetObj()^.LinkAction(GetHandle(),xLink);
			endif;
		endif;
	endproc
	
	export proc void Motivate(real p_fDur, real p_fDef, real p_fPower)
		if(HasTimer(TIMER_MOTIVATED))then
			DeleteTimer(TIMER_MOTIVATED);
		endif;
		var ^CBoniBucket pxBBDef=GetBoniBucket(CFightingObj.BONUS_DEFENSE), pxBBRangeDef=GetBoniBucket(CFightingObj.BONUS_RANGEDDEFENSE), pxBBAtk=GetBoniBucket(CFightingObj.BONUS_DAMAGE);
		if(pxBBDef!=null)then
			pxBBDef^.RemEntry("motivate_def");
			pxBBDef^.AddEntry("motivate_def", p_fDef);
		endif;
		if(pxBBRangeDef!=null)then
			pxBBRangeDef^.RemEntry("motivate_rdef");
			pxBBRangeDef^.AddEntry("motivate_rdef", p_fDef);
		endif;
		if(pxBBAtk!=null)then
			pxBBAtk^.RemEntry("motivate_atk");
			pxBBAtk^.AddEntry("motivate_atk", p_fPower);
		endif;
		ForceBoniUpdate();
		UpdateWeaponBoni();
		UpdateRangeNDamageInformation();
		CreateTimer(TIMER_MOTIVATED,CGameTimeSpan.OneSecond()*p_fDur, false);
	endproc;
	
	export proc void WoundMortally(CObjHndl p_xSource, int p_iSource, int p_iLevel, real p_fDmg)
		var real fDiv=15.0f;
		var int iCounter=90;
		switch(p_iLevel)
			case(1)do fDiv=12.0; iCounter=80; endcase;
			case(2)do fDiv=11.0; iCounter=70; endcase;
			case(3)do fDiv=10.0; iCounter=60; endcase;
			case(4)do fDiv=9.0; iCounter=50; endcase;
			case default do endcase;
		endswitch;
		var int iMax=iCounter*(p_iLevel+2);
		var real fIncrease=Math.Round(p_fDmg/fDiv);
//		var real fDamage=Math.Round(p_fDmg/fDiv);
		var real fDamage=fIncrease*2.0;
		var bool bFound=true;
		switch(p_iSource)
			case(-1)do m_xLethalWoundZero.InflictWound(fDamage, iCounter, fIncrease, p_xSource, p_iSource, iMax); endcase;
			case(0)do m_xLethalWoundOne.InflictWound(fDamage, iCounter, fIncrease, p_xSource, p_iSource, iMax); endcase;
			case(1)do m_xLethalWoundTwo.InflictWound(fDamage, iCounter, fIncrease, p_xSource, p_iSource, iMax); endcase;
			case(2)do m_xLethalWoundThree.InflictWound(fDamage, iCounter, fIncrease, p_xSource, p_iSource, iMax); endcase;
			case(3)do m_xLethalWoundFour.InflictWound(fDamage, iCounter, fIncrease, p_xSource, p_iSource, iMax); endcase;
			case(4)do m_xLethalWoundFive.InflictWound(fDamage, iCounter, fIncrease, p_xSource, p_iSource, iMax); endcase;
			case(5)do m_xLethalWoundSix.InflictWound(fDamage, iCounter, fIncrease, p_xSource, p_iSource, iMax); endcase;
			case(6)do m_xLethalWoundSeven.InflictWound(fDamage, iCounter, fIncrease, p_xSource, p_iSource, iMax); endcase;
			case(7)do m_xLethalWoundEight.InflictWound(fDamage, iCounter, fIncrease, p_xSource, p_iSource, iMax); endcase;
			case default do bFound=false; endcase;
		endswitch;
//		if(!bFound)then return; endif;
//		var CObjHndl xHndl=AddFX("Allosaurus_Sm_Scrunch_Fx",-1.0);
//		if(xHndl.IsValid())then
//			var CFourCC xLink;
//			xHndl.GetObj()^.LinkAction(GetHandle(),xLink);
//		endif;
	endproc
	
//	export proc void LethalWoundCured(int p_iID)
//		switch(p_iID)
//			case(0)do m_xLethalWoundZero.Reset(); endcase;
//			case(1)do m_xLethalWoundOne.Reset(); endcase;
//			case(2)do m_xLethalWoundTwo.Reset(); endcase;
//			case(3)do m_xLethalWoundThree.Reset(); endcase;
//			case(4)do m_xLethalWoundFour.Reset(); endcase;
//			case(5)do m_xLethalWoundFive.Reset(); endcase;
//			case(6)do m_xLethalWoundSix.Reset(); endcase;
//			case(7)do m_xLethalWoundSeven.Reset(); endcase;
//			case(8)do m_xLethalWoundEight.Reset(); endcase;
//			case default do endcase;
//		endswitch;
//	endproc;
	
	export proc void Purification()
		ResetDamagePortion();
		SetHitpoints(GetMaxHitpoints());
		PourMagicalBalmUponLethalWounds();
		Detoxification();
		FullHeal();
	endproc;
	
	export proc void FullRestoration()
		ResetDamagePortion();
		SetHitpoints(GetMaxHitpoints());
		PourMagicalBalmUponLethalWounds();
		Detoxification();
		FullHeal();
		var ^CAttribs pxA=GetAttribs();
		if(pxA==null)then return; endif;
		UpdateDestructionFlags();
		var ^CBuilding pxB=cast<CBuilding>(this);
		if(pxB!=null&&!pxB^.IsReady())then
			pxA^.SetValue("CurTask","none");
			pxA^.SetValue("CurProcessObj","");
			pxA^.SetValue("CurProcess",0);
			pxA^.SetValue("ReadyForWork",1);
			pxB^.SetReadyBuild();
		endif;
	endproc;
	
	export proc void PourMagicalBalmUponLethalWounds()
		m_xLethalWoundZero.Reset();
		m_xLethalWoundOne.Reset();
		m_xLethalWoundTwo.Reset();
		m_xLethalWoundThree.Reset();
		m_xLethalWoundFour.Reset();
		m_xLethalWoundFive.Reset();
		m_xLethalWoundSix.Reset();
		m_xLethalWoundSeven.Reset();
		m_xLethalWoundEight.Reset();
//		RemoveFX("Allosaurus_Sm_Scrunch_Fx");
	endproc;
	
	export proc void WoundDamage(real p_fDamage, CObjHndl p_xLE, int p_iLE)
		if(m_bGodMode)then return;endif;
		if(m_bSlaveInvincible)then return;endif;
		if(m_bLevelUpInvulnerable)then return; endif;
		//Henry: to make unit invincible in other cases as well
		if(m_bStolen)then return; endif;
		if(m_bFountainHealed||m_bResurrectSafety)then return; endif;
		if(GetType()=="ANML"&&HasTimer(TIMER_SANCTIFICATION))then
			DeleteTimer(TIMER_SANCTIFICATION);
			if(!IsInFight())then
				CreateTimer(TIMER_SANCTIFICATION, CGameTimeSpan.OneSecond() * 5.0, false);
			endif;
		endif;
		m_iLastDamage=p_iLE;
		m_xLastEnemy=p_xLE;
//		SpreadDamage(p_fDamage);
		if(m_bBloodInfect)then
			p_fDamage*=2.0f;
		endif;
		HPReduction(Math.Max(Math.Ceil(p_fDamage*m_fDefenseFactor),1.0), p_iLE);
	endproc;
	
	export proc void DoTaskAnim(string p_sName)
		return;
	endproc;
	
	export proc void StealResis(int p_iPlayer,CObjHndl p_xEnemy, ref bool p_rbEventStream)
		var ^CBasePlayer pxEnemy=CBasePlayer.GetPlayer(p_iPlayer), pxOwn=CBasePlayer.GetPlayer(GetOwner());
		if(pxEnemy==null||pxOwn==null||!p_xEnemy.IsValid())then return; endif;
		var ^CTechTree.CNode pxLimitsNode=m_xTechTree.FindNode(GetObjPath()+"/UpdateLimits");
		var int iFood=0,iWood=0,iStone=0;
		if(pxLimitsNode==null)then
			if(IsTradeUnit())then
				GetLastResis(iFood,iWood,iStone);
				iFood=Math.Clamp(iFood*2, 0, pxOwn^.GetFood());
				iWood=Math.Clamp(iWood*2, 0, pxOwn^.GetWood());
				iStone=Math.Clamp(iStone*2, 0, pxOwn^.GetStone());
			else
				return;
			endif;
		else
			iFood=Math.Clamp(pxLimitsNode^.GetSubValueI("max_food",0), 0, pxOwn^.GetFood());
			iWood=Math.Clamp(pxLimitsNode^.GetSubValueI("max_wood",0), 0, pxOwn^.GetWood());
			iStone=Math.Clamp(pxLimitsNode^.GetSubValueI("max_stone",0), 0, pxOwn^.GetStone());
		endif;
		if(iFood==0&&iWood==0&&iStone==0)then return; endif;
		iFood-=(pxEnemy^.AddResource("food",iFood.ToReal(),false)).ToInt();
		iWood-=(pxEnemy^.AddResource("wood",iWood.ToReal(),false)).ToInt();
		iStone-=(pxEnemy^.AddResource("stone",iStone.ToReal(),false)).ToInt();
//		fFood*=-1.0;
//		pxEnemy^.AddFood(iFood);
		pxOwn^.AddFood((iFood*(-1)));
//		pxEnemy^.AddWood(iWood);
		pxOwn^.AddWood((iWood*(-1)));
//		pxEnemy^.AddStone(iStone);
		pxOwn^.AddStone((iStone*(-1)));
		var string sPlayerName="unknown";
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel!=null)then
			sPlayerName=pxLevel^.GetLevelInfo().GetPlayerSlot(pxEnemy^.GetPlayerSlotID()).GetName();
		endif;
		if(sPlayerName!="unknown")then
			CFeedback.Print(GetOwner(), CFeedback.ATTACK, "_MIRAGE_NT_ResourcesStolen\t"+sPlayerName);
		endif;
		pxOwn^.IWasAttacked(GetHandle(), p_xEnemy, false);
		p_rbEventStream=false;
	endproc;
	
	export proc bool CouldBeStolen(^CFightingObj p_pxTamer)
		return false;
	endproc;
	
	export proc void PlayerRevealed(bool p_bYes)
		m_bPlayerRevealed=p_bYes;
		SetRevealState(p_bYes);
		var array CFightingObj.CCamouflageLayer axLayers;
		axLayers=3;
		axLayers[0].SetType("entr");
		axLayers[1].SetType("disg");
		axLayers[2].SetType("feign");
//		axLayers[3].SetType("");
		var int i, iC=axLayers.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var int iIdx=m_axCamouflageLayers.FindEntry(axLayers[i]);
			if(iIdx!=-1&&m_axCamouflageLayers[iIdx].IsValid())then
				m_axCamouflageLayers[iIdx].SetDisabled(m_bPlayerRevealed);
			endif;
		endfor;
		UpdateCamouflageLayers();
	endproc
	
	export proc bool IsBaby()
		return false;
	endproc;
	
//	export proc void RotIdleAnim()
//	endproc;
	
	export proc bool HasOpenBuildUp()
		return false;
	endproc;
	
	export proc bool HasTransportBuildUp()
		return false;
	endproc;
	
	export proc bool ShallBeResurrectable()
		if(CMirageSrvMgr.Get().DisableSpirits())then return false; endif;
		if(m_bSpiritCreated)then
			return false;
		endif;
		var bool bCreateSprit=false;
		var CFourCC xType=GetType();
//		if((xType=="CHTR"||xType=="ANML")&&GetOwner()!=-1&&GetClassName()!="Barry_s0"&&GetClassName()!="Harry_s0"&&!GetTamed())then
		if((xType=="CHTR"||xType=="ANML"||xType=="SHIP")&&GetOwner()!=-1&&GetClassName()!="Barry_s0"&&GetClassName()!="Harry_s0")then
			var ^CAttribs pxAttr=GetAttribs();
			if(pxAttr!=null)then
				if(pxAttr^.GetValue("illusion")=="1")then
					bCreateSprit=false;
				else
					bCreateSprit=true;
				endif;
			endif;
			if(xType=="SHIP"&&m_xTechTree.GetValueR(GetObjPath()+"/spirit_life",0.0f)<=0.0f)then
				bCreateSprit=false;
			endif;
			if(cast<CHero>(this)!=null||GetClassName()=="special_eusmilus"||GetClassName()=="Miyagi_s0"/*||GetClassName()=="special_baryonyx"*/)then
				var ^CLevelInfoHost pxLevelInfo=^(CSrvWrap.GetCurLevel()^.GetLevelInfo());
				if(pxLevelInfo==null)then
					if(CMirageSrvMgr.Get().HeroPool()||!pxLevelInfo^.IsMultiplayer())then
						bCreateSprit=false;
					endif
				endif
			endif;
		endif;
		m_bSpiritCreated=true;
		return bCreateSprit;
	endproc;
	
	export proc void UpdateTribeName()
		var ^CAttribs pxAttribs=GetAttribs();
		if(pxAttribs==null)then return; endif;
		var string sTribe=pxAttribs^.GetValue("tribe");
		if(sTribe=="")then
			if(m_sTribe.IsEmpty())then
				m_sTribe=GetPlayerTribeName();
			endif;
			pxAttribs^.SetValue("tribe",m_sTribe);
		else
			m_sTribe=sTribe;
		endif;
	endproc;
	
	export proc void SetHunting(bool p_bHunting)
		return;
	endproc;
	
	export proc bool IsHunting()
		return false;
	endproc;
	
	export proc real GetAdaption()
		return 1.0f;
	endproc;
	
	export proc void DoChopAnim()
		AnimAction("attack_front");
	endproc;
	
	export proc string EatAnim()
		return "standanim";
	endproc;
	
	export proc bool IsBugged()
		return false;
	endproc;
	
	export proc bool IsCarnivore()
		return false;
	endproc;
	
	export proc bool IsHerbivore()
		return false;
	endproc;
	
	export proc void SetBloodInfection(bool p_bOn, real p_fDuration)
		m_bBloodInfect=p_bOn;
		if(HasTimer(TIMER_NO_HEALING))then
			DeleteTimer(TIMER_NO_HEALING);
		endif;
		if(p_bOn&&p_fDuration>0.0)then
			CreateTimer(TIMER_NO_HEALING, CGameTimeSpan.OneSecond()*p_fDuration, false);
		endif;
	endproc;
	
	export proc void OneHitKilling(int p_iPlayer, CObjHndl p_xEnemy)
		if(m_bGodMode||m_bCeaseFire)then return;endif;
		if(m_bSlaveInvincible)then return; endif;
		m_iLastDamage=p_iPlayer;
		m_xLastEnemy=p_xEnemy;
		if(m_bDivideSkulls)then
			(m_afDamagePortion[p_iPlayer])+=GetHitpoints();
		endif;
//		SetDyingInTPO(GetTransportObj().IsValid());
		m_bPassingAway=GetTransportObj().IsValid();
		OnKill();
		Die();
	endproc;
	
	export proc void OneHitKillingSilent(int p_iPlayer, CObjHndl p_xEnemy, bool p_bSkipCorpse)
		if(m_bGodMode)then return; endif;
		if(m_bSlaveInvincible)then return; endif;
		m_bNoCorpse=p_bSkipCorpse;
		m_iLastDamage=p_iPlayer;
		m_xLastEnemy=p_xEnemy;
		if(m_bDivideSkulls)then
			(m_afDamagePortion[p_iPlayer])+=GetHitpoints();
		endif;
		m_bPassingAway=GetTransportObj().IsValid();
		DieFastAndSilent();
	endproc;
	
	export proc void SetPinnedDown(bool p_bOn, real p_fDuration)
		m_bPinnedDown=p_bOn;
		if(HasTimer(TIMER_PINNED_DOWN))then
			DeleteTimer(TIMER_PINNED_DOWN);
		endif;
		if(p_bOn&&p_fDuration>0.0)then
			CreateTimer(TIMER_PINNED_DOWN, CGameTimeSpan.OneSecond()*p_fDuration, false);
		endif;
		var bool bStart=false;
		var vec3 vP;
		if(HasWalkAction())then
			bStart=true;
			vP=GetCurWalkTarget();
		endif;
		UpdateSpeed();
		if(bStart)then
			WalkAction(vP,GetMaxSpeed());
		endif;
	endproc;
	
	export proc void SetBrokenLegs(bool p_bOn, real p_fDuration)
		m_bBrokenLegs=p_bOn;
		if(HasTimer(TIMER_BROKEN_LEGS))then
			DeleteTimer(TIMER_BROKEN_LEGS);
		endif;
		if(p_bOn&&p_fDuration>0.0)then
			CreateTimer(TIMER_BROKEN_LEGS, CGameTimeSpan.OneSecond()*p_fDuration, false);
		endif;
		var bool bStart=false;
		var vec3 vP;
		if(HasWalkAction())then
			bStart=true;
			vP=GetCurWalkTarget();
		endif;
		UpdateSpeed();
		if(bStart)then
			WalkAction(vP,GetMaxSpeed());
		endif;
	endproc;
	
	export proc void SetTurtleOnLand(bool p_bOn)
		m_bTurtleOnLand=p_bOn;
		var bool bStart=false;
		var vec3 vP;
		if(HasWalkAction())then
			bStart=true;
			vP=GetCurWalkTarget();
		endif;
		UpdateSpeed();
		if(bStart)then
			//TerminateAction(); Stack overflow exception
			WalkAction(vP,GetMaxSpeed());
		endif;
	endproc;
	
	export proc void SetSpeedRun(bool p_bOn, real p_fDuration, string p_sFilter)
		if(HasTimer(TIMER_SPEED_RUN))then
			DeleteTimer(TIMER_SPEED_RUN);
		endif;
		if(p_bOn&&p_fDuration>0.0)then
			CreateTimer(TIMER_SPEED_RUN, CGameTimeSpan.OneSecond()*p_fDuration, false);
		endif;
		var ^CTechTreeDef pxDef=GetTechTreeDef();
		if(pxDef!=null)then
			if(p_bOn&&!pxDef^.HasFilter(p_sFilter))then
				pxDef^.EnableFilter(p_sFilter);
			elseif(!p_bOn&&pxDef^.HasFilter(p_sFilter))then
				pxDef^.DisableFilter(p_sFilter);
			endif;
		endif;
		var bool bStart=false;
		var vec3 vP;
		if(HasWalkAction())then
			bStart=true;
			vP=GetCurWalkTarget();
		endif;
		UpdateSpeed();
		if(bStart)then
			UpdateAggressionPos(vP);
			WalkAction(vP,GetMaxSpeed());
		endif;
	endproc;
	
	export proc void SetShattered(bool p_bOn, real p_fDuration)
		m_bShattered=p_bOn;
		if(HasTimer(TIMER_SHATTERED))then
			DeleteTimer(TIMER_SHATTERED);
		endif;
		if(p_bOn&&p_fDuration>0.0)then
			CreateTimer(TIMER_SHATTERED, CGameTimeSpan.OneSecond()*p_fDuration, false);
		endif;
		ForceGeneralUpdate();
		m_bOwnWeaponHasChanged=true;
	endproc;
	
	export proc void SetLacerated(bool p_bOn, real p_fDuration)
		m_bLacered=p_bOn;
		if(HasTimer(TIMER_LACERED))then
			DeleteTimer(TIMER_LACERED);
		endif;
		if(p_bOn&&p_fDuration>0.0)then
			CreateTimer(TIMER_LACERED, CGameTimeSpan.OneSecond()*p_fDuration, false);
		endif;
		ForceGeneralUpdate();
		m_bOwnWeaponHasChanged=true;
	endproc;
	
	export proc void SetSundered(bool p_bOn, real p_fDuration)
		m_bSundered=p_bOn;
		if(HasTimer(TIMER_SUNDERED))then
			DeleteTimer(TIMER_SUNDERED);
		endif;
		if(p_bOn&&p_fDuration>0.0)then
			CreateTimer(TIMER_SUNDERED, CGameTimeSpan.OneSecond()*p_fDuration, false);
		endif;
		ForceGeneralUpdate();
		m_bOwnWeaponHasChanged=true;
	endproc;
	
	export proc void SetBlinded(bool p_bOn, real p_fDuration)
		m_bBlinded=p_bOn;
		if(HasTimer(TIMER_BLINDNESS))then
			DeleteTimer(TIMER_BLINDNESS);
		endif;
		if(p_bOn&&p_fDuration>0.0)then
			CreateTimer(TIMER_BLINDNESS, CGameTimeSpan.OneSecond()*p_fDuration, false);
		endif;
		UpdateFOW();
		ForceGeneralUpdate();
	endproc;
	
	export proc void SetInsected(bool p_bOn, real p_fDuration)
		RemoveFX("insects_fx");
//		if(HasTimer(TIMER_INSECTS_FX))then DeleteTimer(TIMER_INSECTS_FX); endif;
		SetPinnedDown(p_bOn,p_fDuration);
		SetSedated(p_bOn,p_fDuration);
		SetBlinded(p_bOn,p_fDuration);
		if(p_bOn)then
//			CreateTimer(TIMER_INSECTS_FX, CGameTimeSpan.OneSecond() * p_fDuration, true);
			var CFourCC xLink="NONE";
			var CObjHndl xInsects=AddFX("insects_fx",p_fDuration+1.0);
			if(xInsects.IsValid())then
				xInsects.GetObj()^.LinkAction(GetHandle(),xLink);
			endif;
		endif;
	endproc;
	
	export proc void SetDeafened(bool p_bOn, real p_fDuration)
		m_bDeafened=p_bOn;
		if(HasTimer(TIMER_DEAFENED))then
			DeleteTimer(TIMER_DEAFENED);
		endif;
		if(p_bOn&&p_fDuration>0.0)then
			CreateTimer(TIMER_DEAFENED, CGameTimeSpan.OneSecond()*p_fDuration, false);
		endif;
	endproc;
	
	export proc void SetMarkedForDeath(bool p_bOn, real p_fDuration)
		m_bMarkedForDeath=p_bOn;
		if(HasTimer(MARKED_FOR_DEATH))then
			DeleteTimer(MARKED_FOR_DEATH);
		endif;
		if(p_bOn&&p_fDuration>0.0)then
			CreateTimer(MARKED_FOR_DEATH, CGameTimeSpan.OneSecond()*p_fDuration, false);
		endif;
		ForceGeneralUpdate();
	endproc;
	
	export proc void SetCyborgEffect(bool p_bOn, real p_fDuration)
		m_bCyborgBonus=p_bOn;
		if(HasTimer(RALLY_ROAR))then
			DeleteTimer(RALLY_ROAR);
		endif;
		if(p_bOn&&p_fDuration>0.0)then
			CreateTimer(RALLY_ROAR, CGameTimeSpan.OneSecond()*p_fDuration, false);
		endif;
		ForceGeneralUpdate();
	endproc;
	
	export proc void SetTitanDefense(bool p_bOn, real p_fDuration)
		m_bTitanDefense=p_bOn;
		if(HasTimer(DEFENSE_SHAKE))then
			DeleteTimer(DEFENSE_SHAKE);
		endif;
		if(p_bOn&&p_fDuration>0.0)then
			CreateTimer(DEFENSE_SHAKE, CGameTimeSpan.OneSecond()*p_fDuration, false);
		endif;
		ForceGeneralUpdate();
	endproc;
	
	export proc void ActivateExplosiveRounds(bool p_bOn)
		if(GetClassName()!="seas_lumberjack_minigun")then return; endif;
		m_bExplosiveRounds=p_bOn;
		var ^CTechTreeDef pxDef=GetTechTreeDef();
		if(pxDef==null)then return; endif;
		if(p_bOn)then
			pxDef^.EnableFilter(CLumberjack.EXPLOSIVES_ROUNDS);
			var CFourCC xLink="FIRE";
			var CObjHndl xFire=AddFX("titan_fire",-1.0);
			if(xFire.IsValid())then
				xFire.GetObj()^.LinkAction(GetHandle(),xLink);
			endif;
			if(HasTimer(ID_EXPLOSIVES_ROUNDS))then DeleteTimer(ID_EXPLOSIVES_ROUNDS); endif;
			CreateTimer(ID_EXPLOSIVES_ROUNDS, CGameTimeSpan.OneSecond() * 1.0, true);
		else
			pxDef^.DisableFilter(CLumberjack.EXPLOSIVES_ROUNDS);
			RemoveFX("titan_fire");
			if(HasTimer(ID_EXPLOSIVES_ROUNDS))then DeleteTimer(ID_EXPLOSIVES_ROUNDS); endif;
			AddSpecialActionTimer("Actions/SEAS/Moves/VHCL/explosives_rounds");
		endif;
		ForceGeneralUpdate();
	endproc;
	
	export proc void ActivateJetpack(bool p_bOn)
		if(GetClassName()!="hu_jetpack_warrior")then return; endif;
		m_bJetpack=p_bOn;
		var ^CTechTreeDef pxDef=GetTechTreeDef();
		if(pxDef==null)then return; endif;
		if(p_bOn)then
			pxDef^.EnableFilter(CHu.JETPACK_FLYING);
		else
			pxDef^.DisableFilter(CHu.JETPACK_FLYING);
		endif;
	endproc;
	
	export proc void SetFireworkEffect(bool p_bOn, real p_fDuration)
		m_bFirework=p_bOn;
		if(HasTimer(TIMER_FIREWORK))then
			DeleteTimer(TIMER_FIREWORK);
		endif;
		var CFightingObj.CCamouflageLayer xLayer;
		xLayer.SetType("smok");
		var int iIdx=m_axCamouflageLayers.FindEntry(xLayer);
		if(iIdx!=-1&&m_axCamouflageLayers[iIdx].IsValid())then
			m_axCamouflageLayers[iIdx].SetRevealed(p_bOn);
			UpdateCamouflageLayers();
		endif;
		if(!p_bOn&&CanDisguise())then
			ResetCamouflageTimer();
			AddCamouflageEffect("disg");
		elseif(p_bOn&&p_fDuration>0.0)then
			CreateTimer(TIMER_FIREWORK, CGameTimeSpan.OneSecond()*p_fDuration, false);
		endif;
	endproc;
	
	export proc void SetPeaceTime(bool p_bOn, real p_fDuration)
		if(m_bCeaseFire&&!p_bOn)then
			RemoveRangedBuff("peace_gong");
		endif;
		var string sFX = "fx_stina_hypnosis_big";
		RemoveFX(sFX);
		m_bCeaseFire=p_bOn;
		var ^CAttribs pxA=GetAttribs();
		if(pxA!=null)then
			pxA^.SetValue("peace_time",p_bOn);
		endif;
		if(HasTimer(CEASE_FIRE))then
			DeleteTimer(CEASE_FIRE);
		endif;
		if(p_bOn)then
			AddRangedBuff("peace_gong");
			var CObjHndl xHndl = AddFX(sFX,p_fDuration);
			if(xHndl.IsValid())then
				var CFourCC xLink;
				xHndl.GetObj()^.LinkAction(GetHandle(),xLink,{0.0,0.0,3.0});
			endif;
		else
			PreCheckForEnemies();
		endif;
		if(p_bOn&&p_fDuration>0.0)then
			CreateTimer(CEASE_FIRE, CGameTimeSpan.OneSecond()*p_fDuration, false);
		endif;
		CheckEnemyValidity();
		CheckFighterValidity();
	endproc;
	
	export proc void SetUnboard(bool p_bOn, real p_fDuration)
		if(GetTransportClass()<1)then return; endif;
		var real fScapeZ=CSrvWrap.GetScapeMgr().GetHeight(GetPosX(), GetPosY());
		var real fSea=CSrvWrap.GetScapeMgr().GetSeaLevel();
		if(fScapeZ+5.0f<fSea)then return; endif;
		var ^CAttribs pxAttr=GetAttribs();
		var string sFX="Deathping_Char_Fx";
		if(m_bUnboard&&!p_bOn)then
			RemoveFX(sFX);
			RemoveRangedBuff("deplenish");
		endif;
		m_bUnboard=p_bOn;
		if(HasTimer(UNBOARD_CURSE))then
			DeleteTimer(UNBOARD_CURSE);
		endif;
		if(p_bOn)then
			Evacuate();
			AddRangedBuff("deplenish");
			if(pxAttr!=null&&pxAttr^.GetValueInt("is_cursed")!=1)then
				pxAttr^.SetValue("is_cursed",1);
			endif;
			var CObjHndl xHndl=AddFX(sFX,p_fDuration);
			if(xHndl.IsValid())then
				var CFourCC xLink;
				xHndl.GetObj()^.LinkAction(GetHandle(),xLink,{0.0,0.0,3.0});
			endif;
		else
			if(pxAttr!=null&&pxAttr^.GetValueInt("is_cursed")!=0)then
				pxAttr^.SetValue("is_cursed",0);
			endif;
		endif;
		if(p_bOn&&p_fDuration>0.0)then
			CreateTimer(UNBOARD_CURSE, CGameTimeSpan.OneSecond()*p_fDuration, false);
		endif;
	endproc;
	
	export proc void SetFroozenEffect(bool p_bOn)
		if(m_bFrozen!=p_bOn)then
			m_bFrozen=p_bOn;
			ForceGeneralUpdate();
		endif;
	endproc;
	
	export proc void StimUnit(bool p_bOn)
		var ^CTechTreeDef pxDef=GetTechTreeDef();
		if(pxDef!=null)then
			if(p_bOn&&!m_bStimpack)then
				pxDef^.EnableFilter(CSEAS.STIMPACK);
			elseif(m_bStimpack&&!p_bOn)then
				pxDef^.DisableFilter(CSEAS.STIMPACK);
			endif;
		endif;
		m_bStimpack=p_bOn;
		ForceGeneralUpdate();
	endproc;
	
	export proc bool IsActionPaused()
		return false;
	endproc;
	
	export proc bool CountInStatistic()
		return true;
	endproc
	
	export proc void AddItemSilent(CObjHndl p_xItem)
		var ^CInventory pxInv=GetInventory();
		if(pxInv==null)then return; endif;
		var ^CItem pxItem=cast<CItem>(p_xItem.GetObj());
		if(pxItem==null)then return; endif;
		if(!CArtifactMgr.Get().AddArtifact(GetOwner(),p_xItem))then return; endif;
		pxInv^.AddItem(pxItem^.GetHandle());
		var CFourCC xLink="INVE";
		pxItem^.LinkAction(GetHandle(), xLink);
		pxItem^.SetVisible(false);
		pxItem^.OnTakeItem(this,"Silent!");
		AddItemName(pxItem^.GetName());
	endproc;
	
	export proc void RemoveItemSilent(CObjHndl p_xItem)
		var ^CInventory pxInv=GetInventory();
		if(pxInv==null)then return; endif;
		var ^CItem pxItem=cast<CItem>(p_xItem.GetObj());
		if(pxItem==null)then return; endif;
		if(!CArtifactMgr.Get().RemoveArtifact(GetOwner(),p_xItem))then /*Do Nothing*/; endif;
		pxInv^.RemItem(pxItem^.GetHandle());
		pxItem^.OnDroppedItem(this,false,"Silent!",false);
		pxItem^.TerminateAction();
		AddItemName("");
	endproc;
	
	export proc void StealItem(CObjHndl p_xItem)
		var ^CInventory pxInv=GetInventory();
		if(pxInv==null)then return; endif;
		var ^CItem pxItem=cast<CItem>(p_xItem.GetObj());
		if(pxItem==null)then return; endif;
		if(!CArtifactMgr.Get().AddArtifact(GetOwner(),p_xItem))then return; endif;
		pxInv^.AddItem(pxItem^.GetHandle());
		var CFourCC xLink="INVE";
		pxItem^.LinkAction(GetHandle(), xLink);
		pxItem^.SetVisible(false);
		pxItem^.OnTakeItem(this,"Steal");
		AddItemName(pxItem^.GetName());
		InvokeGenericSCEvent(38,0.6f);
	endproc;
	
	export proc void LoseItem(CObjHndl p_xItem)
		var ^CInventory pxInv=GetInventory();
		if(pxInv==null)then return; endif;
		var ^CItem pxItem=cast<CItem>(p_xItem.GetObj());
		if(pxItem==null)then return; endif;
		if(!CArtifactMgr.Get().RemoveArtifact(GetOwner(),p_xItem))then /*Do Nothing*/; endif;
		pxInv^.RemItem(pxItem^.GetHandle());
		pxItem^.OnDroppedItem(this,false,"Steal",false);
		pxItem^.TerminateAction();
		AddItemName("");
	endproc;
	
	export proc CObjHndl GetLastEnemy()
		return m_xLastEnemy;
	endproc;
	
	export proc void RecycledByUpgrade()
//		SetDyingInTPO(GetTransportObj().IsValid());
		m_bPassingAway=GetTransportObj().IsValid();
		if(!IsDead())then
			SetDead(true);
			var ^CAttribs pxAttr=GetAttribs();
			if(HasTimer(TIMER_WALKING_BOMB))then DeleteTimer(TIMER_WALKING_BOMB); endif;
			if(m_xTransportObj.IsValid())then
				var ^CTransportObj pxObj=cast<CTransportObj>(m_xTransportObj.GetObj());
				if(pxObj!=null)then
					pxObj^.OnDismount(GetHandle(),true,GetPos());
				endif;
				var ^CBunker pxBunker=cast<CBunker>(m_xTransportObj.GetObj());
				if(pxBunker!=null)then
					pxBunker^.RemChar(GetHandle());
				endif;
				var ^CSeasFortress pxFortress=cast<CSeasFortress>(m_xTransportObj.GetObj());
				if(pxFortress!=null)then
					pxFortress^.RemChar(GetHandle());
				endif;
			endif;
			if(m_xProduceUnit.IsValid())then
				var ^CVirtualProduceUnit pxO=cast<CVirtualProduceUnit>(m_xProduceUnit.GetObj());
				if(pxO!=null)then pxO^.Die(); endif;
				m_xProduceUnit.FromInt(-1);
			endif;
			if(m_xReactor.IsValid())then
				var ^CVirtualProduceUnit pxO=cast<CVirtualProduceUnit>(m_xReactor.GetObj());
				if(pxO!=null)then pxO^.Die(); endif;
				m_xReactor.FromInt(-1);
			endif;
			if(m_xHiveMind.IsValid())then
				var ^CHiveMind pxO=cast<CHiveMind>(m_xHiveMind.GetObj());
				if(pxO!=null)then pxO^.Delete(); endif;
				m_xHiveMind.FromInt(-1);
				m_iCmdID=m_iOwnerID;
			endif;
			m_fHitpoints=0.0f;
			var int ik=m_axParasites.NumEntries();
			if(ik>0)then
				var int iKC=ik;
				for(ik=0)cond(ik<iKC)iter(ik++)do
					var CObjHndl xParasite=m_axParasites[ik];
					if(xParasite.IsValid())then
						var ^CParasite pxParasite=cast<CParasite>(xParasite.GetObj());
						if(pxParasite!=null)then
							pxParasite^.Removement();
							m_axParasites.DeleteEntry(ik);
							ik--;iKC--;
						endif;
					endif;
				endfor
			endif;
			if(m_xGroup.IsValid())then
				var ^CGroupObj pxGroup=cast<CGroupObj>(m_xGroup.GetObj());
				if(pxGroup!=null)then
					pxGroup^.RemMember(GetHandle());
				endif;
			endif;
			var ^CInventory pxInv=GetInventory();
			if(pxInv!=null)then
				var int i, iC=pxInv^.Count();
				var CObjList xList;
				for(i=0) cond(i<iC) iter(++i)do
					if(!pxInv^.GetItem(i).IsValid())then continue; endif;
					xList.Include(pxInv^.GetItem(i));
				endfor;
				iC=xList.NumEntries();
				for(i=0)cond(i<iC)iter(i++)do
					if(xList[i].IsValid())then
						var ^CGameObj pxItem=xList[i].GetObj();
						var ^CItem pxI=cast<CItem>(pxItem);
						if(pxI!=null)then
							RemoveItem(pxI^.GetHandle());
						endif;
					endif;
				endfor;
				pxInv^.Clear();
			endif;
			if(m_pxTaskMgr!=null)then
				m_pxTaskMgr^.BreakAll();
			endif;
			ClearFX();
			super.Delete();
		endif;
	endproc;
	
	export proc void ActivateCustomFilterAndUpdate(bool p_bOn,string p_sFilter)
		var ^CTechTreeDef pxDef=GetTechTreeDef();
		if(pxDef!=null)then
			if(p_bOn&&!pxDef^.HasFilter(p_sFilter))then
				pxDef^.EnableFilter(p_sFilter);
			elseif(!p_bOn&&pxDef^.HasFilter(p_sFilter))then
				pxDef^.DisableFilter(p_sFilter);
			endif;
		endif;
		ForceGeneralUpdate();
		m_bOwnWeaponHasChanged=true;
	endproc;
	
	export proc int GetPQENO() // Henry: prod queue num entries own
		return m_iPQNEO;
	endproc;
	
	export proc int GetPQENR() // Henry: prod queue num entries reactor
		return m_iPQNER;
	endproc;
	
	export proc void SetPTO(CObjHndl p_xHndl)
		m_xPotentialTransportObject=p_xHndl;
	endproc;
	
	export proc CObjHndl GetPTO()
		return m_xPotentialTransportObject;
	endproc;
	
	export proc int NumPassengers()
		return 0;
	endproc;
	
	export proc bool LiquidationFinished(ref int p_riNum,int p_iLastDamage,CObjHndl p_xLastEnemy)
		return true;
	endproc;
	
	export proc vec3 GetPosInMap(vec3 p_vPos)
		var vec3 vNew=p_vPos;
		var real fX=Math.Clamp(vNew.GetX(),128.0,m_fMapWidth),fY=Math.Clamp(vNew.GetY(),128.0,m_fMapHeight);
		vNew.SetX(fX); vNew.SetY(fY);
		return vNew;
	endproc;
	
	export proc bool IsInvisible()
		return GetVisibleMask()==0h;
	endproc;
	
	export proc real GetCorruptionRadius()
		var ^CFightingObj.CSpecialAbility pxA=m_xAbilities.GetAbility("corruption", true);
		var real fValue=-1.0;
		if(pxA!=null)then
			fValue=pxA^.GetValueF("radius");
		endif;
		return fValue;
	endproc;
	
	export proc real GetCorruptionAmount(^CFightingObj p_pxTarget)
		var ^CFightingObj.CSpecialAbility pxA=m_xAbilities.GetAbility("corruption", true);
		if(pxA==null)then return 0.0; endif;
		var real fMod=p_pxTarget^.GetMaxHitpoints()*pxA^.GetValueF("mod")*0.01;
		var real fAmount=pxA^.GetValueF("amount");
		return fAmount+fMod;
	endproc;
	
	export proc real GetCorruptionAmount()
		var ^CFightingObj.CSpecialAbility pxA=m_xAbilities.GetAbility("corruption", true);
		if(pxA==null)then return 0.0; endif;
		return pxA^.GetValueF("amount");
	endproc;
	
	export proc void Corrupt(real p_fHitpoints)
		if(GetHitpoints()>1.0)then
			AddRangedBuff("is_getting_corrupted");
			DeleteTimer(TIMER_ISGETTINGCORRUPTED_FX);
			CreateTimer(TIMER_ISGETTINGCORRUPTED_FX,CGameTimeSpan.OneSecond()*2.5,false);
			var CObjHndl xHndl=AddFX("Downgrade_Animal_Fx",-1.0);
			var CFourCC xLink;
			if(xHndl.IsValid())then
				xHndl.GetObj()^.LinkAction(GetHandle(),xLink);
			endif;
			DeleteTimer(TIMER_ISGETTINGCORRUPTED);
			CreateTimer(TIMER_ISGETTINGCORRUPTED,CGameTimeSpan.OneSecond() * 2.5, false);
			SetHitpoints(Math.Max(GetHitpoints()-p_fHitpoints,1.0));
		endif;
	endproc;
	
	export proc void Intimidate(CObjHndl p_xInt, real p_fDuration)
		SetIntimidate(p_xInt);
		if(HasTimer(TIMER_INTIMIDATED))then
			DeleteTimer(TIMER_INTIMIDATED);
		endif;
		if(p_xInt.IsValid()&&p_fDuration>0.0)then
			CreateTimer(TIMER_INTIMIDATED, CGameTimeSpan.OneSecond()*p_fDuration, false);
		endif;
	endproc;
	
	export proc void PrepareToTeleporting(real p_fDuration)
		var CObjHndl xHndl=AddFX("pre_teleport_fx",p_fDuration);
		if(xHndl.IsValid())then
			var CFourCC xLink;
			xHndl.GetObj()^.LinkAction(GetHandle(),xLink);
			xHndl.GetObj()^.SetAnim("anim",3);
		endif;
	endproc;
	
	export proc bool GetBlinded()
		return m_bBlinded;
	endproc;
	
	export proc bool ReSetLevelClean(int p_iLevel)
		var ^CBasePlayer pxBPl=CBasePlayer.GetPlayer(m_iOwnerID);
		if(pxBPl==null)then return false; endif;
		if((p_iLevel<0)||(p_iLevel>4))then return false; endif;
		SetLevelFilter(false);
		SetLevelFilter(true);
		GetWeaponMgr()^.UpdateAll();
		OnTechTreeChange();
		return true;
	endproc;
	
	export proc bool IsItATrap()
		return false;
	endproc;
	
	export proc void OverSetTransportObj()
	endproc;
	
	export proc void UnSetTransportObj()
	endproc;
	
	export proc void LetLeavePassenger(CObjHndl p_xPassenger, int p_iEvent)
	endproc;
	
	export proc void UnMountEvent(CObjHndl p_xObj, int p_iEvent)
		if(p_xObj.IsValid())then
			p_xObj.GetObj()^.InvokeGenericSCEvent(p_iEvent,5.0f);
		endif;
	endproc;
	
	export proc string GetReportCode()
		return "";
	endproc;
	
	export proc real GetJawSize()
		return m_fJawSize;
	endproc;
	
	export proc real FeedFactor()
		return m_fFeedFactor;
	endproc;
	
	export proc void GameOverKill(int p_iSwitch)
		m_bGameOverKill=true;
//		SetDyingInTPO(GetTransportObj().IsValid());
		m_bPassingAway=GetTransportObj().IsValid();
		Die();
	endproc;
	
	export proc void UpdateRegion()
//	export proc void UpdateRegion(bool p_bAlliance,bool p_bHostility,int p_iPlayer)
		if(DeleteOwnRegion())then
			InitOwnRegion();
		endif; 
	endproc;
	
	export proc void DeleteVPU()
		if(m_xProduceUnit.IsValid())then
			var ^CVirtualProduceUnit pxO=cast<CVirtualProduceUnit>(m_xProduceUnit.GetObj());
			if(pxO!=null)then
				pxO^.Die();
			endif;
			m_xProduceUnit.FromInt(-1);
		endif;
	endproc;
	
	export proc void UpdateVPUFlags()
		var ^CTechTree.CNode pxFlags=m_xTechTree.FindNode(GetObjPath()+"/flags");
		if(pxFlags!=null)then
			var int i,iC=pxFlags^.NumSubs();
			var ^CAttribs pxAttr = GetAttribs();
			if(pxAttr!=null)then
				if(iC>0)then
					if(pxFlags^.GetSub(0)!=null)then
						m_sObjFlag=pxFlags^.GetSub(0)^.GetName();
						pxAttr^.SetValue("ObjFlag",pxFlags^.GetSub(0)^.GetName());
						if(GetProduceUnit().IsValid())then
							var ^CAttribs pxAttr=GetProduceUnit().GetObj()^.GetAttribs();
							if(pxAttr!=null)then
								pxAttr^.SetValue("ObjFlag",pxFlags^.GetSub(0)^.GetName());
							endif;
						endif;
					endif;
				else
					m_sObjFlag="";
					pxAttr^.SetValue("ObjFlag","");
				endif;
			endif;
		endif;
	endproc;
	
	export proc bool CheckLevelCondition(^CTechTree.CNode p_pxAction)
		if(p_pxAction==null)then return false; endif;
		var ^CTechTree.CNode pxCondNode=p_pxAction^.GetSub("conditions");
		if(pxCondNode==null)then return true; endif;
		if((pxCondNode^.GetSubValueI("level")-1)>GetLevel())then return false; endif;
		return true;
	endproc;
	
	export proc void SetAILock(bool p_bOn)
		m_bAILock=p_bOn;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("ai_lock",m_bAILock);
		endif;
	endproc;
	
	export proc bool GetAILock()
		return m_bAILock;
	endproc;
	
	export proc void AttackSrv(^CGameObj p_pxEnemy)
		if(m_iAggressionState==3)then return; endif;
		if(p_pxEnemy==null)then return; endif;
		if(IsDead())then return; endif;
		if(GetIncapacitated())then return; endif;
		Fight(p_pxEnemy,p_pxEnemy^.GetPos(),false,false);
	endproc;
	
	export proc void AggressiveSrv(vec3 p_vPos)
		if(m_iAggressionState==3)then return; endif;
		if(m_pxTaskMgr==null)then return; endif;
		var ^CTask pxTask=m_pxTaskMgr^.GetCurTask();
		if(pxTask!=null)then
			if(pxTask^.Break())then
				pxTask^.EndTask();
			endif;
		endif;
		UpdateAggressionPos(p_vPos);
		var array vec3 avPos; avPos.AddEntry(p_vPos);
		StartPatrol(avPos, 0, GetDefaultSpeed());
		CheckPatrol();
	endproc;
	
	export proc void CheckTeslaMachine(CObjHndl p_xRally)
		return;
	endproc;
	
	export proc void CheckDestination(CObjHndl p_xRally)
		return;
	endproc;
	
	export proc CObjHndl GetSpawnPos(ref vec3 p_rvPos,ref vec3 p_rvRot)
		return CObjHndl.Invalid();
	endproc;
	
	export proc CFightingObj.CBuildCosts GetBuildCosts()
		return m_xCosts;
	endproc;
	
	export proc void SetCosts(CAction.CResourceCosts p_xCosts)
		m_bCostsFromAction=true;
		m_xCosts=p_xCosts;
	endproc;
	
	export proc void UpdateCosts(CAction.CResourceCosts p_xCosts)
		if(!m_bCostsFromAction)then
			UpdateBuildCosts();
		endif;
		m_xCosts.Update(p_xCosts);
	endproc;
	
	export proc void UpdateBuildCosts()
		m_bCostsFromAction=true;
		var CTechTreeDef xTTDef;
		var ^CTechTreeMgr pxTTMgr=CSrvWrap.GetGame().GetTechTreeMgr();
		var CTechTree xTT=pxTTMgr^.GetTechTree(xTTDef);
		var ^CTechTree.CNode pxBuildAction=xTT.FindNode(GetBuildAction()+"/conditions");
		if(pxBuildAction==null)then
			return;
		endif;
		var ^CTechTree.CNode pxResCosts=pxBuildAction^.GetSub("rescosts");
		if(pxResCosts==null)then return; endif;
		m_xCosts.m_iWood=Math.Max(pxResCosts^.GetSubValueI("wood",0),0);
		m_xCosts.m_iStone=Math.Max(pxResCosts^.GetSubValueI("stone",0),0);
		m_xCosts.m_iFood=Math.Max(pxResCosts^.GetSubValueI("food",0),0);
		m_xCosts.m_iSkulls=Math.Max(pxResCosts^.GetSubValueI("iron",0),0);
	endproc;
	
	export proc void GetLastResis(ref int p_riFood, ref int p_riWood, ref int p_riStone)
	endproc;
	
	export proc void CheckEpoch(int p_iHighest)
		if(!CMirageSrvMgr.Get().FreeSpecials())then return; endif;
		var string sTribe=GetTribeName();
		var ^CPlayer pxPlayer=CSrvWrap.GetCurLevel()^.GetPlayer(GetOwner());
		if(pxPlayer==null)then return; endif;
		var ^CTechTreeDef pxTTDef=^(pxPlayer^.GetPlayerTechTreeDef());
		if(pxTTDef==null)then return; endif;
		var array string asFilters;
		var int i, iC=p_iHighest;
		for(i=2)cond(i<iC)iter(i++)do
			asFilters.AddEntry("/Filters/"+sTribe+"/Upgrades/xenage/epoch_"+i.ToString());
		endfor;
		iC=asFilters.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(!pxTTDef^.HasFilter(asFilters[i]))then
				pxTTDef^.EnableFilter(asFilters[i]);
			endif;
		endfor;
	endproc;
	
	export proc bool IsCamouflaged()
		return m_bIsCamouflaged;
	endproc;
	
	export proc bool WardenEmpowered()
		return HasTimer(TIMER_ANML_IMMUNITY)&&GetEffectFlag(EFFECT_NO_ANIMAL_AGGRO);
	endproc;
	
	export proc vec3 GetRallyPosSimple()
		return m_vRallyPos;
	endproc;
	
	export proc vec3 GetCustomRallyPos()
		var real fRadius=GetRadius();
		if(GetClassName().Find("seas_")!=-1)then
			fRadius/=2.5f;
		endif;
		var vec3 vPos=GetPos()+({0.0,1.0,0.0}*fRadius);
		return vPos;
	endproc;
	
	export proc void SetHitable(bool p_bHitable)
		super.SetHitable(p_bHitable);
		CheckEnemyValidity();
	endproc;
	
	export proc void SetIsVanished(bool p_bVanished)
		super.SetIsVanished(p_bVanished);
		CheckEnemyValidity();
		CheckFighterValidity();
	endproc;
	
	export proc void CheckEnemyValidity()
		if(m_bCeaseFire||m_bIsDead||m_bIsGettingFinished||!IsHitable()||GetIsVanished()||m_bSlaveInvincible)then
			m_bInvalidEnemy=true;
		else
			m_bInvalidEnemy=false;
		endif;
		var ^CAttribs pxA=GetAttribs();
		if(pxA!=null)then
			pxA^.SetValue("invalid_enemy",m_bInvalidEnemy);
		endif;
	endproc;
	
	export proc bool InvalidEnemy()
		return m_bInvalidEnemy;
	endproc;
	
	export proc void CheckEnemyHiding()
		if(m_bIsCamouflaged||m_bFeignDeath)then
			m_bHidingEnemy=true;
		else
			m_bHidingEnemy=false;
		endif;
	endproc;
	
	export proc bool HidingEnemy()
		return m_bHidingEnemy;
	endproc;
	
	export proc void SetUniqueMask(bool p_bOn)
		m_bUniqueMask=p_bOn;
	endproc;
	
	export proc bool HasUniqueMask()
		return m_bUniqueMask;
	endproc;
	
	export proc void CheckFighterValidity()
		if(m_bFeignDeath||m_bCeaseFire||m_bIsDead||m_bIsGettingFinished||GetIsVanished()||m_bIncapacitated||m_bSlaveInvincible)then
			m_bInvalidFighter=true;
		else
			m_bInvalidFighter=false;
		endif;
	endproc;
	
	export proc bool InvalidFighter()
		return m_bInvalidFighter;
	endproc;
	
	export proc bool IsDetector()
		return false;
	endproc;
	
	export proc void AddTaskFO(^CTask p_pxTask)
		if(m_pxTaskMgr!=null)then
			m_pxTaskMgr^.AddTask(p_pxTask);
		endif;
	endproc;
	
	export proc void SetTaskFO(^CTask p_pxTask)
		if(m_pxTaskMgr!=null)then
			m_pxTaskMgr^.SetTask(p_pxTask);
		endif;
	endproc;
	
	export proc void SetSubTaskFO(^CTask p_pxTask)
		if(m_pxTaskMgr!=null)then
			m_pxTaskMgr^.SetSubTask(p_pxTask);
		endif;
	endproc;
		
	export proc void NewTaskFO(^CTask p_pxTask, bool p_bQ)
		if(m_pxTaskMgr!=null)then
			if(p_bQ)then
				m_pxTaskMgr^.AddTask(p_pxTask);
			else
				m_pxTaskMgr^.SetTask(p_pxTask);
			endif;
		endif;
	endproc;
	
//	export proc void ShowWeapons()
//		return;
//	endproc;
	
//	export proc void ShowWeapons(string p_sAnim)
//		return;
//	endproc;
	
	export proc void SetNoHitReaction()
		m_bNoHitReaction=true;
	endproc;
	
	export proc void ClearBuildUpCache()
		m_xDmgCache.m_pxLastBUOwner=null;
		m_xDmgCache.m_fBuildUpDamage=0.0;
		m_xDmgCache.m_pxLastBUOExtra=null;
		m_xDmgCache.m_fBUDExtra=0.0;
		m_bWeaponHasChanged=true;
	endproc;
	
	export proc bool CanTame()
		return m_bCanTame;
	endproc;
	
	proc bool DeleteOwnRegion()
		if(!m_xRegionGuid.IsNull())then
			var ^CRegionMgr pxRM=^(CSrvWrap.GetRegionMgr());
			if(pxRM!=null)then
				var int iIdx=CSrvWrap.GetRegionMgr().FindRegion(m_xRegionGuid);
				if(iIdx>=0)then
					var ^CRegion pxRegion=pxRM^.GetRegion(iIdx);
					m_xSink.Unsubscribe();
					if(pxRegion!=null)then
						pxRegion^.Unbind();
					endif;
					m_xSink.DeleteRegion();
					var CGuid xNew;
					m_xRegionGuid=xNew;
					m_sPerRegName="";
				elseif(m_sPerRegName!="")then
					var ^CRegion pxRegion=pxRM^.GetRegion(m_sPerRegName);
					if(pxRegion!=null)then
						m_xSink.Unsubscribe();
						pxRegion^.Unbind();
						m_xSink.DeleteRegion();
						var CGuid xNew;
						m_xRegionGuid=xNew;
						m_sPerRegName="";
					endif;
				endif;
			endif;
			var ^CAttribs pxAttr=GetAttribs();
			if(pxAttr!=null)then
				pxAttr^.SetValue("RangeMarker","");
			endif;
		endif;
		return true;
	endproc;
	
	export proc void InitOwnRegion()
	endproc;
	
	export proc void RemoveBuff()
	endproc;
	
	export proc bool GoAfterTarget(CObjHndl p_xEnemy)
		if(!p_xEnemy.IsValid())then return false; endif;
		var ^CGameObj pxEnemy=p_xEnemy.GetObj();
		if(pxEnemy==null)then return false; endif;
		if(!IsAbleToWalk())then return false; endif;
		if(m_bDoingFinishingMove)then return false; endif;
		var bool bNoUserCommand=false;
		if(m_pxTaskMgr!=null)then
			var ^CTask pxTask=m_pxTaskMgr^.GetCurTask();
			if(pxTask!=null)then
				bNoUserCommand=!pxTask^.IsUserCommand();
			endif;
		else
			return false;
		endif;
		var bool bPos = false;
		var bool bValidEnemy = false;
		var bool bFarFromDest = false;
		var real fAlarmRng=GetAlarmRange()*2.0;
		fAlarmRng += GetAttackRange();
		bPos=(m_vAggressionPos-pxEnemy^.GetPos()).Abs2() > fAlarmRng;
		bValidEnemy=true;
		bFarFromDest=(m_vAggressionPos-GetPos()).Abs2S()>2.0;
		var CFourCC xWalkSet;
		var real fAttackRange;
		if(GetSecondaryWeaponS()==GetCurrentWeapon())then
			fAttackRange=GetSecondaryRangeS();
		elseif(GetSecondaryWeaponM()==GetCurrentWeapon())then
			fAttackRange=GetSecondaryRangeM();
		else
			fAttackRange=GetAttackRange()-2.0f;
		endif;
		if(m_fAttackRange<1.0)then
			fAttackRange=0.0; //GetCollisionRadius()+0.1;
		endif;
		var real fPFallOff=0.0;
		if(!GetProjectile().IsEmpty())then
			if(GetRightHandWeapon()==GetCurrentWeapon())then
				fPFallOff=GetProjectileFallOffCone();
			endif;
		endif;
		if(fPFallOff>0.0)then
			fAttackRange+=GetCollisionRadiusInner();
		else
			fAttackRange+=GetCollisionRadius();
		endif;
		if(bValidEnemy)then
			var ^CWall pxWall=cast<CWall>(pxEnemy);
			var ^CTower pxTower=cast<CTower>(pxEnemy);
			if(bNoUserCommand)then
				if(m_bAggressionWalk)then
					TerminateAction();
					var CGameObj.CAdvanceActionParams xAWAP;
					xAWAP.m_fMinDistance=fAttackRange;
					xAWAP.m_iPrefSpeed=GetMaxSpeed();
					xAWAP.m_fProjectileFallOff=fPFallOff;
					xAWAP.m_bStopOnLostTarget=bNoUserCommand;
					if(GetOnWall())then
						AdvanceWallAction(p_xEnemy,xAWAP,!pxEnemy^.GetOnWall(),bNoUserCommand);
					else
						AdvanceAction(p_xEnemy,xAWAP);
					endif;
					return true;
				elseif(GetAggressionState()>0)then
					if(bPos /*&& GetAggressionState()==1*/&&!m_bAggressionWalk)then
						if(bFarFromDest)then
							if(GetOnWall())then
								WallWalkAction(m_vAggressionPos,true,GetDefaultSpeed(),false);
							else
								WalkAction(m_vAggressionPos,GetDefaultSpeed(),true);
							endif;
							return false;
						endif;
					else
						var real fDist=(pxEnemy^.GetPos()-GetPos()).Abs();
						if(fDist>fAlarmRng-2.0f)then
							return false;
						endif;
						TerminateAction();
						var CGameObj.CAdvanceActionParams xAWAP;
						xAWAP.m_fMinDistance=fAttackRange;
						xAWAP.m_iPrefSpeed=GetMaxSpeed();
						xAWAP.m_xWalkSet=GetWalkSet();
						xAWAP.m_fMaxRange=fAlarmRng;
						xAWAP.m_vRootPos=m_vAggressionPos;
						xAWAP.m_fProjectileFallOff=fPFallOff;
						xAWAP.m_bStopOnLostTarget=bNoUserCommand;
						if(GetOnWall())then
							AdvanceWallAction(p_xEnemy,xAWAP,!pxEnemy^.GetOnWall(),bNoUserCommand);
						else
							AdvanceAction(p_xEnemy,xAWAP);
						endif;
						return true;
					endif;
				elseif(bFarFromDest)then
					if(GetOnWall())then
						WallWalkAction(m_vAggressionPos,true,GetDefaultSpeed(),false);
					else
						WalkAction(m_vAggressionPos,GetDefaultSpeed(),true);
					endif;
				endif;
				return false;
			else
				TerminateAction();
				var CGameObj.CAdvanceActionParams xAWAP;
				xAWAP.m_fMinDistance=fAttackRange;
				xAWAP.m_iPrefSpeed=GetMaxSpeed();
				xAWAP.m_sFirstStrike=GetFirstStrikeAnim();
				xAWAP.m_fProjectileFallOff=fPFallOff;
				xAWAP.m_bStopOnLostTarget=bNoUserCommand;
				if(GetOnWall()||pxEnemy^.GetOnWall())then
					if(!GetOnWall()&&pxEnemy^.GetOnWall()&&!GetProjectile().IsEmpty())then
						AdvanceAction(p_xEnemy,xAWAP);
					else
						AdvanceWallAction(p_xEnemy,xAWAP,!pxEnemy^.GetOnWall(),!bNoUserCommand);
					endif;
				else
					AdvanceAction(p_xEnemy,xAWAP);
				endif;
				return true;
			endif;
		else
			if(bFarFromDest)then
				if(GetOnWall())then
					WallWalkAction(m_vAggressionPos,true,GetDefaultSpeed(),false);
				else
					WalkAction(m_vAggressionPos,GetDefaultSpeed(),true);
				endif;
			elseif(m_bAggressionWalk)then
				m_bAggressionWalk=false;
				m_bAggrTNoAnml=false;
			endif;
			return false;
		endif;
	endproc;
	
	proc real GetTechTreeJawSize()
		var string sObjPath=GetObjPath();
		var real fJawSize=m_xTechTree.GetValueR(sObjPath+"/jaw_size",20.0);
		return fJawSize;
	endproc;
	
	proc real GetTechTreeFeedFactor()
		var string sObjPath=GetObjPath();
		var real fFeedFactor=m_xTechTree.GetValueR(sObjPath+"/feed_factor",1.0);
		return fFeedFactor;
	endproc;
	
//	export proc bool GetFireProof()
//		return false;
//	endproc;
	
	///////
	//	GetRangedDefenseBoni()
	///////
	export proc ref CBonus GetRangedDefenseBoni()
		return m_xRangedDefBoni;
	endproc;
	
	export proc bool AiOwner()
		return m_bAI;
	endproc;
	
	export proc void SetPenetrationFactor(real p_fPenetrationFactor)
		m_fPenetrationFactor=p_fPenetrationFactor;
	endproc;
	
	export proc ref real GetPenetrationFactor()
		return m_fPenetrationFactor;
	endproc;
	
	export proc void Penetrate(vec3 p_vPos, int p_iTarget, CObjHndl p_xPrimaryTarget)
		var CObjList xList;
		UpdateFightFactors();
		var real fPF, fPA, fAF; // Henry: PF=penetration factor, PA=penetration angle, AF=attack factor
		if(GetAttackPenetrate())then
			fPF=GetAttackSplash();
			fPA=GetAttackAngle();
			fAF=GetAttackFactor();
		else
			fAF=1.0;
			fPF=GetPenetrationFactor(); // Henry: PenetrationFactor (propagation, aoe, cleave, splash, etc)
			fPA=GetPenetrationAngle();
		endif;
		GetPenetrableTargets(p_vPos, GetAttackRange(), xList, fPA, p_iTarget, p_xPrimaryTarget);
		var int i, iC=xList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(xList[i]==GetHandle())then continue; endif;
			var ^CFightingObj pxFight=cast<CFightingObj>(xList[i].GetObj());
			if(pxFight!=null)then
//				if(pxFight^.GetTransportObj().IsValid())then continue; endif;
//				if(!pxFight^.IsHitable())then continue; endif;
				pxFight^.ClearDamageCache();
				var real fReaction;
				if(xList[i]==p_xPrimaryTarget)then
					fReaction=pxFight^.TakeDmg(this,false,fAF);
				else
					fReaction=pxFight^.TakeDmg(this,false,fAF*fPF)*(fPF*fAF);
				endif;
				if(m_bMeleePenetrate)then
					SetReaction(fReaction);
				endif;
			endif;
		endfor;
	endproc;
	
	export proc void GetPenetrableTargets(vec3 p_vTarget, real p_fRadius, ref CObjList p_rxObjs, real p_fAngle, int p_iID, CObjHndl p_xPT)
		var string sOwn=GetClassName();
		var bool bWorld=GetOwner()==-1;
		var CObjQuery xQuery;
		CSrvWrap.GetDiplomacyMgr().AddMyEnemiesToSearch(GetOwner(), xQuery);
		xQuery.SetOwner(-1,true);
		var real fDist=(p_vTarget-GetPos()).Abs2();
		var vec3 vPos=GetPos();
		xQuery.RegionCircle(vPos, Math.Max(p_fRadius*2.0, fDist*1.5));
		var CObjList xL;
		xQuery.Exclude(p_xPT);
		xQuery.Execute(xL);
		xL.Include(p_xPT);
		p_fAngle*=0.5;
		p_fAngle=(Math.Pi()/180.0)*p_fAngle;
		p_fRadius+=GetCollisionRadius()+2.0f;
		var vec3 vDir=(p_vTarget - vPos);
		var int i, iC=xL.NumEntries();
//		var bool bWorld=p_iID==-1;
		for(i=0) cond(i<iC) iter(++i)do
			if(xL[i]==GetHandle())then continue; endif;
			var ^CFightingObj pxO=cast<CFightingObj>(xL[i].GetObj());
			if(pxO!=null)then
				if(bWorld && pxO^.GetOwner()==-1 && pxO^.GetClassName()==sOwn)then continue; endif;
				if(pxO^.GetTransportObj().IsValid()||pxO^.GetOnWall())then continue; endif;
				if(!pxO^.IsHitable())then continue; endif;
//				if(!bWorld&&pxO^.GetOwner()==-1)then continue; endif;
				var vec3 vDirEnemy=(pxO^.GetPos()-vPos);
				var real fEnemyRadius=pxO^.GetCollisionRadiusInner();
				var real fEnemyDistSquare=vDirEnemy.AbsSquare();
				if((fEnemyRadius+p_fRadius)*(fEnemyRadius+p_fRadius)<fEnemyDistSquare)then
					continue;
				endif;
				var real fAngle=vDir.AngBetweenXY(vDirEnemy);
				if(fAngle>p_fAngle)then
					continue;
				endif;
				p_rxObjs.Include(xL[i]);
			endif;
		endfor;
	endproc;
	
	export proc bool IsDyingInTPO()
		return m_bPassingAway;
	endproc;
	
	export proc void SetDyingInTPO(bool p_bDying)
		m_bPassingAway=p_bDying;
	endproc;
	
	export proc bool AttackWildTarget(^CFightingObj p_pxEnemy)
		return false;
	endproc;
	
	proc bool IsHero(string p_sClass)
		if(p_sClass=="Stina_s0"||p_sClass=="Bela_s0"||p_sClass=="Cole_s0"||p_sClass=="special_eusmilus"
		||p_sClass=="mayor_s0"||p_sClass=="darwin_s0"||p_sClass=="tesla_s0"||p_sClass=="babbage_s0"
		||p_sClass=="hermit_s0"||p_sClass=="lovelace_s0"||p_sClass=="schliemann_s0"||p_sClass=="livingstone_s0"
		||p_sClass=="Miyagi_s0"||p_sClass=="Tarna_s0"||p_sClass=="Larry_s0"||p_sClass=="special_mobile_suit")then
			return true;
		else
			return false;
		endif;
	endproc;
	
	proc bool IsLevelAcceptable(int p_iDest)
		var int iSwitch=CMirageSrvMgr.Get().DwnLvlSwitch();
		if(iSwitch<1)then
			return false;
		elseif(iSwitch==1)then
			if(!IsHero(GetClassName()))then return false; endif;
		endif;
		if(iSwitch<3)then
			if(m_sObjPath=="")then return false; endif;
			var CTechTreeDef xDef;
			var CTechTree xTT=CTechTreeMgr.Get().GetTechTree(xDef);
			var int iMinLevel = xTT.GetValueI(m_sObjPath+"/captainlevel",5)-1;
			if(p_iDest<iMinLevel)then return false; endif;
		endif;
		return true;
	endproc;
	
	export proc void SetFrighteningEffect()
		var real fDuration=15.0;
		DeleteTimer(TIMER_FRIGHTENING);
		ActivateCustomFilterAndUpdate(true,CNinigiTriceratops.FRIGHTENING_PATH);
		AddRangedBuff("lower_fighting_rate");
		CreateTimer(TIMER_FRIGHTENING,CGameTimeSpan.OneSecond() * fDuration, false);
	endproc;
	
	export proc void SetSedated(bool p_bOn, real p_fTime)
		DeleteTimer(TIMER_SEDATED);
		RemoveRangedBuff("lower_fighting_rate");
		ActivateCustomFilterAndUpdate(p_bOn,CHero.TOXIC_PATH);
		if(p_bOn&&p_fTime>0.0)then
			AddRangedBuff("lower_fighting_rate");
			CreateTimer(TIMER_SEDATED,CGameTimeSpan.OneSecond() * p_fTime, false);
		endif;
	endproc;
	
	export proc void SetValorEffect(real p_fDur)
		DeleteTimer(TIMER_VALOR);
		ActivateCustomFilterAndUpdate(true,CParasaurolophus.VALOR_PATH);
		AddRangedBuff("higher_fighting_rate");
		CreateTimer(TIMER_VALOR,CGameTimeSpan.OneSecond() * p_fDur, false);
	endproc;
	
	export proc void SetRallyEffect(real p_fDur)
		DeleteTimer(RALLY_TRUMP);
		ActivateCustomFilterAndUpdate(true,CMammoth.RALLY_PATH);
		AddRangedBuff("higher_fighting_freq");
		CreateTimer(RALLY_TRUMP,CGameTimeSpan.OneSecond() * p_fDur, false);
	endproc;
	
	// CHEAT for testing
//	export static proc void ToggleGodModeForPlayer(string p_sName,int p_iPlayer)
//		if(pxO!=null)then p_iPlayer=pxO^.GetOwner(); endif;
	export static proc void ToggleGodModeForPlayer(string p_sName)
		var ^CGameObj pxO = CSrvWrap.GetObjMgr()^.GetObjByName(p_sName);
		if(pxO==null)then return; endif;
		var int iP=pxO^.GetOwner();
		var bool bOn;
		CMirageSrvMgr.Get().ToggleGodMode(iP,bOn);
		var CObjQuery xQuery;
		var CObjList xList;
		xQuery.SetOwner(iP);
		xQuery.Execute(xList);
		var int i,iC=xList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFightingObj pxObj=cast<CFightingObj>(xList[i].GetObj());
			if(pxObj!=null)then
				pxObj^.SetGodMode(bOn);
			endif;
		endfor;
	endproc;
	
	export proc bool CreateProjectileAndShootBUNew(^CFightingObj p_pxEnemy, vec3 p_vPos)
		var string sProj=GetProjectile()+GetWeaponMgr()^.GetRightHVariationPostfix();
		var ^CArrow pxArrow=cast<CArrow>(CSrvWrap.GetObjMgr()^.CreateObj(sProj,GetOwner(),GetProjectileStartPos()));
		if(pxArrow!=null)then
			if(p_pxEnemy==null)then
				var real fPrev=p_vPos.GetZ();
				var real fScapeZ=CSrvWrap.GetScapeMgr().GetHeight(p_vPos.GetX(), p_vPos.GetY());
				p_vPos.SetZ(fScapeZ);
				pxArrow^.SetAttackScape(this, p_vPos);
			else
				pxArrow^.Set(this, p_pxEnemy);
			endif;
			return true;
		endif;
		return false;
	endproc;
	
	export proc string GetStandardDescription()
		return m_sStandardDesc;
	endproc;
	
	export proc string GetObjectFlag()
		return m_sObjFlag;
	endproc;
	
	export proc bool GetSlaveInvincible()
		return m_bSlaveInvincible;
	endproc;
	
	export proc void SetSlaveInvincible(bool p_bOn)
		m_bSlaveInvincible=p_bOn;
		CheckEnemyValidity();
		CheckFighterValidity();
	endproc;
	
	export proc bool SkipCorpse()
		return m_bNoCorpse;
	endproc;
	
	export proc void SetSkipCorpse(bool p_bSkip)
		m_bNoCorpse=p_bSkip;
	endproc;
	
	export proc void AddToDoTask(string p_sTask, CObjHndl p_xSubject, CObjList p_xSubList, vec3 p_vTarget, string p_sParam, real p_fStart, real p_fDelay)
		var bool bNow=m_axToDoList.NumEntries()<1;
		var ^CToDoEntry pxTDE=^(m_axToDoList.NewEntryRef());
		pxTDE^.Initialize(p_sTask, p_xSubject, p_xSubList, p_vTarget, p_sParam, p_fStart, p_fDelay, bNow, OnExecuteNextEntry);
		pxTDE^.SetPlace(m_axToDoList.NumEntries()-1);
	endproc;
	
	proc bool OnExecuteNextEntry(string p_sTask, CObjHndl p_xSubject, CObjList p_xSubList, vec3 p_vTarget, string p_sParam, real p_fDelay)
		if(m_axToDoList.NumEntries()<1)then return false; endif;
//		m_axToDoList.DeleteEntryUS(0);
		m_axToDoList.DeleteEntry(0);
		if(p_sTask=="MarchToWar")then
			MarchToWar(p_vTarget, p_sParam.ToInt());
		elseif(p_sTask=="MountPass")then
			var ^CTransportObj pxT=cast<CTransportObj>(this);
			if(pxT!=null)then
				var int i,iC=p_xSubList.Validate();
				for(i=0)cond(i<iC)iter(i++)do
					if(pxT^.IsFull())then break; endif;
					pxT^.OnMount(p_xSubList[i]);
				endfor;
			endif;
		elseif(p_sTask=="UnboardAtPos")then
			var ^CTransportObj pxT=cast<CTransportObj>(this);
			if(pxT!=null)then
				pxT^.PrepareUnboard(p_vTarget,false);
			endif;
		elseif(p_sTask=="CTheLite")then
			var CGameEvtPtr xEvt=CGameEvtPtr.CreateEvent("CTheLite");
			xEvt.SetObjHandle(0,p_xSubject);
			HandleEvent(xEvt);
		elseif(p_sTask=="WalkToPos")then
			var bool bAdd = false, bPF = false;
			var array string asParams;
			p_sParam.Split(asParams,"|",true);
			if(asParams.NumEntries()>1)then
				bPF = asParams[0]=="1";
				bAdd = asParams[1]=="1";
			endif;
			var ^CWalkToPos pxTask = cast<CWalkToPos>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"Walk2Pos"));
			if(pxTask!=null)then
				var bool bR=pxTask^.Init(GetHandle(), p_vTarget, GetDefaultSpeed(), bPF, true, false, true);
				if(bR)then
					pxTask^.SetUserCommand(true);
					AddTask(pxTask,bAdd);
				else
					pxTask^.GetFactory()^.FreeState(pxTask);
				endif;
			endif;
		endif;
		//...
		if(m_axToDoList.NumEntries()>0)then
//			m_axToDoList.QSort();
			m_axToDoList[0].StartTimer(p_fDelay);
		endif;
		return true;
	endproc;
	
	proc void MarchToWar(vec3 p_vTarget, int p_iPrefSpeed)
		if(m_pxTaskMgr!=null)then
			var ^CTask pxTask=m_pxTaskMgr^.GetCurTask();
			if(pxTask!=null)then
				if(pxTask^.Break())then
					pxTask^.EndTask();
				endif;
			endif;
		endif;
		UpdateAggressionPos(p_vTarget);
		m_bAggressionWalk=true;
		m_bAggrTNoAnml=false;
		var array vec3 avPos; avPos.AddEntry(p_vTarget);
		var int iSpeed=Math.Clamp(p_iPrefSpeed,1,GetMaxSpeed());
		StartPatrol(avPos, 0, iSpeed);
		CheckPatrol();
	endproc;
	
	export proc void SetAIBrain(bool p_bOn)
	endproc;
	
	export proc bool GetAIBrain()
		return false;
	endproc;
	
//	export proc bool CanSeeRHearNakama(^CGameObj p_pxObj)
//		if(p_pxObj==null)then return false; endif;
//		var real fDistSquare=(p_pxObj^.GetPos()-GetPos()).Abs2S();
//		var real fRangeSquare=GetNakamaRange() * GetNakamaRange();
//		return (fDistSquare<fRangeSquare);
//	endproc;
//	
//	proc real GetNakamaRange()
//		var real fRange=GetAlarmRange();
//		if(GetAttackRange()>fRange)then
//			fRange=GetAttackRange();
//		endif;
//		if(GetFOWRange()>fRange)then
//			fRange=GetFOWRange();
//		endif;
//		return 4.0f*fRange;
//	endproc;
	
	export proc string GetTaskDescription()
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			return pxAttr^.GetValue("TaskDescription");
		endif;
		return "";
	endproc;
	
	export proc void DoHPRelatedStuff()
	endproc;
	
	export proc void SetCustomHandles(string p_sIdentifier, CObjHndl p_xHndl)
	endproc;
	
	export proc void SetCustomLists(string p_sIdentifier, CObjList p_xList)
	endproc;
	
	export proc real GetWaterHeight()
//		return CSrvWrap.GetScapeMgr().GetSeaLevel();
		return m_fWaterLevel;
	endproc;
	
	export proc void FilterEnemyListCustom(ref CObjList p_rxList)
		if(GetClassName()=="darwin_s0"||GetEffectFlag(EFFECT_NO_ANIMAL_AGGRO)||CMirageSrvMgr.Get().GetNeutralToWildAnimals(GetOwner()))then
			var int i,iC=p_rxList.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				var CObjHndl xHndl=p_rxList[i];
				if(xHndl.IsValid())then
					if((xHndl.GetObj()^.GetType()=="ANML" || xHndl.GetObj()^.GetType()=="NEST") && xHndl.GetObj()^.GetOwner()==-1)then
						p_rxList.DeleteEntry(i);i--;iC--;
					endif;
				endif;
			endfor;
		endif;
	endproc;
	
	export proc bool ResistantToThrow()
		return m_bThrowDisabled||m_bThrowImmune||IsTrapped();
	endproc;
	
	export proc void FountainArrived(CObjHndl p_xObj)
	endproc;
	
	export proc void DropAllItems()
		var ^CInventory pxInv=GetInventory();
		if(pxInv!=null)then
			var int i, iC=pxInv^.Count();
			var CObjList xList;
			for(i=0)cond(i<iC)iter(++i)do
				if(!pxInv^.GetItem(i).IsValid())then continue; endif;
				xList.Include(pxInv^.GetItem(i));
			endfor;
			iC=xList.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				if(xList[i].IsValid())then
					var ^CGameObj pxItem=xList[i].GetObj();
					var ^CItem pxI=cast<CItem>(pxItem);
					if(pxI!=null)then
						RemoveItem(pxI^.GetHandle());
					endif;
				endif;
			endfor;
			pxInv^.Clear();
		endif;
	endproc;
	
	export proc CObjHndl GetReturnEnemy()
		return m_xReturnEnemy;
	endproc;
	
	export proc void ClearAutoMoves()
		while(m_axAutoSpecialMoves.NumEntries()>0)do
			m_axAutoSpecialMoves.DeleteEntry(0);
		endwhile;
	endproc;
	
	export proc void ToTheGround(real p_fDur)
		DeleteTimer(TIMER_GET_UP);
		m_bOnTheGround=true;
		CreateTimer(TIMER_GET_UP,CGameTimeSpan.OneSecond() * p_fDur, false);
	endproc;
	
	export proc void SetFinishingMode(bool p_bOn)
		if(HasTimer(FINISHING_MODE))then
			DeleteTimer(FINISHING_MODE);
		endif;
		m_bDoingFinishingMove=p_bOn;
		if(p_bOn)then
			CreateTimer(FINISHING_MODE,CGameTimeSpan.OneSecond() * 10.0f, false);
		endif;
	endproc;
	
	export proc void SetRevealState(bool p_bRevealed)
		if(m_sObjPath.IsEmpty())then
			UpdateObjPath();
		endif;
		if(!DoesCountInUnitLimit())then
			if(m_xTechTree.GetValueI(GetObjPath()+"/production_facility",0)==0)then
				return;
			endif;
		endif;
		if(p_bRevealed)then
			CreateTimer(TIMER_HERE_I_AM, CGameTimeSpan.OneSecond()*45.0f, true);
			HereIAm();
		elseif(HasTimer(TIMER_HERE_I_AM))then
			DeleteTimer(TIMER_HERE_I_AM);
		endif;
	endproc;
	
	export proc void HereIAm()
		var int i, iC=8, iMe=GetOwner();
		for(i=0)cond(i<iC)iter(i++)do
			if(i==iMe)then continue; endif;
			if(CSrvWrap.GetDiplomacyMgr().GetIsFriend(i, iMe)&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(iMe, i))then continue; endif;
			CSrvWrap.SendGenericEvtToPlayer(i, "MiniMapAttack\t"+GetPos().ToString()+"\tReveal_"+iMe.ToString());
		endfor;
	endproc;
	
	export proc void SetTornado(CObjHndl p_xHndl)
		m_xTornado=p_xHndl;
	endproc;
	
	export proc CObjHndl GetTornado()
		return m_xTornado;
	endproc;
	
	export proc bool ShallBeRevealedAutomaticaly()
		return true;
	endproc;
	
	export proc real GetFlyingHeight()
		return 0.0f;
	endproc;
	
	export proc bool IsSiegeUnit()
		return false;
	endproc;
	
	export proc int GetProjectilesNumber()
		return 1;
	endproc;
	
	export proc void EndFlee()
		if(GetType()=="ANML"/*&&GetOwner()==-1*/)then
			var ^CFightingObj.CSpecialAbility pxAb=m_xAbilities.GetAbility("sanctification", true);
			if(pxAb!=null)then
				CreateTimer(TIMER_SANCTIFICATION, CGameTimeSpan.OneSecond() * 3.0, false);
				m_fCuringAmount=pxAb^.GetValueF("amount");
			endif;
		endif;
	endproc;
	
	export proc void BreakSiege()
	endproc;
	
	export proc void SetSiegeBreak(bool p_bOn)
	endproc;
	
	export proc bool IsVisInFOWNew(string p_sClass)
		return IsVisInFOW();
	endproc;
	
	export proc bool HPReachedZero()
		return m_bHPReachedZero;
	endproc;
	
	export proc void RemoveTrapObj()
		m_bObjectTrap=false;
	endproc;
	
	export proc void InvalidateTrap()
		m_xTrap=CObjHndl.Invalid();
	endproc;
	
	export proc void UntrapHandle(CObjHndl p_xTrap)
		var ^CTrapped pxTask=cast<CTrapped>(GetCurTask());
		if(pxTask!=null)then
			pxTask^.RemoveTrapObject(p_xTrap);
		endif;
	endproc;
	
	export proc void UntrapBool()
		m_bIsTrapped=false;
	endproc;
	
	export proc void UntrapTime()
		m_bTimeTrap=false;
	endproc;
	
	export proc bool IsSelfTrapped()
		return m_bIsTrapped;
	endproc;
	
	export proc void UpdateTrapHandle(CObjHndl p_xTrap)
		if(m_xTrap.IsValid()||!p_xTrap.IsValid())then return; endif;
		m_xTrap=p_xTrap;
	endproc;
	
	export proc void TotalUntrap()
		m_bIsTrapped=false;
		var ^CTrapped pxTask=cast<CTrapped>(GetCurTask());
		if(pxTask!=null)then
			pxTask^.TotalUntrap();
		endif;
	endproc;
	
	export proc void ClearTrapValues()
		m_bTimeTrap=false;
		m_bObjectTrap=false;
		m_bIsTrapped=false;
	endproc;
	
	export proc vec3 GetDummyPos(ref vec3 p_rvMid, real p_fFactor)
//		var CFourCC xLink="Ex_1";
		var CFourCC xLink=m_xTechTree.GetValueS(GetObjPath()+"/dummy_pos", "Ex_1");
		var vec3 vPos;
		if(!GetLinkPosWorld(xLink,vPos))then
			var real fRadius=GetRadius();
			if(GetClassName().Find("seas_")!=-1)then
				fRadius/=2.5f;
			endif;
			vPos=GetPos()+({0.0,1.0,0.0}*fRadius);
		endif;
		var vec3 vDir=vPos-GetPos();
		var real fDist= vDir.Abs();
		vDir.Normalize();
//		p_rvMid = GetPos()+(vDir*(fDist*0.65f));
		p_rvMid = GetPos()+(vDir*(fDist*p_fFactor));
		p_rvMid.SetZ(CSrvWrap.GetScapeMgr().GetHeight(p_rvMid.GetX(), p_rvMid.GetY()));
		vPos.SetZ(CSrvWrap.GetScapeMgr().GetHeight(vPos.GetX(), vPos.GetY()));
		return vPos;
	endproc;
	
	export proc vec3 GetSpawnPos(ref vec3 p_rvDoor, real p_fFactor)
		var CFourCC xLink="Spwn";
//		var CFourCC xLink=m_xTechTree.GetValueS(GetObjPath()+"/spwn_pos", "Spwn");
		var vec3 vPos;
		if(!GetLinkPosWorld(xLink,vPos))then
			vPos=GetPos();
		endif;
		var vec3 vTmp, vExit=GetDummyPos(vTmp,0.0f);
		var vec3 vDir=vExit-GetPos();
		var real fDist= vDir.Abs();
		vDir.Normalize();
//		p_rvDoor = GetPos()+(vDir*(fDist*0.2f));
		p_rvDoor = GetPos()+(vDir*(fDist*p_fFactor));
		p_rvDoor.SetZ(vPos.GetZ());
		return vPos;
	endproc;
	
	export proc vec3 GetAggressionPos()
		return m_vAggressionPos;
	endproc;
	
	export proc void Flight()
	endproc;
	
	export proc void CPDF() // Henry: Check Patrol During Flight
	endproc;
	
	export proc ^CTask FindTaskByName(string p_sName, bool p_bQueue)
		if(m_pxTaskMgr!=null)then
			return m_pxTaskMgr^.FindTaskByName(p_sName,p_bQueue);
		endif;
		return null;
	endproc;
	
	export proc bool CalcRammerThrow(int p_iEnemyLevel, int p_iFighterSize, ref real po_rfStrength)
		if(!HasAnim("hit_back")||GetActionDesc()=="CActFall"||ResistantToThrow()||GetOnWall())then return false; endif;
//		if(p_iFighterSize==0)then return false; endif;
		var real fStrengthJitter=0.05*((p_iEnemyLevel+1).ToReal());
		po_rfStrength=.0;
		switch(p_iFighterSize)
			case(0)do po_rfStrength=5.0; endcase;
			case(1)do po_rfStrength=4.5; endcase;
			case(2)do po_rfStrength=4.0; endcase;
			case(3)do po_rfStrength=3.5; endcase;
			case(4)do po_rfStrength=3.0; endcase;
			case(5)do po_rfStrength=2.5; endcase;
			case(6)do po_rfStrength=2.0; endcase;
			case(7)do po_rfStrength=1.5; endcase;
			case(8)do po_rfStrength=1.0; endcase;
			case(9)do po_rfStrength=0.5; endcase;
			case default do endcase;
		endswitch;
		po_rfStrength+=Random.MTRandF(po_rfStrength*fStrengthJitter);
		return true;
	endproc;
	
	export proc CObjHndl GetWorstSpiritToReplace(CObjList p_xPyCOs, ref string p_rsName, ref int p_riCount)
		var array CCharacter.CSpiritSorter axList;
		var int i, iC = p_xPyCOs.NumEntries();
		p_riCount=iC;
		for(i=0)cond(i<iC)iter(i++)do
			var ^CPyramidCardObject pxTmp=cast<CPyramidCardObject>(p_xPyCOs[i].GetObj());
			if(pxTmp==null)then p_riCount-=1; continue; endif;
//			var ^CMrgSprt pxSpirit=cast<CMrgSprt>(pxTmp^.GetSpiritHandle().GetObj());
			var ^CMrgSprt pxSpirit=pxTmp^.GetSpirit();
			if(pxSpirit==null)then continue; endif;
			if(pxSpirit^.GetResurrectMode()||pxSpirit^.HasResurrecter())then continue; endif;
			var ^CCharacter.CSpiritSorter pxEntry=^(axList.NewEntryRef());
			pxEntry^.m_iSpiritLevel=1;
			pxEntry^.m_fRadius=pxSpirit^.GetSprtRadius();
			pxEntry^.m_iMaxHP=pxSpirit^.GetSprtHP();
			pxEntry^.m_bOwn=true;
			pxEntry^.m_bVIP=pxSpirit^.GetVIP();
			pxEntry^.m_xHandle=p_xPyCOs[i];
			pxEntry^.m_sClass=pxTmp^.GetName();
		endfor;
		axList.QSort();
		iC=axList.NumEntries()-1;
		for(i=iC)cond(i>=0)iter(i--)do
			if(axList[i].m_xHandle.IsValid())then
				p_rsName=axList[i].m_sClass;
				return axList[i].m_xHandle;
			endif;
		endfor;
		return CObjHndl.Invalid();
	endproc;
	
	export proc void PrepareStillStand()
		StopEverything();
		m_bIsGettingFinished=m_bIsTrapped=true;
	endproc;
	
	export proc bool ExcludeBuildUp()
		return m_bExcludeBuildUp;
	endproc;
	
	export proc bool AttackInFOW()
		return m_bAttackInFOW;
	endproc;
	
	export proc bool AuraSharing()
		return m_bAuraSharing;
	endproc;
	
	export proc void UpdatePTName()
		m_sPTName=GetPlayerTribeName();
	endproc;
	
	export proc string GetTribeNameForReqMgr()
		if(m_bTechtreeSteal)then
			return GetTribeName();
		else
			return m_sPTName;
		endif;
	endproc;
	
	export proc bool CheckTribes(^CTechTree.CNode p_pxAction)
		if(CMirageSrvMgr.Get().TechtreeSteal())then return true; endif;
		if(p_pxAction==null)then return true; endif;
		var ^CTechTree.CNode pxCondNode=p_pxAction^.GetSub("conditions");
		if(pxCondNode==null)then return true; endif;
		var ^CTechTree.CNode pxTribes=pxCondNode^.GetSub("tribe");
		if(pxTribes==null)then return true; endif;
		var bool bCheckTribe = false;
		var int i, iC = pxTribes^.NumSubs();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CTechTree.CNode pxNode = pxTribes^.GetSub(i);
			if(m_sPTName == pxNode^.GetValue())then
				bCheckTribe=true;
				break;
			endif;
		endfor;
		return bCheckTribe;
	endproc;
	
	export proc bool GetNoReceiveDamage()
		return (m_bGodMode||m_bSlaveInvincible||m_bLevelUpInvulnerable||m_bFountainHealed);
	endproc;
	
	export proc void ResetIdleAnim()
	endproc;
	
	export proc void HPReduction(real p_fValue, int p_iPlayerID)
		var real fOld=m_fHitpoints;
		m_fHitpoints-= p_fValue;
		m_fHitpoints=Math.Max(m_fHitpoints,0.0);
		if(m_bDivideSkulls)then
			var real fDifference=fOld-m_fHitpoints;
			(m_afDamagePortion[p_iPlayerID+1])+=fDifference;
		endif;
		if(m_fHitpoints<=0.0f&&!IsDead())then
			var bool bFM=CanBeFinished(m_xCurEnemy,m_xLastEnemy);
			if(bFM)then
				return;
			elseif(!m_bIsGettingFinished)then
				OnKill();
			endif;
		endif;
		UpdateHitpoints();
	endproc;
	
	export proc void ResetDamagePortion()
		if(m_bDivideSkulls)then
			var int i;
			for(i=0)cond(i<9)iter(i++)do
				m_afDamagePortion[i]=0.0;
			endfor;
		endif;
	endproc;
	
	export proc real GetMiscValueTT(string p_sValue)
		return m_xTechTree.GetValueR("MiscValues/"+GetTribeName()+"/"+p_sValue,0.0);
	endproc;
	
	export proc void MakeLUInvulnerable(real p_fTime)
		m_bLevelUpInvulnerable=true;
		CreateTimer(CFightingObj.TIMER_LEVELUP_INV, CGameTimeSpan.OneSecond()*p_fTime, false);
	endproc;
	
	export proc bool IsLocked()
		return m_bLocked;
	endproc;
	
	export proc void ToggleLocked()
		m_bLocked=!m_bLocked;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("is_locked",m_bLocked);
		endif;
	endproc;
	
	export proc bool IsBuildMode()
		return false;
	endproc;
	
	export proc void TerminateActionFightTask()
		TerminateAction();
	endproc;
	
	export proc bool StartCustomTask(string p_sTask, string p_sFlag, real p_fReal1, real p_fReal2, int p_iInt)
		return StartCustomTask(GetHandle(), p_sTask, p_sFlag, p_fReal1, p_fReal2, p_iInt);
	endproc;
	
	export proc bool StartCustomTask(CObjHndl p_xSubject, string p_sTask, string p_sFlag, real p_fReal1, real p_fReal2, int p_iInt)
		var bool bR;
		var ^CCustomTask pxTask = cast<CCustomTask>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"CustTask"));
		if(pxTask==null)then return bR; endif;
		bR = pxTask^.Init(GetHandle(),p_xSubject,p_sTask,p_sFlag,p_fReal1,p_fReal2,p_iInt);
		if(bR)then
			pxTask^.SetUserCommand(true);
			AddTask(pxTask,true);
		else
			pxTask^.GetFactory()^.FreeState(pxTask);
		endif;
		return bR;
	endproc;
	
	export proc bool StartCustomTask(string p_sTask, string p_sFlag)
		return StartCustomTask(GetHandle(), p_sTask, p_sFlag);
	endproc;
	
	export proc bool StartCustomTask(CObjHndl p_xSubject, string p_sTask, string p_sFlag)
		var bool bR;
		var ^CCustomTask pxTask = cast<CCustomTask>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"CustTask"));
		if(pxTask==null)then return bR; endif;
		bR = pxTask^.Init(GetHandle(),p_xSubject,p_sTask,p_sFlag);
		if(bR)then
			pxTask^.SetUserCommand(true);
			AddTask(pxTask,true);
		else
			pxTask^.GetFactory()^.FreeState(pxTask);
		endif;
		return bR;
	endproc;
	
	export proc void SimpleNewDie()
		if(!IsDead())then
			m_bIsDead=true;
			m_fHitpoints=0.0f;
			SetDead(true);
			var ^CAttribs pxAttribs=GetAttribs();
			if(pxAttribs!=null)then
				pxAttribs^.SetValue("dead",true);
			endif;
		endif;
	endproc;
	
	export proc void LeavingTPOAftermath()
		if(CanDisguise())then
			DeleteTimer(CAMO_TIMER);
			CreateTimer(CAMO_TIMER, CGameTimeSpan.OneSecond() * 0.5, false);
			AddCamouflageEffect("disg");
		endif;
	endproc;

	export proc string InformHenry()
		var string sInfo=GetName()+": i'm here";
//		var real fDayTime=(CTimeMgr.Get().GetVirtualTime()/CTimeMgr.Get().GetVirtualDayLength());
//		fDayTime-=(fDayTime.ToInt()).ToReal();
//		vsInfo=fDayTime.ToString();
		CSrvWrap.SendGenericEvtToPlayer(4, "MiniMapAttack\t"+GetPos().ToString()+"\tAttack");
		return sInfo;
	endproc;
	
	//========================================================================================
	//===End of new FightingObj procedures in MIRAGE by Henry=================================
	//========================================================================================
	
	//========================================================================================
	//===New FightingObj childeren classes in MIRAGE by Henry=================================
	//========================================================================================
	
	class CBuildCosts
		
		export var int m_iStone;
		export var int m_iWood;
		export var int m_iFood;
		export var int m_iSkulls;
		
		export constructor()
			m_iStone=0;
			m_iWood=0;
			m_iFood=0;
			m_iSkulls=0;
		endconstructor;
		
		export destructor()
		enddestructor;
		
		export proc ref CFightingObj.CBuildCosts op_Assign(ref CAction.CResourceCosts p_rxOther)
			m_iStone=p_rxOther.m_iStone;
			m_iWood=p_rxOther.m_iWood;
			m_iFood=p_rxOther.m_iFood;
			m_iSkulls=p_rxOther.m_iSkulls;
			return(this^);
		endproc;
		
		export proc void Update(ref CAction.CResourceCosts p_rxOther)
			m_iStone+=p_rxOther.m_iStone;
			m_iWood+=p_rxOther.m_iWood;
			m_iFood+=p_rxOther.m_iFood;
			m_iSkulls+=p_rxOther.m_iSkulls;
		endproc;
		
	endclass;
	
	class CFireTick inherit CEvtSink
	
		const real FREQUENCY=2.0;
		
		var int					m_iTimer;
		var real				m_fDmgPerTick;
		var int					m_iTickCount;
		var int					m_iMaxTickCount;
		var CObjHndl		m_xSource;
		var int					m_iEnemy;
		export var procref <void, real, CObjHndl, int> m_xOnTick;
		export var procref <void> m_xOnDecay;
		
		export constructor()
			m_xOnTick=OnTick;
			m_xOnDecay=OnDecay;
			m_iTimer=-1;
			m_iTickCount=0;
			m_iEnemy=-1;
		endconstructor;
		
		export destructor()
			if(m_iTimer!=-1)then
				CTimeMgr.Get().GetTimer(m_iTimer)^.Unsubscribe(this);
				CTimeMgr.Get().DeleteTimer(m_iTimer);
			endif;
			m_xSource=CObjHndl.Invalid();
			m_iEnemy=-1;
		enddestructor;
		
		export proc ref CObjHndl GetSource()
			return m_xSource;
		endproc;
		
		export proc ref int GetEnemy()
			return m_iEnemy;
		endproc;
		
		export proc bool op_LessEqual(real p_fOther)
			return m_fDmgPerTick<=p_fOther;
		endproc;
		
		export proc bool op_LessEqual(int p_iOther)
			return (m_iMaxTickCount-m_iTickCount)<=p_iOther;
		endproc;
		
		export proc bool op_GreaterEqual(real p_fOther)
			return m_fDmgPerTick>=p_fOther;
		endproc;
		
		export proc bool op_GreaterEqual(int p_iOther)
			return (m_iMaxTickCount-m_iTickCount)>=p_iOther;
		endproc;
		
		export proc ref CFightingObj.CFireTick op_Assign(ref CFightingObj.CFireTick p_rxOther)
			SetFire(p_rxOther.GetDmgPerTick(), p_rxOther.GetMaxTickCount(), p_rxOther.GetCurTickCount(), p_rxOther.GetSource(), p_rxOther.GetEnemy());
			return(this^);
		endproc;
		
		proc void OnTick(real p_fReal, CObjHndl p_xSource, int p_iEnemy)
		endproc;
		
		proc void OnDecay()
		endproc;
		
		export proc bool OnPush(ref CEvtPointer  p_rxEP)
			m_xOnTick.Call(m_fDmgPerTick, m_xSource, m_iEnemy);
			m_iTickCount++;
			if(m_iTickCount >= m_iMaxTickCount)then
				Reset();
				m_xOnDecay.Call();
			endif;
			return true;
		endproc;
		
		export proc void SetFire(real p_fDmg, int p_iMaxTickCount, int p_iCurTickCount, CObjHndl p_xSource, int p_iEnemy)
			if(m_iTimer==-1)then
				m_iTimer=CTimeMgr.Get().CreateTimer(CGameTimeSpan.OneSecond() * FREQUENCY, true);
				CTimeMgr.Get().GetTimer(m_iTimer)^.Subscribe(this);
			endif;
			m_fDmgPerTick=p_fDmg;
			m_iMaxTickCount=p_iMaxTickCount;
			m_iTickCount=p_iCurTickCount;
			m_xSource=p_xSource;
			m_iEnemy=p_iEnemy;
		endproc;
		
		export proc ref int GetCurTickCount()
			return m_iTickCount;
		endproc;
		
		export proc int GetTicksLeft()
			return (m_iMaxTickCount - m_iTickCount);
		endproc;
		
		export proc ref int GetMaxTickCount()
			return m_iMaxTickCount;
		endproc;
		
		export proc ref real GetDmgPerTick()
			return m_fDmgPerTick;
		endproc;
		
		export proc void Reset()
			if(m_iTimer!=-1)then
				CTimeMgr.Get().GetTimer(m_iTimer)^.Unsubscribe(this);
				CTimeMgr.Get().DeleteTimer(m_iTimer);
				m_iTimer=-1;
			endif;
			m_iTickCount=0;
			m_iMaxTickCount=0;
			m_fDmgPerTick=0.0;
			m_xSource=CObjHndl.Invalid();
			m_iEnemy=-1;
		endproc;
		
		export proc void DoKArc(ref CArc p_rxArc, int p_iVersion)
			var bool bTimerStart=(m_iTimer==-1);
			p_rxArc << m_iTimer;
			p_rxArc << m_fDmgPerTick;
			p_rxArc << m_iTickCount;
			p_rxArc << m_iMaxTickCount;
			if(m_iTimer!=-1&&bTimerStart)then
				m_iTimer=CTimeMgr.Get().CreateTimer(CGameTimeSpan.OneSecond() * FREQUENCY, true);
				CTimeMgr.Get().GetTimer(m_iTimer)^.Subscribe(this);
			endif;
			if(p_iVersion>=22)then
				m_xSource.DoKArc(p_rxArc);
				p_rxArc << m_iEnemy;
			endif;
		endproc;
		
	endclass;
	
	class CLethalTick inherit CEvtSink
	
		const real FREQUENCY=3.0;
		
		var int					m_iTimerID;
		var real				m_fDmgPerTick;
		var real				m_fIncrease;
		var int					m_iTickCount;
		var int					m_iMaxTickCount;
		var int					m_iTickIncrease;
		var int					m_iCounter;
		var CObjHndl		m_xSource;
		var int					m_iEnemy;
		export var int	m_iID;
		export var procref <void, real, CObjHndl, int> m_xOnTick;
		export var procref <void, int> m_xOnDecay;
		
		export constructor()
			m_xOnTick=OnTick;
			m_xOnDecay=OnDecay;
			m_iTimerID=-1;
			m_iTickCount=0;
			m_iTickIncrease=0;
			m_iCounter=0;
			m_iEnemy=-1;
			m_fDmgPerTick=0.0f;
			m_fIncrease=0.0f;
			m_xSource=CObjHndl.Invalid();
		endconstructor;
		
		export destructor()
			if(m_iTimerID!=-1)then
				CTimeMgr.Get().GetTimer(m_iTimerID)^.Unsubscribe(this);
				CTimeMgr.Get().DeleteTimer(m_iTimerID);
			endif;
			m_xSource=CObjHndl.Invalid();
			m_iEnemy=-1;
		enddestructor;
		
		export proc ref CObjHndl GetSource()
			return m_xSource;
		endproc;
		
		export proc ref int GetEnemy()
			return m_iEnemy;
		endproc;
		
//		export proc ref CFightingObj.CLethalTick op_Assign(ref CFightingObj.CLethalTick p_rxOther)
//			InflictWound(p_rxOther.GetDmgPerTick(), p_rxOther.GetCounter(), p_rxOther.GetIncreasement(), p_rxOther.GetSource(), p_rxOther.GetEnemy());
//			return(this^);
//		endproc;
		
		proc void OnTick(real p_fReal, CObjHndl p_xSource, int p_iEnemy)
		endproc;
		
		proc void OnDecay(int p_iID)
		endproc;
		
		export proc bool OnPush(ref CEvtPointer  p_rxEP)
			m_xOnTick.Call(m_fDmgPerTick, m_xSource, m_iEnemy);
			m_iTickCount++;
			if(m_iTickCount >= m_iMaxTickCount)then
				Reset();
//				m_xOnDecay.Call(m_iID);
			endif;
			m_iTickIncrease++;
			if(m_iTickIncrease >= m_iCounter)then
				m_iTickIncrease=0;
				m_fDmgPerTick += m_fIncrease;
			endif;
			m_iMaxTickCount=0;
			return true;
		endproc;
		
		export proc void InflictWound(real p_fDmg, int p_iCounter, real p_fIncrease, CObjHndl p_xSource, int p_iEnemy, int p_iMax)
			m_iTickCount=0;
			if(m_iMaxTickCount<p_iMax||m_iMaxTickCount<1)then
				m_iMaxTickCount=p_iMax;
			endif;
			if(m_iTimerID==-1)then
				m_iTimerID=CTimeMgr.Get().CreateTimer(CGameTimeSpan.OneSecond() * FREQUENCY, true);
				CTimeMgr.Get().GetTimer(m_iTimerID)^.Subscribe(this);
			endif;
			m_fDmgPerTick += p_fDmg;
			if(p_fIncrease>m_fIncrease)then
				m_fIncrease=p_fIncrease;
			endif;
			if(p_iCounter<m_iCounter||m_iCounter<1)then
				m_iCounter=p_iCounter;
			endif;
			m_xSource=p_xSource;
			m_iEnemy=p_iEnemy;
		endproc;
		
		export proc ref int GetCurTickCount()
			return m_iTickCount;
		endproc;
		
		export proc int GetCounter()
			return m_iCounter;
		endproc;
		
		export proc ref real GetDmgPerTick()
			return m_fDmgPerTick;
		endproc;
		
		export proc ref int GetIncreasement()
			return m_iCounter;
		endproc;
		
		export proc void Reset()
			if(m_iTimerID!=-1)then
				CTimeMgr.Get().GetTimer(m_iTimerID)^.Unsubscribe(this);
				CTimeMgr.Get().DeleteTimer(m_iTimerID);
				m_iTimerID=-1;
			endif;
			m_iTickCount=0;
			m_iMaxTickCount=0;
			m_fDmgPerTick=0.0;
			m_fIncrease=0.0;
			m_iCounter=0;
			m_xSource=CObjHndl.Invalid();
			m_iEnemy=-1;
		endproc;
		
		export proc void DoKArc(ref CArc p_rxArc, int p_iVersion)
			var bool bTimerStart=(m_iTimerID==-1);
			p_rxArc << m_iTimerID;
			p_rxArc << m_fDmgPerTick;
			p_rxArc << m_fIncrease;
			p_rxArc << m_iTickCount;
			p_rxArc << m_iMaxTickCount;
			p_rxArc << m_iTickIncrease;
			p_rxArc << m_iCounter;
			if(m_iTimerID!=-1&&bTimerStart)then
				m_iTimerID=CTimeMgr.Get().CreateTimer(CGameTimeSpan.OneSecond() * FREQUENCY, true);
				CTimeMgr.Get().GetTimer(m_iTimerID)^.Subscribe(this);
			endif;
			m_xSource.DoKArc(p_rxArc);
			p_rxArc << m_iEnemy;
		endproc;
		
	endclass;
	
	class CToDoEntry inherit CEvtSink
	
		export var procref <void, string, CObjHndl, CObjList, vec3, string, real> m_xOnExecute;
		
		export var string m_sToDoName;
		var string m_sParams;
		var vec3 m_vTarget;
		var CObjHndl m_xSubject;
		var CObjList m_xSubList;
		var real m_fStart;
		var real m_fNextDelay;
		var int m_iTimer;
		export var int m_iPlace;
		
		export constructor()
			m_xOnExecute=OnExecute;
			m_iTimer=-1;
		endconstructor;
		
		export destructor()
			if(m_iTimer!=-1)then
				CTimeMgr.Get().GetTimer(m_iTimer)^.Unsubscribe(this);
				CTimeMgr.Get().DeleteTimer(m_iTimer);
			endif;
		enddestructor;
		
		proc void OnExecute(string p_sTask, CObjHndl p_xSubject, CObjList p_xSubList, vec3 p_vTarget, string p_sParam, real p_fDelay)
		endproc;
		
		export proc bool OnPush(ref CEvtPointer p_rxEP)
			if(!m_xOnExecute.IsNull())then
				m_xOnExecute.Call(m_sToDoName,m_xSubject,m_xSubList,m_vTarget,m_sParams,m_fNextDelay);
			endif;
			return true;
		endproc;
		
		export proc void Initialize(string p_sTask, CObjHndl p_xSubject, CObjList p_xSubList, vec3 p_vTarget, string p_sParam, real p_fStart, real p_fDelay, bool p_bNow, procref <void,string,CObjHndl,CObjList,vec3,string,real> p_xProcRef)
			m_sToDoName=p_sTask;
			m_xSubject=p_xSubject;
			m_xSubList=p_xSubList;
			m_vTarget=p_vTarget;
			m_sParams=p_sParam;
			m_fStart=p_fStart;
			m_fNextDelay=p_fDelay;
			m_xOnExecute=p_xProcRef;
			if(p_bNow)then
				if(m_iTimer==-1)then
					var real fStart=m_fStart;
					if(fStart<=0.0)then fStart=1.0; endif;
					m_iTimer=CTimeMgr.Get().CreateTimer(CGameTimeSpan.OneSecond() * fStart, false);
					CTimeMgr.Get().GetTimer(m_iTimer)^.Subscribe(this);
				endif;
			endif;
		endproc;
		
		export proc void SetProcRef(procref <void,string,CObjHndl,CObjList,vec3,string,real> p_xProcRef)
			m_xOnExecute=p_xProcRef;
		endproc;
		
		export proc void SetPlace(int p_iPlace)
			m_iPlace=p_iPlace;
		endproc;
		
		export proc void StartTimer(real p_fAdd)
			if(m_iTimer==-1)then
				var real fStart=m_fStart+p_fAdd;
				if(fStart<=0.0)then fStart=1.0; endif;
				m_iTimer=CTimeMgr.Get().CreateTimer(CGameTimeSpan.OneSecond() * fStart, false);
				CTimeMgr.Get().GetTimer(m_iTimer)^.Subscribe(this);
			endif;
		endproc;
		
		export proc bool op_Greater(ref CFightingObj.CToDoEntry p_rxOther)
			return m_iPlace<p_rxOther.m_iPlace;
		endproc;
		
		export proc void DoKArc(ref CArc p_rxArc, int p_iVersion)
			var bool bTimerStart=(m_iTimer==-1);
			p_rxArc << m_iTimer;
			if(m_iTimer!=-1&&bTimerStart)then
				var ^CTimerObj pxTimer=CTimeMgr.Get().GetTimer(m_iTimer);
				if(pxTimer==null)then
					m_iTimer=CTimeMgr.Get().CreateTimer(CGameTimeSpan.OneSecond() * 5.0f, false);
					CTimeMgr.Get().GetTimer(m_iTimer)^.Subscribe(this);
				endif;
			endif;
			m_xSubList.DoKArc(p_rxArc);
			m_xSubject.DoKArc(p_rxArc);
			p_rxArc << m_sToDoName;
			p_rxArc << m_sParams;
			p_rxArc << m_vTarget;
			p_rxArc << m_fStart;
			p_rxArc << m_fNextDelay;
		endproc;
		
	endclass;
	
	//========================================================================================
	//===End of new FightingObj children classes in MIRAGE by Henry===========================
	//========================================================================================
	
endclass;
	
class CBonus
	
	export var array real		m_afTypeValue;
	export var array string		m_asTypeClass;
	
	export var array real		m_afClassValue;
	export var array string		m_asClassClass;
	
	export constructor()
	endconstructor;
	
	export proc void AddBonus( string p_sType, string p_sClass, real p_fValue)
		var int i;
		var int iIdx;
		if(p_sType=="Type")then
			iIdx=m_asTypeClass.FindEntry(p_sClass);
			if(iIdx!=-1)then
				m_afTypeValue[iIdx]+=p_fValue;
			else
				iIdx=m_asTypeClass.AddEntry(p_sClass);
				m_afTypeValue.AddEntry(p_fValue);
			endif;
		elseif(p_sType=="Class")then
			iIdx=m_asClassClass.FindEntry(p_sClass);
			if(iIdx!=-1)then
				m_afClassValue[iIdx]+=p_fValue;
			else
				iIdx=m_asClassClass.AddEntry(p_sClass);
				m_afClassValue.AddEntry(p_fValue);
			endif;
		endif;
		return;
	endproc;
	
	export proc ref CBonus op_Assign( ref CBonus p_rxN)
		m_asTypeClass=p_rxN.m_asTypeClass;
		m_afTypeValue=p_rxN.m_afTypeValue;
		m_asClassClass=p_rxN.m_asClassClass;
		m_afClassValue=p_rxN.m_afClassValue;
		return this^;
	endproc;
	
	export proc void Clear()
		m_asTypeClass=0;
		m_afTypeValue=0;
		m_asClassClass=0;
		m_afClassValue=0;
	endproc;
	
	export proc real GetBonus(string p_sType, string p_sClass)
		var real fBonus=0.0;
		var int iIdx=m_asTypeClass.FindEntry(p_sType);
		if(iIdx!=-1)then
			fBonus += m_afTypeValue[iIdx];
		endif;
		iIdx=m_asClassClass.FindEntry(p_sClass);
		if(iIdx!=-1)then
			fBonus += m_afClassValue[iIdx];
		endif;
		return fBonus;
	endproc;
	
	export proc int NumBoni()
		return m_asTypeClass.NumEntries();
	endproc;
	
endclass;
	
class CAreaDamage
	
	var ^CTimerTick				m_pxTick;
	
	var ^CFightingObj			m_pxFighter;
	var vec3							m_vTarget;
	var CObjHndl					m_xFighter;
	var int								m_iOwner;
	var int								m_iSizeClass;
	var bool							m_bBuildUp;
	var CObjHndl					m_xSpawner;
	var bool							m_bNoAir;
	var bool							m_bNoTraps;
	
	export constructor()
	endconstructor;
	
	export constructor(^CFightingObj p_pxFO, vec3 p_vTarget)
/*
		if(p_pxFO==null)then return; endif;
		var real fHitRange=p_pxFO^.GetHitRange();
		if(fHitRange==0.0)then CSrvWrap.LogError("CAreaDamage","CAreaDamage created by "+p_pxFO^.GetName()+", but hitrange is 0.0!"); return; endif;
		if(p_pxFO^.GetDmg()==0.0)then CSrvWrap.LogError("CAreaDamage","CAreaDamage created by "+p_pxFO^.GetName()+", but damage is 0.0!"); return; endif;
*/
		if(p_pxFO!=null)then
			m_iOwner=p_pxFO^.GetOwner();
			m_xFighter=p_pxFO^.GetHandle();
			m_pxFighter=p_pxFO;
			m_vTarget=p_vTarget;
			m_iSizeClass=p_pxFO^.GetWeaponSizeClass();
			m_bBuildUp=false;
			m_bNoAir=false;
			m_bNoTraps=false;
			DoAreaDamage(p_pxFO^.GetHitRange(), p_pxFO^.GetDmg(), p_pxFO^.GetEndDmg());
		endif;
	endconstructor;
	
	export constructor(^CFightingObj p_pxFO, vec3 p_vTarget, real p_fRange, int p_iSizeClass)
		if(p_pxFO!=null)then
			m_iOwner=p_pxFO^.GetOwner();
			m_xFighter=p_pxFO^.GetHandle();
			m_pxFighter=p_pxFO;
			m_vTarget=p_vTarget;
			m_iSizeClass=p_iSizeClass;
			m_bBuildUp=false;
			m_bNoAir=false;
			m_bNoTraps=false;
			DoAreaDamage(p_fRange, p_pxFO^.GetDmg(), p_pxFO^.GetEndDmg());
		endif;
	endconstructor;
	
	export constructor(^CFightingObj p_pxFO, vec3 p_vTarget, int p_iSizeClass)
		if(p_pxFO!=null)then
			m_iOwner=p_pxFO^.GetOwner();
			m_xFighter=p_pxFO^.GetHandle();
			m_pxFighter=p_pxFO;
			m_vTarget=p_vTarget;
			m_iSizeClass=p_iSizeClass;
			m_bBuildUp=false;
			m_bNoAir=false;
			m_bNoTraps=false;
			DoAreaDamage(p_pxFO^.GetHitRange(), p_pxFO^.GetDmg(), p_pxFO^.GetEndDmg());
		endif;
	endconstructor;
	
	export constructor(^CFightingObj p_pxObj, string p_sTTPath, vec3 p_vTarget)
		if(p_pxObj!=null)then
			m_xFighter=p_pxObj^.GetHandle();
			m_iOwner=p_pxObj^.GetOwner();
			m_pxFighter=p_pxObj;
			m_vTarget=p_vTarget;
			var ^CPlayer pxPlayer=CSrvWrap.GetCurLevel()^.GetPlayer(m_iOwner);
			var CTechTree xTT;
			if(pxPlayer!=null)then
				xTT=pxPlayer^.GetPlayerTechTree();
			endif;
			var real fDmg 			= 0.0f;
			var real fEndDmg		= 0.0f;
			var real fHitRange	= 0.0f;
			m_iSizeClass				= 0;
			var ^CTechTree.CNode pxTTNode=xTT.FindNode(p_sTTPath);
			if(pxTTNode!=null)then
				fDmg					= pxTTNode^.GetSubValueF("damage",0.0f);
				fEndDmg				= pxTTNode^.GetSubValueF("enddamage",0.0f);
				fHitRange			= pxTTNode^.GetSubValueF("hitrange",0.0f);
				m_iSizeClass	= pxTTNode^.GetSubValueI("unit_size",0);
				m_bNoAir			= pxTTNode^.GetSubValueI("airweapon",0)==0;
			endif;
			m_bBuildUp=false;
//			m_bNoAir=false;
			m_bNoTraps=false;
			DoAreaDamage(fHitRange, fDmg, fEndDmg);
		endif;
	endconstructor;
	
	export constructor(string p_sTTPath, real p_fHitRange, real p_fDmg, real p_fEndDmg, int p_iOwner, vec3 p_vPos, int p_iSizeClass)
		m_iOwner=p_iOwner;
		m_vTarget=p_vPos;
		var ^CPlayer pxPlayer=CSrvWrap.GetCurLevel()^.GetPlayer(m_iOwner);
		var CTechTree xTT;
		if(pxPlayer!=null)then
			xTT=pxPlayer^.GetPlayerTechTree();
		endif;
		var real fDmg				= p_fDmg;
		var real fEndDmg		= p_fEndDmg;
		var real fHitRange	= p_fHitRange;
		m_iSizeClass				= p_iSizeClass;
		var ^CTechTree.CNode pxTTNode=xTT.FindNode(p_sTTPath);
		if(pxTTNode!=null)then
			fDmg					= pxTTNode^.GetSubValueF("damage",0.0f);
			fEndDmg				= pxTTNode^.GetSubValueF("enddamage",0.0f);
			fHitRange			= pxTTNode^.GetSubValueF("hitrange",0.0f);
			m_iSizeClass	= pxTTNode^.GetSubValueI("unit_size",0);
		endif;
		m_bNoAir=false;
		m_bNoTraps=false;
		DoAreaDamage(fHitRange, fDmg, fEndDmg);
	endconstructor;
	
	export constructor(^CFightingObj p_pxFO, bool p_bBuildUp, vec3 p_vTarget, int p_iSizeClass, bool p_bNoAir, real p_fHitrange, real p_fDamage, real p_fEndDamage)
		if(p_pxFO!=null)then
			m_iOwner=p_pxFO^.GetOwner();
			m_xFighter=p_pxFO^.GetHandle();
			m_pxFighter=p_pxFO;
			m_vTarget=p_vTarget;
			m_iSizeClass=p_iSizeClass;
			m_bBuildUp=p_bBuildUp;
			m_bNoAir=p_bNoAir;
			m_bNoTraps=false;
			DoAreaDamage(p_fHitrange, p_fDamage, p_fEndDamage);
		endif;
	endconstructor;
	
	export constructor(real p_fHitRange, real p_fDmg, real p_fEndDmg, int p_iOwner, vec3 p_vPos)
		m_iOwner=p_iOwner;
		m_vTarget=p_vPos;
		m_bNoAir=false;
		m_bNoTraps=false;
		DoAreaDamage(p_fHitRange, p_fDmg, p_fEndDmg);
	endconstructor;
	
	export constructor(real p_fHitRange, real p_fDmg, real p_fEndDmg, int p_iOwner, vec3 p_vPos, int p_iSizeClass)
		m_iOwner=p_iOwner;
		m_vTarget=p_vPos;
		m_iSizeClass=p_iSizeClass;
		m_bNoAir=false;
		m_bNoTraps=false;
		DoAreaDamage(p_fHitRange, p_fDmg, p_fEndDmg);
	endconstructor;
	
	export constructor(real p_fHitRange, real p_fDmg, real p_fEndDmg, int p_iOwner, vec3 p_vPos, int p_iSizeClass, bool p_bNoAir)
		m_iOwner=p_iOwner;
		m_vTarget=p_vPos;
		m_iSizeClass=p_iSizeClass;
		m_bNoAir=p_bNoAir;
		DoAreaDamage(p_fHitRange, p_fDmg, p_fEndDmg);
	endconstructor;
	
	export constructor(real p_fHitRange, real p_fDmg, real p_fEndDmg, int p_iOwner, vec3 p_vPos, int p_iSizeClass, bool p_bNoAir, bool p_bNoTraps)
		m_iOwner=p_iOwner;
		m_vTarget=p_vPos;
		m_iSizeClass=p_iSizeClass;
		m_bNoAir=p_bNoAir;
		m_bNoTraps=p_bNoTraps;
		DoAreaDamage(p_fHitRange, p_fDmg, p_fEndDmg);
	endconstructor;
	
	proc void DoAreaDamage(real p_fHitRange, real p_fDmg, real p_fEndDmg)
		if(p_fHitRange<=0.0)then
			p_fHitRange=1.0;
		endif;
		if(m_xFighter.IsValid())then
			m_pxFighter^.UpdateFightFactors();
		endif;
		var CObjList xEnemies;
		var CObjQuery xQuery;
		CSrvWrap.GetDiplomacyMgr().AddMyEnemiesToSearch(m_iOwner, xQuery, false);
		xQuery.SetOwner(-1, true);
		xQuery.SetType("CHTR");
		xQuery.SetType("SHIP",true);
		xQuery.SetType("ANML",true);
		xQuery.SetType("VHCL",true);
		xQuery.SetType("BLDG",true);
		xQuery.SetType("FGHT",true);
		xQuery.SetType("NEST",true);
		xQuery.RegionCircle(m_vTarget, p_fHitRange+20.0);
		xQuery.Execute(xEnemies);
		var int i, iC=xEnemies.NumEntries();
		for (i=0) cond(i<iC) iter(++i)do
			var ^CFightingObj pxFO=cast<CFightingObj>(xEnemies[i].GetObj());
			if(pxFO==null)then continue; endif;
			if(pxFO^.GetTransportObj().IsValid()||pxFO^.GetOnWall())then continue; endif;
			if(!pxFO^.IsHitable())then continue; endif;
			if(m_bNoAir&&pxFO^.IsFlyingUnit())then continue; endif;
			if(m_bNoTraps&&pxFO^.IsItATrap())then continue; endif;
//			if(m_bNoTraps&&pxFO^.GetIsTrap())then continue; endif;
			var real fDistance=(pxFO^.GetPos() - m_vTarget).Abs2();
			fDistance-=pxFO^.GetCollisionRadius();
			if(fDistance>=p_fHitRange)then xEnemies.DeleteEntry(i);i--; iC--; continue; endif;
			if(fDistance<0.0)then fDistance=0.0; endif;
			var real fEndDamageFactor=0.0;
			if(p_fDmg!=0.0)then
				fEndDamageFactor=p_fEndDmg / p_fDmg;
			endif;
			var real fFactor=( (1.0 - fEndDamageFactor) * ((p_fHitRange - fDistance) / p_fHitRange) )+fEndDamageFactor;
			//L CSrvWrap.LogInfo("AreaDamage","p_fDmg/p_fEndDmg/fFactor "+p_fDmg.ToString()+"/"+p_fEndDmg.ToString()+"/"+fFactor.ToString());
			pxFO^.ClearDamageCache();
			if(m_xFighter.IsValid())then
				if(m_bBuildUp)then
					pxFO^.SetLastDamage(m_iOwner);
					pxFO^.TakeDmgFromBuildup(m_pxFighter, fFactor, m_pxFighter^.GetHitDelay());
					pxFO^.AddEnemy(m_xFighter, true);
				else
					pxFO^.SetLastDamage(m_iOwner);
					pxFO^.TakeDmg(m_pxFighter, fFactor);
					pxFO^.AddEnemy(m_xFighter, true);
				endif;
			else
				pxFO^.SetLastDamage(m_iOwner);
				pxFO^.TakeDirectDmg(p_fDmg*fFactor,m_xFighter);
			endif;
		endfor;
		if(m_iSizeClass>0)then
			CFightingObj.InvokeAreaThrow(m_vTarget,xEnemies,m_iSizeClass);
		endif;
		m_pxTick=new CTimerTick();
		m_pxTick^.m_xOnTick=OnDelete;
		m_pxTick^.SetTimer(0.5);
	endproc;
	
	export constructor(real p_fHitRange, real p_fDmg, real p_fEndDmg, int p_iOwner, vec3 p_vPos, string p_sType) //Henry: just to make it different...
		m_iOwner=p_iOwner;
		m_vTarget=p_vPos;
		DoAreaDamageForAll(p_fHitRange, p_fDmg, p_fEndDmg);
	endconstructor;
	
	proc void DoAreaDamageForAll(real p_fHitRange, real p_fDmg, real p_fEndDmg)
		if(p_fHitRange<=0.0)then
			p_fHitRange=1.0;
		endif;
		if(m_xFighter.IsValid())then
			m_pxFighter^.UpdateFightFactors();
		endif;
		var CObjList xEnemies;
		var CObjQuery xQuery;
		xQuery.SetOwner(-1, true);
		xQuery.SetType("CHTR");
		xQuery.SetType("SHIP",true);
		xQuery.SetType("ANML",true);
		xQuery.SetType("VHCL",true);
		xQuery.SetType("BLDG",true);
		xQuery.SetType("FGHT",true);
		xQuery.SetType("NEST",true);
		xQuery.RegionCircle(m_vTarget, p_fHitRange+20.0);
		xQuery.Execute(xEnemies);
		var int i, iC=xEnemies.NumEntries();
		for (i=0) cond(i<iC) iter(++i)do
			var ^CFightingObj pxFO=cast<CFightingObj>(xEnemies[i].GetObj());
			if(pxFO==null)then continue; endif;
			if(pxFO^.GetTransportObj().IsValid()||pxFO^.GetOnWall())then continue; endif;
			if(!pxFO^.IsHitable())then continue; endif;
			var real fDistance=(pxFO^.GetPos() - m_vTarget).Abs2();
			fDistance-=pxFO^.GetCollisionRadius();
			if(fDistance>=p_fHitRange)then xEnemies.DeleteEntry(i);i--; iC--; continue; endif;
			if(fDistance<0.0)then fDistance=0.0; endif;
			var real fEndDamageFactor=0.0;
			if(p_fDmg!=0.0)then
				fEndDamageFactor=p_fEndDmg / p_fDmg;
			endif;
			var real fFactor=( (1.0 - fEndDamageFactor) * ((p_fHitRange - fDistance) / p_fHitRange) )+fEndDamageFactor;
			pxFO^.ClearDamageCache();
			if(m_xFighter.IsValid())then
				if(m_bBuildUp)then
					pxFO^.SetLastDamage(m_iOwner);
					pxFO^.TakeDmgFromBuildup(m_pxFighter, fFactor, m_pxFighter^.GetHitDelay());
					pxFO^.AddEnemy(m_xFighter, true);
				else
					pxFO^.SetLastDamage(m_iOwner);
					pxFO^.TakeDmg(m_pxFighter, fFactor);
					pxFO^.AddEnemy(m_xFighter, true);
				endif;
			else
				pxFO^.SetLastDamage(m_iOwner);
				pxFO^.TakeDirectDmg(p_fDmg*fFactor,m_xFighter);
			endif;
		endfor;
		if(m_iSizeClass>0)then
			CFightingObj.InvokeAreaThrow(m_vTarget,xEnemies,m_iSizeClass);
		endif;
		m_pxTick=new CTimerTick();
		m_pxTick^.m_xOnTick=OnDelete;
		m_pxTick^.SetTimer(0.5);
	endproc;
	
	export constructor(CObjHndl p_xOwner, real p_fHitRange, real p_fDmg, real p_fEndDmg, int p_iOwner, vec3 p_vPos, int p_iSizeClass)
		m_xFighter=p_xOwner;
		m_iOwner=p_iOwner;
		m_iSizeClass=p_iSizeClass;
		m_vTarget=p_vPos;
		DoAreaDamageForAllAgain(p_fHitRange, p_fDmg, p_fEndDmg, 0.0f);
	endconstructor;
	
	export constructor(CObjHndl p_xOwner, real p_fHitRange, real p_fDmg, real p_fEndDmg, int p_iOwner, vec3 p_vPos, int p_iSizeClass, real p_fPiercing)
		m_xFighter=p_xOwner;
		m_iOwner=p_iOwner;
		m_iSizeClass=p_iSizeClass;
		m_vTarget=p_vPos;
		DoAreaDamageForAllAgain(p_fHitRange, p_fDmg, p_fEndDmg, p_fPiercing);
	endconstructor;
	
	proc void DoAreaDamageForAllAgain(real p_fHitRange, real p_fDmg, real p_fEndDmg, real p_fPiercing)
		if(p_fHitRange<=0.0)then
			p_fHitRange=1.0;
		endif;
		var CObjList xEnemies;
		var CObjQuery xQuery;
		xQuery.SetOwner(-1, true);
		//CSrvWrap.GetDiplomacyMgr().AddMyEnemiesToSearch(m_iOwner, xQuery, false);
		//CSrvWrap.GetDiplomacyMgr().AddMyFriendsToSearch(m_iOwner, xQuery);
		xQuery.SetType("CHTR");
		xQuery.SetType("SHIP",true);
		xQuery.SetType("ANML",true);
		xQuery.SetType("VHCL",true);
		xQuery.SetType("BLDG",true);
		xQuery.SetType("FGHT",true);
		xQuery.SetType("NEST",true);
		xQuery.RegionCircle(m_vTarget, p_fHitRange+20.0);
		xQuery.Execute(xEnemies);
		var int i, iC=xEnemies.NumEntries();
		for (i=0) cond(i<iC) iter(++i)do
			var ^CFightingObj pxFO=cast<CFightingObj>(xEnemies[i].GetObj());
			if(pxFO==null)then continue; endif;
			if(pxFO^.GetTransportObj().IsValid()||pxFO^.GetOnWall())then continue; endif;
			if(!pxFO^.IsHitable())then continue; endif;
			var real fDistance=(pxFO^.GetPos() - m_vTarget).Abs2();
			fDistance-=pxFO^.GetCollisionRadius();
			if(fDistance>=p_fHitRange)then xEnemies.DeleteEntry(i);i--; iC--; continue; endif;
			if(fDistance<0.0)then fDistance=0.0; endif;
			var real fEndDamageFactor=0.0;
			if(p_fDmg!=0.0)then
				fEndDamageFactor=p_fEndDmg / p_fDmg;
			endif;
			var real fFactor=( (1.0 - fEndDamageFactor) * ((p_fHitRange - fDistance) / p_fHitRange) )+fEndDamageFactor;
			pxFO^.SetLastDamage(m_iOwner);
			pxFO^.TakeDirectDmg(p_fDmg*fFactor,p_fPiercing,m_xFighter);
		endfor;
		if(m_iSizeClass>0)then
			CFightingObj.InvokeAreaThrow(m_vTarget,xEnemies,m_iSizeClass);
		endif;
		m_pxTick=new CTimerTick();
		m_pxTick^.m_xOnTick=OnDelete;
		m_pxTick^.SetTimer(0.5);
	endproc;
	
	export constructor(^CFightingObj p_pxObj, CObjHndl p_xSpawner, string p_sTTPath, vec3 p_vTarget)
		if(p_pxObj!=null)then
			m_xFighter=p_pxObj^.GetHandle();
			m_pxFighter=p_pxObj;
			if(p_xSpawner.IsValid())then
				m_xSpawner=p_xSpawner;
			else
				m_xSpawner=p_pxObj^.GetSpawningPool();
			endif;
			m_iOwner=p_pxObj^.GetOwner();
			m_vTarget=p_vTarget;
			var ^CPlayer pxPlayer=CSrvWrap.GetCurLevel()^.GetPlayer(m_iOwner);
			var CTechTree xTT;
			if(pxPlayer!=null)then
				xTT=pxPlayer^.GetPlayerTechTree();
			endif;
			var real fDmg				= 0.0f;
			var real fEndDmg		= 0.0f;
			var real fHitRange	= 0.0f;
			m_iSizeClass				= 0;
			var ^CTechTree.CNode pxTTNode=xTT.FindNode(p_sTTPath);
			if(pxTTNode!=null)then
				fDmg					= pxTTNode^.GetSubValueF("damage",0.0f);
				fEndDmg				= pxTTNode^.GetSubValueF("enddamage",0.0f);
				fHitRange			= pxTTNode^.GetSubValueF("hitrange",0.0f);
				m_iSizeClass	= pxTTNode^.GetSubValueI("unit_size",0);
			endif;
			DoAreaDamageCreditingSpawner(fHitRange, fDmg, fEndDmg);
		endif;
	endconstructor;
	
	export constructor(^CFightingObj p_pxObj, CObjHndl p_xSpawner, real p_fHitRange, real p_fDmg, real p_fEndDmg, int p_iOwner, vec3 p_vPos, int p_iSizeClass)
		if(p_xSpawner.IsValid())then
			m_xSpawner=p_xSpawner;
		endif;
		if(p_pxObj!=null)then
			m_xFighter=p_pxObj^.GetHandle();
			m_pxFighter=p_pxObj;
			if(!m_xSpawner.IsValid())then
				m_xSpawner=p_pxObj^.GetSpawningPool();
			endif;
		endif;
		m_iOwner=p_iOwner;
		m_vTarget=p_vPos;
		m_iSizeClass = p_iSizeClass;
		DoAreaDamageCreditingSpawner(p_fHitRange, p_fDmg, p_fEndDmg);
	endconstructor;
	
	proc void DoAreaDamageCreditingSpawner(real p_fHitRange, real p_fDmg, real p_fEndDmg)
		if(p_fHitRange<=0.0)then
			p_fHitRange=1.0;
		endif;
		if(m_pxFighter!=null)then
			m_pxFighter^.UpdateFightFactors();
		endif;
		var CObjList xEnemies;
		var CObjQuery xQuery;
		CSrvWrap.GetDiplomacyMgr().AddMyEnemiesToSearch(m_iOwner, xQuery, false);
		xQuery.SetOwner(-1, true);
		xQuery.SetType("CHTR");
		xQuery.SetType("SHIP",true);
		xQuery.SetType("ANML",true);
		xQuery.SetType("VHCL",true);
		xQuery.SetType("BLDG",true);
		xQuery.SetType("FGHT",true);
		xQuery.SetType("NEST",true);
		xQuery.RegionCircle(m_vTarget, p_fHitRange+20.0);
		xQuery.Execute(xEnemies);
		var int i, iC=xEnemies.NumEntries();
		for (i=0) cond(i<iC) iter(++i)do
			var ^CFightingObj pxFO=cast<CFightingObj>(xEnemies[i].GetObj());
			if(pxFO==null)then continue; endif;
			if(pxFO^.GetTransportObj().IsValid()||pxFO^.GetOnWall())then continue; endif;
			if(!pxFO^.IsHitable())then continue; endif;
			var real fDistance=(pxFO^.GetPos() - m_vTarget).Abs2();
			fDistance-=pxFO^.GetCollisionRadius();
			if(fDistance>=p_fHitRange)then xEnemies.DeleteEntry(i);i--; iC--; continue; endif;
			if(fDistance<0.0)then fDistance=0.0; endif;
			var real fEndDamageFactor=0.0;
			if(p_fDmg!=0.0)then
				fEndDamageFactor=p_fEndDmg / p_fDmg;
			endif;
			var real fFactor=( (1.0 - fEndDamageFactor) * ((p_fHitRange - fDistance) / p_fHitRange) )+fEndDamageFactor;
			pxFO^.ClearDamageCache();
			if(m_xFighter.IsValid())then
				pxFO^.SetLastDamage(m_iOwner);
				pxFO^.TakeDmg(m_pxFighter, fFactor);
				pxFO^.AddEnemy(m_xFighter, true);
			else
				pxFO^.SetLastDamage(m_iOwner);
				pxFO^.TakeDirectDmg(p_fDmg*fFactor,m_xSpawner);
			endif;
		endfor;
		if(m_iSizeClass>0)then
			CFightingObj.InvokeAreaThrow(m_vTarget,xEnemies,m_iSizeClass);
		endif;
		m_pxTick=new CTimerTick();
		m_pxTick^.m_xOnTick=OnDelete;
		m_pxTick^.SetTimer(0.5);
	endproc;
	
	export constructor(real p_fHitRange, real p_fDmg, real p_fEndDmg, int p_iOwner, vec3 p_vPos, int p_iSizeClass, ^CFightingObj p_pxFO)
		if(p_pxFO!=null)then
			m_xFighter=p_pxFO^.GetHandle();
			m_pxFighter=p_pxFO;
		endif;
		m_iOwner=p_iOwner;
		m_iSizeClass=p_iSizeClass;
		m_vTarget=p_vPos;
		DoAreaDamagePrecise(p_fHitRange, p_fDmg, p_fEndDmg);
	endconstructor;
	
	proc void DoAreaDamagePrecise(real p_fHitRange, real p_fDmg, real p_fEndDmg)
		if(p_fHitRange<=0.0)then
			p_fHitRange=1.0;
		endif;
		if(m_xFighter.IsValid())then
			m_pxFighter^.UpdateFightFactors();
		endif;
		var CObjList xEnemies;
		var CObjQuery xQuery;
		CSrvWrap.GetDiplomacyMgr().AddMyEnemiesToSearch(m_iOwner, xQuery, false);
		xQuery.SetOwner(-1, true);
		xQuery.SetType("CHTR");
		xQuery.SetType("SHIP",true);
		xQuery.SetType("ANML",true);
		xQuery.SetType("VHCL",true);
		xQuery.SetType("BLDG",true);
		xQuery.SetType("FGHT",true);
		xQuery.SetType("NEST",true);
		xQuery.RegionCircle(m_vTarget, p_fHitRange+20.0);
		xQuery.Execute(xEnemies);
		var int i, iC=xEnemies.NumEntries();
		for(i=0)cond(i<iC)iter(++i)do
			var ^CFightingObj pxFO=cast<CFightingObj>(xEnemies[i].GetObj());
			if(pxFO==null)then continue; endif;
			if(pxFO^.GetTransportObj().IsValid()||pxFO^.GetOnWall())then continue; endif;
			if(!pxFO^.IsHitable())then continue; endif;
			if(m_bNoAir&&pxFO^.IsFlyingUnit())then continue; endif;
			if(m_bNoTraps&&pxFO^.IsItATrap())then continue; endif;
//			if(m_bNoTraps&&pxFO^.GetIsTrap())then continue; endif;
			var real fDistance=(pxFO^.GetPos() - m_vTarget).Abs2();
			fDistance-=pxFO^.GetCollisionRadius();
			if(fDistance>=p_fHitRange)then xEnemies.DeleteEntry(i);i--; iC--; continue; endif;
			if(fDistance<0.0)then fDistance=0.0; endif;
			var real fEndDamageFactor=0.0;
			if(p_fDmg!=0.0)then
				fEndDamageFactor=p_fEndDmg / p_fDmg;
			endif;
			var real fFactor=( (1.0 - fEndDamageFactor) * ((p_fHitRange - fDistance) / p_fHitRange) )+fEndDamageFactor;
			pxFO^.AddEnemy(m_xFighter, true);
			pxFO^.SetLastDamage(m_iOwner);
			pxFO^.TakeDirectDmg(p_fDmg*fFactor,m_xFighter);
		endfor;
		if(m_iSizeClass>0)then
			CFightingObj.InvokeAreaThrow(m_vTarget,xEnemies,m_iSizeClass);
		endif;
		m_pxTick=new CTimerTick();
		m_pxTick^.m_xOnTick=OnDelete;
		m_pxTick^.SetTimer(0.5);
	endproc;
	
	export destructor()
		delete m_pxTick;
	enddestructor;
	
	proc void OnDelete()
		delete this;
	endproc;
	
endclass;
	
class CAttribBonus
	export var real		m_fBonus;
	export var int		m_iType;
	export var string	m_sIdentifier;			// used to identify this boni when removing
	
	export proc void Set(int p_iType, string p_sID, real p_fBonus)
		m_iType=p_iType;
		m_sIdentifier=p_sID;
		m_fBonus=p_fBonus;
	endproc;
endclass;
	
class CBoniBucket
	
	export var int 				m_iType;
	var array CAttribBonus		m_axBoni;
	
	export proc int NumEntries()
		return m_axBoni.NumEntries();
	endproc;
	
	export proc int FindEntry(string p_sID)
		var int i, iC=m_axBoni.NumEntries();
		for(i=0) cond(i<iC) iter(++i)do
			if(m_axBoni[i].m_sIdentifier==p_sID)then
				return i;
			endif;
		endfor;
		return -1;
	endproc;
	
	export proc void AddEntry(ref CAttribBonus p_rxBonus)
		if(p_rxBonus.m_iType==m_iType)then
			if(FindEntry(p_rxBonus.m_sIdentifier)<0)then
				m_axBoni.AddEntry(p_rxBonus);
			else
				m_axBoni[FindEntry(p_rxBonus.m_sIdentifier)].m_fBonus=p_rxBonus.m_fBonus;
			endif;
		endif;
	endproc;
	
	export proc void AddEntry(string p_sID, real p_fBonus)
		var CAttribBonus xB;
		xB.Set(m_iType, p_sID, p_fBonus);
		AddEntry(xB);
	endproc;
	
	export proc void RemEntry(int p_iIdx)
		m_axBoni.DeleteEntryUS(p_iIdx);
	endproc;
	
	export proc void RemEntry(string p_sID)
		var int iIdx=FindEntry(p_sID);
		if(iIdx >= 0)then
			m_axBoni.DeleteEntryUS(iIdx);
		endif;
	endproc;
	
	export proc ref CAttribBonus op_Index(int p_iIdx)
		return m_axBoni[p_iIdx];
	endproc;
	
	export proc real GetBonusValue(int p_iID)
		return m_axBoni[p_iID].m_fBonus;
	endproc;
	
endclass;
