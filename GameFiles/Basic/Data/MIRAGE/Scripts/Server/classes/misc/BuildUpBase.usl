class CBuildUpFactory
	
	static var ^CBuildUpFactory ms_pxInst;
	
	export static proc ref CBuildUpFactory Get()
		if(ms_pxInst==null)then
			ms_pxInst = new CBuildUpFactory();
		endif;
		return ms_pxInst^;
	endproc;
	
	export static proc void Kill()
		delete ms_pxInst;
	endproc;
	
	export proc ^CBuildUpBase CreateBuildUp(int p_iType)
		var ^CBuildUpBase pxBuildUp;
		if(p_iType==CBuildUpBase.TYPE_FAKE)then
			pxBuildUp = new CBuildUpBase();
		elseif(p_iType==CBuildUpBase.TYPE_SIEGE)then
			pxBuildUp = new CBuildUpBase();
		elseif(p_iType==CBuildUpBase.TYPE_TRANSPORTER)then
			pxBuildUp = new CBuildUpTransporter();
		elseif(p_iType==CBuildUpBase.TYPE_TRANSPORTER_OPEN)then
			pxBuildUp = new CBuildUpTransporterOpen();
		elseif(p_iType==CBuildUpBase.TYPE_WEAPON)then
			pxBuildUp = new CBuildUpWeapon();
		elseif(p_iType==CBuildUpBase.TYPE_WEAPON_TRANSPORTER)then
			pxBuildUp = new CBuildUpWeaponTransporter();
		elseif(p_iType==CBuildUpBase.TYPE_TREX)then
			pxBuildUp = new CBuildUpRexTransporter();
		elseif(p_iType==CBuildUpBase.TYPE_SEISMO)then
			pxBuildUp = new CBuildUpSeismoTransporter();
		elseif(p_iType==CBuildUpBase.TYPE_TRIC_TITAN)then
			pxBuildUp = new CBuildUpTricTitanTransporter();
		elseif(p_iType==CBuildUpBase.TYPE_TRIC_TRANSPORTER)then
			pxBuildUp = new CBuildUpTricTransporter();
		elseif(p_iType==CBuildUpBase.TYPE_STYRA_TRANSPORTER)then
			pxBuildUp = new CBuildUpNinigiStyraTransporter();
		elseif(p_iType==CBuildUpBase.TYPE_CYBORG_TRANSPORTER)then
			pxBuildUp = new CBuildUpAjeCyborgTransporter();
		endif;
		return pxBuildUp;
	endproc;
	
endclass;
	
class CUniversalLinkObj
	
	var CFourCC		m_xLink;
	var CObjHndl	m_xObj;
	var real			m_fFlexDelay;
	var vec3			m_vLinkOffset;
	var bool			m_bCustom;
	var CObjHndl	m_xParentObj;
	
	export constructor()
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc void DoKArc(ref CArc p_rxArc, int p_iVersion)
		var string sLink = m_xLink.AsString();
		p_rxArc << sLink;
		m_xLink = sLink;
		if(p_iVersion>=8)then
			m_xParentObj.DoKArc(p_rxArc);
		endif;
		m_xObj.DoKArc(p_rxArc);
		if(p_iVersion>=10)then
			p_rxArc << m_fFlexDelay;
		endif;
	endproc;
	
	export proc void DoKArcMirage(ref CArc p_rxArc, int p_iVersion)
		if(p_iVersion>=1)then
			p_rxArc << m_vLinkOffset;
			p_rxArc << m_bCustom;
		endif;
	endproc;
	
	export proc void DoKArcResource(ref CArc p_rxArc, int p_iVersion)
		var string sLink = m_xLink.AsString();
		p_rxArc << sLink;
		m_xLink = sLink;
		m_xParentObj.DoKArc(p_rxArc);
		m_xObj.DoKArc(p_rxArc);
		p_rxArc << m_fFlexDelay;
		p_rxArc << m_vLinkOffset;
		p_rxArc << m_bCustom;
	endproc;
	
	export proc void SetLink(string p_sLink)
		m_xLink = p_sLink;
	endproc;
	
	export proc CFourCC GetLink()
		return m_xLink;
	endproc;
	
	export proc void SetHandle(CObjHndl p_xObj)
		m_xObj = p_xObj;
	endproc;
	
	export proc CObjHndl GetHandle()
		return m_xObj;
	endproc;
	
	export proc void SetDelay(real p_fDelay)
		m_fFlexDelay = p_fDelay;
	endproc;
	
	export proc real GetDelay()
		return m_fFlexDelay;
	endproc;
	
	export proc void SetParentObj(CObjHndl p_xObj)
		m_xParentObj = p_xObj;
	endproc;
	
	export proc CObjHndl GetParentObj()
		return m_xParentObj;
	endproc;
	
	export proc void SetLinkOffset(vec3 p_vOffset)
		m_vLinkOffset = p_vOffset;
	endproc;
	
	export proc vec3 GetLinkOffset()
		return m_vLinkOffset;
	endproc;
	
	export proc void SetCustom(bool p_bCustom)
		m_bCustom = p_bCustom;
	endproc;
	
	export proc bool GetCustom()
		return m_bCustom;
	endproc;
	
endclass;
	
class CBuildUpBase
	
	export const int TYPE_NONE = 0;
	export const int TYPE_FAKE = 1;
	export const int TYPE_TRANSPORTER = 2;
	export const int TYPE_TRANSPORTER_OPEN = 3;
	export const int TYPE_LUMBERUPGRADE = 4;
	export const int TYPE_SIEGE = 5;
	export const int TYPE_WEAPON = 11;
	export const int TYPE_WEAPON_LOGCANNON = 12;
	export const int TYPE_WEAPON_TRANSPORTER = 13;
	export const int TYPE_TREX = 14;
	export const int TYPE_SEISMO = 15;
	export const int TYPE_TRIC_TITAN = 16;
	export const int TYPE_TRIC_TRANSPORTER = 17;
	export const int TYPE_STYRA_TRANSPORTER = 18;
	export const int TYPE_CYBORG_TRANSPORTER = 19;
	
	var int							m_iType;
	var CObjHndl				m_xParent;
	var string					m_sAnim;
	
	var array CUniversalLinkObj m_axLinkedObjs;
	
	var int m_iAggressionState;
	
	export constructor()
		SetType(CBuildUpBase.TYPE_FAKE);
		m_iAggressionState = 2;
		m_sAnim="standanim";
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc void DoKArc(ref CArc p_rxArc, int p_iVersion)
		p_rxArc << m_iType;
		var int i, iC = m_axLinkedObjs.NumEntries();
		p_rxArc << iC;
		p_rxArc << m_iAggressionState;
		m_axLinkedObjs = iC;
		for(i=0)cond(i<iC)iter(i++)do
			m_axLinkedObjs[i].DoKArc(p_rxArc, p_iVersion);
		endfor;
		if(p_iVersion>=14)then
			m_xParent.DoKArc(p_rxArc);
		endif;
	endproc;
	
	export proc void DoKArcMirage(ref CArc p_rxArc, int p_iVersion)
		if(p_iVersion>=1)then
			var int i, iC = m_axLinkedObjs.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				m_axLinkedObjs[i].DoKArcMirage(p_rxArc, p_iVersion);
			endfor;
		endif;
	endproc;
	
	export proc void OnPostLoad()
	endproc;
	
	export proc void EnableLinkedObjs()
	endproc;
	
	export proc void OnActionEnd(bool p_bBroken)
	endproc;
	
	export proc void SetType(int p_iType)
		m_iType = p_iType;
	endproc;
	
	export proc int GetType()
		return m_iType;
	endproc;
	
	export proc void Kill()
		var ^CGameObj pxParent = m_xParent.GetObj();
		var int i, iC = m_axLinkedObjs.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CGameObj pxObj = m_axLinkedObjs[i].GetHandle().GetObj();
			if(pxObj==null)then continue; endif;
			if(pxParent!=null)then
				pxParent^.RemGroupedChildren(pxObj^.GetGuid());
			endif;
			pxObj^.Delete();
		endfor;
		delete this;
	endproc;
	
	export proc void SetOwner(int p_iOwner)
		var int i, iC = m_axLinkedObjs.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CGameObj pxObj = m_axLinkedObjs[i].GetHandle().GetObj();
			if(pxObj==null)then continue; endif;
			pxObj^.SetOwner(p_iOwner);
		endfor;
	endproc;
	
	export proc void SetAggressionState(int p_iState)
		m_iAggressionState = p_iState;
	endproc;
	
	export proc void SetParent(CObjHndl p_xParent)
		m_xParent = p_xParent;
	endproc;
	
	export proc CObjHndl GetParent()
		return m_xParent;
	endproc;
	
	export proc bool AttackEnemy(^CGameObj p_pxObj, vec3 p_vPos)
		return false;
	endproc;
	
	export proc void Fight(^CGameObj p_pxTarget, vec3 p_vPos, bool p_bUserCommand, bool p_bQ)
	endproc;
	
	export proc void PlayExtraAnim(string p_sAnim)
	endproc;
	
	export proc void OnActionStart()
		var ^CAnimal pxParent=cast<CAnimal>(m_xParent.GetObj());
		if(pxParent==null||pxParent^.GetClassName()!="aje_velociraptor_handler")then return; endif;
		var ^CGameObj pxLinkedObj = GetPrimaryLinkedObj().GetObj();
		if(pxLinkedObj==null)then return; endif;
		var string sAct = pxParent^.GetActionDesc();
		if(sAct == "CActWalk" || sAct == "CActMoveAnim" || sAct == "CActAdvanceWalk")then
		elseif (sAct == "CActRotate")then
		else
			return;
		endif;
		var string sAnim="walk_1";
		if(pxLinkedObj^.HasAnim(sAnim))then
			pxLinkedObj^.SetAnim(sAnim,0);
		endif;
//		var int iMode=0, iMax=pxParent^.GetMaxSpeed();
//		var string sAnim="walk_";
//		if(sAct=="CActWalk"||sAct=="CActMoveAnim"||sAct=="CActAdvanceWalk")then
//			iMode=iMax;
//		elseif(sAct=="CActRotate")then
//			iMode=iMax;
//		else
//			return;
//		endif;
//		sAnim+=(Math.Clamp(iMode,1,3)).ToString();
//		if(pxLinkedObj^.HasAnim(sAnim))then
//			pxLinkedObj^.SetAnim(sAnim,iMode);
//		endif;
		/*var ^CTransportObj pxParent = cast<CTransportObj>(m_xParent.GetObj());
		if(pxParent==null)then return; endif;
		var ^CGameObj pxLinkedObj = GetPrimaryLinkedObj().GetObj();
		if(pxLinkedObj==null)then return; endif;
		
		var int iSpeed = pxParent^.GetDefaultSpeed();
		var string sWalkAnim = "walk_"+iSpeed.ToString();
		var string sRotateAnim = "walk_1";
		var string sAnim = "";
		var string sAct = pxParent^.GetActionDesc();
	
		if(sAct=="CActWalk"||sAct=="CActMoveAnim"||sAct=="CActAdvanceWalk")then
			sAnim = sWalkAnim;
		elseif(sAct=="CActRotate")then
			sAnim = sRotateAnim;
		else
			return;
		endif;
	
		if(pxLinkedObj^.HasAnim(sAnim))then
			pxLinkedObj^.SetSLEAnim(sAnim,9999,true,false);
			//pxLinkedObj^.SetAnim(sAnim, 3);
		endif;*/
	endproc;
	
	export proc void OnActionEnd()
		var ^CGameObj pxLinkedObj = GetPrimaryLinkedObj().GetObj();
		if(pxLinkedObj==null)then return; endif;
		if(pxLinkedObj^.HasAnim(m_sAnim))then
			pxLinkedObj^.SetAnim(m_sAnim, 3);
		endif;
	endproc;
	
	export proc void AddObjCustomized(CObjHndl p_xHndl, string p_sLink, vec3 p_vOffset)
		AddObjWithOffset(p_xHndl, p_sLink, -1.0, CObjHndl.Invalid(), p_vOffset);
	endproc;
	
	export proc void AddObjWithParent(CObjHndl p_xHndl, string p_sLink, CObjHndl p_xParent)
		var vec3 vTmp={0.0,0.0,0.0};
		AddObjWithOffset(p_xHndl, p_sLink, -1.0, p_xParent, vTmp);
	endproc;
	
	export proc void AddCustWithParent(CObjHndl p_xHndl, string p_sLink, vec3 p_vOffset, CObjHndl p_xParent)
		AddObjWithOffset(p_xHndl, p_sLink, -1.0, p_xParent, p_vOffset);
	endproc;
	
	export proc void AddCustDelayedObj(CObjHndl p_xHndl, string p_sLink, real p_fDelay, CObjHndl p_xParent, vec3 p_vOffset)
		AddObjWithOffset(p_xHndl, p_sLink, p_fDelay, p_xParent, p_vOffset);
	endproc;
	
	export proc void AddCustDelayedObjAnim(CObjHndl p_xHndl, string p_sLink, real p_fDelay, CObjHndl p_xParent, vec3 p_vOffset, string p_sAnim)
		m_sAnim=p_sAnim;
		AddObjWithOffset(p_xHndl, p_sLink, p_fDelay, p_xParent, p_vOffset);
	endproc;
	
	export proc void AddObjWithOffset(CObjHndl p_xHndl, string p_sLink, real p_fDelay, CObjHndl p_xParent, vec3 p_vOffset)
		var ^CUniversalLinkObj pxObj = ^(m_axLinkedObjs.NewEntryRef());
		if(pxObj==null)then return; endif;
		pxObj^.SetHandle(p_xHndl);
		pxObj^.SetLink(p_sLink);
		pxObj^.SetDelay(p_fDelay);
		pxObj^.SetParentObj(p_xParent);
		pxObj^.SetLinkOffset(p_vOffset);
		pxObj^.SetCustom(true);
		UpdateLinkedObjs();
	endproc;
	
	export proc void AddObj(CObjHndl p_xHndl, string p_sLink)
		AddObjFlex(p_xHndl, p_sLink, -1.0, CObjHndl.Invalid());
	endproc;
	
	export proc void AddObjFlex(CObjHndl p_xHndl, string p_sLink, real p_fDelay, CObjHndl p_xParent)
		var ^CUniversalLinkObj pxObj = ^(m_axLinkedObjs.NewEntryRef());
		if(pxObj==null)then return; endif;
		pxObj^.SetHandle(p_xHndl);
		pxObj^.SetLink(p_sLink);
		pxObj^.SetDelay(p_fDelay);
		pxObj^.SetParentObj(p_xParent);
		pxObj^.SetLinkOffset({0.0,0.0,0.0});
		pxObj^.SetCustom(false);
		UpdateLinkedObjs();
	endproc;
	
	export proc void UpdateLinkedObjs()
		var ^CGameObj pxParent = GetParent().GetObj();
		if(pxParent==null)then return; endif;
		var int i, iC = m_axLinkedObjs.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CGameObj pxObj = m_axLinkedObjs[i].GetHandle().GetObj();
			if(pxObj==null)then
				m_axLinkedObjs.DeleteEntry(i);
				i--; iC--;
				continue;
			endif;
			var real fDelay = m_axLinkedObjs[i].GetDelay();
			var CFourCC xLink = m_axLinkedObjs[i].GetLink();
			var CObjHndl xParent = m_axLinkedObjs[i].GetParentObj();
			var bool bCustom = m_axLinkedObjs[i].GetCustom();
			var vec3 vOffset = m_axLinkedObjs[i].GetLinkOffset();
			if(!xParent.IsValid())then
				xParent = m_xParent;
			endif;
			if(bCustom)then
				if(fDelay>=0.0)then
					pxObj^.FlexLinkAction(xParent,xLink,fDelay,vOffset,"walk_1");
				else
					pxObj^.LinkAction(xParent,xLink,vOffset);
				endif;
			else
				if(fDelay>=0.0)then
					pxObj^.FlexLinkAction(xParent,xLink,fDelay,{0.0,0.0,0.0},"walk_1");
				else
					pxObj^.LinkAction(xParent, xLink);
				endif;
			endif;
			pxParent^.AddGroupedChildren(pxObj^.GetGuid());
			pxObj^.SetVisible(xLink!="NONE");
			pxObj^.SetSelectable(xLink!="NONE");
		endfor;
		var ^CTransportObj pxTransportParent = cast<CTransportObj>(GetParent().GetObj());
		if(pxTransportParent!=null)then
			pxTransportParent^.ResetFlag();
			pxTransportParent^.LinkCaptainObj();
		endif;
	endproc;
	
	export proc void UpdatePassengersLinking()
		return;
	endproc;
	/*
	export proc void TransferLinkedObjs(^CBuildUpBase p_pxOther)
		if(p_pxOther==null)then return; endif;
		var bool bSpecial = false;
		var ^CGameObj pxParent = m_xParent.GetObj();
		if(pxParent==null)then return; endif;
//		var ^CAnimal pxAnimal = cast<CAnimal>(pxParent);
//		if(pxAnimal!=null)then
//			bSpecial = pxAnimal^.IsSpecial();
//		endif;
		while(m_axLinkedObjs.NumEntries()>0)do
			var ^CGameObj pxObj = m_axLinkedObjs[0].GetHandle().GetObj();
			if(pxObj==null)then
				m_axLinkedObjs.DeleteEntry(0);
				continue;
			endif;
			pxParent^.RemGroupedChildren(pxObj^.GetGuid());
			pxObj^.TerminateAction();
			var bool bDestObj=false;
			var Quat qRot;
			var Quat qSecRot;
			var bool bTricMG=pxObj^.GetClassName()=="seas_triceratops_machinegun";
			begin TryDestruction;
				var string sParent = pxParent^.GetClassName();
				var string sGfx = pxObj^.GetGfxName()+"_dest";
//				if(CSrvWrap.GetGfxMgrBase().FindGraphicSetEntry(sGfx)&&!bSpecial)then
				if(!bTricMG&&CSrvWrap.GetGfxMgrBase().FindGraphicSetEntry(sGfx))then
					var ^CUniversalCorpse pxGameObj = cast<CUniversalCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("Corpse",pxObj^.GetOwner(),pxObj^.GetPos(),pxObj^.GetRotation()));
					if(pxGameObj!=null)then
						pxGameObj^.SetSource(pxObj);
						pxGameObj^.Init(sGfx, pxObj^.GetName(), 10.0);
						bDestObj=true;
						qRot=pxParent^.GetRot();
						qSecRot=pxObj^.GetAdditionalRot();
						pxObj^.Delete();
						pxObj = pxGameObj;
					endif;
				endif;
			end TryDestruction;
			if(bTricMG)then
				pxObj^.SetDestructLevel(2);
			else
				if(pxObj^.HasAnim("destroy"))then
					pxObj^.SetAnim("destroy", 1);
				else
					pxObj^.SetAnim("standanim", 3);
				endif;
			endif;
			var bool bCustom = m_axLinkedObjs[0].GetCustom();
			if(bCustom)then
				p_pxOther^.AddObjWithOffset(m_axLinkedObjs[0].GetHandle(), m_axLinkedObjs[0].GetLink().AsString(), m_axLinkedObjs[0].GetDelay(), m_axLinkedObjs[0].GetParentObj(), m_axLinkedObjs[0].GetLinkOffset());
			else
				p_pxOther^.AddObjFlex(m_axLinkedObjs[0].GetHandle(), m_axLinkedObjs[0].GetLink().AsString(), m_axLinkedObjs[0].GetDelay(), m_axLinkedObjs[0].GetParentObj());
			endif;
			if(bDestObj)then
				pxObj^.SetRot(qRot);
				pxObj^.SecRotAction(qSecRot,0.0);
			endif;
			m_axLinkedObjs.DeleteEntry(0);
		endwhile;
	endproc;
	*/
	export proc void TransferLinkedObjs(^CDino_Food p_pxCorpse)
		if(p_pxCorpse==null)then return; endif;
		var bool bSpecial = false;
		var ^CGameObj pxParent = m_xParent.GetObj();
		if(pxParent==null)then return; endif;
		while(m_axLinkedObjs.NumEntries()>0)do
			var ^CGameObj pxObj = m_axLinkedObjs[0].GetHandle().GetObj();
			if(pxObj==null)then
				m_axLinkedObjs.DeleteEntry(0);
				continue;
			endif;
			pxParent^.RemGroupedChildren(pxObj^.GetGuid());
			pxObj^.TerminateAction();
			var bool bDestObj=false;
			var Quat qRot;
			var Quat qSecRot;
			var bool bTricMG=pxObj^.GetClassName()=="seas_triceratops_machinegun";
			begin TryDestruction;
				var string sParent = pxParent^.GetClassName();
				var string sGfx = pxObj^.GetGfxName()+"_dest";
//				if(CSrvWrap.GetGfxMgrBase().FindGraphicSetEntry(sGfx)&&!bSpecial)then
				if(!bTricMG&&CSrvWrap.GetGfxMgrBase().FindGraphicSetEntry(sGfx))then
					var ^CUniversalCorpse pxGameObj = cast<CUniversalCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("Corpse",pxObj^.GetOwner(),pxObj^.GetPos(),pxObj^.GetRotation()));
					if(pxGameObj!=null)then
						pxGameObj^.SetSource(pxObj);
						pxGameObj^.Init(sGfx, pxObj^.GetName(), 10.0);
						bDestObj=true;
						qRot=pxParent^.GetRot();
						qSecRot=pxObj^.GetAdditionalRot();
						pxObj^.Delete();
						pxObj = pxGameObj;
					endif;
				endif;
			end TryDestruction;
			if(bTricMG)then
				pxObj^.SetDestructLevel(2);
			else
				if(pxObj^.HasAnim("destroy"))then
					pxObj^.SetAnim("destroy", 1);
				elseif(pxObj^.HasAnim("standanim"))then
					pxObj^.SetAnim("standanim", 3);
				endif;
			endif;
			var bool bCustom = m_axLinkedObjs[0].GetCustom();
			if(bCustom)then
				p_pxCorpse^.AddObjWithOffset(m_axLinkedObjs[0].GetHandle(), m_axLinkedObjs[0].GetLink().AsString(), m_axLinkedObjs[0].GetDelay(), m_axLinkedObjs[0].GetParentObj(), m_axLinkedObjs[0].GetLinkOffset());
			else
				p_pxCorpse^.AddObjFlex(m_axLinkedObjs[0].GetHandle(), m_axLinkedObjs[0].GetLink().AsString(), m_axLinkedObjs[0].GetDelay(), m_axLinkedObjs[0].GetParentObj());
			endif;
			if(bDestObj)then
				pxObj^.SetRot(qRot);
				pxObj^.SecRotAction(qSecRot,0.0);
			endif;
			m_axLinkedObjs.DeleteEntry(0);
		endwhile;
	endproc;
	
	export proc CObjHndl GetPrimaryLinkedObj()
		var CObjHndl xHndl;
		if(m_axLinkedObjs.NumEntries()>0)then
			xHndl = m_axLinkedObjs[0].GetHandle();
		endif;
		return xHndl;
	endproc;
	
	export proc CObjHndl GetPrimaryLinkedObjFight()
		return GetPrimaryLinkedObj();
	endproc;
	
	export proc CObjHndl GetLinkedObj(int p_iIndex)
		var CObjHndl xHndl;
		if(m_axLinkedObjs.NumEntries()>p_iIndex&&p_iIndex>=0)then
			xHndl = m_axLinkedObjs[p_iIndex].GetHandle();
		endif;
		return xHndl;
	endproc;
	
	export proc CFourCC GetPrimaryLink()
		return GetPrimaryLinkDefault();
	endproc;
	
	export proc CFourCC GetPrimaryLinkDefault()
		var CFourCC xLink;
		if(m_axLinkedObjs.NumEntries()>0)then
			xLink = m_axLinkedObjs[0].GetLink();
		endif;
		return xLink;
	endproc;
	
	export proc void RemovePassenger(CObjHndl p_xPassenger)
//		return;
	endproc;
	
	export proc string GetWeaponClass()
		return "none";
	endproc;
	
	export proc string GetWeapon()
		return "none";
	endproc;
	
	export proc void UpdateWeaponAndParent()
	endproc;
	/*
	export proc void TransferLinkedObjsAdd(^CBuildUpBase p_pxOther)
	endproc;
	*/
	export proc void TransferLinkedObjsAdd(^CDino_Food p_pxCorpse)
	endproc;
	
endclass;
	
class CBuildUpTransporter inherit CBuildUpBase
	
	var CObjList m_xPassengers;
	
	export constructor()
		SetType(CBuildUpBase.TYPE_TRANSPORTER);
	endconstructor;
	
	export proc void SetParent(CObjHndl p_xParent)
		super.SetParent(p_xParent);
		var ^CTransportObj pxObj=cast<CTransportObj>(p_xParent.GetObj());
		if(pxObj!=null)then
			//RT#16031 added CHoverCraft condition
			//also added CZeppelin condition
//			if(cast<CShip>(pxObj)!=null||cast<CHoverCraft>(pxObj)!=null||cast<CZeppelin>(pxObj)!=null||cast<CCrashBlimp>(pxObj)!=null)then
			if(cast<CShip>(pxObj)!=null||cast<CHoverCraft>(pxObj)!=null||cast<CCrashBlimp>(pxObj)!=null)then
				pxObj^.SetTransportClass(2);
			else
				pxObj^.SetTransportClass(1);
			endif;
		endif;
	endproc;
	
	export proc void DoKArc(ref CArc p_rxArc, int p_iVersion)
		super.DoKArc(p_rxArc,p_iVersion);
		if(p_iVersion>=14)then
			var int i, iC = m_xPassengers.NumEntries();
			p_rxArc << iC;
			m_xPassengers = iC;
			for(i=0)cond(i<iC)iter(i++)do
				m_xPassengers[i].DoKArc(p_rxArc);
			endfor;
		endif;
	endproc;
	
	export proc void AddPassenger(CObjHndl p_xPassenger)
		m_xPassengers.Include(p_xPassenger);
		UpdateLinkedObjs();
	endproc;
	
	export proc void Kill()
		var ^CTransportObj pxParent = cast<CTransportObj>(m_xParent.GetObj());
		if(pxParent!=null)then
			while(m_xPassengers.NumEntries()>0)do
				if(!pxParent^.OnDismount(m_xPassengers[0]))then
					m_xPassengers.DeleteEntry(0);
				endif;
			endwhile;
		endif;
		super.Kill();
	endproc;
	
	export proc void RemovePassenger(CObjHndl p_xPassenger)
		if(m_xPassengers.FindEntry(p_xPassenger)==-1)then return; endif;
		m_xPassengers.RemEntry(p_xPassenger);
		var ^CGameObj pxPassenger = p_xPassenger.GetObj();
		if(pxPassenger==null)then return; endif;
		var ^CGameObj pxParent = m_xParent.GetObj();
		if(pxParent==null)then return; endif;
		pxParent^.RemGroupedChildren(pxPassenger^.GetGuid());
		UpdateLinkedObjs();
	endproc;
	
	export proc void UpdateLinkedObjs()
		var ^CGameObj pxParent = m_xParent.GetObj();
		if(pxParent==null)then return; endif;
		super.UpdateLinkedObjs();
		if(GetType()==CBuildUpBase.TYPE_TRANSPORTER)then
			var CFourCC xInvalidLink;
			var int i, iC = m_xPassengers.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				var ^CGameObj pxPassenger = m_xPassengers[i].GetObj();
				if(pxPassenger==null)then
					m_xPassengers.DeleteEntry(i);
					i--; iC--;
					continue;
				endif;
				pxPassenger^.SetVisible(false);
				pxPassenger^.LinkAction(m_xParent,xInvalidLink);
				pxParent^.AddGroupedChildren(pxPassenger^.GetGuid());
			endfor;
		endif;
	endproc;
	
endclass;
	
class CBuildUpTransporterOpen inherit CBuildUpTransporter
	
	var array string m_asIgnoreLinks;
	
	export constructor()
		SetType(CBuildUpBase.TYPE_TRANSPORTER_OPEN);
	endconstructor;
	
	export proc void DoKArc(ref CArc p_rxArc, int p_iVersion)
		super.DoKArc(p_rxArc, p_iVersion);
		if(p_iVersion>=9)then
			var int i, iC = m_asIgnoreLinks.NumEntries();
			p_rxArc << iC;
			m_asIgnoreLinks = iC;
			for(i=0)cond(i<iC)iter(i++)do
				p_rxArc << m_asIgnoreLinks[i];
			endfor;
		endif;
	endproc;
	
	export proc void AddIgnoreLink(string p_sLink)
		m_asIgnoreLinks.AddEntry(p_sLink);
	endproc;
	
	export proc void Fight(^CGameObj p_pxTarget, vec3 p_vPos, bool p_bUserCommand, bool p_bQ)
		var int i, iC = m_xPassengers.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFightingObj pxObj = cast<CFightingObj>(m_xPassengers[i].GetObj());
			if(pxObj==null)then continue; endif;
			pxObj^.Fight(p_pxTarget, p_vPos, p_bUserCommand, p_bQ);
		endfor;
	endproc;
	
	export proc void UpdateLinkedObjs()
		var ^CTransportObj pxParent = cast<CTransportObj>(m_xParent.GetObj());
		if(pxParent==null)then return; endif;
		super.UpdateLinkedObjs();
		if(m_axLinkedObjs.NumEntries()<=0)then return; endif;
		var ^CGameObj pxObj = m_axLinkedObjs[0].GetHandle().GetObj();
		if(pxObj==null)then return; endif;
		var bool bHidden = pxParent^.GetTransportObj().IsValid();
		var CObjList xPassengers = m_xPassengers;
		var string sLink = "Dri";
		var int iNumber = 1;
		var int i, iC = 10;
		for(i=0)cond(i<iC)iter(i++)do
			var CFourCC xLink = "Dri" + i.ToString();
			var vec3 vP;
			if(m_asIgnoreLinks.FindEntry(xLink.AsString())!=-1)then continue; endif;
			if(pxObj^.GetLinkPosObj(xLink, vP))then
				if(xPassengers.NumEntries()>0)then
					var ^CGameObj pxPassenger = xPassengers[0].GetObj();
					if(pxPassenger!=null)then
						pxPassenger^.LinkAction(pxObj^.GetHandle(), xLink);
						pxPassenger^.SetRndInvMaskSingleFlagInv(88,false);
						pxParent^.AddGroupedChildren(pxPassenger^.GetGuid());
						var string sLoopAnim = pxParent^.GetPassengerLoopAnim();
						var string sAnim = pxPassenger^.GetCurrentAnimName();
						if(pxPassenger^.HasAnim(sLoopAnim)&&sAnim!=sLoopAnim&&sAnim!="heal_0")then
							pxPassenger^.SetAnim(sLoopAnim, 3);
						endif;
						if(pxPassenger^.GetFSM()!=null)then
							pxPassenger^.GetFSM()^.Enable(true);
						endif;
						pxPassenger^.SetVisible(!bHidden);
					endif;
					xPassengers.DeleteEntry(0);
				endif;
			endif;
		endfor;
	endproc;
	
	export proc void UpdatePassengersLinking()
		var ^CTransportObj pxParent = cast<CTransportObj>(m_xParent.GetObj());
		if(pxParent==null)then return; endif;
		if(m_axLinkedObjs.NumEntries()<1)then return; endif;
		var ^CGameObj pxObj = m_axLinkedObjs[0].GetHandle().GetObj();
		if(pxObj==null)then return; endif;
		var bool bHidden = pxParent^.GetTransportObj().IsValid();
		var CObjList xPassengers = m_xPassengers;
		var string sLink = "Dri";
		var int iNumber = 1;
		var int i, iC = 10;
		for(i=0)cond(i<iC)iter(i++)do
			if(xPassengers.NumEntries()>0)then
				var CFourCC xLink = "Dri" + i.ToString();
				var vec3 vP;
				if(m_asIgnoreLinks.FindEntry(xLink.AsString())!=-1)then continue; endif;
				if(pxObj^.GetLinkPosObj(xLink, vP))then
					var ^CGameObj pxPassenger = xPassengers[0].GetObj();
					if(pxPassenger!=null)then
						pxPassenger^.LinkAction(pxObj^.GetHandle(), xLink);
						pxPassenger^.SetRndInvMaskSingleFlagInv(88,false);
						pxParent^.AddGroupedChildren(pxPassenger^.GetGuid());
						var string sLoopAnim = pxParent^.GetPassengerLoopAnim();
						var string sAnim = pxPassenger^.GetCurrentAnimName();
						if(pxPassenger^.HasAnim(sLoopAnim)&&sAnim!=sLoopAnim&&sAnim!="heal_0")then
							pxPassenger^.SetAnim(sLoopAnim, 3);
						endif;
						if(pxPassenger^.GetFSM()!=null)then
							pxPassenger^.GetFSM()^.Enable(true);
						endif;
						pxPassenger^.SetVisible(!bHidden);
					endif;
					xPassengers.DeleteEntry(0);
				endif;
			else
				break;
			endif;
		endfor;
	endproc;
	
	export proc void RemovePassenger(CObjHndl p_xPassenger)
		super.RemovePassenger(p_xPassenger);
		var ^CGameObj pxObj=p_xPassenger.GetObj();
		if(pxObj!=null)then
			var Quat qAddRot = pxObj^.GetAdditionalRot();
			if(!qAddRot.IsIdentity())then
				var vec3 vCurDir = {0.0f, 1.0f, 0.0f};
				pxObj^.GetRot().VecRotateU(vCurDir);
				qAddRot.VecRotateU(vCurDir);
				var real fD = ({0.0f, 1.0f, 0.0}-vCurDir).Abs2();
				qAddRot.SetIdentity();
				pxObj^.SecRotAction(qAddRot, fD);
			endif;
		endif;
	endproc;
	
	export proc void EnableLinkedObjs()
		super.EnableLinkedObjs();
		var int i, iC = m_xPassengers.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CGameObj pxObj = m_xPassengers[i].GetObj();
			if(pxObj==null)then continue; endif;
			if(pxObj^.GetFSM()==null)then continue; endif;
			pxObj^.GetFSM()^.Enable(true);
		endfor;
	endproc;
	
endclass;
	
class CBuildUpWeapon inherit CBuildUpBase
	
	var CObjList			m_xEnemies;
	var CObjHndl			m_xCurEnemy;
	
	var string				m_sWeaponNode;
	var string				m_sWeaponClass;
	var real					m_fRange;
	var real					m_fMinRange;
	var CRegionSink		m_xSink;
	var CGuid					m_xRegionGuid;
	
	var bool					m_bAdditionalWeapon;
	var bool					m_bAutoAttack;
	var bool					m_bCanRotate;
	var bool					m_bCanSwitchAttackMode;
	
	var CObjHndl			m_xCaptain;
	
	var real					m_fDmg;
	var real					m_fEndDmg;
	var real					m_fProjectileFallOff;
	var real					m_fProjectileSpeed;
	var real					m_fProjectileJitter;
	var real					m_fProjectileDelay;
	var real					m_fHitRange;
	var real					m_fArmorPiercing;
	var real					m_fAttackRange;
	var real					m_fDuration;
	var real					m_fMinAttackRange;
	var int						m_iWeaponSizeClass;
	var bool					m_bPenetration;
	var string				m_sProjectile;
	//Henry: new options ;)
	var real					m_fFireDamage;
	var int						m_iBurnTickCount;
	var real					m_fPoisonDamage;
	var int						m_iPoisonTickCount;
	var bool					m_bAirWeapon;
	var real					m_fBuildUpRotSpeed;
//	var real					m_fChangeTime;
	var bool					m_bOwnCaptain;
	var bool					m_bFake;
	var bool					m_bSecond;
	
	var int						m_iAttackState;
	
	const int					ATTACKSTATE_WALK = 0;
	const int					ATTACKSTATE_WALK2ATTACK = 1;
	const int					ATTACKSTATE_ATTACK = 2;
	const int					ATTACKSTATE_ATTACK2WALK = 3;
	
	var string				m_sAttackAnim;
	var string				m_sTurnAnim;
	
	export constructor()
		m_sProjectile = "";
		SetType(CBuildUpBase.TYPE_WEAPON);
		m_bAdditionalWeapon = false;
		m_bCanSwitchAttackMode = false;
		m_bOwnCaptain=false;
		m_bFake=false;
		m_bSecond=false;
		m_fBuildUpRotSpeed = 1.0f;
//		m_fChangeTime = 1.0f;
		m_xSink.m_xOnObjAdd=OnObjAdd;
		m_xSink.m_xOnObjRem=OnObjRem;
		m_sAttackAnim="attack_front";
		m_sTurnAnim="";
	endconstructor;
	
	export proc void DoKArc(ref CArc p_rxArc, int p_iVersion)
		super.DoKArc(p_rxArc, p_iVersion);
		p_rxArc << m_xRegionGuid;
		p_rxArc << m_bAdditionalWeapon;
		p_rxArc << m_bCanRotate;
		p_rxArc << m_iAttackState;
		p_rxArc << m_sWeaponNode;
		m_xCurEnemy.DoKArc(p_rxArc);
		m_xEnemies.DoKArc(p_rxArc);
		if(p_iVersion>=11)then
			p_rxArc << m_bAutoAttack;
			p_rxArc << m_bCanSwitchAttackMode;
		endif;
		if(p_iVersion>=12)then
			m_xCaptain.DoKArc(p_rxArc);
		endif;
	endproc;
	
	export proc void DoKArcMirage(ref CArc p_rxArc, int p_iVersion)
		super.DoKArcMirage(p_rxArc, p_iVersion);
		if(p_iVersion>=1)then
			p_rxArc << m_sWeaponClass;
			p_rxArc << m_fBuildUpRotSpeed;
			p_rxArc << m_bOwnCaptain;
			p_rxArc << m_bFake;
			p_rxArc << m_sTurnAnim;
			p_rxArc << m_bSecond;
		endif;
	endproc;
	
	export proc void Kill()
		var ^CTransportObj pxParent = cast<CTransportObj>(m_xParent.GetObj());
		if(pxParent!=null)then
			pxParent^.m_xOnBusyTimer.Clear();
		endif;
		var int i, iC = m_axLinkedObjs.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(!m_bOwnCaptain&&m_axLinkedObjs[i].GetHandle()==m_xCaptain)then
				m_axLinkedObjs.DeleteEntry(i);
				i--; iC--;
			endif;
		endfor;
		super.Kill();
	endproc;
	
	export proc void AddObjCaptain(CObjHndl p_xHndl, string p_sLink, real p_fDelay, CObjHndl p_xParent)
		AddObjCaptain(p_xHndl, p_sLink, p_fDelay, p_xParent, false);
	endproc;
	
	export proc void AddObjCaptainCust(CObjHndl p_xHndl, string p_sLink, real p_fDelay, CObjHndl p_xParent, vec3 p_vOffset, bool p_bOwn)
		m_xCaptain = p_xHndl;
		m_bOwnCaptain = p_bOwn;
		return AddObjWithOffset(p_xHndl, p_sLink, p_fDelay, p_xParent, p_vOffset);
	endproc;
	
	export proc void AddObjCaptain(CObjHndl p_xHndl, string p_sLink, real p_fDelay, CObjHndl p_xParent, bool p_bOwn)
		m_xCaptain = p_xHndl;
		m_bOwnCaptain = p_bOwn;
		return AddObjFlex(p_xHndl, p_sLink, p_fDelay, p_xParent);
	endproc;
	
	export proc void SetParent(CObjHndl p_xParent)
		super.SetParent(p_xParent);
		var ^CTransportObj pxParent = cast<CTransportObj>(p_xParent.GetObj());
		if(pxParent!=null)then
			pxParent^.m_xOnBusyTimer = OnBusyTimer;
		endif;
	endproc;
	
	export proc void SetWeaponClass(string p_sWeaponClass)
		if(m_bFake)then return; endif;
		m_sWeaponClass = p_sWeaponClass;
		var ^CFightingObj pxParent = cast<CFightingObj>(m_xParent.GetObj());
		if(pxParent==null)then return; endif;
		var CTechTree xTechTree = pxParent^.GetTechTree();
		var ^CTechTree.CNode pxWeapons = xTechTree.FindNode("/Objects/"+pxParent^.GetTribeName()+"/Weapons");
		if(pxWeapons==null)then return; endif;
		var array ^CTechTree.CNode apxWeapons;
		var int i, iC = pxWeapons^.NumSubs();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CTechTree.CNode pxWeaponNode = pxWeapons^.GetSub(i);
			if(pxWeaponNode==null)then continue; endif;
			var ^CTechTree.CNode pxNode = pxWeaponNode^.GetSub("Users");
			if(pxNode==null)then continue; endif;
			var int iA, iAC = pxNode^.NumSubs();
			for(iA=0)cond(iA<iAC)iter(iA++)do
				if(pxNode^.GetSubValue(iA)==p_sWeaponClass)then
					apxWeapons.AddEntry(pxWeaponNode);
				endif;
			endfor;
		endfor;
		iC = apxWeapons.NumEntries();
		var int iIndex = -1;
		var int iMaxLevel = -1;
		var int iCondLevel = pxParent^.GetLevel();
		var real fMaxDmg = 0.0;
		var real fMaxRange = 0.0;
		for(i=0)cond(i<iC)iter(i++)do
			var ^CTechTree.CNode pxNode = apxWeapons[i];
			var int iLevel = pxNode^.GetSubValueI("level")-1;
			var real fRange = pxNode^.GetSubValueF("range");
			var real fDmg = pxNode^.GetSubValueF("damage");
			var real fMinRange = pxNode^.GetSubValueF("minattackrange",0.0);
			if(iLevel>iCondLevel)then continue; endif;
			if(iLevel<iMaxLevel)then continue; endif;
			if(fRange<fMaxRange)then continue; endif;
			if(fDmg<fMaxDmg)then continue; endif;
			iMaxLevel=iLevel; fMaxRange=fRange; fMaxDmg=fDmg; iIndex=i;
		endfor;
		if(iIndex!=-1)then
			SetWeapon(apxWeapons[iIndex]^.GetAbsPath());
		endif;
	endproc;
	
	export proc void UpdateWeapon()
		SetWeaponClass(m_sWeaponClass);
	endproc;
	
	export proc string GetWeaponClass()
		return m_sWeaponClass;
	endproc;
	
	export proc void UpdateWeaponAndParent()
		if(m_bFake)then return; endif;
//		SetWeaponClass(m_sWeaponClass);
		SetWeapon(m_sWeaponNode);
		var ^CFightingObj pxObj=cast<CFightingObj>(m_xParent.GetObj());
		if(pxObj!=null)then
			pxObj^.UpdateRangeNDamageInformation();
		endif;
	endproc;
	
	export proc void UpdateCaptainObj()
		if(m_xCaptain.IsValid())then
			var ^CCaptain pxCaptain=cast<CCaptain>(m_xCaptain.GetObj());
			if(pxCaptain!=null)then
				pxCaptain^.UpdateGfx();
			endif;
		endif;
	endproc;
	
	export proc void SetWeapon(string p_sWeaponNode)
		if(m_bFake)then return; endif;
		m_sWeaponNode = p_sWeaponNode;
		var ^CFightingObj pxParent = cast<CFightingObj>(m_xParent.GetObj());
		if(pxParent==null)then return; endif;
		var ^CTechTree.CNode pxWeaponNode = pxParent^.GetTechTree().FindNode(m_sWeaponNode);
		if(pxWeaponNode==null)then return; endif;
		m_fDmg = 0.0;
		m_fEndDmg = 0.0;
		m_fProjectileFallOff = 0.0;
		m_fProjectileSpeed = 0.0;
		m_fProjectileJitter = 0.0;
		m_fProjectileDelay = 0.0;
		m_fHitRange = 0.0;
		m_fArmorPiercing = 0.0;
		m_fAttackRange = 0.0;
		m_iWeaponSizeClass = 0;
		m_bPenetration = false;
		m_fMinAttackRange = 0.0;
		m_fFireDamage = 0.0;
		m_iBurnTickCount = 0;
		m_fPoisonDamage = 0.0;
		m_iPoisonTickCount = 0;
		m_fFireDamage = 0.0;
		m_iBurnTickCount = 0;
		m_bAirWeapon = false;
		var ^CTechTree.CNode pxProjectiles = pxWeaponNode^.GetSub("Projectile");
		if(pxProjectiles!=null)then
			if(pxProjectiles^.NumSubs() > 0)then
				m_sProjectile = pxProjectiles^.GetSubValue("0");
			endif;
		endif;
		var real fFrequency = pxWeaponNode^.GetSubValueF("frequency");
		if(fFrequency==0.0)then
			fFrequency = 1.0;
		endif;
		m_fDuration = (60.0/fFrequency);
		m_fDmg								= pxWeaponNode^.GetSubValueF("damage",0.0);
		m_fEndDmg							= pxWeaponNode^.GetSubValueF("enddamage",0.0);
		m_fProjectileFallOff	= pxWeaponNode^.GetSubValueF("bulletfalloff",0.0);
		m_fProjectileSpeed		= pxWeaponNode^.GetSubValueF("bulletspeed",0.0);
		m_fProjectileJitter		= pxWeaponNode^.GetSubValueF("jitter",0.0);
		m_fProjectileDelay		= pxWeaponNode^.GetSubValueF("shootdelay",0.0);
//		m_fArmorPiercing			= pxWeaponNode^.GetSubValueF("armorpiercing");
		var real fMaxP				= CMirageSrvMgr.Get().GetMaxDef()*100.0f;
		m_fArmorPiercing			= Math.Clamp(pxWeaponNode^.GetSubValueF("armorpiercing"),0.0,fMaxP);
		m_fHitRange						= pxWeaponNode^.GetSubValueF("hitrange",0.0);
		m_iWeaponSizeClass		= pxWeaponNode^.GetSubValueI("unit_size",0);
		m_bPenetration				= pxWeaponNode^.GetSubValueB("penetration",false);
		m_fPoisonDamage				= pxWeaponNode^.GetSubValueF("poison_damage",0.0);
		m_iPoisonTickCount		= pxWeaponNode^.GetSubValueI("poison_tick_count",0);
		m_fFireDamage					= pxWeaponNode^.GetSubValueF("fire_damage",0.0);
		m_iBurnTickCount			= pxWeaponNode^.GetSubValueI("fire_tick_count",0);
		m_bAirWeapon					= pxWeaponNode^.GetSubValueB("airweapon",false);
		var real fMinRange		= pxWeaponNode^.GetSubValueF("minattackrange",0.0);
		var real fRange				= pxWeaponNode^.GetSubValueF("range",1.0);
		if(m_fAttackRange!=fRange)then
			m_fAttackRange=fRange;
			DeleteAggressionRegion();
			CreateAggressionRegion();
		endif;
		if(m_fMinAttackRange!=fMinRange)then
			m_fMinAttackRange=fMinRange;
		endif;
		m_fDuration *= pxParent^.GetTechTreeModifier("WeaponDuration",true);
		m_fDuration += pxParent^.GetTechTreeModifier("WeaponDuration",false);
		m_fDuration *= pxParent^.GetAICheatModifier();
		if(!m_bAdditionalWeapon)then
			m_fDmg *= pxParent^.GetTechTreeModifier("ranged_damage",true);
			m_fDmg += pxParent^.GetTechTreeModifier("ranged_damage",false);
			m_fDmg *= pxParent^.GetTechTreeModifier("Damage",true);
			m_fDmg += pxParent^.GetTechTreeModifier("Damage",false);
		endif;
		if(m_bAirWeapon)then
			pxParent^.SetTBUAW(true);
		endif;
		if(m_bAdditionalWeapon)then
			pxParent^.ClearBuildUpCache();
			pxParent^.UpdateBUWeapons(m_fDmg,m_fEndDmg,m_fArmorPiercing,m_sProjectile,m_fPoisonDamage,m_iPoisonTickCount,m_fFireDamage,m_iBurnTickCount,m_bAirWeapon);
			pxParent^.UpdateBUWeaponBoni(m_sWeaponNode);
			pxParent^.UpdateRangeNDamageInformation();
		endif;
	endproc;
	
	export proc string GetWeapon()
		return m_sWeaponNode;
	endproc;
	
	export proc real GetDmg()
		return m_fDmg;
	endproc;
	
	export proc real GetEndDmg()
		return m_fEndDmg;
	endproc;
	
	export proc real GetProjectileFallOff()
		return m_fProjectileFallOff;
	endproc;
	
	export proc real GetProjectileSpeed()
		return m_fProjectileSpeed;
	endproc;
	
	export proc real GetProjectileJitter()
		return m_fProjectileJitter;
	endproc;
	
	export proc real GetProjectileDelay()
		return m_fProjectileDelay;
	endproc;
	
	export proc real GetHitRange()
		return m_fHitRange;
	endproc;
	
	export proc real GetArmorPiercing()
		return m_fArmorPiercing;
	endproc;
	
	export proc real GetAttackRange()
		if(m_xParent.IsValid())then
			var ^CFightingObj pxParent = cast<CFightingObj>(m_xParent.GetObj());
			if(pxParent!=null&&pxParent^.GetMirageFlag(CFightingObj.MIRAGE_BLINDING_STORM))then
				return 2.0f;
			endif;
		endif;
		return m_fAttackRange;
	endproc;
	
	export proc ref real GetMinAttackRange()
		return m_fMinAttackRange;
	endproc;
	
	export proc real GetWeaponDuration()
		return m_fDuration;
	endproc;
	
	export proc int GetWeaponSizeClass()
		return m_iWeaponSizeClass;
	endproc;
	
	export proc bool GetPenetration()
		return m_bPenetration;
	endproc;
	
	export proc string GetProjectile()
		return m_sProjectile;
	endproc;
	
	export proc ref real GetPoisonDmg()
		return m_fPoisonDamage;
	endproc;
	
	export proc ref int GetPoisonMaxTickCount()
		return m_iPoisonTickCount;
	endproc;
	
	export proc ref real GetFireDmg()
		return m_fFireDamage;
	endproc;
	
	export proc ref int GetBurnTime()
		return m_iBurnTickCount;
	endproc;
	
	export proc bool CanShootAir()
		return m_bAirWeapon;
	endproc;
	
	export proc vec3 GetProjectileStartPos()
		var ^CFightingObj pxParent = cast<CFightingObj>(m_xParent.GetObj());
		if(pxParent==null)then return {0.0,0.0,0.0}; endif;
		var ^CGameObj pxObj = GetPrimaryLinkedObjFight().GetObj();
		if(pxObj==null)then return pxParent^.GetProjectileStartPos(); endif;
		var vec3 vPos; var CFourCC xLink = "Proj";
		if(pxObj^.GetClassName()=="universal_captain")then
			xLink = "HndR";
		endif;
		if(!pxObj^.GetLinkPosWorld(xLink, vPos))then
			return pxParent^.GetProjectileStartPos();
		endif;
		return vPos;
	endproc;
	
	export proc void OnPostLoad()
		if(m_bFake)then return; endif;
		if(!m_xRegionGuid.IsNull())then
			var int iIdx = CSrvWrap.GetRegionMgr().FindRegion(m_xRegionGuid);
			if(iIdx>=0)then
				var ^CRegion pxRegion = CSrvWrap.GetRegionMgr().GetRegion(iIdx);
				if(pxRegion!=null)then
					m_xSink.SetRegion(pxRegion);
					pxRegion^.BindToObj(m_xParent);
					m_xSink.Subscribe();
				endif;
			else
				var CGuid xG; m_xRegionGuid = xG;
			endif;
		endif;
		var ^CFightingObj pxObj=cast<CFightingObj>(m_xParent.GetObj());
		if(!m_sWeaponNode.IsEmpty())then
			SetWeapon(m_sWeaponNode);
			if(pxObj!=null)then
				pxObj^.UpdateRangeNDamageInformation();
			endif;
//		elseif(pxObj!=null)then
//			// Henry: probable weapon class...
//			SetWeaponClass(pxObj^.GetClassName());
		endif;
		var ^CProduct pxBuildUpObj = cast<CProduct>(GetPrimaryLinkedObjFight().GetObj());
		if(pxBuildUpObj!=null)then
			var ^CBuildUpFight pxFight = cast<CBuildUpFight>(pxBuildUpObj^.GetCurTask());
			if(pxFight!=null)then
				pxFight^.SetBuildUp(this);
			endif;
		endif;
	endproc;
	
	export proc void EnableLinkedObjs()
		super.EnableLinkedObjs();
		var ^CProduct pxBuildUpObj = cast<CProduct>(GetPrimaryLinkedObjFight().GetObj());
		if(pxBuildUpObj!=null)then
			if(pxBuildUpObj^.GetFSM()!=null)then
				pxBuildUpObj^.GetFSM()^.Enable(true);
			endif;
		endif;
		var ^CCaptain pxCaptain = cast<CCaptain>(m_xCaptain.GetObj());
		if(pxCaptain!=null)then
			if(pxCaptain^.GetFSM()!=null)then
				pxCaptain^.GetFSM()^.Enable(true);
			endif;
		endif;
	endproc;
	
	export proc void SetCanRotate(bool p_bValue)
		m_bCanRotate = p_bValue;
	endproc;
	
	export proc bool CanRotate()
		return m_bCanRotate;
	endproc;
	
	export proc void SetCanSwitchAttackMode(bool p_bValue)
		m_bCanSwitchAttackMode = p_bValue;
	endproc;
	
	export proc bool CanSwitchAttackMode()
		return m_bCanSwitchAttackMode;
	endproc;
	
	export proc bool IsInAttackMode()
		return (m_iAttackState==ATTACKSTATE_WALK2ATTACK)||(m_iAttackState==ATTACKSTATE_ATTACK);
	endproc;
	
	export proc void SetAdditionalWeapon(bool p_bValue)
		m_bAdditionalWeapon = p_bValue;
		if(p_bValue)then
			var ^CFightingObj pxParent = cast<CFightingObj>(m_xParent.GetObj());
			if(pxParent!=null)then
				m_fDmg -= pxParent^.GetTechTreeModifier("Damage",false);
				m_fDmg /= pxParent^.GetTechTreeModifier("Damage",true);
				m_fDmg -= pxParent^.GetTechTreeModifier("ranged_damage",false);
				m_fDmg /= pxParent^.GetTechTreeModifier("ranged_damage",true);
				if(m_bAdditionalWeapon)then
					pxParent^.UpdateBUWeapons(m_fDmg,m_fEndDmg,m_fArmorPiercing,m_sProjectile,m_fPoisonDamage,m_iPoisonTickCount,m_fFireDamage,m_iBurnTickCount,m_bAirWeapon);
					pxParent^.UpdateBUWeaponBoni(m_sWeaponNode);
				endif;
			endif;
		endif;
		SetAutoAttack(p_bValue);
	endproc;
	
	export proc bool GetAdditionalWeapon()
		return m_bAdditionalWeapon;
	endproc;
	
	export proc void SetAutoAttack(bool p_bValue)
		if(m_bAutoAttack != p_bValue)then
			m_bAutoAttack = p_bValue;
			if(m_bAutoAttack)then
				CreateAggressionRegion();
			else
				DeleteAggressionRegion();
			endif;
		endif;
	endproc;
	
	export proc bool GetAutoAttack()
		return m_bAutoAttack;
	endproc;
	
	export proc void SetBuildUpRotSpeed(real p_fValue)
		m_fBuildUpRotSpeed = p_fValue;
	endproc;
	
	export proc real GetBuildUpRotSpeed()
		return m_fBuildUpRotSpeed;
	endproc;
	
//	export proc void SetChangeTime(real p_fValue)
//		m_fChangeTime = p_fValue;
//	endproc;
	
//	export proc real GetChangeTime()
//		return m_fChangeTime;
//	endproc;
	
	export proc bool IsBusy()
		var ^CTransportObj pxParent = cast<CTransportObj>(m_xParent.GetObj());
		if(pxParent==null)then return false; endif;
		return pxParent^.IsBuildUpBusy();
	endproc;
	
	proc void OnBusyTimer()
		if(m_iAttackState==ATTACKSTATE_WALK2ATTACK)then
			m_iAttackState = ATTACKSTATE_ATTACK;
		elseif(m_iAttackState==ATTACKSTATE_ATTACK2WALK)then
			m_iAttackState = ATTACKSTATE_WALK;
		endif;
	endproc;
	
	proc void CreateAggressionRegion()
		if(m_bFake)then return; endif;
		if(!m_xRegionGuid.IsNull())then return; endif;
		var ^CGameObj pxParent = m_xParent.GetObj();
		if(pxParent==null)then return; endif;
		var ^CRegionMgr pxRM = ^(CSrvWrap.GetRegionMgr());
		if(pxRM!=null)then
			var real fRange = GetAttackRange() + pxParent^.GetCollisionRadius() + 20.0;
			var vec3 vDimension;
			vDimension.SetXYZ(fRange, fRange, 0.0);
			var int iIdx = pxRM^.CreateRegion("WeaponBuildUp_"+pxParent^.GetName()+"_"+Random.GetInt().ToString(),  010b, pxParent^.GetPos(), vDimension);
			if(iIdx >= 0)then
				var ^CRegion pxRegion = pxRM^.GetRegion(iIdx);
				m_xRegionGuid = pxRegion^.GetGUID();
				m_xSink.SetRegion(pxRegion);
				pxRegion^.BindToObj(GetPrimaryLinkedObjFight());
				m_xSink.Subscribe();
			endif;
		endif;
	endproc;
	
	proc void DeleteAggressionRegion()
		if(!m_xRegionGuid.IsNull())then
			var ^CRegionMgr pxRM = ^(CSrvWrap.GetRegionMgr());
			if(pxRM!=null)then
				var int iIdx = CSrvWrap.GetRegionMgr().FindRegion(m_xRegionGuid);
				if(iIdx >= 0)then
					var ^CRegion pxRegion = pxRM^.GetRegion(iIdx);
					m_xSink.Unsubscribe();
					if(pxRegion!=null)then
						pxRegion^.Unbind();
					endif;
					m_xSink.DeleteRegion();
					var CGuid xNew;
					m_xRegionGuid = xNew;
				endif;
			endif;
		endif;
	endproc;
	
	proc bool OnObjAdd(CObjHndl p_xHndl)
		var ^CFightingObj pxEnemy = cast<CFightingObj>(p_xHndl.GetObj());
		if(pxEnemy==null)then return false; endif;
		m_xEnemies.Include(p_xHndl);
		return true;
	endproc;
	
	export proc void Fight(^CGameObj p_pxTarget, vec3 p_vPos, bool p_bUserCommand, bool p_bQ)
		InvokeFight(p_pxTarget, p_vPos, p_bUserCommand, p_bQ, false);
	endproc;
	
	export proc void InvokeFight(^CGameObj p_pxTarget, vec3 p_vPos, bool p_bNewUserCommand, bool p_bQ, bool p_bOldTaskEnd)
		var bool bTemp;
		InvokeFight(p_pxTarget, p_vPos, p_bNewUserCommand, p_bOldTaskEnd, p_bQ, false, bTemp);
	endproc;
	
	export proc void InvokeFight(^CGameObj p_pxTarget, vec3 p_vPos, bool p_bNewUserCommand, bool p_bQ, bool p_bOldTaskEnd, bool p_bSkipChecks, ref bool p_rbOk)
		if(m_bFake)then return; endif;
		if(p_pxTarget==null)then return; endif;
		var ^CProduct pxBuildUpObj = cast<CProduct>(GetPrimaryLinkedObjFight().GetObj());
		if(pxBuildUpObj==null)then return; endif;
		var ^CFightingObj pxParent = cast<CFightingObj>(m_xParent.GetObj());
		if(pxParent==null)then return; endif;
		if(!p_bSkipChecks)then
			if(!GetAutoAttack())then return; endif;
			if((pxParent^.IsTrapped()&&!pxParent^.ExcludeBuildUp())||pxParent^.InvalidFighter()||m_iAggressionState==3)then return; endif;
			if(pxParent^.GetTransportObj().IsValid())then return; endif;
			if(!GetAdditionalWeapon()&&pxParent^.IsReallyInFight())then return; endif;
			if(p_pxTarget^.GetHandle()==m_xParent)then return; endif;
		endif;
		if(p_pxTarget^.GetOwner()!=-1&&p_pxTarget^.GetOwner()==pxParent^.GetOwner()&&!CMirageSrvMgr.Get().AllowAttackOwnStuff())then return; endif;
		var bool bOldUserCommand = false;
		var ^CTask pxTask = pxBuildUpObj^.GetCurTask();
		if(pxTask!=null)then
			bOldUserCommand = pxTask^.IsUserCommand();
			if(p_bOldTaskEnd)then
				bOldUserCommand = false;
			endif;
		endif;
		if(bOldUserCommand&&!p_bNewUserCommand)then return; endif;
		if(p_pxTarget!=null)then
			m_xCurEnemy = p_pxTarget^.GetHandle();
		endif;
		var ^CBuildUpFight pxFightTask = cast<CBuildUpFight>(pxTask);
		if(pxFightTask!=null&&!p_bQ)then
			pxFightTask^.UpdateEnemy(m_xCurEnemy);
			pxFightTask^.SetUserCommand(p_bNewUserCommand);
			p_rbOk=true;
		else
			pxFightTask=cast<CBuildUpFight>(CSrvWrap.GetUSLFactoryMgr().CreateState(pxBuildUpObj^.GetFSM(),"BUFight"));
			if(pxFightTask==null)then return; endif;
			if(!pxFightTask^.Init(m_xParent,m_xCurEnemy, this))then pxFightTask^.GetFactory()^.FreeState(pxFightTask); return; endif;
			pxFightTask^.SetUserCommand(p_bNewUserCommand);
			pxBuildUpObj^.AddTask(pxFightTask, p_bQ);
			p_rbOk=true;
		endif;
	endproc;
	
	export proc void InvokeFightNew(^CGameObj p_pxTarget, vec3 p_vPos, bool p_bNewUserCommand, bool p_bOldTaskEnd, bool p_bSkipChecks, ref bool p_rbOk)
		if(m_bFake)then return; endif;
		if(p_pxTarget==null)then return; endif;
		var ^CProduct pxBuildUpObj = cast<CProduct>(GetPrimaryLinkedObjFight().GetObj());
		if(pxBuildUpObj==null)then return; endif;
		var ^CFightingObj pxParent = cast<CFightingObj>(m_xParent.GetObj());
		if(pxParent==null)then return; endif;
		if(!p_bSkipChecks)then
			if(!GetAutoAttack())then return; endif;
			if((pxParent^.IsTrapped()&&!pxParent^.ExcludeBuildUp())||pxParent^.InvalidFighter()||m_iAggressionState==3)then return; endif;
			if(pxParent^.GetTransportObj().IsValid())then return; endif;
			if(!GetAdditionalWeapon()&&pxParent^.IsReallyInFight())then return; endif;
			if(p_pxTarget^.GetHandle()==m_xParent)then return; endif;
		endif;
		if(p_pxTarget^.GetOwner()!=-1&&p_pxTarget^.GetOwner()==pxParent^.GetOwner()&&!CMirageSrvMgr.Get().AllowAttackOwnStuff())then return; endif;
		var bool bOldUserCommand = false;
		var ^CTask pxTask = pxBuildUpObj^.GetCurTask();
		if(pxTask!=null)then
			bOldUserCommand = pxTask^.IsUserCommand();
			if(p_bOldTaskEnd)then
				bOldUserCommand = false;
			endif;
		endif;
		if(bOldUserCommand&&!p_bNewUserCommand)then return; endif;
		if(p_pxTarget!=null)then
			m_xCurEnemy = p_pxTarget^.GetHandle();
		endif;
		var ^CBuildUpFight pxFightTask = cast<CBuildUpFight>(pxTask);
		if(pxFightTask!=null)then
			pxFightTask^.UpdateEnemy(m_xCurEnemy);
			pxFightTask^.SetUserCommand(p_bNewUserCommand);
			p_rbOk=true;
		else
			pxFightTask=cast<CBuildUpFight>(CSrvWrap.GetUSLFactoryMgr().CreateState(pxBuildUpObj^.GetFSM(),"BUFight"));
			if(pxFightTask==null)then return; endif;
			if(!pxFightTask^.Init(m_xParent,m_xCurEnemy, this))then pxFightTask^.GetFactory()^.FreeState(pxFightTask); return; endif;
			pxFightTask^.SetUserCommand(p_bNewUserCommand);
			pxBuildUpObj^.AddTask(pxFightTask, false);
			p_rbOk=true;
		endif;
	endproc;
	
	export proc bool StartFightingTask(bool p_bOldTaskEnd)
		if(m_bFake)then return false; endif;
		if(m_iAggressionState==1||m_iAggressionState==-1||m_iAggressionState==3)then return false; endif;
		if(!GetAutoAttack())then return false; endif;
		var ^CFightingObj pxParent = cast<CFightingObj>(m_xParent.GetObj());
		if(pxParent==null)then return false; endif;
		if(pxParent^.GetTransportObj().IsValid())then return false; endif;
//		var vec3 vParent=pxParent^.GetPos();
		if(!GetPrimaryLinkedObjFight().IsValid())then return false; endif;
		var ^CProduct pxBUObj=cast<CProduct>(GetPrimaryLinkedObjFight().GetObj());
		if(pxBUObj==null)then return false; endif;
		var vec3 vMe=pxBUObj^.GetPos();
		if(pxParent^.InvalidFighter()||(pxParent^.IsTrapped()&&!pxParent^.ExcludeBuildUp()))then return false; endif;
		if(!GetAdditionalWeapon()&&pxParent^.IsReallyInFight())then return false; endif;
		var CObjList xList = m_xEnemies;
		pxParent^.SortEnemyList(xList, GetAttackRange(), false, false);
		if(xList.NumEntries()<=0)then return false; endif;
		var ^CFightingObj pxObj=null;
		while(xList.NumEntries()>0)do
			if(!xList[0].IsValid())then
				xList.DeleteEntry(0);
				pxObj=null;
				continue;
			endif;
			pxObj = cast<CFightingObj>(xList[0].GetObj());
			if(pxObj==null)then
				xList.DeleteEntry(0);
				pxObj=null;
				continue;
			endif;
			if(CSrvWrap.GetObjMgr()^.IsInFOW(pxObj,pxParent^.GetOwner()))then
				xList.DeleteEntry(0);
				pxObj=null;
				continue;
			endif;
			if(pxObj^.IsFlyingUnit()&&!CanShootAir())then
				xList.DeleteEntry(0);
				pxObj=null;
				continue;
			endif;
			if(pxObj^.InvalidEnemy()||pxObj^.HidingEnemy())then
				xList.DeleteEntry(0);
				pxObj=null;
				continue;
			endif;
			var real fMinAtRan=0.0f;
			fMinAtRan=GetMinAttackRange()+1.0f;
			var real fMinAttSec=(fMinAtRan*fMinAtRan);
			var real fDistance=(pxObj^.GetPos()-vMe).Abs2S();
			if(fDistance <= (fMinAttSec-1.0f))then
				xList.DeleteEntry(0);
				pxObj=null;
				continue;
			endif;
			break;
		endwhile;
		var bool bTmp;
		var vec3 vTarget;
		var bool bReturn=false;
		if(pxObj!=null)then
			vTarget=pxObj^.GetPos();
			bReturn=true;
		endif;
		InvokeFight(pxObj, vTarget, false, false, p_bOldTaskEnd, true, bTmp);
		return bReturn;
	endproc;
	
	export proc bool StartFightingTask(bool p_bOldTaskEnd, bool p_bUseCurEnemy, ref bool p_rbOk, bool p_bUserCommand)
		if(m_bFake)then return false; endif;
		if(m_iAggressionState==1||m_iAggressionState==-1||m_iAggressionState==3)then return false; endif;
		if(!GetAutoAttack())then return false; endif;
		var ^CFightingObj pxParent = cast<CFightingObj>(m_xParent.GetObj());
		if(pxParent==null)then return false; endif;
		if(pxParent^.GetTransportObj().IsValid())then return false; endif;
//		var vec3 vParent=pxParent^.GetPos();
		if(!GetPrimaryLinkedObjFight().IsValid())then return false; endif;
		var ^CProduct pxBUObj=cast<CProduct>(GetPrimaryLinkedObjFight().GetObj());
		if(pxBUObj==null)then return false; endif;
		if(pxBUObj^.HasQueue())then p_rbOk=true; return true; endif;
		var vec3 vMe=pxBUObj^.GetPos();
		if(pxParent^.InvalidFighter()||(pxParent^.IsTrapped()&&!pxParent^.ExcludeBuildUp()))then return false; endif;
		if(!GetAdditionalWeapon()&&pxParent^.IsReallyInFight())then return false; endif;
		var CObjList xList;
		if(p_bUseCurEnemy&&m_xCurEnemy.IsValid())then
			xList.AddEntry(m_xCurEnemy);
		else
			p_bUseCurEnemy=false;
		endif;
		xList.Include(m_xEnemies);
//		var CObjList xList = m_xEnemies;
		pxParent^.SortEnemyList(xList, GetAttackRange(), false, false);
		if(xList.NumEntries()<=0)then return false; endif;
		var ^CFightingObj pxObj=null;
		while(xList.NumEntries()>0)do
			if(!xList[0].IsValid())then
				xList.DeleteEntry(0);
				pxObj=null;
				continue;
			endif;
			pxObj = cast<CFightingObj>(xList[0].GetObj());
			if(pxObj==null)then
				xList.DeleteEntry(0);
				pxObj=null;
				continue;
			endif;
			if(CSrvWrap.GetObjMgr()^.IsInFOW(pxObj,pxParent^.GetOwner()))then
				xList.DeleteEntry(0);
				pxObj=null;
				continue;
			endif;
			if(pxObj^.IsFlyingUnit()&&!CanShootAir())then
				xList.DeleteEntry(0);
				pxObj=null;
				continue;
			endif;
			if(pxObj^.InvalidEnemy()||pxObj^.HidingEnemy())then
				xList.DeleteEntry(0);
				pxObj=null;
				continue;
			endif;
			var real fMinAtRan=0.0f;
			fMinAtRan=GetMinAttackRange()+1.0f;
			var real fMinAttSec=(fMinAtRan*fMinAtRan);
			var real fDistance=(pxObj^.GetPos()-vMe).Abs2S();
			if(fDistance <= (fMinAttSec-1.0f))then
				xList.DeleteEntry(0);
				pxObj=null;
				continue;
			endif;
			break;
		endwhile;
//		if(p_bUseCurEnemy && xList[0]==m_xCurEnemy)then
//			return true;
//		endif;
		var vec3 vTarget;
		var bool bReturn=false;
		if(pxObj!=null)then
			vTarget=pxObj^.GetPos();
			bReturn=true;
		endif;
		InvokeFightNew(pxObj, vTarget, p_bUserCommand, p_bOldTaskEnd, true, p_rbOk);
		return bReturn;
	endproc;
	
	export proc void SetCurEnemy(CObjHndl p_xHndl)
		m_xCurEnemy=p_xHndl;
	endproc;
	
	proc bool OnObjRem(CObjHndl p_xHndl)
		m_xEnemies.RemEntry(p_xHndl);
		return true;
	endproc;
	
	export proc bool SwitchToAttackMode()
		var ^CTransportObj pxParent = cast<CTransportObj>(m_xParent.GetObj());
		if(pxParent==null)then return false; endif;
		if(!CanSwitchAttackMode())then
			pxParent^.SwitchToAttackMode();
			return false;
		endif;
		if(m_iAttackState==ATTACKSTATE_WALK||m_iAttackState==ATTACKSTATE_ATTACK2WALK)then
			pxParent^.SetBuildUpBusy(1.5);
			pxParent^.SwitchToAttackMode();
			m_iAttackState = ATTACKSTATE_WALK2ATTACK;
		endif;
		if(m_iAttackState==ATTACKSTATE_WALK2ATTACK)then
			return true;
		endif;
		return false;
	endproc;
	
	export proc void ResetRotation()
		var ^CTransportObj pxParent = cast<CTransportObj>(m_xParent.GetObj());
		if(pxParent!=null && pxParent^.IsTrapped())then
			return;
		endif;
		var ^CGameObj pxObj = GetPrimaryLinkedObjFight().GetObj();
		if(pxObj!=null)then
			var Quat qAddRot = pxObj^.GetAdditionalRot();
			//var bool bRotate = pxObj^.GetSecActionDesc()!="CAct";
			if(!qAddRot.IsIdentity())then
				var vec3 vCurDir = {0.0f, 1.0f, 0.0f};
				pxObj^.GetRot().VecRotateU(vCurDir);
				qAddRot.VecRotateU(vCurDir);
				var real fD = ({0.0f, 1.0f, 0.0}-vCurDir).Abs2();
				fD *= GetBuildUpRotSpeed();
				qAddRot.SetIdentity();
				pxObj^.SecRotAction(qAddRot, fD);
			endif;
		endif;
	endproc;
	
	export proc bool SwitchToWalkMode()
		if(!CanSwitchAttackMode())then return false; endif;
		if(CanRotate())then
			ResetRotation();
		endif;
		var ^CTransportObj pxParent = cast<CTransportObj>(m_xParent.GetObj());
		if(pxParent==null)then return false; endif;
		if(m_iAttackState==ATTACKSTATE_ATTACK||m_iAttackState==ATTACKSTATE_WALK2ATTACK)then
			pxParent^.SetBuildUpBusy(1.0);
			pxParent^.SwitchToWalkMode();
			m_iAttackState = ATTACKSTATE_ATTACK2WALK;
		endif;
		if(m_iAttackState==ATTACKSTATE_ATTACK2WALK)then
			return true;
		endif;
		return false;
	endproc;
	
	export proc void SetRotAnim(string p_sAnim)
		m_sTurnAnim=p_sAnim;
	endproc;
	
	export proc bool RotateToEnemy(^CGameObj p_pxEnemy, vec3 p_vPos)
		if(!CanRotate())then return false; endif;
		var ^CGameObj pxObj = GetPrimaryLinkedObjFight().GetObj();
		if(pxObj==null)then return false; endif;
		var Quat qAddRot = pxObj^.GetAdditionalRot();
		if(p_pxEnemy!=null)then
			p_vPos = p_pxEnemy^.GetPos();
		endif;
		var vec3 vEnemyDirection = (p_vPos-pxObj^.GetPos()).GetNormalized();
		vEnemyDirection.SetZ(0.0f);
		vEnemyDirection.Normalize();
		var vec3 vSelfDirection = {0.0f, 1.0f, 0.0};
		pxObj^.GetRot().VecRotateU(vSelfDirection);
		qAddRot.VecRotateU(vSelfDirection);
		vSelfDirection.SetZ(0.0f);
		vSelfDirection.Normalize();
		var real fDifference = (vEnemyDirection-vSelfDirection).Abs2()*0.5f;
		if(fDifference > 0.1f)then
			if(pxObj^.GetSecActionDesc()=="CAct")then
				var Quat qR; qR.FromXYDir(vEnemyDirection.GetX(), vEnemyDirection.GetY());
				qR /= pxObj^.GetRot();
				fDifference *= GetBuildUpRotSpeed();
//				if(m_sTurnAnim!="")then
//					pxObj^.SetAnim(m_sTurnAnim,3);
//					pxObj^.SetSLEAnim(m_sTurnAnim,10);
//				endif;
				pxObj^.SecRotAction(qR, fDifference);
			endif;
			return true;
		endif;
		return false;
	endproc;
	
	export proc bool RotateToEnemyRightNow(^CGameObj p_pxEnemy, vec3 p_vPos)
		if(!CanRotate())then return false; endif;
		var ^CGameObj pxObj = GetPrimaryLinkedObjFight().GetObj();
		if(pxObj==null)then return false; endif;
		var Quat qAddRot = pxObj^.GetAdditionalRot();
		if(p_pxEnemy!=null)then
			p_vPos = p_pxEnemy^.GetPos();
		endif;
		var vec3 vEnemyDirection = (p_vPos-pxObj^.GetPos()).GetNormalized();
		vEnemyDirection.SetZ(0.0f);
		vEnemyDirection.Normalize();
		var vec3 vSelfDirection = {0.0f, 1.0f, 0.0};
		pxObj^.GetRot().VecRotateU(vSelfDirection);
		qAddRot.VecRotateU(vSelfDirection);
		vSelfDirection.SetZ(0.0f);
		vSelfDirection.Normalize();
		var real fDifference = (vEnemyDirection-vSelfDirection).Abs2()*0.5f;
		if(fDifference > 0.1f)then
			if(pxObj^.GetSecActionDesc()=="CAct")then
				var Quat qR; qR.FromXYDir(vEnemyDirection.GetX(), vEnemyDirection.GetY());
				qR /= pxObj^.GetRot();
				fDifference *= 0.1;
				pxObj^.SecRotAction(qR, fDifference);
			endif;
			return false;
		endif;
		return false;
	endproc;
	
	export proc bool AttackEnemy(^CFightingObj p_pxEnemy, vec3 p_vPos)
		if(m_bFake)then return false; endif;
		var ^CFightingObj pxParent = cast<CFightingObj>(m_xParent.GetObj());
		if(pxParent==null)then return false; endif;
		if(pxParent^.InvalidFighter()||(pxParent^.IsTrapped()&&!pxParent^.ExcludeBuildUp()))then return false; endif;
		if(p_pxEnemy!=null)then
			if(p_pxEnemy^.GetTransportObj().IsValid())then return false; endif;
			if(p_pxEnemy^.InvalidEnemy()||p_pxEnemy^.HidingEnemy())then return false; endif;
			if(p_pxEnemy^.IsFlyingUnit() && !CanShootAir())then return false; endif;
		endif;
		var ^CGameObj pxObj = GetPrimaryLinkedObjFight().GetObj();
		if(pxObj==null)then return false; endif;
		pxParent^.BuildUpKeeperAttack();
		if(pxObj^.HasAnim(m_sAttackAnim))then
			pxObj^.SetAnim(m_sAttackAnim, 1);
		endif;
//		pxParent^.CreateProjectileAndShoot(p_pxEnemy, p_vPos);
		var int j, iK=pxParent^.GetProjectilesNumber();
		for(j=0)cond(j<iK)iter(j++)do
			pxParent^.CreateProjectileAndShoot(p_pxEnemy, p_vPos);
		endfor;
		var real fDuration = pxParent^.GetWeaponDuration();
		var ^CTransportObj pxTOParent = cast<CTransportObj>(m_xParent.GetObj());
		if(pxTOParent!=null)then
			pxTOParent^.DoCaptainAttackAnim();
			pxTOParent^.SetBuildUpBusy(fDuration);
		endif;
		pxParent^.WaitAction(fDuration);
		return true;
	endproc;
	
	export proc bool AutoAttackEnemy(^CFightingObj p_pxEnemy, ref real p_rfDuration)
		if(m_bFake)then return false; endif;
		var ^CFightingObj pxParent = cast<CFightingObj>(m_xParent.GetObj());
		if(pxParent==null)then return false; endif;
		var vec3 vEnemy;
		if(pxParent^.InvalidFighter()||(pxParent^.IsTrapped()&&!pxParent^.ExcludeBuildUp()))then return false; endif;
		if(p_pxEnemy!=null)then
			if(p_pxEnemy^.GetTransportObj().IsValid())then return false; endif;
			if(p_pxEnemy^.InvalidEnemy()||p_pxEnemy^.HidingEnemy())then return false; endif;
			vEnemy=p_pxEnemy^.GetPos();
		endif;
		var ^CGameObj pxObj = GetPrimaryLinkedObjFight().GetObj();
		if(pxObj==null)then return false; endif;
		var bool bShoot, bAdditional=GetAdditionalWeapon();
		p_rfDuration = GetWeaponDuration();
		if(p_rfDuration<=0.0f)then
			p_rfDuration=pxParent^.GetWeaponDuration();
			if(p_rfDuration<=0.0f)then
				p_rfDuration=1.0;
			endif;
		endif;
		pxParent^.BuildUpKeeperAttack();
		if(pxObj^.HasAnim(m_sAttackAnim))then
			pxObj^.SetAnim(m_sAttackAnim, 1);
		endif;
//		pxParent^.CreateProjectileAndShootBuildUp(p_pxEnemy, p_pxEnemy^.GetPos(), this);
		var int j, iK=pxParent^.GetProjectilesNumber();
		for(j=0)cond(j<iK)iter(j++)do
			if(!bAdditional)then
				bShoot=pxParent^.CreateProjectileAndShootBUNew(p_pxEnemy, vEnemy);
			else
				bShoot=pxParent^.CreateProjectileAndShootBuildUp(p_pxEnemy, vEnemy, this);
			endif;
		endfor;
		if(!bShoot)then return false; endif;
		var ^CTransportObj pxTOParent = cast<CTransportObj>(m_xParent.GetObj());
		if(pxTOParent==null)then return false; endif;
		if(!GetAdditionalWeapon())then
			pxTOParent^.DoBuildUpCaptainAttackAnim();
		else
			if(m_xCaptain.IsValid())then
				var ^CGameObj pxCaptain = m_xCaptain.GetObj();
				var string sAnim = pxTOParent^.GetCaptainAttackAnim();
				if(pxCaptain^.HasAnim(sAnim))then
					pxCaptain^.SetAnim(sAnim, 1);
				endif;
			endif;
		endif;
//		var real fDuration = GetWeaponDuration();
		pxTOParent^.SetBuildUpBusy(p_rfDuration);
		return true;
	endproc;
	
	export proc void PlayExtraAnim(string p_sAnim)
		if(!m_bFake)then return; endif;
		if(m_xCaptain.IsValid())then
			var ^CGameObj pxCaptain = m_xCaptain.GetObj();
//			var string sAnim = pxTOParent^.GetExtraCaptainAttackAnim();
			if(pxCaptain^.HasAnim(p_sAnim))then
				pxCaptain^.SetAnim(p_sAnim, 1);
			endif;
		endif;
	endproc;
	
	export proc void StopFighting()
		var ^CProduct pxBuildUpObj = cast<CProduct>(GetPrimaryLinkedObjFight().GetObj());
		if(pxBuildUpObj==null)then return; endif;
		var ^CBuildUpFight pxFightTask = cast<CBuildUpFight>(pxBuildUpObj^.GetCurTask());
		if(pxFightTask!=null)then
			pxFightTask^.Break();
		endif;
		if(m_xParent.IsValid())then
			var ^CFightingObj pxParent = cast<CFightingObj>(m_xParent.GetObj());
			if(pxParent==null||pxParent^.InvalidFighter())then
				if(pxFightTask!=null)then
					pxFightTask^.Break();
				endif;
			endif;
		endif;
	endproc;
	
	export proc void UpdateLinkedObjs()
		super.UpdateLinkedObjs();
		if(!m_xCaptain.IsValid())then return; endif;
		var ^CTransportObj pxParent = cast<CTransportObj>(m_xParent.GetObj());
		if(pxParent==null)then return; endif;
		var string sAnim = pxParent^.GetCaptainAnim();
		if(sAnim.IsEmpty())then return; endif;
		if(m_xCaptain.GetObj()^.HasAnim(sAnim))then
			m_xCaptain.GetObj()^.SetAnim(sAnim,3);
		endif;
	endproc;
	/*
	export proc void TransferLinkedObjsAdd(^CBuildUpBase p_pxOther)
		if(m_bFake)then return; endif;
		if(p_pxOther==null)then return; endif;
		var ^CGameObj pxParent = m_xParent.GetObj();
		if(pxParent==null)then return; endif;
		var int i, iC=m_axLinkedObjs.NumEntries()-1;
		for(i=iC)cond(i>=0)iter(i--)do
			if(m_axLinkedObjs[i].GetHandle()==m_xCaptain)then continue; endif;
			var ^CGameObj pxObj = m_axLinkedObjs[i].GetHandle().GetObj();
			if(pxObj==null)then
				m_axLinkedObjs.DeleteEntry(i);
				continue;
			endif;
			pxParent^.RemGroupedChildren(pxObj^.GetGuid());
			pxObj^.TerminateAction();
			if(pxObj^.GetClassName()=="seas_triceratops_machinegun")then
				pxObj^.SetDestructLevel(2);
			else
				if(pxObj^.HasAnim("destroy"))then
					pxObj^.SetAnim("destroy", 1);
				else
					pxObj^.SetAnim("standanim", 3);
				endif;
			endif;
			var bool bCustom = m_axLinkedObjs[i].GetCustom();
			if(bCustom)then
				p_pxOther^.AddObjWithOffset(m_axLinkedObjs[i].GetHandle(), m_axLinkedObjs[i].GetLink().AsString(), m_axLinkedObjs[i].GetDelay(), m_axLinkedObjs[i].GetParentObj(), m_axLinkedObjs[i].GetLinkOffset());
			else
				p_pxOther^.AddObjFlex(m_axLinkedObjs[i].GetHandle(), m_axLinkedObjs[i].GetLink().AsString(), m_axLinkedObjs[i].GetDelay(), m_axLinkedObjs[i].GetParentObj());
			endif;
			m_axLinkedObjs.DeleteEntry(i);
		endfor;
	endproc;
	*/
	export proc void TransferLinkedObjsAdd(^CDino_Food p_pxCorpse)
		if(m_bFake)then return; endif;
		if(p_pxCorpse==null)then return; endif;
		var ^CGameObj pxParent = m_xParent.GetObj();
		if(pxParent==null)then return; endif;
		var int i, iC=m_axLinkedObjs.NumEntries()-1;
		for(i=iC)cond(i>=0)iter(i--)do
			if(m_axLinkedObjs[i].GetHandle()==m_xCaptain)then continue; endif;
			var ^CGameObj pxObj = m_axLinkedObjs[i].GetHandle().GetObj();
			if(pxObj==null)then
				m_axLinkedObjs.DeleteEntry(i);
				continue;
			endif;
			pxParent^.RemGroupedChildren(pxObj^.GetGuid());
			pxObj^.TerminateAction();
			if(pxObj^.GetClassName()=="seas_triceratops_machinegun")then
				pxObj^.SetDestructLevel(2);
			else
				if(pxObj^.HasAnim("destroy"))then
					pxObj^.SetAnim("destroy", 1);
				elseif(pxObj^.HasAnim("standanim"))then
					pxObj^.SetAnim("standanim", 3);
				endif;
			endif;
			var bool bCustom = m_axLinkedObjs[i].GetCustom();
			if(bCustom)then
				p_pxCorpse^.AddObjWithOffset(m_axLinkedObjs[i].GetHandle(), m_axLinkedObjs[i].GetLink().AsString(), m_axLinkedObjs[i].GetDelay(), m_axLinkedObjs[i].GetParentObj(), m_axLinkedObjs[i].GetLinkOffset());
			else
				p_pxCorpse^.AddObjFlex(m_axLinkedObjs[i].GetHandle(), m_axLinkedObjs[i].GetLink().AsString(), m_axLinkedObjs[i].GetDelay(), m_axLinkedObjs[i].GetParentObj());
			endif;
			m_axLinkedObjs.DeleteEntry(i);
		endfor;
	endproc;
	
	export proc void SetFake(bool p_bValue)
		m_bFake = p_bValue;
	endproc;
	
	export proc void SetSecond(bool p_bValue)
		m_bSecond = p_bValue;
	endproc;
	
	export proc bool GetSecond()
		return m_bSecond;
	endproc;
	
endclass;
	
class CBuildUpWeaponTransporter inherit CBuildUpWeapon
	
	var CObjList m_xPassengers;
	
	export constructor()
		SetType(CBuildUpBase.TYPE_WEAPON_TRANSPORTER);
	endconstructor;
	
	export proc void DoKArc(ref CArc p_rxArc, int p_iVersion)
		super.DoKArc(p_rxArc,p_iVersion);
		if(p_iVersion>=14)then
			var int i, iC = m_xPassengers.NumEntries();
			p_rxArc << iC;
			m_xPassengers = iC;
			for(i=0)cond(i<iC)iter(i++)do
				m_xPassengers[i].DoKArc(p_rxArc);
			endfor;
		endif;
	endproc;
	
	export proc void AddPassenger(CObjHndl p_xPassenger)
		m_xPassengers.Include(p_xPassenger);
		UpdateLinkedObjs();
	endproc;
	
	export proc void Kill()
		var ^CTransportObj pxParent = cast<CTransportObj>(m_xParent.GetObj());
		if(pxParent!=null)then
			while(m_xPassengers.NumEntries()>0)do
				if(!pxParent^.OnDismount(m_xPassengers[0]))then
					m_xPassengers.DeleteEntry(0);
				endif;
			endwhile;
		endif;
		super.Kill();
	endproc;
	
	export proc void RemovePassenger(CObjHndl p_xPassenger)
		if(m_xPassengers.FindEntry(p_xPassenger)==-1)then return; endif;
		m_xPassengers.RemEntry(p_xPassenger);
		var ^CGameObj pxPassenger = p_xPassenger.GetObj();
		if(pxPassenger==null)then return; endif;
		var ^CGameObj pxParent = m_xParent.GetObj();
		if(pxParent==null)then return; endif;
		pxParent^.RemGroupedChildren(pxPassenger^.GetGuid());
		UpdateLinkedObjs();
	endproc;
	
	export proc void UpdateLinkedObjs()
		var ^CGameObj pxParent = m_xParent.GetObj();
		if(pxParent==null)then return; endif;
		super.UpdateLinkedObjs();
		if(GetType()==CBuildUpBase.TYPE_WEAPON_TRANSPORTER)then
			var CFourCC xInvalidLink;
			var int i, iC = m_xPassengers.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				var ^CGameObj pxPassenger = m_xPassengers[i].GetObj();
				if(pxPassenger==null)then
					m_xPassengers.DeleteEntry(i);
					i--; iC--;
					continue;
				endif;
				pxPassenger^.SetVisible(false);
				pxPassenger^.LinkAction(m_xParent,xInvalidLink);
				pxParent^.AddGroupedChildren(pxPassenger^.GetGuid());
			endfor;
		endif;
	endproc;
	
endclass;
	
class CBuildUpRexTransporter inherit CBuildUpTransporter
	
	var array string m_asIgnoreLinks;
	
	export constructor()
		SetType(CBuildUpBase.TYPE_TREX);
	endconstructor;
	
	export proc void DoKArcMirage(ref CArc p_rxArc, int p_iVersion)
		super.DoKArcMirage(p_rxArc, p_iVersion);
		if(p_iVersion>=1)then
			var int i, iC = m_asIgnoreLinks.NumEntries();
			p_rxArc << iC;
			m_asIgnoreLinks = iC;
			for(i=0)cond(i<iC)iter(i++)do
				p_rxArc << m_asIgnoreLinks[i];
			endfor;
		endif;
	endproc;
	
	export proc void AddIgnoreLink(string p_sLink)
		m_asIgnoreLinks.AddEntry(p_sLink);
	endproc;
	
	export proc void Fight(^CGameObj p_pxTarget, vec3 p_vPos, bool p_bUserCommand, bool p_bQ)
		var int i, iC = m_xPassengers.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFightingObj pxObj = cast<CFightingObj>(m_xPassengers[i].GetObj());
			if(pxObj==null)then continue; endif;
			pxObj^.Fight(p_pxTarget, p_vPos, p_bUserCommand, p_bQ);
		endfor;
	endproc;
	
	export proc void UpdateLinkedObjs()
		var ^CTransportObj pxParent = cast<CTransportObj>(m_xParent.GetObj());
		if(pxParent==null)then return; endif;
		var CObjList xPassengers = m_xPassengers;
		super.UpdateLinkedObjs();
		var bool bHidden = pxParent^.GetTransportObj().IsValid();
		var string sLink = "Rid";
		var int i, iC = 4;
		for(i=0)cond(i<iC)iter(i++)do
			var CFourCC xLink = "Rid" + i.ToString();
			var vec3 vP;
			if(m_asIgnoreLinks.FindEntry(xLink.AsString())!=-1)then continue; endif;
			if(pxParent^.GetLinkPosObj(xLink, vP))then
				if(xPassengers.NumEntries()>0)then
					var ^CGameObj pxPassenger = xPassengers[0].GetObj();
					if(pxPassenger!=null)then
						pxPassenger^.LinkAction(m_xParent, xLink);
						pxPassenger^.SetRndInvMaskSingleFlagInv(88,false);
						pxParent^.AddGroupedChildren(pxPassenger^.GetGuid());
						var string sLoopAnim = pxParent^.GetPassengerLoopAnim();
						var string sAnim = pxPassenger^.GetCurrentAnimName();
						if(pxPassenger^.HasAnim(sLoopAnim)&&sAnim!=sLoopAnim&&sAnim!="heal_0")then
							pxPassenger^.SetAnim(sLoopAnim, 3);
						endif;
						if(pxPassenger^.GetFSM()!=null)then
							pxPassenger^.GetFSM()^.Enable(true);
						endif;
						pxPassenger^.SetVisible(!bHidden);
					endif;
					xPassengers.DeleteEntry(0);
				endif;
			endif;
		endfor;
	endproc;
	
	export proc void RemovePassenger(CObjHndl p_xPassenger)
		super.RemovePassenger(p_xPassenger);
		var ^CGameObj pxObj=p_xPassenger.GetObj();
		if(pxObj!=null)then
			var Quat qAddRot = pxObj^.GetAdditionalRot();
			if(!qAddRot.IsIdentity())then
				var vec3 vCurDir = {0.0f, 1.0f, 0.0f};
				pxObj^.GetRot().VecRotateU(vCurDir);
				qAddRot.VecRotateU(vCurDir);
				var real fD = ({0.0f, 1.0f, 0.0}-vCurDir).Abs2();
				qAddRot.SetIdentity();
				pxObj^.SecRotAction(qAddRot, fD);
			endif;
		endif;
	endproc;
	
	export proc void EnableLinkedObjs()
		super.EnableLinkedObjs();
		var int i, iC = m_xPassengers.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CGameObj pxObj = m_xPassengers[i].GetObj();
			if(pxObj==null)then continue; endif;
			if(pxObj^.GetFSM()==null)then continue; endif;
			pxObj^.GetFSM()^.Enable(true);
		endfor;
	endproc;
	
endclass;
	
class CBuildUpSeismoTransporter inherit CBuildUpWeapon
	
	var CObjList m_xPassengers;
	var array string m_asIgnoreLinks;
	
	export constructor()
		SetType(CBuildUpBase.TYPE_SEISMO);
	endconstructor;
	
	export proc void DoKArc(ref CArc p_rxArc, int p_iVersion)
		super.DoKArc(p_rxArc, p_iVersion);
		if(p_iVersion>=15)then
			var int i, iC = m_asIgnoreLinks.NumEntries();
			p_rxArc << iC;
			m_asIgnoreLinks = iC;
			for(i=0)cond(i<iC)iter(i++)do
				p_rxArc << m_asIgnoreLinks[i];
			endfor;
			iC = m_xPassengers.NumEntries();
			p_rxArc << iC;
			m_xPassengers = iC;
			for(i=0)cond(i<iC)iter(i++)do
				m_xPassengers[i].DoKArc(p_rxArc);
			endfor;
		endif;
	endproc;
	
	export proc void DoKArcMirage(ref CArc p_rxArc, int p_iVersion)
		if(p_iVersion>=1)then
			p_rxArc << m_sAnim;
		endif;
	endproc;
	
	export proc void SetParent(CObjHndl p_xParent)
		super.SetParent(p_xParent);
		var ^CTransportObj pxObj=cast<CTransportObj>(p_xParent.GetObj());
		if(pxObj!=null)then
			pxObj^.SetTransportClass(1);
		endif;
	endproc;
	
	export proc void AddIgnoreLink(string p_sLink)
		m_asIgnoreLinks.AddEntry(p_sLink);
	endproc;
	
	export proc void Fight(^CGameObj p_pxTarget, vec3 p_vPos, bool p_bUserCommand, bool p_bQ)
		var int i, iC = m_xPassengers.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFightingObj pxObj = cast<CFightingObj>(m_xPassengers[i].GetObj());
			if(pxObj==null)then continue; endif;
			pxObj^.Fight(p_pxTarget, p_vPos, p_bUserCommand, p_bQ);
		endfor;
	endproc;
	
	export proc void UpdateLinkedObjs()
		var ^CTransportObj pxParent = cast<CTransportObj>(m_xParent.GetObj());
		if(pxParent==null)then return; endif;
		var CObjList xPassengers = m_xPassengers;
		super.UpdateLinkedObjs();
		var bool bHidden = pxParent^.GetTransportObj().IsValid();
		var array vec3 avOffset;
		avOffset.AddEntry({0.0,-0.5,0.0});
		avOffset.AddEntry({0.0,1.5,0.0});
		var array string asLinks;
		asLinks.AddEntry("Ride");
		asLinks.AddEntry("Ch_1");
		var int i, iC = asLinks.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var CFourCC xLink = asLinks[i];
			var vec3 vP;
			if(m_asIgnoreLinks.FindEntry(xLink.AsString())!=-1)then continue; endif;
			if(pxParent^.GetLinkPosObj(xLink, vP))then
				if(xPassengers.NumEntries()>0)then
					var ^CGameObj pxPassenger = xPassengers[0].GetObj();
					if(pxPassenger!=null)then
						pxPassenger^.LinkAction(m_xParent, xLink, avOffset[i]);
						pxPassenger^.SetRndInvMaskSingleFlagInv(88,false);
						pxParent^.AddGroupedChildren(pxPassenger^.GetGuid());
						var string sLoopAnim = pxParent^.GetPassengerLoopAnim();
						var string sAnim = pxPassenger^.GetCurrentAnimName();
						if(pxPassenger^.HasAnim(sLoopAnim)&&sAnim!=sLoopAnim&&sAnim!="heal_0")then
							pxPassenger^.SetAnim(sLoopAnim, 3);
						endif;
						if(pxPassenger^.GetFSM()!=null)then
							pxPassenger^.GetFSM()^.Enable(true);
						endif;
						pxPassenger^.SetVisible(!bHidden);
					endif;
					xPassengers.DeleteEntry(0);
				endif;
			endif;
		endfor;
	endproc;
	
	export proc void AddPassenger(CObjHndl p_xPassenger)
		m_xPassengers.Include(p_xPassenger);
		UpdateLinkedObjs();
	endproc;
	
	export proc void Kill()
		var ^CTransportObj pxParent = cast<CTransportObj>(m_xParent.GetObj());
		if(pxParent!=null)then
			while(m_xPassengers.NumEntries()>0)do
				if(!pxParent^.OnDismount(m_xPassengers[0]))then
					m_xPassengers.DeleteEntry(0);
				endif;
			endwhile;
		endif;
		super.Kill();
	endproc;
	
	export proc void RemovePassenger(CObjHndl p_xPassenger)
		if(m_xPassengers.FindEntry(p_xPassenger)==-1)then return; endif;
		m_xPassengers.RemEntry(p_xPassenger);
		var ^CGameObj pxPassenger = p_xPassenger.GetObj();
		if(pxPassenger==null)then return; endif;
		var ^CGameObj pxParent = m_xParent.GetObj();
		if(pxParent==null)then return; endif;
		pxParent^.RemGroupedChildren(pxPassenger^.GetGuid());
		UpdateLinkedObjs();
		var ^CGameObj pxObj=p_xPassenger.GetObj();
		if(pxObj!=null)then
			var Quat qAddRot = pxObj^.GetAdditionalRot();
			if(!qAddRot.IsIdentity())then
				var vec3 vCurDir = {0.0f, 1.0f, 0.0f};
				pxObj^.GetRot().VecRotateU(vCurDir);
				qAddRot.VecRotateU(vCurDir);
				var real fD = ({0.0f, 1.0f, 0.0}-vCurDir).Abs2();
				qAddRot.SetIdentity();
				pxObj^.SecRotAction(qAddRot, fD);
			endif;
		endif;
	endproc;
	
	export proc void EnableLinkedObjs()
		super.EnableLinkedObjs();
		var int i, iC = m_xPassengers.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CGameObj pxObj = m_xPassengers[i].GetObj();
			if(pxObj==null)then continue; endif;
			if(pxObj^.GetFSM()==null)then continue; endif;
			pxObj^.GetFSM()^.Enable(true);
		endfor;
	endproc;
	
	export proc void UpdatePassengersLinking()
		var ^CTransportObj pxParent = cast<CTransportObj>(m_xParent.GetObj());
		if(pxParent==null)then return; endif;
		var bool bHidden = pxParent^.GetTransportObj().IsValid();
		if(m_axLinkedObjs.NumEntries()<1)then return; endif;
		var ^CGameObj pxObj = m_axLinkedObjs[0].GetHandle().GetObj();
		if(pxObj==null)then return; endif;
		var CObjList xPassengers = m_xPassengers;
		var array vec3 avOffset;
		avOffset.AddEntry({0.0,-0.5,0.0});
		avOffset.AddEntry({0.0,1.5,0.0});
		var array string asLinks;
		asLinks.AddEntry("Ride");
		asLinks.AddEntry("Ch_1");
		var int i, iC = asLinks.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(xPassengers.NumEntries()>0)then
				var CFourCC xLink = asLinks[i];
				var vec3 vP;
				if(m_asIgnoreLinks.FindEntry(xLink.AsString())!=-1)then continue; endif;
				if(pxParent^.GetLinkPosObj(xLink, vP))then
					var ^CGameObj pxPassenger = xPassengers[0].GetObj();
					if(pxPassenger!=null)then
						pxPassenger^.LinkAction(m_xParent, xLink, avOffset[i]);
						pxPassenger^.SetRndInvMaskSingleFlagInv(88,false);
						pxParent^.AddGroupedChildren(pxPassenger^.GetGuid());
						var string sLoopAnim = pxParent^.GetPassengerLoopAnim();
						var string sAnim = pxPassenger^.GetCurrentAnimName();
						if(pxPassenger^.HasAnim(sLoopAnim)&&sAnim!=sLoopAnim&&sAnim!="heal_0")then
							pxPassenger^.SetAnim(sLoopAnim, 3);
						endif;
						if(pxPassenger^.GetFSM()!=null)then
							pxPassenger^.GetFSM()^.Enable(true);
						endif;
						pxPassenger^.SetVisible(!bHidden);
					endif;
					xPassengers.DeleteEntry(0);
				endif;
			endif;
		endfor;
	endproc;
	
endclass;

class CBuildUpTransporterCustom inherit CBuildUpTransporter
	
	var array vec3 m_avOffsets;
	var array string m_asLinks;
	var array string m_asIgnoreLinks;
	
	export proc void DoKArc(ref CArc p_rxArc, int p_iVersion)
		super.DoKArc(p_rxArc, p_iVersion);
		if(p_iVersion>=15)then
			var int i, iC = m_asIgnoreLinks.NumEntries();
			p_rxArc << iC;
			m_asIgnoreLinks = iC;
			for(i=0)cond(i<iC)iter(i++)do
				p_rxArc << m_asIgnoreLinks[i];
			endfor;
		endif;
	endproc;
	
	export proc void SetParent(CObjHndl p_xParent)
		super.SetParent(p_xParent);
		var ^CTransportObj pxObj=cast<CTransportObj>(p_xParent.GetObj());
		if(pxObj!=null)then
			pxObj^.SetTransportClass(1);
		endif;
	endproc;
	
	export proc void AddIgnoreLink(string p_sLink)
		m_asIgnoreLinks.AddEntry(p_sLink);
	endproc;
	
	export proc void Fight(^CGameObj p_pxTarget, vec3 p_vPos, bool p_bUserCommand, bool p_bQ)
		var int i, iC = m_xPassengers.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFightingObj pxObj = cast<CFightingObj>(m_xPassengers[i].GetObj());
			if(pxObj==null)then continue; endif;
			pxObj^.Fight(p_pxTarget, p_vPos, p_bUserCommand, p_bQ);
		endfor;
	endproc;
	
	export proc void AddPassenger(CObjHndl p_xPassenger)
		m_xPassengers.Include(p_xPassenger);
		UpdateLinkedObjs();
	endproc;
	
	export proc void Kill()
		var ^CTransportObj pxParent = cast<CTransportObj>(m_xParent.GetObj());
		if(pxParent!=null)then
			while(m_xPassengers.NumEntries()>0)do
				if(!pxParent^.OnDismount(m_xPassengers[0]))then
					m_xPassengers.DeleteEntry(0);
				endif;
			endwhile;
		endif;
		super.Kill();
	endproc;
	
	export proc void RemovePassenger(CObjHndl p_xPassenger)
		if(m_xPassengers.FindEntry(p_xPassenger)==-1)then return; endif;
		m_xPassengers.RemEntry(p_xPassenger);
		var ^CGameObj pxPassenger = p_xPassenger.GetObj();
		if(pxPassenger==null)then return; endif;
		var ^CGameObj pxParent = m_xParent.GetObj();
		if(pxParent==null)then return; endif;
		pxParent^.RemGroupedChildren(pxPassenger^.GetGuid());
		UpdateLinkedObjs();
		var ^CGameObj pxObj=p_xPassenger.GetObj();
		if(pxObj!=null)then
			var Quat qAddRot = pxObj^.GetAdditionalRot();
			if(!qAddRot.IsIdentity())then
				var vec3 vCurDir = {0.0f, 1.0f, 0.0f};
				pxObj^.GetRot().VecRotateU(vCurDir);
				qAddRot.VecRotateU(vCurDir);
				var real fD = ({0.0f, 1.0f, 0.0}-vCurDir).Abs2();
				qAddRot.SetIdentity();
				pxObj^.SecRotAction(qAddRot, fD);
			endif;
		endif;
	endproc;
	
	export proc void EnableLinkedObjs()
		super.EnableLinkedObjs();
		var int i, iC = m_xPassengers.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CGameObj pxObj = m_xPassengers[i].GetObj();
			if(pxObj==null)then continue; endif;
			if(pxObj^.GetFSM()==null)then continue; endif;
			pxObj^.GetFSM()^.Enable(true);
		endfor;
	endproc;
	
	export proc void UpdateLinkedObjs()
		var ^CTransportObj pxParent = cast<CTransportObj>(m_xParent.GetObj());
		if(pxParent==null)then return; endif;
		var CObjList xPassengers = m_xPassengers;
		super.UpdateLinkedObjs();
		if(m_axLinkedObjs.NumEntries()<=0)then return; endif;
		var ^CGameObj pxObj = m_axLinkedObjs[0].GetHandle().GetObj();
		if(pxObj==null)then return; endif;
		var bool bHidden = pxParent^.GetTransportObj().IsValid();
		var int i, iC = m_asLinks.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var CFourCC xLink = m_asLinks[i];
			var vec3 vP;
//			if(m_asIgnoreLinks.FindEntry(xLink.AsString())!=-1)then continue; endif;
			if(pxObj^.GetLinkPosObj(xLink, vP))then
				if(xPassengers.NumEntries()>0)then
					var ^CGameObj pxPassenger = xPassengers[0].GetObj();
					if(pxPassenger!=null)then
						pxPassenger^.LinkAction(pxObj^.GetHandle(), xLink, m_avOffsets[i]);
						pxPassenger^.SetRndInvMaskSingleFlagInv(88,false);
						pxParent^.AddGroupedChildren(pxPassenger^.GetGuid());
						var string sLoopAnim = pxParent^.GetPassengerLoopAnim();
						var string sAnim = pxPassenger^.GetCurrentAnimName();
						if(pxPassenger^.HasAnim(sLoopAnim)&&sAnim!=sLoopAnim&&sAnim!="heal_0")then
							pxPassenger^.SetAnim(sLoopAnim, 3);
						endif;
						if(pxPassenger^.GetFSM()!=null)then
							pxPassenger^.GetFSM()^.Enable(true);
						endif;
						pxPassenger^.SetVisible(!bHidden);
					endif;
					xPassengers.DeleteEntry(0);
				endif;
			endif;
		endfor;
	endproc;
	
	export proc void UpdatePassengersLinking()
		var ^CTransportObj pxParent = cast<CTransportObj>(m_xParent.GetObj());
		if(pxParent==null)then return; endif;
		var bool bHidden = pxParent^.GetTransportObj().IsValid();
		if(m_axLinkedObjs.NumEntries()<1)then return; endif;
		var ^CGameObj pxObj = m_axLinkedObjs[0].GetHandle().GetObj();
		if(pxObj==null)then return; endif;
		var CObjList xPassengers = m_xPassengers;
		var int i, iC = m_asLinks.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(xPassengers.NumEntries()>0)then
				var CFourCC xLink = m_asLinks[i];
				var vec3 vP;
				if(m_asIgnoreLinks.FindEntry(xLink.AsString())!=-1)then continue; endif;
				if(pxObj^.GetLinkPosObj(xLink, vP))then
					var ^CGameObj pxPassenger = xPassengers[0].GetObj();
					if(pxPassenger!=null)then
						pxPassenger^.LinkAction(pxObj^.GetHandle(), xLink, m_avOffsets[i]);
						pxPassenger^.SetRndInvMaskSingleFlagInv(88,false);
						pxParent^.AddGroupedChildren(pxPassenger^.GetGuid());
						var string sLoopAnim = pxParent^.GetPassengerLoopAnim();
						var string sAnim = pxPassenger^.GetCurrentAnimName();
						if(pxPassenger^.HasAnim(sLoopAnim)&&sAnim!=sLoopAnim&&sAnim!="heal_0")then
							pxPassenger^.SetAnim(sLoopAnim, 3);
						endif;
						if(pxPassenger^.GetFSM()!=null)then
							pxPassenger^.GetFSM()^.Enable(true);
						endif;
						pxPassenger^.SetVisible(!bHidden);
					endif;
					xPassengers.DeleteEntry(0);
				endif;
			endif;
		endfor;
	endproc;
	
	export proc void AddLinkAndOffset(string p_sLink, vec3 p_vOffset)
		m_asLinks.AddEntry(p_sLink);
		m_avOffsets.AddEntry(p_vOffset);
	endproc;
	
endclass;

class CBuildUpTricTitanTransporter inherit CBuildUpTransporterCustom
	
	export constructor()
		SetType(CBuildUpBase.TYPE_TRIC_TITAN);
		AddLinkAndOffset("Dri1",{0.0,0.76,0.0});
		AddLinkAndOffset("Dri1",{0.0,-0.33,0.0});
		AddLinkAndOffset("Dri2",{0.0,-0.16,0.0});
		AddLinkAndOffset("Dri3",{0.0,0.16,0.0});
		AddLinkAndOffset("Dri4",{0.0,0.5,0.0});
		AddLinkAndOffset("Dri4",{0.0,-0.55,0.0});
	endconstructor;
	
		// Henry: 5 slots version...
//		avOffset.AddEntry({0.0,0.7,0.0});
//		avOffset.AddEntry({0.0,-0.56,0.0});
//		avOffset.AddEntry({0.0,-0.53,0.0});
//		avOffset.AddEntry({0.0,-0.37,0.0});
//		avOffset.AddEntry({0.0,-0.15,0.0});
//		asLinks.AddEntry("Dri1");
//		asLinks.AddEntry("Dri1");
//		asLinks.AddEntry("Dri2");
//		asLinks.AddEntry("Dri3");
//		asLinks.AddEntry("Dri4");
	
endclass;
	
class CBuildUpTricTransporter inherit CBuildUpTransporterCustom
	
	export constructor()
		SetType(CBuildUpBase.TYPE_TRIC_TRANSPORTER);
		AddLinkAndOffset("Dri2",{0.0,0.40,0.0});
		AddLinkAndOffset("Dri2",{0.0,-0.17,0.0});
		AddLinkAndOffset("Dri3",{0.0,0.33,0.0});
		AddLinkAndOffset("Dri3",{0.0,-0.26,0.0});
	endconstructor;
	
endclass;
	
class CBuildUpNinigiStyraTransporter inherit CBuildUpTransporterCustom
	
	export constructor()
		SetType(CBuildUpBase.TYPE_STYRA_TRANSPORTER);
		AddLinkAndOffset("Dri2",{0.0,0.0,0.0});
		AddLinkAndOffset("Dri3",{0.0,0.0,0.0});
		AddLinkAndOffset("Dri4",{0.0,0.0,0.0});
		AddLinkAndOffset("Dri1",{0.0,-1.43,0.0});
	endconstructor;
	
endclass;
	
class CBuildUpAjeCyborgTransporter inherit CBuildUpTransporterCustom
	
	export constructor()
		SetType(CBuildUpBase.TYPE_CYBORG_TRANSPORTER);
		AddLinkAndOffset("Dri2",{0.8,0.0,0.0});
		AddLinkAndOffset("Dri2",{-0.8,0.0,0.0});
		AddLinkAndOffset("Dri3",{0.0,0.0,0.0});
		AddLinkAndOffset("Dri4",{0.0,0.0,0.0});
	endconstructor;
	
endclass;
	