class CFirefly inherit CGameObj

	var ^CState m_pxNight;
	var ^CState m_pxDay;
	var ^CState m_pxInit;
	var int	 m_iNight;
	var int	 m_iDay;
	var bool	m_bLight;
	var real	m_fDelay;
	var real	m_fStartTime;

	export constructor()
		Random.Seed();
	endconstructor;

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetSelectable(false);
		SetHitable(false);

		if(p_bLoad)then
			SetVisible(false);
		else
			SetVisible(true);
		endif;

		m_iNight			= 7;
		m_iDay		= 0;
		m_bLight			= false;
		m_fDelay			=0.0;

		var ^CFSM pxFSM		 = InitFSM();
		var TStateClassID xUSLStateID="USLState";

		m_pxInit					= CSrvWrap.GetUSLFactoryMgr().CreateState(pxFSM,xUSLStateID);
		m_pxDay				 = CSrvWrap.GetUSLFactoryMgr().CreateState(pxFSM,xUSLStateID);
		m_pxNight				= CSrvWrap.GetUSLFactoryMgr().CreateState(pxFSM,xUSLStateID);

		m_pxInit^.m_xOnTick	 = InitOnTick;

		m_pxDay^.m_xOnEnter	 = DayOnEnter;
		m_pxDay^.m_xOnTick	  = DayOnTick;
		m_pxNight^.m_xOnEnter	= NightOnEnter;
		m_pxNight^.m_xOnTick		= NightOnTick;

		GetFSM()^.ChangeState(m_pxInit);
	endproc;
/*
	proc bool ElapsedTime(real p_fInterval)
		var real fTime=CTimeMgr.Get().GetSeconds();
		return (fTime-m_fStartTime>p_fInterval);
	endproc;

	proc int GetRealTime()
		var int iTime=(CTimeMgr.Get().GetTime().GetMinute())%10;
		return (iTime);
	endproc;
*/
	proc void InitOnTick(int p_iTime)
/*	  m_fDelay=(Random.GetInt()%40).ToReal();
		if(GetRealTime()<m_iDay)then
			GetFSM()^.ChangeState(m_pxNight);
		elseif(GetRealTime()<m_iNight)then
			GetFSM()^.ChangeState(m_pxDay);
		else
			GetFSM()^.ChangeState(m_pxNight);
		endif;*/
	endproc;

	proc void DayOnEnter(^CState p_pxFrom, ^CState p_pxTo)
/*	  m_fStartTime=CTimeMgr.Get().GetSeconds();
		m_fDelay=(Random.GetInt()%70).ToReal();*/
	endproc;

	proc void DayOnTick(int p_iTime)
/*	  if(m_bLight)then
			if(ElapsedTime(m_fDelay))then
				SetVisible(false);
				m_bLight=false;
				return;
			endif;
		elseif(GetRealTime()>=m_iNight)then
			GetFSM()^.ChangeState(m_pxNight);
		endif;*/
	endproc;

	proc void NightOnEnter(^CState p_pxFrom, ^CState p_pxTo)
/*	  m_fStartTime=CTimeMgr.Get().GetSeconds();
		m_fDelay=(Random.GetInt()%70).ToReal();*/
	endproc;

	proc void NightOnTick(int p_iTime)
/*	  if(!m_bLight)then
			if(ElapsedTime(m_fDelay))then
				SetVisible(true);
				m_bLight=true;
				return;
			endif;
		elseif(GetRealTime()>=m_iDay && GetRealTime()<m_iNight)then
			GetFSM()^.ChangeState(m_pxDay);
		endif;*/
	endproc;

endclass;

class CDefensePoint inherit CGameObj

	constructor()
	endconstructor;

	destructor()
	enddestructor;

	proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			SetType("WYPT");
			SetHitable(false);
			SetSelectable(false);
			SetVisible(false);
		endif;
	endproc;

endclass;

class CColoredBox inherit CGameObj

	constructor()
	endconstructor;

	destructor()
	enddestructor;

	proc void OnInit(bool p_bLoad)
		SetSelectable(true);
		SetHitable(true);
		SetVisible(true);
	endproc;

	export proc void HandleGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams)
		if(p_sCommand=="StartCam")then
//		  SetVisible(false);
//		  SetHitable(false);
			SetSelectable(false);
			SetAnim("schweben",3);
		endif;
	endproc;

endclass;

class CLakeOfDamage inherit CGameObj

	var string	m_sTypes,m_sRegionName;
	var int		m_iDamage;
	const int	TIMER_DAMAGE	=2444;
	var CObjHndl					m_xActor;

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		m_xActor = CObjHndl.Invalid();
		if(!p_bLoad)then
			SetType("DMGL");
			SetHitable(false);
			SetSelectable(false);
			SetVisible(false);
			InitAttribs();
		else
			var ^CAttribs pxA = GetAttribs();
			if(pxA!=null)then
				m_sTypes=pxA^.GetValue("damage_types");
				m_iDamage=pxA^.GetValueInt("damage_per_tick");
				m_sRegionName=pxA^.GetValue("region_name");
			endif;
		endif;
		InitEvents();
		DeleteTimer(TIMER_DAMAGE);
		CreateTimer(TIMER_DAMAGE,CGameTimeSpan.OneSecond()*3.0,true);
	endproc;
	
	proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==TIMER_DAMAGE)then
				Damage();
			endif;
		endif;
	endproc;

	proc void Damage()
		var ^CRegion pxRegion=CSrvWrap.GetRegionMgr().GetRegion(m_sRegionName);
		if(pxRegion==null)then return; endif;
		var CObjList xObjList;
		var int i,iC=pxRegion^.NumObjects();
		for(i=0)cond(i<iC)iter(i++)do
			xObjList.AddEntry(pxRegion^.GetObject(i));
		endfor;
		iC=xObjList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFightingObj pxFighter=cast<CFightingObj>(xObjList[i].GetObj());
			if(pxFighter==null)then continue; endif;
			if(pxFighter^.GetTransportObj().IsValid()||pxFighter^.IsFlyingUnit()||pxFighter^.GetOnWall())then continue; endif;
			if(!m_sTypes.IsEmpty() && m_sTypes.Find(pxFighter^.GetType().AsString())==-1)then continue; endif;
			pxFighter^.TakeDirectMeleeDmg(m_iDamage.ToReal(),m_xActor);
		endfor;
	endproc;

endclass;

class CLakeOfHealing inherit CGameObj

	var string	m_sTypes,m_sRegionName;
	var int		m_iDamage;
	const int	TIMER_DAMAGE	=2444;

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			SetType("DMGL");
			SetHitable(false);
			SetSelectable(false);
			SetVisible(false);
			InitAttribs();
		else
			var ^CAttribs pxA = GetAttribs();
			if(pxA!=null)then
				m_sTypes=pxA^.GetValue("damage_types");
				m_iDamage=pxA^.GetValueInt("damage_per_tick");
				m_sRegionName=pxA^.GetValue("region_name");
			endif;
		endif;
		InitEvents();
		DeleteTimer(TIMER_DAMAGE);
		CreateTimer(TIMER_DAMAGE,CGameTimeSpan.OneSecond()*3.0,true);
	endproc;
	
	proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==TIMER_DAMAGE)then
				Damage();
			endif;
		endif;
	endproc;

	proc void Damage()
		var ^CRegion pxRegion=CSrvWrap.GetRegionMgr().GetRegion(m_sRegionName);
		if(pxRegion==null)then return; endif;
		var CObjList xObjList;
		var int i,iC=pxRegion^.NumObjects();
		for(i=0)cond(i<iC)iter(i++)do
			xObjList.AddEntry(pxRegion^.GetObject(i));
		endfor;
		iC=xObjList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFightingObj pxFighter=cast<CFightingObj>(xObjList[i].GetObj());
			if(pxFighter==null)then continue; endif;
			if(pxFighter^.IsFlyingUnit())then continue; endif;
			if(!m_sTypes.IsEmpty() && m_sTypes.Find(pxFighter^.GetType().AsString())==-1)then continue; endif;
			pxFighter^.HealMe(m_iDamage.ToReal());
		endfor;
	endproc;

endclass;

class CLightObj inherit CGameObj

	var real m_fRange;
	var string m_sDiffuse;
	var string m_sAmbient;
	var string m_sSpecular;
	var real m_fAttenuationConst;
	var real m_fAttenuationLinear;
	var real m_fAttenuationSquared;

	export proc void OnInit(bool p_bLoad)
		if(!p_bLoad)then
			SetType("LGHT");
			SetHitable(false);
			SetSelectable(false);
			var ^CAttribs pxAttribs=InitAttribs();
			if(pxAttribs!=null)then
				/*
				pxAttribs^.SetValue("range",m_fRange.ToString());
				pxAttribs^.SetValue("diffuse",m_sDiffuse);
				pxAttribs^.SetValue("ambient",m_sAmbient);
				pxAttribs^.SetValue("specular",m_sSpecular);
				pxAttribs^.SetValue("attenuation_const",m_fAttenuationConst);
				pxAttribs^.SetValue("attenuation_linear",m_fAttenuationLinear);
				pxAttribs^.SetValue("attenuation_squared",m_fAttenuationSquared);
				*/
				pxAttribs^.SetValue("range",(8.0).ToString());
				pxAttribs^.SetValue("diffuse","239 208 38");
				pxAttribs^.SetValue("ambient","148 48 37");
				pxAttribs^.SetValue("specular","242 238 208");
				pxAttribs^.SetValue("attenuation_const",(0.0).ToString());
				pxAttribs^.SetValue("attenuation_linear",(0.2).ToString());
				pxAttribs^.SetValue("attenuation_squared",(0.0).ToString());
			else
				CSrvWrap.LogError("LightObj","Could not read object attribs!" );
			endif;
		else
			var ^CAttribs pxAttribs=CheckAttribs();
			if(pxAttribs!=null)then
				m_fRange=pxAttribs^.GetValueFloat("range");
				m_sDiffuse=pxAttribs^.GetValue("diffuse");
				m_sAmbient=pxAttribs^.GetValue("ambient");
				m_sSpecular=pxAttribs^.GetValue("specular");
				m_fAttenuationConst=pxAttribs^.GetValueFloat("attenuation_const");
				m_fAttenuationLinear=pxAttribs^.GetValueFloat("attenuation_linear");
				m_fAttenuationSquared=pxAttribs^.GetValueFloat("attenuation_squared");
			else
				CSrvWrap.LogError("LightObj","Could not read object attribs!" );
			endif;
		endif;
	endproc;
	
	proc ^CAttribs CheckAttribs()
		var ^CAttribs pxAttribs=GetAttribs();
		if(pxAttribs==null)then pxAttribs=InitAttribs(); endif;
		if(!pxAttribs^.ContainsKey("range"))then
			pxAttribs^.SetValue("range",m_fRange);
		endif;
		if(!pxAttribs^.ContainsKey("diffuse"))then
			pxAttribs^.SetValue("diffuse",m_sDiffuse);
		endif;
		if(!pxAttribs^.ContainsKey("ambient"))then
			pxAttribs^.SetValue("ambient",m_sAmbient);
		endif;
		if(!pxAttribs^.ContainsKey("specular"))then
			pxAttribs^.SetValue("specular",m_sSpecular);
		endif;
		if(!pxAttribs^.ContainsKey("attenuation_const"))then
			pxAttribs^.SetValue("attenuation_const",m_fAttenuationConst);
		endif;
		if(!pxAttribs^.ContainsKey("attenuation_linear"))then
			pxAttribs^.SetValue("attenuation_linear",m_fAttenuationLinear);
		endif;
		if(!pxAttribs^.ContainsKey("attenuation_squared"))then
			pxAttribs^.SetValue("attenuation_squared",m_fAttenuationSquared);
		endif;
		return pxAttribs;
	endproc;
	
endclass;

class CRallyPoint inherit CGameObj
	
	export proc void OnInit(bool p_bLoad)
		if(!p_bLoad)then
			SetType("RALL");
			SetHitable(false);
			SetSelectable(false);
			SetVisible(true);
		endif;
	endproc;
	
endclass;

class CAtmoSoundObj inherit CGameObj
	
	export proc void OnInit(bool p_bLoad)
		if(!p_bLoad)then
			SetType("ATMO");
			SetHitable(false);
			SetSelectable(false);
			SetVisible(false);
			var ^CAttribs pxAttribs=InitAttribs();
			if(pxAttribs!=null)then
				pxAttribs^.SetValue("volume", 100);
				pxAttribs^.SetValue("pitch", 1.0);
				pxAttribs^.SetValue("minfadedist", 1.0);
				pxAttribs^.SetValue("maxfadedist", 25.0);
				pxAttribs^.SetValue("maxhearingdist", 25.0);
				pxAttribs^.SetValue("flags", 0);
				pxAttribs^.SetValue("innerconeangle", 30);
				pxAttribs^.SetValue("outerconeangle", 45);
				pxAttribs^.SetValue("coneoutsidevolume", 30);
			endif;
		endif;
	endproc;

endclass;

class CEAXEnvironmentObj inherit CGameObj
	
	export proc void OnInit(bool p_bLoad)
		if(!p_bLoad)then
			SetType("EAXE");
			SetHitable(false);
			SetSelectable(false);
			SetVisible(false);
			var ^CAttribs pxAttribs=InitAttribs();
			if(pxAttribs!=null)then
				pxAttribs^.SetValue("environmentname", "generic");
			endif;
		endif;
	endproc;
	
endclass;

class CDecoObj inherit CGameObj
	
	export constructor()
		SetVisInFOW(true);
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		SetType("DECO");
		SetSelectable(false);
		SetHitable(false);
		SetPlaceBlocker(false);
	endproc;
	
endclass;

class CDecoAnimObj inherit CDecoObj
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetAnim("anim",3);
	endproc;
	
endclass;

class CBigCrater inherit CDecoObj

	const int 	TIMER_1=1905;
	const int 	TIMER_2=1906;
	const int 	TIMER_3=1907;

	export constructor()
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		SetType("BCRT");
		InitEvents();
		if(!p_bLoad)then
			CreateTimer(TIMER_1,CGameTimeSpan.OneSecond()*30.0f, false);
			SetRot(Quat.RotationZ(Random.MTRandF(0.0f,Math.Pi()*2.0f)));
			AlignScape();
			SetRndInvMaskSingleFlagInv(6,true);
			SetRndInvMaskSingleFlagInv(7,true);
		else
			//old savegame compatibility, timers were not saved
			if(!HasTimer(TIMER_1)&&!HasTimer(TIMER_1)&&!HasTimer(TIMER_3))then
				Delete();
			endif;
		endif;
	endproc;

	export destructor()
	enddestructor;

	proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==TIMER_1)then
				SetRndInvMaskSingleFlagInv(7,false);
				DeleteTimer(TIMER_1);
				CreateTimer(TIMER_2,CGameTimeSpan.OneSecond()*30.0f, false);
			elseif(p_rxEvtPtr.GetInt(0)==TIMER_2)then
				SetRndInvMaskSingleFlagInv(6,false);
				DeleteTimer(TIMER_2);
				CreateTimer(TIMER_3,CGameTimeSpan.OneSecond()*60.0f, false);
			elseif(p_rxEvtPtr.GetInt(0)==1907)then
				Delete();
			endif;
		endif;
	endproc;

endclass;

class CFX inherit CGameObj

	const int TIMER_CFXE = 3425;

	var CObjHndl	m_xParent;
	var string		m_sFXClass;

	export constructor()
	endconstructor;

	export destructor()
	enddestructor;
	
	proc void OnInit(bool p_bLoad)	
		super.OnInit(p_bLoad);
		InitEvents();
		if(!p_bLoad)then
			SetType("CFXE");
		endif;
	endproc;

	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass() == ms_xTimerClass)then
			var int iTimerID = p_rxEvtPtr.GetInt(0);
			if(iTimerID == TIMER_CFXE)then
				DeleteTimer(TIMER_CFXE);
				var ^CFightingObj pxObj = cast<CFightingObj>(m_xParent.GetObj());
				if(pxObj==null || !pxObj^.RemoveFX(m_sFXClass))then
					Delete();
				endif;
				return;
			endif;
		endif;
		super.HandleEvent(p_rxEvtPtr);
	endproc;

	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CFX] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xType="CFXE";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xParent.DoKArc(pxArc^);
		(pxArc^) << m_sFXClass;
		pxWalk^.Close();
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="CFXE")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			if(p_pxReaderNode^.GetVersion()>=1)then
				m_xParent.DoKArc(pxArc^);
				(pxArc^) << m_sFXClass;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		var string sEffectName = GetName();
		var string sParentName = "Invalid";
		var string sEffectPos = GetPos().ToString();
		if(m_xParent.IsValid())then
			sParentName = m_xParent.GetObj()^.GetName();
		endif;
		var string sMessage ="Effect name='"+sEffectName+"' parent='"+sParentName+"' pos='"+sEffectPos+"'";
		if(!m_xParent.IsValid()&&!CMirageSrvMgr.SkipOrphans())then
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			System.Assert(pxLevel!=null);
			if(pxLevel^.IsEditable())then
				var bool bIgnore=(sEffectName.Find("fx_holy_forest")!=-1);//WT1171
				if(!bIgnore)then
					Windows.DbgPrint("DETECTED orphant effect: "+sMessage);
					if(Windows.MessageBox("Orphant effect detected",sMessage+"\n\n	Delete Object?",050004h)==6)then
						Windows.DbgPrint("DELETED orphant effect: "+sMessage);
						Delete();
						return;
					endif;
				endif;
			endif;
		endif;
	endproc;

	export proc void SetTimer(real p_fTime)
		if(p_fTime > 0.0)then
			DeleteTimer(TIMER_CFXE);
			CreateTimer(TIMER_CFXE, CGameTimeSpan.OneSecond() * p_fTime, true);
		endif;
	endproc;

	export proc void SetFXClass(string p_sFXClass)
		m_sFXClass = p_sFXClass;
	endproc;

	export proc ref string GetFXClass()
		return m_sFXClass;
	endproc;

	export proc void SetParent(CObjHndl p_xParent)
		m_xParent = p_xParent;
	endproc;

	export proc ref CObjHndl GetParent()
		return m_xParent;
	endproc;
	
endclass;

class CSign inherit CGameObj

	const int			UPDATE_TIMER=199;
	const int			TIMER_ID=200;
	var CObjHndl	m_xTarget;

	export constructor()
	endconstructor;

	export destructor()
	enddestructor;

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		InitEvents();
	endproc;

	export proc void SetCountDown(real p_fTime, CObjHndl p_xTarget)
		//Windows.DbgPrint("CountDown("+p_fTime.ToString()+")");
		m_xTarget = p_xTarget;
		CreateTimer(TIMER_ID, CGameTimeSpan.OneSecond() * p_fTime, false);
		CreateTimer(UPDATE_TIMER, CGameTimeSpan.OneSecond() * 0.1, true);
	endproc;

	proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		//Windows.DbgPrint("HandleEvent() CSign");
		if(p_rxEvtPtr.GetClass() == ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0) == TIMER_ID )then
//				Windows.DbgPrint("Delete()");
				DeleteTimer(UPDATE_TIMER);
				Delete();
			elseif( p_rxEvtPtr.GetInt(0) == UPDATE_TIMER )then
				if(m_xTarget.IsValid())then
					SetPos(m_xTarget.GetObj()^.GetPos()+{0.0,0.0,3.0});
				else
					DeleteTimer(UPDATE_TIMER);
					DeleteTimer(TIMER_ID);
					Delete();
				endif;
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;

endclass;

class CColObj inherit CGameObj
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetType("COLL");
		CSrvWrap.GetPathfinder().AddPFBlocker(this);
		SetSelectable(false);
		SetHitable(false);
	endproc;
	
//	export proc void OnInit(bool p_bLoad)
//		super.OnInit(p_bLoad);
//		SetType("COLL");
//		if(!p_bLoad)then
//			CSrvWrap.GetPathfinder().AddPFBlocker(this);
//		else
//			var ^CAttribs pxA=GetAttribs();
////			if(pxA==null)then pxA=InitAttribs(); endif;
//			if(pxA!=null)then
//				var bool bBlock=pxA^.GetValueBool("blocker");
//				if(bBlock)then
//					CSrvWrap.GetPathfinder().AddPFBlocker(this);
//				else
//					CSrvWrap.GetPathfinder().RemPFBlocker(this);
//				endif;
//			else
//				CSrvWrap.GetPathfinder().AddPFBlocker(this);
//			endif;
//		endif;
//		SetSelectable(false);
//		SetHitable(false);
//	endproc;
	
//	export proc void HandleEditorCommand(string p_sCommand,^CGameObj p_pxObject,vec3 p_vPos,string p_sMiscParams)
//		if(p_sCommand=="SetPFBBlocking")then
//			if(CMirageSrvMgr.SDK())then
//				var bool bBlock=p_sMiscParams=="true";
//				var ^CAttribs pxA=GetAttribs();
//				if(pxA==null)then pxA=InitAttribs(); endif;
//				if(pxA!=null)then
//					pxA^.SetValue("blocker",bBlock);
//				endif;
//				if(bBlock)then
//					CSrvWrap.GetPathfinder().AddPFBlocker(this);
//				else
//					CSrvWrap.GetPathfinder().RemPFBlocker(this);
//				endif;
////				CSrvWrap.GetPathfinder().UpdatePFBlocker(pxO);
//			endif;
//		else
//			super.HandleEditorCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams);
//		endif;
//	endproc;
	
endclass;

class CDecoColObj inherit CGameObj
	
	constructor()
		SetVisInFOW(true);
	endconstructor;
	
//	export proc void OnInit(bool p_bLoad)
//		super.OnInit(p_bLoad);
//		SetType("DCCO");
//		CSrvWrap.GetPathfinder().AddPFBlocker(this);
//		SetPlaceBlocker(true);
//		SetSelectable(false);
//		SetHitable(false);
//	endproc;
	
	export proc void OnInit(bool p_bLoad)
		SetPlaceBlocker(false);
		super.OnInit(p_bLoad);
		SetType("DCCO");
		if(!p_bLoad)then
			CSrvWrap.GetPathfinder().AddPFBlocker(this);
			SetPlaceBlocker(true);
		else
			var ^CAttribs pxA=GetAttribs();
//			if(pxA==null)then pxA=InitAttribs(); endif;
			if(pxA!=null)then
				var bool bBlock=pxA^.GetValueBool("blocker");
				if(bBlock)then
					CSrvWrap.GetPathfinder().AddPFBlocker(this);
				else
					CSrvWrap.GetPathfinder().RemPFBlocker(this);
				endif;
				SetPlaceBlocker(bBlock);
			else
				CSrvWrap.GetPathfinder().AddPFBlocker(this);
				SetPlaceBlocker(true);
			endif;
		endif;
		SetSelectable(false);
		SetHitable(false);
//		CMirageSrvMgr.Debug("is "+GetName()+" pf blocking at loading: "+IsPFBlocker().ToString());
	endproc;
	
	export proc void HandleEditorCommand(string p_sCommand,^CGameObj p_pxObject,vec3 p_vPos,string p_sMiscParams)
		if(p_sCommand=="SetPFBBlocking")then
			if(CMirageSrvMgr.SDK())then
				var bool bBlock=p_sMiscParams=="true";
				var ^CAttribs pxA=GetAttribs();
				if(pxA==null)then pxA=InitAttribs(); endif;
				if(pxA!=null)then
					pxA^.SetValue("blocker",bBlock);
				endif;
				if(bBlock)then
					CSrvWrap.GetPathfinder().AddPFBlocker(this);
				else
					CSrvWrap.GetPathfinder().RemPFBlocker(this);
				endif;
				SetPlaceBlocker(bBlock);
			endif;
		else
			super.HandleEditorCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams);
		endif;
	endproc;
	
endclass;

class CDecoColAnimObj inherit CDecoColObj

	constructor()
		SetVisInFOW(true);
	endconstructor;

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetAnim("anim",3);
	endproc;

endclass;

class CSeasHQLavaObj inherit CDecoColObj

	constructor()
		SetVisInFOW(true);
	endconstructor;

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetAnim("seq_anim",0,150);
	endproc;

endclass;

class CAnimObj inherit CGameObj

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetSelectable(false);
		SetHitable(false);
		SetAnim("anim",1);
	endproc;

endclass;

class CUpgradeObj inherit CGameObj

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetVisible(true);
		SetSelectable(false);
		SetHitable(false);
	endproc;

endclass;

class CRegionObj inherit CGameObj

	var string m_sRegionName;

	export constructor()
	endconstructor;

	export destructor()
	enddestructor;

	export proc void OnInit(bool p_bLoad);
		if(!p_bLoad)then
			SetType("ZONE");
			SetSelectable(false);
			SetHitable(false);
			var ^CAttribs pxAttribs=InitAttribs();
			pxAttribs^.SetValue("name",m_sRegionName);
//			Windows.DbgPrint("CRegion: OnInit()--> new");
		else
			var ^CAttribs pxAttribs=CheckAttribs();
			if(pxAttribs!=null)then
				m_sRegionName=pxAttribs^.GetValue("name");
//				Windows.DbgPrint("CRegion: OnInit()--> load");
			else
//				Windows.DbgPrint("ERROR: Could not read object attribs!" );
			endif;
		endif;
	endproc;

	proc ^CAttribs CheckAttribs()
		var ^CAttribs pxAttribs=GetAttribs();
		if(pxAttribs==null)then pxAttribs=InitAttribs();endif;
		if(!pxAttribs^.ContainsKey("name"))then
			pxAttribs^.SetValue("name",m_sRegionName);
		endif;
		return pxAttribs;
	endproc;

	export proc void SetAttrib(string p_sName, string p_sValue)
		if(p_sName=="name")then
			m_sRegionName=p_sValue;
		else
			super.SetAttrib(p_sName,p_sValue);
		endif;
	endproc;

	export proc void SetName(string p_sRegionName)
		if(m_sRegionName==p_sRegionName)then return; endif;
		m_sRegionName=p_sRegionName;
		GetAttribs()^.SetValue("name",m_sRegionName);
	endproc;

	proc void HandleGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams)
//		Windows.DbgPrint("GamePlayCommand: "+p_sCommand+" "+p_vPos.ToString()+" "+p_sMiscParams);
	endproc;
endclass;

class CShowFOWObj inherit CGameObj
	
	const int KILL_TIMER=200;
	
	export proc void OnInit(bool p_bLoad);
		super.OnInit(p_bLoad);
		SetSelectable(false);
		SetHitable(false);
		SetType("OTHR");
		SetVisible(true);
		InitEvents();
	endproc;
	
	export proc void SetFOWRange(real p_fFOW)
		SetFOW(p_fFOW);
	endproc;
	
	export proc void SetKillTimer( real p_fDuration )
		CreateTimer(KILL_TIMER,CGameTimeSpan.OneSecond() * p_fDuration, false);
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass() == ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0) == KILL_TIMER )then
				Delete();
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	export proc void OnActionEnd(bool p_bBroken)
		Delete();
	endproc;
	
endclass;

class CLifeTimeObj inherit CGameObj

	const int KILL_TIMER =200;
	const int CHECK_TIMER =201;
	var CObjHndl m_xParent;

	export proc void OnInit(bool p_bLoad);
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			SetSelectable(false);
			SetHitable(false);
			SetType("OTHR");
			SetVisible(true);
		endif;
		InitEvents();
	endproc;

	export proc void SetKillTimer( real p_fDuration, CObjHndl p_xParent)
		CreateTimer(KILL_TIMER,CGameTimeSpan.OneSecond() * p_fDuration, false);
		if(p_xParent.IsValid())then
			m_xParent=p_xParent;
			CreateTimer(CHECK_TIMER,CGameTimeSpan.OneSecond() * 1.0, true);
		endif;
	endproc;

	proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass() == ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0) == KILL_TIMER )then
				Delete();
			elseif(p_rxEvtPtr.GetInt(0) == CHECK_TIMER )then
				if(!m_xParent.IsValid())then
					DeleteTimer(KILL_TIMER);
					DeleteTimer(CHECK_TIMER);
					Delete();
				endif;
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;

	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CLifeTimeObj] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xType="Life";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xParent.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="Life")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xParent.DoKArc(pxArc^);
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;

endclass;

class CFireWorkObj inherit CShowFOWObj

	const real		FIREWORK_LIFETIME		= 10.0;
	const real		FIREWORK_FOWRANGE		= 200.0;
	const real		SHOW_TIME						= 4.5;
	const int			EXPLODE_TIMER				= 40053;

	export proc void OnInit(bool p_bLoad);
		super.OnInit(p_bLoad);
		SetVisible(true);
		var real fRadius=FIREWORK_FOWRANGE;
		if(CRequirementsMgr.Get().CheckInvention(null, GetOwner(), "monk_range", "Ninigi"))then
			fRadius+=20.0f;
		endif;
		SetFOWRange(fRadius);
		SetAnim("anim",1);
		SetKillTimer(FIREWORK_LIFETIME);
		CreateTimer(EXPLODE_TIMER,CGameTimeSpan.OneSecond() * SHOW_TIME, false);
	endproc;

	proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass() == ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0) == EXPLODE_TIMER)then
				RemoveSmoke();
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;

	export proc void RemoveSmoke()
		var CObjQuery xSearch;
		xSearch.Clear();
		xSearch.SetType("CHTR");
		xSearch.SetType("ANML",true);
		xSearch.SetType("BLDG",true);
		xSearch.SetType("SHIP",true);
		xSearch.SetType("VHCL",true);
		var real fRadius=FIREWORK_FOWRANGE;
		if(CRequirementsMgr.Get().CheckInvention(null, GetOwner(), "monk_range", "Ninigi"))then
			fRadius+=20.0f;
		endif;
		xSearch.RegionCircle(GetPos(), fRadius);
		CSrvWrap.GetDiplomacyMgr().AddMyEnemiesToSearch(GetOwner(), xSearch, false);
		//CSrvWrap.GetDiplomacyMgr().AddMyFriendsToSearch(GetOwner(), xSearch); //Henry: for testing...
		var CObjList xList;
		if(!xSearch.Execute(xList))then return; endif;
		var int i,iC=xList.NumEntries();
		for (i=0) cond (i<xList.NumEntries()) iter (++i)do
			var ^CFightingObj pxObj=cast<CFightingObj>(xList[i].GetObj());
			if(pxObj==null)then continue; endif;
			pxObj^.SetFireworkEffect(true,FIREWORK_LIFETIME);
			if(pxObj^.GetCamouflage()||pxObj^.IsFeignDeath())then
				pxObj^.Reveal();
			endif;
			if(pxObj^.GetEffectFlag(CFightingObj.EFFECT_AJE_CAMOUFLAGE))then
				pxObj^.SetEffectFlag(CFightingObj.EFFECT_AJE_CAMOUFLAGE, false);
			endif;
//			var ^CTrap pxTrap = cast<CTrap>(pxObj);
//			if(pxTrap!=null)then
//				pxTrap^.OnReveal();
//				pxTrap^.StartHiddenTimer(FIREWORK_LIFETIME);
//			endif;
		endfor;
	endproc;

endclass;

class CDummySoundObj inherit CGameObj

	var int m_iStartRandom, m_iEndRandom;
	var string m_sAnim_day;
	var string m_sAnim_night;
	var string m_sAnim;
	var bool m_bNight;
	
	const int TIMER_ID=196;
	const int RANDOM_TIMER=200;

	export proc void OnInit(bool p_bLoad);
		super.OnInit(p_bLoad);
		SetSelectable(false);
		SetHitable(false);
		SetVisible(true);
		SetGFX("Dummy_SoundObj");
		InitEvents();
		SetFOW(0.0);
		var string sName = GetName();
		var array string asTokens;
		sName.Split(asTokens, ";", true);
		if(asTokens.NumEntries()==5)then
			m_iStartRandom = asTokens[1].ToInt();
			m_iEndRandom = asTokens[2].ToInt();
			m_sAnim_day = asTokens[3];
			m_sAnim = asTokens[3];
			m_sAnim_night = asTokens[4];
		else
			m_sAnim = "";
			m_sAnim_day = "";
			m_sAnim_night = "";
			m_iStartRandom = 30;
			m_iEndRandom = 120;
		endif;
		CreateRandomTimer(m_iStartRandom, m_iEndRandom);
		CreateTimer(TIMER_ID,CGameTimeSpan.OneSecond()*15.0f,true);
	endproc;

	export proc void CreateRandomTimer( int p_iStart, int p_iEnd )
		var real fDuration = (Random.GetInt()%(p_iEnd - p_iStart) + p_iStart).ToReal();
		CreateTimer(RANDOM_TIMER,CGameTimeSpan.OneSecond() * fDuration, false);
	endproc;

	proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass() == ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0) == RANDOM_TIMER )then
				if(m_sAnim!="")then
					SetAnim(m_sAnim,1);
				endif;
				CreateRandomTimer(m_iStartRandom, m_iEndRandom);
			elseif(p_rxEvtPtr.GetInt(0)==TIMER_ID)then
				var real fDayTime=(CTimeMgr.Get().GetVirtualTime()/CTimeMgr.Get().GetVirtualDayLength());
				fDayTime-=(fDayTime.ToInt()).ToReal();
				var bool bNight = false;
				//L CSrvWrap.LogInfo("Building","daytime: "+fDayTime.ToString());
				if((fDayTime>CTimeMgr.Get().GetVirtualNightOffset())||(fDayTime<CTimeMgr.Get().GetVirtualDayOffset()))then
					bNight=true;
				endif;
				if(m_bNight != bNight)then
					m_bNight=bNight;
					if(m_bNight && m_sAnim_night!="")then
						m_sAnim = m_sAnim_night;
					elseif(!m_bNight)then
						m_sAnim = m_sAnim_day;
					endif;
				endif;
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;

endclass;

class CFlyingTraderMgr

	export static var CObjHndl ms_xFlyingTrader;

	//Resource prices
	static var real				 ms_fWoodPrice;
	static var real				 ms_fStonePrice;
	static var real				 ms_fIronPrice;
	static var real				 ms_fBonePrice;
	static var real				 ms_fHidePrice;
	static var real				 ms_fResinPrice;

	static var real				 ms_fWoodPriceModifier;
	static var real				 ms_fStonePriceModifier;
	static var real				 ms_fIronPriceModifier;
	static var real				 ms_fBonePriceModifier;
	static var real				 ms_fHidePriceModifier;
	static var real				 ms_fResinPriceModifier;

	static var real				 ms_fMaxPriceRatio;
	static var real				 ms_fMinPriceRatio;

	export static proc void OnInit()
		//Resource prices and modifiers, should come from TT
		ms_fWoodPrice=1.5;
		ms_fStonePrice=2.0;
		ms_fIronPrice=4.0;
		ms_fBonePrice=2.0;
		ms_fHidePrice=2.0;
		ms_fResinPrice=4.0;
		ms_fWoodPriceModifier=0.0f;
		ms_fStonePriceModifier=0.0f;
		ms_fIronPriceModifier=0.0f;
		ms_fBonePriceModifier=0.0f;
		ms_fHidePriceModifier=0.0f;
		ms_fResinPriceModifier=0.0f;
		//Resource price ist capped to ms_fMaxPriceRatio * resource price
		ms_fMaxPriceRatio=10.0f;
		//Resource price ist limited to resource price / ms_fMinPriceRatio
		ms_fMinPriceRatio=0.5f;
	endproc;

	export static proc ^CFlyingTrader GetFlyingTrader()
		if(!ms_xFlyingTrader.IsValid())then
			//Create a FlyingTrade obj.
			var ^CObjMgrHost pxObjMgr=CSrvWrap.GetObjMgr();
			var ^CFlyingTrader pxTrader = cast<CFlyingTrader>(pxObjMgr^.CreateObj( "FlyingTrader", -1, {0.0, 0.0, 0.0}));
			if(pxTrader!=null)then
				ms_xFlyingTrader = pxTrader^.GetHandle();
			else
				ms_xFlyingTrader = CObjHndl.Invalid();
				KLog.LogError("FlyingTraderMgr", "Could not create FlyingTrader obj!");
				return null;
			endif;
		endif;
		return cast<CFlyingTrader>(ms_xFlyingTrader.GetObj());
	endproc;

	//Returns the price of the resource
	export static proc real GetResourcePrice(string p_sType)
		if(p_sType=="food")then
			return(1.0);
		elseif(p_sType=="wood")then
			return(ms_fWoodPrice+ms_fWoodPriceModifier);
		elseif(p_sType=="stone")then
			return(ms_fStonePrice+ms_fStonePriceModifier);
		elseif(p_sType=="iron")then
			return(ms_fIronPrice+ms_fIronPriceModifier);
		elseif(p_sType=="bone")then
			return(ms_fBonePrice+ms_fBonePriceModifier);
		elseif(p_sType=="hide")then
			return(ms_fHidePrice+ms_fHidePriceModifier);
		elseif(p_sType=="resin")then
			return(ms_fResinPrice+ms_fResinPriceModifier);
		endif;
		return(0.0f);
	endproc;

	//Adjusts modifier accoring to the amount of resource traded
	export static proc bool SetResourcePrice(string p_sType,real p_fAmount)
		if(p_fAmount==0.0)then return(false);endif;
		var real fChange=(p_fAmount/1000.0f);
		if(p_sType=="wood")then
			ms_fWoodPriceModifier=ms_fWoodPriceModifier+fChange;
			ms_fWoodPriceModifier=Math.Clamp(ms_fWoodPriceModifier,-(ms_fWoodPrice*ms_fMinPriceRatio),ms_fWoodPrice*ms_fMaxPriceRatio);
		elseif(p_sType=="stone")then
			ms_fStonePriceModifier=ms_fStonePriceModifier+fChange;
			ms_fStonePriceModifier=Math.Clamp(ms_fStonePriceModifier,-(ms_fStonePrice*ms_fMinPriceRatio),ms_fStonePrice*ms_fMaxPriceRatio);
		elseif(p_sType=="iron")then
			ms_fIronPriceModifier=ms_fIronPriceModifier+fChange;
			ms_fIronPriceModifier=Math.Clamp(ms_fIronPriceModifier,-(ms_fIronPrice*ms_fMinPriceRatio),ms_fIronPrice*ms_fMaxPriceRatio);
		elseif(p_sType=="bone")then
			ms_fBonePriceModifier=ms_fBonePriceModifier+fChange;
			ms_fBonePriceModifier=Math.Clamp(ms_fBonePriceModifier,-(ms_fBonePrice*ms_fMinPriceRatio),ms_fBonePrice*ms_fMaxPriceRatio);
		elseif(p_sType=="hide")then
			ms_fHidePriceModifier=ms_fHidePriceModifier+fChange;
			ms_fHidePriceModifier=Math.Clamp(ms_fHidePriceModifier,-(ms_fHidePrice*ms_fMinPriceRatio),ms_fHidePrice*ms_fMaxPriceRatio);
		elseif(p_sType=="resin")then
			ms_fResinPriceModifier=ms_fResinPriceModifier+fChange;
			ms_fResinPriceModifier=Math.Clamp(ms_fResinPriceModifier,-(ms_fResinPrice*ms_fMinPriceRatio),ms_fResinPrice*ms_fMaxPriceRatio);
		endif;
		UpdateAttribs();
		return(true);
	endproc;

	//Called by the deflation timer. Adjusts the modifier ==> 0.0f
	export static proc bool Deflate()
		if(ms_fWoodPriceModifier!=0.0f)then
			if(ms_fWoodPriceModifier>0.0f)then
				ms_fWoodPriceModifier=ms_fWoodPriceModifier-0.01f;
			else
				ms_fWoodPriceModifier=ms_fWoodPriceModifier+0.01f;
			endif;
		endif;
		if(ms_fStonePriceModifier!=0.0f)then
			if(ms_fStonePriceModifier>0.0f)then
				ms_fStonePriceModifier=ms_fStonePriceModifier-0.01f;
			else
				ms_fStonePriceModifier=ms_fStonePriceModifier+0.01f;
			endif;
		endif;
		if(ms_fIronPriceModifier!=0.0f)then
			if(ms_fIronPriceModifier>0.0f)then
				ms_fIronPriceModifier=ms_fIronPriceModifier-0.01f;
			else
				ms_fIronPriceModifier=ms_fIronPriceModifier+0.01f;
			endif;
		endif;
		if(ms_fBonePriceModifier!=0.0f)then
			if(ms_fBonePriceModifier>0.0f)then
				ms_fBonePriceModifier=ms_fBonePriceModifier-0.01f;
			else
				ms_fBonePriceModifier=ms_fBonePriceModifier+0.01f;
			endif;
		endif;
		if(ms_fHidePriceModifier!=0.0f)then
			if(ms_fHidePriceModifier>0.0f)then
				ms_fHidePriceModifier=ms_fHidePriceModifier-0.01f;
			else
				ms_fHidePriceModifier=ms_fHidePriceModifier+0.01f;
			endif;
		endif;
		if(ms_fResinPriceModifier!=0.0f)then
			if(ms_fResinPriceModifier>0.0f)then
				ms_fResinPriceModifier=ms_fResinPriceModifier-0.01f;
			else
				ms_fResinPriceModifier=ms_fResinPriceModifier+0.01f;
			endif;
		endif;
		UpdateAttribs();
		return(true);
	endproc;

	export static proc void UpdateAttribs()
		var ^CLevel pxLevel = CSrvWrap.GetCurLevel();
		if(pxLevel==null)then return; endif;
		var int i, iC = 8;
		for(i=0)cond(i<iC)iter(i++)do
			var ^CPlayer pxPlayer = pxLevel^.GetPlayer(i);
			if(pxPlayer==null)then continue; endif;
			var ^CAttribs pxAttr = pxPlayer^.GetAttribs();
			if(pxAttr==null)then continue; endif;
			pxAttr^.SetValue("wood_price",((100.0 * (ms_fWoodPrice+ms_fWoodPriceModifier))+0.5).ToInt());
			pxAttr^.SetValue("stone_price",((100.0 * (ms_fStonePrice+ms_fStonePriceModifier))+0.5).ToInt());
			pxAttr^.SetValue("iron_price",((100.0 * (ms_fIronPrice+ms_fIronPriceModifier))+0.5).ToInt());
			pxAttr^.SetValue("bone_price",((100.0 * (ms_fBonePrice+ms_fBonePriceModifier))+0.5).ToInt());
			pxAttr^.SetValue("hide_price",((100.0 * (ms_fHidePrice+ms_fHidePriceModifier))+0.5).ToInt());
			pxAttr^.SetValue("resin_price",((100.0 * (ms_fResinPrice+ms_fResinPriceModifier))+0.5).ToInt());
		endfor;
	endproc;

endclass;

class CFlyingTrader inherit CFightingObj
	var CObjList				m_xWarehouses;
	var CObjHndl				m_xCurrentWarehouse;
	var CObjList				m_xPlayerWarehouses;
	var CGameTime				m_xLastTick;
	var int					 m_iCurrentPlayerTarget;
	var int					 m_iLastOwner;
	var array int				m_aiPlayerOrder;

	const int			  		DEFLATION_TIMER=9999;

	export constructor()
		m_aiPlayerOrder=8;
	endconstructor;

	export destructor()
	enddestructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CFlyingTrader] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xType="FlTr";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xWarehouses.DoKArc(pxArc^);
		m_xCurrentWarehouse.DoKArc(pxArc^);
		m_xPlayerWarehouses.DoKArc(pxArc^);
		m_xLastTick.DoKArc(pxArc^);
		(pxArc^) << m_iCurrentPlayerTarget;
		(pxArc^) << m_iLastOwner;
		
		var int i,iC=m_aiPlayerOrder.NumEntries();
		(pxArc^) << iC;
		for(i=0) cond(i<iC) iter(i++)do
			(pxArc^) << m_aiPlayerOrder[i];
		endfor;
		pxWalk^.Close();
		
		xType="FTMg";
		pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		pxArc=^(pxWalk^.GetArc());
		CFlyingTraderMgr.ms_xFlyingTrader.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="FlTr")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xWarehouses.DoKArc(pxArc^);
			m_xCurrentWarehouse.DoKArc(pxArc^);
			m_xPlayerWarehouses.DoKArc(pxArc^);
			m_xLastTick.DoKArc(pxArc^);
			(pxArc^) << m_iCurrentPlayerTarget;
			(pxArc^) << m_iLastOwner;

			var int i,iC;
			(pxArc^) << iC;
			m_aiPlayerOrder=iC;
			for(i=0) cond(i<iC) iter(i++)do
				(pxArc^) << m_aiPlayerOrder[i];
			endfor;
		elseif(p_pxReaderNode^.GetType()=="FTMg")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			CFlyingTraderMgr.ms_xFlyingTrader.DoKArc(pxArc^);
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;

	export proc void HandleGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams)
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("/Walk")>=0)then
				SetVisible(true);
				var ^CFlyingTrade pxTask = cast<CFlyingTrade>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(), "FlyTra"));
				if(pxTask!=null)then
					pxTask^.Init(GetHandle(), p_vPos);
					SetTaskFO(pxTask);
				endif;
			else
				super.HandleGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams);
			endif;
		else
			super.HandleGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams);
		endif;
	endproc;

	export proc void RegisterTradeBuilding(^CBuilding p_pxBuilding)
		if(p_pxBuilding==null)then return; endif;
		//L CSrvWrap.LogSpam("FlyingTrader","Enter: RegisterTradeBuilding()"+p_pxBuilding^.GetName());
		m_xWarehouses.Include(p_pxBuilding^.GetHandle());
	endproc;

	export proc bool DoesCountInUnitLimit()
		return false;
	endproc;

	export proc void DeRegisterTradeBuilding(^CBuilding p_pxBuilding)
		if(p_pxBuilding==null)then return; endif;
		//L CSrvWrap.LogSpam("FlyingTrader","Enter: DeRegisterTradeBuilding()");
		m_xWarehouses.RemEntry(p_pxBuilding^.GetHandle());
	endproc;

	export proc void OnInit(bool p_bLoad);
		//L CSrvWrap.LogSpam("FlyingTrader","Enter: OnInit()");
		//if(p_bLoad)then Delete(); return; endif;
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			SetSelectable(false);
			SetHitable(true);
			InitEvents();
			SetFOW(10.0);
			SetVisInFOW(true); //the trader and fow did not work very well together... change this when fixed.
			m_iCurrentPlayerTarget = -1;
			m_iLastOwner = -1;
			Hide();
			m_xLastTick=CTimeMgr.Get().GetTime();
			m_xCurrentWarehouse = CObjHndl.Invalid();
		endif;
		var ^CFSM pxFSM=GetFSM();
		if(p_bLoad)then
			m_pxIdleState=pxFSM^.FindSubStateRecursive("idle");
		endif;
		if(m_pxIdleState==null)then
			m_pxIdleState=CSrvWrap.GetUSLFactoryMgr().CreateState(pxFSM,"idle");
		endif;
		if(m_pxIdleState!=null)then
			m_pxIdleState^.m_xOnEnter=OnIdleEnter;
			m_pxIdleState^.m_xOnTick=OnIdleTick;
			m_pxIdleState^.m_xOnLeave=OnIdleLeave;
		endif;
		if(m_pxTaskMgr!=null)then
			m_pxTaskMgr^.SetReturnState(m_pxIdleState);
		endif;
		if(pxFSM^.GetCurState()==null)then
			pxFSM^.ChangeState(m_pxIdleState);
		endif;
		var CGameTimeSpan xTS=CGameTimeSpan.OneSecond()*60.0f;
		CreateTimer(DEFLATION_TIMER,xTS,true);
	endproc;

	proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==DEFLATION_TIMER)then
				CFlyingTraderMgr.Deflate();
			endif;
		endif;
		super.HandleEvent(p_rxEvtPtr);
	endproc;

	proc void OnIdleEnter(^CState p_pxFrom, ^CState p_pxTo)
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr != null && pxAttr^.GetValue("CurTask")!="Idle")then
			pxAttr^.SetValue("CurTask","Idle");
		endif;
	endproc;

	proc void StartFlyTask()
		var bool bNewOwner = true;
		if(m_iLastOwner==m_xCurrentWarehouse.GetObj()^.GetOwner())then
			bNewOwner = false;
		endif;
		m_iLastOwner = m_xCurrentWarehouse.GetObj()^.GetOwner();
		var bool bLastWarehouse = false;
		//if(m_xPlayerWarehouses.NumEntries()==0)then
		bLastWarehouse = true;
		//endif;
		SetVisible(true);
		var ^CFlyingTrade pxTask = cast<CFlyingTrade>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(), "FlyTra"));
		if(pxTask!=null)then
			pxTask^.Init(GetHandle(), m_xCurrentWarehouse, bNewOwner, bLastWarehouse);
			SetTaskFO(pxTask);
		endif;
		//Send feedback to player that the trader is on his way...
		//CFeedback.Print("The Flying Trader is on his way to you!", m_iLastOwner);
	endproc;

	proc void OnIdleTick(int p_iTime)
		//L CSrvWrap.LogSpam("FlyingTrader","Enter: OnIdleTick:");
		if(m_iCurrentPlayerTarget==-2)then
			m_iCurrentPlayerTarget=-1;
			m_xLastTick=CTimeMgr.Get().GetTime();
			Hide();
			return;
		endif;
		if(m_xCurrentWarehouse.IsValid())then
			//maybe we were attacked on the way, so try again..
			//L CSrvWrap.LogSpam("FlyingTrader","Trying to reach building again");
			StartFlyTask();
			return;
		endif;
		if(m_iCurrentPlayerTarget<0)then
			//we are away... look if it is time to spawn
			var CGameTime xNow=CTimeMgr.Get().GetTime();
			var real fDiff = (xNow-m_xLastTick).GetSecondsF();
//		  CSrvWrap.LogSpam("FlyingTrader","TimeDiff:"+fDiff.ToString());
			if( fDiff > 10.0)then	//wait a bit here...
				//L CSrvWrap.LogSpam("FlyingTrader","Time to trade");
				m_iCurrentPlayerTarget=0;
				SpawnAtMapEdge();
				var int i;
				for(i=0)cond(i<8)iter(i++)do
					m_aiPlayerOrder[i]=i;
				endfor;
				var int iTemp;
				for(i=0)cond(i<8)iter(i++)do
					var int iRandom = Random.GetInt()%8;
					iTemp = m_aiPlayerOrder[i];
					m_aiPlayerOrder[i]=m_aiPlayerOrder[iRandom];
					m_aiPlayerOrder[iRandom]=iTemp;
				endfor;
//			  for(i=0)cond(i<8)iter(i++)do
//				  CSrvWrap.LogSpam("FlyingTrader","Order:"+m_aiPlayerOrder[i].ToString());
//			  endfor;
			else
				//L CSrvWrap.LogSpam("FlyingTrader","Sleep.");
				return;
			endif;
		endif;
		//check what player to visit or if we should go away...
		if(m_iCurrentPlayerTarget>7)then
			//GoToMapEdge();
			m_iLastOwner=-1;
			Hide();
			m_iCurrentPlayerTarget=-2;
			//L CSrvWrap.LogSpam("FlyingTrader","All visited, go away.");
			return;
		endif;
		if(m_xPlayerWarehouses.NumEntries()>0)then
			//still have places to visit at this player.
			m_xPlayerWarehouses.Validate();
			var int iIndex = m_xPlayerWarehouses.FindNearest(GetPos());
			if(iIndex>=0)then
				m_xCurrentWarehouse = m_xPlayerWarehouses[iIndex];
				//m_xPlayerWarehouses.DeleteEntry(iIndex);
				StartFlyTask();
			endif;
			//if(m_xPlayerWarehouses.NumEntries()==0)then
			m_iCurrentPlayerTarget++;
			//endif;
			return;
		endif;
		m_xWarehouses.Validate();
		//find warehouse that belongs to player.
		while(m_iCurrentPlayerTarget<8)do
			var int i;
			for(i=0)cond(i<m_xWarehouses.NumEntries())iter(i++)do
				var CObjHndl xObj = m_xWarehouses[i];
				if(!xObj.IsValid())then
					//should have been deleted above, but just in case.
					continue;
				endif;
				var ^CGameObj pxObj = xObj.GetObj();
				if( pxObj^.GetOwner()== m_aiPlayerOrder[m_iCurrentPlayerTarget] )then
					var ^CBuilding pxBuilding = cast<CBuilding>(pxObj);
					if(pxBuilding!=null)then
						if(!pxBuilding^.IsBuildMode())then
							m_xPlayerWarehouses.Include(pxObj^.GetHandle());
						endif;
					endif;
				endif;
			endfor;
			if(m_xPlayerWarehouses.NumEntries()==0)then
				m_iCurrentPlayerTarget++;
			else
				break;
			endif;
		endwhile;
	endproc;

	proc void OnIdleLeave(^CState p_pxFrom, ^CState p_pxTo)
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr != null && pxAttr^.GetValue("CurTask")=="Idle")then
			pxAttr^.SetValue("CurTask","");
		endif;
	endproc;

	proc bool IsIdle()
		var ^CFSM pxFSM = GetFSM();
		if(pxFSM!=null)then
			return (pxFSM^.GetCurState()==m_pxIdleState);
		endif;
		return true;
	endproc;

	export proc void WarehouseVisited()
		m_xPlayerWarehouses.Validate();

		var bool bTraded = false;

		var int i;
		for(i=0)cond(i<m_xPlayerWarehouses.NumEntries())iter(i++)do
			var CObjHndl xObj = m_xPlayerWarehouses[i];
			if(!xObj.IsValid())then
				//should have been deleted above, but just in case.
				continue;
			endif;

			var ^CGameObj pxWarehouse = xObj.GetObj();
			if(pxWarehouse==null)then continue; endif;

			var ^CWarehouse pxBuilding = cast<CWarehouse>(pxWarehouse);
			if(pxBuilding!=null)then
				if(pxBuilding^.TraderArrived())then
					bTraded = true;
					//Set LastEventPos
					var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
					if(pxLevel!=null)then
						var ^CPlayer pxPlayer=pxLevel^.GetPlayer(pxBuilding^.GetOwner());
						if(pxPlayer!=null)then
							var ^CAttribs pxAttribs = pxPlayer^.GetAttribs();
							if(pxAttribs==null)then return();endif;
							pxAttribs^.SetValue("lastevent",pxBuilding^.GetPos().ToString());
						endif;
					endif;
				endif;
			else
				CSrvWrap.LogWarning("FlyingTrade","Failed cast to CWarehouse, no trade performed.");
			endif;
		endfor;

		if(bTraded)then
			//CFeedback.Print("Trader visited and resources have been traded.",m_iLastOwner);
		else
			//CFeedback.Print("Trader visited, but there was nothing to trade.",m_iLastOwner);
		endif;

		m_xCurrentWarehouse = CObjHndl.Invalid();
		m_xPlayerWarehouses.Clear();  //only visit one of the warehouses.
	endproc;

	proc void Hide()
		var vec3 vPos = GetRandomMapEdge();
		vPos.SetZ(50.0f);
		SetPos(vPos);
		SetVisible(false);
	endproc;

	proc void SpawnAtMapEdge()
		var vec3 vPos = GetRandomMapEdge();
		vPos.SetZ(50.0f);
		SetPos(vPos);
		SetVisible(true);
	endproc;

	proc void GoToMapEdge()
		var vec3 vMyPos = GetPos();
		var real fHeight = CSrvWrap.GetScapeMgr().GetHeight( vMyPos.GetX(), vMyPos.GetY());
		if((vMyPos.GetZ()-fHeight)<29.0)then //this is just for safety
			vMyPos.SetZ(fHeight+30.0);
			SetPos(vMyPos);
		endif;
		var vec3 vPos = GetRandomMapEdge();
		vPos.SetZ(50.0f);
		//WalkAction(vPos, 3, false, false);
	endproc;

	proc vec3 GetRandomMapEdge()
		var real fHeight = CSrvWrap.GetScapeMgr().GetMapHeight().ToReal();
		var real fWidth = CSrvWrap.GetScapeMgr().GetMapWidth().ToReal();

		var int iRandom = Random.GetInt()%4;
		if(iRandom==0)then
			var vec3 vPos;
			vPos.SetXYZ(0.0, Random.MTRandF(0.0, fHeight), 0.0);
			return vPos;
		elseif(iRandom==1)then
			var vec3 vPos;
			vPos.SetXYZ(fWidth, Random.MTRandF(0.0, fHeight), 0.0);
			return vPos;
		elseif(iRandom==2)then
			var vec3 vPos;
			vPos.SetXYZ(Random.MTRandF(0.0, fWidth), 0.0, 0.0);
			return vPos;
		else
			var vec3 vPos;
			vPos.SetXYZ(Random.MTRandF(0.0, fWidth), fHeight, 0.0);
			return vPos;
		endif;
	endproc;

endclass;

class CInsectsObj inherit CGameObj
	
	const int					START_TIMER=201;
	const int					EAT_TIMER=200;
	var int						m_iEatCount;
	var CObjHndl			m_xOwner;
	var CObjHndl			m_xTarget;
	var CGameTimeSpan	m_xTime;
	var CGameTime			m_xStartTime;
	var bool					m_bIllusion;
	var bool					m_bFood;
	var bool					m_bWood;
	
	constructor()
		m_bIllusion=false;
	endconstructor;
	
	destructor()
	enddestructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CInsectsObj] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		if(!CMirageSrvMgr.SDK())then
			var CFourCC xType="InOb";
			var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
			var ^CArc pxArc=^(pxWalk^.GetArc());
			pxArc^ << m_iEatCount;
			pxArc^ << m_bFood;
			pxArc^ << m_bWood;
			pxArc^ << m_bIllusion;
			m_xOwner.DoKArc(pxArc^);
			m_xTarget.DoKArc(pxArc^);
			m_xStartTime.DoKArc(pxArc^);
			pxWalk^.Close();
		endif;
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="InOb")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			pxArc^ << m_iEatCount;
			pxArc^ << m_bFood;
			pxArc^ << m_bWood;
			pxArc^ << m_bIllusion;
			m_xOwner.DoKArc(pxArc^);
			m_xTarget.DoKArc(pxArc^);
			m_xStartTime.DoKArc(pxArc^);
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	proc void OnActionStart()
		//L CSrvWrap.LogInfo("Arrow",GetName()+" CArrow: Zisch. Losgeflogen!");
	endproc;
	
	proc void OnActionEnd(bool p_bBroken)
		if(m_xTarget.IsValid()&&!m_bIllusion)then
			//TODO: Insert effect/animation
			m_xStartTime = CTimeMgr.Get().GetTime();
			CreateTimer(EAT_TIMER, CGameTimeSpan.OneSecond() * 1.0, true);
			SetGfxNew();
		else
			Delete();
		endif;
	endproc;
	
	proc void SetGfxNew()
		SetGFX("Hu_Insects");
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		CheckEvents();
		if(!p_bLoad)then
			SetType("PROD");
		else
		endif;
		SetHitable(false);
		SetSelectable(false);
		SetVisible(false);
	endproc;
	
	proc ^CGameEvtQueue CheckEvents()
		var ^CGameEvtQueue pxQueue=GetEvents();
		if(pxQueue==null)then
			pxQueue=InitEvents();
		endif;
		return pxQueue;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass() == ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0) == START_TIMER )then
				Shoot();
			elseif(p_rxEvtPtr.GetInt(0) == EAT_TIMER )then
				if(!Eat())then
					Delete();
				endif;
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	export proc void Set(CObjHndl p_xTarget, CGameTimeSpan p_xTime, int p_iEatCount,CObjHndl p_xOwner, bool p_bIllusion, int p_iType)
		SetGFX("WoodLog");
		m_xTarget = p_xTarget;
		m_xOwner=p_xOwner;
		m_xTime = p_xTime;
		m_iEatCount = p_iEatCount;
		m_bIllusion=p_bIllusion;
		switch (p_iType)
			case(0)do m_bFood=true; endcase;
			case(1)do m_bWood=true; endcase;
			case(2)do m_bFood=true; m_bWood=true; endcase;
			case default do  m_bFood=true; m_bWood=true; endcase;
		endswitch;
		CreateTimer(START_TIMER, CGameTimeSpan.OneSecond() * 1.0, false);
	endproc;
	
	export proc void Shoot()
		SetVisible(true);
		if(HasTimer(START_TIMER))then DeleteTimer(START_TIMER);endif;
		if(m_xTarget.IsValid())then
			BallisticAction(m_xTarget.GetObj()^.GetPos(),20.0,3.0);
			if(!HasAction())then
				Delete();
			endif;
		else
			Delete();
		endif;
	endproc;
	
	proc bool Eat()
		var CGameTime xNow = CTimeMgr.Get().GetTime();
		if((xNow - m_xStartTime) > m_xTime)then
			return false;
		endif;
		if(!m_xTarget.IsValid())then
			return false;
		endif;
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel==null)then return false; endif;
		var ^CPlayer pxPlayer = pxLevel^.GetPlayer(GetOwner());
		if(pxPlayer==null)then return false; endif;
		var ^CAttribs pxAttr = pxPlayer^.GetAttribs();
		if(pxAttr==null)then return false; endif;
		var int iValue, iEaten;
		if(m_bFood)then
			iValue = pxAttr^.GetValueInt("food");
			iValue = Math.Max((iValue-m_iEatCount),0);
			iEaten = iValue;
			pxAttr^.SetValue("food",iValue);
		endif;
		if(m_bWood)then
			iValue = pxAttr^.GetValueInt("wood");
			iValue = Math.Max((iValue-m_iEatCount),0);
			iEaten += iValue;
			pxAttr^.SetValue("wood",iValue);
		endif;
		if(iEaten==0)then
			return false;
		endif;
		CheckAttackMessage();
		return true;
	endproc;
	
	proc void CheckAttackMessage()
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		var ^CGameObj pxEnemy=m_xOwner.GetObj();
		var ^CGameObj pxTarget=m_xTarget.GetObj();
		if(pxEnemy!=null && pxTarget!=null &&pxLevel != null)then
			var ^CPlayer pxPlayer = pxLevel^.GetPlayer(pxTarget^.GetOwner());
			if(pxPlayer != null)then
				var ^CBasePlayer pxBasePlayer = cast<CBasePlayer>(pxPlayer);
				if(pxBasePlayer != null)then
					pxBasePlayer^.IWasAttacked(pxTarget^.GetHandle(), pxEnemy^.GetHandle(), true);
				endif;
			endif;
		endif;
	endproc;
	
endclass;

class CTermitesObj inherit CInsectsObj
	
	var int m_iTermitesOwner;
	
	proc void SetGfxNew()
		SetGFX("Aje_Termites");
	endproc;
	
	export proc void Set(CObjHndl p_xTarget, CGameTimeSpan p_xTime, int p_iEatCount,CObjHndl p_xOwner, bool p_bIllusion, int p_iType)
		super.Set(p_xTarget,p_xTime,p_iEatCount,p_xOwner,p_bIllusion,p_iType);
		m_iTermitesOwner=-1;
		var ^CGameObj pxOwner=m_xOwner.GetObj();
		if(pxOwner!=null)then
			m_iTermitesOwner=pxOwner^.GetOwner();
		endif;
	endproc;
	
	proc bool Eat()
		var CGameTime xNow = CTimeMgr.Get().GetTime();
		if((xNow - m_xStartTime) > m_xTime)then
			return false;
		endif;
		var ^CBuilding pxBuilding = cast<CBuilding>(m_xTarget.GetObj());
		if(pxBuilding==null)then
			return false;
		endif;
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel==null)then return false; endif;
		var ^CPlayer pxPlayer = pxLevel^.GetPlayer(GetOwner());
		if(pxPlayer==null)then return false; endif;
		pxBuilding^.TakeDirectMeleeDmg(m_iEatCount.ToReal(),m_iTermitesOwner,m_xOwner);
		CheckAttackMessage();
		return true;
	endproc;
	
endclass;
	
class CTornadoObj inherit CGameObj
	
	const int					RAGE_TIMER=201;
	var CRegionSink		m_xSink;
	var CGuid					m_xRegionGuid;
	var CObjList			m_xRegionObjects;
	
	//START TUNING VALUES
	const real				RANGE =12.0;
	const real				TIME =10.0;
	const real				PRC_DAMAGE =0.50;
	const real				PRC_DAMAGE_BLDG =0.25;
	const real				MIN_DAMAGE =300.0;
	const real				MAX_DAMAGE =2000.0;
	//END TUNING VALUES
	
	var vec3					m_vTarget;
	var CObjHndl			m_xActor;
	var CObjList			m_xMovableTargets;
	var CObjList			m_xNonMovableTargets;
	var CGameTimeSpan	m_xTime;
	var CGameTime			m_xStartTime;
	
	export constructor()
		m_xSink.m_xOnObjAdd=OnObjAdd;
		m_xSink.m_xOnObjRem=OnObjRem;
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		InitEvents();
		if(!p_bLoad)then
			var vec3 vDimension;
			vDimension.SetXYZ(RANGE, RANGE, 0.0);
			CreateOwnRegion("WhirlRadius_"+GetName()+"_"+Random.GetInt().ToString(), vDimension, 010b);
//		else
		endif;
		SetHitable(false);
		SetSelectable(false);
		SetVisible(true);
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CTornadoObj] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		if(!CMirageSrvMgr.SDK())then
			var CFourCC xType="Trnd";
			var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
			var ^CArc pxArc=^(pxWalk^.GetArc());
			pxArc^ << m_xRegionGuid;
			m_xRegionObjects.DoKArc(pxArc^);
			pxWalk^.Close();
		endif;
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="Trnd")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			pxArc^ << m_xRegionGuid;
			m_xRegionObjects.DoKArc(pxArc^);
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		if(!m_xRegionGuid.IsNull())then
			var int iIdx = CSrvWrap.GetRegionMgr().FindRegion(m_xRegionGuid);
			if(iIdx>=0)then
				var ^CRegion pxRegion = CSrvWrap.GetRegionMgr().GetRegion(iIdx);
				if(pxRegion!=null)then
					m_xSink.SetRegion(pxRegion);
					pxRegion^.BindToObj(GetHandle());
					m_xSink.Subscribe();
				endif;
			else
				Delete();
			endif;
		endif;
	endproc;
	
	export proc void Set(vec3 p_vTarget, CObjHndl p_xActor)
		m_vTarget = p_vTarget;
		m_xActor = p_xActor;
		m_xTime = TIME;
		m_xStartTime = CTimeMgr.Get().GetTime();
//		m_xMovableTargets.Clear();
		m_xNonMovableTargets.Clear();
		var CObjList xList;
		if(GetOwner()>=0)then
//			var ^CObjList pxEnemies=CSrvWrap.GetObjMgr()^.GetOwnerEnemyList(GetOwner());
//			if(pxEnemies==null)then return; endif;
//			pxEnemies^.CopySorted(xList, p_vTarget, RANGE+20.0);
			var CObjQuery xQuery;
			xQuery.SetOwner(-1, true);
//			xQuery.SetOwner(-1);
			xQuery.SetType("CHTR");
			xQuery.SetType("SHIP",true);
			xQuery.SetType("ANML",true);
			xQuery.SetType("VHCL",true);
			xQuery.SetType("BLDG",true);
			xQuery.SetType("FGHT",true);
			xQuery.SetType("NEST",true);
			xQuery.SetVisibility(-1, false);
			xQuery.RegionCircle(p_vTarget, RANGE+18.0);
			xQuery.Execute(xList);
			var CObjList xQueryList;
//			if(!xQuery.Execute(xQueryList))then
			if(xQuery.Execute(xQueryList))then
				xList.Include(xQueryList);
			endif;
			var int i, iC;
			iC = xList.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				if(!xList[i].IsValid())then continue; endif;
				var ^CFightingObj pxFight = cast<CFightingObj>(xList[i].GetObj());
				if(pxFight==null)then continue; endif;
				var real fDistance=(pxFight^.GetPos()-GetPos()).Abs2();
				fDistance-=pxFight^.GetCollisionRadius();
				if(fDistance>RANGE)then continue; endif;
//				if(pxFight^.IsAbleToWalk())then
				if(pxFight^.GetType()!="BLDG")then
//					m_xMovableTargets.Include(xList[i]);
//					pxFight^.SetTrappedHandle(GetHandle());
				else
					m_xNonMovableTargets.Include(xList[i]);
					pxFight^.SetTrappedHandle(GetHandle());
				endif;
			endfor;
		endif;
		SetAnim("swirl",3);
		Swirl();
		CreateTimer(RAGE_TIMER, CGameTimeSpan.OneSecond() * 1.0, true);
	endproc;

	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass() == ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0) == RAGE_TIMER )then
				if(!Swirl())then
					DeleteTimer(RAGE_TIMER);
					DeleteOwnRegion();
					FreeVictims();
					Delete();
				endif;
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;

	proc void FreeVictims()
//		var CObjHndl xInvalid = CObjHndl.Invalid();
		var int i, iC = m_xMovableTargets.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFightingObj pxFight = cast<CFightingObj>(m_xMovableTargets[i].GetObj());
			if(pxFight!=null)then
				pxFight^.UntrapHandle(GetHandle());
			endif;
		endfor;
		m_xNonMovableTargets.Validate();
		iC = m_xNonMovableTargets.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFightingObj pxFight = cast<CFightingObj>(m_xNonMovableTargets[i].GetObj());
			if(pxFight!=null)then
				pxFight^.UntrapHandle(GetHandle());
			endif;
		endfor;
	endproc;

	proc bool Swirl()
		var int iOwner=GetOwner();
		var CGameTime xNow = CTimeMgr.Get().GetTime();
		if((xNow - m_xStartTime) > m_xTime)then
			return false;
		endif;
		var real fALLDmg=(PRC_DAMAGE/m_xTime.GetSecondsF());
		var real fBLDGDmg=(PRC_DAMAGE_BLDG/m_xTime.GetSecondsF());
		var real fMinDmg=MIN_DAMAGE/m_xTime.GetSecondsF();
		var real fMaxDmg=MAX_DAMAGE/m_xTime.GetSecondsF();
//		var ^CRegion pxRegion=CSrvWrap.GetRegionMgr().GetRegionByGuid(m_xRegionGuid);
//		if(pxRegion==null)then return false; endif;
//		var CObjList xObjList;
//		var int i,iC=pxRegion^.NumObjects();
//		for(i=0)cond(i<iC)iter(i++)do
//			xObjList.AddEntry(pxRegion^.GetObject(i));
//		endfor;
//		xObjList.Validate();
		var CObjList xObjList=m_xRegionObjects;
		var int i,iC=xObjList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFightingObj pxFighter=cast<CFightingObj>(xObjList[i].GetObj());
			if(pxFighter==null)then continue; endif;
			if(pxFighter^.GetTornado().IsValid())then
				if(!(pxFighter^.GetTornado()==GetHandle()))then continue; endif;
			else
				pxFighter^.SetTornado(GetHandle());
			endif;
			var int iID = pxFighter^.GetOwner();
//			if(iID==iOwner || CSrvWrap.GetDiplomacyMgr().GetIsFriend(iID, iOwner))then continue; endif;
			if(pxFighter^.GetTransportObj().IsValid())then continue; endif;
			var string sType = pxFighter^.GetType().AsString();
			var real fDmg;
			if(sType=="BLDG")then
				fDmg=Math.Clamp(pxFighter^.GetHitpoints()*fBLDGDmg,fMinDmg,fMaxDmg);
			elseif(sType=="ANML"||sType=="CHTR"||sType=="FGHT"||sType=="NEST"||sType=="SHIP"||sType=="VHCL")then
				fDmg=Math.Clamp(pxFighter^.GetHitpoints()*fALLDmg,fMinDmg,fMaxDmg);
			endif;
			pxFighter^.TakeDirectMeleeDmg(fDmg,iOwner,m_xActor);
		endfor;
//		var int i, iC = m_xMovableTargets.NumEntries();
//		for(i=0)cond(i<iC)iter(i++)do
//			var ^CFightingObj pxFight = cast<CFightingObj>(m_xMovableTargets[i].GetObj());
//			if(pxFight!=null)then
//				var real fDmg=Math.Clamp(pxFight^.GetHitpoints()*fALLDmg,fMinDmg,fMaxDmg);
//				pxFight^.TakeDirectMeleeDmg(fDmg,iOwner,m_xActor);
//			endif;
//		endfor;
//		iC = m_xNonMovableTargets.NumEntries();
//		for(i=0)cond(i<iC)iter(i++)do
//			var ^CFightingObj pxFight = cast<CFightingObj>(m_xNonMovableTargets[i].GetObj());
//			if(pxFight!=null)then
//				var real fDmg=Math.Clamp(pxFight^.GetHitpoints()*fBLDGDmg,fMinDmg,fMaxDmg);
//				pxFight^.TakeDirectMeleeDmg(fDmg,iOwner,m_xActor);
//			endif;
//		endfor;
		return true;
	endproc;
	
	proc void CreateOwnRegion(string p_sRegionClass, vec3 p_vDimension, bitset p_dwType)
		var ^CRegionMgr pxRM = ^(CSrvWrap.GetRegionMgr());
		if(pxRM!=null)then
			var int iIdx = pxRM^.CreateRegion(p_sRegionClass, p_dwType, GetPos(), p_vDimension);
			if(iIdx >= 0)then
				var ^CRegion pxRegion = pxRM^.GetRegion(iIdx);
				if(pxRegion!=null)then
					m_xRegionGuid = pxRegion^.GetGUID();
					m_xSink.SetRegion(pxRegion);
					pxRegion^.BindToObj(GetHandle());
					m_xSink.Subscribe();
				else
					pxRM^.DeleteRegion(iIdx);
					Delete();
				endif;
			endif;
		endif;
	endproc;
	
	proc void DeleteOwnRegion()
		if(!m_xRegionGuid.IsNull())then
			var ^CRegionMgr pxRM = ^(CSrvWrap.GetRegionMgr());
			if(pxRM!=null)then
				var int iIdx = CSrvWrap.GetRegionMgr().FindRegion(m_xRegionGuid);
				if(iIdx >= 0)then
					var ^CRegion pxRegion = pxRM^.GetRegion(iIdx);
					m_xSink.Unsubscribe();
					if(pxRegion!=null)then
						pxRegion^.Unbind();
					endif;
					m_xSink.DeleteRegion();
//					pxRM^.DeleteRegion(iIdx);
					var CGuid xNew;
					m_xRegionGuid = xNew;
				endif;
			endif;
		endif;
	endproc;
	
	proc bool OnObjAdd(CObjHndl p_xHndl)
		var ^CGameObj pxO = p_xHndl.GetObj();
		if(pxO==null)then return false; endif;
//		if(pxO^.GetOwner()==GetOwner())then return false; endif;
//		if(CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxO^.GetOwner(), GetOwner())&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxO^.GetOwner()))then return false; endif;
		var ^CFightingObj pxFighter=cast<CFightingObj>(pxO);
		if(pxFighter!=null&&!pxFighter^.GetTornado().IsValid())then
			pxFighter^.SetTornado(GetHandle());
		endif;
		m_xRegionObjects.Include(p_xHndl);
		return true;
	endproc;
	
	proc bool OnObjRem(CObjHndl p_xHndl)
		if(m_xRegionObjects.FindEntry(p_xHndl)==-1)then return false; endif;
		m_xRegionObjects.RemEntry(p_xHndl);
		var ^CFightingObj pxFighter=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxFighter!=null&&pxFighter^.GetTornado().IsValid()&&pxFighter^.GetTornado()==GetHandle())then
			pxFighter^.SetTornado(CObjHndl.Invalid());
		endif;
		return true;
	endproc;
	
endclass;

class CUniversalCorpse inherit CGameObj

	class CSource
		
		export var string		m_sClass;
		export var int			m_iLevel;
		export var CFourCC	m_xType;
		export var int			m_iMaxHP;

		export constructor()
		endconstructor;
		
		export destructor()
		enddestructor;
		
		export proc ref CUniversalCorpse.CSource op_Assign( ^CGameObj p_pxOther )
			if(p_pxOther!=null)then
				m_sClass = p_pxOther^.GetClassName();
				var ^CAttribs pxAttr = p_pxOther^.GetAttribs();
				if(pxAttr!=null)then
					m_iLevel = pxAttr^.GetValueInt("level");
					m_xType = p_pxOther^.GetType();
					m_iMaxHP = pxAttr^.GetValueInt("maxhitpoints");
				endif;
			endif;
			return this^;
		endproc;
		
		export proc void DoKArc(ref CArc p_rxArc)
			var int iVersion=1;
			p_rxArc << iVersion;
			p_rxArc << m_sClass;
			p_rxArc << m_iLevel;
			
			var string sType=m_xType.AsString();
			p_rxArc << sType;
			m_xType=sType;
			
			p_rxArc << m_iMaxHP;
		endproc;
		
	endclass;

	export const int										TIMER_DELETE=123;
	var string													m_sAnim;
	var int															m_iPlayMode;
	var array CUniversalCorpse.CSource	m_axSources;
	var int															m_iOrgMaxHP;
	var CObjHndl												m_xFood;
	var int															m_iHPPercent;

	export constructor()
		SetHitable(true);
		SetSelectable(false);
		m_iPlayMode = 1;
		m_iHPPercent=100;
	endconstructor;

	export destructor()
	enddestructor;

	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CUniversalCorpse] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xBase="UCor";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,3);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		// version 3
		var int i,iC=m_axSources.NumEntries();
		pxArc^ << iC;
		for(i=0)cond(i<iC)iter(i++)do
			m_axSources[i].DoKArc(pxArc^);
		endfor;
		// version 3
		pxWalk^.Close();
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="UCor")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			if(iVersion==1)then
				var bool bAutoRespawn;
				pxArc^ << bAutoRespawn;
				var int i,iC=m_axSources.NumEntries();
				pxArc^ << iC;
				m_axSources=iC;
				for(i=0)cond(i<iC)iter(i++)do
					m_axSources[i].DoKArc(pxArc^);
				endfor;
			endif;
			if(iVersion==2)then
				var bool bAutoRespawn;
				pxArc^ << bAutoRespawn;
				var int i,iC=m_axSources.NumEntries();
				pxArc^ << iC;
				m_axSources=iC;
				for(i=0)cond(i<iC)iter(i++)do
					m_axSources[i].DoKArc(pxArc^);
				endfor;
				var CObjHndl xPyCO;
				xPyCO.DoKArc(pxArc^);
			endif;
			if(iVersion>=3)then
				var int i,iC=m_axSources.NumEntries();
				pxArc^ << iC;
				m_axSources=iC;
				for(i=0)cond(i<iC)iter(i++)do
					m_axSources[i].DoKArc(pxArc^);
				endfor;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		if(!p_bLoad)then
			SetDynamicBBox(true);
			SetType("OTHR");
			InitAttribs();
		endif;
		super.OnInit(p_bLoad);
		InitEvents();
	endproc;
	
	export proc void SetHPPercent(int p_iPercent)
		m_iHPPercent = p_iPercent;
	endproc;
	
	export proc void SetFoodObj(CObjHndl p_xFood)
		m_xFood = p_xFood;
	endproc;
	
	export proc void SetSource(^CGameObj p_pxSource)
		var CUniversalCorpse.CSource xSource = p_pxSource;
		begin SetLevelAttrib;
			var ^CAttribs pxAttribs = GetAttribs();
			if(pxAttribs!=null)then
				pxAttribs^.SetValue("level",xSource.m_iLevel);
				pxAttribs^.SetValue("class",xSource.m_sClass);
			endif;
		end SetLevelAttrib;
		m_axSources.AddEntry(xSource);
	endproc;
	
	export proc string GetSourceClass()
		if(m_axSources.NumEntries()>0)then
			return m_axSources[0].m_sClass;
		endif;
		return "";
	endproc;

	export proc void SetDieAnim(string p_sAnim, bool p_bPlayAnim)
		m_sAnim = p_sAnim;
		if(p_bPlayAnim)then
			m_iPlayMode = 1;
		else
			m_iPlayMode = 0;
		endif;
	endproc;

	export proc void Init(string p_sGfx, string p_sName, real p_fDuration)
		SetGFX(p_sGfx);
		SetName(p_sName);
		InvokeGenericSCEvent(40,4.0);
		PlayAnim(m_iPlayMode);
		if(p_fDuration>0.0)then
			CreateTimer(TIMER_DELETE, CGameTimeSpan.OneSecond()*p_fDuration,false);
		endif;
	endproc;

	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass() == ms_xTimerClass)then
			var int iTimerID = p_rxEvtPtr.GetInt(0);
			if(iTimerID == TIMER_DELETE)then
				Delete();
			endif;
		endif;
	endproc;

	proc void PlayAnim(int p_iMode)
	endproc;

	export proc int GetLevel()
		var int i, iC = m_axSources.NumEntries();
		var int iMaxLevel = 0;
		for(i=0)cond(i<iC)iter(i++)do
			if(m_axSources[i].m_iLevel > iMaxLevel)then
				iMaxLevel = m_axSources[i].m_iLevel;
			endif;
		endfor;
		return iMaxLevel;
	endproc;

endclass;

class CTrainingDummy inherit CGameObj
	
	var CObjHndl m_xBuilding;
	
	destructor()
		if(m_xBuilding.IsValid())then
			m_xBuilding.GetObj()^.SetSLEAnim("work_finished",1,false,true);
		endif;
	enddestructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetSelectable(false);
		SetHitable(false);
		if(GetClassName()=="NewTDummyANML")then
			SetType("ANTD");
			var ^CAttribs pxAttribs=InitAttribs();
			var real fT=CTimeMgr.Get().GetVirtualTime();
			pxAttribs^.SetValue("birth_time",fT);
			pxAttribs^.SetValue("die_time",fT);
			pxAttribs^.SetValue("growup_duration",1.0f);
			SetRndInvMask(CFightingObj.VIS_FLAG_ANML_PLAYER_ALL|CFightingObj.VIS_FLAG_ANML_WOUND_ALL);
		endif;
	endproc;
	
	export proc void StartTraining(string p_sGFX)
		StartTraining(p_sGFX,"farm_anim_1");
	endproc;
	
	export proc void StartTraining(string p_sGFX, real p_fHeight)
		StartTraining(p_sGFX,"farm_anim_1");
	endproc;
	
	export proc void StartTraining(string p_sGFX,string p_sAnim)
		SetGFX(p_sGFX);
		AnimAction(p_sAnim);
	endproc;
	
	export proc void AddParams(int p_iType, string p_sAnim, vec3 p_vPos, real p_fRot, real p_fSpeed, int p_iLoopes)
	endproc;
	
	export proc void OnActionEnd(bool p_bBroken)
		Delete();
	endproc;
	
	export proc void SetBuilding(CObjHndl p_xBldg)
		m_xBuilding=p_xBldg;
	endproc;
	
endclass;

class CFountain inherit CGameObj

	class CHealRequest //obsolete
		
		export proc void DoKArc(^CArc p_pxArc)
			var bool bInvalid;
			p_pxArc^ << bInvalid;
			var int iInvalid;
			p_pxArc^ << iInvalid;
			var CObjHndl xInvalid;
			xInvalid.DoKArc(p_pxArc^);
			var CObjList xInvalidList;
			xInvalidList.DoKArc(p_pxArc^);
		endproc;
		
	endclass;

	var real m_fRefillDuration;
	var int m_iMaxHealAmount;
	var CGameTime m_xAvailable;
	var bool m_bDefFirstInit;

	const int REFILL_TIMER=911;
	var CGameTime m_xLastRefillTick;
	var real m_fFillState;
	
	export constructor()
		m_xAvailable = CGameTime.GetInvalidTime();
		m_bDefFirstInit=false;
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		if(!p_bLoad)then
			SetType("FNTN");
			InitAttribs();
			SetSelectable(true);
			SetHitable(true);
		else
			var ^CAttribs pxA = GetAttribs();
			if(pxA!=null)then
				m_iMaxHealAmount=pxA^.GetValueInt("maxhitpoints");
				m_fRefillDuration=pxA^.GetValueInt("refill_dur").ToReal();
				m_fFillState=pxA^.GetValueInt("hitpoints").ToReal();
			endif;
			if(!m_bDefFirstInit)then
				if(!CMirageSrvMgr.SDK())then
					m_bDefFirstInit=true;
				endif;
				if(m_bDefFirstInit&&CSrvWrap.GetGame().GetType()==2&&GetOwner()!=-1)then
					var int iTempO=GetOwner();
					var ^CBasePlayer pxOwner=CBasePlayer.GetPlayer(iTempO);
					if(pxOwner==null)then
						var ^CLevelInfoHost pxLevelInfo=^(CSrvWrap.GetCurLevel()^.GetLevelInfo());
						var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
						var ^CPropDB.CNode pxTeams=pxGenericDB^.FindNode("ClientSettings/DefendTeams",false);
						if(pxTeams!=null)then
							var array string asTeams;
							var array int aiDefenders;
							var string sTeams=pxTeams^.Value();
							if(sTeams!="")then
								sTeams.Split(asTeams,":",true);
								var int j, jC=Math.Clamp(asTeams.NumEntries(),1,8);
								for(j=0)cond(j<jC)iter(j++)do
									if(Math.Clamp(asTeams[j].ToInt(),1,2)==1)then
										aiDefenders.AddEntry(j);
									endif;
								endfor;
								if(aiDefenders.FindEntry(iTempO)!=-1)then
									jC=aiDefenders.NumEntries();
									for(j=0)cond(j<jC)iter(j++)do
										if(aiDefenders[j]!=iTempO)then
											pxOwner=CBasePlayer.GetPlayer(aiDefenders[j]);
											if(pxOwner!=null)then
												SetOwner(aiDefenders[j]);
												break;
											endif;
										endif;
									endfor;
								endif;
							endif;
						endif;
					endif;
				endif;
			endif;
		endif;
		InitEvents();
		SetAnim("base_anim",3);
	endproc;
	
	export proc real GetRefillDuration()
		return m_fRefillDuration;
	endproc;
	
	export proc int GetMaxHealAmount()
		return m_iMaxHealAmount;
	endproc;
	
	export proc void SetRefillDuration(real p_fRefillDur)
		m_fRefillDuration = p_fRefillDur;
		var ^CAttribs pxA = GetAttribs();
		if(pxA!=null)then
			pxA^.SetValue("refill_dur", m_fRefillDuration);
		endif;
	endproc;
	
	export proc void SetMaxHealAmount(int p_iMaxHeal)
		m_iMaxHealAmount = p_iMaxHeal;
		var ^CAttribs pxA = GetAttribs();
		if(pxA!=null)then
			pxA^.SetValue("heal_amount", m_iMaxHealAmount);
			pxA^.SetValue("maxhitpoints", m_iMaxHealAmount);
			pxA^.SetValue("hitpoints", m_iMaxHealAmount);
			if(HasTimer(REFILL_TIMER))then
				DeleteTimer(REFILL_TIMER);
			endif;
		endif;
	endproc;
	
	export proc bool StartRefillTimer()
		if(HasTimer(REFILL_TIMER))then return false; endif;
		m_xLastRefillTick=CTimeMgr.Get().GetTime();
		CreateTimer(REFILL_TIMER, CGameTimeSpan.OneSecond()*1.0, true);
		return true;
	endproc;
	
	export proc void StopRefillTimer()
		if(!HasTimer(REFILL_TIMER))then return; endif;
		DeleteTimer(REFILL_TIMER);
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==REFILL_TIMER)then
				var CGameTime xNow=CTimeMgr.Get().GetTime();
				Refill(xNow-m_xLastRefillTick);
				m_xLastRefillTick=xNow;
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	proc void Refill(CGameTimeSpan p_xDiff)
		var real fDuration=p_xDiff.GetSecondsF();
		var real fMaxAmount=m_iMaxHealAmount.ToReal();
		if(fDuration<=0.0)then
			fDuration=1.0;
		endif;
		var real fDiff=(fDuration/Math.Max(1.0,m_fRefillDuration))*fMaxAmount;
		m_fFillState+=fDiff;
		if(m_fFillState>=fMaxAmount)then
			m_fFillState=fMaxAmount;
			StopRefillTimer();
		endif;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("hitpoints",(m_fFillState+0.5).ToInt());
		endif;
	endproc;

	export proc void ObjArrived(CObjHndl p_xObj)
		var ^CFightingObj pxObj=cast<CFightingObj>(p_xObj.GetObj());
		if(pxObj==null)then return; endif;
		var real fHitpoints=pxObj^.GetHitpoints();
		var real fMaxHitpoints=pxObj^.GetMaxHitpoints();
		var real fDiff=m_fFillState-(fMaxHitpoints-fHitpoints);
		if(fDiff>=0.0)then
			pxObj^.FullHeal();
		else
			pxObj^.HealMe(m_fFillState);
			fDiff=0.0;
		endif;
		pxObj^.FountainArrived(GetHandle());
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("hitpoints",(fDiff+0.5).ToInt());
		endif;
		m_fFillState=fDiff;
		StartRefillTimer();
		if(HasAnim("fill_anim"))then
			InvokeGenericSCEvent(23,0.0);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CFountain] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xBase="Fntn";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,2);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		pxArc^ << m_fRefillDuration;
		pxArc^ << m_iMaxHealAmount;
		m_xAvailable.DoKArc(pxArc^);
		m_xLastRefillTick.DoKArc(pxArc^);
		pxArc^ << m_bDefFirstInit;
		pxWalk^.Close();
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="Fntn")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			if(iVersion==0)then
				var CHealRequest xInvalid;
				xInvalid.DoKArc(pxArc);
			endif;
			pxArc^ << m_fRefillDuration;
			pxArc^ << m_iMaxHealAmount;
			m_xAvailable.DoKArc(pxArc^);
			if(iVersion>=1)then
				m_xLastRefillTick.DoKArc(pxArc^);
			endif;
			if(iVersion>=2)then
				pxArc^ << m_bDefFirstInit;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void UpdateState()
		var ^CAttribs pxA=GetAttribs();
		if(pxA==null)then return; endif;
		m_iMaxHealAmount=pxA^.GetValueInt("maxhitpoints");
		if(m_iMaxHealAmount.ToReal()<m_fFillState)then
			m_fFillState=m_iMaxHealAmount.ToReal();
		endif;
		m_fRefillDuration=pxA^.GetValueInt("refill_dur").ToReal();
		if(HasTimer(REFILL_TIMER))then
			DeleteTimer(REFILL_TIMER);
		endif;
		StartRefillTimer();
	endproc;
	
endclass;

class CDelayedArmySpawn inherit CGameObj
	
	class CSpawnJob
		export var string m_sClass;
		export var int m_iLevel;
		
		export constructor()
		endconstructor;
		
		/*export constructor(ref CDelayedArmySpawn.CSpawnJob p_rxRhs)
			m_sClass = p_rxRhs.m_sClass;
			m_iLevel = p_rxRhs.m_iLevel;
		endconstructor;
		
		export proc ref CDelayedArmySpawn.CSpawnJob op_Assign(ref CDelayedArmySpawn.CSpawnJob p_rxRhs)
			m_sClass = p_rxRhs.m_sClass;
			m_iLevel = p_rxRhs.m_iLevel;
			return this^;
		endproc;*/
	endclass;
	
	class CJobQueue
		var array CSpawnJob m_axJobs;
		
		export proc void Push(CDelayedArmySpawn.CSpawnJob p_xJob)
			m_axJobs.AddEntry(p_xJob);
		endproc;
		
		export proc ^CDelayedArmySpawn.CSpawnJob Push()
			return ^(m_axJobs.NewEntryRef());
		endproc;
		
		export proc CDelayedArmySpawn.CSpawnJob Pop()
			var CSpawnJob xJob = m_axJobs[0];
			m_axJobs.DeleteEntry(0);
			return xJob;
		endproc;
		
		export proc int NumEntries()
			return m_axJobs.NumEntries();
		endproc;
		
		export proc bool IsEmpty()
			return m_axJobs.NumEntries()<=0;
		endproc;
		
		export proc void DoKArc(ref CArc p_rxArc)
			var int iC = m_axJobs.NumEntries();
			p_rxArc << iC;
			m_axJobs = iC;
			
			var int i;
			for(i=0) cond(i<iC) iter(++i)do
				p_rxArc << m_axJobs[i].m_sClass;
				p_rxArc << m_axJobs[i].m_iLevel;
			endfor;
		endproc;
	endclass;
	
	var CJobQueue m_xJobs;
	var real m_fSpawnDelay;
	var vec3 m_vSpawnPos;
	var vec3 m_vExitPos;
	var vec3 m_vDestination;
	var CObjHndl m_xGroup;
	var CObjHndl m_xSource;
	
	const int TIMER_ID = 98908;
	const int TIMER_START = 98907;
	
	export constructor()
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		InitEvents();
		SetVisible(false);
	endproc;
	
	export proc void SetSpawnDelay(real p_fDelay)
		m_fSpawnDelay = p_fDelay;
	endproc;
	
	export proc void SetSpawnPos(vec3 p_vPos)
		m_vSpawnPos = p_vPos;
	endproc;
	
	export proc void SetExitPos(vec3 p_vPos)
		m_vExitPos = p_vPos;
	endproc;
	
	export proc void SetDestinationPos(vec3 p_vPos)
		m_vDestination = p_vPos;
	endproc;
	
	export proc void SetGroup(CObjHndl p_xGroupHndl)
		m_xGroup = p_xGroupHndl;
	endproc;
	
	export proc void SetSourceObj(CObjHndl p_xSource)
		m_xSource=p_xSource;
	endproc;
	
	export proc void AddJob(string p_sClass, int p_iLevel)
		var ^CSpawnJob pxJob = m_xJobs.Push();
		pxJob^.m_sClass = p_sClass;
		pxJob^.m_iLevel = p_iLevel;
	endproc;

	export proc void StartAnim()
		var real fWait=OpenDoor();
		if(fWait>0.0)then
			DeleteTimer(TIMER_START);
			CreateTimer(TIMER_START, CGameTimeSpan.OneSecond() * fWait, true);
		else
			StartSpawn();
		endif;
	endproc;
	
	export proc void StartSpawn()
		Spawn();
		DeleteTimer(TIMER_ID);
		CreateTimer(TIMER_ID, CGameTimeSpan.OneSecond() * m_fSpawnDelay, true);
	endproc;
	
	export proc void Spawn()
		if(!m_xJobs.IsEmpty())then
			var CSpawnJob xJob = m_xJobs.Pop();
			
			// create obj
			var ^CGameObj pxO = CSrvWrap.GetObjMgr()^.CreateObj(xJob.m_sClass, GetOwner(), m_vSpawnPos);
			
			// set level
			var ^CFightingObj pxFightingObj = cast<CFightingObj>(pxO);
			if(pxFightingObj!=null)then
				pxFightingObj^.SetLevelClean(xJob.m_iLevel);
			endif;		
			
			// add to group
			if(m_xGroup.IsValid())then
				var ^CGroupObj pxGroup = cast<CGroupObj>(m_xGroup.GetObj());
				if(pxGroup!=null)then
					pxGroup^.AddMember(pxO^.GetHandle());
				endif;
			endif;
			
			// let's go
			if(m_xSource.IsValid())then
				var CGameEvtPtr xEvt=CGameEvtPtr.CreateEvent("CTheLite");
				xEvt.SetObjHandle(0,m_xSource);
				pxO^.HandleEvent(xEvt);
			else
				var ^CFightingObj pxFO = cast<CFightingObj>(pxO);
				if(pxFO!=null)then
					var ^CWalkToPos pxWalkTask=cast<CWalkToPos>(CSrvWrap.GetUSLFactoryMgr().CreateState(pxFO^.GetFSM(),"Walk2Pos"));
					if(pxWalkTask!=null)then
						pxWalkTask^.Init(pxFO^.GetHandle(),m_vExitPos, pxFO^.GetDefaultSpeed(), false, true, false, true);
						pxWalkTask^.SetUserCommand(true);
						pxFO^.AddTask(pxWalkTask,false);
					endif;
					pxWalkTask=cast<CWalkToPos>(CSrvWrap.GetUSLFactoryMgr().CreateState(pxFO^.GetFSM(),"Walk2Pos"));
					if(pxWalkTask!=null)then
						pxWalkTask^.Init(pxFO^.GetHandle(),m_vDestination, pxFO^.GetDefaultSpeed(), true, true, false, true);
						pxWalkTask^.SetUserCommand(true);
						pxFO^.AddTask(pxWalkTask,true);
					endif;
				endif;
			endif;
		else
			CloseDoor();
			DeleteTimer(TIMER_ID);
			Delete();
		endif;
	endproc;
	
	export proc real OpenDoor()
		var real fAnim=0.0f;
		if(!m_xSource.IsValid())then return 0.0; endif;
		var ^CGameObj pxObj=m_xSource.GetObj();
		if(pxObj^.HasAnim("open"))then
			pxObj^.SetAnim("open",1);
//			fAnim = pxObj^.GetCurrentAnimLength();
		elseif(pxObj^.HasAnim("work_finished"))then
			pxObj^.SetAnim("work_finished",1);
//			fAnim = pxObj^.GetCurrentAnimLength();
		elseif(pxObj^.HasAnim("spawn"))then
			pxObj^.SetAnim("spawn",1);
//			fAnim = pxObj^.GetCurrentAnimLength();
		endif;
		return fAnim;
	endproc;
	
	export proc void CloseDoor()
		if(!m_xSource.IsValid())then return; endif;
		var ^CGameObj pxObj=m_xSource.GetObj();
		if(!pxObj^.HasAnim("close"))then return; endif;
		pxObj^.SetAnim("close",1);
	endproc;
	
	proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==TIMER_ID)then
				Spawn();
			elseif(p_rxEvtPtr.GetInt(0)==TIMER_START)then
				StartSpawn();
			endif;
		endif;
	endproc;

 	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CDelayedArmySpawn] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xBase="DeAS";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xJobs.DoKArc(pxArc^);
		pxArc^<< m_fSpawnDelay;
		pxArc^<< m_vSpawnPos;
		pxArc^<< m_vExitPos;
		pxArc^<< m_vDestination;
		m_xGroup.DoKArc(pxArc^);
		m_xSource.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="DeAS")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xJobs.DoKArc(pxArc^);
			pxArc^<< m_fSpawnDelay;
			pxArc^<< m_vSpawnPos;
			pxArc^<< m_vExitPos;
			pxArc^<< m_vDestination;
			m_xGroup.DoKArc(pxArc^);
			if(p_pxReaderNode^.GetVersion()>=1)then
				m_xSource.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
endclass;

class CDeleteMeDummy inherit CGameObj
	export constructor()
		Delete();
	endconstructor;
endclass;

class CMiscNonIdiObj inherit CGameObj

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);		
		SetSelectable(false);
		SetHitable(false);
		if(!p_bLoad)then
			SetType("MNIO");
		endif;
	endproc;

endclass;

/** A CPyramidCardObject will displayed within client pyramid. Use it to force display of information within pyramid */
class CPyramidCardObject inherit CGameObj

	var CObjHndl	m_xBaseObj;
	var int				m_iOwner;
	var int				m_iSupply;
	var int				m_iSpiritHandle;
	var string		m_sNode;
	var bool			m_bSpirit;
	var bool			m_bPreSpirit;
	var CObjHndl	m_xSpirit;
	
	const int			TIMER_SPIRIT_KILL = 40182;
	const int			TIMER_SPIRIT_RESET = 40113;
	
	export constructor()
		m_bSpirit=false;
		m_bPreSpirit=false;
	endconstructor;

	export proc bool Init(^CGameObj p_pxGameObj)
		m_xBaseObj = p_pxGameObj^.GetHandle();
		SetPos(p_pxGameObj^.GetPos());
		var ^CAttribs pxAttr = GetAttribs();
		var ^CAttribs pxGameObjAttr = p_pxGameObj^.GetAttribs();
		if(pxAttr!=null && pxGameObjAttr!=null)then
			pxAttr^.SetValue("level", pxGameObjAttr^.GetValueInt("level"));
			pxAttr^.SetValue("hitpoints", pxGameObjAttr^.GetValueInt("hitpoints"));
			pxAttr^.SetValue("maxhitpoints", pxGameObjAttr^.GetValueInt("maxhitpoints"));
			pxAttr^.SetValue("CurTask", pxGameObjAttr^.GetValue("CurTask"));
			pxAttr^.SetValue("clientpyramid_slotid", pxGameObjAttr^.GetValue("clientpyramid_slotid"));
			pxAttr^.SetValue("ObjPath", pxGameObjAttr^.GetValue("ObjPath"));
			pxAttr^.SetValue("dead", true);
			pxAttr^.SetValue("TaskDescription", "");
			pxAttr^.SetValue("unit_count", true);
			pxAttr^.SetValue("Equip_Slot_0", pxGameObjAttr^.GetValue("Equip_Slot_0"));
			pxAttr^.SetValue("max_passengers", pxGameObjAttr^.GetValueInt("max_passengers"));
			pxAttr^.SetValue("can_attack", pxGameObjAttr^.GetValueInt("can_attack"));
			pxAttr^.SetValue("damage", pxGameObjAttr^.GetValueInt("damage"));
		endif;
		return true;
	endproc;

	export proc bool DoesCountInUnitLimit()
		return false;
	endproc;

	export proc void SetClientPyramidSlotID(int p_iID)
		GetAttribs()^.SetValue("clientpyramid_slotid", p_iID);
	endproc;

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			SetType("PyCO");
			InitAttribs();
			SetHitable(false);
			SetSelectable(false);
			SetVisible(false);
		else
			if(m_bSpirit)then
				InitEvents();
			endif;
		endif;
	endproc;

	export proc void OnPostLoad()
		super.OnPostLoad();
	endproc;

	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CPyramidCardObject] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xBase="PyCO";
		var int iVersion=3;
		if(CMirageSrvMgr.SDK())then
			iVersion=1;
		endif;
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,iVersion);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xBaseObj.DoKArc(pxArc^);
		if(iVersion>=2)then
			(pxArc^) << m_bSpirit;
			(pxArc^) << m_iOwner;
			(pxArc^) << m_iSupply;
			(pxArc^) << m_iSpiritHandle;
			(pxArc^) << m_sNode;
		endif;
		if(iVersion>=3)then
			(pxArc^) << m_bPreSpirit;
			m_xSpirit.DoKArc(pxArc^);
		endif;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="PyCO")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xBaseObj.DoKArc(pxArc^);
			if(p_pxReaderNode^.GetVersion()>=2)then
				(pxArc^) << m_bSpirit;
				(pxArc^) << m_iOwner;
				(pxArc^) << m_iSupply;
				(pxArc^) << m_iSpiritHandle;
				(pxArc^) << m_sNode;
			endif;
			if(p_pxReaderNode^.GetVersion()>=3)then
				(pxArc^) << m_bPreSpirit;
				m_xSpirit.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void SetResurectMod(int p_iOwner,int p_iSpiritHandle,string p_sNode,int p_iSupply,real p_fTime)
		if(GetEvents()==null)then
			InitEvents();
		endif;
		if(!HasTimer(TIMER_SPIRIT_KILL))then
			CreateTimer(TIMER_SPIRIT_KILL, CGameTimeSpan.OneSecond() * (600.0f), false);
		endif;
		m_bSpirit=true;
		m_iOwner=p_iOwner;
		m_iSpiritHandle=p_iSpiritHandle;
		m_sNode=p_sNode;
		p_iSupply=m_iSupply;
		CreateTimer(TIMER_SPIRIT_RESET, CGameTimeSpan.OneSecond() * (p_fTime+10.0f), false);
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass() == ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0) == TIMER_SPIRIT_RESET || p_rxEvtPtr.GetInt(0) == TIMER_SPIRIT_KILL)then
				ResetResurrection();
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	proc void ResetResurrection()
		if(!m_bSpirit)then return; endif;
		DeleteTimer(TIMER_SPIRIT_RESET);
		DeleteTimer(TIMER_SPIRIT_KILL);
		var ^CPlayer pxPlayer=CSrvWrap.GetCurLevel()^.GetPlayer(m_iOwner);
		if(pxPlayer==null)then return; endif;
		var ^CAttribs pxPlAttr=pxPlayer^.GetAttribs();
		if(pxPlAttr==null)then return; endif;
		var ^CSpirit pxSpirit=CSrvWrap.GetSpiritMgr().GetSpirit(m_iSpiritHandle);
		var int iCount=-1;
		if(pxSpirit!=null)then
			iCount=pxSpirit^.GetRessurectionValue();
			pxSpirit^.SetRessurectionValue(iCount-1);
		endif;
		if(iCount==1)then
			pxPlAttr^.SetValue("virtual_supply", pxPlAttr^.GetValueInt("virtual_supply")-m_iSupply);
			pxPlAttr^.SetValue(m_sNode, pxPlAttr^.GetValueInt(m_sNode)-1);
			Delete();
		endif;
		//CSrvWrap.GetObjMgr()^.DeleteObject(this);
	endproc;
	
	export proc void StopTimer()
		m_bSpirit=false;
		DeleteTimer(TIMER_SPIRIT_RESET);
	endproc;
	
	export proc void SetSpiritHandle(CObjHndl p_xSprt)
		m_xSpirit=p_xSprt;
	endproc;
	
	export proc CObjHndl GetSpiritHandle()
		return m_xSpirit;
	endproc;
	
	export proc ^CMrgSprt GetSpirit()
		return cast<CMrgSprt>(m_xSpirit.GetObj());
	endproc;
	
	export proc void SetPreSpirit(bool p_bOn, int p_iHndl)
		m_bSpirit=p_bOn;
		var ^CAttribs pxA = GetAttribs();
		if(pxA!=null)then
			pxA^.SetValue("pre_spirit", p_bOn);
			pxA^.SetValue("spirit_handle", p_iHndl);
		endif;
	endproc;
	
	export proc void HandleGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams)
		if(p_sCommand=="remove_pre_pyco")then
			var ^CMrgSprt pxS = GetSpirit();
			if(pxS!=null)then
				pxS^.DestroyPyCO();
			endif;
			return;
		else
			super.HandleGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams);
		endif;
	endproc;
	
endclass;

class CActionEffectObj inherit CGameObj
	
	const int TIMER_EFFECT = 112233;
	static var CPropDB ms_xParticleDB;	
		
	export constructor()		
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			SetType("EFFO");
			InitAttribs();			
			SetHitable(false);
			SetSelectable(false);			
		endif;
		InitEvents();
	endproc;
	
	export proc void Init(string p_sEffectPath, int p_iNumLoops)
		if(ms_xParticleDB.GetRoot().NumSubs()==0)then
			var string sPath=CSrvWrap.GetUrsRelPath()+"/Data/Base/Scripts/Game/sequencer/particles.txt";
			if(!ms_xParticleDB.Load(sPath))then
				KLog.LogError("CActionEffectObj","ms_xParticleDB.Load() failed");
			endif;
		endif;
		
		p_sEffectPath.TrimLeft("/");
		p_sEffectPath.TrimRight("/");
		var ^CPropDB.CNode pxEffectNode=^(ms_xParticleDB[p_sEffectPath]);
		if(pxEffectNode^.Value().IsEmpty())then
			Delete();			
			return;
		endif;		
		SetGFX(pxEffectNode^.Value());		
		SetSLEAnim("anim",p_iNumLoops);		
		if(p_iNumLoops>0)then
			var real fAnimLength=pxEffectNode^.GetValueR("length",4.0f);		
			DeleteTimer(TIMER_EFFECT);
			CreateTimer(TIMER_EFFECT,CGameTimeSpan.OneSecond()*(fAnimLength*p_iNumLoops.ToReal()),false);
		endif;
	endproc;
	
	 proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==TIMER_EFFECT)then				
				Delete();
			endif;		
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;		
		
	endproc;

endclass;