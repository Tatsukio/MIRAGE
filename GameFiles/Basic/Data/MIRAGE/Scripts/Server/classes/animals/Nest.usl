class CNest inherit CFightingObj
	
	class CTimeTable
		
		class CEntry
			export var int m_iID;
			export var int m_iStartTime;
			export var int m_iEndTime;
		endclass;
		
		var array CEntry m_axEntries;
		
		export proc int GetID(int p_iTime)
			var int i,iC=m_axEntries.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				var int iStart=m_axEntries[i].m_iStartTime;
				var int iEnd=m_axEntries[i].m_iEndTime;
				// for night time, 22 - 4
				if(iStart>iEnd)then
					if((p_iTime>=iStart)||(p_iTime<iEnd))then
						return m_axEntries[i].m_iID;
					endif;
				else
					if((p_iTime>=iStart) && (p_iTime<iEnd))then
						return m_axEntries[i].m_iID;
					endif;
				endif;
			endfor;
			return -1;
		endproc;
		
		export proc void SetData(int p_iID,int p_iStartTime,int p_iEndTime)
			var int i,iC=m_axEntries.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				if(m_axEntries[i].m_iID==p_iID)then
					m_axEntries[i].m_iStartTime=p_iStartTime;
					m_axEntries[i].m_iEndTime=p_iEndTime;
					return;
				endif;
			endfor;
			var int iIdx=m_axEntries.NewEntry();
			m_axEntries[iIdx].m_iID=p_iID;
			m_axEntries[iIdx].m_iStartTime=p_iStartTime;
			m_axEntries[iIdx].m_iEndTime=p_iEndTime;
		endproc;
		
		export proc void FromString(string p_sData)
			m_axEntries=0;
			var array string asEntries;
			p_sData.Split(asEntries,"\n",true);
			var int i,iC=asEntries.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				var array string asTiles;
				asEntries[i].Split(asTiles,"\t",true);
				if(asTiles.NumEntries()<3)then continue; endif;
				SetData(asTiles[0].ToInt(),asTiles[1].ToInt(),asTiles[2].ToInt());
			endfor;
		endproc;
		
		export proc string ToString()
			var string sRet;
			var int i,iC=m_axEntries.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				sRet+=	m_axEntries[i].m_iID.ToString()+"\t"+
					m_axEntries[i].m_iStartTime.ToString()+"\t"+
					m_axEntries[i].m_iEndTime.ToString()+"\n";
			endfor;
			return sRet;
		endproc;
	endclass;
	
	export static var array int	ms_aiNeutralPlayer;
	
	var CGuid							m_xActionArea;
	var CGuid							m_xSafeArea;
	var CGuid							m_xHotspotArea;
	var CGuid							m_xToleranceArea;
	const int							TIMER_SPAWN=1177;
	var CObjList					m_xAnimals;
	export var CObjHndl		m_xFlock;
	
	//shared data
	var ^CRegion					m_pxActionArea;
	var ^CRegion					m_pxSafeArea;
	var ^CRegion					m_pxHotspotArea;
	var ^CRegion					m_pxToleranceArea;
	var CTimeTable				m_xHotspotTimeTable;
	
	var bool							m_bSpawnUninfluenced;
	var bool							m_bSpawnGrown;
	var bool							m_bExt;
	
	var real							m_fFlockAgility;
	var real							m_fFlockDensity; ///< radius for each animal in m
	var real							m_fFlockSize;
	
	const int							TIMER_UPDATEPOS=4343;
	var vec3							m_vFlockPos; ///< center, where animals should be around
	
	const int							TIMER_CHECK_AREA=3443;
	const int							NEST_RESPAWN=40004;
	const real						RESPAWN_DURATION=600.0f;
	
	var CObjQuery					m_xEnemySearch; /// used to check if there is some enemy, like building, in save region
	var vec3							m_vLastRandomPos;
	var int								m_iGrowSize;
	var bool							m_bInactive;
	var bool							m_bPrevHitable;
	var bool							m_bPrevVisible;
	var bool							m_bPrevSelectable;
	var bitset						m_dwVisMask;
	var CObjList					m_xPreNeighborhood;
	var bool							m_bGameStart;
	var vec3							m_vTmp;
	
	/*
	attribs {
	string	SpawnType;	// Tierart
	int 	SpawnAmount;// Wie viele Tiere insgesamt nachproduziert werden, bis das Nest "leer" ist
	int		SpawnMax;	// Wenn diese Zahl erreicht ist, werden keine neuen Tiere mehr produziert.
	int		SpawnRate;	// Die Geschwindigkeit, mit der die Zahl der Tiere bis zur max. Zahl aufgefüllt wird
	}*/
	
	constructor()
		m_xEnemySearch.SetType("BLDG");
		m_vLastRandomPos={0.0f,0.0f,0.0f};
		m_iGrowSize=0;
		m_bInactive=false;
		m_bExt=false;
		m_dwVisMask=011111111b;
		m_bPrevHitable=false;
		m_bPrevVisible=true;
		m_bPrevSelectable=true;
		m_bGameStart=false;
		m_vTmp=GetPos();
	endconstructor;
	
	destructor()
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		System.Assert(pxLevel!=null);
		if(pxLevel^.IsEditable())then
			var ^CRegionMgr pxRM=^(CSrvWrap.GetRegionMgr());
			pxRM^.DeleteRegion(m_xActionArea);
			pxRM^.DeleteRegion(m_xSafeArea);
			pxRM^.DeleteRegion(m_xHotspotArea);
			if(!m_xToleranceArea.IsNull())then
				pxRM^.DeleteRegion(m_xToleranceArea);
			endif;
		endif;
	enddestructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetMovableInFight(false);
		SetCanWalk(false);
		var ^CRegionMgr pxRM=^(CSrvWrap.GetRegionMgr());
		if(!p_bLoad)then
			SetSelectable(true); // ... make it selectable ...
			SetHitable(true); // ... and hitable.
			SetType("NEST");
			InitAttribs();
			var int iTmp=pxRM^.CreateRegion(GetName()+"_ActionArea",CSubRegion.RT_Oval,GetPos(),{40.0f,40.0f,0.0f});
			m_pxActionArea=pxRM^.GetRegion(iTmp);
			m_xActionArea=m_pxActionArea^.GetGUID();
			m_pxActionArea^.SetColor({{0,255,191,255}});
			iTmp=pxRM^.CreateRegion(GetName()+"_SafeArea",CSubRegion.RT_Oval,GetPos(),{20.0f,20.0f,0.0f});
			m_pxSafeArea=pxRM^.GetRegion(iTmp);
			m_xSafeArea=m_pxSafeArea^.GetGUID();
			m_pxSafeArea^.SetColor({{255,0,0,255}});
			iTmp=pxRM^.CreateRegion(GetName()+"_HotspotArea"/*,CSubRegion.RT_Oval,GetPos(),{20.0f,20.0f,0.0f}*/);
			m_pxHotspotArea=pxRM^.GetRegion(iTmp);
			m_xHotspotArea=m_pxHotspotArea^.GetGUID();
			m_pxHotspotArea^.SetColor({{255,255,0,255}});
			if(!CMirageSrvMgr.SkipTolerance())then
				iTmp=pxRM^.CreateRegion(GetName()+"_ToleranceArea",CSubRegion.RT_Oval,GetPos(),{80.0f,80.0f,0.0f});
				m_pxToleranceArea=pxRM^.GetRegion(iTmp);
				m_xToleranceArea=m_pxToleranceArea^.GetGUID();
				m_pxToleranceArea^.SetColor({{161,127,255,255}});
			endif;
		else
			m_pxActionArea=pxRM^.GetRegionByGuid(m_xActionArea);
			m_pxSafeArea=pxRM^.GetRegionByGuid(m_xSafeArea);
			m_pxHotspotArea=pxRM^.GetRegionByGuid(m_xHotspotArea);
			if(!m_xToleranceArea.IsNull())then
				m_pxToleranceArea=pxRM^.GetRegionByGuid(m_xToleranceArea);
			elseif(!CMirageSrvMgr.SkipTolerance())then
				var vec3 vR;
				var real fR=80.0f;
				if(GetClassName().Find("_nest_spawn")!=-1||GetClassName()=="hu_kennel_nest")then
					fR=140.0f;
				endif;
				vR.SetXYZ(fR,fR,0.0f);
				var int iTmp=pxRM^.CreateRegion(GetName()+"_ToleranceArea",CSubRegion.RT_Oval,GetPos(),vR);
				m_pxToleranceArea=pxRM^.GetRegion(iTmp);
				m_xToleranceArea=m_pxToleranceArea^.GetGUID();
				m_pxToleranceArea^.SetColor({{0,255,191,255}});
			endif;
			var ^CAttribs pxAttribs=GetAttribs();
			m_xHotspotTimeTable.FromString(pxAttribs^.GetValue("hotspot_timetable"));
			if(!CMirageSrvMgr.SDK()&&!m_bGameStart)then
				if(HasTimer(TIMER_SPAWN))then DeleteTimer(TIMER_SPAWN); endif;
				m_bGameStart=true;
			endif;
		endif;
		if(CMirageSrvMgr.SDK())then
			if(HasTimer(TIMER_SPAWN))then DeleteTimer(TIMER_SPAWN); endif;
		endif;
		if((GetClassName()=="Nest_Mammal_Cave"||GetClassName()=="nest_ice_mammal_cave") && !m_bInactive && m_bPBlocker)then
			CSrvWrap.GetPathfinder().AddPFBlocker(this);
		endif;
		if(m_pxActionArea!=null)then
			m_pxActionArea^.SetAnimalsOnly();
		endif;
		if(m_pxSafeArea!=null)then
			m_pxSafeArea^.SetAnimalsOnly();
		endif;
		if(m_pxHotspotArea!=null)then
			m_pxHotspotArea^.SetAnimalsOnly();
		endif;
		if(m_pxToleranceArea!=null)then
			m_pxToleranceArea^.SetAnimalsOnly();
		endif;
		if((m_pxHotspotArea==null)||(m_pxSafeArea==null)||(m_pxActionArea==null)||(m_pxToleranceArea==null))then
			KLog.LogError("Nest","Missing regions for nest "+GetName());
		endif;
		m_fFlockAgility=-1.0f;
		m_fFlockDensity=-1.0f;
		UpdateAttribs(p_bLoad);
		UpdateFlockPos();
		StartTimer();
		if(!HasTimer(TIMER_CHECK_AREA))then
			CreateTimer(TIMER_CHECK_AREA,CGameTimeSpan.OneSecond()*2.0f,true);
		endif;
		OnTechTreeChange();
		// we can't build on nests
		//SetPlaceBlocker(true);
//		SetPlaceBlocker(!m_bInactive);
		if(!p_bLoad)then
			SetPlaceBlocker(true);
			SetCanFightAttrib(false);
		else
			SetPlaceBlocker(m_bPBlocker&&!m_bInactive);
		endif;
		if(GetOwner()==-1)then
			var bool bAnimalsVisInFOW=CMirageSrvMgr.Get().AnimalsVisInFOW();
			SetVisInFOW(bAnimalsVisInFOW);
		endif;
	endproc;
	
	export proc void OnPostLoad()
		UpdateFlockPos();
		var ^CAttribs pxAttribs=GetAttribs();
		if(!CMirageSrvMgr.SDK())then
			begin Preplaced_Animals;
				var string sGuids=pxAttribs^.GetValue("preplace_anmls");
				var array string asToks;
				sGuids.Split(asToks, "\n", true);
				var CGuid xG;
				var int i, iC=asToks.NumEntries();
				for(i=0) cond(i<iC) iter(++i)do
					xG.FromString(asToks[i]);
					var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.GetObjByGuid(xG);
					if(pxO!=null)then
						AddAnimal(pxO^.GetHandle());
	//					if(m_xAnimals.FindEntry(pxO^.GetHandle())<0)then
	//						m_xAnimals.Include(pxO^.GetHandle());
	//					endif;
					endif;
				endfor;
			end Preplaced_Animals;
		endif;
		begin Advance_Population;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if((pxLevel!=null) && !pxLevel^.IsEditable())then
				m_xAnimals.Validate();
				var real fVF=CTimeMgr.Get().GetVirtualFactor();
				var real fVDL=CTimeMgr.Get().GetVirtualDayLength();
				var real fAdvanceTime=pxAttribs^.GetValueFloat("advance_time")*(fVF/fVDL);
				var int iSpawnAmount=pxAttribs^.GetValueInt("spawn_amount");
//				var int iSpawnMaxOrigi=pxAttribs^.GetValueInt("spawn_max");
				var int iSpawnMax=pxAttribs^.GetValueInt("spawn_max") - m_xAnimals.NumEntries()+m_iGrowSize;
				var real fSpawnRate=pxAttribs^.GetValueFloat("spawn_rate")*(fVF/fVDL);
				if((iSpawnAmount!=0) && (fAdvanceTime>0.0f) && (fSpawnRate>0.0f) && (iSpawnMax>0) && !m_bInactive)then
					var int i,iSpawnCnt=Math.Ceil(fAdvanceTime/fSpawnRate).ToInt();
					iSpawnCnt=Math.Min(iSpawnCnt,iSpawnMax);
					if(iSpawnAmount!=-1)then
						iSpawnCnt=Math.Min(iSpawnCnt,iSpawnAmount);
					endif;
					var real fVirtualNow=CTimeMgr.Get().GetVirtualTime()-(fAdvanceTime*fVDL);
					// spawn iSpawnCnt animals
					for(i=0)cond(i<iSpawnCnt)iter(i++)do
						var CObjHndl xAnimal;
						var bool bBaby;
						if(!SpawnAnimal(fVirtualNow,xAnimal,bBaby))then
							KLog.LogError("Nest","spawn animal failed");
							break;
						endif;
						var ^CGameObj pxAnimal=xAnimal.GetObj();
						if(pxAnimal==null)then continue; endif;
						var vec3 vPos=GetPos();
						GetRandomPoint(vPos,bBaby,true);
						CSrvWrap.GetObjMgr()^.GetFreePos(vPos,pxAnimal,vPos,null,true,false,false);
						var ^CPathfinder pxPF=^(CSrvWrap.GetPathfinder());
						var ^CRegion pxActionArea=GetActionAreaPtr();
						if(pxPF^.ValidateAnimalSpawnPath(pxAnimal,GetPos(),vPos, pxActionArea))then
							vPos.SetZ(Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vPos.GetX(),vPos.GetY()),CSrvWrap.GetScapeMgr().GetSeaLevel()));
							pxAnimal^.SetPos(vPos);
						endif;
						//CNest.CSpawnPosSelector.Invoke(this, pxAnimal, bBaby);
						fVirtualNow+=(fSpawnRate*fVDL);
					endfor;
				endif;
				// unset advance time, so we make it only once upon first load in game mode
				pxAttribs^.SetValue("advance_time",0.0f);
			endif;
		end Advance_Population;
		UpdateFlockSize();
		UpdateFlockPos();
	endproc;
	
	export proc bool DoesCountInUnitLimit()
		return false;
	endproc;
	
	///////
	// GetTechTreeAggressive()
	///////
	export proc int GetTechTreeAggressiv()
		if(GetOwner()!=-1)then
			return super.GetTechTreeAggressiv();
		else
			var ^CAttribs pxAttr=GetAttribs();
			if(pxAttr==null)then return 0; endif;
			var string sClass=pxAttr^.GetValue("spawn_type");
			var string sPath="Objects/World/ANML/"+sClass;
			var ^CTechTree.CNode pxObj=m_xTechTree.FindNode(sPath);
			if(pxObj==null)then return 0; endif;
			var int iAggr=pxObj^.GetSubValueI("aggressive", 0);
			//if(iAggr==1&&!CMirageSrvMgr.Get().NestRespawn())then iAggr=0; endif;
			return iAggr;
		endif;
	endproc;
	
	export proc void SetAttrib(string p_sName, string p_sValue)
		if(p_sName=="spawn_grown")then
			m_bSpawnGrown=(p_sValue.ToInt()!=0);
		elseif(p_sName=="spawn_uninfluenced")then
			m_bSpawnUninfluenced=(p_sValue.ToInt()!=0);
		else
			super.SetAttrib(p_sName,p_sValue);
		endif;
	endproc;
	
	export proc void OnTechTreeChange(ref CStringArray po_rasChanges)
		super.OnTechTreeChange(po_rasChanges);
	endproc;
	
	export proc void OnTechTreeChange()
		super.OnTechTreeChange();
		var ^CAttribs pxAttribs=GetAttribs();
		if(pxAttribs==null)then return; endif;
		var string sTribe=GetTribeName();
		if(sTribe.IsEmpty())then return; endif;
		var string sClassName=pxAttribs^.GetValue("spawn_type");
		var ^CTechTree.CNode pxObjNode=m_xTechTree.FindNode("Objects/"+sTribe+"/ANML/"+sClassName);
		if(pxObjNode==null)then
			var ^CTechTree.CNode pxTribeNode=m_xTechTree.FindNode("Objects/"+sTribe);
			if(pxTribeNode==null)then return; endif;
			pxObjNode=pxTribeNode^.FindNodeRecursiveByName(sClassName);
		endif;
		if(pxObjNode==null)then return; endif;
		var real fOldValue=m_fFlockAgility;
		m_fFlockAgility=pxObjNode^.GetSubValueF("agility",0.0f);
		if(m_fFlockAgility!=fOldValue)then
			UpdateAgilityTimer();
		endif;
		fOldValue=m_fFlockDensity;
		m_fFlockDensity=pxObjNode^.GetSubValueF("density",0.0f);
		if(m_fFlockDensity!=fOldValue)then
			UpdateFlockSize();
		endif;
	endproc;
	
	proc void UpdateFlockSize()
//		KLog.LogSpam("MaMa",GetName()+" flock density: "+m_fFlockDensity.ToString());
		m_fFlockSize=2.0f*Math.Max(m_fFlockDensity,5.0f)*Math.Sqrt(m_xAnimals.NumEntries().ToReal()/Math.Pi());
//		KLog.LogSpam("MaMa",GetName()+" new flock size: "+m_fFlockSize.ToString());
	endproc;
	
	export proc bool IsAbleToFight()
		return false;
	endproc;
	
	export proc void AddAnimal(CObjHndl p_xObj)
		if(p_xObj.IsValid())then
			var ^CAnimal pxA=cast<CAnimal>(p_xObj.GetObj());
			if(pxA!=null)then
//				if(m_xAnimals.FindEntry(p_xObj)>=0)then return; endif;
				if(m_xAnimals.FindEntry(p_xObj)<0)then
					m_xAnimals.Include(p_xObj);
				endif;
				pxA^.m_xNest=GetHandle();
				begin Flocking;
					if((!m_xFlock.IsValid())&&(m_pxSafeArea!=null))then
						var CObjQuery xOQ;
						xOQ.SetType("NEST");
						xOQ.SetRegion(m_pxSafeArea^.GetHandle());
						xOQ.Exclude(GetHandle());
						var CObjList xNests;
						if(xOQ.Execute(xNests))then
							var int i,iC=xNests.NumEntries();
							for(i=0)cond(i<iC)iter(i++)do
								var ^CNest pxWalk=cast<CNest>(xNests[i].GetObj());
								if(pxWalk==null)then continue; endif;
								if(pxWalk^.m_xFlock.IsValid())then
									m_xFlock=pxWalk^.m_xFlock;
									break;
								endif;
							endfor;
						endif;
					endif;
					if(!m_xFlock.IsValid())then
						var ^CGameObj pxObj=CSrvWrap.GetObjMgr()^.CreateObj("Flock",GetOwner());
						if(pxObj!=null)then
							m_xFlock=pxObj^.GetHandle();
						endif;
					endif;
					var ^CFlock pxFlock=cast<CFlock>(m_xFlock.GetObj());
					if(pxFlock!=null)then
						pxA^.m_xFlock=m_xFlock;
						pxFlock^.AddMember(p_xObj);
					endif;
				end Flocking;
				UpdateFlockSize();
			endif;
		endif;
	endproc;
	
	export proc void RemAnimal(CObjHndl p_xObj)
		if(m_xAnimals.RemEntry(p_xObj))then
			var ^CAnimal pxA=cast<CAnimal>(p_xObj.GetObj());
			if(pxA!=null)then
				pxA^.m_xNest=CObjHndl.Invalid();
				pxA^.m_xFlock=CObjHndl.Invalid();
			endif;
			UpdateFlockSize();
		endif;
	endproc;
	
	export proc void HandleGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams)
		if(p_sCommand=="AddAnimal")then
			if(p_pxObject!=null)then
				AddAnimal(p_pxObject^.GetHandle());
			endif;
		elseif(p_sCommand=="RemAnimal")then
			if(p_pxObject!=null)then
				RemAnimal(p_pxObject^.GetHandle());
			endif;
		else
			super.HandleGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams);
		endif;
	endproc;
	
	proc void PreCheckForEnemies()
		return;
/*
		var int iOwner=GetOwner();
		if(iOwner>-1)then return; endif;
	
		var CObjList xEnemyList;
	
		var ^CFlock pxF=cast<CFlock>(m_xFlock.GetObj());
		if(pxF!=null)then
			m_xEnemySearch.ClearExcludes();
			m_xEnemySearch.Exclude(pxF^.GetObjects());
		endif;
	
		m_xEnemySearch.SetRegion(GetSafeArea());
		if(m_xEnemySearch.Execute(xEnemyList))then
			xEnemyList.SortDistance(GetPos());
			var int i,iC=xEnemyList.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				var ^CBuilding pxB=cast<CBuilding>(xEnemyList[i].GetObj());
				if(pxB!=null && !pxB^.IsBuildMode())then
					OnDefend(pxB,pxB);
				endif;
			endfor;
		endif;
*/
	endproc;
	
	proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[Nest.usl] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xType="nest";
		var int iVersion=4;
		if(CMirageSrvMgr.SDK())then
			iVersion=4;
		endif;
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,iVersion);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		(pxArc^) << m_xActionArea;
		(pxArc^) << m_xSafeArea;
		(pxArc^) << m_xHotspotArea;
		m_xFlock.DoKArc(pxArc^);
		m_xAnimals.DoKArc(pxArc^);
		var int i,iCount=ms_aiNeutralPlayer.NumEntries();
		(pxArc^) << iCount;
		for(i=0)cond(i<iCount)iter(i++)do
			(pxArc^) << ms_aiNeutralPlayer[i];
		endfor;
		pxWalk^.Close();
		xType="tole"; // Henry: for tolerance area mainly...
		iVersion=2;
		pxWalk=p_pxWriterNode^.AddSubChunk(xType,iVersion);
		pxArc=^(pxWalk^.GetArc());
		if(iVersion>=1)then
			(pxArc^) << m_xToleranceArea;
		endif;
		if(iVersion>=2)then
			(pxArc^) << m_iGrowSize;
			(pxArc^) << m_bInactive;
			(pxArc^) << m_bPrevHitable;
			(pxArc^) << m_dwVisMask;
			m_xPreNeighborhood.DoKArc(pxArc^);
			(pxArc^) << m_bExt;
			(pxArc^) << m_bPrevVisible;
			(pxArc^) << m_bPrevSelectable;
			(pxArc^) << m_bGameStart;
		endif;
		pxWalk^.Close();
	endproc;
	
	proc void Load(^CUOFReaderNode p_pxReaderNode)
//		CMirageSrvMgr.Debug(GetName()+"'s nest version: '"+(p_pxReaderNode^.GetVersion()).ToString()+"'");
//		CMirageSrvMgr.Debug(GetName()+"'s nest type: '"+p_pxReaderNode^.GetType().AsString()+"'");
		if(p_pxReaderNode^.GetType()=="nest")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			if(p_pxReaderNode^.GetVersion()==1)then
				(pxArc^) << m_xSafeArea;
				(pxArc^) << m_xActionArea;
			elseif(p_pxReaderNode^.GetVersion()==2)then
				(pxArc^) << m_xActionArea;
				(pxArc^) << m_xSafeArea;
				(pxArc^) << m_xHotspotArea;
			elseif(p_pxReaderNode^.GetVersion()==3)then
				(pxArc^) << m_xActionArea;
				(pxArc^) << m_xSafeArea;
				(pxArc^) << m_xHotspotArea;
				m_xFlock.DoKArc(pxArc^);
				m_xAnimals.DoKArc(pxArc^);
			elseif(p_pxReaderNode^.GetVersion()>=4)then
				(pxArc^) << m_xActionArea;
				(pxArc^) << m_xSafeArea;
				(pxArc^) << m_xHotspotArea;
				m_xFlock.DoKArc(pxArc^);
				m_xAnimals.DoKArc(pxArc^);
				var int i,iCount=0;
				var int iPlayer;
				(pxArc^) << iCount;
				for(i=0)cond(i<iCount)iter(i++)do
					(pxArc^) << iPlayer;
					ms_aiNeutralPlayer.Include(iPlayer);
				endfor;
			endif;
		elseif(p_pxReaderNode^.GetType()=="tole")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVer=p_pxReaderNode^.GetVersion();
			if(iVer>=1)then
				(pxArc^) << m_xToleranceArea;
			endif;
			if(iVer>=2)then
				(pxArc^) << m_iGrowSize;
				(pxArc^) << m_bInactive;
				(pxArc^) << m_bPrevHitable;
				(pxArc^) << m_dwVisMask;
				m_xPreNeighborhood.DoKArc(pxArc^);
				(pxArc^) << m_bExt;
				(pxArc^) << m_bPrevVisible;
				(pxArc^) << m_bPrevSelectable;
				(pxArc^) << m_bGameStart;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool GetRandomPoint(ref vec3 po_rvPos,bool p_bBaby)
		return GetRandomPoint(po_rvPos,p_bBaby,false);
	endproc;
	
	export proc bool GetRandomPoint(ref vec3 po_rvPos,bool p_bBaby,bool p_bIgnoreFlock)
		if(p_bBaby)then
			if((m_pxSafeArea!=null) && (m_pxSafeArea^.NumSubs()>0))then
				po_rvPos=m_pxSafeArea^.GetRandomPointInside();
				return true;
			endif;
			return false;
		endif;
		if(p_bIgnoreFlock)then
			if((m_pxActionArea!=null) && (m_pxActionArea^.NumSubs()>0))then
				var int iTry=0;
				var vec3 vNewPos;
				while(iTry++<100)do
					vNewPos=m_pxActionArea^.GetRandomPointInside();
					var real fVariance=Math.Min(10.0f, m_pxActionArea^.GetRadius()/4.0f);
					if((Math.Abs(vNewPos.GetX()-m_vLastRandomPos.GetX())+Math.Abs(vNewPos.GetX()-m_vLastRandomPos.GetY())) > fVariance)then
						po_rvPos=vNewPos;
						break;
					endif;
				endwhile;
				m_vLastRandomPos=po_rvPos;
				return true;
			endif;
			return false;
		endif;
		po_rvPos=m_vFlockPos;
		if((m_pxActionArea!=null) && (m_pxActionArea^.NumSubs()>0))then
			// find random pos
			var vec3 vPos;
			var int iTry=0;
			var vec3 vNewPos;
			while(iTry++<100)do
				vNewPos=m_pxActionArea^.GetRandomPointInside();
				var real fVariance=Math.Min(10.0f, m_pxActionArea^.GetRadius()/4.0f);
				if((Math.Abs(vNewPos.GetX()-m_vLastRandomPos.GetX())+Math.Abs(vNewPos.GetX()-m_vLastRandomPos.GetY())) > fVariance)then
					vPos=vNewPos;
					break;
				endif;
			endwhile;
			m_vLastRandomPos=vPos;
			// calc position in flock
			var vec3 vDir=vPos-m_vFlockPos;
			vDir.SetZ(0.0f);
			var real fLength=vDir.Abs2();
			if(fLength>m_fFlockSize)then
				fLength=Random.MTRandF(0.0f,m_fFlockSize);
			endif;
			po_rvPos=vPos+(vDir.GetNormalized()*fLength);
		endif;
		return true;
	endproc;
	
	export proc bool AcceptablePos(vec3 p_vPos,bool p_bBaby)
		return AcceptablePos(p_vPos,p_bBaby,false);
	endproc;
	
	export proc bool AcceptablePos(vec3 p_vPos,bool p_bBaby,bool p_bIgnoreFlock)
		if(p_bBaby)then
			return IsInSafeArea(p_vPos);
		endif;
		if(!IsInActionArea(p_vPos))then return false; endif;
		if(p_bIgnoreFlock)then return true; endif;
		var ^CFlock pxFlock=cast<CFlock>(m_xFlock.GetObj());
		if(pxFlock==null)then return true; endif;
		var real fLength=(p_vPos-m_vFlockPos).Abs2();
		return (fLength<=pxFlock^.GetFlockSize()/* m_fFlockSize */);
	endproc;
	
	proc bool GetRandomPointInHotspot(ref vec3 po_rvPos,bool p_bUseDayTime)
		if((m_pxHotspotArea!=null) && (m_pxHotspotArea^.NumSubs()>0))then
			if(Random.MTRandF(0.0,1.0)<0.60)then
				if(p_bUseDayTime)then
					var real fDayTime=Math.FMod(CTimeMgr.Get().GetVirtualTime(),CTimeMgr.Get().GetVirtualDayLength())/(60.0*60.0);
					var int iIdx=m_xHotspotTimeTable.GetID(fDayTime.ToInt());
					if(iIdx>=0 && iIdx<m_pxHotspotArea^.NumSubs())then
						po_rvPos=m_pxHotspotArea^[iIdx]^.GetRandomPointInside();
						return true;
					endif;
				else
					po_rvPos=m_pxHotspotArea^.GetRandomPointInside();
					return true;
				endif;
			endif;
		endif;
		return false;
	endproc;
	
	export proc bool IsInSafeArea(ref vec3 p_rvPos)
		if(m_pxSafeArea!=null)then
			return m_pxSafeArea^.IsInside( p_rvPos );
		endif;
		return false;
	endproc;
	
	export proc bool IsInActionArea(ref vec3 p_rvPos)
		if(m_pxActionArea!=null)then
			return m_pxActionArea^.IsInside( p_rvPos );
		endif;
		return false;
	endproc;
	
	export proc int GetActionArea()
		if(m_pxActionArea==null)then return -1; endif;
		return m_pxActionArea^.GetHandle();
	endproc;
	
	export proc ^CRegion GetActionAreaPtr()
		return m_pxActionArea;
	endproc;
	
	export proc int GetSafeArea()
		if(m_pxSafeArea==null)then return -1; endif;
		return m_pxSafeArea^.GetHandle();
	endproc;
	
	export proc ^CRegion GetSafeAreaPtr()
		return m_pxSafeArea;
	endproc;
	
	export proc int GetHotspotArea()
		if(m_pxHotspotArea==null)then return -1; endif;
		return m_pxHotspotArea^.GetHandle();
	endproc;
	
	export proc ^CRegion GetHotspotAreaPtr()
		return m_pxHotspotArea;
	endproc;
	
	export proc bool IsInToleranceArea(ref vec3 p_rvPos)
		if(m_pxToleranceArea!=null)then
			return m_pxToleranceArea^.IsInside( p_rvPos );
		endif;
		return false;
	endproc;
	
	export proc int GetToleranceArea()
		if(m_pxToleranceArea==null)then return -1; endif;
		return m_pxToleranceArea^.GetHandle();
	endproc;
	
	export proc ^CRegion GetToleranceAreaPtr()
		return m_pxToleranceArea;
	endproc;
	
	export proc ^CRegion GetToleranceAreaForced()
		if(m_xToleranceArea.IsNull())then
			var ^CRegionMgr pxRM=^(CSrvWrap.GetRegionMgr());
			var int iTol = pxRM^.CreateRegion(GetName()+"_ToleranceArea",CSubRegion.RT_Oval,GetPos(),{80.0f,80.0f,0.0f});
			m_pxToleranceArea=pxRM^.GetRegion(iTol);
			m_xToleranceArea=m_pxToleranceArea^.GetGUID();
			m_pxToleranceArea^.SetColor({{161,127,255,255}});
			m_pxToleranceArea^.SetAnimalsOnly();
		endif;
		return m_pxToleranceArea;
	endproc;
	
	proc bool SpawnAnimal()
		var CObjHndl xRet;
		var bool bBaby;
		if(m_bSpawnGrown)then
			return SpawnAnimal(CTimeMgr.Get().GetVirtualTime()-CTimeMgr.Get().GetVirtualDayLength()*2.0f,xRet,bBaby);
		endif;
		return SpawnAnimal(CTimeMgr.Get().GetVirtualTime(),xRet,bBaby);
	endproc;
	
	export proc bool SpawnAnimal(real p_fVirtualBirthTime,ref CObjHndl po_rxAnimal,ref bool po_rbBaby)
		if(m_bExt)then return false; endif;
		var ^CAttribs pxAttribs=GetAttribs();
		var int iSpawnAmount=pxAttribs^.GetValueInt("spawn_amount");
		if(iSpawnAmount==0)then
			KLog.LogError("Nest","spawn amount ==0, can't spawn new animal");
			return false;
		endif;
		var string sSpawnType=pxAttribs^.GetValue("spawn_type");
		var ^CObjMgrHost pxObjMgr=CSrvWrap.GetObjMgr();
		var ^CGameObj pxTmp=pxObjMgr^.CreateObj(sSpawnType,GetOwner(),GetPos());
		if(pxTmp==null)then
			KLog.LogError("Nest","spawn type "+sSpawnType+" not found");
			return false;
		endif;
		var ^CAnimal pxBaby=cast<CAnimal>(pxTmp);
		if(pxBaby==null)then
			KLog.LogError("Nest","spawn type "+sSpawnType+" is not of type ANML");
			return false;
		endif;
		pxBaby^.SetActAutonomous(m_bSpawnUninfluenced);
		po_rxAnimal=pxBaby^.GetHandle();
		//L KLog.LogInfo("Nest","neues tier '"+sSpawnType+"' erzeugt");
		po_rbBaby=pxBaby^.Birth(GetHandle(),p_fVirtualBirthTime);
		var vec3 vPos=pxBaby^.GetPos();
		CSrvWrap.GetObjMgr()^.GetFreePos(vPos,pxBaby,vPos,null,true,false,false);
		vPos.SetZ(Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vPos.GetX(),vPos.GetY()),CSrvWrap.GetScapeMgr().GetSeaLevel()));
		pxBaby^.SetPos(vPos);
		// find friend nest and join it's flock if present, or create new one
		begin Flocking;
			if((!m_xFlock.IsValid())&&(m_pxSafeArea!=null))then
				var CObjQuery xOQ;
				xOQ.SetType("NEST");
				xOQ.SetRegion(m_pxSafeArea^.GetHandle());
				xOQ.Exclude(GetHandle());
				var CObjList xNests;
				if(xOQ.Execute(xNests))then
					var int i,iC=xNests.NumEntries();
					for(i=0)cond(i<iC)iter(i++)do
						var ^CNest pxWalk=cast<CNest>(xNests[i].GetObj());
						if(pxWalk==null)then continue; endif;
						if(pxWalk^.m_xFlock.IsValid())then
							m_xFlock=pxWalk^.m_xFlock;
							break;
						endif;
					endfor;
				endif;
			endif;
			if(!m_xFlock.IsValid())then
				var ^CGameObj pxObj=CSrvWrap.GetObjMgr()^.CreateObj("Flock",GetOwner());
				if(pxObj!=null)then
					m_xFlock=pxObj^.GetHandle();
					//L CSrvWrap.LogSpam("Nest","new flock created");
				else
					CSrvWrap.LogError("Nest","create flock failed");
				endif;
			endif;
			var ^CFlock pxFlock=cast<CFlock>(m_xFlock.GetObj());
			if(pxFlock!=null)then
				pxFlock^.AddMember(po_rxAnimal);
			endif;
		end Flocking;
		m_xAnimals.Include(po_rxAnimal);
		if(iSpawnAmount!=-1)then
			pxAttribs^.SetValue("spawn_amount",iSpawnAmount-1);
		endif;
		return true;
	endproc;
	
	proc void UpdateFlockPos()
		m_vFlockPos=GetPos();
		if(!GetRandomPointInHotspot(m_vFlockPos,true))then
			var int iNumAnmls=m_xAnimals.NumEntries();
			if(iNumAnmls<1)then
				if((m_pxActionArea!=null) && (m_pxActionArea^.NumSubs()>0))then
					m_vFlockPos=m_pxActionArea^.GetRandomPointInside();
				endif;
			else
				var ^CAnimal pxAnml=cast<CAnimal>((m_xAnimals[0]).GetObj());
				if(pxAnml==null)then return; endif;
				if(!pxAnml^.IsSleepTime())then
					if((m_pxActionArea!=null) && (m_pxActionArea^.NumSubs()>0))then
						m_vFlockPos=m_pxActionArea^.GetRandomPointInside();
					endif;
				else
					if((m_pxSafeArea!=null) && (m_pxSafeArea^.NumSubs()>0))then
						m_vFlockPos=m_pxSafeArea^.GetRandomPointInside();
					endif;
				endif;
			endif;
		endif;
//		KLog.LogSpam("MaMa",GetName()+" new FlockPos: "+m_vFlockPos.ToString());
		begin NotifyAnimals;
		// KLog.LogSpam("MaZi", "Notify Animals");
			var int i,iC=m_xAnimals.NumEntries();
			for(i=0)cond(i<iC)iter(++i)do
				var ^CAnimal pxAnml=cast<CAnimal>((m_xAnimals[i]).GetObj());
				if(pxAnml!=null)then
					//KLog.LogSpam("MaZi", "-> "+pxAnml^.GetName());
					var vec3 vPos;
					GetRandomPoint(vPos,pxAnml^.IsBaby());
					pxAnml^.SetNextWalkTarget(vPos);
				endif;
			endfor;
		end NotifyAnimals;
	endproc;
	
	proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==TIMER_SPAWN)then
				var ^CAttribs pxAttribs=GetAttribs();
				//L CSrvWrap.LogInfo("Nest","timer");
				var int iSpawnAmount=pxAttribs^.GetValueInt("spawn_amount");
				if(iSpawnAmount==0)then
					//KLog.LogInfo("MaZi","keine Tiere mehr zum produzieren");
					DeleteTimer(TIMER_SPAWN);
				else
					var int iSpawnMax=pxAttribs^.GetValueInt("spawn_max")+m_iGrowSize;
					if(m_xAnimals.NumEntries()<iSpawnMax && !m_bInactive)then
						SpawnAnimal();
					endif;
					if((m_xAnimals.NumEntries())>=iSpawnMax)then
						//L KLog.LogInfo("Nest","spawn max erreicht");
						DeleteTimer(TIMER_SPAWN);//stoppt den timer
					endif;
				endif;
				return;
			elseif(p_rxEvtPtr.GetInt(0)==TIMER_CHECK_AREA)then
				//auskommentiert durch CHP
				//Every Animal outside the Action Area starts every 2 seconds a new Walk Action !?!?
				//this caused RT#11313
				//wieder einkommentiert durch AnTr
				//siehe RT#13644
				/**/
				if(m_pxActionArea!=null)then
					var int i,iC=m_xAnimals.NumEntries();
					for(i=0)cond(i<iC)iter(i++)do
						var ^CAnimal pxAnml=cast<CAnimal>((m_xAnimals[i]).GetObj());
						if(pxAnml==null)then continue; endif;
						if(!m_pxActionArea^.IsInside(pxAnml^.GetPos()))then
							var bool bWalkInArea=false;
							begin FIX_RT_11313;
								var ^CWalkToPos pxCurWalkTask=cast<CWalkToPos>(pxAnml^.GetCurTask());
								if(pxCurWalkTask!=null)then
									var vec3 vTargetPos=pxCurWalkTask^.GetTargetPos();
									if(IsInActionArea(vTargetPos)||IsInSafeArea(vTargetPos))then
										bWalkInArea=true;
									endif;
								endif;
							end FIX_RT_11313;
							if(!bWalkInArea && !pxAnml^.IsFleeing() && !m_bInactive)then
//							if(!bWalkInArea && !pxAnml^.IsInFight() && !m_bInactive)then
								if(pxAnml^.IsInFight()&&m_pxToleranceArea^.IsInside(pxAnml^.GetPos()))then return; endif; // Henry: tolerate fighting in a bigger radius
								var vec3 vPos;
								GetRandomPoint(vPos,pxAnml^.IsBaby());
								CSrvWrap.GetObjMgr()^.GetFreePos(vPos,pxAnml,vPos,null,true,false,false);
									// Henry: SEK...
//								pxAnml^.GoTo(vPos, false, GetDefaultSpeed(), true, true);
								pxAnml^.GoTo(vPos, false, pxAnml^.GetMaxSpeed(), true, true);
//								pxAnml^.GoTo(vPos, false, pxAnml^.GetDefaultSpeed(), true, true);
							endif;
						endif;
					endfor;
				endif;
				return;
				/**/
			elseif(p_rxEvtPtr.GetInt(0)==TIMER_UPDATEPOS)then
				UpdateFlockPos();
			elseif(p_rxEvtPtr.GetInt(0)==NEST_RESPAWN)then
//				CSrvWrap.SendGenericEvtToPlayer(0, "MiniMapAttack\t"+GetPos().ToString()+"\tAttack");
				var CObjList xList;
				var CObjQuery xQuery;
				xQuery.SetOwner(-1, true);
				xQuery.SetType("ANML");
				xQuery.SetType("BLDG",true);
				xQuery.SetType("CHTR",true);
				xQuery.SetType("FGHT",true);
				xQuery.SetType("NEST",true);
				xQuery.SetType("SHIP",true);
				xQuery.SetType("VHCL",true);
				xQuery.RegionCircle(GetPos(), 8.0f);
				xQuery.Exclude(GetHandle());
				xQuery.Exclude(m_xAnimals,true);
				xQuery.Execute(xList);
				if(xList.NumEntries() <= 0)then
					m_bInactive=false;
//					SetVisibleMask(m_dwVisMask);
					SetVisible(m_bPrevVisible);
					SetSelectable(m_bPrevSelectable);
					SetHitable(m_bPrevHitable);
					SetPlaceBlocker(true);
//					SetDead(false);
					if(GetClassName()=="Nest_Mammal_Cave"||GetClassName()=="nest_ice_mammal_cave")then
						CSrvWrap.GetPathfinder().AddPFBlocker(this);
					endif;
					UpdateAgilityTimer();
					StartTimer();
					if(!HasTimer(TIMER_CHECK_AREA))then
						CreateTimer(TIMER_CHECK_AREA,CGameTimeSpan.OneSecond()*2.0f,true);
					endif;
//					if(HasTimer(NEST_RESPAWN))then DeleteTimer(NEST_RESPAWN); endif;
				else
					CreateTimer(NEST_RESPAWN, CGameTimeSpan.OneSecond() * 60.0f, false); //Henry: try again after a minute
				endif;
			endif;
		endif;
		super.HandleEvent(p_rxEvtPtr);
	endproc;
	
	proc void OnDefend(^CGameObj p_pxEnemy)
		OnDefend(p_pxEnemy,this);
	endproc;
	
	export proc void ShoutForHelp(bool p_bForced)
		//dont shout for help, see OnDefend() below for defending techniques
	endproc;
	
	proc void OnDefend(^CGameObj p_pxEnemy,^CGameObj p_pxVictim)
		if(p_pxEnemy==null)then return; endif;
		var int i,iC=m_xAnimals.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CAnimal pxWalk=cast<CAnimal>(m_xAnimals[i].GetObj());
			if(pxWalk!=null && !pxWalk^.IsBaby())then
				if((p_pxVictim==null)||(pxWalk^.CanSee(p_pxVictim)))then
					if(!pxWalk^.IsInFight())then
						pxWalk^.Fight(p_pxEnemy, p_pxEnemy^.GetPos(), false, false);
					endif;
				endif;
			endif;
		endfor;
	endproc;
	
	//tier stirbt
	export proc void DieAnimal(CObjHndl p_xAnimal)
		m_xAnimals.RemEntry(p_xAnimal);
		StartTimer();
	endproc;
	
	export proc void Die()
		super.Die();
	endproc;
	
	export proc void Delete()
		var ^CAttribs pxAttr=GetAttribs();
		if(CMirageSrvMgr.Get().NestRespawn() && GetTribeName()=="World"&&pxAttr!=null&&pxAttr^.GetValueInt("no_respawn")==0)then
			if((m_pxHotspotArea==null)||(m_pxSafeArea==null)||(m_pxActionArea==null)||(m_pxToleranceArea==null))then
				super.Delete();
				return;
			endif;
			var int iCounter=0, iMax=20;
			var real fRadius=10.0f;
			if(m_pxSafeArea!=null)then
				fRadius=m_pxSafeArea^.GetRadius();
			endif;
			var vec3 vNewNest, vOldNest=GetPos();
			vNewNest=vOldNest;
			while(iCounter<iMax)do
				if(m_pxSafeArea==null)then
					vNewNest=vOldNest;
					break;
				endif;
				iCounter++;
				vNewNest=m_pxSafeArea^.GetRandomPointInside();
				var bool bOkay=GetFreePos(vNewNest,fRadius);
				bOkay=bOkay&&m_pxSafeArea^.IsInside(vNewNest);
				if(bOkay)then
					vNewNest.SetZ(Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vNewNest.GetX(),vNewNest.GetY()),CSrvWrap.GetScapeMgr().GetSeaLevel()));
					break;
				elseif(iCounter>=iMax)then
					vNewNest=vOldNest;
					break;
				endif;
			endwhile;
			var ^CNest pxNewNest=cast<CNest>(CSrvWrap.GetObjMgr()^.CreateObj(GetClassName(),GetOwner(),vNewNest,GetRotation()));
			if(pxNewNest!=null)then
//				m_bInactive=true;
				if(HasTimer(NEST_RESPAWN))then DeleteTimer(NEST_RESPAWN); endif;
				if(HasTimer(TIMER_SPAWN))then DeleteTimer(TIMER_SPAWN); endif;
				if(HasTimer(TIMER_UPDATEPOS))then DeleteTimer(TIMER_UPDATEPOS); endif;
				if(HasTimer(TIMER_CHECK_AREA))then DeleteTimer(TIMER_CHECK_AREA); endif;
				pxNewNest^.SetHitable(false);
				pxNewNest^.SetVisible(false);
				pxNewNest^.DeleteOwnRegions();
				var string sSpawnType,sTimeTable;
				var int iSpawnMax;
				var real fSpawnRate;
				var ^CAttribs pxAttribs=GetAttribs();
				if(pxAttribs!=null)then
					sSpawnType=pxAttribs^.GetValue("spawn_type");
					sTimeTable=pxAttribs^.GetValue("hotspot_timetable");
					iSpawnMax=pxAttribs^.GetValueInt("spawn_max");
					fSpawnRate=pxAttribs^.GetValueFloat("spawn_rate");
				endif;
				pxNewNest^.Inherit(m_xActionArea,m_xSafeArea,m_xHotspotArea,m_xToleranceArea,sSpawnType,sTimeTable,iSpawnMax,fSpawnRate,m_xAnimals,IsHitable(),GetVisibleMask()!=0h,IsSelectable(),GetVisibleMask());
			endif;
		endif;
		super.Delete();
	endproc;
	
	export proc void StartTimer()
		if(CMirageSrvMgr.SDK())then return; endif;
		if(HasTimer(TIMER_SPAWN))then return; endif;
		var ^CAttribs pxAttribs=GetAttribs();
		var real fSpawnRate=pxAttribs^.GetValueFloat("spawn_rate");
		CreateTimer(TIMER_SPAWN,CGameTimeSpan.OneSecond()*fSpawnRate,true);
	endproc;
	
	proc void UpdateAgilityTimer()
		DeleteTimer(TIMER_UPDATEPOS);
		var real fAgility=m_fFlockAgility;
		if(fAgility<=0.0f)then
			fAgility=30.0f;
		endif;
//		KLog.LogSpam("MaMa",GetName()+" starts agility timer "+fAgility.ToString());
		CreateTimer(TIMER_UPDATEPOS,CGameTimeSpan.OneSecond()*fAgility,true);
	endproc;
	
	export proc bool BelongsToNest(CObjHndl p_xAnimal)
		return (m_xAnimals.FindEntry(p_xAnimal)!=-1);
	endproc;
	
	export proc void AnimalAttacked(^CAnimal p_pxVictim, ^CFightingObj p_pxEnemy)
		if(p_pxVictim^.IsBaby())then
			OnDefend(p_pxEnemy,p_pxVictim);
		endif;
	endproc;
	
	export proc bool ChangeSpawnAmount(int p_iNewNumber)
		m_iGrowSize=p_iNewNumber;
		StartTimer();
		return true;
	endproc;
	
	export proc void Damage(real p_fDamage)
		if(m_bInactive)then
			return;
		else
			super.Damage(p_fDamage);
		endif;
	endproc;
	
	export proc void PoisonDamage(real p_fDamage, CObjHndl p_xEnemy, int p_iEnemy)
		if(m_bInactive)then
			return;
		endif;
		return super.PoisonDamage(p_fDamage, p_xEnemy, p_iEnemy);
	endproc;
	
	export proc void BurnDamage(real p_fDamage, CObjHndl p_xEnemy, int p_iEnemy)
		if(m_bInactive)then
			return;
		endif;
		return super.BurnDamage(p_fDamage, p_xEnemy, p_iEnemy);
	endproc;
	
	export proc void ChainDamage(real p_fDamage, int p_iLast, CObjHndl p_xLast)
		if(m_bInactive)then
			return;
		endif;
		return super.ChainDamage(p_fDamage, p_iLast, p_xLast);
	endproc;
	
	export proc void WoundDamage(real p_fDamage, CObjHndl p_xLE, int p_iLE)
		if(m_bInactive)then
			return;
		endif;
		return super.BurnDamage(p_fDamage, p_xLE, p_iLE);
	endproc;
	
	export proc void Extermination()
		m_bExt=true;
		var int i, iC=m_xAnimals.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(!m_xAnimals[i].IsValid())then continue; endif;
			var ^CFightingObj pxA=cast<CFightingObj>(m_xAnimals[i].GetObj());
			if(pxA==null)then continue; endif;
			pxA^.DiePerHarakiri();
		endfor;
		if(m_xFlock.IsValid())then
			m_xFlock.GetObj()^.Delete();
		endif;
	endproc;
	
	export proc void DeleteOwnRegions()
		var ^CRegionMgr pxRM=^(CSrvWrap.GetRegionMgr());
		pxRM^.DeleteRegion(m_xActionArea);
		pxRM^.DeleteRegion(m_xSafeArea);
		pxRM^.DeleteRegion(m_xHotspotArea);
		pxRM^.DeleteRegion(m_xToleranceArea);
	endproc;
	
	export proc void Inherit(CGuid p_xAction, CGuid p_xSafe, CGuid p_xHot, CGuid p_xTolerance, string p_sSpawn, string p_sTimetable, int p_iSpawn, real p_fSpawn, CObjList p_xAnimals, bool p_bHitable, bool p_bVisible, bool p_bSelectable, bitset p_dwMask)
//		SetDead(true);
//		SetVisible(false);
//		SetHitable(false);
		m_bInactive=true;
		m_dwVisMask=p_dwMask;
		m_bPrevHitable=p_bHitable;
		m_bPrevVisible=p_bVisible;
		m_bPrevSelectable=p_bSelectable;
		var ^CRegionMgr pxRM=^(CSrvWrap.GetRegionMgr());
		m_xActionArea=p_xAction;
		m_xSafeArea=p_xSafe;
		m_xHotspotArea=p_xHot;
		m_xToleranceArea=p_xTolerance;
		m_pxActionArea=pxRM^.GetRegionByGuid(p_xAction);
		m_pxSafeArea=pxRM^.GetRegionByGuid(p_xSafe);
		m_pxHotspotArea=pxRM^.GetRegionByGuid(p_xHot);
		m_pxToleranceArea=pxRM^.GetRegionByGuid(p_xTolerance);
		var ^CAttribs pxAttribs=GetAttribs();
		if(pxAttribs!=null)then
			pxAttribs^.SetValue("spawn_type",p_sSpawn);
			pxAttribs^.SetValue("hotspot_timetable",p_sTimetable);
			pxAttribs^.SetValue("spawn_max",p_iSpawn);
			pxAttribs^.SetValue("spawn_amount",-1);
			pxAttribs^.SetValue("spawn_rate",p_fSpawn);
		endif;
		m_xFlock=CObjHndl.Invalid();
//		m_xFlock=p_xFlock;
		p_xAnimals.Validate();
		if(p_xAnimals.NumEntries()>0)then
			m_xAnimals=p_xAnimals;
		endif;
		var int i,iC=m_xAnimals.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(m_xAnimals[i].IsValid())then
				var ^CAnimal pxTier=cast<CAnimal>(m_xAnimals[i].GetObj());
				if(pxTier!=null)then
					pxTier^.UpdateNest(GetHandle());
				endif;
			endif;
		endfor;
//		UpdateFlockPos();
		SetPlaceBlocker(false);
		CSrvWrap.GetPathfinder().RemPFBlocker(this);
		if(HasTimer(NEST_RESPAWN))then DeleteTimer(NEST_RESPAWN); endif;
		if(HasTimer(TIMER_SPAWN))then DeleteTimer(TIMER_SPAWN); endif;
//		if(HasTimer(TIMER_UPDATEPOS))then DeleteTimer(TIMER_UPDATEPOS); endif;
		if(HasTimer(TIMER_CHECK_AREA))then DeleteTimer(TIMER_CHECK_AREA); endif;
//		SetPlaceBlocker(!m_bInactive);
		Random.Seed();
		CreateTimer(NEST_RESPAWN, CGameTimeSpan.OneSecond() * (Random.MTRandF(RESPAWN_DURATION*0.75f, RESPAWN_DURATION*1.5f)), false);
//		CreateTimer(NEST_RESPAWN, CGameTimeSpan.OneSecond() * 25.0, false);
	endproc;
	
	export proc void PlayerRevealed(bool p_bYes)
		return;
	endproc
	
	export proc void HandleEditorCommand(string p_sCommand,^CGameObj p_pxObject,vec3 p_vPos,string p_sMiscParams)
		if(CMirageSrvMgr.SDK())then
			if(p_sCommand=="StoreTmpPos")then
				// Henry: for regions' position shifting
//				m_vTmp=GetPos();
				m_vTmp=p_vPos;
			elseif(p_sCommand=="TranslatePos")then
				// Henry: translate all regions to the new position
				if(p_vPos==m_vTmp)then return; endif;
//				var vec3 vMe=GetPos();
//				var vec3 vOffset;
//				vOffset.SetXYZ(vMe.GetX()-m_vTmp.GetX(),vMe.GetY()-m_vTmp.GetY(),0.0f);
				var vec3 vOffset=p_vPos-m_vTmp;
				vOffset.SetZ(0.0f);
				var array ^CRegion apxRegions;
				apxRegions.AddEntry(m_pxActionArea);
				apxRegions.AddEntry(m_pxSafeArea);
				apxRegions.AddEntry(m_pxHotspotArea);
				apxRegions.AddEntry(m_pxToleranceArea);
				var int k, kC=apxRegions.NumEntries();
				for(k=0)cond(k<kC)iter(k++)do
					var ^CRegion pxR=apxRegions[k];
					if(pxR!=null)then
						pxR^.SetRendering(false);
						pxR^.SetSelected(false);
						var int i, iC = pxR^.NumSubs();
						for(i=0)cond(i<iC)iter(i++)do
							var ^CSubRegion pxSub = pxR^[i];
							if(pxSub!=null)then
								pxSub^.SetSelected(false);
								pxSub^.SetEditMode(false);
								pxSub^.Translate(vOffset);
								pxSub^.SetSelected(false);
								pxSub^.SetEditMode(false);
							endif;
						endfor;
						pxR^.SetSelected(false);
						pxR^.SetRendering(false);
					endif;
				endfor;
//				if(m_pxActionArea!=null)then
//					m_pxActionArea^.Translate(vOffset);
//				endif;
//				if(m_pxSafeArea!=null)then
//					m_pxSafeArea^.Translate(vOffset);
//				endif;
//				if(m_pxHotspotArea!=null)then
//					m_pxHotspotArea^.Translate(vOffset);
//				endif;
				m_vTmp=GetPos();
			elseif(p_sCommand=="SimpleRegionCopy")then
				if(p_pxObject==null)then return; endif;
				var ^CNest pxNest=cast<CNest>(p_pxObject);
				if(pxNest==null||pxNest^.GetHandle()==GetHandle())then return; endif;
				var array string asParams;
				p_sMiscParams.Split(asParams,":",true);
				if(asParams.NumEntries()!=4)then return; endif;
				var bool bColor=asParams[0]=="1", bEnable=asParams[1]=="1", bClear=asParams[2]=="1";
				var int iClass=asParams[3].ToInt();
				if(iClass==7)then
					CopyArea(0,pxNest,bColor,bEnable,bClear,false,-1,-1);
					CopyArea(1,pxNest,bColor,bEnable,bClear,false,-1,-1);
					CopyArea(2,pxNest,bColor,bEnable,bClear,false,-1,-1);
					CopyArea(3,pxNest,bColor,bEnable,bClear,false,-1,-1);
				elseif(iClass==6)then
					CopyArea(0,pxNest,bColor,bEnable,bClear,false,-1,-1);
					CopyArea(1,pxNest,bColor,bEnable,bClear,false,-1,-1);
					CopyArea(3,pxNest,bColor,bEnable,bClear,false,-1,-1);
				elseif(iClass==5)then
					CopyArea(0,pxNest,bColor,bEnable,bClear,false,-1,-1);
					CopyArea(3,pxNest,bColor,bEnable,bClear,false,-1,-1);
				elseif(iClass==4)then
					CopyArea(0,pxNest,bColor,bEnable,bClear,false,-1,-1);
					CopyArea(1,pxNest,bColor,bEnable,bClear,false,-1,-1);
				else
					CopyArea(iClass,pxNest,bColor,bEnable,bClear,false,-1,-1);
				endif;
			elseif(p_sCommand=="CloneFlipRotatetMove")then
				if(p_pxObject==null)then return; endif;
				var ^CNest pxNest=cast<CNest>(p_pxObject);
				if(pxNest==null||pxNest^.GetHandle()==GetHandle())then return; endif;
				var array string asParams;
				p_sMiscParams.Split(asParams,":",true);
				if(asParams.NumEntries()!=6)then return; endif;
				var bool bColor=asParams[0]=="1", bEnable=asParams[1]=="1", bClear=asParams[2]=="1";
				var int iClass=asParams[3].ToInt();
				var int iAngle=asParams[4].ToInt();
				var int iAxis=asParams[5].ToInt();
				if(iClass==7)then
					CopyArea(0,pxNest,bColor,bEnable,bClear,true,iAngle,iAxis);
					CopyArea(1,pxNest,bColor,bEnable,bClear,true,iAngle,iAxis);
					CopyArea(2,pxNest,bColor,bEnable,bClear,true,iAngle,iAxis);
					CopyArea(3,pxNest,bColor,bEnable,bClear,true,iAngle,iAxis);
				elseif(iClass==6)then
					CopyArea(0,pxNest,bColor,bEnable,bClear,true,iAngle,iAxis);
					CopyArea(1,pxNest,bColor,bEnable,bClear,true,iAngle,iAxis);
					CopyArea(3,pxNest,bColor,bEnable,bClear,true,iAngle,iAxis);
				elseif(iClass==5)then
					CopyArea(0,pxNest,bColor,bEnable,bClear,true,iAngle,iAxis);
					CopyArea(3,pxNest,bColor,bEnable,bClear,true,iAngle,iAxis);
				elseif(iClass==4)then
					CopyArea(0,pxNest,bColor,bEnable,bClear,true,iAngle,iAxis);
					CopyArea(1,pxNest,bColor,bEnable,bClear,true,iAngle,iAxis);
				else
					CopyArea(iClass,pxNest,bColor,bEnable,bClear,true,iAngle,iAxis);
				endif;
			elseif(p_sCommand=="ClearSubs")then
				var array ^CRegion apxRegions;
				switch(p_sMiscParams.ToInt())
					case(0)do apxRegions.AddEntry(m_pxActionArea); endcase;
					case(1)do apxRegions.AddEntry(m_pxSafeArea); endcase;
					case(2)do apxRegions.AddEntry(m_pxHotspotArea); endcase;
					case(3)do apxRegions.AddEntry(m_pxToleranceArea); endcase;
					case(4)do
						apxRegions.AddEntry(m_pxActionArea);
						apxRegions.AddEntry(m_pxSafeArea);
					endcase;
					case(5)do
						apxRegions.AddEntry(m_pxActionArea);
						apxRegions.AddEntry(m_pxToleranceArea);
					endcase;
					case(6)do
						apxRegions.AddEntry(m_pxActionArea);
						apxRegions.AddEntry(m_pxSafeArea);
						apxRegions.AddEntry(m_pxToleranceArea);
					endcase;
					case(7)do
						apxRegions.AddEntry(m_pxActionArea);
						apxRegions.AddEntry(m_pxSafeArea);
						apxRegions.AddEntry(m_pxHotspotArea);
						apxRegions.AddEntry(m_pxToleranceArea);
					endcase;
					case default do return; endcase;
				endswitch;
				var int k, kC=apxRegions.NumEntries();
				for(k=0)cond(k<kC)iter(k++)do
					if(apxRegions[k]!=null)then
						apxRegions[k]^.Clear();
					endif;
				endfor;
			elseif(p_sCommand=="TransferAttribs")then
				if(p_pxObject!=null)then
					var ^CNest pxNest=cast<CNest>(p_pxObject);
					if(pxNest==null||pxNest^.GetHandle()==GetHandle())then return; endif;
					var string sOwn=GetClassName(), sOther=pxNest^.GetClassName();
					if(sOwn!=sOther&&!((sOwn=="Nest_Mammal_Cave"&&sOther=="nest_ice_mammal_cave")||(sOwn=="nest_ice_mammal_cave"&&sOther=="Nest_Mammal_Cave")))then return; endif;
					var array string asParams;
					p_sMiscParams.Split(asParams,":",true);
					if(asParams.NumEntries()!=3)then return; endif;
					var bool bVisible=asParams[0]=="1", bHitable=asParams[1]=="1", bSelectable=asParams[2]=="1";
					SetVisible(bVisible); SetHitable(bHitable); SetSelectable(bSelectable);
					var ^CAttribs pxAOwn=GetAttribs(), pxASub=pxNest^.GetAttribs();
					if(pxAOwn!=null&&pxASub!=null)then
						pxAOwn^.SetValue("spawn_type",pxASub^.GetValue("spawn_type"));
						pxAOwn^.SetValue("spawn_amount",pxASub^.GetValueInt("spawn_amount"));
						pxAOwn^.SetValue("spawn_max",pxASub^.GetValueInt("spawn_max"));
						pxAOwn^.SetValue("spawn_rate",pxASub^.GetValueFloat("spawn_rate"));
						pxAOwn^.SetValue("advance_time",pxASub^.GetValueFloat("advance_time"));
					endif;
				endif;
			else
				super.HandleEditorCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams);
			endif;
		else
			super.HandleEditorCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams);
		endif;
	endproc;
	
	export proc bool CopyArea(int p_iArea, ^CNest p_pxNest, bool p_bColor, bool p_bEnable, bool p_bClear, bool p_bCFRM, int p_iAngle, int p_iAxis)
//		if(p_pxObject==null)then return false; endif;
//		var ^CNest pxNest=cast<CNest>(p_pxObject);
//		if(pxNest==null||pxNest^.GetHandle()==GetHandle())then return false; endif;
		var ^CRegion pxRegionOwn=null, pxRegionOther=null;
		switch(p_iArea)
			case(0)do
				pxRegionOwn=m_pxActionArea;
				pxRegionOther=p_pxNest^.GetActionAreaPtr();
			endcase;
			case(1)do
				pxRegionOwn=m_pxSafeArea;
				pxRegionOther=p_pxNest^.GetSafeAreaPtr();
			endcase;
			case(2)do
				pxRegionOwn=m_pxHotspotArea;
				pxRegionOther=p_pxNest^.GetHotspotAreaPtr();
			endcase;
			case(3)do
				pxRegionOwn=m_pxToleranceArea;
				pxRegionOther=p_pxNest^.GetToleranceAreaPtr();
			endcase;
			case default do return false; endcase;
		endswitch;
		if((p_bClear||p_iArea==2)&&pxRegionOwn!=null)then
			// Henry: in the case of hotspot area, better to remove the previous subregions under all circumstances
			pxRegionOwn^.Clear();
		endif;
		var string sHotspot;
		if(p_iArea==2)then
			var ^CAttribs pxAOwn=GetAttribs(), pxASub=p_pxNest^.GetAttribs();
			if(pxAOwn!=null&&pxASub!=null)then
				sHotspot=pxASub^.GetValue("hotspot_timetable");
				pxAOwn^.SetValue("hotspot_timetable",sHotspot);
			endif;
		endif;
		CopySubRegions(pxRegionOwn,pxRegionOther,p_bColor,p_bEnable,p_bCFRM,p_iAngle,p_iAxis,p_pxNest^.GetPos());
		if(sHotspot!="")then
			m_xHotspotTimeTable.FromString(sHotspot);
		endif;
		return true;
	endproc;
	
	export proc bool CopySubRegions(^CRegion p_pxOwn, ^CRegion p_pxOther, bool p_bColor, bool p_bEnable, bool p_bCFRM, int p_iAngle, int p_iAxis, vec3 p_vSource)
		if(p_pxOwn==null||p_pxOther==null)then return false; endif;
		var int k, kC=p_pxOther^.NumSubs();
		for(k=0)cond(k<kC)iter(k++)do
			var ^CSubRegion pxSub = p_pxOther^[k];
			if(pxSub!=null)then
				var vec3 vExt, vSub=pxSub^.GetPos();
				var string sPos=pxSub^.ToString();
				sPos=sPos.Mid(sPos.Find("Ext: ")+5);
				vExt.FromString(sPos);
				if(p_bCFRM)then
					vSub=GetNewPos(p_vSource,vSub,p_iAngle,p_iAxis);
				endif;
				if(p_iAngle==1||p_iAngle==3)then
					vExt.SetXYZ(vExt.GetY()/2.0f, vExt.GetX()/2.0f, 0.0f);
				else
					vExt.SetXYZ(vExt.GetX()/2.0f, vExt.GetY()/2.0f, 0.0f);
				endif;
				// Henry: for some fucked up reasons creating the subregion with the previous type from the get go causes size problems with rectangular subregions
				var int iIdx=p_pxOwn^.AddSubRegion(CSubRegion.RT_Oval,vSub,vExt);
				if(iIdx!=-1)then
					p_pxOwn^[iIdx]^.SetType(pxSub^.GetType());
					if(p_bEnable)then
						p_pxOwn^[iIdx]^.SetEnable(pxSub^.GetEnable());
					endif;
				endif;
			endif;
		endfor;
		if(p_bColor)then
			p_pxOwn^.SetColor(p_pxOther^.GetColor());
		endif;
		if(p_bEnable)then
			p_pxOwn^.SetEnable(p_pxOther^.GetEnable());
		endif;
		return true;
	endproc;
	
	proc vec3 GetNewPos(vec3 p_vNest, vec3 p_vSub, int p_iRot, int p_iAxis)
		var vec3 vReturn, vMe=GetPos();
		var vec3 vDir=p_vSub-p_vNest;
		var real fDist= vDir.Abs();
		vDir.Normalize();
		switch(p_iAxis)
			case(1)do vDir.SetXYZ(vDir.GetX()*-1.0f,vDir.GetY(),vDir.GetZ()); endcase;
			case(2)do vDir.SetXYZ(vDir.GetX(),vDir.GetY()*-1.0f,vDir.GetZ()); endcase;
			case default do endcase;
		endswitch;
		switch(p_iRot)
			case(1)do vDir.SetXYZ(vDir.GetY()*-1.0f,vDir.GetX(),vDir.GetZ()); endcase;
			case(2)do vDir.SetXYZ(vDir.GetX()*-1.0f,vDir.GetY()*-1.0f,vDir.GetZ()); endcase;
			case(3)do vDir.SetXYZ(vDir.GetY(),vDir.GetX()*-1.0f,vDir.GetZ()); endcase;
			case default do endcase;
		endswitch;
		vReturn=vMe+vDir*fDist;
		return vReturn;
	endproc;
	
	export proc bool NewRegions(int p_iID, array vec3 p_avPos, array vec3 p_avExt, array bool p_abEnable, array bitset p_adwType)
		var ^CRegion pxRegion=null;
		switch(p_iID)
			case(0)do
				pxRegion=m_pxActionArea;
			endcase;
			case(1)do
				pxRegion=m_pxSafeArea;
			endcase;
			case(2)do
				pxRegion=m_pxHotspotArea;
			endcase;
			case(3)do
				pxRegion=m_pxToleranceArea;
			endcase;
			case default do return false; endcase;
		endswitch;
		if(pxRegion==null)then return false; endif;
		pxRegion^.Clear();
		var int k, kC=p_abEnable.NumEntries();
		for(k=0)cond(k<kC)iter(k++)do
			var vec3 vNewExt=p_avExt[k];
			vNewExt.SetXYZ(vNewExt.GetX()/2.0f, vNewExt.GetY()/2.0f, 0.0f);
			var int iIdx=pxRegion^.AddSubRegion(CSubRegion.RT_Oval,p_avPos[k],vNewExt);
			if(iIdx!=-1)then
				pxRegion^[iIdx]^.SetType(p_adwType[k]);
				pxRegion^[iIdx]^.SetEnable(p_abEnable[k]);
			endif;
		endfor;
		return true;
	endproc;
	
endclass;
	
class CSwimmingNest inherit CNest
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
	
		var vec3 vPos=GetPos();
		vPos.SetZ(CSrvWrap.GetScapeMgr().GetSeaLevel());
		SetPos(vPos);
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel^.IsEditable())then
			SetVisible(true);
			SetSelectable(true);
		else
			SetVisible(false);
			SetSelectable(false);
		endif;
	endproc;
	
endclass;
