
/*?
	?group URS.Scripts.Server.Classes
	?item CAnimal
	?desc class for Animals in game
	?prefix CAnimal
?*/
class CAnimal inherit CTransportObj
	
	//Fight stuff
	const int						TIMER_FATIGUE = 7711;
	var real						m_fFatigue;
	var CObjQuery				m_xEnemySearch; ///< used only for wild animals (GetOwner()==-1)
	var CObjHndl				m_xLastOnAttackChecked;
	
	//Special move stuff
	const real					RAGE_DURATION=30.0;
	const real					BRACH_RAGE_DURATION=60.0;
	export const int		TIMER_RAGETO=7811;
	var CFourCC					m_xRageWalkSet;
	var CGameTime				m_xRageStart;
	
	//Idle stuff
	const int						AGILITY_TIMER = 2403;
	var CGameTime				m_xIdleStart;
	var int							m_iPerformanceTimeOut;
	var bool						m_bActAutonomous;
	var vec3						m_vNextWalkTarget;		///< if not clear, position of next walk
	
	//Nest stuff
	export var CObjHndl		m_xNest;
	export var CObjHndl		m_xFlock;
	const int							TIMER_GROWUP=1177;
	
	//Food stuff
	var CObjList					m_xFoodCache;
	var CGameTime					m_xLastUpdateFoodCache;
	var real							m_fUpdateFoodInterval;
	var CGameTime					m_xLastFeedingTime;
	
	var real							m_fGrowUpValue;
	
	//Henry: new member values
	var bool							m_bHerbivore;
	var bool							m_bCarnivore;
	var real							m_fAdaption;
	export var bool				m_bBugged;
	var bool							m_bSpecial;
	var bool							m_bTransformable;
	var bool							m_bHunting;
	var bool							m_bCamouflage;
	export var CObjHndl		m_xFakeCorpse;
	var CObjHndl					m_xSpy;
	var int								m_iSpy;
	var string						m_sRagePath;
	
	export const int FORCE_HEALING			= 40003;
	
	constructor()
		m_fFatigue=0.0f;
		m_iPerformanceTimeOut=0;
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_PARTYCOL, false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE, false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_HELMET, false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMOR, false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_STANDARTE, false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMORSADDLE, false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_MISC,true);
	
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_WOUND_ARMLI, false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_WOUND_ARMRE, false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_WOUND_LEGLI, false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_WOUND_LEGRE, false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_WOUND_BELLI, false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_WOUND_BELRE, false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_WOUND_HEAD, false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_WOUND_TAIL, false);
		
//		var int iIndex=AddAutoSpecialMove("Actions/Hu/Moves/ANML/Mammoth_Stampede");
//		m_axAutoSpecialMoves[iIndex].m_xOnCheckConditions=CheckRageTo;
//		m_axAutoSpecialMoves[iIndex].m_xOnStartAction=StartRageTo;
		
		m_xRageWalkSet="rage";
		m_fGrowUpValue=1.0;
		
		m_bHerbivore=false;
		m_bCarnivore=false;
		m_bBugged=false;
		m_bSpecial=false;
		m_fAdaption=4.0;
		m_bTransformable=false;
		m_bHunting=false;
		m_bCamouflage=false;
		m_xFakeCorpse=CObjHndl.Invalid();
		m_xSpy=CObjHndl.Invalid();
	endconstructor;
	
	destructor()
		DeleteTimer(TIMER_GROWUP);
		DeleteTimer(TIMER_FATIGUE);
		if(HasTimer(TIMER_RAGETO))then
			EndRageTo();
		endif;
		var ^CNest pxNest=cast<CNest>(m_xNest.GetObj());
		if(pxNest!=null)then
			pxNest^.DieAnimal(GetHandle());
		endif;
		if(m_xFakeCorpse.IsValid())then
			var ^CGameObj pxFC=m_xFakeCorpse.GetObj();
			if(pxFC!=null)then
				var ^CDino_Food pxDinoFood=cast<CDino_Food>(pxFC);
				if(pxDinoFood!=null)then
					pxDinoFood^.FeignDelete();
				endif;
			endif;
		endif;
		var ^CFlock pxFlock=cast<CFlock>(m_xFlock.GetObj());
		if(pxFlock!=null)then
			pxFlock^.RemoveMember(GetHandle());
		endif;
	enddestructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetCanWalk(true);
		if(!p_bLoad)then
			SetType("ANML");
			InitAttribs();
		else
			ChangeFatigue(0.0f);
		endif;
		UpdateAttribs(p_bLoad);
		AddUnit();
		//item inventory -> all levels can now have one item
		if(GetInventory()==null)then
			InitInventory(1);
		endif;
		if(GetOwner()==-1)then
			SetAggressionState(2);
			var bool bAnimalsVisInFOW=CMirageSrvMgr.Get().AnimalsVisInFOW();
			SetVisInFOW(bAnimalsVisInFOW);
		endif;
		SetIdleAnim();
		if(!IsWildAnimal())then
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,GetOwner()>=0);
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_PARTYCOL,GetOwner()>=0);
		endif;
		OnTechTreeChange();
		if(!p_bLoad)then
			StartTT();
			SetCanFightAttrib(true);
		endif;
		InitEnemySearch();
		SetAnimalType();
//		if(!p_bLoad)then
//			SetAdditionalBeastThings(); //Henry: ;)
//		endif;
		if(IsWildAnimal())then
			if(ShowAnmlMiscFlag())then
				SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_MISC,true);
			else
				SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_MISC,false);
			endif;
		endif;
		if(GetClassName()=="Stegosaurus"||GetClassName()=="arena_ankylosaurus")then
			SetAttackDirection(Math.Pi());
		endif;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		if(m_xSpy.IsValid())then
			var CFourCC xL="NOPE";
			m_xSpy.GetObj()^.LinkAction(GetHandle(), xL);
		endif;
		ForceHealing();
	endproc;
	
	export proc bool CanSee(^CGameObj p_pxObj)
		if(p_pxObj==null)then return false; endif;
		var real fDistSquare=(p_pxObj^.GetPos()-GetPos()).Abs2S();
		var real fSightRangeSquare=GetSightRange() * GetSightRange();
		return (fDistSquare<fSightRangeSquare);
	endproc;
	
	export proc bool AttackEnemy(^CFightingObj p_pxEnemy, vec3 p_vTarget, ref bool p_rbRotated)
		if(HasTimer(TIMER_RAGETO))then
			EndRageTo();
		endif;
		return super.AttackEnemy(p_pxEnemy, p_vTarget, p_rbRotated);
	endproc;
	
	export proc bool FollowEnemy(^CFightingObj p_pxEnemy, bool p_bAttackScape)
		if(GetOwner()==-1 && p_pxEnemy!=null)then
			UpdateAggressionPos(p_pxEnemy^.GetPos());
		endif;
		return super.FollowEnemy(p_pxEnemy,p_bAttackScape);
	endproc;
	
	export proc bool CheckRageTo(string p_sTTPath)
		if(GetClassName()!="hu_mammoth"&&GetClassName()!="hu_rhino")then return false; endif;
		if(HasTimer(TIMER_RAGETO))then return false; endif;
		if(!CRequirementsMgr.Get().CheckInvention(this, GetOwner(), "mammoth_stampede", GetTribeName()))then return false; endif;
		var ^CFightingObj pxEnemy=cast<CFightingObj>(m_xCurEnemy.GetObj());
		if(pxEnemy==null)then return false; endif;
		var real fRangeSquare=(pxEnemy^.GetPos() - GetPos()).AbsSquare();
		if(fRangeSquare<100.0)then return false; endif;
		if(fRangeSquare>(GetFOWRange()*GetFOWRange()))then return false; endif;
		return true;
	endproc;
	
	export proc void StartRageTo(string p_sTTPath)
		if(!HasTimer(TIMER_RAGETO))then
			CreateTimer(TIMER_RAGETO,CGameTimeSpan.OneSecond()*2.0,true);
			m_xRageStart=CTimeMgr.Get().GetTime();
			SetDefaultWalkSet(m_xRageWalkSet);
		endif;
	endproc;
	
	proc void RageTo()
		var CGameTime xNow=CTimeMgr.Get().GetTime();
		var CGameTimeSpan xDuration=RAGE_DURATION;
		if((xNow - m_xRageStart) >= xDuration)then
			EndRageTo();
			return;
		endif;
		if(!HasTimer(TIMER_RAGETO))then
			return;
		endif;
		var vec3 vDirection={0.0,1.0,0.0};
		vDirection.RotZ(GetRotation().GetZ());
		var vec3 vLeft=(vDirection${0.0,0.0,1.0}).GetNormalized();
		var vec3 vRight=vLeft * (-1.0);
		vLeft.SetZ(0.5);
		vRight.SetZ(0.5);
		vLeft *= 10.0;
		vRight *= 10.0;
		var ^CAreaDamage pxDmg=new CAreaDamage(7.0, GetDmg(), 10.0, GetOwner(), GetPos(), m_iSizeClass);
		var ^CObjList pxEnemies=CSrvWrap.GetObjMgr()^.GetOwnerEnemyList(GetOwner());
		if(pxEnemies!=null)then
			var CObjList xList;
			pxEnemies^.CopySorted(xList,GetPos(),7.0);
			var int i, iC=xList.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				var ^CCharacter pxFight=cast<CCharacter>(xList[i].GetObj());
				if(pxFight!=null)then
					var real fAngle=GetAngleToR(pxFight);
					if(fAngle>=0.0)then
						pxFight^.SetHitReactionTimer(0.0,vRight);
					else
						pxFight^.SetHitReactionTimer(0.0,vLeft);
					endif;
				endif;
			endfor;
		endif;
	endproc;
	
	proc void RhinoRageTo()
		var CGameTime xNow = CTimeMgr.Get().GetTime();
		var CGameTimeSpan xDuration = RAGE_DURATION;
		if((xNow - m_xRageStart) >= xDuration)then
			EndRageTo();
			return;
		endif;
		if(!HasTimer(TIMER_RAGETO))then
			return;
		endif;
		var vec3 vDirection = {0.0,1.0,0.0};
		vDirection.RotZ(GetRotation().GetZ());
		var vec3 vLeft = (vDirection${0.0,0.0,1.0}).GetNormalized();
		var vec3 vRight = vLeft * (-1.0);
		vLeft.SetZ(0.5);
		vRight.SetZ(0.5);
		vLeft *= 10.0;
		vRight *= 10.0;
		var ^CAreaDamage pxDmg = new CAreaDamage(5.5, GetDmg(), 8.0, GetOwner(), GetPos(), m_iSizeClass);
		var ^CObjList pxEnemies=CSrvWrap.GetObjMgr()^.GetOwnerEnemyList(GetOwner());
		if(pxEnemies!=null)then
			var CObjList xList;
			pxEnemies^.CopySorted(xList,GetPos(),5.5);
			var int i, iC = xList.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				var ^CCharacter pxFight = cast<CCharacter>(xList[i].GetObj());
				if(pxFight!=null)then
					var real fAngle = GetAngleToR(pxFight);
					if(fAngle>=0.0)then
						pxFight^.SetHitReactionTimer(0.0,vRight);
					else
						pxFight^.SetHitReactionTimer(0.0,vLeft);
					endif;
				endif;
			endfor;
		endif;
	endproc;
	
	proc void BrachioRageTo()
		var CGameTime xNow=CTimeMgr.Get().GetTime();
		var CGameTimeSpan xDuration=BRACH_RAGE_DURATION;
		if((xNow - m_xRageStart) >= xDuration)then
			EndRageTo();
			return;
		endif;
		if(!HasTimer(TIMER_RAGETO))then
			return;
		endif;
		var vec3 vDirection={0.0,1.0,0.0};
		vDirection.RotZ(GetRotation().GetZ());
		var vec3 vLeft=(vDirection${0.0,0.0,1.0}).GetNormalized();
		var vec3 vRight=vLeft * (-1.0);
		vLeft.SetZ(0.5);
		vRight.SetZ(0.5);
		vLeft *= 10.0;
		vRight *= 10.0;
		var ^CAreaDamage pxDmg=new CAreaDamage(9.0, GetDmg(), GetDmg()/5.0, GetOwner(), GetPos(), m_iSizeClass);
		var ^CObjList pxEnemies=CSrvWrap.GetObjMgr()^.GetOwnerEnemyList(GetOwner());
		if(pxEnemies!=null)then
			var CObjList xList;
			pxEnemies^.CopySorted(xList,GetPos(),7.0);
			var int i, iC=xList.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				var ^CCharacter pxFight=cast<CCharacter>(xList[i].GetObj());
				if(pxFight!=null)then
					var real fAngle=GetAngleToR(pxFight);
					if(fAngle>=0.0)then
						pxFight^.SetHitReactionTimer(0.0,vRight);
					else
						pxFight^.SetHitReactionTimer(0.0,vLeft);
					endif;
				endif;
			endfor;
		endif;
	endproc;
	
	proc void EndRageTo()
		DeleteTimer(TIMER_RAGETO);
		ResetSpecialActionTimer(m_sRagePath);
		AddSpecialActionTimer(m_sRagePath);
		SetDefaultWalkSet(GetWalkSet());
	endproc;
	
	export proc ref CFourCC GetWalkSet()
		if(HasTimer(TIMER_RAGETO))then
			return m_xRageWalkSet;
		else
			return super.GetWalkSet();
		endif;
	endproc;
	
	export proc bool IsInFight()
		var bool bReturn=super.IsInFight();
		var ^CTask pxTask=GetCurTask();
		if(pxTask==null)then return bReturn; endif;
		var ^CFlee pxFlee=cast<CFlee>(pxTask);
		bReturn=bReturn||(pxFlee!=null);
		return bReturn;
	endproc;
	
	export proc bool IsFleeing()
		var ^CTask pxTask=GetCurTask();
		if(pxTask==null)then return false; endif;
		var ^CFlee pxFlee=cast<CFlee>(pxTask);
		return pxFlee!=null;
	endproc;
	
	export proc void OnActionEnd(bool p_bBroken)
		super.OnActionEnd(p_bBroken);
		var bool bSetIdleAnim=true;
		var ^CTask pxCurTask=GetCurTask();
		if(pxCurTask!=null)then
			bSetIdleAnim=pxCurTask^.OnActionEnd(p_bBroken);
		endif;
		if(bSetIdleAnim)then
			if(!IsDead() && m_fHitpoints>0.0f && !IsFeignDeath() && !m_bRotateSLEAction && !IsGroupWalkPending())then
				SetIdleAnim();
			endif;
		endif;
		if(HasBuildUp())then
			GetBuildUp()^.OnActionEnd(p_bBroken);
		endif;
		if(HasTimer(TIMER_RAGETO))then
			EndRageTo();
		endif;
	endproc;
	
	export proc bool FleeToNest()
		if(m_xNest.IsValid())then
			var vec3 vPos=m_xNest.GetObj()^.GetPos();
			GoTo(vPos, true, GetMaxSpeed(), true, true);
			return true;
		endif;
		return false;
	endproc;
	
	export proc void CreateSpirit()
		if(IsWildAnimal())then return; endif;
		super.CreateSpirit();
	endproc;
	
	export proc void SetActAutonomous(bool p_bNoInfluence)
		m_bActAutonomous=p_bNoInfluence;
	endproc;
	
	export proc bool GetActAutonomous()
		return m_bActAutonomous;
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		po_rxLink="Ride";
		SetCaptainAnim("ride_idle_0");
		SetCaptainAttackAnim("eusmilus_stina_sm");
		return true;
	endproc;
	
	export proc void DoCaptainAttackAnim()
		if(HasBuildUp())then return super.DoCaptainAttackAnim(); endif;
		if(m_xCaptain.IsValid())then
			var ^CGameObj pxCaptain=m_xCaptain.GetObj();
			if(pxCaptain==null)then return; endif;
			var string sAnim=GetCaptainAttackAnim();
			if(pxCaptain^.HasAnim(sAnim))then
				pxCaptain^.SetAnim(sAnim, 1);
			endif;
		endif;
		return;
	endproc;
	
	export proc void RemoveOwnClass(ref CObjList p_rxList)
		var ^CRegion pxR;
		var ^CNest pxN;
		if(m_xNest.IsValid())then
			pxN=cast<CNest>(m_xNest.GetObj());
			if(pxN!=null)then
				pxR=pxN^.GetActionAreaPtr();
			endif;
		endif;
		var int i,iC=p_rxList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFightingObj pxW=cast<CFightingObj>(p_rxList[i].GetObj());
			if(pxW==null)then
				p_rxList.DeleteEntry(i);i--;iC--;
				continue;
			elseif(pxW^.IsBaby())then;
				p_rxList.DeleteEntry(i);i--;iC--;
				continue;
			elseif(((pxW^.GetOwner()==GetOwner()) && (pxW^.GetClassName()==GetClassName())))then
				p_rxList.DeleteEntry(i);i--;iC--;
				continue;
			endif;
			if(pxN!=null)then
				if(pxN^.BelongsToNest(p_rxList[i]))then
					p_rxList.DeleteEntry(i);i--;iC--;
					continue;
				endif;
			endif;
			if(pxR!=null&&GetProjectile().IsEmpty())then
				if(!pxR^.IsObjectInRegion(p_rxList[i]))then;
					p_rxList.DeleteEntry(i);i--;iC--;
					continue;
				endif;
			endif;
			if(pxW^.IsFlyingUnit()&&!CanShootAir())then
				p_rxList.DeleteEntry(i);i--;iC--;
			elseif(pxW^.GetClassName()=="darwin_s0")then
				p_rxList.DeleteEntry(i);i--;iC--;
			elseif(pxW^.GetClassName()=="volcano")then
				p_rxList.DeleteEntry(i);i--;iC--;
			elseif(pxW^.GetClassName().Find("_wreckage")!=-1)then
				p_rxList.DeleteEntry(i);i--;iC--;
			elseif(pxW^.GetNeutralObject())then
				p_rxList.DeleteEntry(i);i--;iC--;
//			elseif(pxW^.GetEffectFlag(EFFECT_AJE_CAMOUFLAGE)&&GetOwner()==-1&&GetGfxName()==pxW^.GetGfxName())then
//				p_rxList.DeleteEntry(i);i--;iC--;
			elseif(pxW^.GetEffectFlag(CFightingObj.EFFECT_NO_ANIMAL_AGGRO))then
				p_rxList.DeleteEntry(i);i--;iC--;
			elseif(pxW^.InvalidEnemy())then
				p_rxList.DeleteEntry(i);i--;iC--;
			elseif(pxW^.HidingEnemy()&&!IsDetector())then
				p_rxList.DeleteEntry(i);i--;iC--;
			endif;
		endfor;
	endproc;
	
	export proc void FillEnemyList(ref CObjList p_rxDirectList, ref CObjList p_rxAlarmList)
		if(GetOwner()<0)then
			var ^CFlock pxF=cast<CFlock>(m_xFlock.GetObj());
			if(pxF!=null)then
				m_xEnemySearch.ClearExcludes();
				m_xEnemySearch.Exclude(pxF^.GetObjects());
			endif;
			m_xEnemySearch.Exclude(GetHandle(),true);
			var string sClass=GetClassName();
			var ^CNest pxN=cast<CNest>(m_xNest.GetObj());
			if(pxN!=null)then
				var ^CRegion pxR=pxN^.GetActionAreaPtr();
				var CObjList xPreList;
				if(pxR!=null)then
					var int i, iC=pxR^.NumObjects();
					for(i=0)cond(i<iC)iter(++i)do
						var CObjHndl xObj=pxR^.GetObject(i);
						var ^CFightingObj pxO=cast<CFightingObj>(xObj.GetObj());
						if(pxO==null)then continue; endif;
						if(pxO^.GetClassName()==sClass)then continue; endif;
						if(CNest.ms_aiNeutralPlayer.FindEntry(pxO^.GetOwner())>=0)then continue; endif;
						if(pxO^.GetVisibleMask()!=011111111b)then continue; endif;
						xPreList.Include(xObj);
					endfor;
				endif;
				m_xEnemySearch.RegionCircle(GetPos(),Math.Max(GetAttackRange(),30.0));
				m_xEnemySearch.Execute(xPreList,p_rxDirectList);
				m_xEnemySearch.RegionCircle(GetPos(),GetAlarmRange());
				m_xEnemySearch.Execute(xPreList,p_rxAlarmList);
			else
				m_xEnemySearch.RegionCircle(GetPos(),Math.Max(GetAttackRange(),30.0));
				m_xEnemySearch.Execute(p_rxDirectList);
				m_xEnemySearch.RegionCircle(GetPos(),GetAlarmRange());
				m_xEnemySearch.Execute(p_rxAlarmList);
			endif;
			RemoveOwnClass(p_rxDirectList);
			RemoveOwnClass(p_rxAlarmList);
		else
			super.FillEnemyList(p_rxDirectList,p_rxAlarmList);
		endif;
	endproc;
	
	proc void PreCheckForEnemies()
		if(GetOwner()!=-1)then
			super.PreCheckForEnemies();
			return;
		endif;
		if(IsBaby())then
			return;
		endif;
		var real fRange=GetAlarmRange();
		if(GetAttackRange()>fRange)then
			fRange=GetAttackRange();
		endif;
		fRange+=50.0f;
		var CObjList xEnemyList;
		var ^CObjList pxEnemies;
		var int iOwner=GetOwner();
		if(iOwner<0)then
			// only aggressive animals can attack
			if(GetAggressive()!=1)then
				return;
			endif;
			var ^CFlock pxF=cast<CFlock>(m_xFlock.GetObj());
			if(pxF!=null)then
				m_xEnemySearch.ClearExcludes();
				m_xEnemySearch.Exclude(pxF^.GetObjects());
			endif;
			m_xEnemySearch.Exclude(GetHandle(),true);
			SetOwnerEnemySearch(m_xFoodCache.NumEntries()==0);
			m_xEnemySearch.RegionCircle(GetPos(),fRange);
			m_xEnemySearch.Execute(xEnemyList);
			m_xEnemySearch.ClearExcludes();
			RemoveOwnClass(xEnemyList);
			var int iAvailableHelper=GetAvailableHelperCount(this, false);
			var int i,iC=xEnemyList.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				var ^CGameObj pxWalk=xEnemyList[i].GetObj();
				if(pxWalk^.GetOwner()==-1)then
					var int iTTHelper=GetMaxHelperCount();
					var int iNeededHelper=GetHelperCount(pxWalk);
					if((iTTHelper*2)<iNeededHelper)then
						xEnemyList.DeleteEntry(i);
						i--;iC--;
//					elseif(iAvailableHelper<(Math.Floor(iNeededHelper.ToReal()*1.5f)).ToInt())then
					elseif(iAvailableHelper<(iNeededHelper*2))then
						xEnemyList.DeleteEntry(i);
						i--;iC--;
					endif;
				endif;
			endfor;
			pxEnemies=^(xEnemyList);
		else
			pxEnemies=CSrvWrap.GetObjMgr()^.GetOwnerEnemyList(iOwner);
		endif;
		var int iNearest=pxEnemies^.FindNearest(GetPos(),fRange);
		if(iNearest!=-1)then
			ActivateAggroTimer();
		else
			DeleteTimer(TIMER_AGGRO);
			SetAlarmed(false);
		endif;
	endproc;
	
	export proc void UpdateHitpoints()
		super.UpdateHitpoints();
		var bitset dwWounds;
		if(m_fMaxHitpoints==0.0f)then m_fMaxHitpoints=1.0f; endif;
		var real fHealthRatio=m_fHitpoints/m_fMaxHitpoints;
		if(fHealthRatio<=0.8f)then
			dwWounds|=01d<<VIS_FLAG_ANML_WOUND_ARMLI;
			if(fHealthRatio<=0.7f)then
				dwWounds|=01d<<VIS_FLAG_ANML_WOUND_ARMRE;
				if(fHealthRatio<=0.6f)then
					dwWounds|=01d<<VIS_FLAG_ANML_WOUND_LEGLI;
					if(fHealthRatio<=0.5f)then
						dwWounds|=01d<<VIS_FLAG_ANML_WOUND_LEGRE;
						if(fHealthRatio<=0.4f)then
							dwWounds|=01d<<VIS_FLAG_ANML_WOUND_BELLI;
							if(fHealthRatio<=0.3f)then
								dwWounds|=01d<<VIS_FLAG_ANML_WOUND_BELRE;
								if(fHealthRatio<=0.2f)then
									dwWounds|=01d<<VIS_FLAG_ANML_WOUND_TAIL;
								endif;
							endif;
						endif;
					endif;
				endif;
			endif;
		endif;
		var bitset dwRndInvMask=GetRndInvMask();
		dwRndInvMask|=VIS_FLAG_ANML_WOUND_ALL;
		dwRndInvMask&=~dwWounds;
		SetRndInvMask(dwRndInvMask);
		var ^CTaskMgr pxTaskMgr=cast<CTaskMgr>(GetFSM()^.FindSubStateRecursive("TaskMgr"));
		if(pxTaskMgr!=null)then
			var ^CFlee pxFlee=cast<CFlee>(pxTaskMgr^.GetCurTask());
			if(pxFlee!=null && m_fMaxHitpoints>0.0)then
				pxFlee^.SetHitpoints(m_fHitpoints/m_fMaxHitpoints);
			endif;
		endif;
		if(m_bHunting && fHealthRatio==1.0f)then
			m_bHunting=false;
		endif;
	endproc;
	
	export proc bool ExamineEnemies(bool p_bAlarm)
		if((GetOwner()==-1) && (cast<CFeed>(GetCurTask())!=null))then
			return false;
		endif;
		return super.ExamineEnemies(p_bAlarm);
	endproc;
	
	export proc bool ExamineEnemies(bool p_bAlarm, bool p_bFillEnemyList)
		return super.ExamineEnemies(p_bAlarm, p_bFillEnemyList);
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CAnimal] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xType="anml";
		var int iVersion=5;
		if(CMirageSrvMgr.SDK())then
			iVersion=4;
		endif;
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,iVersion);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xFlock.DoKArc(pxArc^);
		m_xNest.DoKArc(pxArc^);
		(pxArc^) << m_fFatigue;
		(pxArc^) << m_bActAutonomous;
		(pxArc^) << m_fGrowUpValue;
		if(iVersion>=5)then
			(pxArc^) << m_bHerbivore;
			(pxArc^) << m_bCarnivore;
			(pxArc^) << m_fAdaption;
			(pxArc^) << m_bBugged;
			(pxArc^) << m_bSpecial;
			(pxArc^) << m_bTransformable;
			(pxArc^) << m_bHunting;
			m_xFakeCorpse.DoKArc(pxArc^);
			(pxArc^) << m_bCamouflage;
			m_xSpy.DoKArc(pxArc^);
		endif;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="anml")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			if(p_pxReaderNode^.GetVersion()>=1)then
				m_xFlock.DoKArc(pxArc^);
				m_xNest.DoKArc(pxArc^);
			endif;
			if(p_pxReaderNode^.GetVersion()>=2)then
				(pxArc^) << m_fFatigue;
			endif;
			if(p_pxReaderNode^.GetVersion()>=3)then
				(pxArc^) << m_bActAutonomous;
			endif;
			if(p_pxReaderNode^.GetVersion()>=4)then
				(pxArc^) << m_fGrowUpValue;
			endif;
			if(p_pxReaderNode^.GetVersion()>=5)then
				(pxArc^) << m_bHerbivore;
				(pxArc^) << m_bCarnivore;
				(pxArc^) << m_fAdaption;
				(pxArc^) << m_bBugged;
				(pxArc^) << m_bSpecial;
				(pxArc^) << m_bTransformable;
				(pxArc^) << m_bHunting;
				m_xFakeCorpse.DoKArc(pxArc^);
				(pxArc^) << m_bCamouflage;
				m_xSpy.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc int GetDefaultSpeed()
		if(GetOwner()!=-1)then
			return GetMaxSpeed();
		endif;
		return super.GetDefaultSpeed();
	endproc;
	
	proc bool CreateGrowupTimer(real p_fBirthTime,real p_fDuration)
		var real fNow=CTimeMgr.Get().GetVirtualTime();
		var real fGrowUp=p_fDuration*CTimeMgr.Get().GetVirtualDayLength();
		fGrowUp-=(fNow-p_fBirthTime);
		if(fGrowUp<=0.0)then return false; endif;
		var CGameTimeSpan xTS=CGameTimeSpan.OneSecond()*(fGrowUp/10.0f);
		xTS=xTS/CTimeMgr.Get().GetVirtualFactor();
		var ^CAttribs pxA=GetAttribs();
		if(pxA!=null)then
			pxA^.SetValue("is_baby",true);
		endif;
		CreateTimer(TIMER_GROWUP,xTS,true);
		return true;
	endproc;
	
	export proc bool Birth(CObjHndl p_xNest,real p_fVirtualBirthTime)
		//L CSrvWrap.LogSpam("Animal","birth_time"+p_fVirtualBirthTime.ToString() );
		GetAttribs()^.SetValue("birth_time",p_fVirtualBirthTime);
		var real fVF=CTimeMgr.Get().GetVirtualFactor();
		var real fVDL=CTimeMgr.Get().GetVirtualDayLength();
		var real fGrowUpDuration=GetTechTreeValueR("growup_duration",fVDL/fVF)*(fVF/fVDL);
		GetAttribs()^.SetValue("growup_duration",fGrowUpDuration);
		m_xNest=p_xNest;
		var bool bRes=CreateGrowupTimer(p_fVirtualBirthTime,fGrowUpDuration);
		ChangeMaxHitpoints(GetTechTreeHitpoints());
		return bRes;
	endproc;
	
	export proc real ChangeFatigue(real p_fDiff)
		m_fFatigue=Math.Clamp(m_fFatigue+p_fDiff,0.0f,1.0f);
		if(m_fFatigue<=0.0f)then
			DeleteTimer(TIMER_FATIGUE);
		else
			if(!HasTimer(TIMER_FATIGUE))then
				CreateTimer(TIMER_FATIGUE,CGameTimeSpan.OneSecond(),true);
			endif;
		endif;
		return m_fFatigue;
	endproc;
	
	export proc real GetFatigue()
		return m_fFatigue;
	endproc;
	
	export proc void OnTechTreeChange()
		super.OnTechTreeChange();
		if(IsVegetarian())then
			m_fUpdateFoodInterval=60.0f;
		else
			m_fUpdateFoodInterval=30.0f;
		endif;
	endproc;
	
	export proc void OnTechTreeChange(ref CStringArray p_rasChanges)
		super.OnTechTreeChange(p_rasChanges);
	endproc;
	
	export proc real CalculateHitpointsFromGrowUpSize(real p_fMaxHitpoints)
		var real fValue=p_fMaxHitpoints;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr==null)then return fValue; endif;
		var real fNow=CTimeMgr.Get().GetVirtualTime();
		var real fBirthTime=pxAttr^.GetValueFloat("birth_time");
		var real fVF=CTimeMgr.Get().GetVirtualFactor();
		var real fGrowUp=GetTechTreeValueR("growup_duration",CTimeMgr.Get().GetVirtualDayLength()/fVF)*fVF;
		if(fBirthTime!=0.0f && fNow<(fBirthTime+fGrowUp))then
			if(fGrowUp>0.0f)then
				var real fStrength=((fNow-fBirthTime)/fGrowUp);
				if(fStrength<0.2f)then fStrength=0.2f; endif;//min 20%
				fValue=(fValue*fStrength);
			else
				var real fStrength=0.2f;
				fValue=(fValue*fStrength);
			endif;
		endif;
		return fValue;
	endproc;
	
	export proc int CalculateScalpsFromGrowUpSize(int p_iMaxScalps)
		var int iValue=p_iMaxScalps;
		var ^CAttribs pxAttr=GetAttribs();
		var real fNow=CTimeMgr.Get().GetVirtualTime();
		var real fBirthTime=pxAttr^.GetValueFloat("birth_time");
		var real fVF=CTimeMgr.Get().GetVirtualFactor();
		var real fGrowUp=GetTechTreeValueR("growup_duration",CTimeMgr.Get().GetVirtualDayLength()/fVF)*fVF;
		if(fBirthTime!=0.0f && fGrowUp!=0.0f && fNow<(fBirthTime+fGrowUp))then
			var real fStrength=((fNow-fBirthTime)/fGrowUp);
			iValue=Math.Max( ( (iValue.ToReal()*fStrength)+0.5).ToInt() , 1);
		endif;
		return iValue;
	endproc;
	
	export proc int GetScalpValue()
		var int iValue=super.GetScalpValue();
		return CalculateScalpsFromGrowUpSize(iValue);
	endproc;
	
	export proc void ChangeMaxHitpoints(real p_fNewMax)
		var real fHP=CalculateHitpointsFromGrowUpSize(p_fNewMax);
		if(fHP==p_fNewMax)then
			m_fGrowUpValue=1.0;
			DeleteTimer(TIMER_GROWUP);
			var ^CAttribs pxA=GetAttribs();
			if(pxA!=null)then
				pxA^.SetValue("is_baby",false);
			endif;
		endif;
		super.ChangeMaxHitpoints(fHP);
		UpdateGrowUpValue();
		GrowUp();
		GetAttribs()^.SetValue("skulls",CalculateScalpsFromGrowUpSize(super.GetScalpValue())); //WT#1408
	endproc;
	
	proc void SetOwnerEnemySearch(bool p_bIncludeWorld)
		m_xEnemySearch.SetOwner(0);
		m_xEnemySearch.SetOwner(1,true);
		m_xEnemySearch.SetOwner(2,true);
		m_xEnemySearch.SetOwner(3,true);
		m_xEnemySearch.SetOwner(4,true);
		m_xEnemySearch.SetOwner(5,true);
		m_xEnemySearch.SetOwner(6,true);
		m_xEnemySearch.SetOwner(7,true);
		if(p_bIncludeWorld)then
			m_xEnemySearch.SetOwner(-1,true);
		endif;
	endproc;
	
	proc void InitEnemySearch()
		SetOwnerEnemySearch(GetOwner()==-1);
		m_xEnemySearch.SetType("CHTR");
		m_xEnemySearch.SetType("FGHT",true);
		m_xEnemySearch.SetType("ANML",true);
		m_xEnemySearch.SetType("VHCL",true);
		m_xEnemySearch.SetType("BLDG",true);
		if(!GetProjectile().IsEmpty())then
			m_xEnemySearch.SetType("SHIP",true);
		endif;
	endproc;
	
	export proc void UpdateEquipment()
		if(GetOwner()==-1)then
			InitEnemySearch();
		endif;
		super.UpdateEquipment();
	endproc;
	
	export proc void SetOwner(int p_iOwner)
		super.SetOwner(p_iOwner);
		InitEnemySearch();
		OnTechTreeChange();
		if(p_iOwner>-1)then
			//why set aggression state here?
			//SetAggressionState(2);
			SetVisInFOW(false);
		else
			var bool bAnimalsVisInFOW=CMirageSrvMgr.Get().AnimalsVisInFOW();
			SetVisInFOW(bAnimalsVisInFOW);
		endif;
	endproc;
	
	proc bool IsHungry()
		var real fRepletion=GetTechTreeValueR("repletion",0.0f);
		return ((CTimeMgr.Get().GetTime()-m_xLastFeedingTime).GetSecondsF()>=fRepletion);
	endproc;
	
	/// try to find food, return true if found and feeding initiated
	proc bool FindFood()
		if((CTimeMgr.Get().GetTime()-m_xLastUpdateFoodCache).GetSecondsF()>=m_fUpdateFoodInterval)then
			UpdateFoodCache();
		endif;
		var CObjHndl xFood;
		begin SelectFood;
			var int iNumFoods=m_xFoodCache.NumEntries();
			if(iNumFoods>0)then
				var int iTryCnt=0;
				while(iTryCnt<5)do
					var int iFoodIdx=Random.GetInt()%iNumFoods;
					var ^CGameObj pxO=m_xFoodCache[iFoodIdx].GetObj();
					if(pxO!=null)then
						if(IsPositionOk(pxO^.GetPos()) && !IsScaredPos(pxO^.GetPos()))then
							xFood=pxO^.GetHandle();
							break;
						endif;
					else
						m_xFoodCache.DeleteEntry(iFoodIdx);
						iNumFoods=m_xFoodCache.NumEntries();
						if(iNumFoods<=0)then break; endif;
					endif;
					iTryCnt++;
				endwhile;
			endif;
		end SelectFood;
		if(xFood.IsValid())then
			Feed(xFood);
			return true;
		elseif(IsVegetarian())then
			// TODO: let vegetarian find some better place to eat
			Feed(GetPos());
			return true;
		endif;
		return false;
	endproc;
	
	export proc void SetNextWalkTarget(vec3 p_vPos)
		m_vNextWalkTarget=p_vPos;
	endproc;
	
	proc bool StartNewWalkTarget()
		if(!m_vNextWalkTarget.ToBool())then return false; endif;
		var vec3 vFreePos;
		if(CSrvWrap.GetObjMgr()^.GetFreePos(vFreePos,this,m_vNextWalkTarget,null,true,false,false))then
			var vec3 vUnscaredPos=vFreePos;
			var bool bScared=UnscarePos(vUnscaredPos);
			// if scared, don't try to hold nest or flock restrictions
			if(bScared||IsPositionOk(vUnscaredPos))then
				//L CSrvWrap.LogSpam("Animal", "Setting new walk pos:"+vUnscaredPos.ToString());
				GoTo(vUnscaredPos, false, GetDefaultSpeed(), true, true);
			else
				// we couldn't find unscared position meeting nest or flock restrictions
				GoTo(vFreePos, false, GetDefaultSpeed(), true, true);
			endif;
		else
			// we couldn't get free position
			GoTo(m_vNextWalkTarget, false, GetDefaultSpeed(), true, true);
		endif;
		m_vNextWalkTarget.Clear();
		return true;
	endproc;
	
	proc void CalcNextWalkTarget()
		var ^CNest pxNest=cast<CNest>(m_xNest.GetObj());
		var vec3 vNextPos;
		var int iSafeCounter=0;
		while(iSafeCounter<30)do
			var bool bCalc=true;
			if(pxNest!=null)then
				bCalc=!(pxNest^.GetRandomPoint(vNextPos,IsBaby()));
			endif;
			if(bCalc)then
				if(IsBaby())then
					vNextPos.SetX(GetPosX()+Random.MTRandF(-5.0, 5.0));
					vNextPos.SetY(GetPosY()+Random.MTRandF(-5.0, 5.0));
				else
					vNextPos.SetX(GetPosX()+Random.MTRandF(-30.0, 30.0));
					vNextPos.SetY(GetPosY()+Random.MTRandF(-30.0, 30.0));
				endif;
			endif;
			if(IsPositionOk(vNextPos))then
				SetNextWalkTarget(vNextPos);
				return;
			endif;
			iSafeCounter++;
		endwhile;
	endproc;
	
	export proc void OnIdleEnter(^CState p_pxFrom, ^CState p_pxTo)
		if(GetOwner()==-1)then
			if(IsFeignDeath())then return; endif;
			if(!IsGroupWalkPending()||GetClassName()=="Archaeopteryx")then
				SetIdleAnim();
			endif;
			m_xCurEnemy=CObjHndl.Invalid();
			m_xIdleStart=CTimeMgr.Get().GetTime();
		else
			super.OnIdleEnter(p_pxFrom,p_pxTo);
			//RT#16669
			if(!IsDead() && m_fHitpoints>0.0f && !IsFeignDeath() && !m_bRotateSLEAction && !IsGroupWalkPending())then
				SetIdleAnim();
			endif;
		endif;
	endproc;
	
	export proc void OnIdleTick(int p_iTime)
		// wild animal :)
		if(GetOwner()==-1||GetActAutonomous())then
			// have a nest
			if(m_xNest.IsValid())then
				DeleteTimer(AGILITY_TIMER);
			else
				if(!HasTimer(AGILITY_TIMER))then
					var string sObjPath=GetObjPath();
					var real fAgility=(m_xTechTree.GetValueR(sObjPath+"/agility",0.0f));
					if(fAgility<=0.0f)then
						fAgility=15.0f;
					endif;
					CreateTimer(AGILITY_TIMER,CGameTimeSpan.OneSecond()*fAgility,true);
				endif;
			endif;
			//performance timeout
			if(m_iPerformanceTimeOut<5)then
				m_iPerformanceTimeOut++;
				return;
			else
				m_iPerformanceTimeOut=0;
			endif;
			// try to start walking
			if(StartNewWalkTarget())then return; endif;
			var bool bSleepTime=IsSleepTime();
			var real fRand=Random.MTRandF();
			var real fSleepWeight=0.6f;
			var real fRepletion=0.8f;
			if(bSleepTime && (fRand>fSleepWeight))then
				var ^CSleep pxTask=cast<CSleep>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(), "Sleep"));
				if(pxTask!=null)then
					if(pxTask^.Init(GetHandle()))then
						SetTaskFO(pxTask);
					else
						pxTask^.GetFactory()^.FreeState(pxTask);
					endif;
				endif;
			elseif(IsHungry() && (fRand>fRepletion) && FindFood())then
				// all things done in if-statement
			else
				var real fDur=Random.MTRandF(5.0f,10.0f);
				WaitAction(fDur);
			endif;
			CheckPatrol();
		else
			super.OnIdleTick(p_iTime);
		endif;
	endproc;
	
	export proc void PrepareBuildUpTransferLinkedObjs()
	endproc;
	
	export proc void Die()
		if(SkipCorpse())then
			super.Die();
			return;
		endif;
		if(!IsDead()&&!IsDyingInTPO())then
			var ^CGameObj pxGameObj;
			var bool bUnitRes=CMirageSrvMgr.Get().UnitResources();
			if(GetClassName()=="special_eusmilus" && !bUnitRes)then
				pxGameObj=CSrvWrap.GetObjMgr()^.CreateObj("CharacterCorpse",GetOwner(),GetPos(),GetRotation());
				if(pxGameObj!=null)then
					var ^CCharacterCorpse pxCorpse=cast<CCharacterCorpse>(pxGameObj);
					if(pxCorpse!=null)then
						pxCorpse^.SetSource(this);
						pxCorpse^.SetOwner(GetOwner());
						pxCorpse^.Init(GetGfxName(), GetName(),8.0f);
					endif;
				endif;
			elseif(GetClassName()=="Miyagi_s0" && !IsInWater())then
				if(!bUnitRes)then
					pxGameObj=CSrvWrap.GetObjMgr()^.CreateObj("CharacterCorpse",GetOwner(),GetPos(),GetRotation());
					if(pxGameObj!=null)then
						var ^CCharacterCorpse pxCorpse=cast<CCharacterCorpse>(pxGameObj);
						if(pxCorpse!=null)then
							pxCorpse^.SetSource(this);
							pxCorpse^.SetOwner(GetOwner());
							pxCorpse^.Init("pirates_ninigi_warrior_s5", GetName(),8.0f);
						endif;
					endif;
				else
					var ^CChar_Food pxFood=cast<CChar_Food>(CSrvWrap.GetObjMgr()^.CreateObj(GetClassName()+"_corpse",GetOwner(),GetPos(),GetRotation()));
					if(pxFood!=null)then
						pxFood^.SetName(GetName());
						pxFood^.Initialize(this);
						pxFood^.SetAggressive(GetTechTreeAggressiv());
						pxFood^.SetDieAnim("die_simple",true);
						pxFood^.InvokeGenericSCEvent(16,4.0f);
						pxFood^.Init();
					endif;
				endif;
			else
				pxGameObj=CSrvWrap.GetObjMgr()^.CreateObj(GetClassName()+"_food",GetOwner(),GetPos(),GetRotation());
				if(pxGameObj!=null)then
					pxGameObj^.SetGFX(GetGfxName());
				endif;
			endif;
			if(pxGameObj!=null)then
				pxGameObj^.SetName(GetName());
				var ^CFood pxFood=cast<CFood>(pxGameObj);
				if(pxFood!=null)then
					pxFood^.SetRndInvMask(GetRndInvMask());
				endif;
				PrepareBuildUpTransferLinkedObjs();
				var ^CDino_Food pxDinoFood=cast<CDino_Food>(pxGameObj);
				if(pxDinoFood!=null)then
					if(GetClassName()=="Muraenosaurus"||GetClassName()=="Nothosaurus")then
						pxDinoFood^.Initialize(this, m_iSizeClass, false, 0.4f, -88, 5.0f);
					elseif(GetClassName()=="Kronosaurus"||GetClassName()=="Liopleurodon"||GetClassName()=="Mosasaurus")then
						pxDinoFood^.Initialize(this, m_iSizeClass, false, 0.4f, -88, 0.8f);
					else
						pxDinoFood^.Initialize(this, m_iSizeClass, false);
					endif;
					pxDinoFood^.SetAggressive(GetTechTreeAggressiv());
					if(HasBuildUp())then
//						pxDinoFood^.SetBuildUp(CBuildUpBase.TYPE_FAKE);
//						GetBuildUp()^.TransferLinkedObjs(pxDinoFood^.GetBuildUp());
						GetBuildUp()^.TransferLinkedObjs(pxDinoFood);
						var int j, jC=NumAdditionalBuildUps();
						for(j=0)cond(j<jC)iter(j++)do
							if(HasAdditionalBuildUp(j))then
//								GetAdditionalBuildUp(j)^.TransferLinkedObjsAdd(pxDinoFood^.GetBuildUp());
								GetAdditionalBuildUp(j)^.TransferLinkedObjsAdd(pxDinoFood);
							endif;
						endfor;
						pxDinoFood^.UpdateLinkedObjs();
					endif;
				endif;
				var real fNow=CTimeMgr.Get().GetVirtualTime();
				var ^CAttribs pxFoodAttribs=pxGameObj^.GetAttribs();
				if(pxFoodAttribs!=null)then
					pxFoodAttribs^.SetValue("birth_time",GetAttribs()^.GetValueFloat("birth_time"));
					pxFoodAttribs^.SetValue("growup_duration",GetAttribs()^.GetValueFloat("growup_duration"));
					pxFoodAttribs^.SetValue("die_time",fNow);
					var real fMaxHP=GetTechTreeHitpoints();
					var real fCurHP=CalculateHitpointsFromGrowUpSize(fMaxHP);
					var real fMaxValue=pxFoodAttribs^.GetValueInt("value").ToReal();
					pxFoodAttribs^.SetValue("value",((fCurHP*fMaxValue)/fMaxHP).ToInt());
				endif;
				var real fRadius=GetRadius();
				pxGameObj^.SetOwner(GetOwner());
				if(fRadius<=3.5)then
					pxGameObj^.InvokeGenericSCEvent(16,4.0f);
				elseif(fRadius<=5.0)then
					pxGameObj^.InvokeGenericSCEvent(10,4.0f);
				else
					pxGameObj^.InvokeGenericSCEvent(17,4.0f);
				endif;
				if(IsInWater() && (GetClassName()=="ninigi_baryonyx"||GetClassName()=="Baryonyx"||GetClassName()=="Miyagi_s0"))then
					pxGameObj^.SetAnim("drown",1);
				endif;
			endif;
		endif;
		super.Die();
	endproc;
	
	export proc void ActionTask(string p_sAction)
		var ^CVirtualProduceUnit pxProduceUnit=cast<CVirtualProduceUnit>(GetProduceUnit().GetObj());
		if(pxProduceUnit==null)then return; endif;
		pxProduceUnit^.Action(p_sAction);
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(m_xSpy.IsValid() && p_sMiscParams.Find("/Walk")<0 && p_sMiscParams.Find("/Stop")<0 && p_sMiscParams.Find("/AggroState_")<0)then
			RetainConsciousness();
			return;
		endif;
		if(IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/Dismount")!=-1)
			)then return; endif;
		if(GetTransportObj().IsValid()&&!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/LeaveTransport")>=0))then return; endif;
		if(GetActAutonomous() && p_sMiscParams.Find("AttackSrv")==-1 &&
		!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill"))then return; endif;
		if(p_sCommand=="Action")then
			var string sUpgradePath="Actions/"+GetTribeName()+"/Upgrades/"+GetClassName();
			if(p_sMiscParams.Find(sUpgradePath)!=-1)then
				ActionTask(p_sMiscParams);
			//check all the Special actions
//			elseif(p_sMiscParams.Find("/FeignDeath")!=-1)then
//				if(CheckSpecialActionTimer(p_sMiscParams))then
//					FeignDeathTask(true, p_sMiscParams,p_bQ);
//				endif;
			elseif(p_sMiscParams.Find("/EatSomethingFast")>=0)then
				EatPlantsOrMeat(null, GetPos(), true, p_bQ);
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		elseif(p_sCommand=="EatThatThing")then
			EatPlantsOrMeat(p_pxObject, p_vPos, false, p_bQ);
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	export proc bool StunningRoar(string p_sAnimName, real p_fTime, real p_fTimeOffset, real p_fRadius, string p_sTTPath, bool p_bQ, bool p_bAILock)
//		MemorizeCurrentFightState(CObjHndl.Invalid(),false,false);
		var ^CStunningRoar pxTask=cast<CStunningRoar>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"StunRoar"));
		if(pxTask==null)then return false; endif;
		var bool bReturn=pxTask^.Init(GetHandle(),p_sAnimName, p_fTime, p_fTimeOffset, p_fRadius,p_sTTPath);
		if(bReturn)then
			SetAILock(p_bAILock);
			pxTask^.SetUserCommand(true);
			NewTaskFO(pxTask,p_bQ);
		else
			pxTask^.GetFactory()^.FreeState(pxTask);
		endif;
		return bReturn;
	endproc;
	
	export proc bool ShakeOff(string p_sAnimName, real p_fTimeIntervall, real p_fTimeOffset, string p_sPath, bool p_bQ, bool p_bSkipVis, bool p_bAILock)
		return ShakeOff(p_sAnimName, p_fTimeIntervall, p_fTimeOffset, 0.0, 0.0, 0.0, p_sPath, p_bQ, p_bSkipVis, p_bAILock);
	endproc;
	
	export proc bool ShakeOff(string p_sAnimName, real p_fTimeIntervall, real p_fTimeOffset, real p_fDamage, real p_fEndDamage, real p_fRange, string p_sPath, bool p_bQ, bool p_bSkipVis, bool p_bAILock)
//		MemorizeCurrentFightState(CObjHndl.Invalid(),false,false);
		var ^CShakeOff pxTask=cast<CShakeOff>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"ShakeOff"));
		if(pxTask==null)then return false; endif;
		var bool bReturn=false;
		if(p_fDamage>0.0)then
			bReturn=pxTask^.Init(GetHandle(),p_sAnimName, p_fTimeIntervall, p_fTimeOffset, p_fDamage, p_fEndDamage, p_fRange, p_sPath, p_bSkipVis);
		else
			bReturn=pxTask^.Init(GetHandle(),p_sAnimName, p_fTimeIntervall, p_fTimeOffset, p_sPath, p_bSkipVis);
		endif;
		if(bReturn)then
			SetAILock(p_bAILock);
//			if(p_sAnimName=="trex_fm_2")then
//				CMirageSrvMgr.Debug("server ok stomp");
//			endif;
			pxTask^.SetUserCommand(true);
			NewTaskFO(pxTask,p_bQ);
		else
			pxTask^.GetFactory()^.FreeState(pxTask);
		endif;
		return bReturn;
	endproc;
	
	proc bool Paw(bool p_bUserCommand, string p_sTTPath, bool p_bQ, bool p_bAILock)
		var ^CPaw pxTask=cast<CPaw>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"Paw"));
		if(pxTask==null)then return false; endif;
		var bool bReturn=pxTask^.Init(GetHandle(),p_sTTPath);
		if(bReturn)then
			SetAILock(p_bAILock);
			pxTask^.SetUserCommand(p_bUserCommand);
			NewTaskFO(pxTask,p_bQ);
		else
			pxTask^.GetFactory()^.FreeState(pxTask);
		endif;
		return bReturn;
	endproc;
	
	export proc void FeignDeathTask(bool p_bStart, string p_sPath, bool p_bQ)
	/*
		var ^CFeignDeath pxT=cast<CFeignDeath>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(), "FeignDth"));
//		if(GetClassName()=="aje_resource_collector")then return; endif;
		if(pxT!=null && !IsFeignDeath())then
			var bool bReturn=pxT^.Init(GetHandle(), p_bStart, p_sPath);
			if(bReturn)then
				pxTask^.SetUserCommand(true);
				NewTaskFO(pxTask,p_bQ);
				var ^CGameObj pxGameObj=CSrvWrap.GetObjMgr()^.CreateObj(GetClassName()+"_food",GetOwner(),GetPos(),GetRotation());
				if(pxGameObj!=null)then
					pxGameObj^.SetName(GetName());
					var ^CFood pxFood=cast<CFood>(pxGameObj);
					if(pxFood!=null)then
						pxFood^.SetRndInvMask(GetRndInvMask());
					endif;
					var ^CDino_Food pxDinoFood=cast<CDino_Food>(pxFood);
					if(pxDinoFood!=null)then
						m_xFakeCorpse=pxDinoFood^.GetHandle();
						pxDinoFood^.Initialize(this, m_iSizeClass, true);
						pxDinoFood^.SetAggressive(GetTechTreeAggressiv());
						if(HasBuildUp()&&GetBuildUp()^.GetPrimaryLinkedObj().IsValid())then
							var string sName=GetBuildUp()^.GetPrimaryLinkedObj().GetObj()^.GetClassName();
							pxDinoFood^.SetBuildUp(CBuildUpBase.TYPE_FAKE);
							var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj(sName,GetOwner(),GetPos(),GetRotation());
							if(pxO!=null)then
								pxDinoFood^.GetBuildUp()^.AddObj(pxO^.GetHandle(), "con");
							endif;
						endif;
					endif;
				endif;
			else
				pxT^.GetFactory()^.FreeState(pxT);
			endif;
		elseif(pxT!=null && IsFeignDeath())then
			var ^CFeignDeath pxTask=cast<CFeignDeath>(GetCurTask());
			if(pxTask!=null)then
				pxTask^.Break();
			endif;
		endif;
		*/
	endproc;
	
	export proc void SetFeignDeath(bool p_bDeath)
		m_bFeignDeath=p_bDeath;
		if(p_bDeath==false && m_xFakeCorpse.IsValid())then
			var ^CGameObj pxFC=m_xFakeCorpse.GetObj();
			if(pxFC!=null)then
				var ^CDino_Food pxDinoFood=cast<CDino_Food>(pxFC);
				if(pxDinoFood!=null)then
					pxDinoFood^.FeignDelete();
				endif;
			endif;
			m_xFakeCorpse=CObjHndl.Invalid();
		endif;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()=="Feed")then
			var string sEvent=p_rxEvtPtr.GetString();
			var array string asSubs;
			sEvent.Split(asSubs,"/",true);
			if(asSubs.NumEntries()==2)then
				if(GetOwner()==-1)then
					if(IsTrapped())then return; endif;
					// feed after fight
					var string sFood=asSubs[0];
					if(!sFood.IsEmpty())then
						var CObjQuery xFoodSearch;
						var CObjList xFoods;
						var string sClass=sFood+"_food";
						xFoodSearch.SetClass(sClass);
//						xFoodSearch.SetAttribsPos("Meat", true);
						xFoodSearch.RegionCircle(GetPos(),20.0);
						if(xFoodSearch.Execute(xFoods))then
							xFoods.SortDistance(GetPos());
							Feed(xFoods[0]);
						endif;
					endif;
				elseif(IsCarnivore() && m_bHunting && !ExamineEnemies(false, GetAggressionState()!=1 && GetAggressionState()!=-1 && GetAggressionState()!=3) && !GetTransportObj().IsValid())then
					var vec3 vPos;
					vPos.FromString(asSubs[1]);
					if(asSubs[0]!="")then
						GetMeatSearch(asSubs[0],vPos);
					endif;
				endif;
			endif;
		elseif(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==TIMER_GROWUP)then
				ChangeMaxHitpoints(GetTechTreeHitpoints());
				UpdateGrowUpValue();
			elseif(iTimerID==TIMER_FATIGUE)then
				ChangeFatigue(-0.02);
			elseif(iTimerID==999)then
				if(GetTaskMgr()^.GetCurTaskName()=="Hypnosis")then
					GetTaskMgr()^.GetCurTask()^.EndTask();
				endif;
			elseif(iTimerID==TIMER_RAGETO)then
				if(GetClassName()=="hu_mammoth")then
					RageTo();
				elseif(GetClassName()=="hu_rhino")then
					RhinoRageTo();
				elseif(GetClassName()=="aje_brachiosaurus")then
					BrachioRageTo();
				endif;
			elseif(iTimerID==AGILITY_TIMER)then
				CalcNextWalkTarget();
			elseif(iTimerID==FORCE_HEALING)then
				//Henry: force spellcasters to heal
				var bool bTransport=HasOpenBuildUp();
				if(GetPassengers().NumEntries()<=0||!bTransport)then
					DeleteTimer(FORCE_HEALING);
					return;
				endif;
				if(GetTransportObj().IsValid())then return; endif;
				if(bTransport)then
					var int i, iC=m_xPassengers.NumEntries();
					for(i=0)cond(i<iC)iter(i++)do
						var ^CCharacter pxChar=cast<CCharacter>(m_xPassengers[i].GetObj());
						if(pxChar!=null)then
							if(pxChar^.GetClassName()=="hu_druid"||pxChar^.GetClassName()=="aje_shaman"||pxChar^.GetClassName()=="ninigi_monk"||pxChar^.GetClassName()=="seas_medic")then
								if(pxChar^.GetHealingRadius()>0.0f && pxChar^.SomeoneToHeal(false))then
									pxChar^.HealUnits(false, true);
								endif;
							endif;
						endif;
					endfor;
				endif;
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	export proc bool IsBaby()
		var real fNow=CTimeMgr.Get().GetVirtualTime();
		var real fBirthTime=GetAttribs()^.GetValueFloat("birth_time");
		var real fLifeTime=fNow-fBirthTime;
		var real fVF=CTimeMgr.Get().GetVirtualFactor();
		var real fGrowUp=GetTechTreeValueR("growup_duration",CTimeMgr.Get().GetVirtualDayLength()/fVF)*fVF;
		return (fLifeTime<fGrowUp);
	endproc;
	
	proc void UpdateGrowUpValue()
		m_fGrowUpValue=CalculateHitpointsFromGrowUpSize(1.0);
		var ^CAttribs pxA=GetAttribs();
		if(pxA!=null)then
			pxA^.SetValue("is_baby",m_fGrowUpValue<1.0f);
		endif;
	endproc;
	
	export proc real GetGrowUpValue()
		return m_fGrowUpValue;
	endproc;
	
	export proc real GetDmg()
		return m_fGrowUpValue*m_fDamage;
	endproc;
	
	proc int GetHelperCount(^CGameObj p_pxEnemy)
		var ^CFightingObj pxEnemy=cast<CFightingObj>(p_pxEnemy);
		if(pxEnemy==null)then return 0; endif;
		var real fForeignDmg=pxEnemy^.GetDmg();
		if(fForeignDmg==0.0)then return 0; endif;
		var real fForeignDuration=Math.Max(pxEnemy^.GetWeaponDuration(),0.001f);
		if(fForeignDuration==0.0)then return 1000; endif;
		var real fOwnHitpoints=Math.Max(GetHitpoints(),1.0f);
		if(fOwnHitpoints==0.0)then return 1000; endif;
		var real fForeinTime=fOwnHitpoints/(fForeignDmg*fForeignDuration);
		var real fOwnDmg=GetDmg();
		if(fOwnDmg==0.0)then return 1000; endif;
		var real fOwnDuration=Math.Max(GetWeaponDuration(),0.001f);
		if(fOwnDuration==0.0)then return 0; endif;
		var real fForeignHitpoints=pxEnemy^.GetHitpoints();
		if(fForeignHitpoints==0.0)then return 0; endif;
		var real fOwnTime=fForeignHitpoints/(fOwnDmg*fOwnDuration);
		return Math.Floor(fOwnTime/fForeinTime).ToInt();
	endproc;
	
	proc int GetMaxHelperCount()
		return GetTechTreeValueI("maxhelpers",0);
	endproc;
	
	proc int GetAvailableHelperCount(^CGameObj p_pxEnemy, bool p_bGetThem)
		if(p_pxEnemy==null)then return 0; endif;
		var CObjList xHelper;
		var CObjQuery xQ;
		xQ.SetClass(GetClassName());
		xQ.RegionCircle(GetPos(),GetSightRange());
		xQ.Exclude(GetHandle());
		var ^CNest pxNest=cast<CNest>(m_xNest.GetObj());
		if(pxNest!=null)then //check if enemy is in safe area
			var vec3 vEnemyPos=p_pxEnemy^.GetPos();
			if(!pxNest^.IsInSafeArea(vEnemyPos))then
				xQ.SetAttribsNeg("is_baby",true);
			endif;
		endif;
		// no one found, don't attack
		if(!xQ.Execute(xHelper))then return 0; endif;
		xHelper.SortDistance(p_pxEnemy^.GetPos());
		if(p_bGetThem)then
			var CGameEvtPtr xEvt=CGameEvtPtr.CreateEvent("Fight");
			xEvt.SetObjHandle(0,p_pxEnemy^.GetHandle());
			var int i, iC=xHelper.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				var ^CFightingObj pxObj=cast<CFightingObj>(xHelper[i].GetObj());
				if(pxObj==null)then continue; endif;
				pxObj^.HandleEvent(xEvt);
			endfor;
		endif;
		return xHelper.NumEntries();
	endproc;
	
	proc real GetSightRange()
		var real fRange=GetAlarmRange();
		if(GetAttackRange()>fRange)then
			fRange=GetAttackRange();
		endif;
		if(GetFOWRange()>fRange)then
			fRange=GetFOWRange();
		endif;
		return 2.0f*fRange;
	endproc;
	
	proc void Flee(CObjHndl p_xEnemy)
		var ^CTask pxCurTask=GetCurTask();
		if(cast<CFlee>(pxCurTask)==null)then
			if(GetFatigue()>=1.0f)then
				// give up for 5 seconds, than we check it again
				SetIdleAnim();
				WaitAction(1.0f);
			else
				var real fSlowDown=0.0f;
				if(cast<CSleep>(pxCurTask)!=null)then
					fSlowDown=1.0f;
				endif;
				var ^CFlee pxTask=cast<CFlee>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"Flee"));
				if(pxTask!=null)then
					var bool bR=pxTask^.Init(GetHandle(),p_xEnemy,fSlowDown);
					if(bR)then
						SetTaskFO(pxTask);
					else
						pxTask^.GetFactory()^.FreeState(pxTask);
					endif;
				endif;
			endif;
		endif;
	endproc;
	
	proc void Flee(CObjHndl p_xEnemy, bool p_bForce)
		var ^CTask pxCurTask=GetCurTask();
		if(cast<CFlee>(pxCurTask)==null)then
			if(GetFatigue()>=1.0f&&!p_bForce)then
				SetIdleAnim();
				WaitAction(1.0f);
			else
				var real fSlowDown=0.0f;
				if(cast<CSleep>(pxCurTask)!=null)then
					fSlowDown=1.0f;
				endif;
				var ^CFlee pxTask=cast<CFlee>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"Flee"));
				if(pxTask!=null)then
					var bool bR=pxTask^.Init(GetHandle(),p_xEnemy,fSlowDown);
					if(bR)then
						SetTaskFO(pxTask);
					else
						pxTask^.GetFactory()^.FreeState(pxTask);
					endif;
				endif;
			endif;
		endif;
	endproc;
	
	export proc void OnDefend(^CGameObj p_pxEnemy)
		var ^CFightingObj pxEnemy;
		if(p_pxEnemy!=null)then
			pxEnemy=cast<CFightingObj>(p_pxEnemy);
		endif;
		if(pxEnemy!=null)then
			if(GetOwner()==-1)then
				if(pxEnemy^.IsItATrap())then
					Flee(pxEnemy^.GetHandle(),true);
					return;
				elseif(pxEnemy^.IsFlyingUnit()&&!CanShootAir())then
					Flee(pxEnemy^.GetHandle(),true);
					return;
				endif;
			endif;
		endif;
		var ^CNest pxNest=cast<CNest>(m_xNest.GetObj());
		if(pxNest!=null)then
			pxNest^.AnimalAttacked(this,pxEnemy);
		endif;
		var bool bFlee=false;
		// wild animals
		if(GetOwner()==-1)then
			if(IsInFight())then
				return;
			endif;
			// friendly animals
			if(GetAggressive()==-1)then
				bFlee=true;
			else
				//if(m_xLastOnAttackChecked==p_pxEnemy^.GetHandle())then return; endif;
				m_xLastOnAttackChecked=p_pxEnemy^.GetHandle();
				var int iTTHelper = GetMaxHelperCount();
				var int iNeededHelper = GetHelperCount(pxEnemy);
				var bool bWorldEnemy = p_pxEnemy^.GetOwner()==-1;
				if(GetAggressive()==0)then// neutral animals
					if(bWorldEnemy && iTTHelper<iNeededHelper)then
						bFlee=true;
					elseif(bWorldEnemy && GetAvailableHelperCount(pxEnemy, false)<iNeededHelper)then
						bFlee=true;
					else
						if(!m_bIsHelpShout)then
							GetAvailableHelperCount(pxEnemy, true);
						endif;
					endif;
				elseif(GetAggressive()==1)then// aggressiv animals
					if(bWorldEnemy && (iTTHelper*2)<iNeededHelper)then
						bFlee=true;
					elseif(bWorldEnemy && GetAvailableHelperCount(pxEnemy, false)<(iNeededHelper*2))then
						bFlee=true;
					else
						if(!m_bIsHelpShout)then
							GetAvailableHelperCount(pxEnemy, true);
						endif;
					endif;
				endif;
				if(!bFlee && pxNest!=null)then//check enemy pos
					var vec3 vEnemyPos=pxEnemy^.GetPos();
					if(!pxNest^.IsInActionArea(vEnemyPos))then
						bFlee=true;
					endif;
				endif;
				if(!bFlee && (!CanWalk()&&CanSwim()&&(m_fAttackRange<1.0)))then//check enemy pos
					var bool bHarbour=cast<CHarbour>(pxEnemy)!=null;
					var real fHeight=CSrvWrap.GetScapeMgr().GetHeight(pxEnemy^.GetPos().GetX(),pxEnemy^.GetPos().GetY());
					var real fSeaLevel=CSrvWrap.GetScapeMgr().GetSeaLevel()-0.5;
					if(!bHarbour && fHeight>fSeaLevel)then
						bFlee=true;
					endif;
				endif;
				if(!bFlee)then
					m_xLastOnAttackChecked=CObjHndl.Invalid();
				endif;
			endif;
		endif;
		if(bFlee)then
			m_bIsHelpShout=false;
			Flee(pxEnemy^.GetHandle());
			return;
		endif;
		super.OnDefend(p_pxEnemy);
	endproc;
	
	export proc bool IsVegetarian()
		return (GetAggressive()!=1);
	endproc;
	
	export proc void OnKill()
		if(IsWildAnimal() && GetOwner()==-1)then
			CScareMap.Get().AddScareSource(GetPos(),60.0f,360.0f, GetSizeClass(), GetClassName());
		endif;
		super.OnKill();
	endproc;
	
	export proc void GetScared()
		var vec3 vPos=GetPos();
		UnscarePos(vPos,2.0f);
		GoTo(vPos,true,GetMaxSpeed(),true, true);
	endproc;
	
	proc bool UnscarePos(ref vec3 p_rvPos)
		return UnscarePos(p_rvPos,1.0f);
	endproc;
	
	//	return true if position is scared
	proc bool UnscarePos(ref vec3 p_rvPos,real p_fFactor)
		if(GetAggressive()==1)then return false; endif;
		var vec3 vCenter;
		var real fRadius;
		if(!CScareMap.Get().GetStrongestScareSource(GetHandle(),p_rvPos,vCenter,fRadius))then return false; endif;
		fRadius*=p_fFactor;
		var vec3 vDir=p_rvPos-vCenter;
		var ^CNest pxNest=cast<CNest>(m_xNest.GetObj());
		if(pxNest==null)then
			p_rvPos=vCenter+(vDir.GetNormalized()*fRadius);
			return true;
		endif;
		// try to unscare pos in direction away from scare center
		var vec3 vTestPos=vCenter+(vDir.GetNormalized()*fRadius);
		if(pxNest^.AcceptablePos(vTestPos,IsBaby(),true))then
			p_rvPos=vTestPos;
			return true;
		endif;
		var int iTimeout=30;
		while(iTimeout-->0)do
			var vec3 vTestPos;
			if(!pxNest^.GetRandomPoint(vTestPos,IsBaby(),true))then return true; endif;
			if(!CScareMap.Get().GetStrongestScareSource(GetHandle(),vTestPos,vCenter,fRadius))then
				p_rvPos=vTestPos;
				return true;
			endif;
		endwhile;
		// TODO: find best point inside action area and out of scare
		return true;
	endproc;
	
	proc bool IsScaredPos(vec3 p_vPos)
		if(GetAggressive()==1)then return false; endif;
		var vec3 vCenter;
		var real fRadius;
		return CScareMap.Get().GetStrongestScareSource(GetHandle(),p_vPos,vCenter,fRadius);
	endproc;
	
	proc bool IsPositionOk(vec3 p_vPos)
		var ^CNest pxNest=cast<CNest>(m_xNest.GetObj());
		if(pxNest!=null)then
			return pxNest^.AcceptablePos(p_vPos,IsBaby());
		endif;
		var ^CFlock pxFlock=cast<CFlock>(m_xFlock.GetObj());
		if(pxFlock!=null)then
			return pxFlock^.AcceptablePos(p_vPos);
		endif;
		return true;
	endproc;
	
	export proc void UpdateFoodCache()
		m_xFoodCache=0;
		var CObjQuery xOQ;
		if(IsVegetarian())then
			//look for plants, or eat some grass...
			var vec3 vMyPos=GetPos();
			xOQ.SetType("TREE");
			xOQ.SetType("VGTN", true);		//vegetation
		else
			//meat eater
			//look for meat...
			xOQ.SetType("FOOD");
		endif;
		var ^CNest pxNest=cast<CNest>(m_xNest.GetObj());
		if(pxNest!=null)then
			if(IsBaby())then
				xOQ.SetRegion(pxNest^.GetSafeArea());
			else
				xOQ.SetRegion(pxNest^.GetActionArea());
			endif;
		else
			xOQ.RegionCircle(GetPos(), 50.0f);
		endif;
		xOQ.Execute(m_xFoodCache);
		m_xLastUpdateFoodCache=CTimeMgr.Get().GetTime();
	endproc;
	
	proc void Feed(CObjHndl p_xObj)
		var ^CFeed pxTask=cast<CFeed>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(), "Feed"));
		if(pxTask==null)then return; endif;
		pxTask^.Init(GetHandle(),p_xObj);
		SetTaskFO(pxTask);
		m_xLastFeedingTime=CTimeMgr.Get().GetTime();
	endproc;
	
	proc void Feed(vec3 p_vPos)
		var ^CFeed pxTask=cast<CFeed>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(), "Feed"));
		if(pxTask==null)then return; endif;
		var bool bR=pxTask^.Init(GetHandle(),p_vPos);
		if(bR)then
			SetTaskFO(pxTask);
		else
			pxTask^.GetFactory()^.FreeState(pxTask);
		endif;
		m_xLastFeedingTime=CTimeMgr.Get().GetTime();
	endproc;
	
	proc bool IsNightActive()
		var string sObjPath=GetObjPath();
		return (m_xTechTree.GetValueB(sObjPath+"/nightactive",false));
	endproc;
	
	export proc bool IsSleepTime()
		return (CTimeMgr.Get().IsVirtualDay()==IsNightActive());
	endproc;
	
	export proc void SetIdleAnim()
		if(HasAnim("standanim") && GetCurrentAnimName()!="standanim")then
			SetAnim("standanim",3);
		endif;
	endproc;
	
	///////
	//	Players Animal feeding+misc
	///////
	
	export proc void SetAnimalType()
		var int iHerb, iCarn, iBugged, iSpecial, iTransformable;
		var real fAdapt=0.0f;
		iHerb=m_xTechTree.GetValueI(GetObjPath()+"/herbivore", 0);
		iCarn=m_xTechTree.GetValueI(GetObjPath()+"/carnivore", 0);
		fAdapt=m_xTechTree.GetValueR(GetObjPath()+"/adaption", 4.0f);
		iBugged=m_xTechTree.GetValueI(GetObjPath()+"/bugged", 0);
		iSpecial=m_xTechTree.GetValueI(GetObjPath()+"/isspecial", 0);
		iTransformable=m_xTechTree.GetValueI(GetObjPath()+"/transform", 0);
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("Herbivore", iHerb>0);
			pxAttr^.SetValue("Carnivore", iCarn>0);
		endif;
		m_bHerbivore=iHerb>0;
		m_bCarnivore=iCarn>0;
		m_bBugged=iBugged>0;
		m_bSpecial=iSpecial>0;
		m_fAdaption=fAdapt;
		m_bTransformable=iTransformable>0;
	endproc;
	
	export proc void SetAdditionalBeastThings()
		if(HasTimer(FORCE_HEALING))then DeleteTimer(FORCE_HEALING); endif;
		if(GetPassengers().NumEntries()>=0 && HasOpenBuildUp())then
			CreateTimer(FORCE_HEALING, CGameTimeSpan.OneSecond() * 10.0, true);
		endif;
	endproc;
	
	export proc void ForceHealing()
		if(HasTimer(FORCE_HEALING))then DeleteTimer(FORCE_HEALING); endif;
		if(GetPassengers().NumEntries()>=0 && HasOpenBuildUp())then
			CreateTimer(FORCE_HEALING, CGameTimeSpan.OneSecond() * 10.0, true);
		endif;
	endproc;
	
	proc void EatPlantsOrMeat(^CGameObj p_pxObject, vec3 p_vPos, bool p_bFastFood, bool p_bQ)
		if(HasFullHP())then return; endif;
		var ^CEating pxTask=cast<CEating>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(), "Eating"));
		if(pxTask==null)then return; endif;
		var bool bInit=false;
		if(p_pxObject!=null)then
			bInit=pxTask^.Init(GetHandle(),p_pxObject^.GetHandle());
		else
			bInit=pxTask^.Init(GetHandle(),p_vPos, p_bFastFood);
		endif;
		if(!bInit)then pxTask^.GetFactory()^.FreeState(pxTask); return; endif;
		pxTask^.SetUserCommand(true);
		NewTaskFO(pxTask,p_bQ);
		//pxTask^.SetUserCommand(p_iUserCmd==1);
	endproc;
	
	proc void GetMeatSearch(string p_sFood, vec3 p_vPos)
		if(HasFullHP())then return; endif;
		var CObjQuery xMeatSearch;
		var CObjList xMeat;
		xMeatSearch.SetClass(p_sFood+"_food");
		xMeatSearch.RegionCircle(p_vPos,100.0);
		if(xMeatSearch.Execute(xMeat))then
			xMeat.SortDistance(p_vPos);
			while(xMeat.NumEntries()>0)do
				if(!xMeat[0].IsValid())then xMeat.DeleteEntry(0); continue; endif;
				if(xMeat[0].GetObj()==null)then xMeat.DeleteEntry(0); continue; endif;
				EatPlantsOrMeat(xMeat[0].GetObj(), p_vPos, false, true);
				break;
			endwhile;
		endif;
	endproc;
	
	export proc void DoChopAnim()
		AnimAction("attack_front");
	endproc;
	
	export proc string EatAnim()
		return "feeding";
	endproc;
	
	export proc bool IsHerbivore()
		return m_bHerbivore;
	endproc;
	
	export proc bool IsBugged()
		return m_bBugged;
	endproc;
	
	export proc bool IsSpecial()
		return m_bSpecial;
	endproc;
	
	export proc bool IsCarnivore()
		return m_bCarnivore;
	endproc;
	
	export proc real GetAdaption()
		return m_fAdaption;
	endproc;
	
	// Henry: from 2.5.8 not used... (for the time being)
	export proc bool IsTransformable()
		return m_bTransformable;
	endproc;
	
	export proc bool IsHunting()
		return m_bHunting;
	endproc;
	
	export proc void SetHunting(bool p_bHunting)
		m_bHunting=p_bHunting;
	endproc;
	
	export proc void StopEverything()
		super.StopEverything();
		m_bHunting=false;
	endproc;
	
//	export proc real TakeDmgFromBuildup(^CFightingObj p_pxEnemy, real p_fFactor, real p_fHitDelay)
//		if(p_pxEnemy==null)then return 0.0; endif;
//		if(IsFeignDeath()&&GetCurTask()!=null)then
//			var ^CFeignDeath pxTask=cast<CFeignDeath>(GetCurTask());
//			if(pxTask!=null)then
//				pxTask^.Break();
//			endif;
//		endif;
//		return super.TakeDmgFromBuildup(p_pxEnemy, p_fFactor, p_fHitDelay);
//	endproc;
		export proc real TakeDmg(^CFightingObj p_pxEnemy)
		return super.TakeDmg(p_pxEnemy);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile)
		return super.TakeDmg(p_pxEnemy, p_bProjectile);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, real p_fFactor)
		return super.TakeDmg(p_pxEnemy, p_fFactor);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile, real p_fFactor)
		return super.TakeDmg(p_pxEnemy, p_bProjectile, p_fFactor);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile, real p_fFactor, real p_fHitDelay)
		return super.TakeDmg(p_pxEnemy, p_bProjectile, p_fFactor, p_fHitDelay);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile, real p_fFactor, real p_fHitDelay, real p_fArmorPiercing)
		if(p_pxEnemy==null)then return 0.0; endif;
//		if(IsFeignDeath()&&GetCurTask()!=null)then
//			var ^CFeignDeath pxTask=cast<CFeignDeath>(GetCurTask());
//			if(pxTask!=null)then
//				pxTask^.Break();
//			endif;
//		endif;
		if(GetOwner()==-1&&p_pxEnemy^.CanTame())then
			var real fSupposedDmg = p_pxEnemy^.GetDmg();
			fSupposedDmg = Math.Ceil(fSupposedDmg);
			var real fHitpoints = GetHitpoints();
			var real fMinTresshold = GetMaxHitpoints()/5.0f;
			if(fMinTresshold<300.0f)then fMinTresshold = 300.0f; endif;
			if(fMinTresshold>1500.0f)then fMinTresshold = 1500.0f; endif;
			if(!(GetHitpoints()>fMinTresshold&&GetHitpoints()>=fSupposedDmg))then
				if(CouldBeStolen(p_pxEnemy))then;
					return 0.0;
				endif;
			endif;
		endif;
		return super.TakeDmg(p_pxEnemy,p_bProjectile, p_fFactor, p_fHitDelay, p_fArmorPiercing);
	endproc;
	
	export proc bool CouldBeStolen(^CFightingObj p_pxTamer)
		if(p_pxTamer==null)then return false; endif;
		if(!IsWildAnimal()||GetOwner()!=-1)then return false; endif;
		var int iCurrentUser=GetOwner();
		if(iCurrentUser<-1||iCurrentUser>7)then return false; endif;
		var int iCandidat=p_pxTamer^.GetOwner();
		if(iCandidat<0||iCandidat>7)then return false; endif;
		begin check;
			var bool bIsSupplyOn=CMirageSrvMgr.Get().UseSupply();
			var bool bAllowed=false;
			if(!DoesCountInUnitLimit())then
				bAllowed=true;
			else
				if(bIsSupplyOn)then
					bAllowed=(GetLevel()<0||CRequirementsMgr.Get().CheckSupply(iCandidat, true, "dummy", GetLevel(), GetClassName(), true));
				else
					bAllowed=CRequirementsMgr.Get().CheckUnits(iCandidat,GetLevel(),true,true);
				endif;
			endif;
			if(!bAllowed)then
				return false;
			else
				while(m_xPassengers.NumEntries()>0)do
					if(!OnDismount(m_xPassengers[0]))then
						m_xPassengers.DeleteEntry(0);
					endif;
				endwhile;
				SetOwner(iCandidat);
				SetCmdID(iCandidat);
				if(GetActAutonomous())then
					SetActAutonomous(false);
				endif;
				DeleteTimer(TIMER_FATIGUE);
				var ^CNest pxNest=cast<CNest>(m_xNest.GetObj());
				if(pxNest!=null)then
					pxNest^.DieAnimal(GetHandle());
				endif;
				DeleteTimer(AGILITY_TIMER);
				var ^CFlock pxFlock=cast<CFlock>(m_xFlock.GetObj());
				if(pxFlock!=null)then
					pxFlock^.RemoveMember(GetHandle());
				endif;
				m_xNest=CObjHndl.Invalid();
				StopEverything();
				var ^CAttribs pxAttr=GetAttribs();
				if(pxAttr==null)then return false; endif;
				SetTamed(true);
				SetSelectable(true);
				m_bStolen=true;
				UpdateGfxFlags();
				ResetFlag();
				CreateCaptain();
//				AddHitpoints(500.0);
				CSrvWrap.SendGenericEvtToPlayer(iCandidat, "ocupy_unit\t" +GetGuid().ToString()+"\t"+5.ToString());
				if(HasTimer(TIMER_LEVELUP_INV))then
					DeleteTimer(TIMER_LEVELUP_INV);
				endif;
				CreateTimer(TIMER_GOT_STOLEN, CGameTimeSpan.OneSecond() * 1.5, false);
			endif;
		end check;
		return true;
	endproc;
	
	export proc void UpdateWeaponAttribs(real p_fMinRange, real p_fMaxRange, real p_fMeleeDmg, real p_fRangeDmg, real p_fSecondaryDmg, real p_fMeleeDur, real p_fRangeDur, real p_fMeleePiercing, real p_fRangePiercing, int p_iDamageType, int p_iMSlot, int p_iRSlot, string p_sSlot3)
		if(p_fMeleeDmg > 0.0f)then
			p_fMeleeDmg*=GetGrowUpValue();
		endif;
		if(p_fRangeDmg > 0.0f)then
			p_fRangeDmg*=GetGrowUpValue();
		endif;
		super.UpdateWeaponAttribs(p_fMinRange, p_fMaxRange, p_fMeleeDmg, p_fRangeDmg, p_fSecondaryDmg, p_fMeleeDur, p_fRangeDur, p_fMeleePiercing, p_fRangePiercing, p_iDamageType, p_iMSlot, p_iRSlot, p_sSlot3);
	endproc;
	
	export proc void MakeCamouflage(CObjHndl p_xSpy, int p_iOwner)
		m_xSpy=p_xSpy;
		RemoveUnit();
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("unit_count",false);
			pxAttr^.SetValue("camouflage_anml",1);
		endif;
		m_bCamouflage=true;
		var string sClass=GetClassName();
		if(sClass!="Kentrosaurus"&&sClass!="Macrolemys"&&sClass!="Stegosaurus"&&sClass!="Mammoth")then
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_MISC,false);
		endif;
	endproc;
	
	export proc bool DoesCountInUnitLimit()
		return !m_bCamouflage;
	endproc;
	
	export proc void CreateCaptain()
		if(IsWildAnimal())then
			return;
		endif;
		return super.CreateCaptain();
	endproc;
	
	export proc void UpdateNest(CObjHndl p_xNew)
		m_xNest=p_xNew;
	endproc;
	
	export proc void ReBuildWeapon()
	endproc;
	
	export proc string GetVictoryAnim()
		var string sAnim="menace";
		if(GetClassName()=="aje_dilophosaurus")then
			var int iR=Random.GetInt()%3;
			if(iR==1)then
				sAnim="shake";
			elseif(iR==2)then
				sAnim="threaten";
			endif;
		endif;
		return sAnim;
	endproc;
	
	export proc bool IsOnlyCamouflage()
		return m_bCamouflage;
	endproc;
	
	export proc bool SetRallyPoint(vec3 p_vPoint, CObjHndl p_xTarget)
		var bool bR=super.SetRallyPoint(p_vPoint, p_xTarget);
		if(m_xSpy.IsValid())then
			var ^CFightingObj pxSpy=cast<CFightingObj>(m_xSpy.GetObj());
			if(pxSpy!=null)then
				pxSpy^.SetRallyPoint(GetRallyPosSimple(),GetRallyTarget());
			endif;
		endif;
		return bR;
	endproc;
	
	export proc CObjHndl GetNest()
		return m_xNest;
	endproc;
	
	export proc bool AttackWildTarget(^CFightingObj p_pxEnemy)
		if(p_pxEnemy==null||GetOwner()!=-1||!m_bCarnivore||m_xFoodCache.NumEntries()>0||!HasFullHP()||!IsHungry())then
			return false;
		elseif(p_pxEnemy^.IsBaby())then
			return false;
		endif;
		var CObjList xHelper;
		var CObjQuery xQ;
		xQ.SetClass(GetClassName());
		xQ.RegionCircle(GetPos(),GetSightRange());
		xQ.Exclude(GetHandle());
		xQ.SetAttribsNeg("is_baby",true);
		if(xQ.Execute(xHelper))then
			xHelper.SortDistance(p_pxEnemy^.GetPos());
		endif;
		var int iNeededHelper=GetHelperCount(p_pxEnemy);
		var int iAvailableHelper=xHelper.NumEntries();
		if(iAvailableHelper<(iNeededHelper*2))then
//		if(iAvailableHelper>=(Math.Floor(iNeededHelper.ToReal()*1.5f)).ToInt())then
			var CGameEvtPtr xEvt=CGameEvtPtr.CreateEvent("Fight");
			xEvt.SetObjHandle(0,p_pxEnemy^.GetHandle());
			var int i;
			for(i=0)cond(i<iAvailableHelper)iter(i++)do
				var ^CFightingObj pxObj=cast<CFightingObj>(xHelper[i].GetObj());
				if(pxObj==null||pxObj^.IsBaby())then continue; endif;
				pxObj^.HandleEvent(xEvt);
			endfor;
			OnAttack(p_pxEnemy);
			return true;
		endif;
		return false;
	endproc;
	
	export proc bool IsVisInFOWNew(string p_sClass)
		if(GetOwner()==-1&&p_sClass=="seas_great_cannon"&&!AttackInFOW())then return false; endif;
		return IsVisInFOW();
	endproc;
	
	export proc string GetReportCode()
		return "unit";
	endproc;
	
	export proc string GetFirstStrikeAnim()
		var string sFSAnim="first_strike";
		if(HasAnim(sFSAnim)) then return sFSAnim; endif;
		return "";
	endproc;
	
	export proc string GetThreatAnim()
		if(GetGfxName()=="Atroxosaurus")then
			return "roaring";
		endif;
		return "menace";
	endproc;
	
endclass;
	
	///////
	//	Children Classes
	///////

class CArenaAnimal inherit CAnimal
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_PARTYCOL,false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_HELMET,false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMOR,false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_STANDARTE,false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMORSADDLE,false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_MISC,false);
	endproc;
	
	export proc void SetOwner(int p_iOwner)
		super.SetOwner(p_iOwner);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_PARTYCOL,false);
	endproc;
	
	export proc void CheckLevelFlag()
		return;
	endproc;
	
	export proc void CreateCaptain()
	endproc;

endclass;

class CAllosaurus inherit CAnimal
	
	constructor()
		m_xSink.m_xOnObjAdd=OnObjAdd;
		m_xSink.m_xOnObjRem=OnObjRem;
	endconstructor;
	
	proc bool OnObjAdd(CObjHndl p_xHndl)
		if(m_bToBeDeleted)then return false; endif;
		var ^CFightingObj pxO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxO==null)then return false; endif;
		if(pxO^.GetOwner()==GetOwner())then return false; endif;
		if(CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxO^.GetOwner(), GetOwner())&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxO^.GetOwner()))then return false; endif;
		if(!CSrvWrap.GetDiplomacyMgr().GetIsEnemy(GetOwner(), pxO^.GetOwner()))then return false; endif;
		if(pxO^.GetType()=="BLDG")then return false; endif;
		m_xRegionObjects.Include(p_xHndl);
		pxO^.SetMirageFlag(CFightingObj.MIRAGE_KING_JAW, true);
		return true;
	endproc;
	
	proc bool OnObjRem(CObjHndl p_xHndl)
		if(m_xRegionObjects.FindEntry(p_xHndl)==-1)then return false; endif;
		var ^CFightingObj pxO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxO==null)then return false; endif;
		pxO^.SetMirageFlag(CFightingObj.MIRAGE_KING_JAW, false);
		m_xRegionObjects.RemEntry(p_xHndl);
		return true;
	endproc;
	
	proc bool CheckScrunch(string p_sTTPath)
		if(!CRequirementsMgr.Get().CheckInvention(this, GetOwner(), "AlloScrunch", GetTribeName()))then return false; endif;
		if(!CheckSpecialActionTimer(p_sTTPath))then return false; endif;
		if(!m_xCurEnemy.IsValid())then return false; endif;
		if(m_xCurEnemy.GetObj()^.GetOwner()==GetOwner())then return false; endif;
		var ^CFightingObj pxObj=cast<CFightingObj>(m_xCurEnemy.GetObj());
		var bool bInvalid; var CObjHndl xInvalid;
		if(pxObj==null||!IsInCombatRange(pxObj,false))then return false; endif;
		if(GetAngleToR(m_xCurEnemy.GetObj())>0.39)then return false; endif;
		return true;
	endproc;
	
	proc void StartScrunch(string p_sTTPath, bool p_bQ, bool p_bAILock)
//		MemorizeCurrentFightState(m_xCurEnemy,false,false);
		var ^CAlloScrunch pxTask=cast<CAlloScrunch>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"AlloScr"));
		if(pxTask==null)then return; endif;
		var bool bReturn=pxTask^.Init(GetHandle(), m_xCurEnemy, p_sTTPath);
		if(bReturn)then
			SetAILock(p_bAILock);
			pxTask^.SetUserCommand(true);
			AddTask(pxTask,p_bQ);
		else
			pxTask^.GetFactory()^.FreeState(pxTask);
		endif;
	endproc;
	
	export proc void UpdateGfxFlags()
		if(GetClassName()=="aje_allosaurus")then
			var bool bArmorInvented=CRequirementsMgr.Get().CheckInvention(this, GetOwner(), "aje_allosaurus_armor", GetTribeName());
			if(!GetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMOR) && bArmorInvented)then
				SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMOR,true);
			elseif(GetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMOR) && !bArmorInvented)then
				SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMOR,false);
			endif;
			if(m_xTechTree.GetValueB("/Objects/Aje/InventObjects/warpath/invented",false))then
				if(!HasPersonalRegion())then
					var vec3 vD; vD.SetXYZ(35.0, 35.0, 0.0);
					CreatePersonalRegion("KingJaw_"+GetName()+"_"+Random.GetInt().ToString(), vD, 010b);
					AddRangedBuff("owner_less_defense");
				endif;
			endif;
		endif;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(	IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			)then return; endif;
		if(GetTransportObj().IsValid()&&!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/LeaveTransport")>=0))then return; endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("/AlloScrunch")!=(-1))then
				if(CheckScrunch(p_sMiscParams))then
					StartScrunch(p_sMiscParams,p_bQ, p_bA);
				endif;
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	export proc string GetVictoryAnim()
		var string sAnim="menace";
		if(Random.GetInt()%2==1)then
			sAnim="shake";
		endif;
		return sAnim;
	endproc;
	
	export proc void InitOwnRegion()
		if(GetClassName()=="aje_allosaurus")then
			if(m_xTechTree.GetValueB("/Objects/Aje/InventObjects/warpath/invented",false))then
				if(!HasPersonalRegion())then
					var vec3 vD; vD.SetXYZ(35.0, 35.0, 0.0);
					CreatePersonalRegion("KingJaw_"+GetName()+"_"+Random.GetInt().ToString(), vD, 010b);
					AddRangedBuff("owner_less_defense");
				endif;
			endif;
		endif;
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		po_rxLink="Ride";
		SetCaptainAnim("ride_idle_0");
		SetCaptainAttackAnim("ride_attack_front");
		return true;
	endproc;
	
	export proc real FeedFactor()
		return 2.5;
	endproc;
	
//	export proc real FeedFactor()
//		return(m_xTechTree.GetValueR(GetObjPath()+"/FeedFactor",2.5f));
//	endproc;
	
endclass;

class CAnkylosaurus inherit CAnimal
	
	var string m_sOldFightAnim;
	var CFightingObj.CFightAnim m_xOldFightAnim;
	
	var string m_sRamWeapon;
	
	constructor()
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			StartTT();
			CreatePersonalProduceUnit();
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_MISC,false);
		endif;
	endproc;
	
	export proc void DestroyBuildUp()
		super.DestroyBuildUp();
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_MISC,false);
		UpdateEquipment();
		SetAttackType(0);
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		if(HasBuildUp())then
			po_rxLink="Dri1";
			po_rbIsBuildUpLink=true;
			return true;
		else
			return super.GetCaptainLink(po_rxLink, po_rbIsBuildUpLink);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CAnkylosaurus] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xBase="Anky";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		pxArc^ << m_sRamWeapon;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="Anky")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			pxArc^ << m_sRamWeapon;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void ReBuildWeapon()
		UpdateEquipment();
		SetAttackType(0);
	endproc;
	
	export proc void HandleAction(string p_sAction)
		if(p_sAction.Find("aje_ankylosaurus_catapult")>=0||p_sAction.Find("aje_ankylosaurus_dino")>=0)then
			if(!HasBuildUp(CBuildUpBase.TYPE_WEAPON))then
				SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_MISC,true);
				SetBuildUp(CBuildUpBase.TYPE_WEAPON);
				var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("aje_ankylosaurus_catapult", GetOwner());
				if(pxO!=null)then
					GetBuildUp()^.AddObj(pxO^.GetHandle(), "con");
				endif;
				cast<CBuildUpWeapon>(GetBuildUp())^.SetCanRotate(true);
				SetAttackType(1);
			endif;
		else
			DestroyBuildUp();
			ResetFlag();
		endif;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(	IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			)then return; endif;
		if(GetTransportObj().IsValid()&&!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/LeaveTransport")>=0))then return; endif;
		if(p_sCommand=="Cancel")then
			var ^CVirtualProduceUnit pxUnit=cast<CVirtualProduceUnit>(GetProduceUnit().GetObj());
			if(pxUnit==null)then
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			else
				pxUnit^.ReactToGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams, p_bQ, p_bS, p_bA);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	export proc void SetCurEnemy(CObjHndl p_xHndl)
		super.SetCurEnemy(p_xHndl);
		UpdateEquipment();
	endproc;
	
	export proc void OnTechTreeChange(ref CStringArray p_rasChanges)
		super.OnTechTreeChange(p_rasChanges);
		var bool bUpdate=false;
		var int i, iC=p_rasChanges.NumEntries();
		for(i=0) cond(i<iC) iter(++i)do
			if(p_rasChanges[i].Find("/InventObjects/ram/")>=0)then
				bUpdate=true;
			elseif(p_rasChanges[i].Find("/ForceWeaponUpdate")>=0)then
				bUpdate=true;
			endif;
		endfor;
		if(bUpdate)then
			UpdateEquipment();
		endif;
	endproc;
	
	export proc string GetRightHandWeapon()
		if(GetClassName()=="aje_ankylosaurus" && !HasBuildUp() && CRequirementsMgr.Get().CheckInvention(this, GetOwner(), "ram", GetTribeName()))then
//			if(m_xCurEnemy.IsValid() && m_xCurEnemy.GetObj()^.GetType()=="BLDG")then
			if(m_xCurEnemy.IsValid() && m_xCurEnemy.GetObj()^.GetType()!="BLDG")then
				if(m_sRamWeapon.IsEmpty())then
					UpdateEquipment();
				endif;
				return m_sRamWeapon;
			endif;
		endif;
		return m_pxWeaponMgr^.GetRightHandWeapon();
	endproc;
	
	export proc void UpdateEquipment()
		if(GetClassName()=="aje_ankylosaurus" && !HasBuildUp() && CRequirementsMgr.Get().CheckInvention(this, GetOwner(), "ram", GetTribeName()))then
//			if(m_xCurEnemy.IsValid() && m_xCurEnemy.GetObj()^.GetType()=="BLDG")then
			if(m_xCurEnemy.IsValid() && m_xCurEnemy.GetObj()^.GetType()!="BLDG")then
				m_sRamWeapon="/Objects/Aje/Weapons/aje_ankylosaurus_weapon_ram_";
				if(GetLevel()==0)then
					m_sRamWeapon+="a";
				elseif(GetLevel()==1)then
					m_sRamWeapon+="b";
				elseif(GetLevel()==2)then
					m_sRamWeapon+="c";
				elseif(GetLevel()==3)then
					m_sRamWeapon+="d";
				elseif(GetLevel()==4)then
					m_sRamWeapon+="e";
				endif;
				if(GetCurrentWeapon()!=m_sRamWeapon)then
					SetAttackDirection(Math.Pi());
					ClearWeaponCache();
					UpdateWeapons(m_sRamWeapon);
					var ^CAttribs pxAttr=GetAttribs();
					if(pxAttr!=null && pxAttr^.GetValue("Equip_Slot_0")!=m_sRamWeapon)then
						pxAttr^.SetValue("Equip_Slot_0",m_sRamWeapon);
					endif;
					m_bWeaponHasChanged=true;
					m_bOwnWeaponHasChanged=true;
				endif;
				return;
			endif;
		endif;
		if(!m_sRamWeapon.IsEmpty())then
			SetAttackDirection(0.0);
			ClearWeaponCache();
			m_sRamWeapon="";
		endif;
		super.UpdateEquipment();
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		if(HasBuildUp())then
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_MISC,true);
		else
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_MISC,false);
		endif;
	endproc;
	
	export proc void DoCaptainAttackAnim()
		if(HasBuildUp(CBuildUpBase.TYPE_WEAPON))then
			if(m_xCaptain.IsValid())then
				var ^CGameObj pxCaptain=m_xCaptain.GetObj();
				if(pxCaptain^.HasAnim(m_sCaptainAttackAnim))then
					pxCaptain^.SetAnim(m_sCaptainAttackAnim, 1);
				endif;
			endif;
		else
			return super.DoCaptainAttackAnim();
		endif;
	endproc;
	
endclass;

//REDUNDANT
class CAnurognathus inherit CAnimal
	
	var vec3 	m_vPosToFly;
	
	constructor()
	endconstructor;
	
	destructor()
	enddestructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetCanWalk(false);
		SetCanFly(true);
	endproc;

endclass;

class CBrachiosaurus inherit CResourceAnimal
	
	var CDockInfo m_xDockInfo;
	var CObjHndl m_xExtraCaptain;
	var CObjList m_xClimbers;
	var bool m_bSiegeBreak;
	var int m_iArrows;
	
	export constructor()
		m_sRagePath="Actions/Aje/Moves/ANML/BrachioStampede";
		var int iIndex=AddAutoSpecialMove(m_sRagePath);
		m_xDockInfo.SetMoveCallback(Climb);
		m_iArrows=1;
		m_axAutoSpecialMoves[iIndex].m_xOnCheckConditions=CheckRageTo;
		m_axAutoSpecialMoves[iIndex].m_xOnStartAction=StartRageTo;
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc bool IsDocked()
		return m_xDockInfo.GetDocked();
	endproc;
	
	export proc void DoChopAnim()
		var array string asAnims;
		asAnims.AddEntry("shuffle");
		asAnims.AddEntry("brachio_fm_0");
//		asAnims.AddEntry("first_strike");
		asAnims.AddEntry("attack_01");
		asAnims.AddEntry("attack_02");
		asAnims.AddEntry("stomp");
		asAnims.AddEntry("attack_front");
		var int iRandom=Random.GetInt()%asAnims.NumEntries();
		if(HasAnim(asAnims[iRandom]))then
			AnimAction(asAnims[iRandom]);
		endif;
	endproc;
	
	export proc string EatAnim()
		var array string asAnims;
		asAnims.AddEntry("brachio_fm_1");
		asAnims.AddEntry("brachio_fm_2");
		var int iRandom=Random.GetInt()%asAnims.NumEntries();
		return asAnims[iRandom];
	endproc;
	
	export proc real GetAdaption()
		return 7.0f;
	endproc;
	
	proc real Climb(CObjHndl p_xActor,bool p_bUp)
		var ^CCharacter pxActor=cast<CCharacter>(p_xActor.GetObj());
		if(pxActor==null)then return -1.0f; endif;
		if(m_xDockInfo.GetDocked())then
			return pxActor^.StartBrachioClimb(GetHandle(),p_bUp,false,false);
		endif;
		return 0.0f;
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			StartTT();
			CreatePersonalProduceUnit();
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_MISC,false);
		endif;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		var ^CDockWall pxTaskDW=cast<CDockWall>(GetCurTask());
		if(pxTaskDW!=null)then
			pxTaskDW^.SetDockInfo(^m_xDockInfo);
			pxTaskDW^.UpdateBrach();
		endif;
	endproc;
	
	export proc ref CDockInfo GetDockInfo()
		return m_xDockInfo;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CBrachiosaurus] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xBase="Brac"; //CBrachiosaurus
		var int iVersion=4;
		if(CMirageSrvMgr.SDK())then
			iVersion=3;
		endif;
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,iVersion);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xDockInfo.DoKArc(pxArc^);
		if(iVersion>=4)then
			m_xExtraCaptain.DoKArc(pxArc^);
			m_xClimbers.DoKArc(pxArc^);
			pxArc^ << m_bSiegeBreak;
		endif;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="Brac")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xDockInfo.DoKArc(pxArc^);
			if(p_pxReaderNode^.GetVersion()==2)then
				var CObjHndl xProdUnit;
				xProdUnit.DoKArc(pxArc^);
			endif;
			if(p_pxReaderNode^.GetVersion()>=4)then
				m_xExtraCaptain.DoKArc(pxArc^);
				m_xClimbers.DoKArc(pxArc^);
				pxArc^ << m_bSiegeBreak;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void DestroyBuildUp()
		super.DestroyBuildUp();
		m_xExtraCaptain=CObjHndl.Invalid();
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_MISC,false);
		UpdateGfxFlags();
		SetAttackType(0);
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("IsSiegeUnit", 0);
		endif;
	endproc;
	
	export proc void HandleAction(string p_sAction)
		var string sName="Invalid";
		if(HasBuildUp()&&GetBuildUp()^.GetPrimaryLinkedObj().IsValid())then
			sName=GetBuildUp()^.GetPrimaryLinkedObj().GetObj()^.GetClassName();
		endif;
		var ^CAttribs pxAttr=GetAttribs();
		if(p_sAction.Find("aje_brachiosaurus_mobile_camp")>=0)then
			if(sName!="aje_brachiosaurus_mobile_camp")then
				DestroyBuildUp();
				SetBuildUp(CBuildUpBase.TYPE_WEAPON_TRANSPORTER);
				var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("aje_brachiosaurus_mobile_camp", GetOwner());
				GetBuildUp()^.AddObj(pxO^.GetHandle(), "con");
//				cast<CBuildUpWeapon>(GetBuildUp())^.SetWeaponClass("aje_brachiosaurus_mobile_camp");
				cast<CBuildUpWeapon>(GetBuildUp())^.SetWeaponClass(GetClassName());
				cast<CBuildUpWeapon>(GetBuildUp())^.SetAutoAttack(true);
				SetTransportClass(1);
				SetRallySite(true);
				SetCanFightAttrib(true);
			endif;
		elseif(p_sAction.Find("aje_brachiosaurus_catapult")>=0)then
			if(sName!="aje_brachiosaurus_catapult")then
				DestroyBuildUp();
				SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_MISC,true);
				SetBuildUp(CBuildUpBase.TYPE_WEAPON);
				var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("aje_brachiosaurus_catapult", GetOwner());
				if(pxO!=null)then
					GetBuildUp()^.AddObj(pxO^.GetHandle(), "con");
				endif;
				cast<CBuildUpWeapon>(GetBuildUp())^.SetCanRotate(true);
				SetAttackType(1);
				SetRallySite(false);
				SetCanFightAttrib(true);
			endif;
		elseif(p_sAction.Find("aje_brachiosaurus_transporter")>=0)then
			if(sName!="aje_brachiosaurus_transporter")then
				DestroyBuildUp();
				SetBuildUp(CBuildUpBase.TYPE_TRANSPORTER_OPEN);
				cast<CBuildUpTransporterOpen>(GetBuildUp())^.AddIgnoreLink("Dri1");
				var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("aje_brachiosaurus_transporter", GetOwner());
				GetBuildUp()^.AddObj(pxO^.GetHandle(), "con");
				var ^CCaptain pxC=cast<CCaptain>(CSrvWrap.GetObjMgr()^.CreateObj("universal_captain", GetOwner()));
				pxC^.Init(GetHandle());
//				pxC^.SetGFX("aje_rider_b");
				pxC^.Init(GetHandle(),"aje_rider_b",true);
				m_xExtraCaptain=pxC^.GetHandle();
				GetBuildUp()^.AddObj(m_xExtraCaptain, "Ride");
				pxC^.SetAnim("ride_idle_0",3);
				SetCanFightAttrib(true);
				CreateCaptain();
				AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
/*				pxC=cast<CCaptain>(CSrvWrap.GetObjMgr()^.CreateObj("universal_captain", GetOwner()));
				pxC^.Init(GetHandle());
				pxC^.SetName("Nummer2");*/
				cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.AddObjCaptain(m_xCaptain, "Dri1", -1.0, pxO^.GetHandle());
				cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.SetWeaponClass("aje_archer");
				cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.SetCanRotate(true);
				cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.SetAdditionalWeapon(true);
				var ^CGameObj pxObj=m_xCaptain.GetObj();
				if(pxObj!=null)then
					pxObj^.SetAnim("standanim",3);
				endif;
				SetRallySite(false);
			endif;
		elseif(p_sAction.Find("aje_brachiosaurus_siege")>=0)then
			if(sName!="aje_brachiosaurus_siege")then
				DestroyBuildUp();
				SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE, true);
				SetBuildUp(CBuildUpBase.TYPE_SIEGE);
				var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("aje_brachiosaurus_siege", GetOwner());
				if(pxO!=null)then
					GetBuildUp()^.AddObj(pxO^.GetHandle(), "con");
				endif;
				SetCanFightAttrib(false);
				if(pxAttr!=null)then
					pxAttr^.SetValue("IsSiegeUnit", 1);
				endif;
				SetRallySite(false);
			endif;
		else
			DestroyBuildUp();
			SetCanFightAttrib(true);
			ResetFlag();
			SetRallySite(false);
		endif;
		GetBestWeapon(null, true);
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		if(HasBuildUp(CBuildUpBase.TYPE_SIEGE))then
			po_rxLink="Ride";
			SetCaptainAnim("ride_idle_0");
			return true;
		elseif(HasBuildUp(CBuildUpBase.TYPE_TRANSPORTER_OPEN))then
			SetCaptainAnim("standanim");
			po_rxLink="Dri1";
			SetCaptainAttackAnim("bow_1");
			po_rbIsBuildUpLink=true;
			return true;
		else
			return super.GetCaptainLink(po_rxLink, po_rbIsBuildUpLink);
		endif;
	endproc;
	
	proc bool IsSieging()
		return (GetCurTaskName()=="DockWall");
	endproc;
	
	export proc void BreakSiege()
		m_bSiegeBreak=true;
		while(m_xClimbers.NumEntries()>0)do
			var ^CCharacter pxC=cast<CCharacter>(m_xClimbers[0].GetObj());
			m_xClimbers.DeleteEntry(0);
			if(pxC!=null)then
				pxC^.TerminateAction();
				pxC^.BreakSieging();
			endif;
		endwhile;
		if(IsSieging()&&m_pxTaskMgr!=null)then
			m_pxTaskMgr^.BreakAll();
		endif;
		m_xClimbers.Clear();
	endproc;
	
	export proc void SetSiegeBreak(bool p_bOn)
		m_bSiegeBreak=p_bOn;
	endproc;
	
	proc void OnDockedWallDeleted()
		BreakSiege();
	endproc;
	
	export proc void BuildUpKeeperAttack()
		var string sAttack=m_xTechTree.GetValueS(GetObjPath()+"/KeeperAttack","");
		if(sAttack!="" && HasAnim(sAttack))then
			AnimAction(sAttack, 3, true, true);
		endif;
	endproc;
	
	proc void InvokeDock(bool p_bUserCommand,^CWall p_pxWall, bool p_bQ)
		if(!HasBuildUp(CBuildUpBase.TYPE_SIEGE))then return; endif;
		var ^CDockWall pxTask=cast<CDockWall>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"DockWall"));
		if(pxTask==null)then return; endif;
		var bool bOk=pxTask^.Init(GetHandle(),^m_xDockInfo,p_pxWall^.GetHandle());
		if(!bOk)then pxTask^.GetFactory()^.FreeState(pxTask); return; endif;
		pxTask^.SetUserCommand(p_bUserCommand);
		NewTaskFO(pxTask,p_bQ);
	endproc;
	
	proc bool Dock2Wall(^CWall p_pxWall,bool p_bUserCommand)
		if(!IsAbleToWalk())then return false; endif;
		if(p_pxWall==null)then return false; endif;
		var bool bNewUserCmd=p_bUserCommand;
		var bool bOldUserCmd=false;
		var ^CTask pxCurTask=GetCurTask();
		if(pxCurTask!=null)then
			bOldUserCmd=pxCurTask^.IsUserCommand();
		endif;
		if(!bNewUserCmd && bOldUserCmd)then return false; endif;
		m_xDockInfo.SetDocked(false,p_pxWall^.GetHandle());
		p_pxWall^.SetDockerObj(CObjHndl.Invalid());
//		InvokeDock(p_bUserCommand,p_pxWall);
		return true;
	endproc;
	
	export proc void DestroyTheWoods(string p_sPath, bool p_bQ, bool p_bAILock)
		if(!CRequirementsMgr.Get().CheckInvention(this, GetOwner(), "brachiostomp", GetTribeName()))then
			return;
		endif;
		if(!CheckSpecialActionTimer(p_sPath))then
			return;
		endif;
		var ^CBrachioHarvest pxTask=cast<CBrachioHarvest>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"BrHvst"));
		if(pxTask==null)then return; endif;
		var bool bReturn=pxTask^.Init(GetHandle(), GetPos(), p_sPath);
		if(bReturn)then
			SetAILock(p_bAILock);
			pxTask^.SetUserCommand(true);
			NewTaskFO(pxTask,p_bQ);
		else
			pxTask^.GetFactory()^.FreeState(pxTask);
		endif;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(m_xClimbers.Validate()>0)then return; endif;
		if(IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/Dismount")!=-1)
			)then return; endif;
		if(GetTransportObj().IsValid()&&!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/LeaveTransport")>=0))then return; endif;
		var ^CVirtualProduceUnit pxUnit=cast<CVirtualProduceUnit>(GetProduceUnit().GetObj());
		if(p_sCommand=="DockThatWall")then
			if(Dock2Wall(cast<CWall>(p_pxObject),true))then
				InvokeDock(true,cast<CWall>(p_pxObject),p_bQ);
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		elseif(p_sCommand=="Action")then
/*
			if(HasBuildUp(CBuildUpBase.TYPE_SIEGE))then
				if(p_sMiscParams.Find("AttackSrv")>=0 && m_xDockInfo.GetDocked())then
					// do nothing ;)
				else
					super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
				endif;
			endif;
*/
			if(p_sMiscParams.Find("/BrachioStomp")!=(-1))then
				if(CheckSpecialActionTimer(p_sMiscParams))then
					DestroyTheWoods(p_sMiscParams,p_bQ, p_bA);
				endif;
			elseif(p_sMiscParams.Find("/Build/CHTR/aje")!=-1)then
				if(pxUnit==null)then
					super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
				endif;
				pxUnit^.ReactToGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams, p_bQ, p_bS, p_bA);
				return;
			elseif(IsSieging()&&p_sMiscParams.Find("/GoAway")!=-1)then
				//don't go outa way while sieging!!!
				return;
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		elseif(p_sCommand.Find("SetRallyPoint")!=-1)then
			var CObjHndl xHndl;
			if(p_pxObject!=null)then
				xHndl=p_pxObject^.GetHandle();
			endif;
			SetRallyPoint(p_vPos,xHndl);
		elseif(p_sCommand=="Cancel")then
			pxUnit^.ReactToGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams, p_bQ, p_bS, p_bA);
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
//	export proc bool SetRallyPoint(vec3 p_vPoint, CObjHndl p_xTarget)
//		if(!p_xTarget.IsValid()&&p_vPoint=={0.0,0.0,0.0}&&GetRallySite())then
//			return false;
//		endif;
//		return super.SetRallyPoint(p_vPoint, p_xTarget);
//	endproc;
	
	export proc void SetBuildUp(int p_iType)
		super.SetBuildUp(p_iType);
		UpdateGfxFlags();
	endproc;
	
	export proc void UpdateGfxFlags()
		var string sName="Invalid";
		if(HasBuildUp()&&GetBuildUp()^.GetPrimaryLinkedObj().IsValid())then
			sName=GetBuildUp()^.GetPrimaryLinkedObj().GetObj()^.GetClassName();
			if(sName=="aje_brachiosaurus_catapult")then
				SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_MISC,true);
			else
				SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_MISC,false);
			endif;
		endif;
		if(GetClassName()=="aje_brachiosaurus")then
//			if(!HasBuildUp()||HasBuildUp(CBuildUpBase.TYPE_SIEGE))then
				if(!GetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMOR) && CRequirementsMgr.Get().CheckInvention(this, GetOwner(), "aje_brachiosaurus_armor", GetTribeName()))then
					SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMOR,true);
				endif;
//			elseif(GetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMOR))then
//				SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMOR,false);
//			endif;
		endif;
	endproc;
	
	export proc string GetVictoryAnim()
		var string sAnim="menace";
		var int iR=Random.GetInt()%3;
		if(iR==1)then
			sAnim="shuffle";
		elseif(iR==2)then
			sAnim="shake";
		endif;
		return sAnim;
	endproc;
	
	export proc void DoCaptainAttackAnim()
		if(m_xExtraCaptain.IsValid())then
			var ^CGameObj pxCaptain=m_xExtraCaptain.GetObj();
			if(pxCaptain==null)then return; endif;
			var string sAnim="ride_attack_front";
			if(pxCaptain^.HasAnim(sAnim))then
				pxCaptain^.SetAnim(sAnim, 1);
			endif;
		endif;
		return super.DoCaptainAttackAnim();
	endproc;
	
	export proc bool RegisterClimber(CObjHndl p_xClimber)
		if(!p_xClimber.IsValid()||m_bSiegeBreak)then return false; endif;
		m_xClimbers.Include(p_xClimber);
		return true;
	endproc;
	
	export proc bool UnregisterClimber(CObjHndl p_xClimber)
		if(!p_xClimber.IsValid())then return false; endif;
		if(m_xClimbers.FindEntry(p_xClimber)==-1)then return false; endif;
		m_xClimbers.RemEntry(p_xClimber);
		return true;
	endproc;
	
	export proc void Die()
		if(m_xExtraCaptain.IsValid())then
			m_xExtraCaptain.GetObj()^.Delete();
			m_xExtraCaptain=CObjHndl.Invalid();
		endif;
		super.Die();
	endproc;
	
	export proc int GetProjectilesNumber()
//		if(GetObjectFlag()=="aje_brachiosaurus_mobile_camp")then return m_iArrows; endif,
		return super.GetProjectilesNumber();
	endproc;
	
	export proc void UpdatePassengerAttribs()
		super.UpdatePassengerAttribs();
		m_iArrows=1+m_xPassengers.NumEntries();
		return;
	endproc;
	
	export proc string GetFirstStrikeAnim()
		var string sFSAnim="first_strike";
		if(!HasBuildUp() && HasAnim(sFSAnim)) then return sFSAnim; endif;
		return "";
	endproc;
	
	export proc bool CheckRageTo(string p_sTTPath)
		if(GetClassName()!="aje_brachiosaurus"||HasBuildUp())then return false; endif;
		if(HasTimer(TIMER_RAGETO))then return false; endif;
		if(!CRequirementsMgr.Get().CheckInvention(this, GetOwner(), "brachiostampede", GetTribeName()))then return false; endif;
		var ^CFightingObj pxEnemy=cast<CFightingObj>(m_xCurEnemy.GetObj());
		if(pxEnemy==null)then return false; endif;
		var real fRangeSquare=(pxEnemy^.GetPos() - GetPos()).AbsSquare();
		if(fRangeSquare<100.0)then return false; endif;
		if(fRangeSquare>(GetFOWRange()*GetFOWRange()))then return false; endif;
		return true;
	endproc;
	
	export proc void StartRageTo(string p_sTTPath)
		if(!HasTimer(TIMER_RAGETO))then
			CreateTimer(TIMER_RAGETO,CGameTimeSpan.OneSecond()*3.5,true);
			m_xRageStart=CTimeMgr.Get().GetTime();
			SetDefaultWalkSet(m_xRageWalkSet);
		endif;
	endproc;
	
endclass;

class CVelociraptorHandler inherit CAnimal
	
	proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(GetClassName()=="aje_velociraptor_handler")then
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_PARTYCOL,false);
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,false);
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_HELMET,false);
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_STANDARTE,false);
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_MISC,false);
		endif;
	endproc;
	
//	export proc void CheckLevelFlag()
//		return;
//	endproc;
	
	export proc void LinkCaptainObj()
		var ^CGameObj pxCaptain=m_xCaptain.GetObj();
		if(pxCaptain==null)then return; endif;
		SetCaptainAnim("idle_0");
		SetCaptainAttackAnim("victory_0");
		if(!HasBuildUp())then
			SetBuildUp(CBuildUpBase.TYPE_FAKE);
			GetBuildUp()^.AddObjFlex(pxCaptain^.GetHandle(), "Db_1", 3.0, GetHandle());
			GetBuildUp()^.UpdateLinkedObjs();
		endif;
	endproc;
	
	export proc void CreateCaptain()
		//buildup==captain doesn't works well -> skip with existing captain
		if(m_xCaptain.GetObj()!=null)then return; endif;
		super.CreateCaptain();
	endproc;
	
	export proc void OnActionStart()
		super.OnActionStart();
		var ^CGameObj pxCaptain=m_xCaptain.GetObj();
		if(pxCaptain!=null)then
			if(pxCaptain^.GetCurrentAnimName()=="walk_1")then
				var string sAnim="all_walk_3_loop";
				var int iWS=GetCurrentWalkSpeed();
				var string sSAnim="all_walk_"+iWS.ToString()+"_loop";
				if(pxCaptain^.HasAnim(sSAnim))then sAnim=sSAnim; endif;
				pxCaptain^.SetAnim(sAnim,0);
			endif;
		endif;
	endproc;
	
endclass;

class CGallimimus inherit CAnimal
endclass;

class CIguanodon inherit CResourceAnimal
	
	var bool			m_bEquipped;
	var CObjList		m_xAddons;
	var array vec3		m_avAddonOffsets;
	
	constructor()
		m_bEquipped=false;
	endconstructor;

	export destructor()
	enddestructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			if(GetClassName()=="aje_resource_collector")then
				SetTransportClass(1);
				SetBuildUp(CBuildUpBase.TYPE_WEAPON_TRANSPORTER);
				var CObjHndl xWagon, xBar;
				var string sTribe=GetTribeName();
				var ^CGameObj pxObj;
				pxObj=CSrvWrap.GetObjMgr()^.CreateObj("aje_resource_collector_a", GetOwner());
				if(pxObj!=null)then
					xWagon=pxObj^.GetHandle();
				endif;
				pxObj=CSrvWrap.GetObjMgr()^.CreateObj("aje_resource_collector_drawbar", GetOwner());
				if(pxObj!=null)then
					xBar=pxObj^.GetHandle();
				endif;
				GetBuildUp()^.AddObjFlex(xWagon, "Db_2", 3.0, xBar);
				GetBuildUp()^.AddObj(xBar, "Db_1");
				CreatePersonalProduceUnit();
				SetRallySite(true);
			endif;
		endif;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("count_as_hq",!m_bFeignDeath);
		endif;
		if(GetClassName()=="aje_resource_collector")then
			CBLDGMgr.Get().AddBuilding(this);
			UpdateGfxFlags();
		endif;
	endproc;
	
	export proc void UpdateDeliveries()
		super.UpdateDeliveries();
		if(!HasBuildUp())then return; endif;
		var ^CGameObj pxCollector=GetBuildUp()^.GetPrimaryLinkedObj().GetObj();
		if(pxCollector==null)then return; endif;
		var ^CAttribs pxDstAttribs=pxCollector^.GetAttribs();
		var ^CAttribs pxSrcAttribs=GetAttribs();
		if(pxSrcAttribs==null||pxDstAttribs==null)then return; endif;
		var array string asDeliveries;
		asDeliveries=4;
		asDeliveries[0]="stoneDelivery";
		asDeliveries[1]="woodDelivery";
		asDeliveries[2]="foodDelivery";
		asDeliveries[3]="ironDelivery";
		var int i, iC=asDeliveries.NumEntries();
		for(i=0)cond(i<iC)iter(++i)do
			var string sDelivery=asDeliveries[i];
			pxDstAttribs^.SetValue(sDelivery, pxSrcAttribs^.GetValueBool(sDelivery));
			pxSrcAttribs^.SetValue(sDelivery,0);
		endfor;
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="Igua")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			if(p_pxReaderNode^.GetVersion()==0)then
				var CObjHndl xProdUnit;
				xProdUnit.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void PrepareBuildUpTransferLinkedObjs()
		super.PrepareBuildUpTransferLinkedObjs();
		if(!HasBuildUp())then return; endif;
		var ^CGameObj pxCollector=GetBuildUp()^.GetPrimaryLinkedObj().GetObj();
		if(pxCollector==null)then return; endif;
		var ^CAttribs pxDstAttribs=pxCollector^.GetAttribs();
		if(pxDstAttribs==null)then return; endif;
		var array string asDeliveries;
		asDeliveries=4;
		asDeliveries[0]="stoneDelivery";
		asDeliveries[1]="woodDelivery";
		asDeliveries[2]="foodDelivery";
		asDeliveries[3]="ironDelivery";
		var int i, iC=asDeliveries.NumEntries();
		for(i=0)cond(i<iC)iter(++i)do
			var string sDelivery=asDeliveries[i];
			pxDstAttribs^.SetValue(sDelivery,0);
		endfor;
	endproc;
	
//	export proc bool IsAbleToFight()
//		if(GetClassName()=="aje_resource_collector")then
//			return false;
//		endif;
//	endproc;
	
	export proc void UpdateGfxFlags()
		if(!HasBuildUp())then return; endif;
		var ^CGameObj pxCollector=GetBuildUp()^.GetPrimaryLinkedObj().GetObj();
		if(pxCollector==null)then return; endif;
		var int iAge=0, iFinal=0;
		var string sName=pxCollector^.GetGfxName();
		var string sTribe=GetTribeName();
		var string sNewName="aje_resource_collector_";
		var CGameTime xTime=CTimeMgr.Get().GetTime();
		if(m_xTechTree.GetValueI("Objects/"+sTribe+"/InventObjects/liberator/invented",0)!=0)then
			SetAggressionState(0);
		endif;
		if(m_xTechTree.GetValueI("Objects/"+sTribe+"/InventObjects/final_stage/invented",0)!=0)then
			iFinal=6;
			sNewName += "e";
			BuildAddons();
		elseif(m_xTechTree.GetValueI("Objects/"+sTribe+"/InventObjects/age_5/invented",0)!=0)then
			sNewName += "e";
			iAge=5;
		elseif(m_xTechTree.GetValueI("Objects/"+sTribe+"/InventObjects/age_4/invented",0)!=0)then
			sNewName += "d";
			iAge=4;
		elseif(m_xTechTree.GetValueI("Objects/"+sTribe+"/InventObjects/age_3/invented",0)!=0)then
			sNewName += "c";
			iAge=3;
		elseif(m_xTechTree.GetValueI("Objects/"+sTribe+"/InventObjects/age_2/invented",0)!=0)then
			sNewName += "b";
			iAge=2;
		else
			sNewName += "a";
			iAge=1;
		endif;
		if(sNewName!=sName)then
			pxCollector^.SetGFX(sNewName);
		endif;
		var int iMaxAge=iAge+1;
		CheckEpoch(iMaxAge);
		var ^CAttribs pxAttribs=GetPlayerAttribs();
		if(pxAttribs!=null)then
			var int iOldAge=pxAttribs^.GetValueInt("age");
			if(iOldAge!=iAge&&iOldAge<iAge&&GetTribeName()==GetPlayerTribeName())then
				pxAttribs^.SetValue("age", iAge);
			endif;
			iOldAge=pxAttribs^.GetValueInt("final");
			if(iOldAge!=iFinal&&iOldAge==0&&GetTribeName()==GetPlayerTribeName())then
				pxAttribs^.SetValue("final", iFinal);
			endif;
		endif;
	endproc;
	
	export proc void UpdateHitpoints()
		super.UpdateHitpoints();
		UpdateDestructionFlags();
	endproc;
	
	proc bool UpdateDestructionFlags()
		if(HasBuildUp())then
			var ^CGameObj pxCollector=GetBuildUp()^.GetPrimaryLinkedObj().GetObj();
			if(pxCollector==null)then return false; endif;
			if(pxCollector^.GetConstructLevel()<4)then return false; endif;
			if(((GetHitpoints()!=0.0f)&&(GetMaxHitpoints()!=0.0f)))then
				var real fPercentage=GetHitpoints()/(GetMaxHitpoints()/100.0f);
				if(fPercentage<=25.0f)then
					if(pxCollector^.GetDestructLevel()!=2)then
						InvokeGenericSCEvent(14,4.0f);
						pxCollector^.SetDestructLevel(2);
					endif;
					return true;
				elseif(fPercentage<=50.0f)then
					if(pxCollector^.GetDestructLevel()!=1)then
						InvokeGenericSCEvent(14,4.0f);
						pxCollector^.SetDestructLevel(1);
					endif;
					return true;
				else
					pxCollector^.SetDestructLevel(0);
					return true;
				endif;
			endif;
		endif;
		return true;
	endproc;

	proc void BuildAddons()
		if(!m_bEquipped)then
			var CObjHndl xCollector=GetBuildUp()^.GetPrimaryLinkedObj();
			m_bEquipped=true;
			var CFourCC xLink="NOPE";
			var ^CMirageDeco pxA;
			m_avAddonOffsets.AddEntry({0.08,0.44,5.73});
			var int i, iC=m_avAddonOffsets.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				pxA=cast<CMirageDeco>(CSrvWrap.GetObjMgr()^.CreateObj("aje_final_stage_deco_"+i.ToString(),GetOwner(),GetPos(),GetRotation()));
				if(pxA!=null)then
					m_xAddons.AddEntry(pxA^.GetHandle());
					AddGroupedChildren(pxA^.GetGuid());
					pxA^.LinkAction(xCollector,xLink,m_avAddonOffsets[i]);
				endif;
			endfor;
		endif;
	endproc;
	
	export proc void OnTechTreeChange(ref CStringArray p_rasChanges)
		super.OnTechTreeChange(p_rasChanges);
		var int i,iC=p_rasChanges.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(p_rasChanges[i].Find("InventObjects/age_")!=-1)then
				//CheckAge();
			elseif(p_rasChanges[i].Find("InventObjects/final_stage")!=-1)then
				//CheckAge();
				BuildAddons();
			endif;
		endfor;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		var CObjHndl xCollector=GetBuildUp()^.GetPrimaryLinkedObj();
		var CFourCC xLink="NOPE";
		var int i, iC=m_xAddons.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CGameObj pxA=m_xAddons[i].GetObj();
			if(pxA!=null)then
				pxA^.LinkAction(xCollector,xLink,m_avAddonOffsets[i]);
			endif;
		endfor;
	endproc;

	export proc void TransferLinkedObjs(CObjHndl p_xC)
		if(!p_xC.IsValid())then return; endif;
		var CFourCC xLink="NOPE";
		while(m_xAddons.NumEntries()>0)do
			var ^CGameObj pxA = m_xAddons[0].GetObj();
			if(pxA==null)then
				m_xAddons.DeleteEntry(0);
				m_avAddonOffsets.DeleteEntry(0);
				continue;
			endif;
			RemGroupedChildren(pxA^.GetGuid());
			pxA^.TerminateAction();
			pxA^.LinkAction(p_xC,xLink,m_avAddonOffsets[0]);
			m_xAddons.DeleteEntry(0);
			m_avAddonOffsets.DeleteEntry(0);
		endwhile;
		m_xAddons.Clear();
	endproc;
	
	export proc CObjList GetAddons();
		return m_xAddons;
	endproc;
	
	export proc void Die()
		CBLDGMgr.Get().RemoveBuilding(this);
		super.Die();
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(	IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			)then return; endif;
		if(GetTransportObj().IsValid()&&!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/LeaveTransport")>=0))then return; endif;
		var ^CVirtualProduceUnit pxUnit=cast<CVirtualProduceUnit>(GetProduceUnit().GetObj());
		if(pxUnit==null)then
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			return;
		endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("/Build/CHTR/aje")!=-1||p_sMiscParams.Find("_worker_dr")!=-1)then
				pxUnit^.ReactToGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams, p_bQ, p_bS, p_bA);
				return;
			elseif(p_sMiscParams.Find("/Upgrades/"+GetClassName())!=-1)then
				pxUnit^.ReactToGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams, p_bQ, p_bS, p_bA);
				return;
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		elseif(p_sCommand.Find("SetRallyPoint")!=-1)then
			var CObjHndl xHndl;
			if(p_pxObject!=null)then
				xHndl=p_pxObject^.GetHandle();
			endif;
			SetRallyPoint(p_vPos,xHndl);
		elseif(p_sCommand=="Cancel")then
			pxUnit^.ReactToGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams, p_bQ, p_bS, p_bA);
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	export proc void SetFeignDeath(bool p_bDeath)
		super.SetFeignDeath(p_bDeath);
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("count_as_hq",!m_bFeignDeath);
		endif;
		CGameOverMgr.Get().CheckHQ(GetClassName(),!m_bFeignDeath,GetOwner(),GetHandle());
	endproc;
	
	export proc bool ShallBeRevealedAutomaticaly()
		if(GetClassName()=="aje_resource_collector")then return false; endif;
		return true;
	endproc;
	
//	export proc bool SetRallyPoint(vec3 p_vPoint, CObjHndl p_xTarget)
//		if(!p_xTarget.IsValid()&&p_vPoint=={0.0,0.0,0.0}&&GetRallySite())then
//			return false;
//		endif;
//		return super.SetRallyPoint(p_vPoint, p_xTarget);
//	endproc;
	
	export proc string GetReportCode()
		return "center";
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		if(HasBuildUp(CBuildUpBase.TYPE_FAKE))then
			po_rxLink="Ride";
			po_rbIsBuildUpLink=false;
			SetCaptainAnim("ride_idle_0");
			SetCaptainAttackAnim("ride_attack_front");
			return true;
		else
			return super.GetCaptainLink(po_rxLink, po_rbIsBuildUpLink);
		endif;
	endproc;
	
	export proc void DoCaptainAttackAnim()
		if(m_xCaptain.IsValid())then
			var ^CGameObj pxCaptain=m_xCaptain.GetObj();
			if(pxCaptain==null)then return; endif;
			var string sAnim=GetCaptainAttackAnim();
//			if(pxCaptain^.GetCurrentAnimName()!=sAnim&&pxCaptain^.HasAnim(sAnim))then
			if(pxCaptain^.HasAnim(sAnim))then
				pxCaptain^.SetAnim(sAnim, 1);
			endif;
		endif;
		return;
	endproc;
	
endclass;

class CTradeDino inherit CTradeTransporter
	
	export var CObjHndl m_xFakeCorpse;
		
	export constructor()
		m_xFakeCorpse=CObjHndl.Invalid();
	endconstructor;
	
	export destructor()
		if(m_xFakeCorpse.IsValid())then
			var ^CGameObj pxFC=m_xFakeCorpse.GetObj();
			if(pxFC!=null)then
				var ^CDino_Food pxDinoFood=cast<CDino_Food>(pxFC);
				if(pxDinoFood!=null)then
					pxDinoFood^.FeignDelete();
				endif;
			endif;
		endif;
	enddestructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CTradeDino] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		if(!CMirageSrvMgr.SDK())then
			var CFourCC xType="TrDn";
			var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
			var ^CArc pxArc=^(pxWalk^.GetArc());
			m_xFakeCorpse.DoKArc(pxArc^);
			pxWalk^.Close();
		endif;
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="TrDn")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			if(p_pxReaderNode^.GetVersion()>=1)then
				m_xFakeCorpse.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			SetType("ANML");
			InitAttribs();
		endif;
		UpdateAttribs(p_bLoad);
		AddUnit();
		if(!p_bLoad)then
			StartTT();
			SetCanFightAttrib(false);
		endif;
		OnTechTreeChange();
		//item inventory -> all levels can now have one item
		if(GetInventory()==null)then
			InitInventory(1);
		endif;
		if(GetClassName()=="ninigi_cart")then
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,true);
		endif;
		if(!p_bLoad)then
			if(GetClassName()=="ninigi_cart")then
				SetBuildUp(CBuildUpBase.TYPE_FAKE);
				var CObjHndl xWagon, xBar;
				var ^CGameObj pxObj=CSrvWrap.GetObjMgr()^.CreateObj("ninigi_cart_wagon", GetOwner());
				if(pxObj!=null)then
					xWagon=pxObj^.GetHandle();
				endif;
				pxObj=CSrvWrap.GetObjMgr()^.CreateObj("ninigi_cart_drawbar", GetOwner());
				if(pxObj!=null)then
					xBar=pxObj^.GetHandle();
				endif;
				GetBuildUp()^.AddObjFlex(xWagon, "Db_2", 3.0, xBar);
				GetBuildUp()^.AddObj(xBar, "Db_1");
			elseif(GetClassName()=="aje_trade_dino")then
				SetCanFightAttrib(true);
				SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE, true);
				SetBuildUp(CBuildUpBase.TYPE_FAKE);
				var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("aje_trade_dino_buildup", GetOwner());
				if(pxO!=null)then
					GetBuildUp()^.AddObj(pxO^.GetHandle(), "con");
				endif;
			endif;
		endif;
		SetAnimalType();
	endproc;
	
	export proc void SetAnimalType()
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("Herbivore", true);
		endif;
	endproc;
	
	export proc void PrepareBuildUpTransferLinkedObjs()
	endproc;
	
	export proc void Die()
		if(!IsDead()&&!IsDyingInTPO())then
			var ^CGameObj pxGameObj=CSrvWrap.GetObjMgr()^.CreateObj(GetClassName()+"_food",GetOwner(),GetPos(),GetRotation());
			if(pxGameObj!=null)then
				pxGameObj^.SetName(GetName());
				var ^CFood pxFood=cast<CFood>(pxGameObj);
				if(pxFood!=null)then
					pxFood^.SetRndInvMask(GetRndInvMask());
				endif;
				PrepareBuildUpTransferLinkedObjs();
				var ^CDino_Food pxDinoFood=cast<CDino_Food>(pxFood);
				if(pxDinoFood!=null)then
					pxDinoFood^.Initialize(this, m_iSizeClass, false);
					pxDinoFood^.SetAggressive(GetTechTreeAggressiv());
					if(HasBuildUp())then
//						pxDinoFood^.SetBuildUp(CBuildUpBase.TYPE_FAKE);
//						GetBuildUp()^.TransferLinkedObjs(pxDinoFood^.GetBuildUp());
						GetBuildUp()^.TransferLinkedObjs(pxDinoFood);
						pxDinoFood^.UpdateLinkedObjs();
					endif;
					
				endif;
				var real fNow=CTimeMgr.Get().GetVirtualTime();
				var ^CAttribs pxFoodAttribs=pxGameObj^.GetAttribs();
				if(pxFoodAttribs!=null)then
					pxFoodAttribs^.SetValue("birth_time",GetAttribs()^.GetValueFloat("birth_time"));
					pxFoodAttribs^.SetValue("growup_duration",GetAttribs()^.GetValueFloat("growup_duration"));
					pxFoodAttribs^.SetValue("die_time",fNow);
					var real fMaxHP=GetTechTreeHitpoints();
					var real fCurHP=CalculateHitpointsFromGrowUpSize(fMaxHP);
					var real fMaxValue=pxFoodAttribs^.GetValueInt("value").ToReal();
					pxFoodAttribs^.SetValue("value",((fCurHP*fMaxValue)/fMaxHP).ToInt());
				endif;
				var real fRadius=GetRadius();
				if(fRadius<=3.5)then
					pxGameObj^.InvokeGenericSCEvent(16,4.0f);
				elseif(fRadius<=5.0)then
					pxGameObj^.InvokeGenericSCEvent(10,4.0f);
				else
					pxGameObj^.InvokeGenericSCEvent(17,4.0f);
				endif;
			endif;
		endif;
		super.Die();
	endproc;
	
	export proc real CalculateHitpointsFromGrowUpSize(real p_fMaxHitpoints)
		var real fValue=p_fMaxHitpoints;
		var ^CAttribs pxAttr=GetAttribs();
		var real fNow=CTimeMgr.Get().GetVirtualTime();
		var real fBirthTime=pxAttr^.GetValueFloat("birth_time");
		var real fVF=CTimeMgr.Get().GetVirtualFactor();
		var real fGrowUp=GetTechTreeValueR("growup_duration",CTimeMgr.Get().GetVirtualDayLength()/fVF)*fVF;
		if(fBirthTime!=0.0f && fNow<(fBirthTime+fGrowUp))then
			if(fGrowUp>0.0f)then
				var real fStrength=((fNow-fBirthTime)/fGrowUp);
				if(fStrength<0.2f)then fStrength=0.2f; endif;//min 20%
				fValue=(fValue*fStrength);
			else
				var real fStrength=0.2f;
				fValue=(fValue*fStrength);
			endif;
		endif;
		return fValue;
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		if(GetClassName()=="aje_trade_dino")then
			if(HasBuildUp(CBuildUpBase.TYPE_FAKE))then
				po_rxLink="Dri1";
				po_rbIsBuildUpLink=true;
//				SetCaptainAnim("standanim");
//				SetCaptainAttackAnim("standanim");
				SetCaptainAnim("ride_idle_0");
				SetCaptainAttackAnim("ride_attack_front");
				return true;
			else
				return super.GetCaptainLink(po_rxLink, po_rbIsBuildUpLink);
			endif;
		elseif(GetClassName()=="ninigi_cart")then
			if(HasBuildUp(CBuildUpBase.TYPE_FAKE))then
				po_rxLink="Ride";
				po_rbIsBuildUpLink=false;
				SetCaptainAnim("ride_idle_0");
				SetCaptainAttackAnim("ride_idle_0");
//				SetCaptainAttackAnim("ride_attack_front");
//				SetCaptainAnim("standanim");
//				SetCaptainAttackAnim("standanim");
				return true;
			else
				return super.GetCaptainLink(po_rxLink, po_rbIsBuildUpLink);
			endif;
		else
			return false;
		endif;
	endproc;
	
	export proc void DoCaptainAttackAnim()
		if(m_xCaptain.IsValid())then
			var ^CGameObj pxCaptain=m_xCaptain.GetObj();
			if(pxCaptain==null)then return; endif;
			var string sAnim=GetCaptainAttackAnim();
			if(/*pxCaptain^.GetCurrentAnimName()!=sAnim&&*/pxCaptain^.HasAnim(sAnim))then
				pxCaptain^.SetAnim(sAnim, 1);
			endif;
		endif;
		return;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(	IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			)then return; endif;
		if(GetTransportObj().IsValid()&&!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/LeaveTransport")>=0))then return; endif;
		if(p_sCommand=="Action")then
//			if(p_sMiscParams.Find("/FeignDeath")!=-1 && GetClassName()=="aje_trade_dino")then
//				if(CheckSpecialActionTimer(p_sMiscParams))then
//					FeignDeathTask(true, p_sMiscParams,p_bQ);
//				endif;
//			elseif(p_sMiscParams.Find("/EatSomethingFast")>=0)then
			if(p_sMiscParams.Find("/EatSomethingFast")>=0)then
				EatPlantsOrMeat(null, GetPos(), true, p_bQ);
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		elseif(p_sCommand=="EatThatThing")then
			EatPlantsOrMeat(p_pxObject, p_vPos, false, p_bQ);
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	export proc void FeignDeathTask(bool p_bStart, string p_sPath, bool p_bQ)
		/*
		var ^CFeignDeath pxT=cast<CFeignDeath>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(), "FeignDth"));
		if(pxT!=null && !IsFeignDeath())then
			var bool bReturn=pxT^.Init(GetHandle(), p_bStart, p_sPath);
			if(bReturn)then
				pxTask^.SetUserCommand(true);
				NewTaskFO(pxTask,p_bQ);
				var ^CGameObj pxGameObj=CSrvWrap.GetObjMgr()^.CreateObj(GetClassName()+"_food",GetOwner(),GetPos(),GetRotation());
				if(pxGameObj!=null)then
					pxGameObj^.SetName(GetName());
					var ^CFood pxFood=cast<CFood>(pxGameObj);
					if(pxFood!=null)then
						pxFood^.SetRndInvMask(GetRndInvMask());
					endif;
					var ^CDino_Food pxDinoFood=cast<CDino_Food>(pxFood);
					if(pxDinoFood!=null)then
						m_xFakeCorpse=pxDinoFood^.GetHandle();
						pxDinoFood^.Initialize(this, m_iSizeClass, true);
						pxDinoFood^.SetAggressive(GetTechTreeAggressiv());
						if(HasBuildUp()&&GetBuildUp()^.GetPrimaryLinkedObj().IsValid())then
							var string sName=GetBuildUp()^.GetPrimaryLinkedObj().GetObj()^.GetClassName();
							pxDinoFood^.SetBuildUp(CBuildUpBase.TYPE_FAKE);
							var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj(sName,GetOwner(),GetPos(),GetRotation());
							if(pxO!=null)then
								pxDinoFood^.GetBuildUp()^.AddObj(pxO^.GetHandle(), "con");
							endif;
						endif;
					endif;
				endif;
			else
				pxT^.GetFactory()^.FreeState(pxT);
			endif;
		elseif(pxT!=null && IsFeignDeath())then
			var ^CFeignDeath pxTask=cast<CFeignDeath>(GetCurTask());
			if(pxTask!=null)then
				pxTask^.Break();
			endif;
		endif;
		*/
	endproc;
	
	export proc void SetFeignDeath(bool p_bDeath)
		m_bFeignDeath=p_bDeath;
		if(p_bDeath==false && m_xFakeCorpse.IsValid())then
			var ^CGameObj pxFC=m_xFakeCorpse.GetObj();
			if(pxFC!=null)then
				var ^CDino_Food pxDinoFood=cast<CDino_Food>(pxFC);
				if(pxDinoFood!=null)then
					pxDinoFood^.FeignDelete();
				endif;
			endif;
			m_xFakeCorpse=CObjHndl.Invalid();
		endif;
	endproc;
	
	proc void EatPlantsOrMeat(^CGameObj p_pxObject, vec3 p_vPos, bool p_bFastFood, bool p_bQ)
		if(HasFullHP())then return; endif;
		var ^CEating pxTask=cast<CEating>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(), "Eating"));
		if(pxTask==null)then return; endif;
		var bool bInit=false;
		if(p_pxObject!=null)then
			bInit=pxTask^.Init(GetHandle(),p_pxObject^.GetHandle());
		else
			bInit=pxTask^.Init(GetHandle(),p_vPos, p_bFastFood);
		endif;
		if(!bInit)then return; endif;
		if(bInit)then
			pxTask^.SetUserCommand(true);
			NewTaskFO(pxTask,p_bQ);
		else
			pxTask^.GetFactory()^.FreeState(pxTask);
		endif;
		//pxTask^.SetUserCommand(p_iUserCmd==1);
	endproc;
	
	export proc real GetAdaption()
		return 4.0f;
	endproc;
	
	export proc void DoChopAnim()
		AnimAction("attack_front");
	endproc;
	
	export proc string EatAnim()
		return "feeding";
	endproc;
	
//	export proc bool IsBugged()
//		return false;
//	endproc;
	
	export proc bool IsHerbivore()
		return true;
	endproc;
	
	export proc bool IsAbleToFight()
		return GetDmg()>0.0;
	endproc;
	
endclass;

class CMammoth inherit CAnimal
	
	export const string RALLY_PATH="/Filters/Hu/Upgrades/xenage/rally";
	
	constructor()
		m_sRagePath="Actions/Hu/Moves/ANML/Mammoth_Stampede";
		var int iIndex=AddAutoSpecialMove(m_sRagePath);
		m_axAutoSpecialMoves[iIndex].m_xOnCheckConditions=CheckRageTo;
		m_axAutoSpecialMoves[iIndex].m_xOnStartAction=StartRageTo;
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			ReBuildWeapon();
		endif;
	endproc;
	
	export proc void ReBuildWeapon()
		var string sClassName=GetClassName();
		if(sClassName=="hu_mammoth")then
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_MISC,true);
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE, true);
		elseif(sClassName=="hu_mammoth_lumber_upgrade")then
//			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_MISC,false);
//			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE, true);
//			SetBuildUp(CBuildUpBase.TYPE_FAKE);
//			var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("hu_mammoth_lumber_upgrade_buildup", GetOwner());
//			if(pxO!=null)then
//				GetBuildUp()^.AddObj(pxO^.GetHandle(), "we");
//			endif;
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_MISC,false);
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE, false);
			SetBuildUp(CBuildUpBase.TYPE_TRANSPORTER_OPEN);
			cast<CBuildUpTransporterOpen>(GetBuildUp())^.AddIgnoreLink("Dri1");
//			var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("hu_rhino_transporter_buildup", GetOwner());
			var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("hu_triceratops_transporter", GetOwner());
//			var vec3 vOffset={0.0,0.0,0.51};
			var vec3 vOffset={0.0,0.0,0.0};
			AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
			cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.AddObjCaptain(m_xCaptain, "Dri1", -1.0, pxO^.GetHandle());
			cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.SetWeaponClass("hu_archer");
			cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.SetCanRotate(true);
			cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.SetAdditionalWeapon(true);
//			GetBuildUp()^.AddObjCustomized(pxO^.GetHandle(), "Ride", vOffset);
			GetBuildUp()^.AddObjCustomized(pxO^.GetHandle(), "con", vOffset);
			pxO=CSrvWrap.GetObjMgr()^.CreateObj("hu_mammoth_lumber_upgrade_buildup", GetOwner());
			if(pxO!=null)then
				GetBuildUp()^.AddObj(pxO^.GetHandle(), "we");
			endif;
			pxO=CSrvWrap.GetObjMgr()^.CreateObj("hu_mammoth_lumber_upgrade_buildup", GetOwner());
			if(pxO!=null)then
				GetBuildUp()^.AddObj(pxO^.GetHandle(), "we");
			endif;
		elseif(sClassName=="hu_mammoth_log_cannon")then
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_MISC,true);
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE, false);
			SetBuildUp(CBuildUpBase.TYPE_WEAPON);
			var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("hu_mammoth_log_cannon_buildup_top", GetOwner());
			if(pxO!=null)then
				GetBuildUp()^.AddObj(pxO^.GetHandle(), "con");
			endif;
			pxO=CSrvWrap.GetObjMgr()^.CreateObj("hu_mammoth_log_cannon_buildup_bottom", GetOwner());
			if(pxO!=null)then
				GetBuildUp()^.AddObj(pxO^.GetHandle(), "con");
				pxO^.SetAnim("build_down", 0);
			endif;
			cast<CBuildUpWeapon>(GetBuildUp())^.SetCanRotate(true);
			cast<CBuildUpWeapon>(GetBuildUp())^.SetCanSwitchAttackMode(true);
			SetAttackType(1);
		endif;
	endproc;
	
	export proc void SwitchToAttackMode()
		TerminateAction();
		AnimAction("rest", 1, true, false);
		var ^CGameObj pxObj=GetBuildUp()^.GetLinkedObj(1).GetObj();
		if(pxObj!=null)then
			pxObj^.SetAnim("build_down", 1);
		endif;
	endproc;
	
	export proc void DoLevelUpAnim()
		if(GetCurrentAnimName()=="rest")then
			InvokeGenericSCEvent(35,1.0f);
		else
			super.DoLevelUpAnim();
		endif;
	endproc;
	
	export proc void SwitchToWalkMode()
		TerminateAction();
		AnimAction("rest", 0, false, true);
		var ^CGameObj pxObj=GetBuildUp()^.GetLinkedObj(1).GetObj();
		if(pxObj!=null)then
			pxObj^.SetAnim("build_up", 1);
		endif;
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		if(GetClassName()=="hu_mammoth_log_cannon")then
			po_rxLink="Dri1";
			po_rbIsBuildUpLink=true;
			SetCaptainAnim("balista_stand");
			SetCaptainAttackAnim("rhino_ballista_shoot");
			return true;
		elseif(HasBuildUp(CBuildUpBase.TYPE_TRANSPORTER_OPEN))then
			po_rxLink="Dri1";
			po_rbIsBuildUpLink=true;
			SetCaptainAnim("standanim");
			SetCaptainAttackAnim("bow_1");
			return true;
//			return false;
		else
			po_rxLink="Ride";
			SetCaptainAnim("ride_idle_0");
			SetCaptainAttackAnim("ride_attack_front");
			return true;
		endif;
	endproc;
	
	export proc void DoMineAnim()
		AnimAction("attack_front");
	endproc;
	
	export proc void DoCutAnim()
		AnimAction("stomp_harvest");
//		AnimAction("attack_front");
	endproc;
	
	export proc void DoTakeAnim()
		AnimAction("treejog");
	endproc;
	
	export proc bool NextJob(CObjHndl p_xTarget, CObjList p_xIgnoreBuildUps)
		if(!p_xTarget.IsValid())then return false; endif;
		var ^CBuilding pxBuilding=cast<CBuilding>(p_xTarget.GetObj());
		if(pxBuilding!=null && CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxBuilding^.GetOwner()))then
			if(pxBuilding^.IsReady())then
				var string sClassName=pxBuilding^.GetClassName();
				if(sClassName=="ninigi_lumbermill")then
					FindClosestResource(pxBuilding^.GetPos(), "Wood");
				elseif(sClassName=="hu_lumberjack_cottage")then
					FindClosestResource(pxBuilding^.GetPos(), "Lumber");
				elseif(sClassName=="ninigi_hunting_lodge")then
					FindClosestResource(pxBuilding^.GetPos(), "Food");
				elseif(sClassName=="hu_stone_quarry"||sClassName=="ninigi_stone_quarry")then
					FindClosestResource(pxBuilding^.GetPos(), "Stone");
				elseif(sClassName=="aje_bazaar"|| sClassName=="hu_marketplace"||sClassName=="hu_warehouse"||sClassName=="ninigi_warehouse"||sClassName=="seas_small_tent"||sClassName=="seas_steelwork")then
					FindClosestResource(pxBuilding^.GetPos(), "All");
				else
					return super.NextJob(p_xTarget,p_xIgnoreBuildUps);
				endif;
				return true;
			else
				return super.NextJob(p_xTarget,p_xIgnoreBuildUps);
			endif;
		endif;
		var ^CResource pxResource=cast<CResource>(p_xTarget.GetObj());
		if(pxResource!=null)then
			if(pxResource^.GetType()=="WOOD")then
				HarvestTask(pxResource,pxResource^.GetPos(),false);
			elseif(pxResource^.GetType()=="STON")then
				MineTask(pxResource,pxResource^.GetPos(),false);
			elseif(pxResource^.GetType()=="FRUI"||pxResource^.GetType()=="FOOD")then
				GetFoodTask(pxResource,pxResource^.GetPos(),false);
			else
				return false;
			endif;
			return true;
		endif;
		return super.NextJob(p_xTarget,p_xIgnoreBuildUps);
	endproc;
	
	export proc bool FindClosestResource(vec3 p_vPos, string p_sType);
		if(p_vPos=={0.0,0.0,0.0})then return false; endif;
		var real fSRadius=100.0;
		if(p_sType=="Mix"||p_sType=="Wood")then
			var int iSkip=0;
			var vec3 vTree;
			var bool bTreeFound=false;
			var bool bNewTree=false;
			var CForestSrvMgr.CTree xForTree;
			while(true)do
				bNewTree=CSrvWrap.GetForestMgr().FindNextTreeShortDelivery(xForTree,p_vPos,p_vPos,fSRadius,iSkip);
				if(!xForTree.IsValid())then break; endif;
				if(bNewTree==true)then
					CSrvWrap.GetForestMgr().SetHitPoints(xForTree, CSrvWrap.GetForestMgr().GetMaxHPFakeTrees());
				endif;
				CSrvWrap.GetForestMgr().GetTreePos(xForTree, vTree);
				if(Math.Abs(vTree.GetZ()-GetPos().GetZ()) > 10.0f)then //too much height difference...
					iSkip++;
					continue;
				endif;
				if(!CheckMaxAutoprodDist(vTree))then
					iSkip++;
					continue;
				endif;
				bTreeFound=true;
				break;
			endwhile;
			if(bTreeFound)then
				if(bNewTree==true)then
					CSrvWrap.GetForestMgr().SetHitPoints(xForTree, CSrvWrap.GetForestMgr().GetMaxHPFakeTrees());
					if(xForTree.IsFakeTree())then
						var bool bFound=Convert2ObjTree(xForTree);
					endif;
				endif;
			endif;
		endif;
		var CObjQuery xResourceSearch;
		if(p_sType=="Stone"||p_sType=="All")then
			xResourceSearch.SetType("STON",true);
			xResourceSearch.SetAttribsNeg("inactive","1");
		endif;
		if(p_sType=="Wood"||p_sType=="Lumber"||p_sType=="All")then
			xResourceSearch.SetType("TREE",true);
			xResourceSearch.SetType("WOOD",true);
		endif;
		if(p_sType=="Food"||p_sType=="Lumber"||p_sType=="All")then
			xResourceSearch.SetType("FOOD",true);
			xResourceSearch.SetType("FRUI",true);
			xResourceSearch.SetAttribsNeg("fish",1);
		endif;
		xResourceSearch.SetVisibility(GetOwner(),true);
		var CObjList xResources;
		xResourceSearch.RegionCircle(p_vPos,fSRadius);
		if(xResourceSearch.Execute(xResources))then
			xResources.SortDistance(p_vPos);
			while(xResources.NumEntries()>0&&!CheckMaxAutoprodDist(xResources[0]))do
				xResources.DeleteEntry(0);
			endwhile;
			if(xResources.NumEntries()>0)then
				var CFourCC xType=xResources[0].GetObj()^.GetType();
				var CObjHndl xResource=xResources[0];
				if(xType=="FOOD"||xType=="FRUI")then
					GetFoodTask(xResource.GetObj(),xResource.GetObj()^.GetPos(),false);
				elseif(xType=="STON")then
					MineTask(xResource.GetObj(),xResource.GetObj()^.GetPos(),false);
				elseif(xType=="TREE"||xType=="WOOD")then
					HarvestTask(xResource.GetObj(),xResource.GetObj()^.GetPos(),false);
				endif;
			endif;
		endif;
		return(true);
	endproc;
	
	proc bool Convert2ObjTree(ref CForestSrvMgr.CTree po_rxForTree)
		CSrvWrap.GetForestMgr().Refresh(po_rxForTree);
		var bool bFound=false;
		var vec3 vPos;
		if(!po_rxForTree.IsValid())then return bFound; endif;
		var int iTreeType=CSrvWrap.GetForestMgr().GetTreeType(po_rxForTree);
		if(iTreeType==-1)then return bFound; endif;
		if(CSrvWrap.GetForestMgr().GetTreePos(po_rxForTree, vPos)==false)then
			return bFound;
		endif;
		var string sSetting=CSrvWrap.GetCurLevel()^.GetLevelInfo().GetAttribs().GetValue("Setting");
		if(sSetting=="Cave1")then
			sSetting="Savanna";
		elseif(sSetting=="Cave2")then
			sSetting="Ashvalley";
		elseif(sSetting=="Cave3")then
			sSetting="Oasis";
		endif;
		var string sTree=sSetting+"_Tree_0"+(iTreeType+1).ToString();
		var CObjHndl xRet=CSrvWrap.GetForestMgr().ConvertTree(po_rxForTree,sTree);
		bFound=xRet.IsValid();
		return bFound;
	endproc;
	
	proc void HarvestTask(^CGameObj p_pxObject, vec3 p_vPos, bool p_bQ)
		if(!CanHarvest())then
			GoTo(p_vPos, true, GetDefaultSpeed(), true, true);
			return;
		endif;
		var ^CHarvesterTask pxTask=cast<CHarvesterTask>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"HarvestT"));
		if(pxTask==null)then return; endif;
		var bool bInit=false;
		if(p_pxObject!=null)then
			bInit=pxTask^.Init(GetHandle(),p_pxObject^.GetHandle());
		else
			bInit=pxTask^.Init(GetHandle(),p_vPos);
		endif;
		if(!bInit)then pxTask^.GetFactory()^.FreeState(pxTask); return; endif;
		pxTask^.SetUserCommand(true);
		NewTaskFO(pxTask,p_bQ);
	endproc;
	
	proc void MineTask(^CGameObj p_pxObject, vec3 p_vPos, bool p_bQ)
		if(!CanHarvest())then
			GoTo(p_vPos, true, GetDefaultSpeed(), true, true);
			return;
		endif;
		if(p_pxObject!=null)then
			var ^CMineTask pxTask=cast<CMineTask>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"MineT"));
//			if(pxTask==null)then return; endif;
//			pxTask^.Init(GetHandle(),p_pxObject^.GetHandle());
			if(pxTask!=null)then
				if(pxTask^.Init(GetHandle(),p_pxObject^.GetHandle()))then
					pxTask^.SetUserCommand(true);
					NewTaskFO(pxTask,p_bQ);
				else
					pxTask^.GetFactory()^.FreeState(pxTask);
				endif;
			else
				return;
			endif;
		else
			GoTo(p_vPos, true, GetDefaultSpeed(), true, p_bQ);
		endif;
	endproc;
	
	proc void GetFoodTask(^CGameObj p_pxObject, vec3 p_vPos, bool p_bQ)
		if(p_pxObject!=null)then
			var ^CGetFoodTask pxTask=cast<CGetFoodTask>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"GetFoodTask"));
			if(pxTask==null)then return; endif;
			if(pxTask^.Init(GetHandle(),p_pxObject^.GetHandle()))then
				pxTask^.SetUserCommand(true);
				NewTaskFO(pxTask,p_bQ);
			else
				pxTask^.GetFactory()^.FreeState(pxTask);
				return;
			endif;
		else
			GoTo(p_vPos, true, GetDefaultSpeed(), true, p_bQ);
		endif;
	endproc;
	
	proc bool Trumpet(string p_sTTPath, bool p_bQ, bool p_bAILock)
//		MemorizeCurrentFightState(CObjHndl.Invalid(),false,false);
		var ^CMammothTrumpet pxTask=cast<CMammothTrumpet>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"MTrumpet"));
		if(pxTask==null)then return false; endif;
		var bool bReturn=pxTask^.Init(GetHandle(),p_sTTPath);
		if(bReturn)then
			SetAILock(p_bAILock);
			pxTask^.SetUserCommand(true);
			NewTaskFO(pxTask,p_bQ);
		else
			pxTask^.GetFactory()^.FreeState(pxTask);
		endif;
		return bReturn;
	endproc;
	
	export proc void OnActionEnd(bool p_bBroken)
		if(!IsDead() && !IsFeignDeath())then
			if(HasBuildUp(CBuildUpBase.TYPE_WEAPON))then
//				if(!(cast<CBuildUpWeapon>(GetBuildUp()))^.IsInAttackMode())then
//					super.OnActionEnd(p_bBroken);
//					return;
				if((cast<CBuildUpWeapon>(GetBuildUp()))^.IsInAttackMode())then
					GetBuildUp()^.OnActionEnd();
					var ^CTask pxTask=GetCurTask();
					if(pxTask!=null)then
						if(p_bBroken)then
							pxTask^.ActionCanceled();
						else
							pxTask^.ActionSucceeded();
						endif;
					endif;
					GetFSM()^.Enable(true);
					return;
				endif;
			endif;
		endif;
		super.OnActionEnd(p_bBroken);
	endproc;
	
	export proc void TerminateActionFightTask()
		if(!IsDead() && !IsFeignDeath())then
			if(HasBuildUp(CBuildUpBase.TYPE_WEAPON))then
				if((cast<CBuildUpWeapon>(GetBuildUp()))^.IsInAttackMode())then
					return;
				endif;
			endif;
		endif;
		super.TerminateActionFightTask();
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(	IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/Dismount")!=-1)
			)then return; endif;
		if(GetTransportObj().IsValid()&&!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/LeaveTransport")>=0))then return; endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("mammoth_trumpet")!=(-1))then
				if(CheckSpecialActionTimer(p_sMiscParams))then
					Trumpet(p_sMiscParams,p_bQ, p_bA);
				endif;
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	export proc void UpdateGfxFlags()
		var string sClass=GetClassName();
		if(sClass=="hu_mammoth")then
			if(!GetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_HELMET) && m_xTechTree.GetValueB("/Objects/Hu/InventObjects/animal_blades/invented",false))then
				SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_HELMET,true);
			endif;
			if(!GetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMOR) && m_xTechTree.GetValueB("/Objects/Hu/InventObjects/hu_mammoth_armor/invented",false))then
				SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMOR,true);
				SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,false);
				SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMORSADDLE,true);
			endif;
		endif;
	endproc;
	
	export proc void LinkToStock(string p_sGFX)
		super.LinkToStock(p_sGFX);
		if(HasBuildUp(CBuildUpBase.TYPE_FAKE))then
			var ^CGameObj pxObj=GetBuildUp()^.GetPrimaryLinkedObj().GetObj();
			if(pxObj!=null)then
				var CFourCC xLink="psh1";
				pxObj^.SetLinkGFX(xLink, p_sGFX);
			endif;
		elseif(HasBuildUp(CBuildUpBase.TYPE_TRANSPORTER_OPEN))then
			var ^CGameObj pxObj=GetBuildUp()^.GetLinkedObj(1).GetObj();
			if(pxObj!=null)then
				var CFourCC xLink="psh1";
				pxObj^.SetLinkGFX(xLink, p_sGFX);
			endif;
		endif;
	endproc;
	
	export proc void ClearLink()
		super.ClearLink();
		if(HasBuildUp(CBuildUpBase.TYPE_FAKE))then
			var ^CGameObj pxObj=GetBuildUp()^.GetPrimaryLinkedObj().GetObj();
			if(pxObj!=null)then
				var CFourCC xLink="psh1";
				pxObj^.RemLinkGFX(xLink);
			endif;
		elseif(HasBuildUp(CBuildUpBase.TYPE_TRANSPORTER_OPEN))then
			var ^CGameObj pxObj=GetBuildUp()^.GetLinkedObj(1).GetObj();
			if(pxObj!=null)then
				var CFourCC xLink="psh1";
				pxObj^.RemLinkGFX(xLink);
			endif;
		endif;
	endproc;
	
	export proc string GetVictoryAnim()
		var string sAnim="menace";
		var int iR=Random.GetInt()%3;
		if(iR==1)then
			sAnim="shake";
		elseif(iR==2)then
			sAnim="stomp";
		endif;
		return sAnim;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		var string sClassName=GetClassName();
		if(sClassName=="hu_mammoth")then
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_MISC,true);
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE, true);
		elseif(sClassName=="hu_mammoth_lumber_upgrade")then
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_MISC,false);
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE, true);
			// Henry: HACK for old units...
			if(HasBuildUp(CBuildUpBase.TYPE_FAKE))then
				SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE, true);
				var ^CTechTreeDef pxDef=GetTechTreeDef();
				if(pxDef!=null)then
					var string sOld="/Filters/Hu/Upgrades/xenage/mammoth_lumber_captain";
					if(!pxDef^.HasFilter(sOld))then
						pxDef^.EnableFilter(sOld);
					endif;
				endif;
			endif;
		elseif(sClassName=="hu_mammoth_log_cannon")then
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_MISC,true);
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE, false);
		endif;
	endproc;
	
	export proc void Die()
		m_bDieInitiated=true;
		if(GetClassName()=="hu_mammoth_lumber_upgrade")then
			if(HasBuildUp(CBuildUpBase.TYPE_FAKE))then
				var ^CTechTreeDef pxDef=GetTechTreeDef();
				if(pxDef!=null)then
					var string sOld="/Filters/Hu/Upgrades/xenage/mammoth_lumber_captain";
					if(pxDef^.HasFilter(sOld))then
						pxDef^.DisableFilter(sOld);
					endif;
				endif;
			endif;
		endif;
		super.Die();
	endproc;
	
	export proc void DieFastAndSilent()
		m_bDieInitiated=true;
		if(GetClassName()=="hu_mammoth_lumber_upgrade")then
			if(HasBuildUp(CBuildUpBase.TYPE_FAKE))then
				var ^CTechTreeDef pxDef=GetTechTreeDef();
				if(pxDef!=null)then
					var string sOld="/Filters/Hu/Upgrades/xenage/mammoth_lumber_captain";
					if(pxDef^.HasFilter(sOld))then
						pxDef^.DisableFilter(sOld);
					endif;
				endif;
			endif;
		endif;
		super.DieFastAndSilent();
	endproc;
	
	export proc void HarakiriFastAndSilent()
		m_bDieInitiated=true;
		if(GetClassName()=="hu_mammoth_lumber_upgrade")then
			if(HasBuildUp(CBuildUpBase.TYPE_FAKE))then
				var ^CTechTreeDef pxDef=GetTechTreeDef();
				if(pxDef!=null)then
					var string sOld="/Filters/Hu/Upgrades/xenage/mammoth_lumber_captain";
					if(pxDef^.HasFilter(sOld))then
						pxDef^.DisableFilter(sOld);
					endif;
				endif;
			endif;
		endif;
		super.HarakiriFastAndSilent();
	endproc;
	
	export proc bool EradicateForest(bool p_bQueue);
		Deforest(null,GetPos(),p_bQueue,false);
		return(true);
	endproc;
	
	export proc void Deforest(^CGameObj p_pxObj, vec3 p_vPos, bool p_bQ, bool p_bNext);
		if(!CanHarvest())then return(); endif;
		if(p_bQ)then
			StartCustomTask("Deforest","Transport");
			return;
		endif;
		var ^CDeforest pxTask=cast<CDeforest>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"Deforest"));
		if(pxTask==null)then return; endif;
		var bool bInit=false;
		if(p_pxObj!=null)then
			bInit=pxTask^.Init(GetHandle(),p_pxObj^.GetHandle());
		else
			bInit=pxTask^.Init(GetHandle(),p_vPos);
		endif;
		if(!bInit)then pxTask^.GetFactory()^.FreeState(pxTask); return; endif;
		pxTask^.SetUserCommand(true);
		if(p_bNext)then
			AddNextTask(pxTask);
		else
			AddTask(pxTask, false);
		endif;
	endproc;
	
	export proc void Reanimated(bool p_bAnim)
		if(p_bAnim)then
			if(HasAnim("dying"))then
				SetAnim("dying",2);
			endif;
		endif;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("reanimated",1);
		endif;
		return;
	endproc;
	
	export proc void DoCaptainAttackAnim()
		if(HasBuildUp(CBuildUpBase.TYPE_WEAPON))then
			if(m_xCaptain.IsValid())then
				var ^CGameObj pxCaptain=m_xCaptain.GetObj();
				if(pxCaptain^.HasAnim(m_sCaptainAttackAnim))then
					pxCaptain^.SetAnim(m_sCaptainAttackAnim, 1);
				endif;
			endif;
		else
			return super.DoCaptainAttackAnim();
		endif;
	endproc;
	
endclass;

class CMegaloceros inherit CAnimal
	
	export constructor()
		m_xSink.m_xOnObjAdd=OnObjAdd;
		m_xSink.m_xOnObjRem=OnObjRem;
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		if(!p_bLoad)then
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_HELMET,false);
		endif;
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			ReBuildWeapon();
		endif;
	endproc;
	
	export proc void ReBuildWeapon()
		if(GetClassName()=="hu_chariot")then
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,false);
			SetBuildUp(CBuildUpBase.TYPE_TRANSPORTER_OPEN);
			cast<CBuildUpTransporterOpen>(GetBuildUp())^.AddIgnoreLink("Dri1");
			var CObjHndl xWagon, xBar;
			var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("hu_chariot_trailer", GetOwner());
			if(pxO!=null)then
				xWagon=pxO^.GetHandle();
			endif;
			pxO=CSrvWrap.GetObjMgr()^.CreateObj("hu_chariot_drawbar", GetOwner());
			if(pxO!=null)then
				xBar=pxO^.GetHandle();
			endif;
			GetBuildUp()^.AddObjFlex(xWagon, "Db_2", 2.0, xBar);
			GetBuildUp()^.AddObj(xBar, "Db_1");
			AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
			cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.AddObjCaptain(m_xCaptain, "Dri1", -1.0, xWagon);
			cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.SetWeaponClass("hu_archer");
			cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.SetCanRotate(true);
			cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.SetAdditionalWeapon(true);
		endif;
	endproc;
	
	export proc void UpdateGfxFlags()
		if(GetClassName()=="hu_scout")then
			if(m_xTechTree.GetValueB("/Objects/Hu/InventObjects/drums/invented",false))then
				if(!GetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_HELMET))then
					SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_HELMET,true);
				endif;
				if(!HasPersonalRegion())then
					var vec3 vD; vD.SetXYZ(35.0, 35.0, 0.0);
					CreatePersonalRegion("MegalocerosDrums_"+GetName()+"_"+Random.GetInt().ToString(), vD, 010b);
					AddRangedBuff("owner_more_damage");
				endif;
			endif;
			if(m_xTechTree.GetValueB("/Objects/Hu/InventObjects/bfpw_pennant/invented",false))then
				if(!GetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMORSADDLE))then
					SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMORSADDLE,true);
				endif;
				if(!GetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_HELMET))then
					SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_HELMET,true);
				endif;
				if(!HasPersonalRegion())then
					var vec3 vD; vD.SetXYZ(35.0, 35.0, 0.0);
					CreatePersonalRegion("MegalocerosPennant_"+GetName()+"_"+Random.GetInt().ToString(), vD, 010b);
					AddRangedBuff("owner_more_defense");
					AddRangedBuff("owner_more_armor");
				endif;
			endif;
		endif;
	endproc;
	
	proc bool OnObjAdd(CObjHndl p_xHndl)
		if(m_bToBeDeleted)then return false; endif;
		var ^CFightingObj pxO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxO==null)then return false; endif;
		if(!AuraSharing()&&pxO^.GetOwner()!=GetOwner())then return false; endif;
		if(!(CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxO^.GetOwner(), GetOwner())&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxO^.GetOwner())))then return false; endif;
//			if(!CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxO^.GetOwner()))then return false; endif;
//			if(pxO^.GetDmg()==0.0f)then return false; endif;
		if(pxO^.GetType()=="BLDG")then return false; endif;
		m_xRegionObjects.Include(p_xHndl);
		if(GetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMORSADDLE))then
			pxO^.SetMirageFlag(CFightingObj.MIRAGE_SPEAKER, true);
		else
			pxO^.SetEffectFlag(CFightingObj.EFFECT_MEGALO_DRUMS, true);
		endif;
		return true;
	endproc;
	
	proc bool OnObjRem(CObjHndl p_xHndl)
		if(m_xRegionObjects.FindEntry(p_xHndl)==-1)then return false; endif;
		m_xRegionObjects.RemEntry(p_xHndl);
		var ^CFightingObj pxO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxO==null)then return false; endif;
		if(GetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMORSADDLE))then
			pxO^.SetMirageFlag(CFightingObj.MIRAGE_SPEAKER, false);
		else
			pxO^.SetEffectFlag(CFightingObj.EFFECT_MEGALO_DRUMS, false);
		endif;
		return true;
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		if(HasBuildUp(CBuildUpBase.TYPE_TRANSPORTER_OPEN))then
			po_rxLink="Dri1";
			po_rbIsBuildUpLink=true;
			SetCaptainAnim("standanim");
			SetCaptainAttackAnim("bow_1");
			return true;
		else
			return super.GetCaptainLink(po_rxLink, po_rbIsBuildUpLink);
		endif;
	endproc;
	
	export proc void InitOwnRegion()
		if(m_xTechTree.GetValueB("/Objects/Hu/InventObjects/drums/invented",false)&&!HasPersonalRegion())then
			var vec3 vD; vD.SetXYZ(35.0, 35.0, 0.0);
			CreatePersonalRegion("MegalocerosDrums_"+GetName()+"_"+Random.GetInt().ToString(), vD, 010b);
			AddRangedBuff("owner_more_damage");
		endif;
		if(m_xTechTree.GetValueB("/Objects/Hu/InventObjects/bfpw_pennant/invented",false)&&!HasPersonalRegion())then
			if(!GetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMORSADDLE))then
				SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMORSADDLE,true);
			endif;
			var vec3 vD; vD.SetXYZ(35.0, 35.0, 0.0);
			CreatePersonalRegion("MegalocerosPennant_"+GetName()+"_"+Random.GetInt().ToString(), vD, 010b);
			AddRangedBuff("owner_more_defense");
			AddRangedBuff("owner_more_armor");
		endif;
	endproc;
	
endclass;

class CKamikazeVelociraptor inherit CAnimal
	
	const real LIFETIME=30.0f;
	const int LIFETIME_TIMER=666;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			CreateTimer(LIFETIME_TIMER, CGameTimeSpan.OneSecond() * LIFETIME, false);
		endif;
		if(!p_bLoad)then
			SetCanFightAttrib(true);
		endif;
		SetActAutonomous(true);
		ExamineEnemies(true);
	endproc;
	
	export proc void Die()
		Delete();
	endproc;
	
	export proc void Delete()
		if(GetOwner()!=-1)then
			RemoveUnit();
//			SetOwner(-1);
		endif;
		super.Delete();
	endproc;
	
	export proc void OnIdleTick(int p_iTime)
		ExamineEnemies(true);
		UpdateAggressionPos(GetPos());
	endproc;
	
	export proc bool ExamineEnemies(bool p_bAlarm)
		return super.ExamineEnemies(p_bAlarm, true);
	endproc;
	
	export proc bool ExamineEnemies(bool p_bAlarm, bool p_bFillEnemyList)
		return super.ExamineEnemies(true, p_bFillEnemyList);
	endproc;
	
	export proc bool DoesCountInUnitLimit()
		return false;
	endproc;
	
	proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==666)then
				DeleteTimer(LIFETIME_TIMER);
				Die();
				return;
			endif;
		endif;
		super.HandleEvent(p_rxEvtPtr);
	endproc;
	
	export proc bool CouldBeStolen(^CFightingObj p_pxTamer)
		return false;
	endproc;
	
	export proc void AddKillerCount(int p_iAdd)
		if(m_xSpawningPool.IsValid())then
			var ^CFightingObj pxSpawningPool=cast<CFightingObj>(m_xSpawningPool.GetObj());
			if(pxSpawningPool!=null)then
				pxSpawningPool^.AddKillerCount(p_iAdd);
			endif;
		endif;
	endproc;
	
endclass;

class CWildBoar inherit CAnimal
	
	const int TIMER_ID =214;
	
	constructor()
		var int iIndex;
		iIndex=AddAutoSpecialMove("Actions/Hu/Moves/ANML/Wild_Boar_Rage");
		m_axAutoSpecialMoves[iIndex].m_xOnCheckConditions=CheckBoarRage;
		m_axAutoSpecialMoves[iIndex].m_xOnStartAction=StartBoarRage;
	endconstructor;
	
	proc bool CheckBoarRage(string p_sTTPath)
		if(GetClassName()!="hu_wild_boar")then return false; endif;
		if(!CheckSpecialActionTimer(p_sTTPath,true))then return false; endif;
		if(!CRequirementsMgr.Get().CheckInvention(this, GetOwner(), "wild_boar_rage", GetTribeName()))then return false; endif;
		var ^CObjList pxEnemies=CSrvWrap.GetObjMgr()^.GetOwnerEnemyList(GetOwner());
		if(pxEnemies==null)then return false; endif;
		var CObjList xList; pxEnemies^.CopySorted(xList,GetPos(),GetCollisionRadius()+5.0);
		if(xList.NumEntries()<2)then return false; endif;
		return true;
	endproc;
	
	proc void StartBoarRage(string p_sTTPath)
//		if(CheckSpecialActionTimer(p_sTTPath,true))then
			ShakeOff("rage",0.1,1.4,10.0,10.0,8.0,p_sTTPath,false,true,false);
//		endif;
		return;
	endproc;
	
	export proc void UpdateRageUnit()
		if(!GetRageUnit())then
			if(CRequirementsMgr.Get().CheckInvention(this, GetOwner(), "wild_boar_rage", GetTribeName()))then
				SetRageUnit(true);
			endif;
		else
			if(!CRequirementsMgr.Get().CheckInvention(this, GetOwner(), "wild_boar_rage", GetTribeName()))then
				SetRageUnit(false);
			endif;
		endif;
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="WiBo")then
			var int iVersion=p_pxNode^.GetVersion();
			var ^CArc pxArc=^(p_pxNode^.GetArc());
			var bool bInvalid;
			(pxArc^) << bInvalid;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CWildBoar] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xF="SpEu";
		var ^CUOFWriterNode pxN=p_pxWriterNode^.AddSubChunk(xF,1);
		var ^CArc pxArc=^(pxN^.GetArc());
		var bool bInvalid;
		(pxArc^) << bInvalid;
		pxN^.Close();
	endproc;
	
	export proc void UpdateGfxFlags()
		if(GetClassName()=="hu_wild_boar")then
			if(!GetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_HELMET) && m_xTechTree.GetValueB("/Objects/Hu/InventObjects/animal_blades/invented",false))then
				SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_HELMET,true);
			endif;
		endif;
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		po_rxLink="Ride";
		SetCaptainAnim("ride_idle_0");
		SetCaptainAttackAnim("ride_attack_front");
		return true;
	endproc;
	
	export proc string GetVictoryAnim()
		var string sAnim="menace";
		if(Random.GetInt()%2==1)then
			sAnim="rage";
		endif;
		return sAnim;
	endproc;
	
endclass;

class CKentrosaurus inherit CAnimal
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy)
		return super.TakeDmg(p_pxEnemy);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile)
		return super.TakeDmg(p_pxEnemy, p_bProjectile);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, real p_fFactor)
		return super.TakeDmg(p_pxEnemy, p_fFactor);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile, real p_fFactor)
		return super.TakeDmg(p_pxEnemy, p_bProjectile, p_fFactor);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile, real p_fFactor, real p_fHitDelay)
		return super.TakeDmg(p_pxEnemy, p_bProjectile, p_fFactor, p_fHitDelay);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile, real p_fFactor, real p_fHitDelay, real p_fArmorPiercing)
		var real fReturn=super.TakeDmg(p_pxEnemy,p_bProjectile,p_fFactor, p_fHitDelay, p_fArmorPiercing);
		if(fReturn==0.0)then
			fReturn=20.0;
			fReturn += m_xTechTree.GetValueR("MiscValues/Hu/Kentro_Damage",0.0);
		endif;
		return fReturn;
	endproc;
	
	export proc void UpdateGfxFlags()
		if(GetClassName()=="hu_kentrosaurus")then
			if(!GetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMOR) && CRequirementsMgr.Get().CheckInvention(this, GetOwner(), "hu_kentrosaurus_armor", GetTribeName()))then
				SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMOR,true);
				SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMORSADDLE,true);
			endif;
		endif;
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		po_rxLink="Ride";
		SetCaptainAnim("ride_idle_0");
		SetCaptainAttackAnim("ride_attack_front");
		return true;
	endproc;
	
	export proc string GetVictoryAnim()
		var string sAnim="attack_back";
		return sAnim;
	endproc;
	
endclass;
	
class CTitanTriceratops inherit CAnimal
	
	constructor()
	endconstructor;
	
	proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			ReBuildWeapon();
		endif;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/Dismount")!=-1)
			)then return;
		endif;
		if(GetTransportObj().IsValid()&&!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/LeaveTransport")>=0))then return; endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("/titan_paw")!=-1)then
				if(CheckSpecialActionTimer(p_sMiscParams))then
					Paw(true,p_sMiscParams,p_bQ, p_bA);
				endif;
			elseif(p_sMiscParams.Find("/titan_shake_off")!=-1)then
				if(CheckSpecialActionTimer(p_sMiscParams))then
					ShakeOff("titan_rage",1.8,0.1,100.0,100.0,12.0,p_sMiscParams,p_bQ,false,p_bA);
				endif;
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		po_rxLink="Dri1";
		po_rbIsBuildUpLink=true;
		SetCaptainAnim("hu_balista_steamtank_sitpos");
		SetCaptainAttackAnim("hu_balista_steamtank_attack");
		return false;
	endproc;
	
	export proc void ReBuildWeapon()
		if(CMirageSrvMgr.Get().TitanSlots())then
			SetBuildUp(CBuildUpBase.TYPE_TRIC_TITAN);
		else
			SetBuildUp(CBuildUpBase.TYPE_TRANSPORTER_OPEN);
		endif;
		var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("hu_titan_transporter_buildup", GetOwner());
		GetBuildUp()^.AddObj(pxO^.GetHandle(), "con");
		/*var ^CCaptain pxC=cast<CCaptain>(CSrvWrap.GetObjMgr()^.CreateObj("universal_captain", GetOwner()));
		pxC^.Init(GetHandle());
		GetBuildUp()^.AddObjCaptain(pxC^.GetHandle(), "Dri1", -1.0, pxO^.GetHandle());*/
		AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
		var ^CBuildUpWeapon pxWeaponBuildUp=cast<CBuildUpWeapon>(GetAdditionalBuildUp(0));
		pxO=CSrvWrap.GetObjMgr()^.CreateObj("hu_rhino_ballista_buildup_top", GetOwner());
		pxWeaponBuildUp^.AddObj(pxO^.GetHandle(), "con2");
		var ^CCaptain pxC=cast<CCaptain>(CSrvWrap.GetObjMgr()^.CreateObj("universal_captain", GetOwner()));
		pxC^.Init(GetHandle());
		pxWeaponBuildUp^.AddObjCaptain(pxC^.GetHandle(), "Dri1", -1.0, pxO^.GetHandle(), true);
		pxWeaponBuildUp^.SetWeaponClass("hu_titan_ballista");
		pxWeaponBuildUp^.SetCanRotate(true);
		pxWeaponBuildUp^.SetAdditionalWeapon(true);
		pxWeaponBuildUp^.SetAutoAttack(true);
		AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
		pxWeaponBuildUp=cast<CBuildUpWeapon>(GetAdditionalBuildUp(1));
		pxO=CSrvWrap.GetObjMgr()^.CreateObj("hu_rhino_ballista_buildup_top", GetOwner());
		pxWeaponBuildUp^.AddObj(pxO^.GetHandle(), "con3");
		pxC=cast<CCaptain>(CSrvWrap.GetObjMgr()^.CreateObj("universal_captain", GetOwner()));
		pxC^.Init(GetHandle());
		pxWeaponBuildUp^.AddObjCaptain(pxC^.GetHandle(), "Dri1", -1.0, pxO^.GetHandle(), true);
		pxWeaponBuildUp^.SetWeaponClass("hu_titan_ballista");
		pxWeaponBuildUp^.SetCanRotate(true);
		pxWeaponBuildUp^.SetAdditionalWeapon(true);
		pxWeaponBuildUp^.SetAutoAttack(true);
	endproc;
	
	export proc string GetVictoryAnim()
		var string sAnim="menace";
		var int iR=Random.GetInt()%3;
		if(iR==1)then
			sAnim="sm_shake_off";
		elseif(iR==2)then
			sAnim="idle_2";
		endif;
		return sAnim;
	endproc;
	
endclass;
	
class CTriceratops inherit CResourceAnimal
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			ReBuildWeapon();
		endif;
	endproc;
	
	export proc void ReBuildWeapon()
		var string sClass=GetClassName();
		var bool bAje=sClass=="aje_triceratops_archer";
		if(sClass=="seas_triceratops_transporter" || bAje)then
			if(bAje)then
				SetBuildUp(CBuildUpBase.TYPE_CYBORG_TRANSPORTER);
			else
				SetBuildUp(CBuildUpBase.TYPE_TRANSPORTER_OPEN);
			endif;
			var ^CGameObj pxO;
			if(bAje)then
				cast<CBuildUpTransporterCustom>(GetBuildUp())^.AddIgnoreLink("Dri1");
				pxO = CSrvWrap.GetObjMgr()^.CreateObj("aje_triceratops_transporter", GetOwner());
			else
				cast<CBuildUpTransporterOpen>(GetBuildUp())^.AddIgnoreLink("Dri1");
				pxO = CSrvWrap.GetObjMgr()^.CreateObj("seas_triceratops_transporter_buildup", GetOwner());
			endif;
			GetBuildUp()^.AddObj(pxO^.GetHandle(), "con");
			SetCanFightAttrib(true);
			CreateCaptain();
			AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
			cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.AddObjCaptain(m_xCaptain, "Dri1", -1.0, pxO^.GetHandle());
			if(sClass == "aje_triceratops_archer")then
				cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.SetWeaponClass("aje_archer");
			else
				cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.SetWeaponClass("seas_marksman");
			endif;
			cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.SetCanRotate(true);
			cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.SetAdditionalWeapon(true);
			var ^CGameObj pxObj=m_xCaptain.GetObj();
			if(pxObj!=null)then
				pxObj^.SetAnim("standanim",3);
			endif;
		elseif(GetClassName()=="seas_triceratops_resource_collector")then
			SetBuildUp(CBuildUpBase.TYPE_FAKE);
			var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("seas_triceratops_resource_collector_buildup", GetOwner());
			if(pxO!=null)then
				GetBuildUp()^.AddObj(pxO^.GetHandle(), "con");
			endif;
		elseif(GetClassName()=="seas_triceratops_mg")then
			SetBuildUp(CBuildUpBase.TYPE_WEAPON);
			var ^CGameObj pxO = CSrvWrap.GetObjMgr()^.CreateObj("seas_triceratops_machinegun", GetOwner());
			GetBuildUp()^.AddObj(pxO^.GetHandle(), "con");
			cast<CBuildUpWeapon>(GetBuildUp())^.SetWeaponClass(GetClassName());
			cast<CBuildUpWeapon>(GetBuildUp())^.SetAutoAttack(true);
			cast<CBuildUpWeapon>(GetBuildUp())^.SetCanRotate(true);
			cast<CBuildUpWeapon>(GetBuildUp())^.SetAdditionalWeapon(true);
		endif;
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		if(HasBuildUp(CBuildUpBase.TYPE_TRANSPORTER_OPEN)||HasBuildUp(CBuildUpBase.TYPE_CYBORG_TRANSPORTER))then
			//Henry: fixing wrong animation used by seas tric rider (bow_1)
			po_rxLink="Dri1";
			po_rbIsBuildUpLink=true;
			SetCaptainAnim("standanim");
			if(GetClassName()=="seas_triceratops_transporter")then
				SetCaptainAttackAnim("seas_marksman_0");
			else
				SetCaptainAttackAnim("bow_1");
			endif;
			return true;
		elseif(HasBuildUp(CBuildUpBase.TYPE_WEAPON))then
			return false;
		else
			return super.GetCaptainLink(po_rxLink, po_rbIsBuildUpLink);
		endif;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/Dismount")!=-1)
			)then return; endif;
		if(GetTransportObj().IsValid()&&!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/LeaveTransport")>=0))then return; endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("/triceratops_shake_off")!=-1)then
				if(!HasBuildUp()&&CheckSpecialActionTimer(p_sMiscParams))then
					ShakeOff("sm_shake_off",2.0,0.4,50.0,50.0,8.0,p_sMiscParams,p_bQ,false,p_bA);
				endif;
			elseif(p_sMiscParams.Find("/triceratops_tusk")!=(-1))then
				if(!HasBuildUp()&&CheckHook(p_sMiscParams))then
					StartHook(p_sMiscParams, p_bQ, p_bA);
				endif;
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	proc bool CheckHook(string p_sTTPath)
		if(!CRequirementsMgr.Get().CheckInvention(this, GetOwner(), "triceratops_tusk", GetTribeName()))then return false; endif;
		if(!CheckSpecialActionTimer(p_sTTPath))then return false; endif;
		if(!m_xCurEnemy.IsValid())then return false; endif;
		if(m_xCurEnemy.GetObj()^.GetOwner()==GetOwner())then return false; endif;
		var ^CFightingObj pxObj=cast<CFightingObj>(m_xCurEnemy.GetObj());
		var bool bInvalid; var CObjHndl xInvalid;
		if(pxObj==null||!IsInCombatRange(pxObj,false))then return false; endif;
		if(GetAngleToR(m_xCurEnemy.GetObj())>0.39)then return false; endif;
		return true;
	endproc;
	
	proc bool StartHook(string p_sTTPath, bool p_bQ, bool p_bAILock)
//		MemorizeCurrentFightState(m_xCurEnemy,false,false);
		var ^CTriceratopsHook pxTask=cast<CTriceratopsHook>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"TricHook"));
		if(pxTask==null)then return false; endif;
		var bool bReturn = pxTask^.Init(GetHandle(), m_xCurEnemy, p_sTTPath);
		if(bReturn)then
			SetAILock(p_bAILock);
			pxTask^.SetUserCommand(true);
			AddTask(pxTask,p_bQ);
		else
			pxTask^.GetFactory()^.FreeState(pxTask);
		endif;
		return bReturn;
	endproc;
	
	export proc string GetVictoryAnim()
		var string sAnim="menace";
		var int iR=Random.GetInt()%2;
		if(iR==1)then
			sAnim="shake";
		endif;
		return sAnim;
	endproc;
	
endclass;

class CParasaurolophus inherit CAnimal
	
	export const string VALOR_PATH="/Filters/Ninigi/Upgrades/xenage/valor";
	var CObjHndl m_xExtraCaptain;
	
	export constructor()
		m_xSink.m_xOnObjAdd=OnObjAdd;
		m_xSink.m_xOnObjRem=OnObjRem;
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CParasaurolophus] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		if(CMirageSrvMgr.SDK())then
			return;
		endif;
		var CFourCC xBase="NiPa";
		var int iVersion=1;
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,iVersion);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		if(iVersion>=4)then
			m_xExtraCaptain.DoKArc(pxArc^);
		endif;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="NiPa")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			if(p_pxReaderNode^.GetVersion()>=1)then
				m_xExtraCaptain.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			ReBuildWeapon();
		endif;
	endproc;
	
	export proc void ReBuildWeapon()
		var string sClassName=GetClassName();
		if(sClassName=="ninigi_parasaurolophus_drums")then
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,false);
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_MISC,false);
			var CObjHndl xWagon, xBar;
			SetBuildUp(CBuildUpBase.TYPE_FAKE);
			var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("ninigi_drumwagon", GetOwner());
			xWagon=pxO^.GetHandle();
			pxO=CSrvWrap.GetObjMgr()^.CreateObj("ninigi_drumwagon_drawbar", GetOwner());
			xBar=pxO^.GetHandle();
			GetBuildUp()^.AddObjFlex(xWagon,"Db_2", 3.0, xBar);
			GetBuildUp()^.AddObj(xBar,"Db_1");
			if(!HasPersonalRegion())then
				var vec3 vD; vD.SetXYZ(60.0, 60.0, 0.0);
				CreatePersonalRegion("ParasaurolophusDrums_"+GetName()+"_"+Random.GetInt().ToString(), vD, 010b);
			endif;
			SetCanFightAttrib(GetDmg()>0.0);
			AddRangedBuff("owner_more_damage");
		elseif(sClassName=="ninigi_parasaurolophus_gatling")then
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,false);
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_MISC,true);
			SetBuildUp(CBuildUpBase.TYPE_WEAPON);
			var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("ninigi_parasaurolophus_gatling_obj", GetOwner());
			if(pxO!=null)then
				GetBuildUp()^.AddObj(pxO^.GetHandle(), "con");
			endif;
			cast<CBuildUpWeapon>(GetBuildUp())^.SetWeaponClass(GetClassName());
			cast<CBuildUpWeapon>(GetBuildUp())^.SetAutoAttack(true);
			cast<CBuildUpWeapon>(GetBuildUp())^.SetCanRotate(true);
			cast<CBuildUpWeapon>(GetBuildUp())^.SetAdditionalWeapon(true);
		endif;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		if(GetClassName()=="ninigi_parasaurolophus_drums")then
			if(GetDmg()>0.0f)then
				SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,true);
			else
				SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,false);
			endif;
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_MISC,false);
		else
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,false);
		endif;
	endproc;
	
	export proc void UpdateGfxFlags()
		if(GetClassName()=="ninigi_parasaurolophus_drums")then
			var bool bInvention=CRequirementsMgr.Get().CheckInvention(this, GetOwner(), "for_french_parasaurolophus_fan", GetTribeName());
			if(!GetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE) && bInvention)then
				SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,true);
//				AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
//				pxWeaponBuildUp=cast<CBuildUpWeapon>(GetAdditionalBuildUp(0));
//				pxWeaponBuildUp^.SetFake(true);
//				var ^CCaptain pxC=cast<CCaptain>(CSrvWrap.GetObjMgr()^.CreateObj("universal_captain", GetOwner()));
//				if(pxC!=null)then
//					var CObjHndl xMe=GetHandle();
//					pxC^.Init(xMe,"ninigi_rider_c",true);
//					pxWeaponBuildUp^.AddObjCaptain(pxC^.GetHandle(), "Ride", -1.0, xMe);
//				endif;
				var ^CCaptain pxC=cast<CCaptain>(CSrvWrap.GetObjMgr()^.CreateObj("universal_captain", GetOwner()));
				pxC^.Init(GetHandle());
//				pxC^.SetGFX("ninigi_rider_c");
				pxC^.Init(GetHandle(),"ninigi_rider_c",true);
				m_xExtraCaptain=pxC^.GetHandle();
				GetBuildUp()^.AddObj(m_xExtraCaptain, "Ride");
				pxC^.SetAnim("ride_idle_0",3);
				SetAggressionState(0);
				SetCanFightAttrib(true);
			elseif(GetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE) && !bInvention)then
				SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,false);
				SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_MISC,false);
			endif;
		endif;
	endproc;
	
	proc bool OnObjAdd(CObjHndl p_xHndl)
		if(m_bToBeDeleted)then return false; endif;
		var ^CFightingObj pxO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxO==null)then return false; endif;
		if(!AuraSharing()&&pxO^.GetOwner()!=GetOwner())then return false; endif;
		if(!(CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxO^.GetOwner(), GetOwner())&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxO^.GetOwner())))then return false; endif;
//		if(!CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxO^.GetOwner()))then return false; endif;
//			if(pxO^.GetDmg()==0.0f)then return false; endif;
		if(pxO^.GetType()=="BLDG")then return false; endif;
		m_xRegionObjects.Include(p_xHndl);
		pxO^.SetEffectFlag(CFightingObj.EFFECT_PARA_DRUMS, true);
		return true;
	endproc;
	
	proc bool OnObjRem(CObjHndl p_xHndl)
		if(m_xRegionObjects.FindEntry(p_xHndl)==-1)then return false; endif;
		m_xRegionObjects.RemEntry(p_xHndl);
		var ^CFightingObj pxO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxO==null)then return false; endif;
		pxO^.SetEffectFlag(CFightingObj.EFFECT_PARA_DRUMS, false);
		return true;
	endproc;
	
	export proc bool IsAbleToFight()
		if(GetClassName()=="ninigi_parasaurolophus_drums")then
			return GetDmg()>0.0f;
		endif;
		return true;
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		if(GetClassName()=="ninigi_parasaurolophus_drums")then
			po_rxLink="Dri1";
			po_rbIsBuildUpLink=true;
			SetCaptainAnim("standanim");
			SetCaptainAttackAnim("drumwagon_attack");
		elseif(GetClassName()=="ninigi_parasaurolophus_gatling")then
			po_rxLink="Dri1";
			po_rbIsBuildUpLink=true;
			SetCaptainAnim("gatling_rider_standanim");
			SetCaptainAttackAnim("gatling_rider_attack");
			return true;
		else
			return super.GetCaptainLink(po_rxLink, po_rbIsBuildUpLink);
		endif;
		return true;
	endproc;
	
	export proc void InitOwnRegion()
		if(!HasPersonalRegion())then
			var vec3 vD; vD.SetXYZ(60.0, 60.0, 0.0);
			CreatePersonalRegion("ParasaurolophusDrums_"+GetName()+"_"+Random.GetInt().ToString(), vD, 010b);
		endif;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			)then return; endif;
		if(GetTransportObj().IsValid()&&!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/LeaveTransport")>=0))then return; endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("song_of_valor")!=(-1))then
				if(CheckSpecialActionTimer(p_sMiscParams))then
					SingSongOfValor(p_sMiscParams,p_bQ, p_bA);
				endif;
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	proc bool SingSongOfValor(string p_sTTPath, bool p_bQ, bool p_bAILock)
		var ^CSongOfValor pxTask=cast<CSongOfValor>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"SongOfValor"));
		if(pxTask==null)then return false; endif;
		var bool bReturn=pxTask^.Init(GetHandle(),p_sTTPath);
		if(bReturn)then
			SetAILock(p_bAILock);
			pxTask^.SetUserCommand(true);
			NewTaskFO(pxTask,p_bQ);
		else
			pxTask^.GetFactory()^.FreeState(pxTask);
		endif;
		return bReturn;
	endproc;
	
	export proc void DrumAnim(int p_iMod)
		var CObjHndl xSub=GetBuildUp()^.GetPrimaryLinkedObj();
		if(xSub.IsValid())then
			var ^CGameObj pxDrum=xSub.GetObj();
			if(pxDrum==null)then return; endif;
			if(pxDrum^.HasAnim("attack_front"))then
				pxDrum^.SetAnim("attack_front", p_iMod);
			endif;
		endif;
	endproc;
	
	export proc void DoCaptainAttackAnim()
		if(HasBuildUp(CBuildUpBase.TYPE_WEAPON))then
			if(m_xCaptain.IsValid())then
				var ^CGameObj pxCaptain=m_xCaptain.GetObj();
				if(pxCaptain^.HasAnim(m_sCaptainAttackAnim))then
					pxCaptain^.SetAnim(m_sCaptainAttackAnim, 1);
				endif;
			endif;
		else
			if(m_xExtraCaptain.IsValid())then
				var ^CGameObj pxCaptain=m_xExtraCaptain.GetObj();
				if(pxCaptain==null)then return; endif;
				var string sAnim="ride_attack_front";
				if(pxCaptain^.HasAnim(sAnim))then
					pxCaptain^.SetAnim(sAnim, 1);
				endif;
			endif;
			return super.DoCaptainAttackAnim();
		endif;
	endproc;
	
	export proc string GetVictoryAnim()
		var string sAnim="menace";
		var int iR=Random.GetInt()%3;
		if(iR==1)then
			sAnim="shake";
		elseif(iR==2)then
			sAnim="scratch";
		endif;
		return sAnim;
	endproc;
	
	export proc void Die()
		if(m_xExtraCaptain.IsValid())then
			m_xExtraCaptain.GetObj()^.Delete();
			m_xExtraCaptain=CObjHndl.Invalid();
		endif;
		super.Die();
	endproc;
	
endclass;

class CStegosaurus inherit CAnimal
	
	constructor()
		var int iIndex;
		iIndex=AddAutoSpecialMove("Actions/Aje/Moves/ANML/StegoBash");
		m_axAutoSpecialMoves[iIndex].m_xOnCheckConditions=CheckBash;
		m_axAutoSpecialMoves[iIndex].m_xOnStartAction=StartBash;
	endconstructor;
	
	proc bool CheckBash(string p_sTTPath)
		if(HasBuildUp())then return false; endif;
		if(!CheckSpecialActionTimer(p_sTTPath,true))then return false; endif;
		if(!CRequirementsMgr.Get().CheckInvention(this, GetOwner(), "stegosaurus_caudal_bash", GetTribeName()))then return false; endif;
		var ^CObjList pxEnemies=CSrvWrap.GetObjMgr()^.GetOwnerEnemyList(GetOwner());
		if(pxEnemies==null)then return false; endif;
		var CObjList xList;
		pxEnemies^.CopySorted(xList,GetPos(),GetCollisionRadius()+5.0);
		if(xList.NumEntries()<3)then return false; endif;
		return true;
	endproc;
	
	proc void StartBash(string p_sTTPath)
//		if(CheckSpecialActionTimer(p_sTTPath,true))then
			ShakeOff("sm_attack_back",0.1,1.4,10.0,10.0,8.0,p_sTTPath,false,true,false);
//		endif;
		return;
	endproc;
	
	export proc void DoChopAnim()
		var array string asAnims;
		asAnims.AddEntry("stego_fm_1");
		asAnims.AddEntry("menace");
		var int iRandom=Random.GetInt()%asAnims.NumEntries();
		if(HasAnim(asAnims[iRandom]))then
			AnimAction(asAnims[iRandom]);
		endif;
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			StartTT();
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_MISC,false);
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,true);
			CreatePersonalProduceUnit();
		endif;
		SetAttackDirection(Math.Pi());
	endproc;
	
	export proc void HandleAction(string p_sAction)
		if(p_sAction.Find("aje_stegosaurus_transporter")>=0)then
			if(!HasBuildUp(CBuildUpBase.TYPE_TRANSPORTER_OPEN))then
				DestroyBuildUp();
				SetBuildUp(CBuildUpBase.TYPE_TRANSPORTER_OPEN);
				var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("aje_stegosaurus_transporter", GetOwner());
				GetBuildUp()^.AddObj(pxO^.GetHandle(), "con");
				AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
				var ^CBuildUpWeapon pxWeaponBuildUp=cast<CBuildUpWeapon>(GetAdditionalBuildUp(0));
				CreateCaptain();
				pxWeaponBuildUp^.AddObjCaptain(m_xCaptain, "Dri5", -1.0, pxO^.GetHandle());
				pxWeaponBuildUp^.SetWeaponClass("aje_archer");
				pxWeaponBuildUp^.SetCanRotate(true);
				pxWeaponBuildUp^.SetAdditionalWeapon(true);
				SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,false);
			endif;
		else
			DestroyBuildUp();
			ResetFlag();
		endif;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(	IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/Dismount")!=-1)
			)then return; endif;
		if(GetTransportObj().IsValid()&&!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/LeaveTransport")>=0))then return; endif;
		var ^CVirtualProduceUnit pxUnit=cast<CVirtualProduceUnit>(GetProduceUnit().GetObj());
		if(pxUnit==null)then
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
		if(p_sCommand=="Cancel")then
			pxUnit^.ReactToGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams, p_bQ, p_bS, p_bA);
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		if(HasBuildUp())then
			po_rxLink="Dri5";
			po_rbIsBuildUpLink=true;
			SetCaptainAnim("standanim");
			SetCaptainAttackAnim("bow_1");
			return true;
		else
			return super.GetCaptainLink(po_rxLink, po_rbIsBuildUpLink);
		endif;
	endproc;
	
	export proc void DestroyBuildUp()
		super.DestroyBuildUp();
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,true);
		UpdateGfxFlags();
	endproc;
	
	export proc void SetBuildUp(int p_iType)
		super.SetBuildUp(p_iType);
		UpdateGfxFlags();
	endproc;
	
	export proc void UpdateGfxFlags()
		if(GetClassName()=="aje_stegosaurus")then
//			if(!HasBuildUp())then
				if(!GetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMOR) && CRequirementsMgr.Get().CheckInvention(this, GetOwner(), "aje_stegosaurus_armor", GetTribeName()))then
					SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMOR,true);
				endif;
//			elseif(GetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMOR))then
//				SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMOR,false);
//			endif;
		endif;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		if(HasBuildUp())then
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,false);
		else
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,true);
		endif;
	endproc;
	
endclass;

class CWoolly_Rhino inherit CAnimal
	
	const int		DELAY_DESTROY_TIMER=7586;
	
	///////
	//	ctor
	///////
	constructor()
		m_xSink.m_xOnObjAdd=OnObjAdd;
		m_xSink.m_xOnObjRem=OnObjRem;
		m_sRagePath="Actions/Hu/Moves/ANML/Mammoth_Stampede";
		var int iIndex=AddAutoSpecialMove(m_sRagePath);
		m_axAutoSpecialMoves[iIndex].m_xOnCheckConditions=CheckRageTo;
		m_axAutoSpecialMoves[iIndex].m_xOnStartAction=StartRageTo;
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			ReBuildWeapon();
		endif;
	endproc;
	
	export proc void ReBuildWeapon()
		var string sClassName=GetClassName();
		if(sClassName=="hu_rhino_transporter")then
			SetBuildUp(CBuildUpBase.TYPE_TRANSPORTER_OPEN);
			cast<CBuildUpTransporterOpen>(GetBuildUp())^.AddIgnoreLink("Dri1");
			var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("hu_rhino_transporter_buildup", GetOwner());
			GetBuildUp()^.AddObj(pxO^.GetHandle(), "con");
			AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
			cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.AddObjCaptain(m_xCaptain, "Dri1", -1.0, pxO^.GetHandle());
			cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.SetWeaponClass("hu_archer");
			cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.SetCanRotate(true);
			cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.SetAdditionalWeapon(true);
		elseif(sClassName=="hu_rhino_ballista")then
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,false);
			SetBuildUp(CBuildUpBase.TYPE_WEAPON);
			var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("hu_rhino_ballista_buildup_top", GetOwner());
			if(pxO!=null)then
				GetBuildUp()^.AddObj(pxO^.GetHandle(), "we");
				pxO^.SetRndInvMaskSingleFlagInv(VIS_FLAG_VHCL_RAM_HIGH,true);
			endif;
			pxO=CSrvWrap.GetObjMgr()^.CreateObj("hu_rhino_ballista_buildup_bottom", GetOwner());
			if(pxO!=null)then
				GetBuildUp()^.AddObj(pxO^.GetHandle(), "we");
				pxO^.SetRndInvMaskSingleFlagInv(VIS_FLAG_VHCL_RAM_LOW, true);
			endif;
			cast<CBuildUpWeapon>(GetBuildUp())^.SetWeaponClass(GetClassName());
			cast<CBuildUpWeapon>(GetBuildUp())^.SetCanRotate(true);
			cast<CBuildUpWeapon>(GetBuildUp())^.SetAutoAttack(true);
		elseif(sClassName=="hu_rhino")then
			// nothing
		endif;
	endproc;
	
	export proc void DoCaptainAttackAnim()
		if(HasBuildUp(CBuildUpBase.TYPE_WEAPON))then
			if(m_xCaptain.IsValid())then
				var ^CGameObj pxCaptain=m_xCaptain.GetObj();
				if(pxCaptain^.HasAnim(m_sCaptainAttackAnim))then
					pxCaptain^.SetAnim(m_sCaptainAttackAnim, 1);
				endif;
			endif;
		else
			return super.DoCaptainAttackAnim();
		endif;
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		if(HasBuildUp(CBuildUpBase.TYPE_WEAPON))then
			po_rxLink="Dri1";
			po_rbIsBuildUpLink=true;
			SetCaptainAnim("hu_balista_steamtank_sitpos");
			SetCaptainAttackAnim("hu_balista_steamtank_attack");
		elseif(HasBuildUp(CBuildUpBase.TYPE_TRANSPORTER_OPEN))then
			po_rxLink="Dri1";
			po_rbIsBuildUpLink=true;
			SetCaptainAnim("standanim");
			SetCaptainAttackAnim("bow_1");
		else
			po_rxLink="Ride";
			SetCaptainAnim("ride_idle_0");
			SetCaptainAttackAnim("ride_attack_front");
			return true;
		endif;
		return true;
	endproc;
	
	///////
	//	UpdateGfxFlags()
	///////
	export proc void UpdateGfxFlags()
		var string sClass=GetClassName();
		if(sClass=="hu_rhino")then
			if(m_xTechTree.GetValueB("/Objects/Hu/InventObjects/pennant/invented",false))then
				if(!GetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_STANDARTE))then
					SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_STANDARTE,true);
				endif;
				if(!HasPersonalRegion())then
					var vec3 vD; vD.SetXYZ(35.0, 35.0, 0.0);
					CreatePersonalRegion("RhinoPennant_"+GetName()+"_"+Random.GetInt().ToString(), vD, 010b);
					AddRangedBuff("owner_more_defense");
				endif;
			endif;
		endif;
		if(sClass=="hu_rhino")then
			if(!GetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_HELMET) && m_xTechTree.GetValueB("/Objects/Hu/InventObjects/animal_blades/invented",false))then
				SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_HELMET,true);
			endif;
			if(m_xTechTree.GetValueB("/Objects/Hu/InventObjects/hu_rhino_armor/invented",false))then
				if(!GetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMOR))then
					SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMOR,true);
				endif;
				if(!GetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMORSADDLE))then
					SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMORSADDLE,true);
				endif;
				if(GetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE))then
					SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,false);
				endif;
			endif;
		endif;
	endproc;
	
	proc bool OnObjAdd(CObjHndl p_xHndl)
		if(m_bToBeDeleted)then return false; endif;
//		if(p_xHndl==GetHandle())then return false; endif;
		var ^CFightingObj pxO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxO==null)then return false; endif;
		if(!AuraSharing()&&pxO^.GetOwner()!=GetOwner())then return false; endif;
		if(!(CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxO^.GetOwner(), GetOwner())&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxO^.GetOwner())))then return false; endif;
//		if(!CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxO^.GetOwner()))then return false; endif;
		if(pxO^.GetType()=="BLDG")then return false; endif;
		m_xRegionObjects.Include(p_xHndl);
		pxO^.SetEffectFlag(CFightingObj.EFFECT_RHINO_PENNANT, true);
		return true;
	endproc;
	
	proc bool OnObjRem(CObjHndl p_xHndl)
		if(m_xRegionObjects.FindEntry(p_xHndl)==-1)then return false; endif;
		m_xRegionObjects.RemEntry(p_xHndl);
		var ^CFightingObj pxO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxO==null)then return false; endif;
		pxO^.SetEffectFlag(CFightingObj.EFFECT_RHINO_PENNANT, false);
		return true;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(	IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/Dismount")!=-1)
			)then return; endif;
		if(GetTransportObj().IsValid()&&!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/LeaveTransport")>=0))then return; endif;
		if(GetActAutonomous() && p_sMiscParams.Find("AttackSrv")==-1 &&
		!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill"))then return; endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("/rhino_shake_off")!=-1)then
				if(CheckSpecialActionTimer(p_sMiscParams))then
					ShakeOff("sm_shake_off",2.0,0.4,50.0,50.0,8.0,p_sMiscParams,p_bQ,false,p_bA);
				endif;
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	export proc void InitOwnRegion()
		if(m_xTechTree.GetValueB("/Objects/Hu/InventObjects/pennant/invented",false))then
			if(!HasPersonalRegion())then
				var vec3 vD; vD.SetXYZ(35.0, 35.0, 0.0);
				CreatePersonalRegion("RhinoPennant_"+GetName()+"_"+Random.GetInt().ToString(), vD, 010b);
				AddRangedBuff("owner_more_defense");
			endif;
		endif;
	endproc;
	
	export proc string GetVictoryAnim()
		var string sAnim="menace";
		if(Random.GetInt()%2==1)then
			sAnim="shake";
		endif;
		return sAnim;
	endproc;
	
endclass;

class CSaltasaurus inherit CAnimal
	
	const int TIMER_DOPING=3834;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_STANDARTE,false);
			ReBuildWeapon();
		endif;
	endproc;
	
	export proc void ReBuildWeapon()
		var string sClassName=GetClassName();
		if(sClassName=="ninigi_saltasaurus_archer")then
			SetBuildUp(CBuildUpBase.TYPE_TRANSPORTER_OPEN);
			cast<CBuildUpTransporterOpen>(GetBuildUp())^.AddIgnoreLink("Dri1");
			var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("ninigi_saltasaurus_transporter", GetOwner());
			GetBuildUp()^.AddObj(pxO^.GetHandle(), "con");
			AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
			cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.AddObjCaptain(m_xCaptain, "Dri1", -1.0, pxO^.GetHandle());
			cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.SetWeaponClass("ninigi_archer");
			cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.SetCanRotate(true);
			cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.SetAdditionalWeapon(true);
		elseif(sClassName == "ninigi_saltasaurus_launcher")then
			SetBuildUp(CBuildUpBase.TYPE_WEAPON);
			var ^CGameObj pxO = CSrvWrap.GetObjMgr()^.CreateObj("ninigi_triceratops_launcher", GetOwner());
			if(pxO!=null)then
				GetBuildUp()^.AddObj(pxO^.GetHandle(), "con");
			endif;
			cast<CBuildUpWeapon>(GetBuildUp())^.SetCanRotate(true);
			cast<CBuildUpWeapon>(GetBuildUp())^.SetAutoAttack(true);
			cast<CBuildUpWeapon>(GetBuildUp())^.SetWeaponClass(GetClassName());
			cast<CBuildUpWeapon>(GetBuildUp())^.SetBuildUpRotSpeed(0.5f);
		endif;
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		if(HasBuildUp(CBuildUpBase.TYPE_TRANSPORTER_OPEN))then
			po_rxLink="Dri1";
			po_rbIsBuildUpLink=true;
			SetCaptainAnim("standanim");
			SetCaptainAttackAnim("bow_1");
		elseif(HasBuildUp(CBuildUpBase.TYPE_WEAPON))then
			po_rxLink="Dri1";
			po_rbIsBuildUpLink = true;
			SetCaptainAnim("gatling_rider_standanim");
			SetCaptainAttackAnim("gatling_rider_attack");
		else
			return super.GetCaptainLink(po_rxLink, po_rbIsBuildUpLink);
		endif;
		return true;
	endproc;
	
	export proc void DoCaptainAttackAnim()
		if(HasBuildUp(CBuildUpBase.TYPE_WEAPON))then
			if(m_xCaptain.IsValid())then
				var ^CGameObj pxCaptain=m_xCaptain.GetObj();
				if(pxCaptain^.HasAnim(m_sCaptainAttackAnim))then
					pxCaptain^.SetAnim(m_sCaptainAttackAnim, 1);
				endif;
			endif;
		else
			return super.DoCaptainAttackAnim();
		endif;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(	IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/Dismount")!=-1)
			)then return; endif;
		if(GetTransportObj().IsValid()&&!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/LeaveTransport")>=0))then return; endif;
		if(GetActAutonomous() && p_sMiscParams.Find("AttackSrv")==-1)then return; endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("/doping")!=-1)then
				if(CheckSpecialActionTimer(p_sMiscParams))then
					StartDoping(p_sMiscParams,p_bQ);
				endif;
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	export proc bool StartDoping(string p_sTTPath, bool p_bQ)
		if(p_bQ)then
			return StartCustomTask("StartDoping",p_sTTPath);
		endif;
		DeleteTimer(TIMER_DOPING);
		CreateTimer(TIMER_DOPING, CGameTimeSpan.OneSecond()*10.0, false);
		var CObjHndl xHndl=AddFX("fx_saltasaurus_doping", -1.0);
		if(xHndl.IsValid())then
			var CFourCC xLink;
			xHndl.GetObj()^.LinkAction(GetHandle(),xLink);
		endif;
		AddSpecialActionTimer(p_sTTPath);
		return true;
	endproc;
	
	export proc void StopDoping()
		RemoveFX("fx_saltasaurus_doping");
		DeleteTimer(TIMER_DOPING);
	endproc;
	
	export proc void SetIced(real p_fDuration,real p_fResistStart)
		if(HasTimer(TIMER_DOPING))then
			return;
		endif;
		super.SetIced(p_fDuration, p_fResistStart);
	endproc;
	
	export proc void Damage(real p_fDamage)
		if(HasTimer(TIMER_DOPING))then
			return;
		endif;
		super.Damage(p_fDamage);
	endproc;
	
	export proc void PoisonDamage(real p_fDamage, CObjHndl p_xEnemy, int p_iEnemy)
		if(HasTimer(TIMER_DOPING))then
			return;
		endif;
		return super.PoisonDamage(p_fDamage, p_xEnemy, p_iEnemy);
	endproc;
	
	export proc void BurnDamage(real p_fDamage, CObjHndl p_xEnemy, int p_iEnemy)
		if(HasTimer(TIMER_DOPING))then
			return;
		endif;
		return super.BurnDamage(p_fDamage, p_xEnemy, p_iEnemy);
	endproc;
	
	export proc void ChainDamage(real p_fDamage, int p_iLast, CObjHndl p_xLast)
		if(HasTimer(TIMER_DOPING))then
			return;
		endif;
		return super.ChainDamage(p_fDamage, p_iLast, p_xLast);
	endproc;
	
	export proc void WoundDamage(real p_fDamage, CObjHndl p_xLE, int p_iLE)
		if(HasTimer(TIMER_DOPING))then
			return;
		endif;
		return super.BurnDamage(p_fDamage, p_xLE, p_iLE);
	endproc;
	
	proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==TIMER_DOPING)then
				StopDoping();
				return;
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	export proc string GetVictoryAnim()
		var string sAnim="attack_tail";
		return sAnim;
	endproc;
	
endclass;

// Swimming Dinos
class CSwimmingAnimal inherit CAnimal
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetCanWalk(false);
		SetCanSwim(true);
	endproc;
	
	proc void InitEnemySearch()
		SetOwnerEnemySearch(GetOwner()==-1);
		m_xEnemySearch.SetType("SHIP");
		m_xEnemySearch.SetType("BLDG",true);
		m_xEnemySearch.SetType("ANML",true);
		m_xEnemySearch.SetType("VHCL",true);
		m_xEnemySearch.SetType("CHTR",true);
	endproc;

	export proc void SetIdleAnim()
		if(HasAnim("standanim") && GetCurrentAnimName()!="standanim")then
			SetAnim("standanim",3);
		endif;
	endproc;
	
endclass;

class CSmallSwimmer inherit CSwimmingAnimal
	
	export proc void SetIdleAnim()
//		if(HasAnim("swim") && GetCurrentAnimName()!="swim")then
//			SetAnim("swim",3);
//		endif;
		SetSLEAnim("swim",9999,false,false);
		return;
	endproc;
	
	export proc void OnActionPreEnd(bool p_bBroken)
		SetIdleAnim();
		super.OnActionPreEnd(p_bBroken);
	endproc;
	
	export proc void OnActionEnd(bool p_bBroken)
		SetIdleAnim();
		super.OnActionEnd(p_bBroken);
	endproc;
	
	export proc void StopEverything()
		super.StopEverything();
		SetIdleAnim();
	endproc;
	
endclass;

class CFlyingAnimal inherit CAnimal
	
	var real m_fFlyingHeight;
	var real m_fFlyingMin;
	var real m_fFlyingMax;
	var real m_fAttackHeight;
	var string m_sFlyIdleAnim;
	
	constructor()
		m_fFlyingMin=5.0f;
		m_fFlyingMax=15.0f;
		m_fAttackHeight=0.0f;
		m_sFlyIdleAnim="fly";
	endconstructor;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="FlWA")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			if(iVersion>=1)then
				pxArc^<<m_fFlyingHeight;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CFlyingAnimal] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xBase="FlWA";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		pxArc^<<m_fFlyingHeight;
		pxWalk^.Close();
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetCanWalk(false);
		SetCanSwim(false);
		SetCanFly(true);
		if(!p_bLoad)then
			m_fFlyingHeight=7.5f;
			if(GetClassName()=="Pteranodon")then
				m_fFlyingHeight=15.0f;
			endif;
		endif;
		if(GetClassName()=="Pteranodon")then
			m_fFlyingMin=12.0f;
			m_fFlyingMax=25.0f;
			m_fAttackHeight=3.5f;
			m_sFlyIdleAnim="idle";
		endif;
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj , ref CGameObj.CAdvanceActionParams p_rxParams)
		if(!p_xGoalObj.IsValid())then return; endif;
		var vec3 vObj=p_xGoalObj.GetObj()^.GetPos(), vOwn=GetPos(),vNew;
		var real fScape=Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vOwn.GetX(),vOwn.GetY()),m_fWaterLevel);
//		var real fHeight=vOwn.GetZ()-fScape, fRange=GetAttackRange()/*+fHeight-GetRadius()*/;
		var real fHeight=vOwn.GetZ()-fScape, fRange=0.5/*+fHeight-GetRadius()*/;
		vOwn.SetZ(fScape);
		var vec3 vDirection=vOwn - vObj;
		vDirection.Normalize();
		vNew=GetPosInMap(vObj+(vDirection*fRange));
		WalkAction(vNew, GetMaxSpeed(), false);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption, ^CGameObj p_pxGoalObj, CFourCC p_xWalkSet, bool p_bUseMaterial)
		var vec3 vPosition=GetPosInMap(p_vDest);
		vPosition.SetZ(Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vPosition.GetX(),vPosition.GetY()),m_fWaterLevel)+GetFlyingHeight());
		return super.WalkAction(vPosition, p_iPrefSpeed, false, false, p_pxGoalObj, p_xWalkSet, p_bUseMaterial);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption, ^CGameObj p_pxGoalObj, CFourCC p_xWalkSet)
		return WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, p_bHeightAdaption, p_pxGoalObj, p_xWalkSet, true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption, ^CGameObj p_pxGoalObj)
		return WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, p_bHeightAdaption, p_pxGoalObj, GetWalkSet(), true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption)
		return WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, p_bHeightAdaption, null, GetWalkSet(), true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder)
		return WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, true, null, GetWalkSet(), true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed)
		return WalkAction(p_vDest, p_iPrefSpeed, true, true, null, GetWalkSet(), true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest)
		return WalkAction(p_vDest, GetMaxSpeed(), true, true, null, GetWalkSet(), true);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed, CFourCC p_xWalkSet, real p_fMaxRange, ref vec3 p_rvRootPos, ref vec3 p_rvGoalOffset)
		if(!p_xGoalObj.IsValid())then return; endif;
		var vec3 vObj=p_xGoalObj.GetObj()^.GetPos(), vOwn=GetPos(),vNew;
		var real fScape=Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vOwn.GetX(),vOwn.GetY()),m_fWaterLevel);
//		var real fHeight=vOwn.GetZ()-fScape, fRange=GetAttackRange()/*+fHeight-GetRadius()*/;
		var real fHeight=vOwn.GetZ()-fScape, fRange=0.5f/*+fHeight-GetRadius()*/;
		vOwn.SetZ(fScape);
		var vec3 vDirection=vOwn - vObj;
		vDirection.Normalize();
		vNew=GetPosInMap(vObj+(vDirection*fRange));
		WalkAction(vNew, GetMaxSpeed(), false);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed, CFourCC p_xWalkSet, real p_fMaxRange, ref vec3 p_rvRootPos)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed, p_xWalkSet, p_fMaxRange, p_rvRootPos);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed, CFourCC p_xWalkSet, real p_fMaxRange)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed, p_xWalkSet, p_fMaxRange);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed, CFourCC p_xWalkSet)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed, p_xWalkSet);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj)
		return super.AdvanceAction(p_xGoalObj);
	endproc;
	
	export proc real GetFlyingHeight()
		if(m_xCurEnemy.IsValid())then
			return m_xCurEnemy.GetObj()^.GetRadius()+m_fAttackHeight;
		endif;
		m_fFlyingHeight=Math.Clamp((m_fFlyingHeight-Random.MTRandF((-2.5),2.5)),m_fFlyingMin,m_fFlyingMax);
		return m_fFlyingHeight;
	endproc;
	
	export proc void Die()
		var ^CGameObj pxGameObj=CSrvWrap.GetObjMgr()^.CreateObj(GetClassName()+"_food",GetOwner(),GetPos(),GetRotation());
		if(pxGameObj!=null)then
			pxGameObj^.SetGFX(GetGfxName());
		endif;
		if(pxGameObj!=null)then
			pxGameObj^.SetName(GetName());
			var ^CFood pxFood=cast<CFood>(pxGameObj);
			if(pxFood!=null)then
				pxFood^.SetRndInvMask(GetRndInvMask());
			endif;
			var int iLastFrame=25;
			var real fHeightFix=0.0f;
			if(GetClassName()=="Pteranodon")then
				iLastFrame=40;
				fHeightFix=3.5f;
			endif;
			var ^CDino_Food pxDinoFood=cast<CDino_Food>(pxGameObj);
			if(pxDinoFood!=null)then
				pxDinoFood^.Initialize(this, m_iSizeClass, false, 0.00001, iLastFrame, fHeightFix);
				pxDinoFood^.SetAggressive(GetTechTreeAggressiv());
			endif;
			var real fNow=CTimeMgr.Get().GetVirtualTime();
			var ^CAttribs pxFoodAttribs=pxGameObj^.GetAttribs();
			if(pxFoodAttribs!=null)then
				pxFoodAttribs^.SetValue("birth_time",GetAttribs()^.GetValueFloat("birth_time"));
				pxFoodAttribs^.SetValue("growup_duration",GetAttribs()^.GetValueFloat("growup_duration"));
				pxFoodAttribs^.SetValue("die_time",fNow);
				var real fMaxHP=GetTechTreeHitpoints();
				var real fCurHP=CalculateHitpointsFromGrowUpSize(fMaxHP);
				var real fMaxValue=pxFoodAttribs^.GetValueInt("value").ToReal();
				pxFoodAttribs^.SetValue("value",((fCurHP*fMaxValue)/fMaxHP).ToInt());
			endif;
			var real fRadius=GetRadius();
			pxGameObj^.SetOwner(GetOwner());
			if(fRadius<=3.5)then
				pxGameObj^.InvokeGenericSCEvent(16,4.0f);
			elseif(fRadius<=5.0)then
				pxGameObj^.InvokeGenericSCEvent(10,4.0f);
			else
				pxGameObj^.InvokeGenericSCEvent(17,4.0f);
			endif;
		endif;
		super.Die();
	endproc;
	
	export proc bool SkipCorpse()
		return true;
	endproc;
	
	export proc void SetIdleAnim()
//		if(GetCurrentAnimName()!=m_sFlyIdleAnim)then
//			SetAnim(m_sFlyIdleAnim,3);
//		endif;
		SetSLEAnim(m_sFlyIdleAnim,9999,false,false);
		return;
	endproc;
	
	export proc void OnActionPreEnd(bool p_bBroken)
//		SetIdleAnim();
		super.OnActionPreEnd(p_bBroken);
	endproc;
	
	export proc void OnActionEnd(bool p_bBroken)
//		SetIdleAnim();
		super.OnActionEnd(p_bBroken);
	endproc;
	
	export proc void StopEverything()
		super.StopEverything();
		SetIdleAnim();
	endproc;
	
	export proc void SetIced(real p_fDuration,real p_fResistStart)
		return;
	endproc;
	
	export proc int IsInCombatRangeAttackZone(^CObjBase p_pxEnemy, real p_fMaxDist1, real p_fMaxDist2, real p_fMaxDist3, real p_fPConeFallOff)
		var int iRange=super.IsInCombatRangeAttackZone(p_pxEnemy, p_fMaxDist1, p_fMaxDist2, p_fMaxDist3, p_fPConeFallOff);
		if(p_pxEnemy==null)then return iRange; endif;
		var ^CFightingObj pxEnemy=cast <CFightingObj>(p_pxEnemy);
		if(pxEnemy==null)then return iRange; endif;
		if(iRange==0)then
			var vec3 vOwn=GetPos(), vEnemy=pxEnemy^.GetPos();
			vOwn.SetZ(10.0);
			vEnemy.SetZ(10.0);
			var real fAttackRange=GetAttackRange()+GetCollisionRadius();
			var real fAtRan=(fAttackRange*fAttackRange);
			var real fDistance=(vOwn - vEnemy).Abs2S();
			if(fDistance<=(fAtRan-1.0f))then iRange=1; endif; //is in range
		endif;
		return iRange;
	endproc;
	
endclass;

class CBaryonyx inherit CAnimal
	
	var string m_sIdleAnim;
	var string m_sHump;
	
	export constructor()
		if(CMirageSrvMgr.Get().NoHumpWalking())then
			m_sHump="def";
		else
			m_sHump="hump";
		endif;
	endconstructor;

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetCanSwim(true);
		SetIdleAnim();
		if(!p_bLoad)then
			ReBuildWeapon();
		endif;
	endproc;
	
//	export proc void ReBuildWeapon()
//		SetBuildUp(CBuildUpBase.TYPE_FAKE);
//		AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
//		var ^CBuildUpWeapon pxWeaponBuildUp=cast<CBuildUpWeapon>(GetAdditionalBuildUp(0));
//		pxWeaponBuildUp^.AddObjCaptain(m_xCaptain, "Ride", -1.0, GetHandle());
//		var string sClass=GetClassName().Left(GetClassName().Find("_"));
//		pxWeaponBuildUp^.SetWeaponClass(sClass+"_cat_rider");
//		pxWeaponBuildUp^.SetCanRotate(true);
//		pxWeaponBuildUp^.SetAdditionalWeapon(true);
//		pxWeaponBuildUp^.SetAutoAttack(true);
//	endproc;
	
//	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
//		po_rxLink="Ride";
//		po_rbIsBuildUpLink=false;
//		SetCaptainAnim("ride_idle_0");
//		SetCaptainAttackAnim("ride_bow");
//		return true;
//	endproc;
	
	export proc void SetIdleAnim()
		OnAmphibianWaterLandTransition(!IsInWater(),false);
		SetAnim(m_sIdleAnim,3);
	endproc;
	
	export proc void CheckWaterLand()
		OnAmphibianWaterLandTransition(!IsInWater(),true);
	endproc;
	
	export proc string GetThreatAnim()
		if(IsInWater())then
			return "";
		else
			return "menace";
		endif;
	endproc;
	
	export proc ref CFourCC GetWalkSet()
		return m_xWalkSet;
	endproc;
	
	//this function will be called from inside the walk action
	proc void OnAmphibianWaterLandTransition(bool p_bWaterToLand, bool p_bInto)
		if(p_bWaterToLand)then
			m_sIdleAnim="standanim";
			m_xWalkSet="def";
			m_xHumpWalkSet=m_sHump;
		else
			m_sIdleAnim="swim_standanim";
			m_xWalkSet="swim";
			m_xHumpWalkSet="swim";
//			if(p_bInto)then
//				SetAnim("walk_to_swim_2",1);
//			endif;
		endif;
		SetDefaultWalkSet(m_xWalkSet);
	endproc;
	
	export proc string GetFightAnim()
		if(IsInWater())then
			return "swim_attack_front";
		else
			return m_xCurrentFightAnim.m_sAnim;
		endif;
	endproc;
	
	export proc string EatAnim()
		if(IsInWater())then
			return "swim_attack_front";
		else
			return "feeding";
		endif;
	endproc;
	
	export proc bool IsBugged()
		if(IsInWater())then
			return true;
		endif;
		return m_bBugged;
	endproc;
	
	export proc string GetVictoryAnim()
		var string sAnim="menace";
		var int iR=Random.GetInt()%3;
		if(iR==1)then
			sAnim="shake";
		elseif(iR==2)then
			sAnim="scratch";
		endif;
		return sAnim;
	endproc;
	
endclass;

class CMacrolemys inherit CAnimal
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetCanWalk(true);
		SetCanSwim(true);
		if(!p_bLoad)then
			CheckWaterLand();
		endif;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		CheckWaterLand();
	endproc;
	
	export proc void OnActionEnd(bool p_bBroken)
		super.OnActionEnd(p_bBroken);
		CheckWaterLand();	//fallback
	endproc;
	
	export proc void SetPos(vec3 p_vPos)
		//somebody beams me around -> I must check my pos for land/water
		super.SetPos(p_vPos);
		CheckWaterLand();
	endproc;
	
	export proc void CheckWaterLand()
		OnAmphibianWaterLandTransition(!IsInWater());
	endproc;
	
	//this function will be called from inside the walk action
	proc void OnAmphibianWaterLandTransition(bool p_bWaterToLand)
		//KLog.LogWarn("CHP","OnAmphibianWaterLandTransition("+p_bWaterToLand.ToString()+") "+CTimeMgr.Get().GetTime().ToString());
		if(p_bWaterToLand)then
			WaterToLand();
		else
			LandToWater();
		endif;
	endproc;
	
	export proc void WaterToLand()
		SetGFX("Macrolemys_Land");
	endproc;
	
	export proc void LandToWater()
		SetGFX("Macrolemys_Water");
	endproc;
	
	export proc void Die()
//		if(IsInWater()&&!CMirageSrvMgr.Get().UnitResources())then
		if(IsInWater())then
			if(!IsDead())then
//				var ^CShipCorpse pxGameObj=cast<CShipCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("ShipCorpse",GetOwner(),GetPos(),GetRotation()));
//				if(pxGameObj!=null)then
//					pxGameObj^.Init("Macrolemys_Water","dying",GetName(), 10.0);
//					pxGameObj^.SetDestructLevel(2);
//				endif;
				var vec3 vCarcass=GetPos();
				vCarcass.SetZ(vCarcass.GetZ()+1.0);
				var ^CGameObj pxGameObj=CSrvWrap.GetObjMgr()^.CreateObj("Macrolemys_food_water",GetOwner(),vCarcass,GetRotation());
				if(pxGameObj!=null)then
					pxGameObj^.SetName(GetName());
					pxGameObj^.SetGFX("Macrolemys_Water");
					var ^CFood pxFood=cast<CFood>(pxGameObj);
					if(pxFood!=null)then
						pxFood^.SetRndInvMask(GetRndInvMask());
					endif;
					var ^CDino_Food pxDinoFood=cast<CDino_Food>(pxGameObj);
					if(pxDinoFood!=null)then
						pxDinoFood^.Initialize(this, m_iSizeClass, false, 0.4f, -88, 1.0f);
						pxDinoFood^.SetAggressive(GetTechTreeAggressiv());
					endif;
					var real fNow=CTimeMgr.Get().GetVirtualTime();
					var ^CAttribs pxFoodAttribs=pxGameObj^.GetAttribs();
					if(pxFoodAttribs!=null)then
						pxFoodAttribs^.SetValue("birth_time",GetAttribs()^.GetValueFloat("birth_time"));
						pxFoodAttribs^.SetValue("growup_duration",GetAttribs()^.GetValueFloat("growup_duration"));
						pxFoodAttribs^.SetValue("die_time",fNow);
						var real fMaxHP=GetTechTreeHitpoints();
						var real fCurHP=CalculateHitpointsFromGrowUpSize(fMaxHP);
						var real fMaxValue=pxFoodAttribs^.GetValueInt("value").ToReal();
						pxFoodAttribs^.SetValue("value",((fCurHP*fMaxValue)/fMaxHP).ToInt());
					endif;
					var real fRadius=GetRadius();
					pxGameObj^.SetOwner(GetOwner());
					if(fRadius<=3.5)then
						pxGameObj^.InvokeGenericSCEvent(16,4.0f);
					elseif(fRadius<=5.0)then
						pxGameObj^.InvokeGenericSCEvent(10,4.0f);
					else
						pxGameObj^.InvokeGenericSCEvent(17,4.0f);
					endif;
					pxGameObj^.SetAnim("dying",1);
				endif;
			endif;
			m_fHitpoints=0.0f;
			SetDead(true);
			Delete();
		else
			super.Die();
		endif;
	endproc;

endclass;

class CResourceAnimal inherit CAnimal
	
	var array string			m_asLimits;					//names of the limit attribs in player
	var array int				m_aiResLimits;				//resource limits update value
	
	constructor()
	endconstructor;
	
	destructor()
		var ^CBasePlayer pxBasePlayer=CBasePlayer.GetPlayer(GetOwner());
		if(pxBasePlayer!=null)then
			pxBasePlayer^.DestroyLimitCountBuilding(GetHandle());
		endif;
	enddestructor;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="RsAn")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int i, iC;
			pxArc^ << iC;
			m_aiResLimits=iC;
			for(i=0)cond(i<iC)iter(i++)do
				pxArc^ << m_aiResLimits[i];
			endfor;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CResourceAnimal] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xBase="RsAn"; //Building base
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		var int i, iC=m_aiResLimits.NumEntries();
		pxArc^ << iC;
		for(i=0)cond(i<iC)iter(i++)do
			pxArc^ << m_aiResLimits[i];
		endfor;
		pxWalk^.Close();
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		m_asLimits.AddEntry("max_units");
		m_asLimits.AddEntry("max_stone");
		m_asLimits.AddEntry("max_wood");
		m_asLimits.AddEntry("max_food");
		m_asLimits.AddEntry("max_iron");
		m_asLimits.AddEntry("max_resin");
		m_asLimits.AddEntry("max_bone");
		m_asLimits.AddEntry("max_hide");
		m_aiResLimits=8;
		OnTechTreeChange();
		var ^CBasePlayer pxBasePlayer=CBasePlayer.GetPlayer(GetOwner());
		if(pxBasePlayer!=null)then
			pxBasePlayer^.AddLimitCountBuilding(GetHandle());
		endif;
	endproc;
	
	export proc void SetOwner(int p_iNewOwner)
		begin RemResAnmlFromPlayer;
			var ^CBasePlayer pxBasePlayer=CBasePlayer.GetPlayer(GetOwner());
			if(pxBasePlayer!=null)then
				pxBasePlayer^.RemoveLimitCountBuilding(GetHandle());
			endif;
		end RemResAnmlFromPlayer;
		// Call the Method of the Superclass to set a new Owner
		super.SetOwner(p_iNewOwner);
		begin AddResAnmlToPlayer;
			var ^CBasePlayer pxBasePlayer=CBasePlayer.GetPlayer(GetOwner());
			if(pxBasePlayer!=null)then
				pxBasePlayer^.AddLimitCountBuilding(GetHandle());
			endif;
		end AddResAnmlToPlayer;
		OnTechTreeChange();
	endproc;
	
	export proc void OnTechTreeChange()
		super.OnTechTreeChange();
	endproc;
	
	export proc void OnTechTreeChange(ref CStringArray p_rasChanges)
		super.OnTechTreeChange(p_rasChanges);
		var bool bUpdateLimits=false;
		var int i, iC=p_rasChanges.NumEntries();
		for(i=0)cond(i<iC)iter(++i)do
			if(p_rasChanges[i].Find(GetObjPath()+"/UpdateLimits/max_")>=0)then
				bUpdateLimits=true;
			endif;
		endfor;
		if(bUpdateLimits)then
			var ^CBasePlayer pxBasePlayer=CBasePlayer.GetPlayer(GetOwner());
			if(pxBasePlayer!=null)then
				pxBasePlayer^.UpdateLimits(false);
			endif;
		endif;
	endproc;
	
	proc void ChangeResLimits(int p_iIndex, int p_iNewValue)
		var ^CAttribs pxPlAttr;
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel!=null)then
			var ^CPlayer pxPlayer=pxLevel^.GetPlayer(GetOwner());
			if(pxPlayer!=null)then
				pxPlAttr=pxPlayer^.GetAttribs();
			else
				//L CSrvWrap.LogInfo("Building","ChangeResLimits(): Player ungltig!");
			endif;
		else
			//L CSrvWrap.LogInfo("Building","ChangeResLimits(): GameInfo ungltig!");
		endif;
		if(pxPlAttr!=null)then
			pxPlAttr^.SetValue(m_asLimits[p_iIndex], (pxPlAttr^.GetValueInt(m_asLimits[p_iIndex]) - m_aiResLimits[p_iIndex])+p_iNewValue);
			m_aiResLimits[p_iIndex]=p_iNewValue;
		endif;
	endproc;
	
endclass;

class CTrackerDino inherit CAnimal
	
	const real			LIFTIME						= 180.0f;
	const real 			ALARM_RANGE_CHECK_INTERVAL	= 10.0f;
	//Kr1s1m: Created a constant field which represents the scan range of the tracker
	const real			RADAR_RANGE					= 60.0f; //Kr1s1m: Originally 100.0f
	
	const int 			LIFETIME_TIMER_ID			= 666;
	const int			CHECK_ALARM_RANGE			= 667;
	const int			CHOOSE_NEW_DEST				= 668;
	
	//Kr1s1m: Added array to store the tracked by the dino unit types
	var array CFourCC	m_axTrackedTypes;
	
	//Kr1s1m: Added a constructor to initialize the tracked types array
	export constructor()
		//Kr1s1m: The tracked unit types to hunt down are set here.
		//Kr1s1m: You need to use the four letter CFourCC type codes and add them as entries.
		if(m_axTrackedTypes.NumEntries()==0)then
			var CFourCC xCHTR = "CHTR";
			var CFourCC xANML = "ANML";
			var CFourCC xVHCL = "VHCL";
			var CFourCC xBLDG = "BLDG";
			m_axTrackedTypes.AddEntry(xCHTR);
			m_axTrackedTypes.AddEntry(xANML);
			m_axTrackedTypes.AddEntry(xVHCL);
			m_axTrackedTypes.AddEntry(xBLDG);
		endif;
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetActAutonomous(true);
		SetCanUseSiege(false);
		if(!p_bLoad)then
			CreateTimer(LIFETIME_TIMER_ID, CGameTimeSpan.OneSecond() * LIFTIME, false);
			CreateTimer(CHECK_ALARM_RANGE, CGameTimeSpan.OneSecond() * ALARM_RANGE_CHECK_INTERVAL, true);
			OnActionEnd(false);
			AutoScout();
		endif;
	endproc;
	
	export proc bool IsAbleToWalk()
		return true;
	endproc;
	
	proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==LIFETIME_TIMER_ID)then
				Die();
				return;
			elseif(p_rxEvtPtr.GetInt(0)==CHECK_ALARM_RANGE)then
				if(!m_xCurEnemy.IsValid())then
					CheckForNearbyEnemies();
				endif;
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	proc vec3 ChooseRandomDestination(real p_fRadius, real p_fAng)
		var real fAng=(Random.GetInt()%(p_fAng*2.0f).ToInt() - (p_fAng.ToInt())).ToReal() * 0.3f;
		var vec3 vCurPos=GetPos();
		var vec3 vCurDir={0.0, 1.0, 0.0};
		var vec3 vRotVec;
		vRotVec.SetZ(fAng);
		var Quat qRot;
		qRot.FromVec3(vRotVec);
		qRot=GetRot() * qRot;
		qRot.VecRotateU(vCurDir);
		vCurDir*=p_fRadius;
		return vCurPos+vCurDir;
	endproc;
	
	proc void OnActionStart()
		GetFSM()^.Enable(false);
	endproc;
	
	proc bool CheckForNearbyEnemies()
		//Kr1s1m: If no type is being tracked then our job in this function is done.
		if(m_axTrackedTypes.NumEntries()==0)then return false; endif;
		
		var CObjQuery xQuery;
		var CObjList xList, xListSorted;
		//Kr1s1m: First, prepare the main query which will gather all objects of the desired tracked types in a radius range.
		xQuery.RegionCircle(GetPos(), RADAR_RANGE);
		//Kr1s1m: Add the initial type to the query.
		xQuery.SetType(m_axTrackedTypes[0], false);
		//Kr1s1m: Continue by appending the query with each consecutive type from inside the tracked unit types array field.
		var int i, iT = m_axTrackedTypes.NumEntries();
		for(i=1)cond(i<iT)iter(++i)do xQuery.SetType(m_axTrackedTypes[i], true); endfor;
		
		//Kr1s1m: Disabled this part so we can also hunt/track wild animals
		//CSrvWrap.GetDiplomacyMgr().AddMyEnemiesToSearch(GetOwner(), xQuery, false);
		
		var ^CGameObj pxTarget=null;
		//Kr1s1m: Create and initialize a bunch of variables to store indices of objects in radar that are of interest.
		//Kr1s1m: Later these will help easily create priority targeting, without the need of booleans or O(n^2).
		var int iEnemyTribeCHTRorANML=-1, iEnemyTribeVHCL=-1, iEnemyTribeBLDG=-1;
		var int iWildAggresive=-1, iWildNeutral=-1;
		
		//Kr1s1m: If nothing valid was picked up from the world then our job in this function is done.
		if(!xQuery.Execute(xList))then return false; endif;
		
		xList.CopySorted(xListSorted, GetPos(), RADAR_RANGE);
		
		if(xListSorted.NumEntries()>0)then
			var int i, iC=xListSorted.NumEntries();
			for(i=0)cond(i<iC)iter(++i)do
				if(xListSorted[i].IsValid())then
					//Kr1s1m: The next two lines allow the usage of the interface specific to child class CFightingObj.
					var ^CGameObj pxO=xListSorted[i].GetObj();
					var ^CFightingObj pxF=cast<CFightingObj>(xListSorted[i].GetObj());
					var bool bIsFriendly = CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxF^.GetOwner());
					//Kr1s1m: Only consider valid non-allied units which are on the ground.
					if(pxO!=null && !bIsFriendly && !pxO^.GetIsVanished() && !pxO^.IsInWater() && !pxO^.CanFly())then
						if(!pxF^.IsWildAnimal() && 
						   (pxF^.GetType()=="CHTR" || pxF^.GetType()=="ANML") && iEnemyTribeCHTRorANML==-1)then
						    //Kr1s1m: If the CFightingObj is an enemy unit of type CHTR or ANML & such index is not yet stashed save that index.
							iEnemyTribeCHTRorANML=i;
							break;
						endif;
						if(!pxF^.IsWildAnimal() && pxF^.GetType()=="VHCL" && iEnemyTribeVHCL==-1)then 
						    //Kr1s1m: Same as comment above, except for type VHCL
							iEnemyTribeVHCL=i;
						endif;
						if(!pxF^.IsWildAnimal() && pxF^.GetType()=="BLDG" && iEnemyTribeBLDG==-1)then 
						    //Kr1s1m: Same as comment above, except for type BLDG
							iEnemyTribeBLDG=i;
						endif;
						if(pxF^.IsWildAnimal() && pxF^.IsAggressive() && iWildAggresive==-1)then
							//Kr1s1m: If the CFightingObj is a wild aggressive creature and such index is not yet stashed save that index.
							iWildAggresive=i;
						endif;
						if(pxF^.IsWildAnimal() && !pxF^.IsAggressive() && iWildNeutral==-1)then
							//Kr1s1m: Same as comment above this one, but for non-agressive wild creatures (both green and yellow)...
							//Kr1s1m: ...except if the current CFightingObj has "is_baby" attribute (<1.0f grow value) then skip it.
							if(pxF^.GetGrowUpValue()<1.0f)then continue; endif;
							iWildNeutral=i;
						endif;
						pxTarget=pxO;
					endif;
				endif;
			endfor;
		endif;
		//Kr1s1m: The if-elseif-....-elseif-endif chain bellow models the following order of prioritising targets
		//iEnemyTribeCHTRorANML->iEnemyTribeVHCL->iEnemyTribeBLDG->iWildAggresive->iWildNeutral
		if(iEnemyTribeCHTRorANML > -1)then
			pxTarget=xListSorted[iEnemyTribeCHTRorANML].GetObj();
		elseif(iEnemyTribeVHCL > -1)then
			pxTarget=xListSorted[iEnemyTribeVHCL].GetObj();
		elseif(iEnemyTribeBLDG > -1)then
			pxTarget=xListSorted[iEnemyTribeBLDG].GetObj();
		elseif(iWildAggresive > -1)then
			pxTarget=xListSorted[iWildAggresive].GetObj();
		elseif(iWildNeutral > -1)then
			pxTarget=xListSorted[iWildNeutral].GetObj();
		endif;
		if(pxTarget!=null)then
			var vec3 vEPos=pxTarget^.GetPos();
			Fight(pxTarget, vEPos, true, false);
			return true;
		endif;
		return false;
	endproc;
	
	proc void OnIdleTick(int p_iTime)
		if(!CheckForNearbyEnemies())then
			var vec3 vP=ChooseRandomDestination(25.0f, 2.0f);
			GoTo(vP, true, GetMaxSpeed(), true, true);
			return;
		endif;
		super.OnIdleTick(p_iTime);
	endproc;
	
	export proc void OnActionEnd(bool p_bBroken)
		super.OnActionEnd(p_bBroken);
	endproc;
	
	export proc bool DoesCountInUnitLimit()
		return false;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(p_sMiscParams.Find("/Kill")!=-1)then
			Die();
		endif;
		return;
	endproc;
	
	export proc bool IsDetector()
		return true;
	endproc;
	
endclass;

class CEusmilus inherit CAnimal
	
	var string m_sRangedEffectPath;
	var bool m_bRangedEffectOnEnemy;
	
	export constructor()
		m_xSink.m_xOnObjAdd=OnObjAdd;
		m_xSink.m_xOnObjRem=OnObjRem;
	endconstructor;
	
	export destructor()
		if(GetClassName()=="special_eusmilus")then
			CNPCMgr.Get().RemoveNPC(GetOwner(),GetHandle());
		endif;
	enddestructor;
	
	export proc string EatAnim()
		if(GetClassName()=="special_eusmilus")then
			return "eusmilus_fm_0";
		endif;
		return "feeding";
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		po_rxLink="Ride";
		SetCaptainAnim("ride_idle_0");
		if(GetClassName()=="ninigi_eusmilus")then
			SetCaptainAttackAnim("tec_ride_bow_shoot");
		else
			SetCaptainAttackAnim("ride_attack_front");
		endif;
		return true;
	endproc;
	
	export proc string GetVictoryAnim()
		var string sAnim="menace";
		if(Random.GetInt()%2==1)then
			sAnim="shake";
		endif;
		return sAnim;
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			if(GetClassName()=="special_eusmilus")then
				SetUnique(true);
			endif;
		endif;
		if(GetClassName()=="special_eusmilus")then
			if(!CNPCMgr.Get().AddNPC(GetOwner(),GetHandle()))then
				Delete();
			endif;
		endif;
	endproc;
	
	export proc void SetOwner(int p_iNewOwner)
		if(GetClassName()=="special_eusmilus")then
			CNPCMgr.Get().RemoveNPC(GetOwner(),GetHandle());
		endif;
		super.SetOwner(p_iNewOwner);
		if(GetClassName()=="special_eusmilus")then
			if(!CNPCMgr.Get().AddNPC(GetOwner(),GetHandle()))then
				Delete();
			endif;
		endif;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			)then return; endif;
		if(GetTransportObj().IsValid()&&!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/LeaveTransport")>=0))then return; endif;
		if(GetClassName()=="special_eusmilus")then
			if(p_sCommand=="Action")then
//				if(p_sMiscParams.Find("Hypnosis")!=-1)then
				if(p_sMiscParams.Find("Hypnosis")!=-1&&CheckSpecialActionTimer(p_sMiscParams,p_pxObject,true))then
					HypnoseAnimal(p_pxObject, p_sMiscParams, p_bQ, p_bA);
					return;
				endif;
			endif;
		endif;
		super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
	endproc;
	
	proc bool HypnoseAnimal(^CGameObj p_pxObject, string p_sPath, bool p_bQ, bool p_bAILock)
		if(p_pxObject==null)then return false; endif;
//		if(p_pxObject^.GetClassName()=="Miyagi_s0"||p_pxObject^.GetClassName()=="special_eusmilus")then return false; endif;
		var bool bReturn=false;
		if(p_pxObject^.GetType()=="ANML"||p_pxObject^.GetType()=="CHTR")then
//			MemorizeCurrentFightState(p_pxObject^.GetHandle(),true,false);
			var ^CMickDundeeMove pxTask= cast<CMickDundeeMove>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(), "Dundee"));
			if(pxTask==null)then return false; endif;
			if(pxTask^.Init(GetHandle(),p_pxObject^.GetHandle(), p_sPath))then
				bReturn=true;
				SetAILock(p_bAILock);
				pxTask^.SetUserCommand(true);
				NewTaskFO(pxTask,p_bQ);
			else
				pxTask^.GetFactory()^.FreeState(pxTask);
			endif;
		endif;
		return(bReturn);
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="SpEu")then
			var int iVersion=p_pxNode^.GetVersion();
			var ^CArc pxArc=^(p_pxNode^.GetArc());
			(pxArc^) << m_sRangedEffectPath;
			(pxArc^) << m_bRangedEffectOnEnemy;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CEusmilus] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xF="SpEu";
		var ^CUOFWriterNode pxN=p_pxWriterNode^.AddSubChunk(xF,1);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_sRangedEffectPath;
		(pxArc^) << m_bRangedEffectOnEnemy;
		pxN^.Close();
	endproc;
	
	proc bool OnObjAdd(CObjHndl p_xHndl)
		if(m_bToBeDeleted)then return false; endif;
		var ^CFightingObj pxO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxO==null)then return false; endif;
		if(m_sRangedEffectPath.IsEmpty())then return false; endif;
		var bool bFriend = (GetOwner()==pxO^.GetOwner()) || (AuraSharing()&&(CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxO^.GetOwner(), GetOwner())&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxO^.GetOwner())));
		var bool bEnemy=CSrvWrap.GetDiplomacyMgr().GetIsEnemy(GetOwner(), pxO^.GetOwner())||CSrvWrap.GetDiplomacyMgr().GetIsEnemy(pxO^.GetOwner(),GetOwner());
		if(bFriend && m_bRangedEffectOnEnemy)then
			return false;
		elseif(bEnemy && !m_bRangedEffectOnEnemy)then
			return false;
		elseif(!bFriend&&!bEnemy)then
			return false;
		endif;
		m_xRegionObjects.Include(p_xHndl);
		var ^CTechTreeDef pxTTDef=pxO^.GetTechTreeDef();
		if(pxTTDef!=null)then
			pxTTDef^.EnableFilter(m_sRangedEffectPath);
		endif;
		return true;
	endproc;
	
	proc bool OnObjRem(CObjHndl p_xHndl)
		if(m_xRegionObjects.FindEntry(p_xHndl)==-1)then return false; endif;
		m_xRegionObjects.RemEntry(p_xHndl);
		var ^CFightingObj pxO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxO==null)then return false; endif;
		var ^CTechTreeDef pxTTDef=pxO^.GetTechTreeDef();
		if(pxTTDef!=null)then
			pxTTDef^.DisableFilter(m_sRangedEffectPath);
		endif;
		return true;
	endproc;
	
	export proc void OnTechTreeChange()
		super.OnTechTreeChange();
	endproc;
	
	export proc void OnTechTreeChange(ref CStringArray p_rasChanges)
		super.OnTechTreeChange(p_rasChanges);
		if(GetClassName()=="special_eusmilus")then
			// check player weapons, maybe there is something for us
			var bool bSARangeEffect=false;
			var int i,iC;
			for(i=0) cond(i<p_rasChanges.NumEntries()) iter(i++)do
				var string sVal=p_rasChanges[i];
				if(sVal.Find("special_abilities")>=0)then
					if(sVal.Find("RangeEffect")>=0)then
						bSARangeEffect=true;
					endif;
				endif;
			endfor;
			if(bSARangeEffect)then
				var ^CFightingObj.CSpecialAbility pxAb=m_xAbilities.GetAbility("RangeEffect", true);
				if(pxAb!=null && !HasPersonalRegion())then
					m_sRangedEffectPath = "/Filters/Special/Upgrades/"+GetClassName()+"/RangeEffect";
					m_bRangedEffectOnEnemy = pxAb^.GetValueB("OnEnemy");
					var real fRange=pxAb^.GetValueF("radius");
					var vec3 vDimension; vDimension.SetXYZ(fRange, fRange, 0.0);
					CreatePersonalRegion("RangedEffect_"+GetName()+"_"+Random.GetInt().ToString(), vDimension, 010b);
					AddRangedBuff("owner_stina");
				endif;
				if(pxAb==null && HasPersonalRegion())then
					DeletePersonalRegion();
				endif;
			endif;
		endif;
	endproc;
	
	export proc void InitOwnRegion()
		var ^CFightingObj.CSpecialAbility pxAb=m_xAbilities.GetAbility("RangeEffect", true);
		if(pxAb!=null && !HasPersonalRegion())then
			m_sRangedEffectPath = "/Filters/Special/Upgrades/"+GetClassName()+"/RangeEffect";
			m_bRangedEffectOnEnemy = pxAb^.GetValueB("OnEnemy");
			var real fRange=pxAb^.GetValueF("radius");
			var vec3 vDimension; vDimension.SetXYZ(fRange, fRange, 0.0);
			CreatePersonalRegion("RangedEffect_"+GetName()+"_"+Random.GetInt().ToString(), vDimension, 010b);
			AddRangedBuff("owner_stina");
		endif;
	endproc;
	
	export proc void RemoveBuff()
		RemoveRangedBuff("owner_stina");
	endproc;
	
endclass;

class CKennelEusmilus inherit CEusmilus
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		return false;
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetActAutonomous(true);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_PARTYCOL,false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_HELMET,false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMOR,false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_STANDARTE,false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMORSADDLE,false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_MISC,false);
		if(!p_bLoad)then
			SetLevelClean(0);
		endif;
	endproc;
	
	export proc bool DoesCountInUnitLimit()
		return false;
	endproc;
	
	export proc void AddKillerCount(int p_iAdd)
		super.AddKillerCount(p_iAdd);
		if(GetLevel()<4)then
			if(m_iKillerCount>125)then
				SetLevelClean(4);
			elseif(m_iKillerCount>85)then
				SetLevelClean(3);
			elseif(m_iKillerCount>50)then
				SetLevelClean(2);
			elseif(m_iKillerCount>20)then
				SetLevelClean(1);
			endif;
		endif;
	endproc;
	
endclass;

class CNinigiDilophosaurus inherit CAnimal
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetActAutonomous(true);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_PARTYCOL,false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_HELMET,false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMOR,false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_STANDARTE,false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMORSADDLE,false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_MISC,false);
	endproc;
	
	export proc bool DoesCountInUnitLimit()
		return false;
	endproc;
	
	export proc void AddKillerCount(int p_iAdd)
		super.AddKillerCount(p_iAdd);
		if(GetLevel()<4)then
			if(m_iKillerCount>125)then
				SetLevelClean(4);
			elseif(m_iKillerCount>85)then
				SetLevelClean(3);
			elseif(m_iKillerCount>50)then
				SetLevelClean(2);
			elseif(m_iKillerCount>20)then
				SetLevelClean(1);
			endif;
		endif;
	endproc;
	
endclass;

class CTrainingDummyANML inherit CTrainingDummy
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetType("ANTD");
		var ^CAttribs pxAttribs=InitAttribs();
		var real fT=CTimeMgr.Get().GetVirtualTime();
		pxAttribs^.SetValue("birth_time",fT);
		pxAttribs^.SetValue("die_time",fT);
		pxAttribs^.SetValue("growup_duration",1.0f);
	
		SetRndInvMask(CFightingObj.VIS_FLAG_ANML_PLAYER_ALL|CFightingObj.VIS_FLAG_ANML_WOUND_ALL);
	endproc;
endclass;

class CDecoAnimal inherit CAnimal
	export constructor()
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetSelectable(false);
		SetHitable(false);
		SetAggressionState(-1);
		if(!p_bLoad)then
			var string sClass=GetClassName(), sType="hc_citizen_0";
			var int iR=4;
			if(sClass=="hc_guard_01_animal")then
				iR=2;
				sType="hc_guard_0";
			elseif(sClass=="hc_worker_01_animal")then
				iR=3;
				sType="hc_worker_0";
			endif;
			var int iRandom=Random.GetInt()%iR+1;
			SetGFX(sType+iRandom.ToString());
	endif;
	endproc;
	
	export proc void InvokeGenericSCEvent(int p_iInt, real p_fReal)
	endproc;
	
//	export proc int GetDefaultSpeed()
//		return 2;
//	endproc;
	
//	export proc int GetMaxSpeed()
//		return 2;
//	endproc;
	
endclass;

class CTrex inherit CAnimal
	
	export proc void SetIdleAnim()
		Random.Seed();
		var int iRand=Random.GetInt()%5;
		switch(iRand)
			case (0)do AnimAction("idle_0",Random.GetInt()%15,true,true); endcase;
			case (1)do AnimAction("idle_1"); endcase;
			case (2)do AnimAction("idle_2"); endcase;
			case (3)do AnimAction("idle_3"); endcase;
			case (4)do AnimAction("idle_4"); endcase;
			case default do endcase;
		endswitch;
	endproc;
	
	endclass;
	
class CDonkeyKong inherit CAnimal
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetVisInFOW(false);
	endproc;

endclass;

class CAjeTrex inherit CAnimal
	
	const string MONARCHBLADES = "/Filters/Aje/Upgrades/xenage/aoe_weapon_atroxo";
	const int TIMER_MONARCH_BLADES = 40112; //Henry: for turning off rex titan's aoe
	var bool m_bExtraCaptains;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		m_bExtraCaptains=!CMirageSrvMgr.Get().TitanSlots();
		if(!p_bLoad)then
			ReBuildWeapon();
		endif;
	endproc;
	
	export proc void ReBuildWeapon()
		var string sClassName=GetClassName();
		if(sClassName=="aje_atroxosaurus")then
			var CObjHndl xMe=GetHandle();
			SetBuildUp(CBuildUpBase.TYPE_TREX);
			AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
			var ^CBuildUpWeapon pxWeaponBuildUp=cast<CBuildUpWeapon>(GetAdditionalBuildUp(0));
			pxWeaponBuildUp^.AddObjCaptain(m_xCaptain, "Ride", -1.0, xMe);
			pxWeaponBuildUp^.SetWeaponClass("aje_trex_handler_char");
			pxWeaponBuildUp^.SetCanRotate(true);
			pxWeaponBuildUp^.SetAdditionalWeapon(true);
			if(m_bExtraCaptains)then
				AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
				pxWeaponBuildUp=cast<CBuildUpWeapon>(GetAdditionalBuildUp(1));
				pxWeaponBuildUp^.SetFake(true);
				var ^CCaptain pxC=cast<CCaptain>(CSrvWrap.GetObjMgr()^.CreateObj("universal_captain", GetOwner()));
				if(pxC!=null)then
					pxC^.Init(xMe,"aje_trex_guard",true);
					pxWeaponBuildUp^.AddObjCaptain(pxC^.GetHandle(), "Rid2", -1.0, xMe);
				endif;
				AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
				pxWeaponBuildUp=cast<CBuildUpWeapon>(GetAdditionalBuildUp(2));
				pxWeaponBuildUp^.SetFake(true);
				pxC=cast<CCaptain>(CSrvWrap.GetObjMgr()^.CreateObj("universal_captain", GetOwner()));
				if(pxC!=null)then
					pxC^.Init(xMe,"aje_trex_guard",true);
					pxWeaponBuildUp^.AddObjCaptain(pxC^.GetHandle(), "Rid3", -1.0, xMe);
				endif;
			endif;
		endif;
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		if(HasBuildUp(CBuildUpBase.TYPE_TREX))then
			po_rxLink="Ride";
			po_rbIsBuildUpLink=true;
			SetCaptainAnim("standanim");
			SetCaptainAttackAnim("bow_1");
		else
			return super.GetCaptainLink(po_rxLink, po_rbIsBuildUpLink);
		endif;
		return true;
	endproc;
	
	export proc void LinkCaptainObj()
		var ^CGameObj pxCaptain=m_xCaptain.GetObj();
		if(pxCaptain==null)then return; endif;
		AddGroupedChildren(pxCaptain^.GetGuid());
		var bool bBuildUpLink; var CFourCC xLink;
		var CFourCC xNoNo="NOPE";
		if(GetCaptainLink(xLink, bBuildUpLink))then
			pxCaptain^.SetVisible(true);
			if(HasBuildUp(CBuildUpBase.TYPE_TREX))then
				pxCaptain^.RideAction(GetHandle(),xLink,{0.0,0.0,0.0});
			elseif(bBuildUpLink && HasBuildUp())then
				pxCaptain^.RideAction(GetBuildUp()^.GetPrimaryLinkedObj(),xLink,{0.0,0.0,0.0});
			else
				pxCaptain^.RideAction(GetHandle(),xLink,{0.0,0.0,0.0});
			endif;
			DoCaptainAnim();
			return;
		endif;
		xLink="NONE";
		pxCaptain^.LinkAction(GetHandle(),xLink);
		pxCaptain^.SetVisible(false);
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/Dismount")!=-1)
			)then return; endif;
		if(GetTransportObj().IsValid()&&!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/LeaveTransport")>=0))then return; endif;
		if(GetActAutonomous() && p_sMiscParams.Find("AttackSrv")==-1 &&
		!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill"))then return; endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("/trex_scrunch")!=-1)then
				if(CheckSpecialActionTimer(p_sMiscParams))then
					if(ShakeOff("trex_fm_2",0.2,2.0,100.0,100.0,15.0,p_sMiscParams,p_bQ,false,p_bA))then
//						TitanDefense(15.0);
					endif;
				endif;
			elseif(p_sMiscParams.Find("/trex_roar")!=-1)then
				if(CheckSpecialActionTimer(p_sMiscParams))then
					StunningRoar("menace",7.0,0.8,10.0,p_sMiscParams,p_bQ,p_bA);
				endif;
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	export proc void MonarchBlades()
		if(HasTimer(TIMER_MONARCH_BLADES))then DeleteTimer(TIMER_MONARCH_BLADES); endif;
		ActivateCustomFilterAndUpdate(true,MONARCHBLADES);
		CreateTimer(TIMER_MONARCH_BLADES,CGameTimeSpan.OneSecond()*5.0f, false);
		return;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==TIMER_MONARCH_BLADES)then
				ActivateCustomFilterAndUpdate(false,MONARCHBLADES);
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	export proc real GetAdaption()
		return 5.5f;
	endproc;
	
	export proc void DoCaptainAttackAnim()
		if(m_bExtraCaptains)then
			var int i, iC=NumAdditionalBuildUps();
			for(i=0)cond(i<iC)iter(i++)do
				GetAdditionalBuildUp(i)^.PlayExtraAnim("jans_anim_2");
			endfor;
		endif;
		return super.DoCaptainAttackAnim();
	endproc;
	
	export proc void TitanDefense(real p_fRadius)
			var int iOwner=GetOwner();
			var real fDuration=20.0f;
			if(iOwner>=0)then
				var CObjQuery xQuery;
				xQuery.SetType("ANML", false);
				xQuery.SetType("CHTR", true);
				xQuery.SetType("VHCL", true);
				xQuery.SetOwner(iOwner);
				CSrvWrap.GetDiplomacyMgr().AddMyFriendsToSearch(iOwner, xQuery);
				xQuery.RegionCircle(GetPos(), p_fRadius);
				var CObjList xList;
				xQuery.Execute(xList);
				var int i, iC=xList.NumEntries();
				for(i=0) cond(i<iC) iter(++i)do
					var ^CFightingObj pxF=cast<CFightingObj>(xList[i].GetObj());
					if(pxF!=null)then
						pxF^.SetTitanDefense(true,fDuration);
					endif;
				endfor;
			endif;
	endproc;
	
	export proc string GetVictoryAnim()
		var string sAnim="menace";
		if(Random.GetInt()%2==1)then
			sAnim="idle_1";
		endif;
		return sAnim;
	endproc;
	
endclass;

class CSeismosaurus inherit CAnimal
	
	export const string SPEED_RUN_PATH="/Filters/Ninigi/Upgrades/xenage/speed_run";
	
	export constructor()
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			ReBuildWeapon();
		endif;
	endproc;
	
	export proc void ReBuildWeapon()
		SetBuildUp(CBuildUpBase.TYPE_SEISMO);
		var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("ninigi_triceratops_launcher", GetOwner());
		GetBuildUp()^.AddObj(pxO^.GetHandle(), "con");
		//cast<CBuildUpWeapon>(GetBuildUp())^.SetWeaponClass(GetClassName());
		cast<CBuildUpWeapon>(GetBuildUp())^.SetCanRotate(true);
		//cast<CBuildUpWeapon>(GetBuildUp())^.SetAutoAttack(true);
		AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
		var ^CBuildUpWeapon pxWeaponBuildUp=cast<CBuildUpWeapon>(GetAdditionalBuildUp(0));
		pxO=CSrvWrap.GetObjMgr()^.CreateObj("ninigi_parasaurolophus_gatling_obj", GetOwner());
		pxWeaponBuildUp^.AddObj(pxO^.GetHandle(), "con2");
		var ^CCaptain pxC=cast<CCaptain>(CSrvWrap.GetObjMgr()^.CreateObj("universal_captain", GetOwner()));
		pxC^.Init(GetHandle());
		pxWeaponBuildUp^.AddObjCaptain(pxC^.GetHandle(), "Dri1", -1.0, pxO^.GetHandle(), true);
		pxWeaponBuildUp^.SetWeaponClass("ninigi_titan_gatling");
		pxWeaponBuildUp^.SetCanRotate(true);
		pxWeaponBuildUp^.SetAdditionalWeapon(true);
		pxWeaponBuildUp^.SetAutoAttack(true);
		AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
		pxWeaponBuildUp=cast<CBuildUpWeapon>(GetAdditionalBuildUp(1));
		pxO=CSrvWrap.GetObjMgr()^.CreateObj("ninigi_parasaurolophus_gatling_obj", GetOwner());
		pxWeaponBuildUp^.AddObj(pxO^.GetHandle(), "con3");
		pxC=cast<CCaptain>(CSrvWrap.GetObjMgr()^.CreateObj("universal_captain", GetOwner()));
		pxC^.Init(GetHandle());
		pxWeaponBuildUp^.AddObjCaptain(pxC^.GetHandle(), "Dri1", -1.0, pxO^.GetHandle(), true);
		pxWeaponBuildUp^.SetWeaponClass("ninigi_titan_gatling");
		pxWeaponBuildUp^.SetCanRotate(true);
		pxWeaponBuildUp^.SetAdditionalWeapon(true);
		pxWeaponBuildUp^.SetAutoAttack(true);
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		po_rxLink="Dri1";
		po_rbIsBuildUpLink=true;
		SetCaptainAnim("gatling_rider_standanim");
		SetCaptainAttackAnim("gatling_rider_attack");
		return true;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(	IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/Dismount")!=-1)
			)then return; endif;
		if(GetTransportObj().IsValid()&&!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/LeaveTransport")>=0))then return; endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("/barrage")!=-1)then
				if(CheckSpecialActionTimer(p_sMiscParams))then
					ShakeOff("idle_1",2.0,1.0,100.0,100.0,20.0,p_sMiscParams,p_bQ,false,p_bA);
				endif;
			elseif(p_sMiscParams.Find("/enchain")!= -1)then
				if(CheckSpecialActionTimer(p_sMiscParams,p_pxObject,true))then
//				if(p_pxObject!=null)then
					Enchain(p_pxObject^.GetHandle(), p_sMiscParams, p_bQ);
				endif;
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	export proc bool Enchain(CObjHndl p_xTarget, string p_sMiscParams, bool p_bQ)
//		MemorizeCurrentFightState(p_xTarget,true,false);
		var ^CEnchain pxTask=cast<CEnchain>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"Enchain"));
		if(pxTask==null)then return false; endif;
		var bool bReturn=pxTask^.Init(GetHandle(),p_xTarget,p_sMiscParams);
		if(bReturn)then
			pxTask^.SetUserCommand(true);
			NewTaskFO(pxTask,p_bQ);
		else
			pxTask^.GetFactory()^.FreeState(pxTask);
		endif;
		return bReturn;
	endproc;
	
	export proc void DoCaptainThrowAnim()
		if(m_xCaptain.IsValid())then
			m_xCaptain.GetObj()^.SetAnim("gatling_rider_attack",1);
		endif;
	endproc;
	
	export proc string EatAnim()
		return "idle_2";
	endproc;
	
	export proc string GetVictoryAnim()
		var string sAnim="menace";
		if(Random.GetInt()%2==1)then
			sAnim="idle_3";
		endif;
		return sAnim;
	endproc;
	
endclass;

class CDilophosaurus inherit CAnimal
	
	constructor()
		m_xSink.m_xOnObjAdd=OnObjAdd;
		m_xSink.m_xOnObjRem=OnObjRem;
	endconstructor;
	
	proc bool OnObjAdd(CObjHndl p_xHndl)
		if(m_bToBeDeleted)then return false; endif;
		var ^CFightingObj pxO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxO==null)then return false; endif;
		if(pxO^.GetOwner()==GetOwner())then return false; endif;
		if(CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxO^.GetOwner(), GetOwner())&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxO^.GetOwner()))then return false; endif;
		if(!CSrvWrap.GetDiplomacyMgr().GetIsEnemy(GetOwner(), pxO^.GetOwner()))then return false; endif;
		if(pxO^.GetType()=="BLDG")then return false; endif;
		m_xRegionObjects.Include(p_xHndl);
		pxO^.SetMirageFlag(CFightingObj.MIRAGE_KING_JAW, true);
		pxO^.SetMirageFlag(CFightingObj.MIRAGE_KEEN_EYES, true);
		return true;
	endproc;
	
	proc bool OnObjRem(CObjHndl p_xHndl)
		if(m_xRegionObjects.FindEntry(p_xHndl)==-1)then return false; endif;
		var ^CFightingObj pxO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxO==null)then return false; endif;
		pxO^.SetMirageFlag(CFightingObj.MIRAGE_KING_JAW, false);
		pxO^.SetMirageFlag(CFightingObj.MIRAGE_KEEN_EYES, false);
		m_xRegionObjects.RemEntry(p_xHndl);
		return true;
	endproc;
	
	export proc void UpdateGfxFlags()
		if(GetClassName()=="aje_dilophosaurus")then
			if(m_xTechTree.GetValueB("/Objects/Aje/InventObjects/bfpw_warpath/invented",false))then
				if(!HasPersonalRegion())then
					var vec3 vD; vD.SetXYZ(35.0, 35.0, 0.0);
					CreatePersonalRegion("ScoutEye_"+GetName()+"_"+Random.GetInt().ToString(), vD, 010b);
					AddRangedBuff("owner_less_defense");
					AddRangedBuff("owner_less_armor");
				endif;
			endif;
		endif;
	endproc;
	
	export proc void InitOwnRegion()
		if(GetClassName()=="aje_dilophosaurus")then
			if(m_xTechTree.GetValueB("/Objects/Aje/InventObjects/bfpw_warpath/invented",false))then
				if(!HasPersonalRegion())then
					var vec3 vD; vD.SetXYZ(35.0, 35.0, 0.0);
					CreatePersonalRegion("ScoutEye_"+GetName()+"_"+Random.GetInt().ToString(), vD, 010b);
					AddRangedBuff("owner_less_defense");
					AddRangedBuff("owner_less_armor");
				endif;
			endif;
		endif;
	endproc;
	
endclass;