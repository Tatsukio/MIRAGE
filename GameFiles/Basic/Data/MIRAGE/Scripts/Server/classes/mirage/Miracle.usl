
	//========================================================================================
	//=== Animal Specials ====================================================================
	//========================================================================================
	
class CCyborgRoar inherit CActionTask
	
	var CObjHndl		m_xHandle;
	var string			m_sState;
	var real				m_fTime;
	var real				m_fTimeOffSet;
	var real				m_fAnimLength;
	var real				m_fRadius;
	var real				m_fMultiplier;
	var real				m_fDuration;
	var string			m_sAnim;
	
	export constructor()
		SetName("CyborgRoar");
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CCyborgRoar] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xType="CyRo";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xHandle.DoKArc(pxArc^);
		(pxArc^) << m_sState;
		(pxArc^) << m_fTime;
		(pxArc^) << m_fTimeOffSet;
		(pxArc^) << m_sAnim;
		(pxArc^) << m_fAnimLength;
		(pxArc^) << m_fRadius;
		(pxArc^) << m_fMultiplier;
		(pxArc^) << m_fDuration;
		pxWalk^.Close();
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="CyRo")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xHandle.DoKArc(pxArc^);
			if(p_pxReaderNode^.GetVersion()>=1)then
				(pxArc^) << m_sState;
				(pxArc^) << m_fTime;
				(pxArc^) << m_fTimeOffSet;
				(pxArc^) << m_sAnim;
				(pxArc^) << m_fAnimLength;
				(pxArc^) << m_fRadius;
				(pxArc^) << m_fMultiplier;
				(pxArc^) << m_fDuration;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;

	export proc bool Init(CObjHndl p_xHandle, string p_sAnim, real p_fTime, real p_fTimeOffSet, real p_fRadius, real p_fMultiplier, real p_fDuration, string p_sPath)
		m_sState="start_anim";
		if(!p_xHandle.IsValid())then
			m_sState="EndTask";
			return false;
		endif;
		m_xHandle=p_xHandle;
		m_fTime=p_fTime;
		m_fTimeOffSet=p_fTimeOffSet;
		m_sAnim=p_sAnim;
		m_fRadius=p_fRadius;
		m_fMultiplier=p_fMultiplier;
		m_fDuration=p_fDuration;
		SetSpecialActionPath(p_sPath);
		SetPrepareActionPath(m_xHandle, p_sPath, true);
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		if(m_sState=="EndTask")then
			EndTask();
		endif;
	endproc;
	
	export proc bool OnActionEnd(bool p_bBroken)
		return false;
	endproc;
	
	proc void USLOnTick(int p_iTime)
		var ^CAnimal pxHandle = cast<CAnimal>(m_xHandle.GetObj());
		if(pxHandle==null)then EndTask(); return; endif;
		var real fRange = pxHandle^.GetCollisionRadius()+m_fRadius; // must NOT be 0.0;
		if(m_sState=="start_anim")then
			if(!StartSpecialActionTimer(pxHandle))then
				EndTask();
				return;
			endif;
			pxHandle^.MemorizeCurrentFightState(CObjHndl.Invalid(),false,false);
			pxHandle^.SetAnim(m_sAnim,1);
			m_fAnimLength=pxHandle^.GetCurrentAnimLength();
			pxHandle^.WaitAction(m_fTimeOffSet);
			m_sState="calc_bonus";
		elseif(m_sState=="calc_bonus")then
			var int iOwner=pxHandle^.GetOwner();
			var real fZone=30.0f,fDuration=15.0f;
			if(iOwner>=0)then
				var CObjQuery xQuery;
				xQuery.SetType("ANML", false);
				xQuery.SetType("CHTR", true);
				xQuery.SetType("VHCL", true);
				xQuery.SetOwner(pxHandle^.GetOwner());
				CSrvWrap.GetDiplomacyMgr().AddMyFriendsToSearch(pxHandle^.GetOwner(), xQuery);
				xQuery.RegionCircle(pxHandle^.GetPos(), fZone);
				var CObjList xList;
				xQuery.Execute(xList);
				var int i, iC=xList.NumEntries();
				for(i=0) cond(i<iC) iter(++i)do
					var ^CFightingObj pxF=cast<CFightingObj>(xList[i].GetObj());
					if(pxF!=null)then
						pxF^.SetCyborgEffect(true,fDuration);
					endif;
				endfor;
			endif;
			if(m_fAnimLength>m_fTimeOffSet)then
				pxHandle^.WaitAction(m_fAnimLength-m_fTimeOffSet);
			endif;
			m_sState = "finished";
//			m_sState = "do_deafening";
		elseif(m_sState=="do_deafening")then
			var int iOwner = pxHandle^.GetOwner();
			if(iOwner>=0)then
				var CObjList xEnemies;
				var CObjQuery xQuery;
				CSrvWrap.GetDiplomacyMgr().AddMyEnemiesToSearch(iOwner, xQuery, false);
				xQuery.SetOwner(-1, true);
				xQuery.SetType("CHTR");
				xQuery.SetType("SHIP",true);
				xQuery.SetType("ANML",true);
				xQuery.SetType("VHCL",true);
//				xQuery.SetType("BLDG",true);
				xQuery.SetType("FGHT",true);
				xQuery.RegionCircle(pxHandle^.GetPos(), fRange);
				xQuery.Execute(xEnemies);
				var int i, iC=xEnemies.NumEntries();
				for(i=0)cond(i<iC)iter(++i)do
					var ^CFightingObj pxFO=cast<CFightingObj>(xEnemies[i].GetObj());
					if(pxFO==null)then continue; endif;
					pxFO^.TakeDirectMeleeDmg(pxHandle^.GetDmg()*m_fMultiplier,100.0,iOwner,m_xHandle);
					pxFO^.SetDeafened(true,m_fDuration);
				endfor;
			endif;
			if(m_fAnimLength>m_fTimeOffSet)then
				pxHandle^.WaitAction(m_fAnimLength-m_fTimeOffSet);
			endif;
			m_sState = "finished";
		elseif(m_sState=="finished")then
			m_sState="EndTask";
			pxHandle^.ReturnToFight();
		elseif(m_sState=="EndTask")then
			EndTask();
			return;
		endif;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
	endproc;
	
	export proc void EndTask()
		SetPrepareActionPath(m_xHandle, GetSpecialActionPath(), false);
		super.EndTask();
	endproc;
	
	export proc bool Break()
		return false;
	endproc;
	
	export proc void Skip()
	endproc;
	
endclass;
	
class CEating inherit CGenericHarvest
	
	export const real					S_RADIUS=100.0f;
	
	var CForestSrvMgr.CTree		m_xForTree;
	var CObjHndl							m_xAnimal;
	var CObjHndl							m_xFood;
	var CObjHndl							m_xCurLog;
	var CObjHndl							m_xCurTree;
	var int										m_iFeedLoops;
	var int										m_iAnimLoops;
	var bool									m_bObjFood;
	var bool									m_bTree;
	var bool									m_bFirstHit;
	var bool									m_bHerbivore;
	var bool									m_bCarnivore;
	var bool									m_bPlant;
	var bool									m_bMeat;
	var bool									m_bAllJobPosInvalid;
	var bool									m_bLastHit;
	var bool									m_bWalkAction;
	var vec3									m_vFeedPos;
	var vec3									m_vCurLogPos;
	var vec3									m_vJobPos;
	var vec3									m_vLastImportantPos;
	var array vec3						m_avOldInvalidJobPos;
	var CObjQuery							m_xHuntSearch;
	var CObjQuery							m_xWoodLogSearch;
	var CObjQuery							m_xTreeSearch;
	
	const int									MAX_INVALID_TARGETS =10;
	
	export constructor()
		SetName("EatPlantsOrMeat");
		m_bHerbivore=false;
		m_bCarnivore=false;
		m_bPlant=false;
		m_bMeat=false;
		m_bTree=false;
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CEating] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xType="EPOM";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xAnimal.DoKArc(pxArc^);
		m_xFood.DoKArc(pxArc^);
		m_xCurLog.DoKArc(pxArc^);
		m_xCurTree.DoKArc(pxArc^);
		m_xForTree.DoKArc(pxArc^);
		(pxArc^) << m_bObjFood;
		(pxArc^) << m_vFeedPos;
		(pxArc^) << m_iFeedLoops;
		(pxArc^) << m_iAnimLoops;
		(pxArc^) << m_bFirstHit;
		(pxArc^) << m_bHerbivore;
		(pxArc^) << m_bCarnivore;
		(pxArc^) << m_bPlant;
		(pxArc^) << m_bMeat;
		(pxArc^) << m_bTree;
		(pxArc^) << m_vJobPos;
		(pxArc^) << m_bLastHit;
		(pxArc^) << m_bWalkAction;
		(pxArc^) << m_vLastImportantPos;
		(pxArc^) << m_vCurLogPos;
		var int i,iC=m_avOldInvalidJobPos.NumEntries();
		(pxArc^) << iC;
		for(i=0) cond(i<iC) iter(i++)do
			(pxArc^) << m_avOldInvalidJobPos[i];
		endfor;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="EPOM")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xAnimal.DoKArc(pxArc^);
			m_xFood.DoKArc(pxArc^);
			m_xCurLog.DoKArc(pxArc^);
			m_xCurTree.DoKArc(pxArc^);
			m_xForTree.DoKArc(pxArc^);
			(pxArc^) << m_bObjFood;
			(pxArc^) << m_vFeedPos;
			(pxArc^) << m_iFeedLoops;
			(pxArc^) << m_iAnimLoops;
			(pxArc^) << m_bFirstHit;
			(pxArc^) << m_bHerbivore;
			(pxArc^) << m_bCarnivore;
			(pxArc^) << m_bPlant;
			(pxArc^) << m_bMeat;
			(pxArc^) << m_bTree;
			(pxArc^) << m_vJobPos;
			(pxArc^) << m_bLastHit;
			(pxArc^) << m_bWalkAction;
			(pxArc^) << m_vLastImportantPos;
			(pxArc^) << m_vCurLogPos;
			var int i,iC;
			(pxArc^) << iC;
			m_avOldInvalidJobPos=iC;
			for(i=0)cond(i<iC)iter(i++)do
				(pxArc^) << m_avOldInvalidJobPos[i];
			endfor;
			InitSearch();
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool Init(CObjHndl p_xAnimal,CObjHndl p_xFood)
		m_xAnimal=p_xAnimal;
		m_bObjFood=true;
		m_xFood=p_xFood;
		if(!m_xAnimal.IsValid())then
			return false;
		endif;
		var ^CGameObj pxFood=p_xFood.GetObj();
		if(pxFood!=null&&pxFood^.GetType()=="TREE")then
			m_xCurTree=p_xFood;
			m_vJobPos=pxFood^.GetPos();
			m_sState="goto_chop";
		endif;
		var ^CAttribs pxAnAttribs=m_xAnimal.GetObj()^.GetAttribs();
		if(pxAnAttribs!=null)then
			pxAnAttribs^.SetValue("CurTask",GetName());
			m_bHerbivore=pxAnAttribs^.GetValueInt("Herbivore")==1;
			m_bCarnivore=pxAnAttribs^.GetValueInt("Carnivore")==1;
		endif;
		if(m_xFood.IsValid())then
			var ^CAttribs pxFoAttribs=m_xFood.GetObj()^.GetAttribs();
			if(pxFoAttribs!=null)then
				m_bPlant=pxFoAttribs^.GetValueInt("Plant")==1;
				m_bMeat=pxFoAttribs^.GetValueInt("Meat")==1;
			endif;
		endif;
		InitSearch();
		return true;
	endproc;
	
	export proc bool Init(CObjHndl p_xAnimal,vec3 p_vPos, bool p_bSchnellimbiss)
		m_xAnimal=p_xAnimal;
		if(!m_xAnimal.IsValid()||p_vPos=={0.0,0.0,0.0})then
			return false;
		endif;
//		var ^CAnimal pxAnimal=cast<CAnimal>(m_xAnimal.GetObj());
		var ^CFightingObj pxAnimal=cast<CFightingObj>(m_xAnimal.GetObj());
		if(pxAnimal==null)then
			return false;
		endif;
		m_bObjFood=false;
		m_vFeedPos=p_vPos;
		m_bTree=true;
		var ^CAttribs pxAnAttribs=m_xAnimal.GetObj()^.GetAttribs();
		if(pxAnAttribs!=null)then
			m_bHerbivore=pxAnAttribs^.GetValueInt("Herbivore")==1;
			m_bCarnivore=pxAnAttribs^.GetValueInt("Carnivore")==1;
		endif;
		m_vJobPos=p_vPos;
		m_vCurTarget=p_vPos;
		InitSearch();
		if(!p_bSchnellimbiss)then
			m_bTree=true;
			var bool bNewTree=false;
			var CForestSrvMgr.CTree xForTree;
			bNewTree=CSrvWrap.GetForestMgr().FindHarvestTree(xForTree, pxAnimal^.GetPos(), m_vCurTarget);
			if(xForTree.IsValid())then
				if(bNewTree==true)then
					CSrvWrap.GetForestMgr().SetHitPoints(xForTree, CSrvWrap.GetForestMgr().GetMaxHPFakeTrees());
				endif;
				m_xForTree=xForTree;
				m_sState="goto_chop_forest";
			else
				m_sState="search_for_food";
			endif;
		else
			if(m_bCarnivore)then
				pxAnimal^.SetHunting(true);
			endif;
			m_sState="search_for_food";
		endif;
		return true;
	endproc;
	
	proc CObjHndl CreateObjTree(ref CForestSrvMgr.CTree po_rxForTree)
		CSrvWrap.GetForestMgr().Refresh( po_rxForTree );
		if(po_rxForTree.IsValid())then
			var CObjHndl xTree;
			var CObjHndl xInvalid;
			var string sSetting=CSrvWrap.GetCurLevel()^.GetLevelInfo().GetAttribs().GetValue("Setting");
			if(sSetting=="Cave1")then
				sSetting="Savanna";
			elseif(sSetting=="Cave2")then
				sSetting="Ashvalley";
			elseif(sSetting=="Cave3")then
				sSetting="Oasis";
			endif;
			var vec3 vTreePos;
			if(CSrvWrap.GetForestMgr().GetTreePos(po_rxForTree, vTreePos)==true)then
				m_vCurTarget=vTreePos;
				var int iTreeType=CSrvWrap.GetForestMgr().GetTreeType(po_rxForTree);
				if(iTreeType!=-1)then
					xTree=CSrvWrap.GetObjMgr()^.CreateObj(sSetting+"_Tree_0"+(iTreeType+1).ToString()+"_Timber",(-1),m_vCurTarget)^.GetHandle();
				else
					if(po_rxForTree.IsValid())then
						var ^CGameObj pxObj=po_rxForTree.GetObjHandle().GetObj();
						var string sName=pxObj^.GetClassName();
						var ^CGameObj pxTemp=CSrvWrap.GetObjMgr()^.CreateObj(sName+"_Timber",(-1),m_vCurTarget);
						if(pxTemp!=null)then
							xTree=pxTemp^.GetHandle();
						else
							return(xInvalid);
						endif;
						if(!po_rxForTree.IsConvertedFromFake())then
							var vec3 vTrunkRot={0.0,0.0,0.0};
							var ^CGameObj pxTrunk;
							pxTrunk=CSrvWrap.GetObjMgr()^.CreateObj(sName+"_Stump",(-1),m_vCurTarget);
							if(pxTrunk!=null)then
								pxTrunk^.SetRotation(vTrunkRot);
							else
								return(xInvalid);
							endif;
						endif;
					else
					endif;
				endif;
				m_avOldInvalidJobPos=0;
				CSrvWrap.GetForestMgr().ChopTree(po_rxForTree);
			else
				m_sState="search_for_job";
			endif;
			return xTree;
		else
			var CObjHndl xInvalidObj;
			return xInvalidObj;
		endif;
	endproc;
	
	proc void InitSearch()
//		var ^CAnimal pxAnimal=cast<CAnimal>(m_xAnimal.GetObj());
		var ^CFightingObj pxAnimal=cast<CFightingObj>(m_xAnimal.GetObj());
		if(pxAnimal==null)then return; endif;
		m_xHuntSearch.SetOwner(-1);
		m_xHuntSearch.SetType("ANML");
		m_xHuntSearch.SetAttribsPos("anml_aggressive_type",-1);
		m_xHuntSearch.SetAttribsNeg("camouflage_anml",1);
		m_xHuntSearch.SetAttribsNeg("is_baby",true);
		m_xWoodLogSearch.SetType("WOOD");
		m_xTreeSearch.SetType("TREE");
	endproc;
	
	proc bool AddFailedTarget()
		m_avOldInvalidJobPos.AddEntry(m_vCurTarget);
		if(m_avOldInvalidJobPos.NumEntries()>MAX_INVALID_TARGETS)then
			return false;
		endif;
		return true;
	endproc;
	
	export proc string FindClosestFood(vec3 p_vPos);
//		var ^CAnimal pxAnimal=cast<CAnimal>(m_xAnimal.GetObj());
		var ^CFightingObj pxAnimal=cast<CFightingObj>(m_xAnimal.GetObj());
		if(pxAnimal==null)then
			return "end";
		endif;
		if(p_vPos=={0.0,0.0,0.0})then return "end"; endif;
		m_bTree=false;
		var bool bInf=false;
		var CObjQuery xFoodSearch;
		if(pxAnimal^.GetType()=="CHTR")then
			xFoodSearch.SetType("FRUI");
			xFoodSearch.SetType("FOOD",true);
			xFoodSearch.SetAttribsNeg("inactive",1);
			xFoodSearch.SetAttribsNeg("skip_this",1);
			bInf=true;
		elseif(m_bHerbivore && !m_bCarnivore)then
			xFoodSearch.SetType("FRUI");
			xFoodSearch.SetType("WOOD",true);
			xFoodSearch.SetAttribsNeg("fish",1);
			xFoodSearch.SetAttribsNeg("inactive",1);
			xFoodSearch.SetAttribsNeg("skip_this",1);
		elseif(m_bCarnivore)then
			xFoodSearch.SetType("FOOD");
			if(m_bHerbivore)then
				xFoodSearch.SetType("FRUI",true);
				xFoodSearch.SetType("WOOD",true);
				if(!pxAnimal^.CanSwim())then
					xFoodSearch.SetAttribsNeg("fish",1);
				endif;
				xFoodSearch.SetAttribsNeg("inactive",1);
				xFoodSearch.SetAttribsNeg("skip_this",1);
			else
				xFoodSearch.SetAttribsPos("Meat",true);
				xFoodSearch.SetAttribsNeg("skip_this",1);
			endif;
			if(pxAnimal^.CanSwim() && !pxAnimal^.CanWalk() && !m_bHerbivore)then
				xFoodSearch.SetType("FRUI", true);
				xFoodSearch.SetAttribsNeg("Plant",1);
				xFoodSearch.SetAttribsNeg("inactive",1);
				xFoodSearch.SetAttribsNeg("skip_this",1);
			endif;
		endif;
		xFoodSearch.SetVisibility(pxAnimal^.GetOwner(),true);
		var CObjList xFoods;
		xFoodSearch.RegionCircle(p_vPos,S_RADIUS);
		if(xFoodSearch.Execute(xFoods))then
			xFoods.SortDistance(p_vPos);
			if(bInf)then
				var real fSea=CSrvWrap.GetScapeMgr().GetSeaLevel();
				while(xFoods.NumEntries()>0)do
					if(!xFoods[0].IsValid()||xFoods[0].GetObj()==null||(CSrvWrap.GetScapeMgr().GetHeight(xFoods[0].GetObj()^.GetPos().GetX(), xFoods[0].GetObj()^.GetPos().GetY())+5.0f)<fSea)then
						xFoods.DeleteEntry(0);
						continue;
					endif;
					break;
				endwhile;
			endif;
			//while(xFoods.NumEntries()>0&&!pxAnimal^.CheckMaxAutoprodDist(xFoods[0]))do xFoods.DeleteEntry(0); endwhile;
			if(xFoods.NumEntries()>0)then
				var CFourCC xType=xFoods[0].GetObj()^.GetType();
				var CObjHndl xFood=xFoods[0];
				m_vJobPos=xFoods[0].GetObj()^.GetPos();
				if(xType=="FOOD"||xType=="FRUI"||xType=="WOOD")then
					m_vFeedPos=m_vJobPos;
					m_bObjFood=true;
					m_xFood=xFood;
					return "goto_food";
				else
					return "end";
				endif;
			else
				return "end";
			endif;
		else
			return "end";
		endif;
	endproc;
	
	export proc string FindForestTree(vec3 p_vPos);
//		var ^CAnimal pxAnimal=cast<CAnimal>(m_xAnimal.GetObj());
		var ^CFightingObj pxAnimal=cast<CFightingObj>(m_xAnimal.GetObj());
		if(pxAnimal==null)then
			return "end";
		endif;
		if(!m_bHerbivore)then return "end"; endif;
		if(pxAnimal^.GetType()=="CHTR")then return "end"; endif;
		if(p_vPos=={0.0,0.0,0.0})then return "end"; endif;
		begin FindForestTree;
			var bool bNewTree=false;
			var CForestSrvMgr.CTree xTree;
			var int iSkip=0;
			var vec3 vTree;
			var bool bTreeFound=false;
			while(true)do
				var bool bNewTree=CSrvWrap.GetForestMgr().FindNextTreeShortDelivery(xTree,m_vJobPos,pxAnimal^.GetPos(),S_RADIUS,iSkip);
				if(!xTree.IsValid())then break; endif;
				if(bNewTree==true)then
					CSrvWrap.GetForestMgr().SetHitPoints(m_xForTree, CSrvWrap.GetForestMgr().GetMaxHPFakeTrees());
				endif;
				CSrvWrap.GetForestMgr().GetTreePos(xTree, vTree);
				if(Math.Abs(vTree.GetZ()-p_vPos.GetZ()) > 10.0f)then
					iSkip++;
					continue;
				else
					if(!CheckWalkPos(vTree))then
						iSkip++;
						continue;
					endif;
				endif;
				if(!pxAnimal^.CheckMaxAutoprodDist(vTree))then
					iSkip++;
					continue;
				endif;
				bTreeFound=true;
				break;
			endwhile;
			if(bTreeFound)then
				m_xForTree=xTree;
				if(bNewTree==true)then
					CSrvWrap.GetForestMgr().SetHitPoints(m_xForTree, CSrvWrap.GetForestMgr().GetMaxHPFakeTrees());
				endif;
				m_vJobPos=vTree;
				m_vCurTarget=vTree;
				m_vJobPos=vTree;
				m_bTree=true;
				m_bObjFood=false;
				return "goto_chop_forest";
			endif;
			m_xTreeSearch.RegionCircle(m_vJobPos,S_RADIUS);
			var CObjList xTrees;
			if(m_xTreeSearch.Execute(xTrees))then
				xTrees.SortDistance(m_vJobPos);
				var int i;
				for(i=0)cond(i<xTrees.NumEntries())iter(++i)do
					var ^CTree pxTree= cast<CTree>(xTrees[i].GetObj());
					if(pxTree!=null)then
						if(CheckWalkPos(pxTree^.GetPos()) && pxAnimal^.CheckMaxAutoprodDist(pxTree^.GetPos()))then
							m_xCurTree=pxTree^.GetHandle();
							return "goto_chop";
						endif;
					endif;
				endfor;
			endif;
		end FindForestTree;
		if(!m_bAllJobPosInvalid && m_avOldInvalidJobPos.NumEntries()>0)then
			m_avOldInvalidJobPos=0;
			m_bAllJobPosInvalid=true;
			return "end";
		endif;
		return "end";
	endproc;
	
	export proc bool FindFreshMeat(vec3 p_vPos); //xD
//		var ^CAnimal pxAnimal=cast<CAnimal>(m_xAnimal.GetObj());
		var ^CFightingObj pxAnimal=cast<CFightingObj>(m_xAnimal.GetObj());
		if(pxAnimal==null)then
			EndTask();
			return false;
		endif;
		if(!m_bCarnivore)then EndTask(); return false; endif;
		if(p_vPos=={0.0,0.0,0.0})then EndTask(); return false; endif;
		var CObjList xAnimal;
		m_xHuntSearch.SetVisibility(pxAnimal^.GetOwner(),true);
		m_xHuntSearch.RegionCircle(p_vPos,S_RADIUS);
		if(m_xHuntSearch.Execute(xAnimal))then
			xAnimal.SortDistance(p_vPos);
			while(xAnimal.NumEntries()>0)do
				if(!xAnimal[0].IsValid())then
					xAnimal.DeleteEntry(0);
					continue;
				endif;
				var ^CAnimal pxCandidat=cast<CAnimal>(xAnimal[0].GetObj());
				if(pxCandidat!=null && pxCandidat^.IsBaby())then
					xAnimal.DeleteEntry(0);
					continue;
				endif;
				pxAnimal^.HandleGamePlayCommand("Action",xAnimal[0].GetObj(),xAnimal[0].GetObj()^.GetPos(),"/Attack");
				pxAnimal^.SetHunting(true);
				return true;
			endwhile;
		endif;
		pxAnimal^.SetHunting(false);
		return false;
	endproc;
	
	proc bool CheckWalkFail(ref vec3 p_rvWorker,string p_sSuccState,string p_sFailState)
		if(m_vLastImportantPos==p_rvWorker)then
			m_iWalkFailCnt++;
			if(!AddFailedTarget())then return false; endif;
			if(m_iWalkFailCnt>=15)then
				m_sState="exit";
				return false;
			endif;
			m_sState=p_sFailState;
			return false;
		else
			m_bWalkAction=false;
			m_iWalkFailCnt=0;
			m_sState=p_sSuccState;
			return true;
		endif;
	endproc;
	
	proc bool CheckWalkPos(ref vec3 p_rvPos)
		var int i;
		var int iC=m_avOldInvalidJobPos.NumEntries();
		for (i=0) cond (i<iC) iter (i++)do
			if((p_rvPos-m_avOldInvalidJobPos[i]).Abs()<3.0f)then
				return false;
			endif;
		endfor;
		return true;
	endproc;
	
	// Proc USLOnEnter ======================================================
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
//		var ^CAnimal pxAnimal=cast<CAnimal>(m_xAnimal.GetObj());
		var ^CFightingObj pxAnimal=cast<CFightingObj>(m_xAnimal.GetObj());
		if(pxAnimal==null)then
			EndTask();
			return;
		endif;
		var ^CAttribs pxAttr=pxAnimal^.GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("CurTask",GetName());
		endif;
		pxAnimal^.SetTaskDescription("restaurant");
		if(!m_bTree)then
			var ^CFood pxResi=cast<CFood>(m_xFood.GetObj());
			var ^CGameObj pxFood=m_xFood.GetObj();
			if(m_bObjFood)then
				if(pxFood==null||(pxResi!=null && (pxResi^.Inactive()||pxResi^.SkipThis())))then
					m_sState="search_for_job";
					return;
				endif;
				var vec3 vPos=pxFood^.GetPos();
				if(pxFood^.GetType()=="TREE"||pxFood^.GetType()=="WOOD"||pxFood^.GetType()=="FRUI")then
					vPos=GetAdoptedDest(pxAnimal^.GetPos(),vPos,pxAnimal^.GetAdaption());
				endif;
				m_vFeedPos=vPos;
			endif;
			m_sState="goto_food";
		endif;
	endproc;
	
	// Proc USLOnTick =======================================================
	proc void USLOnTick(int p_iTime)
//		var ^CAnimal pxAnimal=cast<CAnimal>(m_xAnimal.GetObj());
		var ^CFightingObj pxAnimal=cast<CFightingObj>(m_xAnimal.GetObj());
		if(pxAnimal==null)then
			EndTask();
			return;
		endif;
		if(pxAnimal^.HasFullHP())then
			pxAnimal^.SetHunting(false);
			EndTask();
			return;
		endif;
		if(m_xFood.IsValid() && m_xFood.GetObj()!=null)then
			var ^CAttribs pxFoAttribs=m_xFood.GetObj()^.GetAttribs();
			if(pxFoAttribs!=null)then
				m_bPlant=pxFoAttribs^.GetValueInt("Plant")==1;
				m_bMeat=pxFoAttribs^.GetValueInt("Meat")==1;
			endif;
		endif;
		var real fDmg=pxAnimal^.GetDmg();
		if(fDmg<=0.0f)then fDmg= 20.0f; endif;
		var real fJaw=pxAnimal^.GetJawSize();
		if(fJaw<=0.0f)then fJaw= 20.0f; endif;
		var ^CGameObj pxFood=m_xFood.GetObj();
		var ^CTree pxTree;
		var ^CWood pxLog;
		var bool bConvertedFakeTree=false;
		var vec3 vPosAnimal=pxAnimal^.GetPos();
		if(m_bTree)then
			CSrvWrap.GetForestMgr().Refresh(m_xForTree);
			if(m_xForTree.IsObject()&&m_xForTree.GetObjHandle().GetObj()!=null)then
				m_xCurTree=m_xForTree.GetObjHandle();
				bConvertedFakeTree=true;
			endif;
			begin CheckTree;
				var ^CGameObj pxTmp=m_xCurTree.GetObj();
				if(pxTmp!=null)then
					pxTree=cast<CTree>(pxTmp);
				endif;
			end CheckTree;
			begin CheckLog;
				var ^CGameObj pxTmp=m_xCurLog.GetObj();
				if(pxTmp!=null)then
					pxLog=cast<CWood>(pxTmp);
				endif;
			end CheckLog;
		elseif(m_bObjFood && pxFood==null)then
			m_bObjFood=false;
			m_sState="search_for_food";
			return;
		endif;
		if(m_sState=="goto_chop")then
			begin CheckTree;
				var ^CGameObj pxTmp=m_xCurTree.GetObj();
				if(pxTmp!=null)then
					pxTree=cast<CTree>(pxTmp);
				endif;
			end CheckTree;
			if(pxTree==null)then
				m_sState="search_for_food";
			else
				if((pxAnimal^.GetPos()-pxTree^.GetPos()).Abs()>10.0)then
					CSrvWrap.GetObjMgr()^.GetFreePos(m_vCurTarget,pxAnimal,pxTree^.GetPos());
					pxAnimal^.WalkAction(m_vCurTarget,pxAnimal^.GetMaxSpeed(),true);
				endif;
				m_sState="rotate_to_tree";
			endif;
		elseif(m_sState=="goto_chop_forest")then
			if(m_bWalkAction==true)then
				CheckWalkFail(pxAnimal^.GetPos(),"goto_chop_forest","search_for_food");
			else
				if(CSrvWrap.GetForestMgr().GetTreePos(m_xForTree, m_vJobPos)==true)then
					if((pxAnimal^.GetPos()-m_vJobPos).Abs()>10.0)then
						CSrvWrap.GetObjMgr()^.GetFreePos(m_vCurTarget,pxAnimal,m_vJobPos);
						m_vCurTarget=GetAdoptedDest(pxAnimal^.GetPos(),m_vJobPos,pxAnimal^.GetAdaption());
						pxAnimal^.WalkAction(m_vCurTarget,pxAnimal^.GetDefaultSpeed(),true);
						m_bWalkAction=true;
						m_vLastImportantPos=pxAnimal^.GetPos();
					endif;
					m_sState="rotate_to_tree_forest";
				else
					m_vJobPos=pxAnimal^.GetPos();
					m_sState="search_for_food";
				endif;
			endif;
		elseif(m_sState=="rotate_to_tree_forest"||m_sState=="rotate_to_tree")then
			if(!m_xForTree.IsValid()&&pxTree==null)then
				m_sState="search_for_food";
				return;
			endif;
			var real fTDistS=(vPosAnimal-m_vJobPos).Abs();
			if(fTDistS>15.0f)then
				m_sState="search_for_food";
				if(!AddFailedTarget())then
					EndTask();
					return;
				endif;
			else
				m_bWalkAction=false;
				var vec3 vDir=m_vJobPos-pxAnimal^.GetPos();
				var Quat qTRot;
				qTRot.FromXYDir(vDir.GetX(),vDir.GetY());
				pxAnimal^.RotateAction(qTRot);
				m_bFirstHit=true;
				if(m_sState=="rotate_to_tree_forest")then
					m_sState="chop_tree_forest";
				else
					m_sState="chop_tree";
					m_bFirstHit=true;
				endif;
			endif;
		elseif(m_sState=="chop_tree"||m_sState=="chop_tree_forest")then
			if(pxTree!=null)then //real tree
				var CGameTime xNow=CTimeMgr.Get().GetTime();
				pxAnimal^.DoChopAnim();
				if(m_bFirstHit)then
					m_bFirstHit=false;
				else
				endif;
				m_xLastTick=xNow;
				if(!pxTree^.Hit(fDmg/2.0f))then
					var CGameEvtPtr xEvt=CGameEvtPtr.CreateEvent("Bash");
					xEvt.SetBool(0,!bConvertedFakeTree);
					pxTree^.HandleEvent(xEvt);
				else
					var CGameEvtPtr xEvt=CGameEvtPtr.CreateEvent("Chop");
					pxTree^.HandleEvent(xEvt);
				endif;
			elseif(m_xForTree.IsFakeTree()&&m_xForTree.IsValid())then
				var CGameTime xNow=CTimeMgr.Get().GetTime();
				pxAnimal^.DoChopAnim();
				if(m_bFirstHit)then
					m_bFirstHit=false;
				else
				endif;
				m_xLastTick=xNow;
				var real fCurHitPoints=CSrvWrap.GetForestMgr().HitTree(m_xForTree, fDmg/2.0f);
				if(fCurHitPoints <= 0.0f)then
					CreateObjTree(m_xForTree);
				else
					Convert2ObjTree(m_xForTree);
				endif;
			else
				m_sState="search_for_food";
			endif;
		elseif(m_sState=="search_for_food")then
			var string sState=FindClosestFood(pxAnimal^.GetPos());
			if(sState=="end")then
				if(m_bHerbivore)then
					sState=FindForestTree(pxAnimal^.GetPos());
					if(sState=="end" && m_bCarnivore && pxAnimal^.IsHunting())then
						var bool bAni=FindFreshMeat(pxAnimal^.GetPos());
						EndTask();
						return;
					endif;
				elseif(m_bCarnivore && pxAnimal^.IsHunting())then
					var bool bAni=FindFreshMeat(pxAnimal^.GetPos());
					EndTask();
					return;
				endif;
			endif;
			if(sState=="end")then
				EndTask();
			endif;
			m_sState=sState;
			return;
		elseif(m_sState=="goto_food")then
			if(pxLog==null && m_bTree)then
				m_sState="search_for_food";
			else
				if(m_bTree)then
					m_vFeedPos=pxLog^.GetPos();
					m_vFeedPos=GetAdoptedDest(pxAnimal^.GetPos(),m_vFeedPos,2.0f);
				endif;
				pxAnimal^.WalkAction(m_vFeedPos, pxAnimal^.GetMaxSpeed());
				m_sState="check_pos";
			endif;
		elseif(m_sState=="check_pos")then
			var vec3 vOwnPos=pxAnimal^.GetPos();
			if((m_vFeedPos-vOwnPos).Abs2()>(5.0f*5.0f))then
				pxAnimal^.WaitAction(5.0f);
				m_sState="end";
			else
				if(m_bObjFood)then
					m_sState="rotate2food";
				else
					m_sState="feed";
					m_iFeedLoops=(Random.GetInt()%5)+10;
					m_iAnimLoops=(Random.GetInt()%8)+11;
				endif;
			endif;
		elseif(m_sState=="rotate2food")then
			pxAnimal^.Rotate2Obj(m_xFood);
			m_sState="feed";
			m_iFeedLoops=(Random.GetInt()%5)+10;
			m_iAnimLoops=(Random.GetInt()%8)+11;
		elseif(m_sState=="feed")then
			if(m_iAnimLoops<=0)then
				if(m_iFeedLoops<=0)then
					m_sState="end";
				else
					m_iFeedLoops--;
					Random.Seed();
					m_iAnimLoops=(Random.GetInt()%8)+3;
					m_bFirstHit=true;
					pxAnimal^.SetIdleAnim();
				endif;
			else
				m_iAnimLoops--;
				if(pxAnimal^.HasAnim(pxAnimal^.EatAnim()))then
					if(pxAnimal^.IsBugged())then
						pxAnimal^.AnimAction(pxAnimal^.EatAnim());
					else
						pxAnimal^.AnimAction(pxAnimal^.EatAnim(),1,m_bFirstHit,m_iAnimLoops==0);
					endif;
				endif;
				if(m_bFirstHit)then m_bFirstHit=false; endif;
				var real fFeededHitpoints=fJaw;
				var ^CResource pxResi=cast<CResource>(pxFood);
				//lets choose food type
				if(m_bPlant)then
					var ^CFruit_Food pxFruitObj=cast<CFruit_Food>(pxFood);
					var ^CWood pxWoodObj=cast<CWood>(pxFood);
					if(pxFruitObj!=null && !pxFruitObj^.Inactive())then
						fFeededHitpoints=pxFruitObj^.Mine(fJaw);
					elseif(pxWoodObj!=null)then
						fFeededHitpoints=pxWoodObj^.Mine(fJaw);
					endif;
				elseif(m_bMeat)then
					var ^CFishShoal pxFish=cast<CFishShoal>(pxFood);
					var ^CFood pxFoodObj=cast<CFood>(pxFood);
					if(pxFish!=null && !pxFish^.Inactive())then
						fFeededHitpoints=pxFish^.Mine(fJaw);
					elseif(pxFoodObj!=null)then
						fFeededHitpoints=pxFoodObj^.Mine(fJaw);
					endif;
				endif;
				if(pxResi!=null)then
					fFeededHitpoints*=pxResi^.FoodFactor();
				endif;
				fFeededHitpoints*=pxAnimal^.FeedFactor();
				pxAnimal^.AddHitpoints(fFeededHitpoints/2.0f);
			endif;
		elseif(m_sState=="end")then
			UpdateAggressionPos(m_xAnimal);
			EndTask();
			return;
		endif;
	endproc;
	
	export proc bool Break()
		if(m_xAnimal.IsValid())then
			m_xAnimal.GetObj()^.TerminateAction();
//			var ^CAnimal pxAnimal=cast<CAnimal>(m_xAnimal.GetObj());
			var ^CFightingObj pxAnimal=cast<CFightingObj>(m_xAnimal.GetObj());
			if(pxAnimal!=null)then
				pxAnimal^.SetHunting(false);
			endif;
			UpdateAggressionPos(m_xAnimal);
		endif;
		return true;
	endproc;
	
	export proc void EndTask()
		UpdateAggressionPos(m_xAnimal);
		super.EndTask();
	endproc;
	
endclass;
	
class CFrightening inherit CActionTask
	
	var CObjHndl m_xAnimal;
	var string m_sState;
	
	export constructor()
		SetName("Frightening");
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CFrightening] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xType="Frgh";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xAnimal.DoKArc(pxArc^);
		(pxArc^) << m_sState;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="Frgh")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xAnimal.DoKArc(pxArc^);
			(pxArc^) << m_sState;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool Init(CObjHndl p_xAnimal, string p_sPath)
		m_sState="start_anim";
		if(!p_xAnimal.IsValid())then
			m_sState="EndTask";
			return false;
		endif;
		m_xAnimal = p_xAnimal;
		SetSpecialActionPath(p_sPath);
		SetPrepareActionPath(m_xAnimal, p_sPath, true);
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		if(m_sState=="EndTask")then
			EndTask();
		endif;
	endproc;
	
	proc void USLOnTick(int p_iTime)
		var ^CAnimal pxAnimal = cast<CAnimal>(m_xAnimal.GetObj());
		if(pxAnimal==null)then EndTask(); return; endif;
		if(m_sState == "start_anim")then
			if(!StartSpecialActionTimer(pxAnimal))then
				EndTask();
				return;
			endif;
			pxAnimal^.MemorizeCurrentFightState(CObjHndl.Invalid(),false,false);
			pxAnimal^.AnimAction("sm_shake_off");
			m_sState = "calc_slow";
		elseif(m_sState == "calc_slow")then
			//calc
			var int iOwner = pxAnimal^.GetOwner();
			if(iOwner>=0)then
				var real fRange = 30.0;
				var CObjList xList;
				var ^CObjList pxEnemies=CSrvWrap.GetObjMgr()^.GetOwnerEnemyList(iOwner);
				if(pxEnemies==null)then return; endif;
				pxEnemies^.CopySorted(xList, pxAnimal^.GetPos(), fRange);
				var int i, iC = xList.NumEntries();
				for(i=0)cond(i<iC)iter(i++)do
					var ^CFightingObj pxFight = cast<CFightingObj>(xList[i].GetObj());
					if(pxFight!=null)then
						pxFight^.SetFrighteningEffect();
					endif;
				endfor;
			endif;
			m_sState = "finished";
		elseif(m_sState == "finished")then
			m_sState="EndTask";
			pxAnimal^.ReturnToFight();
		elseif(m_sState == "EndTask")then
			EndTask();
			return;
		endif;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
	endproc;
	
	export proc void EndTask()
		SetPrepareActionPath(m_xAnimal, GetSpecialActionPath(), false);
		super.EndTask();
	endproc;
	
	export proc bool Break()
		return false;
	endproc;
	
	export proc void Skip()
	endproc;
	
endclass;
	
class CLethalWound inherit CSpecialActionTask
	
	var CObjHndl							m_xActor;
	var CObjHndl							m_xTarget;
	var string								m_sState;
	
	export constructor()
		SetName("LethalWound");
		SetCivil(false);
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CLethalWound] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xType="LeWo";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xActor.DoKArc(pxArc^);
		m_xTarget.DoKArc(pxArc^);
		(pxArc^) << m_sState;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="LeWo")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xActor.DoKArc(pxArc^);
			m_xTarget.DoKArc(pxArc^);
			(pxArc^) << m_sState;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool Init(CObjHndl p_xActor, CObjHndl p_xTarget, string p_sPath)
		if(!p_xActor.IsValid()||!p_xTarget.IsValid())then
			m_sState="EndTask";
			return false;
		endif;
		m_sState="goto_target";
		SetSpecialActionPath(p_sPath);
		SetPrepareActionPath(p_xActor, p_sPath, true);
		m_xActor=p_xActor;
		m_xTarget=p_xTarget;
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		var ^CFightingObj pxFightingObj=cast<CFightingObj>(m_xActor.GetObj());
		var ^CFightingObj pxTarget=cast<CFightingObj>(m_xTarget.GetObj());
		if(pxFightingObj==null||pxTarget==null||!pxFightingObj^.CheckSpecialActionTimer(GetSpecialActionPath()))then
			EndTask();
			return;
		endif;
		if(m_sState=="EndTask")then
			EndTask();
		endif;
	endproc;
	
	proc void USLOnTick(int p_iTime)
		var ^CFightingObj pxActor=cast<CFightingObj>(m_xActor.GetObj());
		var ^CFightingObj pxTarget=cast<CFightingObj>(m_xTarget.GetObj());
		if(pxActor==null||pxTarget==null)then EndTask(); return; endif;
		if(m_sState=="goto_target")then
			var real fAttackRange=10.0;
			if(!IsInRange())then
				if(pxActor^.GetOnWall())then
					EndTask();
					return;
				endif;
				pxActor^.AdvanceAction(pxTarget^.GetHandle(),fAttackRange, pxActor^.GetMaxSpeed());
			endif;
			m_sState="check_pos";
			return;
		elseif(m_sState=="check_pos")then
			if(!IsInRange())then
				EndTask();
			else
				m_sState="rotate";
			endif;
		elseif(m_sState=="rotate")then
			var vec3 vDir=pxTarget^.GetPos()-pxActor^.GetPos();
			var Quat qTRot;
			qTRot.FromXYDir(vDir.GetX(),vDir.GetY());
			pxActor^.RotateAction(qTRot);
			m_sState="anim";
			return;
		elseif(m_sState=="anim")then
			pxActor^.AnimAction("attack_1");
			m_sState="injure";
		elseif(m_sState=="injure")then
			if(!StartSpecialActionTimer(pxActor))then
				EndTask();
				return;
			endif;
			SetUnStoppable(true);
			pxTarget^.WoundMortally(m_xActor, pxActor^.GetOwner(), pxActor^.GetLevel(), pxActor^.GetDmg());
			pxActor^.ReturnToFight();
			m_sState="EndTask";
			return;
		elseif(m_sState=="EndTask")then
			SetUnStoppable(false);
			EndTask();
			return;
		endif;
	endproc;
	
	proc bool IsInRange()
		var ^CFightingObj pxActor=cast<CFightingObj>(m_xActor.GetObj());
		var ^CGameObj pxTarget=m_xTarget.GetObj();
		if(pxActor==null||pxTarget==null)then return false; endif;
		var real fTargetRadius=pxTarget^.GetRadius();
		var real fSelfRadius=pxActor^.GetRadius();
		var real fAttackRange=10.0+fSelfRadius+fTargetRadius;
		var real fDistance=(pxTarget^.GetPos() - pxActor^.GetPos()).Abs2S();
		return fDistance <= fAttackRange*fAttackRange;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
	endproc;
	
	export proc bool Break()
		if(GetUnStoppable())then
			return false;
		endif;
		SetPrepareActionPath(m_xActor, GetSpecialActionPath(), false);
		if(m_xActor.IsValid())then
			m_xActor.GetObj()^.TerminateAction();
		endif;
		return true;
	endproc;
	
	export proc void Skip()
	endproc;
	
	export proc void EndTask()
		SetPrepareActionPath(m_xActor, GetSpecialActionPath(), false);
		UpdateAggressionPos(m_xActor);
		super.EndTask();
	endproc;
	
endclass;

class CPlunder inherit CSpecialActionTask
	
	var CObjHndl							m_xActor;
	var CObjHndl							m_xTarget;
	var string								m_sState;
	
	export constructor()
		SetName("Plunder");
		SetCivil(false);
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CPlunder] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xType="Plun";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xActor.DoKArc(pxArc^);
		m_xTarget.DoKArc(pxArc^);
		(pxArc^) << m_sState;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="Plun")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xActor.DoKArc(pxArc^);
			m_xTarget.DoKArc(pxArc^);
			(pxArc^) << m_sState;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool Init(CObjHndl p_xActor, CObjHndl p_xTarget, string p_sPath)
		if(!p_xActor.IsValid()||!p_xTarget.IsValid())then
			m_sState="EndTask";
			return false;
		endif;
		m_sState="goto_target";
		SetSpecialActionPath(p_sPath);
		SetPrepareActionPath(p_xActor, p_sPath, true);
		m_xActor=p_xActor;
		m_xTarget=p_xTarget;
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		var ^CFightingObj pxFightingObj=cast<CFightingObj>(m_xActor.GetObj());
		var ^CFightingObj pxTarget=cast<CFightingObj>(m_xTarget.GetObj());
		if(pxFightingObj==null||pxTarget==null||!pxFightingObj^.CheckSpecialActionTimer(GetSpecialActionPath()))then
			EndTask();
			return;
		endif;
		if(m_sState=="EndTask")then
			EndTask();
		endif;
	endproc;
	
	proc void USLOnTick(int p_iTime)
		var ^CFightingObj pxActor=cast<CFightingObj>(m_xActor.GetObj());
		var ^CFightingObj pxTarget=cast<CFightingObj>(m_xTarget.GetObj());
		if(pxActor==null||pxTarget==null)then EndTask(); return; endif;
//		if(pxTarget^.GetClassName()=="aje_brachiosaurus")then
//			var ^CAttribs pxAttr=pxTarget^.GetAttribs();
//			if(pxAttr!=null)then
//				if(pxAttr^.GetValue("ObjFlag")!="aje_brachiosaurus_mobile_camp")then
//					EndTask();
//					return;
//				endif;
//			endif;
//		endif;
		if(m_sState=="goto_target")then
			var real fAttackRange=5.0;
			if(!IsInRange())then
				if(pxActor^.GetOnWall())then
					EndTask();
					return;
				endif;
				pxActor^.AdvanceAction(pxTarget^.GetHandle(),fAttackRange, pxActor^.GetMaxSpeed());
			endif;
			m_sState="check_pos";
			return;
		elseif(m_sState=="check_pos")then
			if(!IsInRange())then
				EndTask();
			else
				m_sState="rotate";
			endif;
		elseif(m_sState=="rotate")then
			var vec3 vDir=pxTarget^.GetPos()-pxActor^.GetPos();
			var Quat qTRot;
			qTRot.FromXYDir(vDir.GetX(),vDir.GetY());
			pxActor^.RotateAction(qTRot);
			m_sState="plunder";
		elseif(m_sState=="plunder")then
			if(!StartSpecialActionTimer(pxActor))then
				EndTask();
				return;
			endif;
			SetUnStoppable(true);
			pxActor^.DoTaskAnim("plunder");
			var bool bStream=true;
			pxTarget^.StealResis(pxActor^.GetOwner(),m_xActor,bStream);
			begin TreasureStealing;
				var ^CInventory pxInv=pxActor^.GetInventory(), pxEnemyInv=pxTarget^.GetInventory();
				if(pxInv!=null&&pxEnemyInv!=null&&!pxInv^.IsFull()&&pxEnemyInv^.Count()>0)then
					var int i, iC=pxEnemyInv^.Count();
					var CObjList xList;
					for(i=0)cond(i<iC)iter(++i)do
						if(!pxEnemyInv^.GetItem(i).IsValid())then continue; endif;
						xList.Include(pxEnemyInv^.GetItem(i));
					endfor;
					iC=xList.NumEntries();
					for(i=0)cond(i<iC)iter(i++)do
						if(xList[i].IsValid())then
							var ^CGameObj pxItem=xList[i].GetObj();
							var ^CItem pxI=cast<CItem>(pxItem);
							if(pxI!=null&&!pxInv^.IsFull())then
								pxTarget^.LoseItem(pxI^.GetHandle());
								pxActor^.StealItem(pxI^.GetHandle());
							endif;
						endif;
					endfor;
				endif;
			end TreasureStealing;
			var ^CBasePlayer pxEnemy=CBasePlayer.GetPlayer(pxTarget^.GetOwner());
			if(pxEnemy!=null&&bStream)then
				pxEnemy^.IWasAttacked(m_xTarget,m_xActor,false);
			endif;
			if(pxTarget^.GetClassName().Find("_worker")!=-1)then
				pxTarget^.CouldBeStolen(pxActor);
			endif;
			m_sState="EndTask";
			return;
		elseif(m_sState=="EndTask")then
			SetUnStoppable(false);
			EndTask();
			return;
		endif;
	endproc;
	
	proc bool IsInRange()
		var ^CFightingObj pxActor=cast<CFightingObj>(m_xActor.GetObj());
		var ^CGameObj pxTarget=m_xTarget.GetObj();
		if(pxActor==null||pxTarget==null)then return false; endif;
		var real fTargetRadius=pxTarget^.GetRadius();
		var real fSelfRadius=pxActor^.GetRadius();
		var real fAttackRange=5.0+fSelfRadius+fTargetRadius;
		var real fDistance=(pxTarget^.GetPos() - pxActor^.GetPos()).Abs2S();
		return fDistance <= fAttackRange*fAttackRange;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
	endproc;
	
	export proc bool Break()
		if(GetUnStoppable())then
			return false;
		endif;
		SetPrepareActionPath(m_xActor, GetSpecialActionPath(), false);
		if(m_xActor.IsValid())then
			m_xActor.GetObj()^.TerminateAction();
		endif;
		return true;
	endproc;
	
	export proc void Skip()
	endproc;
	
	export proc void EndTask()
		SetPrepareActionPath(m_xActor, GetSpecialActionPath(), false);
		UpdateAggressionPos(m_xActor);
		super.EndTask();
	endproc;
	
endclass;
	
class CSongOfValor inherit CActionTask
	
	var CObjHndl m_xAnimal;
	var string m_sState;
	
	export constructor()
		SetName("SongOfValor");
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CSongOfValor] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xType="SSoV";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xAnimal.DoKArc(pxArc^);
		(pxArc^) << m_sState;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="SSoV")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xAnimal.DoKArc(pxArc^);
			(pxArc^) << m_sState;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool Init(CObjHndl p_xAnimal, string p_sPath)
		m_sState="start_anim";
		if(!p_xAnimal.IsValid())then
			m_sState="EndTask";
			return false;
		endif;
		m_xAnimal = p_xAnimal;
		SetSpecialActionPath(p_sPath);
		SetPrepareActionPath(p_xAnimal, p_sPath, true);
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		if(m_sState=="EndTask")then
			EndTask();
		endif;
	endproc;
	
	proc void USLOnTick(int p_iTime)
		var ^CParasaurolophus pxAnimal = cast<CParasaurolophus>(m_xAnimal.GetObj());
		if(pxAnimal==null)then EndTask(); return; endif;
		if(m_sState == "start_anim")then
			if(!StartSpecialActionTimer(pxAnimal))then
				m_sState=="EndTask";
				EndTask();
				return;
			endif;
			pxAnimal^.DrumAnim(3);
			pxAnimal^.AnimAction("menace");
			m_sState = "calc_dope";
		elseif(m_sState == "calc_dope")then
			pxAnimal^.DrumAnim(1);
			//calc
			var int iOwner=pxAnimal^.GetOwner();
			var real fZone=30.0f;
			if(iOwner>=0)then
				var CObjQuery xQuery;
				xQuery.SetType("ANML", false);
				xQuery.SetType("CHTR", true);
				xQuery.SetType("VHCL", true);
				xQuery.SetOwner(iOwner);
				CSrvWrap.GetDiplomacyMgr().AddMyFriendsToSearch(iOwner, xQuery);
				xQuery.RegionCircle(pxAnimal^.GetPos(), fZone);
				var CObjList xList;
				xQuery.Execute(xList);
				var int i, iC=xList.NumEntries();
				for(i=0)cond(i<iC)iter(++i)do
					var ^CFightingObj pxF=cast<CFightingObj>(xList[i].GetObj());
					if(pxF!=null)then
						pxF^.SetValorEffect(10.0f);
					endif;
				endfor;
			endif;
			m_sState="EndTask";
		elseif(m_sState == "EndTask")then
			EndTask();
			return;
		endif;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
	endproc;
	
	export proc void EndTask()
		SetPrepareActionPath(m_xAnimal, GetSpecialActionPath(), false);
		super.EndTask();
	endproc;
	
	export proc bool Break()
		return false;
	endproc;
	
	export proc void Skip()
	endproc;
	
endclass;
	
class CTriceratopsHook inherit CSpecialActionTask
	
	var CObjHndl m_xActor;
	var CObjHndl m_xTarget;
	var string m_sState;
	
	export constructor()
		SetName("TricHook");
		SetCivil(false);
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CTriceratopsHook] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xType="TrHo";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xActor.DoKArc(pxArc^);
		m_xTarget.DoKArc(pxArc^);
		(pxArc^) << m_sState;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="TrHo")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xActor.DoKArc(pxArc^);
			m_xTarget.DoKArc(pxArc^);
			(pxArc^) << m_sState;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;	
	
	export proc bool Init(CObjHndl p_xActor, CObjHndl p_xTarget, string p_sPath)
		m_sState="start_anim";
		if(!p_xActor.IsValid()||!p_xTarget.IsValid())then
			m_sState="EndTask";
			return false;
		endif;
		m_xActor=p_xActor;
		m_xTarget=p_xTarget;
		SetSpecialActionPath(p_sPath);
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		if(m_sState=="EndTask")then
			EndTask();
		endif;
		var ^CFightingObj pxFighter=cast<CFightingObj>(m_xActor.GetObj());
		if(pxFighter==null||!pxFighter^.CheckSpecialActionTimer(GetSpecialActionPath()))then
			EndTask();
			return;
		endif;
		var ^CFightingObj pxTarget=cast<CFightingObj>(m_xTarget.GetObj());
		if(pxTarget==null)then
			EndTask();
			return;
		endif;
		var bool bInvalid;
		var CObjHndl xInvalid;
		if(!pxFighter^.IsInCombatRange(pxTarget,false))then
			EndTask();
			return;
		endif;
	endproc;
	
	proc void USLOnTick(int p_iTime)
//		var ^CSeasTriceratops pxActor=cast<CSeasTriceratops>(m_xActor.GetObj());
		var ^CTriceratops pxActor=cast<CTriceratops>(m_xActor.GetObj());
		if(pxActor==null)then EndTask(); return; endif;
		if(m_sState=="start_anim")then
			if(!StartSpecialActionTimer(pxActor))then EndTask();return;endif;
			SetUnStoppable(true);
			pxActor^.MemorizeCurrentFightState(m_xTarget,false,false);
			pxActor^.AnimAction("pawing");
			//pxActor^.AnimAction("sm_shake_off");
			var int iOwner=pxActor^.GetOwner();
			if(iOwner>=0)then
				var ^CFightingObj pxFight=cast<CFightingObj>(m_xTarget.GetObj());
				if(pxFight==null)then EndTask(); return; endif;
				if(pxFight^.GetOnWall())then EndTask(); return; endif;
				pxFight^.ClearDamageCache();
				pxFight^.TakeDmg(pxActor, false, 3.0, pxActor^.GetHitDelay(), 100.0);
				pxFight^.ClearDamageCache();
				var ^CCharacter pxChar=cast<CCharacter>(pxFight);
				if(pxChar!=null && !pxChar^.GetTransportObj().IsValid())then
					var vec3 vDir=(pxChar^.GetPos() - pxActor^.GetPos());
					vDir.Normalize();
					vDir.SetZ(vDir.GetZ()+0.5);
					vDir.Normalize();
					pxChar^.SetHitReactionTimer(0.7,vDir*(10.0f));
				endif;
			endif;
			m_sState="finished";
		elseif(m_sState=="finished")then
			m_sState="EndTask";
			SetUnStoppable(false);
			pxActor^.ReturnToFight();
		elseif(m_sState=="EndTask")then
			EndTask();
			return;
		endif;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
	endproc;
	
	export proc bool Break()
		return false;
	endproc;
	
	export proc void Skip()
	endproc;
	
endclass;
	
class CWalkingBomb inherit CSpecialActionTask
	
	//BadGun Tuning: SEAS Sacrifice
	const real				RANGE=3.0;
	const real				EQUIP_ANIMDELAY=1.0;
	
	var CObjHndl			m_xActor;
	var CObjHndl			m_xTarget;
	var string				m_sState;
	var int						m_iRetryCounter;
	var CGameTime			m_xStart;
	var real					m_fAnimLength;
	
	export constructor()
		SetName("WalkingBomb");
		SetCivil(false);
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CWalkingBomb] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xType="WaBo";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xActor.DoKArc(pxArc^);
		m_xTarget.DoKArc(pxArc^);
		m_xStart.DoKArc(pxArc^);
		(pxArc^) << m_sState;
		(pxArc^) << m_iRetryCounter;
		(pxArc^) << m_fAnimLength;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="WaBo")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xActor.DoKArc(pxArc^);
			m_xTarget.DoKArc(pxArc^);
			m_xStart.DoKArc(pxArc^);
			(pxArc^) << m_sState;
			(pxArc^) << m_iRetryCounter;
			(pxArc^) << m_fAnimLength;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool Init(CObjHndl p_xActor, CObjHndl p_xTarget, string p_sPath)
		m_sState="EndTask";
		if(!p_xActor.IsValid()||!p_xTarget.IsValid())then
			return false;
		endif;
		var ^CFightingObj pxTarget=cast<CFightingObj>(p_xTarget.GetObj());
		if(pxTarget==null)then
			return false;
		endif;
		if(pxTarget^.GetType()!="ANML" && pxTarget^.GetType()!="CHTR" && pxTarget^.GetType()!="VHCL" && pxTarget^.GetType()!="SHIP")then
			return false;
		endif;
		if(pxTarget^.GetOwner()!=p_xActor.GetObj()^.GetOwner())then
			return false;
		endif;
		m_sState="goto_target";
		m_xActor=p_xActor;
		m_xTarget=p_xTarget;
		SetSpecialActionPath(p_sPath);
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		var ^CFightingObj pxFightingObj=cast<CFightingObj>(m_xActor.GetObj());
		if(pxFightingObj==null||!pxFightingObj^.CheckSpecialActionTimer(GetSpecialActionPath()))then
			EndTask();
			return;
		endif;
		if(m_sState=="EndTask")then
			EndTask();
		endif;
	endproc;
	
	proc void USLOnTick(int p_iTime)
		var ^CCharacter pxActor=cast<CCharacter>(m_xActor.GetObj());
		var ^CFightingObj pxTarget=cast<CFightingObj>(m_xTarget.GetObj());
		if(pxActor==null)then EndTask(); return; endif;
		if(pxTarget==null)then EndTask(); return; endif;
		if(m_sState=="goto_target")then
			var bool bInvalid;
			var CObjHndl xInvalid;
			if(!pxActor^.IsInCombatRange(pxTarget, bInvalid, xInvalid, RANGE))then
				if(pxActor^.GetOnWall())then
					EndTask();
					return;
				endif;
				pxActor^.AdvanceAction(pxTarget^.GetHandle(),RANGE,pxActor^.GetDefaultSpeed());
			endif;
			m_sState="rotate";
		elseif(m_sState=="rotate")then
			var bool bInvalid;
			var CObjHndl xInvalid;
			if(!pxActor^.IsInCombatRange(pxTarget, bInvalid, xInvalid, RANGE))then
				if(m_iRetryCounter>3)then
					EndTask();
					return;
				else
					m_iRetryCounter++;
					m_sState="goto_target";
					return;
				endif;
			endif;
			var vec3 vDir=pxTarget^.GetPos()-pxActor^.GetPos();
			var Quat qTRot;
			qTRot.FromXYDir(vDir.GetX(),vDir.GetY());
			pxActor^.RotateAction(qTRot);
			m_sState="equip_explosives";
			if(!StartSpecialActionTimer(pxActor))then EndTask();return;endif;
			SetUnStoppable(true);
			return;
		elseif(m_sState=="equip_explosives")then
			m_xStart=CTimeMgr.Get().GetTime();
			pxActor^.EquipTargetWithExplosives();
			m_sState="last_job";
		elseif(m_sState=="last_job")then
			if((CTimeMgr.Get().GetTime()-m_xStart).GetSecondsF()<EQUIP_ANIMDELAY)then
				return;
			endif;
//			pxActor^.ResetCaptain();
			pxActor^.ShowWeapons();
			var CObjHndl xSacrificer=CObjHndl.Invalid();
			if(xSacrificer.IsValid())then
				xSacrificer=m_xActor;
			endif;
			pxTarget^.DarkRitual(10.0, xSacrificer);
			m_sState="finished";
		elseif(m_sState=="finished")then
			SetUnStoppable(false);
			m_sState="EndTask";
//			pxActor^.ReturnToFight();
			return;
		elseif(m_sState=="EndTask")then
			EndTask();
			return;
		endif;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
		var ^CFightingObj pxFighter=cast<CFightingObj>(m_xActor.GetObj());
		if(pxFighter!=null)then
			pxFighter^.ShowWeapons();
		endif;
	endproc;
	
	export proc bool Break()
		if(GetUnStoppable())then
			return false;
		endif;
		if(m_xActor.IsValid())then
			m_xActor.GetObj()^.TerminateAction();
		endif;
		return true;
	endproc;
	
	export proc void Skip()
	endproc;
	
	export proc void EndTask()
		UpdateAggressionPos(m_xActor);
		super.EndTask();
	endproc;
	
endclass;
	
	//========================================================================================
	//=== Buildings Specials =================================================================
	//========================================================================================
	
class CAutomaticHarvest inherit CTask
	
	var CObjHndl m_xHarvestSite;
	var string m_sResource;
	var string m_sState;
	var int m_iAnim;
	
	export constructor()
		SetName("AutomaticHarvest");
		m_iAnim=1;
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CAutomaticHarvest] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xType="AuHa";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xHarvestSite.DoKArc(pxArc^);
		(pxArc^) << m_sState;
		(pxArc^) << m_sResource;
		(pxArc^) << m_iAnim;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="AuHa")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xHarvestSite.DoKArc(pxArc^);
			(pxArc^) << m_sState;
			(pxArc^) << m_sResource;
			(pxArc^) << m_iAnim;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool Init(CObjHndl p_xBuilding)
		m_xHarvestSite=p_xBuilding;
		var ^CUnlimitedBuilding pxBuilding = cast<CUnlimitedBuilding>(m_xHarvestSite.GetObj());
		if(pxBuilding==null)then
			m_sState="exit";
			return false;
		elseif(!pxBuilding^.GetAutomatized())then
			m_sState="exit";
			return false;
		endif;
		m_sResource="food";
		m_sState="start_harvest";
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom,^CState p_pxTo)
		if(!m_xHarvestSite.IsValid()||m_sState=="exit")then
			EndTask();
			return;
		endif;
		var ^CGrowingField pxCornfield = cast<CGrowingField>(m_xHarvestSite.GetObj());
		if(pxCornfield!=null)then
			if(!pxCornfield^.GetAutomatized())then
				EndTask();
				return;
			endif;
		else
			EndTask();
			return;
		endif;
	endproc;
	
	proc void USLOnTick(int p_iTime)
		if(!m_xHarvestSite.IsValid())then EndTask(); return; endif;
		var ^CGrowingField pxCornfield=cast<CGrowingField>(m_xHarvestSite.GetObj());
		if(pxCornfield==null)then EndTask(); return; endif;
		if(pxCornfield^.CurResInvIsFull()&&m_sState!="drop_resis")then
			m_sState="drop_resis";
		elseif(!pxCornfield^.CurResInvIsFull()&&m_sState=="drop_resis")then
			m_sState="start_harvest";
		endif;
		if(m_sState=="start_harvest")then
			pxCornfield^.CurResInvAdd();
			pxCornfield^.AnimAction("work_"+m_iAnim.ToString());
			if(m_iAnim==1)then
				m_iAnim=2;
			elseif(m_iAnim==2)then
				m_iAnim=1;
			endif;
			m_sState="drop_resis";
			return;
		elseif(m_sState=="drop_resis")then
			if(pxCornfield^.CheckCurResCapacity())then
				m_sState="start_harvest";
			else
				pxCornfield^.SetAnim("idle",3);
				pxCornfield^.WaitAction(2.0f); //wait 2 secs for free checkin
			endif;
			return;
		elseif(m_sState=="exit")then
			EndTask();
			return();
		else
			EndTask();
		endif;
	endproc;
	
endclass;
	
class CSeasWellHeal inherit CTargetTask
	
	const int STATE_WALKTO	= 1;
	const int STATE_ARRIVED	= 2;
	const int STATE_WAIT		= 3;
	const int STATE_CHECK		= 4;
	const int STATE_BREAK		= 5;
	
	var CObjHndl		m_xActor;
	var CObjHndl		m_xTarget;
	var int 				m_iState;
	
	export constructor()
		SetName("SWHeal");
		SetCivil(true);
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CSeasWellHeal] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xType="SWHe";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xActor.DoKArc(pxArc^);
		m_xTarget.DoKArc(pxArc^);
		pxArc^ << m_iState;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="SWHe")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xActor.DoKArc(pxArc^);
			m_xTarget.DoKArc(pxArc^);
			pxArc^ << m_iState;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool Init(CObjHndl p_xActor, CObjHndl p_xTarget)
		if(!p_xActor.IsValid()||!p_xTarget.IsValid())then
			m_iState=STATE_BREAK;
			return false;
		endif;
		m_xActor=p_xActor;
		m_xTarget=p_xTarget;
		m_iState =STATE_WALKTO;
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		SetMaxCounter(5);
	endproc;
	
	proc void USLOnTick(int p_iTime)
		if(m_iState==STATE_WALKTO)then
			var ^CSeasWell pxDruidwell=cast<CSeasWell>(m_xTarget.GetObj());
			var ^CFightingObj pxFO=cast<CFightingObj>(m_xActor.GetObj());
			if(pxDruidwell==null||pxFO==null)then EndTask(); return; endif;
			var vec3 vDest=pxDruidwell^.GetPos();
			SetCurrentTarget(vDest);
			var vec3 vTmp=pxFO^.GetPos();
			if(pxFO^.IsFlyingUnit())then
				vTmp.SetZ(pxDruidwell^.GetPos().GetZ());
			endif;
			if(!IsAlreadyAtTargetPos(vTmp, pxFO^.GetRadius()+7.0f))then
				if(pxFO^.IsFlyingUnit())then
					pxFO^.WalkAction(vDest,pxFO^.GetMaxSpeed());
				else
					CSrvWrap.GetObjMgr()^.GetFreePos(vDest, pxFO, vDest);
					var CGameObj.CAdvanceActionParams xAWAP;
					xAWAP.m_fMinDistance=3.0f;
					xAWAP.m_iPrefSpeed=pxFO^.GetMaxSpeed();
					pxFO^.AdvanceAction(m_xTarget,xAWAP);
				endif;
				m_iState=STATE_CHECK;
			else
				m_iState=STATE_ARRIVED;
				USLOnTick(0);
				return;
			endif;
		elseif(m_iState==STATE_CHECK)then
			var ^CSeasWell pxDruidwell=cast<CSeasWell>(m_xTarget.GetObj());
			var ^CFightingObj pxFO=cast<CFightingObj>(m_xActor.GetObj());
			if(pxDruidwell==null||pxFO==null)then EndTask(); return; endif;
			var vec3 vTmp=pxFO^.GetPos();
			if(pxFO^.IsFlyingUnit())then
				vTmp.SetZ(pxDruidwell^.GetPos().GetZ());
			endif;
			if(!HasArrivedTarget(vTmp,pxFO^.GetRadius()+7.0f))then
				if(!CanFollow())then
					ResetCounter();
					m_iState=STATE_BREAK;
					return;
				else
					m_iState=STATE_WALKTO;
					return;
				endif;
			else
				m_iState=STATE_ARRIVED;
			endif;
		elseif(m_iState==STATE_ARRIVED)then
			var ^CSeasWell pxDruidwell=cast<CSeasWell>(m_xTarget.GetObj());
			if(pxDruidwell==null)then EndTask(); return; endif;
			var ^CFightingObj pxFO=cast<CFightingObj>(m_xActor.GetObj());
			if(pxFO==null)then EndTask(); return; endif;
			pxDruidwell^.ObjArrived(m_xActor);
			EndTask();
		elseif(m_iState==STATE_BREAK)then
			EndTask();
		endif;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
	endproc;
	
	export proc bool Break()
		return true;
	endproc;
	
	export proc void Skip()
	endproc;
	
	export proc void EndTask()
		UpdateAggressionPos(m_xActor);
		super.EndTask();
	endproc;
	
endclass;
	
	//========================================================================================
	//=== Character Specials =================================================================
	//========================================================================================
	
class CBlindingStorm inherit CSpecialActionTask
	
	var CObjHndl							m_xCharacter;
	var vec3									m_vTarget;
	var string								m_sState;
	
	export constructor()
		SetName("BlindingStorm");
		SetCivil(false);
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CBlindingStorm] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xType="BlSt";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xCharacter.DoKArc(pxArc^);
		(pxArc^) << m_vTarget;
		(pxArc^) << m_sState;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="BlSt")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xCharacter.DoKArc(pxArc^);
			(pxArc^) << m_vTarget;
			(pxArc^) << m_sState;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool Init(CObjHndl p_xCharacter,vec3 p_vTarget, string p_sPath)
		m_sState="goto_target";
		if(!p_xCharacter.IsValid()||p_vTarget=={0.0,0.0,0.0})then
			m_sState="EndTask";
			return false;
		endif;
		SetSpecialActionPath(p_sPath);
		SetPrepareActionPath(p_xCharacter, p_sPath, true);
		m_xCharacter=p_xCharacter;
		m_vTarget=p_vTarget;
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		var ^CFightingObj pxFightingObj=cast<CFightingObj>(m_xCharacter.GetObj());
		if(pxFightingObj==null||!pxFightingObj^.CheckSpecialActionTimer(GetSpecialActionPath()))then
			EndTask();
			return;
		endif;
		if(m_sState=="EndTask")then
			EndTask();
		endif;
	endproc;
	
	proc void USLOnTick(int p_iTime)
		var ^CCharacter pxCharacter=cast<CCharacter>(m_xCharacter.GetObj());
		if(pxCharacter==null||m_vTarget=={0.0,0.0,0.0})then EndTask(); return; endif;
		if(m_sState=="goto_target")then
			var real fAttackRange=CSandStorm.STORM_RADIUS;
			fAttackRange+=pxCharacter^.GetMiscValueTT("Shaman_Cast_Storm");
			if(!IsInRange())then
				if(pxCharacter^.GetOnWall())then
					EndTask();
					return;
				endif;
				pxCharacter^.AdvanceAction(CObjHndl.Invalid(),fAttackRange,pxCharacter^.GetMaxSpeed(),pxCharacter^.GetWalkSet(),5000000.0, pxCharacter^.GetPos(), m_vTarget);
			endif;
			m_sState="check_pos";
			return;
	
		elseif(m_sState=="check_pos")then
			if(!IsInRange())then
				EndTask();
			else
				m_sState="summon";
			endif;
	
		elseif(m_sState=="summon")then
			if(!StartSpecialActionTimer(pxCharacter))then
				EndTask();
				return;
			endif;
			SetUnStoppable(true);
			pxCharacter^.SetAnim("thanking",1);
			var int iOwner=-1;
			var vec3 vSpawn=m_vTarget;
			if(pxCharacter!=null)then
				iOwner=pxCharacter^.GetOwner();
			endif;
			var ^CSandStorm pxStorm=cast<CSandStorm>(CSrvWrap.GetObjMgr()^.CreateObj("blinding_cloud",iOwner,vSpawn));
			m_sState="EndTask";
			return;
	
		elseif(m_sState=="EndTask")then
			SetUnStoppable(false);
			EndTask();
			return;
		endif;
	endproc;
	
	proc bool IsInRange()
		var ^CCharacter pxCharacter=cast<CCharacter>(m_xCharacter.GetObj());
		if(pxCharacter==null)then return false; endif;
		var real fSelfRadius=pxCharacter^.GetRadius();
		var real fAttackRange=CSandStorm.STORM_RADIUS+1.0+fSelfRadius;
		fAttackRange+=pxCharacter^.GetMiscValueTT("Shaman_Cast_Storm");
		var real fDistance=(m_vTarget - pxCharacter^.GetPos()).Abs2S();
		return fDistance <= fAttackRange*fAttackRange;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
	endproc;
	
	export proc bool Break()
		if(GetUnStoppable())then
			return false;
		endif;
		SetPrepareActionPath(m_xCharacter, GetSpecialActionPath(), false);
		if(m_xCharacter.IsValid())then
			m_xCharacter.GetObj()^.TerminateAction();
		endif;
		return true;
	endproc;
	
	export proc void Skip()
	endproc;
	
	export proc void EndTask()
		SetPrepareActionPath(m_xCharacter, GetSpecialActionPath(), false);
		UpdateAggressionPos(m_xCharacter);
		super.EndTask();
	endproc;
	
endclass;
	
class CBuildStaircase inherit CTask
	
	var CObjHndl	m_xWorker;		///< worker, who build the sc.
	var CObjHndl	m_xDockSite;	///< wall to build staircase to
	var string		m_sState;
	var vec3			m_vBuildPos;
	var vec3			m_vCurDest;
	var int				m_iFindCnt;
	var int				m_iCommandID;
	
	export constructor()
		SetName("BuildUp");
		m_iCommandID=-1;
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CBuildStaircase] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xType="BuSc";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xWorker.DoKArc(pxArc^);
		m_xDockSite.DoKArc(pxArc^);
		(pxArc^) << m_sState;
		(pxArc^) << m_vBuildPos;
		(pxArc^) << m_vCurDest;
		(pxArc^) << m_iFindCnt;
		(pxArc^) << m_iCommandID;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="BuSc")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xWorker.DoKArc(pxArc^);
			m_xDockSite.DoKArc(pxArc^);
			(pxArc^) << m_sState;
			(pxArc^) << m_vBuildPos;
			(pxArc^) << m_vCurDest;
			(pxArc^) << m_iFindCnt;
			(pxArc^) << m_iCommandID;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool Init(CObjHndl p_xWorker,CObjHndl p_xDocksite)
		if(!p_xWorker.IsValid()||!p_xDocksite.IsValid())then return false; endif;
		m_xWorker = p_xWorker;
		m_xDockSite = p_xDocksite;
		m_sState="find_pos";
		return true;
	endproc;
	
	proc void USLOnTick(int p_iTime)
		var ^CWall pxWall=cast<CWall>(m_xDockSite.GetObj());
		var ^CFightingObj pxWorker=cast<CFightingObj>(m_xWorker.GetObj());
		if((pxWall==null)||(pxWorker==null))then EndTask(); return; endif;
		var ^CGameObj pxS=CSrvWrap.GetPathfinder().GetWallSiege(pxWall);
		if(pxS!=null)then
			EndTask();
			return;
		endif;
		if(m_sState=="find_pos")then
			m_iCommandID=pxWorker^.GetOwner();
			m_vBuildPos=pxWall^.GetPos();
			CSrvWrap.GetObjMgr()^.GetObjPlaceChecker()^.GetWallMap()^.GetFreeDockPos(m_iCommandID,m_vBuildPos,pxWorker^.GetPos());
			m_vCurDest=m_vBuildPos;
			CSrvWrap.GetObjMgr()^.GetFreePos(m_vCurDest,pxWorker,m_vCurDest);
			m_iFindCnt++;
			m_sState="goto_wall";
		elseif(m_sState=="goto_wall")then
			if(pxWorker^.GetOnWall())then
				pxWorker^.WallWalkAction(m_vCurDest,true,pxWorker^.GetMaxSpeed(),false);
			else
				pxWorker^.WalkAction(m_vCurDest,pxWorker^.GetMaxSpeed());
			endif;
			m_sState="place_staircase";
		elseif(m_sState=="place_staircase")then
			if((m_vCurDest-pxWorker^.GetPos()).Abs2()>2.0f)then
				if(m_iFindCnt>4)then
					EndTask();
					return;
				else
					m_sState="find_pos";
				endif;
			else
				var ^CGameObj pxStaircase=CSeasStaircase.GetStaircaseBuildUp(m_iCommandID,m_xDockSite).GetObj();
				if(pxStaircase!=null)then
					pxWorker^.HandleGamePlayCommand("Q_Build",pxStaircase,pxStaircase^.GetPos(),"");
				else
					var vec3 vBuildPos=m_vBuildPos;
					var CObjList xWorker;
					xWorker.Include(pxWorker^.GetHandle());
					var vec3 vTmpDir=vBuildPos-pxWall^.GetPos();
					var real fDist= vTmpDir.Abs();
					vTmpDir.Normalize();
					vBuildPos=pxWall^.GetPos()+(vTmpDir * (fDist-4.5f));
					var real fHeight=CSrvWrap.GetScapeMgr().GetHeight(vBuildPos.GetX(), vBuildPos.GetY());
//					var real fHeight=vBuildPos.GetZ()-1.2f;
					vBuildPos.SetZ(fHeight);
					pxStaircase=CPlaceMgr.Get().PlaceObj(m_iCommandID,"seas_staircase",vBuildPos,{0.0,0.0,0.0},xWorker,true,true).GetObj();
					if(pxStaircase!=null)then
						CSeasStaircase.RegisterStaircaseBuildUp(m_iCommandID,pxStaircase^.GetHandle(),m_xDockSite);
						var vec3 vDir=pxWall^.GetPos()-m_vBuildPos;
						vDir.SetZ(0.0f);
						var Quat qRot;
						qRot.FromXYDir(vDir.GetX(),vDir.GetY());
						var ^CSeasStaircase pxSc = cast<CSeasStaircase>(pxStaircase);
						if(pxSc!=null)then
							pxSc^.SetExtRot(qRot);
							if(pxWall!=null)then
								pxWall^.SetDockerObj(pxStaircase^.GetHandle());
							endif;
							pxSc^.GetDockInfo().SetDocked(true, pxWall^.GetHandle());
						endif;
					endif;
				endif;
				EndTask();
				return;
			endif;
		endif;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
		if(p_pxTo!=GetParent())then return; endif;
	endproc;
	
endclass;
	
class CClimbStaircase inherit CTargetTask
	
	var CObjHndl	m_xWorker;
	var CObjHndl	m_xStaircase;
	var bool			m_bClimbUp;
	var bool			m_bClimbForward;
	var bool			m_bJumpOff;
	var string		m_sState;
	var vec3			m_vEntry;
	var vec3			m_vExit;
	var vec3			m_vPos1;
	var vec3			m_vPos2;
	var vec3			m_vPos3;
	var vec3			m_vPos4;
	var vec3			m_vPos5;
	var vec3			m_vJump;
	var bool			m_bUnStoppable;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CClimbStaircase] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xType="ClSc";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xWorker.DoKArc(pxArc^);
		m_xStaircase.DoKArc(pxArc^);
		(pxArc^) << m_bClimbUp;
		(pxArc^) << m_sState;
		(pxArc^) << m_bClimbForward;
		(pxArc^) << m_vEntry;
		(pxArc^) << m_vPos1;
		(pxArc^) << m_vPos2;
		(pxArc^) << m_vPos3;
		(pxArc^) << m_vPos4;
		(pxArc^) << m_vPos5;
		(pxArc^) << m_vJump;
		(pxArc^) << m_vExit;
		(pxArc^) << m_bJumpOff;
		(pxArc^) << m_bUnStoppable;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="ClSc")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xWorker.DoKArc(pxArc^);
			m_xStaircase.DoKArc(pxArc^);
			(pxArc^) << m_bClimbUp;
			(pxArc^) << m_sState;
			(pxArc^) << m_bClimbForward;
			(pxArc^) << m_vEntry;
			(pxArc^) << m_vPos1;
			(pxArc^) << m_vPos2;
			(pxArc^) << m_vPos3;
			(pxArc^) << m_vPos4;
			(pxArc^) << m_vPos5;
			(pxArc^) << m_vJump;
			(pxArc^) << m_vExit;
			(pxArc^) << m_bJumpOff;
			(pxArc^) << m_bUnStoppable;
//			if(pxArc^.GetVersion()>=2)then
//			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export constructor()
		m_bUnStoppable = false;
		SetName("ClimbStaircase");
	endconstructor;
	
	export proc bool GetUnStoppable()
		return m_bUnStoppable;
	endproc;
	
	export proc void SetUnStoppable(bool p_bValue)
		m_bUnStoppable = p_bValue;
	endproc;
	
	export proc bool Init(CObjHndl p_xWorker,CObjHndl p_xStaircase,bool p_bClimbUp,bool p_bJumpOff)
		if(!p_xWorker.IsValid()||!p_xStaircase.IsValid())then return false; endif;
		m_xWorker=p_xWorker;
		m_xStaircase=p_xStaircase;
		m_bClimbUp=p_bClimbUp;
		m_bClimbForward=true;
		m_bJumpOff=p_bJumpOff;
		m_sState="start";
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		var ^CGameObj pxWorker=m_xWorker.GetObj();
		if(pxWorker==null)then EndTask();return; endif;
		SetMaxCounter(25);
	endproc;
	
	proc void USLOnTick(int p_iTime)
		if(m_sState=="fall")then
			return;
		endif;
		var ^CCharacter pxWorker=cast<CCharacter>(m_xWorker.GetObj());
		var ^CSeasStaircase pxStaircase=cast<CSeasStaircase>(m_xStaircase.GetObj());
		if((pxWorker==null)||(pxStaircase==null))then SetUnStoppable(false); EndTask();return; endif;
		if(pxWorker^.HasSecondaryAction())then return; endif;
		if(m_sState=="start")then
			var vec3 vStart=pxStaircase^.GetPos();
			vStart.SetZ(CSrvWrap.GetScapeMgr().GetHeight(vStart.GetX(), vStart.GetY()));
			var vec3 vExit, vPos1, vPos2, vPos3, vPos4, vPos5, vJump, vDir, vSc, vWall;
			var bool bFrontSide=true;
			if(GetFrontside(pxWorker,pxStaircase,bFrontSide,vSc,vWall))then
				GetPositions(vSc,vWall,vStart,vPos1,vPos2,vPos3,vPos4,vPos5,vJump,vExit);
				m_vPos5=vPos5;
				if(!bFrontSide)then
					m_bClimbForward=false;
					m_vEntry=vExit;
					m_vExit=vStart;
					m_vJump=vJump;
					m_vPos1=vPos4;
					m_vPos2=vPos3;
					m_vPos3=vPos2;
					m_vPos4=vPos1;
					m_vPos5=vPos5;
				else
					m_vEntry=vStart;
					m_vExit=vExit;
					m_vJump=vExit;
					m_vPos1=vPos1;
					m_vPos2=vPos2;
					m_vPos3=vPos3;
					m_vPos4=vPos4;
					m_vPos5=vPos5;
				endif;
				m_sState="trip";
			endif;
			if(m_sState=="start")then m_sState="end"; endif;
		endif;
		if(m_sState=="trip")then
			var vec3 vDest=m_vEntry;
			SetCurrentTarget(vDest);
			m_sState="rotate_0";
			if(!IsAlreadyAtTargetPos(pxWorker^.GetPos(), 7.5))then
				if(pxWorker^.GetOnWall())then
					pxWorker^.WallWalkAction(vDest,true,pxWorker^.GetMaxSpeed(),false);
				else
					pxWorker^.WalkAction(vDest,pxWorker^.GetMaxSpeed());
				endif;
			else
				USLOnTick(0);
				return;
			endif;
		elseif(m_sState=="rotate_0")then
			if(!HasArrivedTarget(pxWorker^.GetPos(),7.5))then
				if(!CanFollow())then
					ResetCounter();
					m_sState="end";
					return;
				else
					m_sState="trip";
					return;
				endif;
			else
				if(!pxStaircase^.RegisterClimber(m_xWorker))then
					EndTask();
					return;
				endif;
				SetUnStoppable(true);
				m_sState="trip_2";
				if(!IsAlreadyAtTargetPos(pxWorker^.GetPos(), 1.5))then
					var Quat qRot=GetAngleToQ(GetCurrentTarget(),pxWorker^.GetPos());
					pxWorker^.RotateAction(qRot);
				else
					USLOnTick(0);
					return;
				endif;
			endif;
		elseif(m_sState=="trip_2")then
			var vec3 vDest=m_vEntry;
			pxWorker^.SetAnim("walk_3",3);
			pxWorker^.SecondaryMoveAction(vDest,5.0f);
			m_sState="rotate_1";
		elseif(m_sState=="rotate_1")then
			var Quat qRot=pxStaircase^.GetRot();
			if(!m_bClimbForward)then
				qRot.RotateZ(Math.Pi());
			else
				qRot.RotateZ(Math.Pihalf());
			endif;
			pxWorker^.SecondaryRotateAction(qRot);
			m_sState="move_1";
		elseif(m_sState=="move_1")then
			var vec3 vDest=m_vPos1;
			var real fSpeed=5.0f;
			if(m_bClimbForward)then
				pxWorker^.SetAnim("walk_3",3);
				fSpeed=11.0f;
			else
				pxWorker^.SetAnim("climb_up_ladder",3);
			endif;
			pxWorker^.SecondaryMoveAction(vDest, fSpeed);
			m_sState="rotate_2";
		elseif(m_sState=="rotate_2")then
			m_sState="move_2";
			var Quat qRot=pxStaircase^.GetRot();
			if(m_bClimbForward)then
				pxWorker^.SecondaryRotateAction(qRot);
				pxWorker^.SetAnim("standrotate_right",1);
			else
				USLOnTick(0);
				return;
			endif;
		elseif(m_sState=="move_2")then
			var vec3 vDest=m_vPos2;
			var real fSpeed=6.0f;
			if(!m_bClimbForward&&m_bJumpOff)then
				m_sState="move_5";
				USLOnTick(0);
				return;
			else
				m_sState="rotate_3";
				pxWorker^.SetAnim("walk_3",3);
				pxWorker^.SecondaryMoveAction(vDest, fSpeed);
			endif;
		elseif(m_sState=="rotate_3")then
			m_sState="move_3";
			var Quat qRot=pxStaircase^.GetRot();
			if(m_bClimbForward)then
				qRot.RotateZ(Math.Pihalf()+Math.Pi());
				pxWorker^.SetAnim("standrotate_right",1);
			else
				qRot.RotateZ(Math.Pihalf());
				pxWorker^.SetAnim("standrotate_right",1);
			endif;
			pxWorker^.SecondaryRotateAction(qRot);
		elseif(m_sState=="move_3")then
			var vec3 vDest=m_vPos3;
			var real fSpeed=11.0f;
			pxWorker^.SetAnim("walk_3",3);
			pxWorker^.SecondaryMoveAction(vDest, fSpeed);
			m_sState="rotate_4";
		elseif(m_sState=="rotate_4")then
			m_sState="move_4";
			var Quat qRot=pxStaircase^.GetRot();
			if(!m_bClimbForward)then
				qRot.RotateZ(Math.Pi());
				pxWorker^.SetAnim("standrotate_left",1);
			else
				pxWorker^.SetAnim("standrotate_left",1);
			endif;
			pxWorker^.SecondaryRotateAction(qRot);
			m_sState="move_4";
		elseif(m_sState=="move_4")then
			var vec3 vDest=m_vPos4;
			var real fSpeed=6.0f;
			pxWorker^.SetAnim("walk_3",3);
			pxWorker^.SecondaryMoveAction(vDest, fSpeed);
			if(m_bJumpOff)then
				m_sState="jump1";
			else
				m_sState="final_rot";
			endif;
		elseif(m_sState=="final_rot")then
			m_sState="trip_end";
			var Quat qRot=pxStaircase^.GetRot();
			if(m_bClimbForward)then
				qRot.RotateZ(Math.Pi());
				pxWorker^.SetAnim("standrotate_right",1);
			else
				qRot.RotateZ(Math.Pihalf()+Math.Pi());
				pxWorker^.SetAnim("standrotate_left",1);
			endif;
			pxWorker^.SecondaryRotateAction(qRot);
		elseif(m_sState=="trip_end")then
			var vec3 vDest=m_vExit;
			var real fSpeed=5.0f;
			if(m_bClimbForward)then
				pxWorker^.SetAnim("climb_down_ladder",3);
			else
				fSpeed=11.0f;
				pxWorker^.SetAnim("walk_3",3);
			endif;
			pxWorker^.SecondaryMoveAction(vDest,fSpeed);
			m_sState="find_new_pos";
		elseif(m_sState=="jump1")then
			var vec3 vDest=m_vExit;
			if(pxWorker^.GetOnWall())then EndTask(); return; endif;
			var real fMaxDist=1.0f;
//			var ^CGameObj pxWall=pxStaircase^.GetDockInfo().GetDockSite().GetObj();
//			if(pxWall!=null)then
//				var vec3 vDirection = vDest - pxWall^.GetPos();
//				fMaxDist = vDirection.Abs()-(pxWall^.GetRadius()+0.5f);
//			endif;
			CSrvWrap.GetObjMgr()^.GetFreePos(vDest,pxWorker,vDest,null,true,false,false,pxWorker^.GetRadius(),010b,fMaxDist);
			vDest.SetZ(CSrvWrap.GetScapeMgr().GetHeight(vDest.GetX(), vDest.GetY()));
			pxWorker^.JumpAction("climb_up_ladder", vDest, pxWorker^.GetRot(), 0.0f, 20.0f);
			m_sState="find_new_pos";
		elseif(m_sState=="move_5")then
			var vec3 vDest=m_vPos5;
			var real fSpeed=11.0f;
			pxWorker^.SetAnim("walk_3",3);
			pxWorker^.SecondaryMoveAction(vDest, fSpeed);
			m_sState="jump2";
		elseif(m_sState=="jump2")then
			var vec3 vDest=m_vJump;
			if(pxWorker^.GetOnWall())then EndTask(); return; endif;
			var real fMaxDist=1.0f;
//			var ^CGameObj pxWall=pxStaircase^.GetDockInfo().GetDockSite().GetObj();
//			if(pxWall!=null)then
//				var vec3 vDirection = vDest - pxWall^.GetPos();
//				fMaxDist = vDirection.Abs()-(pxWall^.GetRadius()+1.5f);
//			endif;
			CSrvWrap.GetObjMgr()^.GetFreePos(vDest,pxWorker,vDest,null,true,false,false,pxWorker^.GetRadius(),010b,fMaxDist);
			vDest.SetZ(CSrvWrap.GetScapeMgr().GetHeight(vDest.GetX(), vDest.GetY()));
			pxWorker^.JumpAction("climb_up_ladder", vDest, pxWorker^.GetRot(), 0.0f, 20.0f);
			m_sState="find_new_pos";
		elseif(m_sState=="find_new_pos")then
			var vec3 vDest=pxWorker^.GetPos();
			CSrvWrap.GetObjMgr()^.GetFreePos(vDest, pxWorker, vDest);
			pxWorker^.WalkAction(vDest,pxWorker^.GetMaxSpeed());
			m_sState="end";
		elseif(m_sState=="end")then
			pxStaircase^.UnregisterClimber(m_xWorker);
			SetUnStoppable(false);
			EndTask();
		endif;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
		var ^CGameObj pxWorker=m_xWorker.GetObj();
		if(pxWorker==null)then EndTask();return; endif;
	endproc;
	
	proc void EndTask()
		UpdateAggressionPos(m_xWorker);
		GetFSM()^.Enable(false);
		super.EndTask();
	endproc;
	
	proc bool GetFrontside(^CGameObj p_pxWorker,^CSeasStaircase p_pxStaircase,ref bool po_rbFrontside,ref vec3 po_rvSc,ref vec3 po_rvWall)
		if(p_pxStaircase==null)then return false; endif;
		var ^CGameObj pxWall=p_pxStaircase^.GetDockInfo().GetDockSite().GetObj();
		if(pxWall==null)then return false; endif;
		var vec3 vPWorker=p_pxWorker^.GetPos();
		po_rvWall=pxWall^.GetPos();
		po_rvSc=p_pxStaircase^.GetPos();
		var vec3 vND = (po_rvWall-po_rvSc).GetNormalized();
		var real fDB=((po_rvWall+vND)-vPWorker).AbsSquare();
		var real fDF=((po_rvWall-vND)-vPWorker).AbsSquare();
		po_rbFrontside=fDF<fDB;
		return true;
	endproc;
	
	proc void GetPositions(vec3 p_vSc,vec3 p_vWall,ref vec3 po_rvEntry,ref vec3 po_rvP1,ref vec3 po_rvP2,ref vec3 po_rvP3,ref vec3 po_rvP4,ref vec3 po_rvP5,ref vec3 po_rvJump,ref vec3 po_rvExit)
		var vec3 vS=p_vSc;
		var vec3 vW=p_vWall;
		vS.SetZ(0.0f);
		vW.SetZ(0.0f);
		var vec3 vTmp, vDirect = vS-vW;
		vDirect.SetZ(0.0f);
		vDirect.Normalize();
		var Quat qRot;
		qRot.FromXYDir(vDirect.GetX(),vDirect.GetY());
		// Henry: current distance is 3.5f
		var real fX=vDirect.GetX(), fY=vDirect.GetY(), fZ=0.0f;
		vTmp=p_vSc+(vDirect*2.4f);
		vDirect.RotZ(Math.Pihalf());
		po_rvEntry=vTmp+(vDirect*2.0f);
		po_rvEntry.SetZ(CSrvWrap.GetScapeMgr().GetHeight(po_rvEntry.GetX(), po_rvEntry.GetY()));
		vDirect.RotZ(Math.Pi());
		po_rvP1=po_rvEntry+(vDirect*7.0f);
		po_rvP1.SetZ(po_rvEntry.GetZ()+5.0f);
		vDirect.RotZ(Math.Pihalf()+Math.Pi());
		po_rvP2=po_rvP1+(vDirect*2.4f);
		vDirect.RotZ(Math.Pihalf()+Math.Pi());
		po_rvP3=po_rvP2+(vDirect*7.5f);
		po_rvP3.SetZ(po_rvP2.GetZ()+5.0f);
		vDirect.RotZ(Math.Pihalf());
		po_rvP4=po_rvP3+(vDirect*3.0f);
		po_rvExit=po_rvP4+(vDirect*4.5f);
		po_rvExit.SetZ(CSrvWrap.GetScapeMgr().GetHeight(po_rvExit.GetX(), po_rvExit.GetY()));
		vDirect.RotZ(Math.Pi());
		po_rvP5=po_rvP4+(vDirect*6.3);
		po_rvJump=po_rvP5+(vDirect*3.0);
		po_rvJump.SetZ(CSrvWrap.GetScapeMgr().GetHeight(po_rvJump.GetX(), po_rvJump.GetY()));
	endproc;
	
	proc Quat GetAngleToQ(vec3 p_vTarget, vec3 p_vOwn)
		var vec3 vDir=p_vTarget - p_vOwn;
		vDir.SetZ(0.0f);
		vDir.Normalize();
		var Quat qRot;
		qRot.FromXYDir(vDir.GetX(), vDir.GetY());
		return qRot;
	endproc;
	
	export proc bool Break()
		if(GetUnStoppable())then
			return false;
		endif;
		return true;
	endproc;
	
	export proc void BreakExt()
		m_sState="fall";
		GetFSM()^.Enable(true);
		var ^CCharacter pxWorker=cast<CCharacter>(m_xWorker.GetObj());
		if(pxWorker!=null)then
			pxWorker^.SiegeFall();
		endif;
		SetUnStoppable(false);
		EndTask();
	endproc;
	
endclass;
	
class CCorrupting inherit CTask

	var CObjHndl		m_xCorruptor;
	var CObjHndl		m_xCurTarget;
	var CGameTime		m_xStart;
	var int					m_iState;
	var vec3				m_vOldTargetPos;

	const int			STATE_QUIT							= 0;
	const int			STATE_GOTO_TARGET				= 1;
	const int			STATE_ROTATE_TO_TARGET	= 2;
	const int			STATE_CORRUPT_ANIM			= 3;
	
	var bool			m_bFirst;
	var int				m_iAnimState;
	
	const int			ANIM_STATE_NONE					= 0;
	const int			ANIM_STATE_STARTED			= 1;
	const int			ANIM_STATE_LOOPING			= 2;
	const int			ANIM_STATE_STOPPED			= 3;

	export constructor()
		SetName("Corrupting");
	endconstructor;

	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CCorrupting] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xType="Crpt";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xCorruptor.DoKArc(pxArc^);
		m_xCurTarget.DoKArc(pxArc^);
		(pxArc^)<< m_iState;
		(pxArc^)<< m_vOldTargetPos;
		(pxArc^)<< m_iAnimState;
		pxWalk^.Close();
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="Crpt")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xCorruptor.DoKArc(pxArc^);
			m_xCorruptor.DoKArc(pxArc^);
			(pxArc^)<< m_iState;
			(pxArc^)<< m_vOldTargetPos;
			(pxArc^)<< m_iAnimState;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool OnActionEnd(bool p_bBroken)
		return false;
	endproc;
	
	export proc bool Init(CObjHndl p_xCorruptor, CObjHndl p_xTarget)
		if(!p_xCorruptor.IsValid())then
			m_iState=STATE_QUIT;
			return false;
		endif;
		m_xCorruptor=p_xCorruptor;
		if(p_xTarget.IsValid())then
			m_iState =STATE_GOTO_TARGET;
			m_xCurTarget=p_xTarget;
		else
			m_iState=STATE_QUIT;
			return false;
		endif;
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		m_vOldTargetPos={-9999.0f,-9999.0f, -9999.9f};
		var ^CCharacter pxC=cast<CCharacter>(m_xCorruptor.GetObj());
		var ^CFightingObj pxT=cast<CFightingObj>(m_xCurTarget.GetObj());
		if(pxC==null||pxT==null||pxT^.GetHitpoints()<=1.0||pxC^.GetCorruptionRadius()<=0.0f||pxC^.GetCorruptionAmount()<=0.0f)then
			EndTask();
			return;
		endif;
		var ^CAttribs pxAttr=pxC^.GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("CurTask",GetName());
		endif;
//		pxC^.ExamineFlags();
	endproc;
	
	proc void USLOnTick(int p_iTime)
		var ^CCharacter pxCorruptor=cast<CCharacter>(m_xCorruptor.GetObj());
		var ^CFightingObj pxFO=cast<CFightingObj>(m_xCurTarget.GetObj());
		if(pxCorruptor!=null&&pxFO!=null)then
			if(pxCorruptor^.GetTransportObj().IsValid()||pxFO^.GetHitpoints()<=1.0)then
				EndTask();
				return;
			endif;
			var bool bReset=false;
			var vec3 vPos=pxCorruptor^.GetPos();
			if(m_iAnimState==ANIM_STATE_STARTED)then
				pxCorruptor^.SetRndInvMaskSingleFlagInv(CFightingObj.VIS_FLAG_CHTR_ACTIVATED,true);
			elseif(m_iAnimState==ANIM_STATE_STOPPED)then
				pxCorruptor^.SetRndInvMaskSingleFlagInv(CFightingObj.VIS_FLAG_CHTR_ACTIVATED,false);
			endif;
			if(m_iState==STATE_GOTO_TARGET)then
				var real fRadius=pxCorruptor^.GetCorruptionRadius();
				if((pxFO^.GetPos()-vPos).Abs2()>fRadius)then
					var CGameObj.CAdvanceActionParams xAWAP;
					xAWAP.m_fMinDistance=fRadius-1.0;
					xAWAP.m_iPrefSpeed=pxCorruptor^.GetMaxSpeed();
					if(!pxCorruptor^.GetOnWall())then
						pxCorruptor^.AdvanceAction(pxFO^.GetHandle(),xAWAP);
					else
						pxCorruptor^.AdvanceWallAction(pxFO^.GetHandle(),xAWAP,!pxFO^.GetOnWall(),IsUserCommand());
					endif;
				endif;
				m_iState=STATE_ROTATE_TO_TARGET;
			elseif(m_iState==STATE_ROTATE_TO_TARGET)then
				pxCorruptor^.UpdateAggressionPos(pxCorruptor^.GetPos());
				var ^CFightingObj pxFO =cast<CFightingObj>(m_xCurTarget.GetObj());
				if(pxFO!=null)then 
					var vec3 vDir =(pxFO^.GetPos()-vPos).GetNormalized();
					var Quat qR; qR.FromXYDir(vDir.GetX(), vDir.GetY());
					pxCorruptor^.RotateAction(qR);
				endif;
				m_bFirst=true;
				m_xStart=CGameTime.GetNullTime();
				m_iState=STATE_CORRUPT_ANIM;
				return;
			elseif(m_iState==STATE_CORRUPT_ANIM)then
				var int iChangeState=STATE_CORRUPT_ANIM;
				var ^CFightingObj pxFO=cast<CFightingObj>(m_xCurTarget.GetObj());
				if(pxFO!=null)then
					var real fDist =(pxFO^.GetPos()-vPos).Abs2();
					if(fDist > pxCorruptor^.GetCorruptionRadius()+pxFO^.GetCollisionRadius()+3.0)then	//target too far away
						iChangeState=STATE_GOTO_TARGET;
					elseif(m_vOldTargetPos.GetX()> -9999.0f &&(pxFO^.GetPos()-m_vOldTargetPos).Abs2S()>3.0f)then	//target has moved
						iChangeState=STATE_ROTATE_TO_TARGET;
					endif;
					m_vOldTargetPos=pxFO^.GetPos();
					var real fValue=0.0;
					if(m_xStart!=CGameTime.GetNullTime())then
						fValue =(CTimeMgr.Get().GetTime()- m_xStart).GetSecondsF();
					endif;
					m_xStart=CTimeMgr.Get().GetTime();
					fValue *= pxCorruptor^.GetCorruptionAmount(pxFO);
					pxFO^.Corrupt(fValue);
				else
					EndTask();
					return;
				endif;
				var string sAnim="heal_0";
				var string sLoopAnim;
				var bool bLast;
				if(iChangeState!=STATE_CORRUPT_ANIM)then
					m_iState=iChangeState;
					bLast=true;
				endif;
				if(!(m_bFirst && bLast)&& pxCorruptor^.HasAnim(sAnim))then
					if(m_bFirst)then
						pxCorruptor^.SetSLEAnim(sAnim,9999,true,true);
						pxCorruptor^.WaitAction(0.3f);
					elseif(bLast)then
						pxCorruptor^.AnimActionStopLoop();
					endif;
				endif;
				if(m_bFirst)then
					m_bFirst=false;
					if(!bLast)then m_iAnimState=ANIM_STATE_STARTED; endif;
				endif;
				if(bLast)then m_iAnimState=ANIM_STATE_STOPPED; endif;
				return;
			elseif(m_iState==STATE_QUIT)then
				pxCorruptor^.SetRndInvMaskSingleFlagInv(CFightingObj.VIS_FLAG_CHTR_ACTIVATED,false);
				EndTask();
				return;
			endif;
		else
			EndTask();
			return;
		endif; 
	endproc;
	
	export proc void EndTask()
		super.EndTask();
		var ^CCharacter pxCorruptor=cast<CCharacter>(m_xCorruptor.GetObj());
		if(pxCorruptor==null)then return; endif;
		pxCorruptor^.SetRndInvMaskSingleFlagInv(CFightingObj.VIS_FLAG_CHTR_ACTIVATED,false);
		var string sLoopAnim="standanim";
		var ^CAttribs pxAttr=pxCorruptor^.GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("CurTask","Idle");
		endif;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
		var ^CCharacter pxCorruptor=cast<CCharacter>(m_xCorruptor.GetObj());
		if(pxCorruptor==null)then return; endif;
		pxCorruptor^.SetRndInvMaskSingleFlagInv(CFightingObj.VIS_FLAG_CHTR_ACTIVATED,false);
		var ^CAttribs pxAttr=pxCorruptor^.GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("CurTask","Idle");
		endif;
	endproc;
	
	export proc bool Break()
		var ^CCharacter pxCorruptor=cast<CCharacter>(m_xCorruptor.GetObj());
		if(pxCorruptor!=null)then
			pxCorruptor^.SetRndInvMaskSingleFlagInv(CFightingObj.VIS_FLAG_CHTR_ACTIVATED,false);
		endif;
		var ^CAttribs pxAttr=pxCorruptor^.GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("CurTask","Idle");
		endif;
		return true;
	endproc;
	
	export proc void Skip()
	endproc;
	
endclass;
	
class CDeforest inherit CTargetTask
	
	var CObjHndl		m_xWorker;
	var CGameTime		m_xLastTick;
	var vec3				m_vCurTarget;
	var string			m_sState;
	var int					m_iWalkFailCnt;
	var string			m_sWeapon;
	
	var CObjHndl		m_xCurTree;
	var CForestSrvMgr.CTree m_xForTree;
	
	var vec3				m_vJobPos;
	var bool				m_bFirstHit;
	var bool				m_bLastHit;
	var bool				m_bWalkAction;
	var vec3				m_vLastImportantPos;
	
	var CObjQuery		m_xTreeSearch;
	var CFourCC			m_xFCCWeaponLink;
	var array vec3	m_avOldInvalidJobPos;
	var bool				m_bAllJobPosInvalid;
	var CObjList		m_xInvalidDeliveries;
	var bool				m_bAllDeliveriesInvalid;
//	var bool				m_bTransportObj;
	
	const int				MAX_INVALID_TARGETS=10;
	
	export constructor()
//		m_bTransportObj=false;
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CDeforest] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xType="Defo";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xWorker.DoKArc(pxArc^);
		m_xLastTick.DoKArc(pxArc^);
		(pxArc^) << m_vCurTarget;
		(pxArc^) << m_sState;
		(pxArc^) << m_iWalkFailCnt;
		m_xCurTree.DoKArc(pxArc^);
		m_xForTree.DoKArc(pxArc^);
		(pxArc^) << m_vJobPos;
		(pxArc^) << m_bFirstHit;
		(pxArc^) << m_bLastHit;
		(pxArc^) << m_bWalkAction;
		(pxArc^) << m_vLastImportantPos;
		// Henry: version 2
//		(pxArc^) << m_bTransportObj;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="Defo")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			m_xWorker.DoKArc(pxArc^);
			m_xLastTick.DoKArc(pxArc^);
			(pxArc^) << m_vCurTarget;
			(pxArc^) << m_sState;
			(pxArc^) << m_iWalkFailCnt;
			m_xCurTree.DoKArc(pxArc^);
			m_xForTree.DoKArc(pxArc^);
			(pxArc^) << m_vJobPos;
			(pxArc^) << m_bFirstHit;
			(pxArc^) << m_bLastHit;
			(pxArc^) << m_bWalkAction;
			(pxArc^) << m_vLastImportantPos;
//			if(iVersion>=2)then
//				(pxArc^) << m_bTransportObj;
//			endif;
			m_xFCCWeaponLink="HndR";
			InitSearch();
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	proc CObjHndl Convert2ObjTree(ref CForestSrvMgr.CTree po_rxForTree)
		CSrvWrap.GetForestMgr().Refresh(po_rxForTree);
		var CObjHndl xRet;
		if(!po_rxForTree.IsValid())then return xRet; endif;
		var int iTreeType=CSrvWrap.GetForestMgr().GetTreeType(po_rxForTree);
		if(iTreeType==-1)then return xRet; endif;
		var vec3 vTreePos;
		if(CSrvWrap.GetForestMgr().GetTreePos(po_rxForTree, vTreePos)==true)then
			m_vCurTarget=vTreePos;
		endif;
		var string sSetting=CSrvWrap.GetCurLevel()^.GetLevelInfo().GetAttribs().GetValue("Setting");
		if(sSetting=="Cave1")then
			sSetting="Savanna";
		elseif(sSetting=="Cave2")then
			sSetting="Ashvalley";
		elseif(sSetting=="Cave3")then
			sSetting="Oasis";
		endif;
		var string sTree=sSetting+"_Tree_0"+(iTreeType+1).ToString();
		xRet=CSrvWrap.GetForestMgr().ConvertTree(po_rxForTree,sTree);
		return xRet;
	endproc;
	
	proc CObjHndl CreateObjTree(ref CForestSrvMgr.CTree po_rxForTree)
		CSrvWrap.GetForestMgr().Refresh(po_rxForTree);
		if(po_rxForTree.IsValid())then
			var CObjHndl xTree;
			var CObjHndl xInvalid;
			var real fTreeRotZ=CSrvWrap.GetForestMgr().GetTreeRotZ(po_rxForTree);
			var string sSetting=CSrvWrap.GetCurLevel()^.GetLevelInfo().GetAttribs().GetValue("Setting");
			if(sSetting=="Cave1")then
				sSetting="Savanna";
			elseif(sSetting=="Cave2")then
				sSetting="Ashvalley";
			elseif(sSetting=="Cave3")then
				sSetting="Oasis";
			endif;
			var vec3 vTreePos;
			if(CSrvWrap.GetForestMgr().GetTreePos(po_rxForTree, vTreePos)==true)then
				m_vCurTarget=vTreePos;
				var int iTreeType=CSrvWrap.GetForestMgr().GetTreeType(po_rxForTree);
				if(iTreeType!=-1)then
					var ^CGameObj pxObj=CSrvWrap.GetObjMgr()^.CreateObj(sSetting+"_Tree_0"+(iTreeType+1).ToString()+"_Timber",(-1),m_vCurTarget);
					xTree=pxObj^.GetHandle();
					pxObj^.SetRot(Quat.RotationZ(fTreeRotZ));
				else
					if(po_rxForTree.IsValid())then
						var ^CGameObj pxObj=po_rxForTree.GetObjHandle().GetObj();
						pxObj^.SetRot(Quat.RotationZ(fTreeRotZ));
						var string sName=pxObj^.GetClassName();
						var ^CGameObj pxTemp=CSrvWrap.GetObjMgr()^.CreateObj(sName+"_Timber",(-1),m_vCurTarget);
						if(pxTemp!=null)then
							xTree=pxTemp^.GetHandle();
							pxTemp^.SetRot(Quat.RotationZ(fTreeRotZ));
						else
							return(xInvalid);
						endif;
						if(!po_rxForTree.IsConvertedFromFake())then
							var ^CGameObj pxTrunk;
							pxTrunk=CSrvWrap.GetObjMgr()^.CreateObj(sName+"_Stump",(-1),m_vCurTarget);
							if(pxTrunk!=null)then
								pxTrunk^.SetRot(Quat.RotationZ(fTreeRotZ));
							else
								return(xInvalid);
							endif;
						endif;
					else
					endif;
				endif;
				m_avOldInvalidJobPos=0;
				CSrvWrap.GetForestMgr().ChopTree(po_rxForTree);
			else
				m_sState="search_for_jobs";
			endif;
			return xTree;
		else
			var CObjHndl xInvalidObj;
			return xInvalidObj;
		endif;
	endproc;
	
	export proc bool Init(CObjHndl p_xWorker,vec3 p_vPos)
		SetName("Deforest");
		m_xWorker=p_xWorker;
		var ^CFightingObj pxWorker=cast<CFightingObj>(m_xWorker.GetObj());
		if(pxWorker==null||p_vPos=={0.0,0.0,0.0})then return false; endif;
		pxWorker^.AnnounceState("deforest");
		var ^CAttribs pxAttr=pxWorker^.GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("CurTask",GetName());
		endif;
		if(pxWorker^.GetType()=="ANML"||pxWorker^.GetType()=="VHCL")then
//			m_bTransportObj=true;
		elseif(pxWorker^.GetClassName().Find("arry_s0")!=-1)then
			m_sWeapon="hu_axe";
		else
			m_sWeapon=pxWorker^.GetClassName().Left(pxWorker^.GetClassName().Find("_"))+"_axe";
		endif;
		m_xFCCWeaponLink="HndR";
		m_vJobPos=p_vPos;
		m_vCurTarget=p_vPos;
		InitSearch();
		var bool bNewTree=false;
		var CForestSrvMgr.CTree xForTree;
		bNewTree=CSrvWrap.GetForestMgr().FindHarvestTree( xForTree, pxWorker^.GetPos(), m_vCurTarget);
		if(xForTree.IsValid())then
			if(bNewTree==true)then
				CSrvWrap.GetForestMgr().SetHitPoints(xForTree, CSrvWrap.GetForestMgr().GetMaxHPFakeTrees());
			endif;
			m_xForTree=xForTree;
			m_sState="goto_chop_forest";
		else
			m_sState="search_for_jobs";
		endif;
		return true;
	endproc;
	
	export proc bool Init(CObjHndl p_xWorker, CObjHndl p_xTarget)
		SetName("Deforest");
		m_xWorker=p_xWorker;
		var ^CFightingObj pxWorker=cast<CFightingObj>(m_xWorker.GetObj());
		var ^CGameObj pxTarget=p_xTarget.GetObj();
		if(pxWorker==null||pxTarget==null)then return false; endif;
		if(pxWorker^.GetType()=="ANML"||pxWorker^.GetType()=="VHCL")then
//			m_bTransportObj=true;
		elseif(pxWorker^.GetClassName().Find("arry_s0")!=-1)then
			m_sWeapon="hu_axe";
		else
			m_sWeapon=pxWorker^.GetClassName().Left(pxWorker^.GetClassName().Find("_"))+"_axe";
		endif;
		m_xFCCWeaponLink="HndR";
		m_vCurTarget=pxTarget^.GetPos();
		if(pxTarget^.GetType()=="TREE")then
			m_xCurTree=p_xTarget;
			m_vJobPos=pxTarget^.GetPos();
			m_sState="goto_chop";
		else
			m_sState="exit";
			return false;
		endif;
		InitSearch();
		return true;
	endproc;
	
	proc void InitSearch()
		var ^CFightingObj pxWorker=cast<CFightingObj>(m_xWorker.GetObj());
		if(pxWorker==null)then return; endif;
		m_xTreeSearch.SetType("TREE");
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		var ^CFightingObj pxWorker=cast<CFightingObj>(m_xWorker.GetObj());
		if(pxWorker==null)then
			EndTask();
			return;
		endif;
		if(m_sState=="exit")then
			EndTask();
			return;
		endif;
		var ^CCharacter pxChar=cast<CCharacter>(m_xWorker.GetObj());
		var ^CTransportObj pxTPO=cast<CTransportObj>(m_xWorker.GetObj());
		if(pxChar==null&&pxTPO==null)then EndTask(); return; endif;
		var ^CAttribs pxAttr=pxWorker^.GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("CurTask",GetName());
		endif;
		if(pxChar!=null)then
			pxChar^.HideWeapons();
		endif;
		pxWorker^.SetTaskDescription("deforest");
		//pxWorker^.SetTaskDescription("wood");
		SetMaxCounter(1);
	endproc;
	
	proc bool AddFailedTarget()
		m_avOldInvalidJobPos.AddEntry(m_vCurTarget);
		if(m_avOldInvalidJobPos.NumEntries() > MAX_INVALID_TARGETS)then
			return false;
		endif;
		return true;
	endproc;
	
	proc bool CheckWalkFail(ref vec3 p_rvWorker,string p_sSuccState,string p_sFailState)
		if(m_vLastImportantPos==p_rvWorker)then
			m_iWalkFailCnt++;
			if(!AddFailedTarget())then return false; endif;
			if(m_iWalkFailCnt >= 15)then
				m_sState="exit";
				return false;
			endif;
			m_sState=p_sFailState;
			return false;
		else
			m_bWalkAction=false;
			m_iWalkFailCnt=0;
			m_sState=p_sSuccState;
			return true;
		endif;
	endproc;
	
	proc bool CheckWalkPos(ref vec3 p_rvPos)
		var int i;
		var int iC=m_avOldInvalidJobPos.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if((p_rvPos - m_avOldInvalidJobPos[i]).Abs()<3.0f)then
				return false;
			endif;
		endfor;
		return true;
	endproc;
	
	proc void USLOnTick(int p_iTime)
		var ^CFightingObj pxTmp;
		var ^CCharacter pxWorker;
		var ^CTransportObj pxTPO;
		begin CheckWorker;
			pxTmp=cast<CFightingObj>(m_xWorker.GetObj());
			if(pxTmp==null)then
				EndTask();
				return;
			endif;
			pxTPO=cast<CTransportObj>(pxTmp);
			pxWorker=cast<CCharacter>(pxTmp);
			if(pxWorker==null&&pxTPO==null)then
				EndTask();
				return;
			endif;
		end CheckWorker;
		var bool bConvertedFakeTree=false;
		CSrvWrap.GetForestMgr().Refresh(m_xForTree);
		if(m_xForTree.IsObject() && m_xForTree.GetObjHandle().GetObj()!=null)then
			m_xCurTree=m_xForTree.GetObjHandle();
			bConvertedFakeTree=true;
		endif;
		var ^CTree pxTree;
		begin CheckTree;
			var ^CGameObj pxTmp=m_xCurTree.GetObj();
			if(pxTmp!=null)then
				pxTree=cast<CTree>(pxTmp);
			endif;
		end CheckTree;
		var vec3 vPosWorker=pxTmp^.GetPos();
		if(m_sState=="goto_chop")then
			if(pxTree==null)then
				m_sState="search_for_jobs";
			else
				CSrvWrap.GetObjMgr()^.GetFreePos(m_vCurTarget,pxTmp,pxTree^.GetPos());
				if(pxWorker!=null)then
					pxWorker^.HideWeapons();
					pxWorker^.SetLinkGFX(m_xFCCWeaponLink,m_sWeapon);
					if(pxWorker^.GetOnWall())then
						pxWorker^.WallWalkAction(m_vCurTarget,true,pxWorker^.GetDefaultSpeed(),false);
					else
						pxWorker^.WalkAction(m_vCurTarget,pxWorker^.GetDefaultSpeed(),true);
					endif;
				elseif(pxTPO!=null)then
					pxTPO^.WalkAction(m_vCurTarget,pxTPO^.GetDefaultSpeed(),true);
				endif;
				SetCurrentTarget(m_vCurTarget);
				m_sState="rotate_to_tree";
			endif;
		elseif(m_sState=="goto_chop_forest")then
			if(CSrvWrap.GetForestMgr().GetTreePos(m_xForTree, m_vJobPos))then
				CSrvWrap.GetObjMgr()^.GetFreePos(m_vCurTarget,pxTmp,m_vJobPos);
				if(pxWorker!=null)then
					pxWorker^.SetLinkGFX(m_xFCCWeaponLink,m_sWeapon);
					if(pxWorker^.GetOnWall())then
						pxWorker^.WallWalkAction(m_vCurTarget,true,pxWorker^.GetDefaultSpeed(),false);
					else
						pxWorker^.WalkAction(m_vCurTarget,pxWorker^.GetDefaultSpeed(),true);
					endif;
				elseif(pxTPO!=null)then
					pxTPO^.WalkAction(m_vCurTarget,pxTPO^.GetDefaultSpeed(),true);
				endif;
				SetCurrentTarget(m_vCurTarget);
				m_sState="rotate_to_tree_forest";
			else
				m_vJobPos=pxTmp^.GetPos();
				m_sState="search_for_jobs";
			endif;
		elseif(m_sState=="rotate_to_tree_forest"||m_sState=="rotate_to_tree")then
			if(!m_xForTree.IsValid() && pxTree==null)then
				m_sState="search_for_jobs";
				return;
			endif;
			var real fDist=8.0f;
			if(pxTPO!=null)then
				fDist=10.0f;
			endif;
			if(!HasArrivedTarget(pxTmp^.GetPos(),fDist))then
				if(!CanFollow())then
					ResetCounter();
					m_sState="search_for_jobs";
					if(!AddFailedTarget())then
						CSrvWrap.SendGenericEvtToPlayer(pxTmp^.GetOwner(), "NoMoreWood");
						EndTask();
						return;
					endif;
				else
					if(m_sState=="rotate_to_tree_forest")then
						m_sState="goto_chop_forest";
					else
						m_sState="goto_chop";
					endif;
					return;
				endif;
			else
				var vec3 vDir=m_vJobPos-pxTmp^.GetPos();
				var Quat qTRot;
				qTRot.FromXYDir(vDir.GetX(),vDir.GetY());
				pxTmp^.RotateAction(qTRot);
				m_bFirstHit=true;
				if(m_sState=="rotate_to_tree_forest")then
					m_sState="chop_tree_forest";
				else
					m_sState="chop_tree";
					m_bFirstHit=true;
				endif;
			endif;
		elseif(m_sState=="chop_tree"||m_sState=="chop_tree_forest")then
			var real fDmg=100000.0f;
			if(pxTree!=null)then
				if(pxWorker!=null)then
					fDmg=5.0f;
					pxWorker^.SetSLEAnim("chop_tree",9999,m_bFirstHit,true);
					pxWorker^.WaitAction(1.0f);
				elseif(pxTPO!=null)then
					pxTPO^.DoCutAnim();
				endif;
				var CGameTime xNow=CTimeMgr.Get().GetTime();
				if(m_bFirstHit)then
					m_bFirstHit=false;
				endif;
				m_xLastTick=xNow;
				if(!pxTree^.Hit(fDmg))then
					var CGameEvtPtr xEvt=CGameEvtPtr.CreateEvent("Bash");
					xEvt.SetBool(0,true);
					pxTree^.HandleEvent(xEvt);
				else
					var CGameEvtPtr xEvt=CGameEvtPtr.CreateEvent("Chop");
					pxTree^.HandleEvent(xEvt);
				endif;
			elseif(m_xForTree.IsFakeTree() && m_xForTree.IsValid())then
				var CGameTime xNow=CTimeMgr.Get().GetTime();
				if(pxWorker!=null)then
					fDmg=5.0f;
					pxWorker^.SetSLEAnim("chop_tree",9999,m_bFirstHit,true);
					pxWorker^.WaitAction(1.0f);
				elseif(pxTPO!=null)then
					pxTPO^.DoCutAnim();
				endif;
				if(m_bFirstHit)then
					m_bFirstHit=false;
				endif;
				m_xLastTick=xNow;
				var real fCurHitPoints=CSrvWrap.GetForestMgr().HitTree(m_xForTree, fDmg);
				if(fCurHitPoints <= 0.0f)then
					CreateObjTree(m_xForTree);
				else
					Convert2ObjTree(m_xForTree);
				endif;
			else
				if(pxWorker!=null)then
					if(!m_bFirstHit)then
						pxWorker^.AnimActionStopLoop();
					endif;
				endif;
				m_sState="search_for_jobs";
			endif;
		elseif(m_sState=="search_for_jobs")then
			begin FindForestTree;
				var bool bNewTree=false;
				var CForestSrvMgr.CTree xTree;
				var int iSkip=0;
				var vec3 vTree;
				var bool bTreeFound;
				while(true)do
					var bool bNewTree=CSrvWrap.GetForestMgr().FindNextTreeShortDelivery(xTree,m_vJobPos,pxTmp^.GetPos(),64.0f,iSkip);
					if(!xTree.IsValid())then break; endif;
					if(bNewTree==true)then
						CSrvWrap.GetForestMgr().SetHitPoints(m_xForTree, CSrvWrap.GetForestMgr().GetMaxHPFakeTrees());
					endif;
					CSrvWrap.GetForestMgr().GetTreePos(xTree, vTree);
					if(Math.Abs(vTree.GetZ()-vPosWorker.GetZ()) > 10.0f)then
						iSkip++;
						continue;
					else
						if(!CheckWalkPos(vTree))then
							iSkip++;
							continue;
						endif;
					endif;
					if(!pxTmp^.CheckMaxAutoprodDist(vTree))then
						iSkip++;
						continue;
					endif;
					bTreeFound=true;
					break;
				endwhile;
				if(bTreeFound)then
					m_xForTree=xTree;
					if(bNewTree==true)then
						CSrvWrap.GetForestMgr().SetHitPoints(m_xForTree, CSrvWrap.GetForestMgr().GetMaxHPFakeTrees());
					endif;
					m_vJobPos=vTree;
					m_sState="goto_chop_forest";
					return;
				endif;
				m_xTreeSearch.RegionCircle(m_vJobPos,64.0f);
				var CObjList xTrees;
				if(m_xTreeSearch.Execute(xTrees))then
					xTrees.SortDistance(m_vJobPos);
					var int i;
					for(i=0)cond(i<xTrees.NumEntries())iter(++i)do
						var ^CTree pxTree= cast<CTree>(xTrees[i].GetObj());
						if(pxTree!=null)then
							if(CheckWalkPos(pxTree^.GetPos()) && pxTmp^.CheckMaxAutoprodDist(pxTree^.GetPos()))then
								m_xCurTree=pxTree^.GetHandle();
								m_sState="goto_chop";
								return;
							endif;
						endif;
					endfor;
				endif;
			end FindForestTree;
			if(!m_bAllJobPosInvalid && m_avOldInvalidJobPos.NumEntries()>0)then
				m_avOldInvalidJobPos=0;
				m_bAllJobPosInvalid=true;
				return;
			endif;
			if(pxWorker!=null)then
				pxWorker^.RemLinkGFX(m_xFCCWeaponLink);
			endif;
			CSrvWrap.SendGenericEvtToPlayer(pxTmp^.GetOwner(), "NoMoreWood");
			EndTask();
			return;
		else
			if(pxWorker!=null)then
				pxWorker^.RemLinkGFX(m_xFCCWeaponLink);
			endif;
			CSrvWrap.SendGenericEvtToPlayer(pxTmp^.GetOwner(), "NoMoreWood");
			EndTask();
		endif;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
		var ^CGameObj pxWorker=m_xWorker.GetObj();
		if(pxWorker!=null&&pxWorker^.GetType()=="CHTR")then
			pxWorker^.RemLinkGFX(m_xFCCWeaponLink);
			(cast<CFightingObj>(pxWorker)^.ShowWeapons());
		endif;
		var int iT, iC;
		iC=m_avOldInvalidJobPos.NumEntries();
		for(iT=0)cond(iT<iC)iter(iT++)do
			m_avOldInvalidJobPos.DeleteEntryUS(iT);
			iT--; iC--;
		endfor;
//		var ^CCharacter pxChar=cast<CCharacter>(m_xWorker.GetObj());
		var ^CFightingObj pxChar=cast<CFightingObj>(m_xWorker.GetObj());
		if(pxChar==null)then return; endif;
		pxChar^.SetTaskDescription("");
	endproc;
	
	export proc bool Break()
		var ^CGameObj pxWorker=m_xWorker.GetObj();
		if(pxWorker!=null)then pxWorker^.TerminateAction(); endif;
		return true;
	endproc;
	
	export proc void EndTask()
		UpdateAggressionPos(m_xWorker);
		super.EndTask();
	endproc;
	
endclass;
	
class CDeplenish inherit CSpecialActionTask
	
	var CObjHndl			m_xCharacter;
	var CObjHndl			m_xTarget;
	var string				m_sState;
	var int						m_iRetryCounter;
	var CGameTime			m_xStart;
	var array string	m_asValidTargets;
	
	export constructor()
		SetName("Deplenish");
		m_asValidTargets.AddEntry("ANML");
		m_asValidTargets.AddEntry("SHIP");
		m_asValidTargets.AddEntry("VHCL");
		SetCivil(false);
		m_iRetryCounter=0;
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CDeplenish] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xType="Depl";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xCharacter.DoKArc(pxArc^);
		m_xTarget.DoKArc(pxArc^);
		m_xStart.DoKArc(pxArc^);
		(pxArc^) << m_sState;
		(pxArc^) << m_iRetryCounter;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="Depl")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xCharacter.DoKArc(pxArc^);
			m_xTarget.DoKArc(pxArc^);
			m_xStart.DoKArc(pxArc^);
			(pxArc^) << m_sState;
			(pxArc^) << m_iRetryCounter;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool Init(CObjHndl p_xCharacter, CObjHndl p_xTarget, string p_sPath)
		m_sState="goto_target";
		if(!p_xCharacter.IsValid()||!p_xTarget.IsValid())then
			m_sState="EndTask";
			return false;
		endif;
		if(m_asValidTargets.FindEntry(p_xTarget.GetObj()^.GetType().AsString())==-1)then
			m_sState="EndTask";
			return false;
		endif;
		var real fScapeZ=CSrvWrap.GetScapeMgr().GetHeight(p_xTarget.GetObj()^.GetPos().GetX(), p_xTarget.GetObj()^.GetPos().GetY());
		var real fSea=CSrvWrap.GetScapeMgr().GetSeaLevel();
		if(fScapeZ+5.0f<fSea)then
			m_sState="EndTask";
			return false;
		endif;
		SetSpecialActionPath(p_sPath);
		SetPrepareActionPath(p_xCharacter, p_sPath, true);
		m_xCharacter=p_xCharacter;
		m_xTarget=p_xTarget;
		return true;
	endproc;
	
	export proc bool Init(CObjHndl p_xCharacter, string p_sPath)
//		m_sState="perform_magic";
		m_sState="curse";
		if(!p_xCharacter.IsValid())then
			m_sState="EndTask";
			return false;
		endif;
		SetSpecialActionPath(p_sPath);
		SetPrepareActionPath(p_xCharacter, p_sPath, true);
		m_xCharacter=p_xCharacter;
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		var ^CFightingObj pxFightingObj=cast<CFightingObj>(m_xCharacter.GetObj());
		if(pxFightingObj==null||!pxFightingObj^.CheckSpecialActionTimer(GetSpecialActionPath()))then
			EndTask();
			return;
		endif;
		if(m_sState=="EndTask")then
			EndTask();
		endif;
	endproc;
	
	proc void USLOnTick(int p_iTime)
		var ^CCharacter pxCharacter=cast<CCharacter>(m_xCharacter.GetObj());
		if(pxCharacter==null)then EndTask(); return; endif;
		if(m_sState=="perform_magic")then
			SetUnStoppable(true);
			m_xStart=CTimeMgr.Get().GetTime();
			pxCharacter^.SetAnim("heal_0",3);
			m_sState="check_time";
			return;
		elseif(m_sState=="check_time")then
			var CGameTimeSpan xDuration=4.0f;
			var CGameTime xNow=CTimeMgr.Get().GetTime();
			if((xNow - m_xStart) >= xDuration)then
				m_sState="curse";
				return;
			endif;
		elseif(m_sState=="curse")then
			if(!StartSpecialActionTimer(pxCharacter))then EndTask(); return; endif;
//			var real fDuration=30.0f;
			var real fDuration=15.0f;
			var real fRange = 30.0;
			var CObjList xList;
			var ^CObjList pxEnemies=CSrvWrap.GetObjMgr()^.GetOwnerEnemyList(pxCharacter^.GetOwner());
			if(pxEnemies==null)then return; endif;
			pxEnemies^.CopySorted(xList, pxCharacter^.GetPos(), fRange);
			var int i, iC = xList.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				var ^CTransportObj pxTrp = cast<CTransportObj>(xList[i].GetObj());
				if(pxTrp!=null)then
					pxTrp^.SetUnboard(true,fDuration);
				endif;
			endfor;
			CSoundEvent.PlayAll("FX_CUnboardCurse",1,pxCharacter^.GetPos());
			m_sState="EndTask";
			return;
		elseif(m_sState=="EndTask")then
			SetUnStoppable(false);
			EndTask();
			return;
		endif;
	endproc;
	
	/*
	proc void USLOnTick(int p_iTime)
		var ^CCharacter pxCharacter=cast<CCharacter>(m_xCharacter.GetObj());
		var ^CFightingObj pxTarget=cast<CFightingObj>(m_xTarget.GetObj());
		if(pxCharacter==null||pxTarget==null)then EndTask(); return; endif;
		if(pxTarget^.GetTransportClass()<1)then EndTask(); return; endif;
		var real fScapeZ=CSrvWrap.GetScapeMgr().GetHeight(pxTarget^.GetPos().GetX(), pxTarget^.GetPos().GetY());
		var real fSea=CSrvWrap.GetScapeMgr().GetSeaLevel();
		if(fScapeZ+5.0f<fSea)then
			EndTask();
			return;
		endif;
		if(m_sState=="goto_target")then
			var real fAttackRange=Math.Max(pxCharacter^.GetHealingRadius(),15.0);
			if(!IsInRange())then
				if(pxCharacter^.GetOnWall())then
					EndTask();return;
				endif;
				pxCharacter^.AdvanceAction(pxTarget^.GetHandle(),fAttackRange, pxCharacter^.GetMaxSpeed());
			endif;
			m_sState="perform_magic";
		elseif(m_sState=="perform_magic")then
			m_xStart=CTimeMgr.Get().GetTime();
			pxCharacter^.SetAnim("heal_0",3);
			m_sState="check_time";
			return;
		elseif(m_sState=="check_time")then
			if(!IsInRange())then
				if(m_iRetryCounter>3)then
					EndTask();
				else
					m_iRetryCounter++;
					m_sState="goto_target";
					return;
				endif;
			endif;
			var CGameTimeSpan xDuration=10.0f;
			var CGameTime xNow=CTimeMgr.Get().GetTime();
			if((xNow - m_xStart) >= xDuration)then
				m_sState="curse";
				return;
			endif;
		elseif(m_sState=="curse")then
			SetUnStoppable(true);
			if(!StartSpecialActionTimer(pxCharacter))then EndTask(); return; endif;
			var real fDuration=60.0f;
			pxTarget^.SetUnboard(true,fDuration);
			CSoundEvent.PlayAll("FX_CUnboardCurse",1,pxTarget^.GetPos());
			m_sState="EndTask";
			return;
		elseif(m_sState=="EndTask")then
			SetUnStoppable(false);
			EndTask();
			return;
		endif;
	endproc;
	*/
	proc bool IsInRange()
		var ^CCharacter pxCharacter=cast<CCharacter>(m_xCharacter.GetObj());
		var ^CGameObj pxTarget=m_xTarget.GetObj();
		if(pxCharacter==null||pxTarget==null)then return false; endif;
		var real fTargetRadius=pxTarget^.GetRadius();
		var real fSelfRadius=pxCharacter^.GetRadius();
		var real fAttackRange=Math.Max(pxCharacter^.GetHealingRadius(),15.0)+fSelfRadius+fTargetRadius;
		var real fDistance=(pxTarget^.GetPos() - pxCharacter^.GetPos()).Abs2S();
		return fDistance <= fAttackRange*fAttackRange;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
	endproc;
	
	export proc bool Break()
		if(GetUnStoppable())then
			return false;
		endif;
		SetPrepareActionPath(m_xCharacter, GetSpecialActionPath(), false);
		if(m_xCharacter.IsValid())then
			m_xCharacter.GetObj()^.TerminateAction();
		endif;
		return true;
	endproc;
	
	export proc void Skip()
	endproc;
	
	export proc void EndTask()
		SetPrepareActionPath(m_xCharacter, GetSpecialActionPath(), false);
		UpdateAggressionPos(m_xCharacter);
		super.EndTask();
	endproc;
	
endclass;
	
class CHemoplague inherit CSpecialActionTask
	
	var CObjHndl		m_xCharacter;
	var CObjHndl		m_xTarget;
	var string			m_sState;
	var int					m_iRetryCounter;
	
	var array string	m_asValidTargets;
	
	export constructor()
		SetName("Hemoplague");
		m_asValidTargets.AddEntry("ANML");
		m_asValidTargets.AddEntry("CHTR");
//		m_asValidTargets.AddEntry("VHCL");
		SetCivil(false);
		m_iRetryCounter=0;
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CHemoplague] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xType="HePl";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xCharacter.DoKArc(pxArc^);
		m_xTarget.DoKArc(pxArc^);
		(pxArc^) << m_sState;
		(pxArc^) << m_iRetryCounter;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="HePl")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xCharacter.DoKArc(pxArc^);
			m_xTarget.DoKArc(pxArc^);
			(pxArc^) << m_sState;
			(pxArc^) << m_iRetryCounter;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool Init(CObjHndl p_xCharacter, CObjHndl p_xTarget, string p_sPath)
		m_sState="goto_target";
		if(!p_xCharacter.IsValid()||!p_xTarget.IsValid())then
			m_sState="EndTask";
			return false;
		endif;
		if(m_asValidTargets.FindEntry(p_xTarget.GetObj()^.GetType().AsString())==-1)then
			m_sState="EndTask";
			return false;
		endif;
		SetSpecialActionPath(p_sPath);
		SetPrepareActionPath(p_xCharacter, p_sPath, true);
		m_xCharacter=p_xCharacter;
		m_xTarget=p_xTarget;
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		var ^CFightingObj pxFightingObj=cast<CFightingObj>(m_xCharacter.GetObj());
		if(pxFightingObj==null||!pxFightingObj^.CheckSpecialActionTimer(GetSpecialActionPath()))then
			EndTask();
			return;
		endif;
		if(m_sState=="EndTask")then
			EndTask();
		endif;
	endproc;
	
	proc void USLOnTick(int p_iTime)
		var ^CCharacter pxCharacter=cast<CCharacter>(m_xCharacter.GetObj());
		var ^CFightingObj pxTarget=cast<CFightingObj>(m_xTarget.GetObj());
		if(pxCharacter==null||pxTarget==null)then EndTask(); return; endif;
		if(m_sState=="goto_target")then
			var real fAttackRange=10.0;
			if(!IsInRange())then
				if(pxCharacter^.GetOnWall())then
					EndTask();return;
				endif;
				pxCharacter^.AdvanceAction(pxTarget^.GetHandle(),fAttackRange, pxCharacter^.GetMaxSpeed());
			endif;
			m_sState="throw";
		elseif(m_sState=="throw")then
			if(!IsInRange())then
				if(m_iRetryCounter>3)then
					EndTask();
				else
					m_iRetryCounter++;
					m_sState="goto_target";
					return;
				endif;
			else
				SetUnStoppable(true);
				if(!StartSpecialActionTimer(pxCharacter))then EndTask(); return; endif;
				pxCharacter^.AnimAction("heal_0");
				pxTarget^.SetBloodInfection(true,20.0f);
				m_sState="EndTask";
				return;
			endif;
		elseif(m_sState=="EndTask")then
			SetUnStoppable(false);
			EndTask();
			return;
		endif;
	endproc;
	
	proc bool IsInRange()
		var ^CCharacter pxCharacter=cast<CCharacter>(m_xCharacter.GetObj());
		var ^CGameObj pxTarget=m_xTarget.GetObj();
		if(pxCharacter==null||pxTarget==null)then return false; endif;
		var real fTargetRadius=pxTarget^.GetRadius();
		var real fSelfRadius=pxCharacter^.GetRadius();
		var real fAttackRange=10.0+fSelfRadius+fTargetRadius;
		var real fDistance=(pxTarget^.GetPos() - pxCharacter^.GetPos()).Abs2S();
		return fDistance <= fAttackRange*fAttackRange;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
	endproc;
	
	export proc bool Break()
		if(GetUnStoppable())then
			return false;
		endif;
		SetPrepareActionPath(m_xCharacter, GetSpecialActionPath(), false);
		if(m_xCharacter.IsValid())then
			m_xCharacter.GetObj()^.TerminateAction();
		endif;
		return true;
	endproc;
	
	export proc void Skip()
	endproc;
	
	export proc void EndTask()
		SetPrepareActionPath(m_xCharacter, GetSpecialActionPath(), false);
		UpdateAggressionPos(m_xCharacter);
		super.EndTask();
	endproc;
	
endclass;
	
class CJumpjet inherit CSpecialActionTask
	
	var CObjHndl		m_xActor;
	var string			m_sState;
	var vec3				m_vJumpPos;
	const real			m_fMaxDistance=500.0f;
	
	export constructor()
		SetName("Jumpjet");
		SetCivil(false);
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CJumpjet] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xType="JuJe";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,2);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xActor.DoKArc(pxArc^);
		(pxArc^) << m_sState;
		(pxArc^) << m_vJumpPos;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="JuJe")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xActor.DoKArc(pxArc^);
			(pxArc^) << m_sState;
			(pxArc^) << m_vJumpPos;
			if(p_pxReaderNode^.GetVersion()==1)then
				var string sInvalid;
				(pxArc^) << sInvalid;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool Init(CObjHndl p_xActor, vec3 p_vPos, string p_sTTPath)
		SetSpecialActionPath(p_sTTPath);
		SetName("Jumpjet");
		var ^CHero pxActr=cast<CHero>(p_xActor.GetObj());
		if(pxActr==null||(pxActr^.GetClassName()!="tesla_s0"&&pxActr^.GetClassName()!="babbage_s0"))then return false; endif;
		m_xActor=p_xActor;
		m_vJumpPos=p_vPos;
		if(!m_xActor.IsValid())then return false; endif;
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		var ^CFightingObj pxFightingObj=cast<CFightingObj>(m_xActor.GetObj());
		if(pxFightingObj==null||!pxFightingObj^.CheckSpecialActionTimer(GetSpecialActionPath()))then
			EndTask();
			return;
		endif;
		if(m_xActor.IsValid())then
			var ^CHero pxActor=cast<CHero>(m_xActor.GetObj());
			if(pxActor==null||(pxActor^.GetClassName()!="tesla_s0"&&pxActor^.GetClassName()!="babbage_s0"))then EndTask();return;endif;
			var vec3 vPos;
			var vec3 vWay=m_vJumpPos-pxActor^.GetPos();
			var real fLength=vWay.Abs();
			if(fLength>m_fMaxDistance)then
				vWay.Normalize();
				var real fTemp=fLength-m_fMaxDistance;
				m_vJumpPos=GetAdoptedDest(pxActor^.GetPos(),m_vJumpPos,fTemp);
			endif;
		endif;
		m_sState="rotate_to_target";
	endproc;
	
	proc void USLOnTick(int p_iTime)
		if(!m_xActor.IsValid())then EndTask();return;endif;
		var ^CHero pxActor=cast<CHero>(m_xActor.GetObj());
		if(pxActor==null)then EndTask(); return; endif;
		if(m_sState=="rotate_to_target")then
			var vec3 vWay=m_vJumpPos-pxActor^.GetPos();
			var Quat qRot;
			qRot.FromXYDir(vWay.GetX(), vWay.GetY());
			pxActor^.RotateAction(qRot);
			m_sState="prepare_to_jump_3";
		elseif(m_sState=="prepare_to_jump_3")then
			if(!CheckSpecialActionTimer(pxActor))then EndTask();return;endif;
			if(!pxActor^.GetFreePos(m_vJumpPos,15.0))then
				EndTask();
				return;
			endif;
			SetUnStoppable(true);
			pxActor^.EquipJetpack(true);
			pxActor^.AnimAction("jetpack",0,true,false);
			m_sState="jump_to_target";
		elseif(m_sState=="jump_to_target")then
			m_vJumpPos.SetZ(CSrvWrap.GetScapeMgr().GetHeight(m_vJumpPos.GetX(), m_vJumpPos.GetY()));
			pxActor^.SetSLEAnim("jetpack",9999,false,false);
			pxActor^.RemoveFromWall();
			pxActor^.JetPackAction(m_vJumpPos);
			m_sState="land_1";
		elseif(m_sState=="land_1")then
			pxActor^.AnimAction("jetpack",0,false,true);
			m_sState="land_2";
		elseif(m_sState=="land_2")then
			SetUnStoppable(false);
			pxActor^.EquipJetpack(false);
			StartSpecialActionTimer(pxActor);
			pxActor^.ShowWeapons();
			m_sState="end";
		elseif(m_sState=="end")then
			EndTask();
		endif;
	endproc;
	
	export proc void RandomizePos(ref vec3 po_rvPos)
		po_rvPos.SetX(po_rvPos.GetX()+(Random.GetInt()%10+1).ToReal());
		po_rvPos.SetY(po_rvPos.GetY()+(Random.GetInt()%10+1).ToReal());
		po_rvPos.SetZ(CSrvWrap.GetScapeMgr().GetHeight(po_rvPos.GetX(), po_rvPos.GetY()));
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
	endproc;
	
	export proc bool Break()
		if(GetUnStoppable())then
			return false;
		endif;
		if(m_xActor.IsValid())then
			m_xActor.GetObj()^.TerminateAction();
		endif;
		return true;
	endproc;
		
	export proc void EndTask()
		UpdateAggressionPos(m_xActor);
		super.EndTask();
	endproc;
	
endclass;
	
class CMeteor inherit CSpecialActionTask
	
	const real								MAGIC_RANGE=40.0f;
	var CObjHndl							m_xCharacter;
	var vec3									m_vTarget;
	var string								m_sState;
	var CGameTime							m_xStart;
	var string								m_sAnimation;
	var bool									m_bIllusion;
	
	export constructor()
		SetName("Meteor");
		SetCivil(false);
		m_sAnimation="NS2010_poor_beg";
		m_bIllusion=false;
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CMeteor] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xType="Mete";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,2);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xCharacter.DoKArc(pxArc^);
		m_xStart.DoKArc(pxArc^);
		(pxArc^) << m_vTarget;
		(pxArc^) << m_sState;
		(pxArc^) << m_bIllusion;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="Mete")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			m_xCharacter.DoKArc(pxArc^);
			m_xStart.DoKArc(pxArc^);
			(pxArc^) << m_vTarget;
			(pxArc^) << m_sState;
			if(iVersion>=2)then
				(pxArc^) << m_bIllusion;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool Init(CObjHndl p_xCharacter,vec3 p_vTarget, string p_sPath, bool p_bIllusion)
		m_sState="goto_target";
		if(!p_xCharacter.IsValid()||p_vTarget=={0.0,0.0,0.0})then
			m_sState="EndTask";
			return false;
		endif;
		m_bIllusion=p_bIllusion;
		SetSpecialActionPath(p_sPath);
		SetPrepareActionPath(p_xCharacter, p_sPath, true);
		m_xCharacter=p_xCharacter;
		m_vTarget=p_vTarget;
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		var ^CFightingObj pxFightingObj=cast<CFightingObj>(m_xCharacter.GetObj());
		if(pxFightingObj==null||!pxFightingObj^.CheckSpecialActionTimer(GetSpecialActionPath()))then
			EndTask();
			return;
		endif;
		if(m_sState=="EndTask")then
			EndTask();
		endif;
	endproc;
	
	proc void USLOnTick(int p_iTime)
		var ^CCharacter pxCharacter=cast<CCharacter>(m_xCharacter.GetObj());
		if(pxCharacter==null||m_vTarget=={0.0,0.0,0.0})then EndTask(); return; endif;
		if(m_sState=="goto_target")then
			var real fAttackRange=CMeteorite.IMPACT_RADIUS+MAGIC_RANGE;
			if(!IsInRange())then
				if(pxCharacter^.GetOnWall())then
					EndTask();
					return;
				endif;
				pxCharacter^.AdvanceAction(CObjHndl.Invalid(),fAttackRange,pxCharacter^.GetDefaultSpeed(),pxCharacter^.GetWalkSet(),5000000.0, pxCharacter^.GetPos(), m_vTarget);
			endif;
			m_sState="check_pos";
			return;
		elseif(m_sState=="check_pos")then
			if(!IsInRange())then
				EndTask();
			else
				m_sState="rotate";
			endif;
		elseif(m_sState=="rotate")then
			var vec3 vDir=m_vTarget-pxCharacter^.GetPos();
			var Quat qTRot;
			qTRot.FromXYDir(vDir.GetX(),vDir.GetY());
			pxCharacter^.RotateAction(qTRot);
			m_sState="pray";
		elseif(m_sState=="pray")then
			m_xStart=CTimeMgr.Get().GetTime();
			//pxCharacter^.SetAnim("praying_wall",3);
			pxCharacter^.SetAnim(m_sAnimation,3);
			m_sState="check_time";
//			var string sPlayerName="Unknown opponent";
//			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
//			if(pxLevel!=null)then
//				var int iOwner=pxCharacter^.GetOwner();
//				var ^CPlayer pxOwner=pxLevel^.GetPlayer(iOwner);
//				if(pxOwner!=null)then
//					sPlayerName=pxLevel^.GetLevelInfo().GetPlayerSlot(pxOwner^.GetPlayerSlotID()).GetName();
//				endif;
//				var int i=0;
//				for(i=0)cond(i<CGameBase.GetMaxPlayers())iter(i++)do
//					var ^CPlayer pxPlayer=pxLevel^.GetPlayer(i);
//					if(pxPlayer==null)then continue; endif;
//					if(cast<CAiPlayer>(pxPlayer)!=null)then continue; endif;
//					if(CSrvWrap.GetDiplomacyMgr().GetIsFriend(iOwner, i))then continue; endif;
//					CSrvWrap.SendGenericEvtToPlayer(i, "MiniMapAttack\t"+m_vTarget.ToString()+"\tCannon");
//					CFeedback.Print(i, CFeedback.ATTACK, "_MIRAGE_NT_MeteorAttack\t"+sPlayerName);
//				endfor;
//			endif;
			return;
		elseif(m_sState=="check_time")then
			if(!IsInRange())then
				EndTask();
			endif;
			if(pxCharacter^.GetCurrentAnimName()!=m_sAnimation)then
				pxCharacter^.SetAnim(m_sAnimation,3);
			endif;
			var CGameTimeSpan xDuration=7.0f;
			var CGameTime xNow=CTimeMgr.Get().GetTime();
			if((xNow - m_xStart) >= xDuration)then
				m_sState="Meteorite";
				return;
			endif;
		elseif(m_sState=="Meteorite")then
			if(!StartSpecialActionTimer(pxCharacter))then
				EndTask();
				return;
			endif;
			SetUnStoppable(true);
			var vec3 vDirection=pxCharacter^.GetPos() - m_vTarget;
			var real fDist= vDirection.Abs();
			vDirection.Normalize();
			var real fDZone=CMeteorite.IMPACT_RADIUS+MAGIC_RANGE+pxCharacter^.GetRadius();
			if(fDist <= fDZone)then
				pxCharacter^.WalkAction(m_vTarget+(vDirection*fDZone), pxCharacter^.GetMaxSpeed());
			endif;
			if(!m_bIllusion)then
				var int iOwner=-1;
				var vec3 vSpawn=m_vTarget;
				if(pxCharacter!=null)then
					vSpawn=pxCharacter^.GetPos();
					iOwner=pxCharacter^.GetOwner();
				endif;
				vSpawn.SetZ(vSpawn.GetZ()+65.0f);
				var ^CMeteorite pxMeteorite=cast<CMeteorite>(CSrvWrap.GetObjMgr()^.CreateObj("hu_meteorite",iOwner,vSpawn));
				if(pxMeteorite!=null)then
					pxMeteorite^.Set(m_vTarget, m_xCharacter, iOwner);
				endif;
			endif;
			//pxCharacter^.AnimAction("victory_1");
			m_sState="EndTask";
			return;
		elseif(m_sState=="EndTask")then
			SetUnStoppable(false);
			EndTask();
			return;
		endif;
	endproc;
	
	proc bool IsInRange()
		var ^CCharacter pxCharacter=cast<CCharacter>(m_xCharacter.GetObj());
		if(pxCharacter==null)then return false; endif;
		var real fSelfRadius=pxCharacter^.GetRadius();
		var real fAttackRange=CMeteorite.IMPACT_RADIUS+MAGIC_RANGE+fSelfRadius;
		var real fSea=CSrvWrap.GetScapeMgr().GetSeaLevel();
		var real fHeight=CSrvWrap.GetScapeMgr().GetHeight(m_vTarget.GetX(),m_vTarget.GetY());
		var vec3 vTarget=m_vTarget;
		if(fSea >= vTarget.GetZ())then
			vTarget.SetZ(fSea);
		endif;
		var real fDistance=(m_vTarget - pxCharacter^.GetPos()).Abs2S();
		return fDistance <= fAttackRange*fAttackRange;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
	endproc;
	
	export proc bool Break()
		if(GetUnStoppable())then
			return false;
		endif;
		SetPrepareActionPath(m_xCharacter, GetSpecialActionPath(), false);
		if(m_xCharacter.IsValid())then
			m_xCharacter.GetObj()^.TerminateAction();
		endif;
		return true;
	endproc;
	
	export proc void Skip()
	endproc;
	
	export proc void EndTask()
		SetPrepareActionPath(m_xCharacter, GetSpecialActionPath(), false);
		UpdateAggressionPos(m_xCharacter);
		super.EndTask();
	endproc;
	
endclass;
	
class CMirageReanim inherit CSpecialActionTask
	
	const real					SAFETY_TIME=1.5f;
	var CObjHndl				m_xCharacter;
	var CObjHndl				m_xSpirit;
	var CGameTimeSpan		m_xDuration;
	var CGameTime				m_xStart;
	var string					m_sState;
	var string					m_sNode;
	var string					m_sTTPath;
	var string					m_sClassName;
	var int							m_iRetryCounter;
	var int							m_iOwner;
	var CObjHndl				m_xPyCO;
	var bool						m_bResurrectModeActivated;
	var int							m_iSupplyCount;
	var bool						m_bEnemiesToo;
	var bool						m_bSpeedBonus;
	var real						m_fDuration;
	var bool						m_bOwnerChange;
	var real						m_fProgress;
	var real						m_fTotalLength;
	var CGameTime				m_xOriginal;
	var bool						m_bUsingPrePyCO;
	var string					m_sPyCOReplace;
	var real						m_fLastProgress;
	
	export constructor()
		SetName("MReanim");
		SetCivil(false);
		m_iRetryCounter = 0;
		m_sClassName = "";
		m_bEnemiesToo = false;
		m_bSpeedBonus = false;
		m_bOwnerChange = false;
		m_fProgress = 0.0f;
		m_sPyCOReplace = "";
		m_fLastProgress = 0.0f;
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CMirageReanim] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xType="MRnm";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xCharacter.DoKArc(pxArc^);
		m_xSpirit.DoKArc(pxArc^);
		m_xDuration.DoKArc(pxArc^);
		m_xStart.DoKArc(pxArc^);
		(pxArc^) << m_sState;
		(pxArc^) << m_sNode;
		(pxArc^) << m_sTTPath;
		(pxArc^) << m_iRetryCounter;
		(pxArc^) << m_iOwner;
		m_xPyCO.DoKArc(pxArc^);
		(pxArc^) << m_bResurrectModeActivated;
		(pxArc^) << m_iSupplyCount;
		(pxArc^) << m_bEnemiesToo;
		(pxArc^) << m_bOwnerChange;
		(pxArc^) << m_bSpeedBonus;
		(pxArc^) << m_fDuration;
		(pxArc^) << m_fProgress;
		(pxArc^) << m_fTotalLength;
		m_xOriginal.DoKArc(pxArc^);
		(pxArc^) << m_bUsingPrePyCO;
		(pxArc^) << m_sPyCOReplace;
		(pxArc^) << m_fLastProgress;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="MRnm")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			m_xCharacter.DoKArc(pxArc^);
			m_xSpirit.DoKArc(pxArc^);
			m_xDuration.DoKArc(pxArc^);
			m_xStart.DoKArc(pxArc^);
			(pxArc^) << m_sState;
			(pxArc^) << m_sNode;
			(pxArc^) << m_sTTPath;
			(pxArc^) << m_iRetryCounter;
			(pxArc^) << m_iOwner;
			m_xPyCO.DoKArc(pxArc^);
			(pxArc^) << m_bResurrectModeActivated;
			(pxArc^) << m_iSupplyCount;
			(pxArc^) << m_bEnemiesToo;
			(pxArc^) << m_bOwnerChange;
			(pxArc^) << m_bSpeedBonus;
			(pxArc^) << m_fDuration;
			(pxArc^) << m_fProgress;
			(pxArc^) << m_fTotalLength;
			m_xOriginal.DoKArc(pxArc^);
			(pxArc^) << m_bUsingPrePyCO;
			(pxArc^) << m_sPyCOReplace;
			(pxArc^) << m_fLastProgress;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void SetPyCO(CObjHndl p_xPyCO)
		m_xPyCO = p_xPyCO;
	endproc;
	
	export proc bool Init(CObjHndl p_xCharacter,CObjHndl p_xSpirit, string p_sTTPath, bool p_bEnemy, bool p_bBonus)
		m_sState="goto_target";
		var ^CMrgSprt pxSpirit=cast<CMrgSprt>(p_xSpirit.GetObj());
		if(!p_xCharacter.IsValid() || pxSpirit==null || pxSpirit^.IsDeactivated())then
			m_sState="End";
			return false;
		endif;
		m_bEnemiesToo=p_bEnemy;
		m_bSpeedBonus=p_bBonus;
		m_xCharacter = p_xCharacter;
		m_xSpirit = p_xSpirit;
		m_sTTPath = p_sTTPath;
		SetSpecialActionPath(p_sTTPath);
		var real fTimeFactor=1.0f;
		var int iActor=p_xCharacter.GetObj()^.GetOwner();
		var int iSpirit=pxSpirit^.GetSprtOwner();
		if(iActor!=iSpirit)then
			if(CSrvWrap.GetDiplomacyMgr().GetRelation(iActor, iSpirit)==2)then
				fTimeFactor=1.0;
			else
				var string sPath=pxSpirit^.GetSprtDescription();
				var int iAge=0,iEpoch=1;
				iAge=pxSpirit^.GetResearch();
				if(!GetPlayerInfos(iActor,iEpoch))then
					m_sState="End";
					return false;
				endif;
				if(iAge<=0||iAge>=7||iEpoch<iAge)then
					m_sState="End";
					return false;
				else
//					fTimeFactor=1.5f;
					fTimeFactor=1.0f;
				endif;
				iSpirit=iActor;
			endif;
		elseif(m_bSpeedBonus)then
			fTimeFactor=0.80f;
		endif;
		var string sCN=pxSpirit^.GetSprtClass();
		if(CNPCMgr.Get().CheckHero(sCN))then
			if(CNPCMgr.Get().HasNPC(sCN,iSpirit))then
				return false;
			endif;
		endif;
		pxSpirit^.AddSprtResurrecter(p_xCharacter);
		SetPrepareActionPath(p_xCharacter, p_sTTPath, true);
		m_fProgress=0.0f;
		m_fDuration=(pxSpirit^.GetResurrectDuration())*fTimeFactor;
		m_fTotalLength=m_fDuration+SAFETY_TIME;
		m_xDuration=m_fDuration;
//		m_xDuration = pxSpirit^.GetResurrectDuration();
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		if(m_sState=="End")then
			EndTask();
		endif;
	endproc;
	
	proc void USLOnTick(int p_iTime)
		var ^CCharacter pxCharacter = cast<CCharacter>(m_xCharacter.GetObj());
		var ^CMrgSprt pxSpirit=cast<CMrgSprt>(m_xSpirit.GetObj());
		if(pxCharacter==null || pxSpirit==null)then EndTask(); return; endif;
		if(pxCharacter^.GetEffectFlag(CFightingObj.EFFECT_AJE_CAMOUFLAGE))then
			pxCharacter^.SetEffectFlag(CFightingObj.EFFECT_AJE_CAMOUFLAGE, false);
		endif;
		if(m_sState == "goto_target")then
			var real fAttackRange = 25.0;
			if(!IsInRange())then
				if(pxCharacter^.GetOnWall())then
					EndTask();
					return;
				endif;
				var vec3 vSpirit = pxSpirit^.GetPos();
				vSpirit.SetZ(CSrvWrap.GetScapeMgr().GetHeight(vSpirit.GetX(), vSpirit.GetY()));
				pxCharacter^.AdvanceAction(CObjHndl.Invalid(),fAttackRange,pxCharacter^.GetDefaultSpeed(),pxCharacter^.GetWalkSet(),5000000.0, pxCharacter^.GetPos(), vSpirit);
			endif;
			m_sState = "rotate";
		elseif(m_sState == "rotate")then
			if(pxSpirit^.GetResurrectMode() || pxSpirit^.IsDeactivated())then
				pxSpirit^.RemSprtResurrecter(m_xCharacter);
				EndTask();
				return;
			endif;
			var string sCN=pxSpirit^.GetSprtClass();
			if(CNPCMgr.Get().CheckHero(sCN))then
				if(CNPCMgr.Get().HasNPC(sCN,m_iOwner))then
					pxSpirit^.RemSprtResurrecter(m_xCharacter);
					EndTask();
					return;
				endif;
			endif;
			pxSpirit^.SetResurrectMode(true,!m_bOwnerChange,m_fProgress);
			m_bResurrectModeActivated=true;
			var vec3 vDir = (pxSpirit^.GetPos()-pxCharacter^.GetPos()).GetNormalized();
			var Quat qR; qR.FromXYDir(vDir.GetX(), vDir.GetY());
			pxCharacter^.RotateAction(qR);
			m_sState="resurrect";
		elseif(m_sState == "resurrect")then
			if(!IsInRange())then
				if(m_iRetryCounter>3)then
					EndTask();
				else
					m_iRetryCounter++;
					m_sState = "goto_target";
					return;
				endif;
			else
				var int iLevel = pxSpirit^.GetSprtLevel();
				m_iOwner = pxSpirit^.GetSprtOwner();
				var int iActor=pxCharacter^.GetOwner();
				if(m_iOwner!=iActor && CSrvWrap.GetDiplomacyMgr().GetRelation(iActor, m_iOwner)!=2 && m_bEnemiesToo)then
					m_bOwnerChange=true;
					m_iOwner=iActor;
				endif;
				var ^CPlayer pxPlayer = CSrvWrap.GetCurLevel()^.GetPlayer(m_iOwner);
				if(pxPlayer==null)then
					EndTask();
					return;
				endif;
				var ^CAttribs pxPlAttr = pxPlayer^.GetAttribs();
				if(pxPlAttr==null)then
					EndTask();
					return;
				endif;
//				if(!CRequirementsMgr.Get().CheckUnits(m_iOwner,iLevel))then
				if(!CRequirementsMgr.Get().CheckUnits(m_iOwner, iLevel, true, false, m_sPyCOReplace, !pxSpirit^.GetSprtPyCO().IsValid()))then
					EndTask();
					return;
				endif;
				if(!CRequirementsMgr.Get().CheckSupply(m_iOwner, true, "dummy", iLevel, pxSpirit^.GetSprtClass(), false))then
					pxCharacter^.PayBackMana(m_sTTPath);
					EndTask();
					return;
				endif;
				if(!pxCharacter^.CheckManaAndPay(GetSpecialActionPath()))then
					EndTask();
					return;
				endif;
//				pxCharacter^.SetResurrecting(true);
				AddVirtualUnit(pxSpirit);
				m_sState = "check";
				m_xStart = CTimeMgr.Get().GetTime();
				m_xOriginal = m_xStart;
				pxCharacter^.SetAnim("praying_wall",3);
				pxSpirit^.StartReanimation(m_fDuration+SAFETY_TIME);
				return;
			endif;
		elseif(m_sState == "check")then
			var CGameTime xNow = CTimeMgr.Get().GetTime();
			var CGameTimeSpan xDiff=xNow-m_xStart;
			m_fProgress = 100.0f*(xDiff.GetSecondsF()/m_fTotalLength);
			pxSpirit^.UpdateProgress(m_fProgress);
			UpdatePyCO(m_fProgress,pxSpirit^.GetSprtProgress());
			if((xDiff)>=m_xDuration)then
				pxCharacter^.SecureResurrector();
				m_xStart=CTimeMgr.Get().GetTime();
				m_xDuration=SAFETY_TIME;
				m_sState = "EndAnim";
				return;
			endif;
		elseif(m_sState=="EndAnim")then
			var CGameTime xNow=CTimeMgr.Get().GetTime();
			var CGameTimeSpan xDiff=xNow-m_xStart;
			m_fProgress = 100.0f*((xNow-m_xOriginal).GetSecondsF()/m_fTotalLength);
			pxSpirit^.UpdateProgress(m_fProgress);
			UpdatePyCO(m_fProgress,pxSpirit^.GetSprtProgress());
			if((xDiff)>=m_xDuration)then
//				UpdatePyCO(100.0f);
//				Resurrect(pxSpirit);
				if(Resurrect(pxSpirit))then
					StartSpecialActionTimer(pxCharacter);
				endif;
				m_sState = "EndTask";
				return;
			endif;
		elseif(m_sState == "EndTask")then
			EndTask();
			return;
		endif;
	endproc;
	
	proc void AddVirtualUnit(^CMrgSprt p_pxSpirit)
		if(p_pxSpirit==null)then return; endif;
		var ^CBasePlayer pxBPl=CBasePlayer.GetPlayer(m_iOwner);
		if(pxBPl==null)then return; endif;
		if(m_bOwnerChange)then
			p_pxSpirit^.DestroyPyCO();
		endif;
		p_pxSpirit^.SetNextOwner(m_iOwner);
		var int iCount=p_pxSpirit^.GetResurrectionValue();
		var int iLevel=p_pxSpirit^.GetSprtLevel();
		var string sClassName=p_pxSpirit^.GetSprtClass();
		var int iSupplyCount = 1;
		iSupplyCount = CMirageSrvMgr.Get().GetSupply(sClassName);
		m_iSupplyCount = iSupplyCount;
		m_sNode = "virtual_units_"+iLevel.ToString();
		p_pxSpirit^.SetResurrectionValue(iCount+1);
		if(iCount<=0)then
			var ^CAttribs pxAttr=pxBPl^.GetAttribs();
			if(pxAttr!=null)then
				pxAttr^.SetValue("virtual_supply", pxAttr^.GetValueInt("virtual_supply")+iSupplyCount);
				pxAttr^.SetValue(m_sNode, pxAttr^.GetValueInt(m_sNode)+1);
			endif;
		endif;
		m_fLastProgress=p_pxSpirit^.GetLastSprtProgress();
		var ^CPyramidCardObject pxTmp = cast<CPyramidCardObject>(p_pxSpirit^.GetSprtPyCO().GetObj());
		if(pxTmp!=null)then
//			pxTmp^.StopTimer();
			pxTmp^.SetPreSpirit(false,-1);
			p_pxSpirit^.InvalidateSprtPyCO();
			m_bUsingPrePyCO=true;
		else
			pxTmp = cast<CPyramidCardObject>(CSrvWrap.GetObjMgr()^.CreateObj("pyramid_card_object",-1,p_pxSpirit^.GetPos()));
			if(pxTmp!=null)then
				var string sClass= p_pxSpirit^.GetSprtDescription();
				var ^CAttribs pxAttr = pxTmp^.GetAttribs();
				if(pxAttr!=null)then
					pxAttr^.SetValue("level", iLevel);
					pxAttr^.SetValue("hitpoints", p_pxSpirit^.GetSprtProgress());
					pxAttr^.SetValue("maxhitpoints", p_pxSpirit^.GetSprtHP());
					pxAttr^.SetValue("CurTask", "");
					pxAttr^.SetValue("clientpyramid_slotid", -1);
					pxAttr^.SetValue("ObjPath", sClass);
					pxAttr^.SetValue("dead", true);
					pxAttr^.SetValue("TaskDescription", "");
					pxAttr^.SetValue("clientpyramid_replacecard", m_sPyCOReplace);
					pxAttr^.SetValue("unit_count", true);
					pxAttr^.SetValue("vertical_fill", 0);
					pxAttr^.SetValue("is_spirit", 1);
				endif;
				pxTmp^.InitTechTreeDef();
				var ^CTechTreeDef pxTTDef = pxTmp^.GetTechTreeDef();
				if(pxTTDef!=null)then
					var array string asTTFilters;
					p_pxSpirit^.GetTTFilters(asTTFilters);
					var int i, iC = asTTFilters.NumEntries();
					for(i=0)cond(i<iC)iter(i++) do
						pxTTDef^.EnableFilter(asTTFilters[i]);
					endfor;
				endif;
				pxTmp^.SetOwner(m_iOwner);
			endif;
		endif;
		m_xPyCO=pxTmp^.GetHandle();
		pxTmp^.SetResurectMod(m_iOwner,-1,m_sNode,m_iSupplyCount,m_fDuration);
	endproc;
	
	proc bool IsInRange()
		if(CMirageSrvMgr.Get().GlobalReanim())then return true; endif;
		var ^CCharacter pxCharacter = cast<CCharacter>(m_xCharacter.GetObj());
		var ^CMrgSprt pxSpirit=cast<CMrgSprt>(m_xSpirit.GetObj());
		if(pxCharacter==null || pxSpirit==null)then return false; endif;
		var vec3 vSpirit = pxSpirit^.GetPos();
		vSpirit.SetZ(CSrvWrap.GetScapeMgr().GetHeight(vSpirit.GetX(), vSpirit.GetY()));
		var real fTargetRadius = pxSpirit^.GetRadius();
		var real fAttackRange = 27.0; //pxCharacter^.GetAttackRange();
		var real fDistance = (vSpirit - pxCharacter^.GetPos()).Abs2S();
		return fDistance <= (fAttackRange+fTargetRadius)*(fAttackRange+fTargetRadius);
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
		if(m_xCharacter.IsValid())then
			if(m_sState!="EndTask")then
				var ^CFightingObj pxFO = cast<CFightingObj>(m_xCharacter.GetObj());
				if(pxFO!=null)then
					pxFO^.ResetSpecialActionTimer(m_sTTPath);
				endif;
				var ^CMrgSprt pxSpirit=cast<CMrgSprt>(m_xSpirit.GetObj());
				if(pxSpirit!=null)then
					if(m_bUsingPrePyCO)then
						pxSpirit^.SetSprtPyCO(m_xPyCO);
					endif;
					pxSpirit^.RemSprtResurrecter(m_xCharacter);
					if(m_bResurrectModeActivated)then
						//release resurrect mode -> others can resurrect now
						pxSpirit^.SetResurrectMode(false,!m_bOwnerChange,m_fProgress);
						m_bResurrectModeActivated=false;
					endif;
				endif;
			endif;
		endif;
	endproc;
	
	proc void Reset()
		var ^CMrgSprt pxSpirit=cast<CMrgSprt>(m_xSpirit.GetObj());
		var int iCount=-1;
		if(pxSpirit!=null)then
			iCount=pxSpirit^.GetResurrectionValue();
			pxSpirit^.SetResurrectionValue(iCount-1);
		endif;
		if(iCount==1)then
			var ^CPyramidCardObject pxTmp = cast<CPyramidCardObject>(m_xPyCO.GetObj());
			if(pxTmp!=null)then
				pxTmp^.StopTimer();
			endif;
			if(m_xPyCO.IsValid())then
				if(m_bUsingPrePyCO&&(m_sState=="check"||m_sState=="EndAnim"))then
//					UpdatePyCO(0.0f);
					pxSpirit^.SetSprtPyCO(m_xPyCO);
				else
					CSrvWrap.GetObjMgr()^.DeleteObject(m_xPyCO.GetObj());
				endif;
			endif;
			var ^CPlayer pxPlayer=CSrvWrap.GetCurLevel()^.GetPlayer(m_iOwner);
			if(pxPlayer==null)then return; endif;
			var ^CAttribs pxPlAttr=pxPlayer^.GetAttribs();
			if(pxPlAttr==null)then return; endif;
			pxPlAttr^.SetValue("virtual_supply", pxPlAttr^.GetValueInt("virtual_supply")-m_iSupplyCount);
			pxPlAttr^.SetValue(m_sNode, pxPlAttr^.GetValueInt(m_sNode)-1);
		endif;
	endproc;
	
	export proc bool Break()
		if(m_sState == "EndAnim")then
			return false;
		endif;
		SetPrepareActionPath(m_xCharacter, GetSpecialActionPath(), false);
		if(m_xCharacter.IsValid())then
			m_xCharacter.GetObj()^.TerminateAction();
		endif;
		if(m_sState == "check"||m_sState == "EndAnim")then
			Reset();
		elseif(m_sState == "abort")then
			Reset();
			var ^CMrgSprt pxSpirit=cast<CMrgSprt>(m_xSpirit.GetObj());
			if(pxSpirit!=null)then
				pxSpirit^.Kill();
			endif;
			m_sState == "EndTask";
			EndTask();
		endif;
		return true;
	endproc;
	
	export proc void Skip()
	endproc;
	
	export proc bool Resurrect(^CMrgSprt p_pxSpirit)
		var string sClassName=p_pxSpirit^.GetSprtClass();
		var int iOwner=m_iOwner;
		if(CNPCMgr.Get().CheckHero(sClassName))then
			if(CNPCMgr.Get().HasNPC(sClassName,iOwner))then
				m_sState="abort";
				Break();
				return false;
			endif;
		endif;
		var ^CPlayer pxPlayer = CSrvWrap.GetCurLevel()^.GetPlayer(m_iOwner);
		if(pxPlayer==null)then return false; endif;
		var ^CAttribs pxPlAttr = pxPlayer^.GetAttribs();
		if(pxPlAttr==null)then return false; endif;
		var ^CTechTreeDef pxPlrTTDef = ^(pxPlayer^.GetPlayerTechTreeDef());
		if(pxPlrTTDef==null)then return false; endif;
		var ^CPyramidCardObject pxTmp = cast<CPyramidCardObject>(m_xPyCO.GetObj());
		if(pxTmp!=null)then
			pxTmp^.StopTimer();
		endif;
		pxPlAttr^.SetValue("virtual_supply", pxPlAttr^.GetValueInt("virtual_supply")-m_iSupplyCount);
		pxPlAttr^.SetValue(m_sNode, pxPlAttr^.GetValueInt(m_sNode)-1);
		m_sClassName=sClassName;
		var vec3 vPos=p_pxSpirit^.GetSprtPos(), vRot=p_pxSpirit^.GetRotation();
		var bool bFound = false;
		p_pxSpirit^.GetProperties(bFound,vPos, vRot);
		var int iLevel=p_pxSpirit^.GetSprtLevel();
		var ^CGameObj pxObj=CSrvWrap.GetObjMgr()^.CreateObj(sClassName,iOwner,vPos,vRot);
		if(m_xPyCO.IsValid() && pxObj!=null)then
			var ^CAttribs pxAT=pxObj^.GetAttribs();
			if(pxAT!=null)then
				pxAT^.SetValue("clientpyramid_replacecard", m_xPyCO.GetObj()^.GetName());
			endif;
		endif;
		var ^CFightingObj pxFO = cast<CFightingObj>(pxObj);
		if(pxFO!=null)then
//			pxFO^.SetRot(p_pxSpirit^.GetSprtRot());
			var vec3 vTmp = pxFO^.GetPos();
//			vTmp.SetZ(Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vTmp.GetX(),vTmp.GetY()),CSrvWrap.GetScapeMgr().GetSeaLevel()));
			pxFO^.AddFlyingHeight(vTmp,12.0f);
			pxFO^.Reanimated(bFound);
//			pxFO^.Reanimated(true);
			var int iKC,iKH,iAS;
			pxFO^.SetLevelClean(iLevel);
			// Henry: statictic didn't get updated after resurrection...
			CSrvWrap.GetCurLevel()^.GetStatisticMgr().AddUnit(pxFO^.GetOwner(), pxFO^.GetClassName(), pxFO^.GetType(), 1);
			var ^CTechTreeDef pxTTDef = pxFO^.GetTechTreeDef();
			if(pxTTDef!=null)then
				var array string asTTFilters;
				var array string asTTDisFilters;
				p_pxSpirit^.GetTTFilters(asTTFilters);
				var int i, iC=pxTTDef^.NumEntries();
				for(i=0)cond(i<iC)iter(i++)do
					var string sFilter=pxTTDef^.GetFilter(i);
					if(asTTFilters.FindEntry(sFilter)==-1)then
						asTTDisFilters.AddEntry(sFilter);
					endif;
				endfor;
				iC=asTTDisFilters.NumEntries();
				for(i=0)cond(i<iC)iter(i++)do
					pxTTDef^.DisableFilter(asTTDisFilters[i]);
				endfor;
				iC = asTTFilters.NumEntries();
				for(i=0) cond(i<iC) iter(i++) do
					if(asTTFilters[i].Find("_RemoveMe")==-1 && !pxPlrTTDef^.HasFilter(asTTFilters[i]))then
						pxTTDef^.EnableFilter(asTTFilters[i]);
					endif;
				endfor;
			endif;
			if(m_xPyCO.IsValid())then
				CSrvWrap.GetObjMgr()^.DeleteObject(m_xPyCO.GetObj());
			endif;
			var string sIDs,sDurs,sStarts,sDeath;
			p_pxSpirit^.DeleteSprt(iKC,iKH,sIDs,sDurs,sStarts,sDeath,iAS);
			pxFO^.SetKillerNumbers(iKC,iKH);
			pxFO^.SetAggressionState(iAS);
			if(sIDs!="")then
				var array string asIDs, asDurs, asStarts;
				sIDs.Split(asIDs, "|", true);
				sDurs.Split(asDurs, "|", true);
				sStarts.Split(asStarts, "|", true);
				var CGameTime xDeath, xStart;
				xDeath.FromString(sDeath);
				var CGameTimeSpan xSpan=(CTimeMgr.Get().GetTime()-xDeath);
				var int i,iC=asIDs.NumEntries();
				if(iC==asDurs.NumEntries()&&iC==asStarts.NumEntries())then
					for(i=0)cond(i<iC)iter(i++)do
						var CTechTree xTT=pxFO^.GetTechTree();
						var ^CTechTree.CNode pxAction=xTT.FindNode(CTechTree.GetPathHashPath(asIDs[i].ToInt()));
						if(pxAction!=null)then
							xStart.FromString(asStarts[i]);
							xStart+=xSpan;
							pxFO^.AddSpecialActionTimerPrecisely(pxAction^.GetAbsPath(),xStart,asDurs[i].ToReal());
						endif;
					endfor;
				endif;
			endif;
			if(CheckifHero(sClassName))then
				CNPCMgr.Get().AddNPC(iOwner, pxFO^.GetHandle());
			endif;
		endif;
		m_sNode = "virtual_units_"+iLevel.ToString();
		var ^CAttribs pxAttr=CSrvWrap.GetCurLevel()^.GetPlayer(m_iOwner)^.GetAttribs();
		//pxFO^.SetEnergy(0.0);
		return true;
	endproc;
	
	export proc void EndTask()
		SetPrepareActionPath(m_xCharacter, GetSpecialActionPath(), false);
		UpdateAggressionPos(m_xCharacter);
		super.EndTask();
	endproc;
	
	proc bool CheckifHero(string p_sClassName)
		if(p_sClassName=="Stina_s0"||p_sClassName=="Bela_s0"||p_sClassName=="Cole_s0"||p_sClassName=="special_eusmilus"
		||p_sClassName=="mayor_s0"||p_sClassName=="darwin_s0"||p_sClassName=="tesla_s0"||p_sClassName=="babbage_s0"
		||p_sClassName=="hermit_s0"||p_sClassName=="lovelace_s0"||p_sClassName=="schliemann_s0"||p_sClassName=="livingstone_s0"
		||p_sClassName=="Miyagi_s0"||p_sClassName=="Tarna_s0"||p_sClassName=="Larry_s0")then
			return true;
		endif;
		return false;
	endproc;
	
	export proc bool GetPlayerInfos(int p_iID,ref int p_riAge)
		var ^CBasePlayer pxP=CBasePlayer.GetPlayer(p_iID);
		if(pxP==null)then return false; endif;
		var ^CAttribs pxA=pxP^.GetAttribs();
		if(pxA==null)then return false; endif;
		p_riAge=pxA^.GetValueInt("age");
		if(pxA^.GetValueInt("final")==6)then
			p_riAge=6;
		endif;
		return true;
	endproc;
	
	export proc void UpdatePyCO(real p_fTaskProcess, int p_iSprtProgress)
		if(m_xPyCO.IsValid())then
			var ^CPyramidCardObject pxTmp = cast<CPyramidCardObject>(m_xPyCO.GetObj());
			if(pxTmp!=null)then
				var ^CAttribs pxAttr = pxTmp^.GetAttribs();
				var real fToFill=(100.0f-m_fLastProgress);
				var real fNew=(fToFill*(p_fTaskProcess/100.0f));
				if(pxAttr!=null)then
//					pxAttr^.SetValue("CurProcess",p_fTaskProcess.ToInt());
					pxAttr^.SetValue("CurProcess",(fNew+m_fLastProgress).ToInt());
					pxAttr^.SetValue("hitpoints",p_iSprtProgress);
				endif;
			endif;
		endif;
	endproc;
	
endclass;
	
class CParasites inherit CSpecialActionTask
	
	var CObjHndl		m_xCharacter;
	var CObjHndl		m_xTarget;
	var string			m_sState;
	var int					m_iRetryCounter;
	
	var array string	m_asValidTargets;
	
	export constructor()
		SetName("Parasites");
		m_asValidTargets.AddEntry("ANML");
		m_asValidTargets.AddEntry("CHTR");
		m_asValidTargets.AddEntry("SHIP");
		m_asValidTargets.AddEntry("VHCL");
		SetCivil(false);
		m_iRetryCounter=0;
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CParasites] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xType="PaRi";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xCharacter.DoKArc(pxArc^);
		m_xTarget.DoKArc(pxArc^);
		(pxArc^) << m_sState;
		(pxArc^) << m_iRetryCounter;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="PaRi")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xCharacter.DoKArc(pxArc^);
			m_xTarget.DoKArc(pxArc^);
			(pxArc^) << m_sState;
			(pxArc^) << m_iRetryCounter;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool Init(CObjHndl p_xCharacter, CObjHndl p_xTarget, string p_sPath)
		m_sState="goto_target";
		if(!p_xCharacter.IsValid()||!p_xTarget.IsValid())then
			m_sState="EndTask";
			return false;
		endif;
		if(m_asValidTargets.FindEntry(p_xTarget.GetObj()^.GetType().AsString())==-1)then
			m_sState="EndTask";
			return false;
		endif;
		SetSpecialActionPath(p_sPath);
		SetPrepareActionPath(p_xCharacter, p_sPath, true);
		m_xCharacter=p_xCharacter;
		m_xTarget=p_xTarget;
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		var ^CFightingObj pxFightingObj=cast<CFightingObj>(m_xCharacter.GetObj());
		if(pxFightingObj==null||!pxFightingObj^.CheckSpecialActionTimer(GetSpecialActionPath()))then
			EndTask();
			return;
		endif;
		if(m_sState=="EndTask")then
			EndTask();
		endif;
	endproc;
	
	proc void USLOnTick(int p_iTime)
		var ^CCharacter pxCharacter=cast<CCharacter>(m_xCharacter.GetObj());
		var ^CGameObj pxTarget=m_xTarget.GetObj();
		if(pxCharacter==null||pxTarget==null)then EndTask(); return; endif;
		if(m_sState=="goto_target")then
			var real fAttackRange=30.0;
			if(!IsInRange())then
				if(pxCharacter^.GetOnWall())then
					EndTask();return;
				endif;
				pxCharacter^.AdvanceAction(pxTarget^.GetHandle(),fAttackRange, pxCharacter^.GetMaxSpeed());
			endif;
			m_sState="throw";
		elseif(m_sState=="throw")then
			if(!IsInRange())then
				if(m_iRetryCounter>3)then
					EndTask();
				else
					m_iRetryCounter++;
					m_sState="goto_target";
					return;
				endif;
			else
				SetUnStoppable(true);
				if(!StartSpecialActionTimer(pxCharacter))then EndTask(); return; endif;
				var ^CParasite pxParasite=cast<CParasite>(CSrvWrap.GetObjMgr()^.CreateObj("seas_parasite",pxCharacter^.GetOwner(),pxCharacter^.GetPos()));
				if(pxParasite!=null)then
					pxCharacter^.AnimAction("tec_sm_cocktail");
					//pxCharacter^.AnimAction("nat_throw");
					pxParasite^.Set(m_xTarget);
					CSoundEvent.PlayAll("FX_CParasite",1,pxCharacter^.GetPos());
				endif;
				m_sState="EndTask";
				return;
			endif;
		elseif(m_sState=="EndTask")then
			SetUnStoppable(false);
			EndTask();
			return;
		endif;
	endproc;
	
	proc bool IsInRange()
		var ^CCharacter pxCharacter=cast<CCharacter>(m_xCharacter.GetObj());
		var ^CGameObj pxTarget=m_xTarget.GetObj();
		if(pxCharacter==null||pxTarget==null)then return false; endif;
		var real fTargetRadius=pxTarget^.GetRadius();
		var real fSelfRadius=pxCharacter^.GetRadius();
		var real fAttackRange=30.0+fSelfRadius+fTargetRadius;
		var real fDistance=(pxTarget^.GetPos() - pxCharacter^.GetPos()).Abs2S();
		return fDistance <= fAttackRange*fAttackRange;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
	endproc;
	
	export proc bool Break()
		if(GetUnStoppable())then
			return false;
		endif;
		SetPrepareActionPath(m_xCharacter, GetSpecialActionPath(), false);
		if(m_xCharacter.IsValid())then
			m_xCharacter.GetObj()^.TerminateAction();
		endif;
		return true;
	endproc;
	
	export proc void Skip()
	endproc;
	
	export proc void EndTask()
		SetPrepareActionPath(m_xCharacter, GetSpecialActionPath(), false);
		UpdateAggressionPos(m_xCharacter);
		super.EndTask();
	endproc;
	
endclass;
	
class CPeaceGong inherit CSpecialActionTask
	
	var CObjHndl			m_xCharacter;
	var CObjHndl			m_xTarget;
	var string				m_sState;
	var CGameTime			m_xStart;
	
	export constructor()
		SetName("PeaceGong");
		SetCivil(false);
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CPeaceGong] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xType="PeGo";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xCharacter.DoKArc(pxArc^);
		m_xTarget.DoKArc(pxArc^);
		m_xStart.DoKArc(pxArc^);
		(pxArc^) << m_sState;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="PeGo")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xCharacter.DoKArc(pxArc^);
			m_xTarget.DoKArc(pxArc^);
			m_xStart.DoKArc(pxArc^);
			(pxArc^) << m_sState;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool Init(CObjHndl p_xCharacter, CObjHndl p_xTarget, string p_sPath)
		m_sState="goto_target";
		if(!p_xCharacter.IsValid()||!p_xTarget.IsValid())then
			m_sState="EndTask";
			return false;
		endif;
		SetSpecialActionPath(p_sPath);
		SetPrepareActionPath(p_xCharacter, p_sPath, true);
		m_xCharacter=p_xCharacter;
		m_xTarget=p_xTarget;
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		var ^CFightingObj pxFightingObj=cast<CFightingObj>(m_xCharacter.GetObj());
		var ^CFightingObj pxTarget=cast<CFightingObj>(m_xTarget.GetObj());
		if(pxFightingObj==null||pxTarget==null||!pxFightingObj^.CheckSpecialActionTimer(GetSpecialActionPath()))then
			EndTask();
			return;
		endif;
		if(m_sState=="EndTask")then
			EndTask();
		endif;
	endproc;
	
	proc void USLOnTick(int p_iTime)
		var ^CCharacter pxCharacter=cast<CCharacter>(m_xCharacter.GetObj());
		var ^CFightingObj pxTarget=cast<CFightingObj>(m_xTarget.GetObj());
		if(pxCharacter==null||pxTarget==null)then EndTask(); return; endif;
		if(m_sState=="goto_target")then
			var real fAttackRange=Math.Max(pxCharacter^.GetHealingRadius(),15.0);
			if(!IsInRange())then
				if(pxCharacter^.GetOnWall())then
					EndTask();return;
				endif;
				pxCharacter^.AdvanceAction(m_xTarget,fAttackRange, pxCharacter^.GetMaxSpeed());
			endif;
			m_sState="perform_magic";
		elseif(m_sState=="perform_magic")then
			m_xStart=CTimeMgr.Get().GetTime();
//			pxCharacter^.SetAnim("thanking",3);
			pxCharacter^.SetAnim("affirming_intense",3);
			m_sState="check_time";
			return;
		elseif(m_sState=="check_time")then
			var CGameTimeSpan xDuration=3.0f;
			var CGameTime xNow=CTimeMgr.Get().GetTime();
			if((xNow - m_xStart) >= xDuration)then
				m_sState="gong";
				return;
			endif;
		elseif(m_sState=="gong")then
			SetUnStoppable(true);
			if(!StartSpecialActionTimer(pxCharacter))then EndTask(); return; endif;
			var real fDuration=10.0f;
			pxTarget^.SetPeaceTime(true,fDuration);
			CSoundEvent.PlayAll("FX_CPeace_Gong",1,pxCharacter^.GetPos());
			m_sState="EndTask";
			return;
		elseif(m_sState=="EndTask")then
			SetUnStoppable(false);
			EndTask();
			return;
		endif;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
	endproc;
	
	proc bool IsInRange()
		if(m_xCharacter.IsValid()&&m_xCharacter==m_xTarget)then return true; endif;
		var ^CCharacter pxCharacter=cast<CCharacter>(m_xCharacter.GetObj());
		var ^CGameObj pxTarget=m_xTarget.GetObj();
		if(pxCharacter==null||pxTarget==null)then return false; endif;
		var real fTargetRadius=pxTarget^.GetRadius();
		var real fSelfRadius=pxCharacter^.GetRadius();
		var real fAttackRange=Math.Max(pxCharacter^.GetHealingRadius(),15.0)+fSelfRadius+fTargetRadius;
		var real fDistance=(pxTarget^.GetPos() - pxCharacter^.GetPos()).Abs2S();
		return fDistance <= fAttackRange*fAttackRange;
	endproc;
	
	export proc bool Break()
		if(GetUnStoppable())then
			return false;
		endif;
		SetPrepareActionPath(m_xCharacter, GetSpecialActionPath(), false);
		if(m_xCharacter.IsValid())then
			m_xCharacter.GetObj()^.TerminateAction();
		endif;
		return true;
	endproc;
	
	export proc void Skip()
	endproc;
	
	export proc void EndTask()
		SetPrepareActionPath(m_xCharacter, GetSpecialActionPath(), false);
		UpdateAggressionPos(m_xCharacter);
		super.EndTask();
	endproc;
	
endclass;
	
class CReanimation inherit CSpecialActionTask
	
	const real				SAFETY_TIME=1.5f;
	var CObjHndl			m_xCharacter;
	var int						m_iSpiritHandle;
	var string				m_sState;
	var string				m_sNode;
	var string				m_sTTPath;
	var string				m_sClassName;
	var int						m_iRetryCounter;
	var int						m_iOwner;
	var CObjHndl			m_xPyCO;
	var bool					m_bResurrectModeActivated;
	var int						m_iSupplyCount;
	var CGameTimeSpan	m_xDuration;
	var CGameTime			m_xStart;
	var bool					m_bLoadBreak;
	var real					m_fProgress;
	var real					m_fTotalLength;
	var CGameTime			m_xOriginal;
	var int						m_iSpiritMaxHP;
	
	export constructor()
		m_iSpiritHandle=-1;
		SetName("Reanimation");
		SetCivil(false);
		m_iRetryCounter=0;
		m_iSpiritMaxHP=0;
		m_sClassName= "";
		//m_iSupplyCount=1;
		m_fProgress = 0.0f;
		m_bLoadBreak = false;
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CReanimation] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xType="ReAn";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,2);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xCharacter.DoKArc(pxArc^);
		m_xDuration.DoKArc(pxArc^);
		m_xStart.DoKArc(pxArc^);
		(pxArc^) << m_iSpiritHandle;
		(pxArc^) << m_sState;
		(pxArc^) << m_sNode;
		(pxArc^) << m_sTTPath;
		(pxArc^) << m_iRetryCounter;
		(pxArc^) << m_iOwner;
		(pxArc^) << m_iSupplyCount;
		m_xPyCO.DoKArc(pxArc^);
		(pxArc^) << m_bResurrectModeActivated;
		(pxArc^) << m_fProgress;
		(pxArc^) << m_fTotalLength;
		m_xOriginal.DoKArc(pxArc^);
		(pxArc^) << m_iSpiritMaxHP;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="ReAn")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			m_xCharacter.DoKArc(pxArc^);
			m_xDuration.DoKArc(pxArc^);
			m_xStart.DoKArc(pxArc^);
			(pxArc^) << m_iSpiritHandle;
			(pxArc^) << m_sState;
			(pxArc^) << m_sNode;
			(pxArc^) << m_sTTPath;
			(pxArc^) << m_iRetryCounter;
			(pxArc^) << m_iOwner;
			(pxArc^) << m_iSupplyCount;
			m_xPyCO.DoKArc(pxArc^);
			(pxArc^) << m_bResurrectModeActivated;
			if(iVersion>=2)then
				(pxArc^) << m_fProgress;
				(pxArc^) << m_fTotalLength;
				m_xOriginal.DoKArc(pxArc^);
				(pxArc^) << m_iSpiritMaxHP;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
		m_bLoadBreak=true;
	endproc;
	
	export proc void SetPyCO(CObjHndl p_xPyCO)
		m_xPyCO=p_xPyCO;
	endproc;
	
	export proc bool Init(CObjHndl p_xCharacter,int p_iSpiritHandle, string p_sTTPath)
		m_sState="goto_target";
		var ^CSpirit pxSpirit=CSrvWrap.GetSpiritMgr().GetSpirit(p_iSpiritHandle);
		if(!p_xCharacter.IsValid()||pxSpirit==null)then
			m_sState="End";
			return false;
		endif;
		pxSpirit^.AddResurrecter();
		m_xCharacter=p_xCharacter;
		m_iSpiritHandle=p_iSpiritHandle;
		m_sTTPath=p_sTTPath;
		SetSpecialActionPath(p_sTTPath);
		var real fTimeFactor=0.85;
		var int iActor=p_xCharacter.GetObj()^.GetOwner();
		var int iSpirit=pxSpirit^.GetOwner();
		if(iActor!=iSpirit)then
			if(CSrvWrap.GetDiplomacyMgr().GetRelation(iActor, iSpirit)==2)then
				fTimeFactor=1.0;
			else
				var string sPath=pxSpirit^.GetDescription();
				var int iAge=0,iEpoch=1;
				var CTechTree xTT=p_xCharacter.GetObj()^.GetTechTree();
				var ^CTechTree.CNode pxPath=xTT.FindNode(sPath);
				if(pxPath==null)then
					m_sState="End";
					return false;
				else
					iAge = pxPath^.GetSubValueI("research",0);
				endif;
				if(!GetPlayerInfos(iActor,iEpoch))then
					m_sState="End";
					return false;
				endif;
				if(iAge<=0||iAge>=7||iEpoch<iAge)then
					m_sState="End";
					return false;
				else
					fTimeFactor=3.0;
				endif;
			endif;
		endif;
		SetPrepareActionPath(p_xCharacter, p_sTTPath, true);
		m_fProgress=0.0f;
		var real fDuration=(pxSpirit^.GetResurrectDuration())*fTimeFactor;
		m_xDuration=fDuration;
		m_fTotalLength=fDuration+SAFETY_TIME;
//		var real fDuration=(pxSpirit^.GetResurrectDuration())/1.5;
//		m_xDuration=(pxSpirit^.GetResurrectDuration());
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		if(m_sState=="End")then
			EndTask();
		endif;
	endproc;
	
	proc void USLOnTick(int p_iTime)
		if(m_bLoadBreak)then
			Break();
			return;
		endif;
		var ^CCharacter pxCharacter=cast<CCharacter>(m_xCharacter.GetObj());
		var ^CSpirit pxSpirit=CSrvWrap.GetSpiritMgr().GetSpirit(m_iSpiritHandle);
		if(pxCharacter==null||pxSpirit==null)then EndTask(); return; endif;
		if(m_sState=="goto_target")then
			var real fAttackRange=40.0;
			if(pxCharacter^.GetClassName()=="aje_shaman")then
				fAttackRange+=pxCharacter^.GetMiscValueTT("Shaman_Cast_Reanimation");
			endif;
			if(!IsInRange())then
				if(pxCharacter^.GetOnWall())then
					EndTask();
					return;
				endif;
				var vec3 vSpirit=pxSpirit^.GetPos();
				vSpirit.SetZ(CSrvWrap.GetScapeMgr().GetHeight(vSpirit.GetX(), vSpirit.GetY()));
				pxCharacter^.AdvanceAction(CObjHndl.Invalid(),fAttackRange,pxCharacter^.GetMaxSpeed(),pxCharacter^.GetWalkSet(),5000000.0, pxCharacter^.GetPos(), vSpirit);
			endif;
			m_sState="spirit_check";
		elseif(m_sState=="spirit_check")then
			if(pxSpirit^.GetRessurectMode())then
				//somebody is already resurrecting this one
				EndTask();
				return;
			endif;
			pxSpirit^.SetRessurectMode(true);
			m_bResurrectModeActivated=true;
			var vec3 vDir=(pxSpirit^.GetPos()-pxCharacter^.GetPos()).GetNormalized();
			var Quat qR; qR.FromXYDir(vDir.GetX(), vDir.GetY());
			pxCharacter^.RotateAction(qR);
			m_sState="resurrect";
		elseif(m_sState=="resurrect")then
			if(!IsInRange())then
				if(m_iRetryCounter>3)then
					EndTask();
				else
					m_iRetryCounter++;
					m_sState="goto_target";
					return;
				endif;
			else
				var int iLevel=pxSpirit^.GetLevel();
				var int iActor=pxCharacter^.GetOwner();
				m_iOwner=pxSpirit^.GetOwner();
				if(m_iOwner!=pxCharacter^.GetOwner() && CSrvWrap.GetDiplomacyMgr().GetRelation(iActor, m_iOwner)!=2)then
					m_iOwner=iActor;
				endif;
				var ^CPlayer pxPlayer=CSrvWrap.GetCurLevel()^.GetPlayer(m_iOwner);
				if(pxPlayer==null)then
					EndTask();
					return;
				endif;
				var ^CAttribs pxPlAttr=pxPlayer^.GetAttribs();
				if(pxPlAttr==null)then
					EndTask();
					return;
				endif;
				if(!CRequirementsMgr.Get().CheckUnits(m_iOwner,iLevel))then
					EndTask();
					return;
				endif;
				if(!CRequirementsMgr.Get().CheckSupply(m_iOwner, true, "dummy", iLevel, pxSpirit^.GetClass(), false))then
					pxCharacter^.PayBackMana(m_sTTPath);
					EndTask();
					return;
				endif;
				m_sState="check";
//				pxCharacter^.SetResurrecting(true);
				AddVirtualUnit(pxSpirit);
				m_xStart=CTimeMgr.Get().GetTime();
				pxCharacter^.SetAnim("praying_wall",3);
				return;
			endif;
		elseif(m_sState=="check")then
			var CGameTime xNow=CTimeMgr.Get().GetTime();
			var CGameTimeSpan xDiff=xNow-m_xStart;
			m_fProgress = 100.0f*(xDiff.GetSecondsF()/m_fTotalLength);
			UpdatePyCO(m_fProgress);
			if((xDiff)>=m_xDuration)then
				pxCharacter^.SetAnim("standanim",3);
				pxCharacter^.SecureResurrector();
				m_xStart=CTimeMgr.Get().GetTime();
				m_xDuration=SAFETY_TIME;
				m_sState="revive";
				return;
			endif;
		elseif(m_sState=="revive")then
			var CGameTime xNow=CTimeMgr.Get().GetTime();
			m_fProgress = 100.0f*((xNow-m_xOriginal).GetSecondsF()/m_fTotalLength);
			UpdatePyCO(m_fProgress);
			if((xNow-m_xStart)>=m_xDuration)then
//				Resurrect(pxSpirit);
				if(Resurrect(pxSpirit))then
					StartSpecialActionTimer(pxCharacter);
				endif;
				StartSpecialActionTimer(pxCharacter);
				m_sState="EndTask";
			endif;
			return;
		elseif(m_sState=="EndTask")then
			EndTask();
			return;
		endif;
	endproc;
	
	proc void AddVirtualUnit(^CSpirit p_pxSpirit)
		if(p_pxSpirit==null)then return; endif;
		var ^CBasePlayer pxBPl=CBasePlayer.GetPlayer(m_iOwner);
		if(pxBPl==null)then return; endif;
		var int iCount=p_pxSpirit^.GetRessurectionValue();
		var int iLevel=p_pxSpirit^.GetLevel();
		var string sClassName=p_pxSpirit^.GetClass();
		var int iSupplyCount = 1;
		iSupplyCount = CMirageSrvMgr.Get().GetSupply(sClassName);
		m_iSupplyCount = iSupplyCount;
		m_sNode = "virtual_units_"+iLevel.ToString();
		if(iCount<=0)then
			var ^CAttribs pxAttr=pxBPl^.GetAttribs();
			if(pxAttr!=null)then
				pxAttr^.SetValue("virtual_supply", pxAttr^.GetValueInt("virtual_supply")+iSupplyCount);
				pxAttr^.SetValue(m_sNode, pxAttr^.GetValueInt(m_sNode)+1);
			endif;
		endif;
		p_pxSpirit^.SetRessurectionValue(iCount+1);
		m_iSpiritMaxHP=p_pxSpirit^.GetMaxHP();
		var ^CPyramidCardObject pxTmp=cast<CPyramidCardObject>(CSrvWrap.GetObjMgr()^.CreateObj("pyramid_card_object",-1,p_pxSpirit^.GetPos()));
		if(pxTmp!=null)then
			var string sClass=p_pxSpirit^.GetDescription();
			var ^CAttribs pxAttr=pxTmp^.GetAttribs();
			if(pxAttr!=null)then
				pxAttr^.SetValue("level", iLevel);
				pxAttr^.SetValue("hitpoints", 0);
				pxAttr^.SetValue("maxhitpoints", m_iSpiritMaxHP);
				pxAttr^.SetValue("CurTask", "");
				pxAttr^.SetValue("clientpyramid_slotid", -1);
				pxAttr^.SetValue("ObjPath", sClass);
				pxAttr^.SetValue("dead", true);
				pxAttr^.SetValue("TaskDescription", "");
				pxAttr^.SetValue("unit_count", true);
				pxAttr^.SetValue("vertical_fill", 0);
				pxAttr^.SetValue("is_spirit", 1);
			endif;
			pxTmp^.InitTechTreeDef();
			var ^CTechTreeDef pxTTDef=pxTmp^.GetTechTreeDef();
			if(pxTTDef!=null)then
				var CStringArray asTTFilters;
				p_pxSpirit^.GetTTFilters(asTTFilters);
				var int i, iC=asTTFilters.NumEntries();
				for(i=0) cond(i<iC) iter(i++)do
					pxTTDef^.EnableFilter(asTTFilters[i]);
				endfor;
			endif;
			pxTmp^.SetOwner(m_iOwner);
			m_xPyCO=pxTmp^.GetHandle();
			pxTmp^.SetResurectMod(m_iOwner,m_iSpiritHandle,m_sNode,m_iSupplyCount,m_xDuration.GetSecondsF());
		endif;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
		if(m_xCharacter.IsValid())then
			if(m_sState!="EndTask")then
				var ^CFightingObj pxFO=cast<CFightingObj>(m_xCharacter.GetObj());
				if(pxFO!=null)then
					pxFO^.ResetSpecialActionTimer(m_sTTPath);
				endif;
				var ^CSpirit pxSpirit=CSrvWrap.GetSpiritMgr().GetSpirit(m_iSpiritHandle);
				if(pxSpirit!=null)then
					pxSpirit^.RemResurrecter();
					if(m_bResurrectModeActivated)then
						//release resurrect mode -> others can resurrect now
						pxSpirit^.SetRessurectMode(false);
						m_bResurrectModeActivated=false;
					endif;
				endif;
			endif;
		endif;
	endproc;
	
	proc void Reset()
		var ^CSpirit pxSpirit=CSrvWrap.GetSpiritMgr().GetSpirit(m_iSpiritHandle);
		var int iCount=-1;
		if(pxSpirit!=null)then
			iCount=pxSpirit^.GetRessurectionValue();
			pxSpirit^.SetRessurectionValue(iCount-1);
		endif;
		if(iCount==1||m_bLoadBreak)then
			var ^CPlayer pxPlayer=CSrvWrap.GetCurLevel()^.GetPlayer(m_iOwner);
			var ^CPyramidCardObject pxTmp = cast<CPyramidCardObject>(m_xPyCO.GetObj());
			if(pxTmp!=null)then
				pxTmp^.StopTimer();
			endif;
			if(m_xPyCO.IsValid())then
				CSrvWrap.GetObjMgr()^.DeleteObject(m_xPyCO.GetObj());
			endif;
			if(pxPlayer==null)then return; endif;
			var ^CAttribs pxPlAttr=pxPlayer^.GetAttribs();
			if(pxPlAttr==null)then return; endif;
			pxPlAttr^.SetValue("virtual_supply", pxPlAttr^.GetValueInt("virtual_supply")-m_iSupplyCount);
			pxPlAttr^.SetValue(m_sNode, pxPlAttr^.GetValueInt(m_sNode)-1);
		endif;
	endproc;
	
	proc bool IsInRange()
		if(CMirageSrvMgr.Get().GlobalReanim())then return true; endif;
		var ^CCharacter pxCharacter=cast<CCharacter>(m_xCharacter.GetObj());
		var ^CSpirit pxSpirit=CSrvWrap.GetSpiritMgr().GetSpirit(m_iSpiritHandle);
		if(pxCharacter==null||pxSpirit==null)then return false; endif;
		var vec3 vSpirit=pxSpirit^.GetPos();
		vSpirit.SetZ(CSrvWrap.GetScapeMgr().GetHeight(vSpirit.GetX(), vSpirit.GetY()));
		var real fTargetRadius=pxSpirit^.GetRadius();
		var real fAttackRange=40.0;
		if(pxCharacter^.GetClassName()=="aje_shaman")then
			fAttackRange+=pxCharacter^.GetMiscValueTT("Shaman_Cast_Reanimation");
		endif;
		var real fDistance=(vSpirit - pxCharacter^.GetPos()).Abs2S();
		return fDistance <= (fAttackRange+fTargetRadius)*(fAttackRange+fTargetRadius);
	endproc;
	
	export proc bool Break()
		SetPrepareActionPath(m_xCharacter, GetSpecialActionPath(), false);
		if(m_xCharacter.IsValid())then
			m_xCharacter.GetObj()^.TerminateAction();
		endif;
		var ^CCharacter pxCharacter=cast<CCharacter>(m_xCharacter.GetObj());
		if(pxCharacter!=null && m_sState=="check")then
			pxCharacter^.PayBackMana(m_sTTPath);
		endif;
//		var ^CCharacter pxCharacter = cast<CCharacter>(m_xCharacter.GetObj());
//		if(pxCharacter!=null)then
//			pxCharacter^.SetResurrecting(false);
//		endif;
		if(m_sState=="check"||m_sState=="EndAnim")then
			Reset();
		elseif(m_sState == "abort")then
			Reset();
			if(CMirageSrvMgr.ms_pxPoolMixer!=null)then
				var int iKC,iKH;
				var string sIDs,sDurs,sStarts,sDeath;
				CMirageSrvMgr.ms_pxPoolMixer^.DeleteSpirit(m_iSpiritHandle,iKC,iKH,sIDs,sDurs,sStarts,sDeath);
			endif;
			CSrvWrap.GetSpiritMgr().DeleteSpirit(m_iSpiritHandle);
			m_sState == "EndTask";
			EndTask();
		endif;
		m_bLoadBreak=false;
		return true;
	endproc;
	
	export proc void Skip()
	endproc;
	
	export proc bool Resurrect(^CSpirit p_pxSpirit)
		var string sClassName=p_pxSpirit^.GetClass();
		var int iOwner=p_pxSpirit^.GetOwner();
		if(CNPCMgr.Get().CheckHero(sClassName))then
			if(CNPCMgr.Get().HasNPC(sClassName,iOwner))then
				m_sState="abort";
				Break();
				return false;
			endif;
		endif;
		var ^CPlayer pxPlayer=CSrvWrap.GetCurLevel()^.GetPlayer(m_iOwner);
		if(pxPlayer==null)then return false; endif;
		var ^CBasePlayer pxBPl=cast<CBasePlayer>(pxPlayer);
		if(pxBPl==null)then return false; endif;
		var ^CAttribs pxPlAttr=pxPlayer^.GetAttribs();
		if(pxPlAttr==null)then return false; endif;
		var ^CTechTreeDef pxPlrTTDef=^(pxPlayer^.GetPlayerTechTreeDef());
		if(pxPlrTTDef==null)then return false; endif;
		var ^CPyramidCardObject pxTmp = cast<CPyramidCardObject>(m_xPyCO.GetObj());
		if(pxTmp!=null)then
			pxTmp^.StopTimer();
		endif;
		pxPlAttr^.SetValue("virtual_supply", pxPlAttr^.GetValueInt("virtual_supply")-m_iSupplyCount);
		pxPlAttr^.SetValue(m_sNode, pxPlAttr^.GetValueInt(m_sNode)-1);
//		var string sClassName=p_pxSpirit^.GetClass();
		m_sClassName=sClassName;
		var vec3 vPos, vRot;
		var bool bFound=false;
		if(CMirageSrvMgr.ms_pxPoolMixer!=null)then
			CMirageSrvMgr.ms_pxPoolMixer^.GetProperties(p_pxSpirit^.GetHandle(), bFound, vPos, vRot);
		endif;
//		var CObjHndl xHndl=CNPCMgr.Get().GetPlayerNPC(m_iOwner, sClassName);
//		if(xHndl.IsValid())then return false; endif;
		var ^CFightingObj pxFO;
		if(bFound)then
			pxFO=cast<CFightingObj>(CSrvWrap.GetObjMgr()^.CreateObj(sClassName,m_iOwner,vPos,vRot));
		else
			pxFO=cast<CFightingObj>(CSrvWrap.GetObjMgr()^.CreateObj(sClassName,m_iOwner,p_pxSpirit^.GetPos(),p_pxSpirit^.GetRotation()));
		endif;
		if(pxFO!=null)then
			var vec3 vTmp = pxFO^.GetPos();
			vTmp.SetZ(Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vTmp.GetX(),vTmp.GetY()),CSrvWrap.GetScapeMgr().GetSeaLevel()));
			pxFO^.AddFlyingHeight(vTmp,12.0f);
			pxFO^.Reanimated(bFound);
			var int iKC,iKH;
			var string sIDs,sDurs,sStarts,sDeath;
			if(CMirageSrvMgr.ms_pxPoolMixer!=null)then
				CMirageSrvMgr.ms_pxPoolMixer^.DeleteSpirit(p_pxSpirit^.GetHandle(),iKC,iKH,sIDs,sDurs,sStarts,sDeath);
			endif;
			pxFO^.SetKillerNumbers(iKC,iKH);
			pxFO^.SetLevelClean(p_pxSpirit^.GetLevel());
			CSrvWrap.GetCurLevel()^.GetStatisticMgr().AddUnit(pxFO^.GetOwner(), pxFO^.GetClassName(), pxFO^.GetType(), 1);
			var ^CTechTreeDef pxTTDef=pxFO^.GetTechTreeDef();
			if(pxTTDef!=null)then
				var CStringArray asTTFilters;
				var CStringArray asTTDisFilters;
				p_pxSpirit^.GetTTFilters(asTTFilters);
				var int i, iC=pxTTDef^.NumEntries();
				for(i=0)cond(i<iC)iter(i++)do
					var string sFilter=pxTTDef^.GetFilter(i);
					if(asTTFilters.FindEntry(sFilter)==-1)then
						asTTDisFilters.AddEntry(sFilter);
					endif;
				endfor;
				iC=asTTDisFilters.NumEntries();
				for(i=0)cond(i<iC)iter(i++)do
					pxTTDef^.DisableFilter(asTTDisFilters[i]);
				endfor;
				iC=asTTFilters.NumEntries();
				for(i=0) cond(i<iC) iter(i++)do
					if(asTTFilters[i].Find("_RemoveMe")==-1 && !pxPlrTTDef^.HasFilter(asTTFilters[i]))then
						pxTTDef^.EnableFilter(asTTFilters[i]);
					endif;
				endfor;
			endif;
			if(m_xPyCO.IsValid())then
				var ^CAttribs pxAttr=pxFO^.GetAttribs();
				if(pxAttr!=null)then
					pxAttr^.SetValue("clientpyramid_replacecard", m_xPyCO.GetObj()^.GetName());
				endif;
			endif;
			if(m_xPyCO.IsValid())then
				CSrvWrap.GetObjMgr()^.DeleteObject(m_xPyCO.GetObj());
			endif;
			if(sIDs!="")then
				var array string asIDs, asDurs, asStarts;
				sIDs.Split(asIDs, "|", true);
				sDurs.Split(asDurs, "|", true);
				sStarts.Split(asStarts, "|", true);
				var CGameTime xDeath, xStart;
				xDeath.FromString(sDeath);
				var CGameTimeSpan xSpan=(CTimeMgr.Get().GetTime()-xDeath);
				var int i,iC=asIDs.NumEntries();
				if(iC==asDurs.NumEntries()&&iC==asStarts.NumEntries())then
					for(i=0)cond(i<iC)iter(i++)do
						var CTechTree xTT=pxFO^.GetTechTree();
						var ^CTechTree.CNode pxAction=xTT.FindNode(CTechTree.GetPathHashPath(asIDs[i].ToInt()));
						if(pxAction!=null)then
							xStart.FromString(asStarts[i]);
							xStart+=xSpan;
							pxFO^.AddSpecialActionTimerPrecisely(pxAction^.GetAbsPath(),xStart,asDurs[i].ToReal());
						endif;
					endfor;
				endif;
			endif;
//			var CTechTree xTT=pxFO^.GetTechTree();
//			var ^CTechTree.CNode pxActions=xTT.FindNode("Actions/"+pxFO^.GetTribeName()+"/Moves/"+pxFO^.GetType().AsString());
//			if(pxActions!=null)then
//				var int i,iC=pxActions^.NumSubs();
//				for(i=0)cond(i<iC)iter(i++)do
//					var ^CTechTree.CNode pxAction=pxActions^.GetSub(i);
//					if(pxAction==null)then continue; endif;
//					if(pxAction^.GetSubValueI("duration")<=0)then continue; endif;
//					pxFO^.AddSpecialActionTimer(pxAction^.GetAbsPath());
//				endfor;
//			endif;
			if(CheckifHero(sClassName))then
				CNPCMgr.Get().AddNPC(m_iOwner, pxFO^.GetHandle());
			endif;
		endif;
		var int iLevel=p_pxSpirit^.GetLevel();
		m_sNode="virtual_units_"+iLevel.ToString();
		var ^CAttribs pxAttr=CSrvWrap.GetCurLevel()^.GetPlayer(m_iOwner)^.GetAttribs();
		CSrvWrap.GetSpiritMgr().DeleteSpirit(p_pxSpirit^.GetHandle());
		//pxFO^.SetEnergy(0.0);
		return true;
	endproc;
	
	export proc void EndTask()
		var ^CSpirit pxSpirit=CSrvWrap.GetSpiritMgr().GetSpirit(m_iSpiritHandle);
		SetPrepareActionPath(m_xCharacter, GetSpecialActionPath(), false);
		UpdateAggressionPos(m_xCharacter);
//		var ^CCharacter pxCharacter = cast<CCharacter>(m_xCharacter.GetObj());
//		if(pxCharacter!=null)then
//			pxCharacter^.SetResurrecting(false);
//		endif;
		super.EndTask();
	endproc;
	
	proc bool CheckifHero(string p_sClassName)
		if(p_sClassName=="Stina_s0"||p_sClassName=="Bela_s0"||p_sClassName=="Cole_s0"||p_sClassName=="special_eusmilus"
		||p_sClassName=="mayor_s0"||p_sClassName=="darwin_s0"||p_sClassName=="tesla_s0"||p_sClassName=="babbage_s0"
		||p_sClassName=="hermit_s0"||p_sClassName=="lovelace_s0"||p_sClassName=="schliemann_s0"||p_sClassName=="livingstone_s0"
		||p_sClassName=="Miyagi_s0"||p_sClassName=="Tarna_s0"||p_sClassName=="Larry_s0")then
			return true;
		endif;
		return false;
	endproc;
	
	export proc bool GetPlayerInfos(int p_iID,ref int p_riAge)
		var ^CBasePlayer pxP=CBasePlayer.GetPlayer(p_iID);
		if(pxP==null)then return false; endif;
		var ^CAttribs pxA=pxP^.GetAttribs();
		if(pxA==null)then return false; endif;
		p_riAge=pxA^.GetValueInt("age");
		if(pxA^.GetValueInt("final")==6)then
			p_riAge=6;
		endif;
		return true;
	endproc;
	
	export proc void UpdatePyCO(real p_fTaskProcess)
		if(m_xPyCO.IsValid())then
			var ^CPyramidCardObject pxTmp = cast<CPyramidCardObject>(m_xPyCO.GetObj());
			if(pxTmp!=null)then
				var ^CAttribs pxAttr = pxTmp^.GetAttribs();
				if(pxAttr!=null)then
					pxAttr^.SetValue("CurProcess",p_fTaskProcess.ToInt());
					pxAttr^.SetValue("hitpoints",(m_iSpiritMaxHP.ToReal()*(p_fTaskProcess/100.0f)).ToInt());
				endif;
			endif;
		endif;
	endproc;
	
endclass;
	
class CStartHourglass inherit CSpecialActionTask
	
	var CObjHndl			m_xCharacter;
	var CObjHndl			m_xTarget;
	var string				m_sState;
	var int						m_iRetryCounter;
	var CGameTime			m_xStart;
	var array string	m_asValidTargets;
	
	export constructor()
		SetName("StartHourglass");
		m_asValidTargets.AddEntry("ANML");
		m_asValidTargets.AddEntry("SHIP");
		m_asValidTargets.AddEntry("VHCL");
		SetCivil(false);
		m_iRetryCounter=0;
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CStartHourglass] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xType="SHGT"; // Henry: Start HourGlass Task
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xCharacter.DoKArc(pxArc^);
		m_xTarget.DoKArc(pxArc^);
		m_xStart.DoKArc(pxArc^);
		(pxArc^) << m_sState;
		(pxArc^) << m_iRetryCounter;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="SHGT")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xCharacter.DoKArc(pxArc^);
			m_xTarget.DoKArc(pxArc^);
			m_xStart.DoKArc(pxArc^);
			(pxArc^) << m_sState;
			(pxArc^) << m_iRetryCounter;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool Init(CObjHndl p_xCharacter, CObjHndl p_xTarget, string p_sPath)
		m_sState="goto_target";
		if(!p_xCharacter.IsValid()||!p_xTarget.IsValid())then
			m_sState="EndTask";
			return false;
		endif;
		if(m_asValidTargets.FindEntry(p_xTarget.GetObj()^.GetType().AsString())==-1)then
			m_sState="EndTask";
			return false;
		endif;
		SetSpecialActionPath(p_sPath);
		SetPrepareActionPath(p_xCharacter, p_sPath, true);
		m_xCharacter=p_xCharacter;
		m_xTarget=p_xTarget;
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		var ^CFightingObj pxFightingObj=cast<CFightingObj>(m_xCharacter.GetObj());
		if(pxFightingObj==null||!pxFightingObj^.CheckSpecialActionTimer(GetSpecialActionPath()))then
			EndTask();
			return;
		endif;
		if(m_sState=="EndTask")then
			EndTask();
		endif;
	endproc;
	
	proc void USLOnTick(int p_iTime)
		var ^CCharacter pxCharacter=cast<CCharacter>(m_xCharacter.GetObj());
		var ^CFightingObj pxTarget=cast<CFightingObj>(m_xTarget.GetObj());
		if(pxCharacter==null||pxTarget==null)then EndTask(); return; endif;
		if(m_sState=="goto_target")then
			var real fAttackRange=10.0;
			if(!IsInRange())then
				if(pxCharacter^.GetOnWall())then
					EndTask();return;
				endif;
				pxCharacter^.AdvanceAction(pxTarget^.GetHandle(),fAttackRange, pxCharacter^.GetMaxSpeed());
			endif;
			m_sState="perform_magic";
		elseif(m_sState=="perform_magic")then
			m_xStart=CTimeMgr.Get().GetTime();
			pxCharacter^.SetAnim("heal_0",3);
			m_sState="check_time";
			return;
		elseif(m_sState=="check_time")then
			if(!IsInRange())then
				if(m_iRetryCounter>3)then
					EndTask();
				else
					m_iRetryCounter++;
					m_sState="goto_target";
					return;
				endif;
			endif;
			var CGameTimeSpan xDuration=3.0f;
			var CGameTime xNow=CTimeMgr.Get().GetTime();
			if((xNow - m_xStart) >= xDuration)then
				m_sState="start";
				return;
			endif;
		elseif(m_sState=="start")then
			SetUnStoppable(true);
			if(!pxCharacter^.CheckSpecialActionTimer(GetSpecialActionPath()))then EndTask(); return; endif;
//			var real fDuration=60.0f;
//			pxTarget^.StartAllSpecialActionTimers(fDuration);
			if(pxTarget^.StartAllSpecialActionTimers())then
				StartSpecialActionTimer(pxCharacter);
			endif;
			m_sState="EndTask";
			return;
		elseif(m_sState=="EndTask")then
			SetUnStoppable(false);
			EndTask();
			return;
		endif;
	endproc;
	
	proc bool IsInRange()
		var ^CCharacter pxCharacter=cast<CCharacter>(m_xCharacter.GetObj());
		var ^CGameObj pxTarget=m_xTarget.GetObj();
		if(pxCharacter==null||pxTarget==null)then return false; endif;
		var real fTargetRadius=pxTarget^.GetRadius();
		var real fSelfRadius=pxCharacter^.GetRadius();
		var real fAttackRange=10.0+fSelfRadius+fTargetRadius;
		var real fDistance=(pxTarget^.GetPos() - pxCharacter^.GetPos()).Abs2S();
		return fDistance <= fAttackRange*fAttackRange;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
	endproc;
	
	export proc bool Break()
		if(GetUnStoppable())then
			return false;
		endif;
		SetPrepareActionPath(m_xCharacter, GetSpecialActionPath(), false);
		if(m_xCharacter.IsValid())then
			m_xCharacter.GetObj()^.TerminateAction();
		endif;
		return true;
	endproc;
	
	export proc void Skip()
	endproc;
	
	export proc void EndTask()
		SetPrepareActionPath(m_xCharacter, GetSpecialActionPath(), false);
		UpdateAggressionPos(m_xCharacter);
		super.EndTask();
	endproc;
	
endclass;
	
class CTeleport inherit CSpecialActionTask
	
	var CObjHndl m_xActor;
	var CObjHndl m_xTarget;
	var string m_sState;
	var CGameTime m_xStart;
	var CObjList m_xUnits;
	
	export constructor()
		SetName("Teleport");
		SetCivil(false);
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CTeleport] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xType="BlSt";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xActor.DoKArc(pxArc^);
		m_xTarget.DoKArc(pxArc^);
		m_xStart.DoKArc(pxArc^);
		(pxArc^) << m_sState;
		m_xUnits.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="BlSt")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xActor.DoKArc(pxArc^);
			m_xTarget.DoKArc(pxArc^);
			m_xStart.DoKArc(pxArc^);
			(pxArc^) << m_sState;
			m_xUnits.DoKArc(pxArc^);
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool Init(CObjHndl p_xActor, CObjHndl p_xTarget, string p_sPath)
		if(!p_xActor.IsValid()||!p_xTarget.IsValid())then
			m_sState="EndTask";
			return false;
		endif;
		m_sState="prepare";
		SetSpecialActionPath(p_sPath);
		m_xActor=p_xActor;
		m_xTarget=p_xTarget;
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		var ^CFightingObj pxFightingObj=cast<CFightingObj>(m_xActor.GetObj());
		if(pxFightingObj==null||!pxFightingObj^.CheckSpecialActionTimer(GetSpecialActionPath()))then
			EndTask();
			return;
		endif;
		pxFightingObj=cast<CFightingObj>(m_xTarget.GetObj());
		if(pxFightingObj==null)then
			EndTask();
			return;
		endif;
		if(m_sState=="EndTask")then
			EndTask();
		endif;
	endproc;
	
	proc void USLOnTick(int p_iTime)
		var ^CFightingObj pxActor=cast<CFightingObj>(m_xActor.GetObj());
		var ^CFightingObj pxTarget=cast<CFightingObj>(m_xTarget.GetObj());
		if(pxActor==null||pxTarget==null)then EndTask(); return; endif;
		var real fDuration=3.0f, fRange=50.0f;
		if(m_sState=="prepare")then
			if(!StartSpecialActionTimer(pxActor))then
				EndTask();
				return;
			endif;
			SetUnStoppable(true);
			pxActor^.SetAnim("thanking",1);
			var CObjQuery xQ;
			xQ.SetType("ANML", false);
			xQ.SetType("CHTR", true);
			xQ.SetType("FGHT", true);
			xQ.SetType("VHCL", true);
			xQ.SetOwner(pxActor^.GetOwner());
			CSrvWrap.GetDiplomacyMgr().AddMyFriendsToSearch(pxActor^.GetOwner(), xQ);
			xQ.RegionCircle(pxActor^.GetPos(), fRange);
			xQ.Execute(m_xUnits);
			var int i, iC=m_xUnits.NumEntries();
			for(i=0)cond(i<iC)iter(++i)do
				var ^CFightingObj pxF=cast<CFightingObj>(m_xUnits[i].GetObj());
				if(pxF!=null)then
					if(pxF^.GetTransportObj().IsValid())then continue; endif;
					pxF^.PrepareToTeleporting(fDuration);
				endif;
			endfor;
			m_xStart=CTimeMgr.Get().GetTime();
			m_sState="check_time";
			return;
		elseif(m_sState=="check_time")then
			var CGameTimeSpan xDuration=fDuration;
			var CGameTime xNow=CTimeMgr.Get().GetTime();
			if((xNow - m_xStart) >= xDuration)then
				m_sState="teleport";
				return;
			endif;
		elseif(m_sState=="teleport")then
			var vec3 vPos=pxTarget^.GetPos();
			vPos.SetZ(CSrvWrap.GetScapeMgr().GetHeight(vPos.GetX(),vPos.GetY()));
			var real fStandRange=pxTarget^.GetRadius();
			var vec3 vOffset={0.7,0.7,0.0};
			var int i, iC=m_xUnits.NumEntries();
			for(i=0) cond(i<iC) iter(++i)do
				var ^CFightingObj pxF=cast<CFightingObj>(m_xUnits[i].GetObj());
				if(pxF!=null)then
					if(pxF^.GetTransportObj().IsValid())then continue; endif;
					pxF^.Rotate(pxTarget^.GetRotation());
					vOffset=vOffset.RotZ((Random.GetInt()%629).ToReal()/100.0);
					var vec3 vGroupPos=vPos+(vOffset*fStandRange);
					var vec3 vTmp;
					CSrvWrap.GetObjMgr()^.GetFreePos(vTmp,pxF,vGroupPos);
					vTmp.SetZ(CSrvWrap.GetScapeMgr().GetHeight(vTmp.GetX(),vTmp.GetY()));
					pxF^.PutIntoPlace(vTmp);
				endif;
			endfor;
			m_sState="EndTask";
		elseif(m_sState=="EndTask")then
			SetUnStoppable(false);
			EndTask();
			return;
		endif;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
	endproc;
	
	export proc bool Break()
		if(GetUnStoppable())then
			return false;
		endif;
		SetPrepareActionPath(m_xActor, GetSpecialActionPath(), false);
		if(m_xActor.IsValid())then
			m_xActor.GetObj()^.TerminateAction();
		endif;
		return true;
	endproc;
	
	export proc void Skip()
	endproc;
	
	export proc void EndTask()
		SetPrepareActionPath(m_xActor, GetSpecialActionPath(), false);
		UpdateAggressionPos(m_xActor);
		super.EndTask();
	endproc;
	
endclass;
	
	//========================================================================================
	//=== General Specials ===================================================================
	//========================================================================================
	
class CActionTask inherit CTask
	
	var string		m_sActionPath;
	var bool			m_bUnStoppable;
	var CObjHndl	m_xGameObj;
	
	export constructor()
		m_sActionPath="";
		m_bUnStoppable=false;
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CActionTask] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xType="AcTk";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,2);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		(pxArc^) << m_sActionPath;
		(pxArc^) << m_bUnStoppable;
		m_xGameObj.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="AcTk")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			(pxArc^) << m_sActionPath;
			(pxArc^) << m_bUnStoppable;
			if(iVersion>=2)then
				m_xGameObj.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void SetSpecialActionPath(string p_sPath)
		m_sActionPath=p_sPath;
	endproc;
	
	export proc string GetSpecialActionPath()
		return m_sActionPath;
	endproc;
	
	export proc bool StartSpecialActionTimer(^CFightingObj p_pxObj)
		if(p_pxObj==null)then return false; endif;
		if(!p_pxObj^.CheckSpecialActionTimer(m_sActionPath))then return false; endif;
		return p_pxObj^.AddSpecialActionTimer(m_sActionPath);
	endproc;
	
	export proc bool StartSpecialActionTimer(^CFightingObj p_pxObj, bool p_bSkipVis)
		if(p_pxObj==null)then return false; endif;
		if(!p_pxObj^.CheckSpecialActionTimer(m_sActionPath, p_bSkipVis))then return false; endif;
		return p_pxObj^.AddSpecialActionTimer(m_sActionPath);
	endproc;
	
	export proc bool CheckSpecialActionTimer(^CFightingObj p_pxObj)
		if(p_pxObj==null)then return false; endif;
		return p_pxObj^.CheckSpecialActionTimer(m_sActionPath);
	endproc;
	
	export proc bool CheckSpecialActionTimer(^CFightingObj p_pxObj, bool p_bSkipVis)
		if(p_pxObj==null)then return false; endif;
		return p_pxObj^.CheckSpecialActionTimer(m_sActionPath, p_bSkipVis);
	endproc;
	
	export proc bool GetUnStoppable()
		return m_bUnStoppable;
	endproc;
	
	export proc void SetUnStoppable(bool p_bValue)
		m_bUnStoppable=p_bValue;
	endproc;
	
	export proc void SetPrepareActionPath(CObjHndl p_xActor, string p_sPath, bool p_bEnable)
		if(!p_xActor.IsValid())then return; endif;
		if(p_xActor.GetObj()==null)then return; endif;
		m_xGameObj=p_xActor;
		var ^CFightingObj pxActor=cast<CFightingObj>(p_xActor.GetObj());
		if(pxActor!=null)then
			if(!p_bEnable&&pxActor^.GetAILock())then
				pxActor^.SetAILock(false);
			endif;
			pxActor^.ReWritePrepareActions(p_sPath, p_bEnable);
		endif;
	endproc;
	
	export proc void ResetPrepare()
		SetPrepareActionPath(m_xGameObj, GetSpecialActionPath(), false);
	endproc;
	
	export proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		ResetPrepare();
		super.USLOnLeave(p_pxFrom,p_pxTo);
	endproc;
	
endclass;

class CCustomTask inherit CTask
	
	var string			m_sActionName;
	var string			m_sState;
	var string			m_sPath;
	var real				m_fRealValue;
	var real				m_fRealValue2;
	var int					m_iIntValue;
	var CObjHndl		m_xActor;
	var CObjHndl		m_xSubject;
	
	export constructor()
		m_sActionName="";
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CCustomTask] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xType="CuTk";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xActor.DoKArc(pxArc^);
		m_xSubject.DoKArc(pxArc^);
		(pxArc^) << m_sActionName;
		(pxArc^) << m_sState;
		(pxArc^) << m_sPath;
		(pxArc^) << m_fRealValue;
		(pxArc^) << m_fRealValue2;
		(pxArc^) << m_iIntValue;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="CuTk")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xActor.DoKArc(pxArc^);
			m_xSubject.DoKArc(pxArc^);
			(pxArc^) << m_sActionName;
			(pxArc^) << m_sState;
			(pxArc^) << m_sPath;
			(pxArc^) << m_fRealValue;
			(pxArc^) << m_fRealValue2;
			(pxArc^) << m_iIntValue;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool Init(CObjHndl p_xActor, CObjHndl p_xSubject, string p_sAction, string p_sPath, real p_fValue, real p_fValue2, int p_iValue)
		if(!p_xActor.IsValid())then
			m_sState="EndTask";
			return false;
		endif;
		m_sState="check_action";
		m_xActor=p_xActor;
		m_xSubject=p_xSubject;
		m_sActionName=p_sAction;
		m_sPath=p_sPath;
		m_iIntValue=p_iValue;
		m_fRealValue=p_fValue;
		m_fRealValue2=p_fValue2;
		return true;
	endproc;
	
	export proc bool Init(CObjHndl p_xActor, CObjHndl p_xSubject, string p_sAction, string p_sPath)
		if(!p_xActor.IsValid()||!p_xSubject.IsValid())then
			m_sState="EndTask";
			return false;
		endif;
		m_sState="check_action";
		m_xActor=p_xActor;
		m_xSubject=p_xSubject;
		m_sActionName=p_sAction;
		m_sPath=p_sPath;
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		var ^CFightingObj pxFightingObj=cast<CFightingObj>(m_xActor.GetObj());
		if(pxFightingObj==null)then
			EndTask();
			return;
		endif;
		if(m_sState=="EndTask")then
			EndTask();
		endif;
	endproc;
	
	proc void USLOnTick(int p_iTime)
		var ^CFightingObj pxActor=cast<CFightingObj>(m_xActor.GetObj());
		if(pxActor==null)then EndTask(); return; endif;
//		if(m_sState=="check_action")then
//			return;
//		endif;
		if(m_sActionName=="ReleaseItem")then
			var ^CInventory pxInv=pxActor^.GetInventory();
			if(pxInv!=null)then
				var ^CItem pxItem=cast<CItem>(m_xSubject.GetObj());
				if(pxItem!=null)then
					if(CArtifactMgr.Get().RemoveArtifact(pxActor^.GetOwner(),m_xSubject))then
						pxInv^.RemItem(m_xSubject);
						pxItem^.OnDroppedItem(pxActor,true,"normal",false);
						pxItem^.TerminateAction();
						if(pxActor^.HasAnim("put_down"))then
							pxActor^.AnimAction("put_down");
						endif;
						pxActor^.AddItemName("");
					endif;
				endif;
			endif;
		elseif(m_sActionName=="ReleaseItemFree")then
			var ^CInventory pxInv=pxActor^.GetInventory();
			if(pxInv!=null)then
				var ^CItem pxItem=cast<CItem>(m_xSubject.GetObj());
				if(pxItem!=null)then
					pxInv^.RemItem(m_xSubject);
					pxItem^.OnDroppedItem(pxActor,true,"normal",false);
					pxItem^.TerminateAction();
					if(pxActor^.HasAnim("put_down"))then
						pxActor^.AnimAction("put_down");
					endif;
					pxActor^.AddItemName("");
				endif;
			endif;
		elseif(m_sActionName=="CallTwins")then
			var ^CHero pxHero=cast<CHero>(pxActor);
			if(pxHero!=null)then
				pxHero^.CallTwins(m_sPath,false);
			endif;
		elseif(m_sActionName=="StartVanish")then
			var ^CHero pxHero=cast<CHero>(pxActor);
			if(pxHero!=null)then
				pxHero^.StartVanish(m_sPath,false);
			endif;
		elseif(m_sActionName=="ResetHourglass")then
			var ^CHero pxHero=cast<CHero>(pxActor);
			if(pxHero!=null)then
				pxHero^.ResetHourglass(m_sPath,false);
			endif;
		elseif(m_sActionName=="Blindness")then
			var ^CHero pxHero=cast<CHero>(pxActor);
			if(pxHero!=null)then
				pxHero^.Blindness(m_sPath,false);
			endif;
		elseif(m_sActionName=="Motivating")then
			var ^CHero pxHero=cast<CHero>(pxActor);
			if(pxHero!=null)then
				pxHero^.Motivating(m_sPath,false);
			endif;
		elseif(m_sActionName=="Fishing")then
			if(m_sPath=="Ship")then
				var ^CShip pxShip=cast<CShip>(pxActor);
				if(pxShip!=null)then
					pxShip^.Fishing(pxShip^.GetPos(),false,true);
				endif;
			elseif(m_sPath=="Boat")then
				var ^CFishingBoat pxBoat=cast<CFishingBoat>(pxActor);
				if(pxBoat!=null)then
					pxBoat^.Fishing(pxBoat^.GetPos(),false,true);
				endif;
			elseif(m_sPath=="Harbour")then
				var ^CSwimmingHarbour pxHarbour=cast<CSwimmingHarbour>(pxActor);
				if(pxHarbour!=null)then
					pxHarbour^.Fishing(pxHarbour^.GetPos(),false,true);
				endif;
			endif;
		elseif(m_sActionName=="Deforest")then
			if(m_sPath=="Character")then
				var ^CCharacter pxCharacter=cast<CCharacter>(pxActor);
				if(pxCharacter!=null)then
					pxCharacter^.Deforest(null,pxCharacter^.GetPos(),false,true);
				endif;
			elseif(m_sPath=="Transport")then
				var ^CTransportObj pxTransportObj=cast<CTransportObj>(pxActor);
				if(pxTransportObj!=null)then
					pxTransportObj^.Deforest(null,pxTransportObj^.GetPos(),false,true);
				endif;
			endif;
		elseif(m_sActionName=="FindTracesAndTraps")then
			if(m_iIntValue==0)then
				var ^CCharacter pxCharacter=cast<CCharacter>(pxActor);
				if(pxCharacter!=null)then
					pxCharacter^.FindTracesAndTraps(m_sPath,pxCharacter^.GetPos(),m_fRealValue,m_fRealValue2,false);
				endif;
			elseif(m_iIntValue==1)then
				var ^CShip pxShip=cast<CShip>(pxActor);
				if(pxShip!=null)then
					pxShip^.FindTracesAndTraps(m_sPath,pxShip^.GetPos(),m_fRealValue,false);
				endif;
			endif;
		elseif(m_sActionName=="EnableAjeCamouflage")then
			var ^CGameObj pxObject=null;
			if(m_xSubject.IsValid())then
				pxObject=m_xSubject.GetObj();
			endif;
			var ^CCharacter pxCharacter=cast<CCharacter>(pxActor);
			if(pxCharacter!=null)then
				pxCharacter^.EnableAjeCamouflage(m_sPath,pxObject,pxCharacter^.GetPos(),false);
			endif;
		elseif(m_sActionName=="EnableHuCamouflage")then
			var ^CGameObj pxObject=null;
			if(m_xSubject.IsValid())then
				pxObject=m_xSubject.GetObj();
			endif;
			var ^CCharacter pxCharacter=cast<CCharacter>(pxActor);
			if(pxCharacter!=null)then
				pxCharacter^.EnableHuCamouflage(m_sPath,pxObject,pxCharacter^.GetPos(),false);
			endif;
		elseif(m_sActionName=="DeafeningRoar")then
			var ^CCharacter pxCharacter=cast<CCharacter>(pxActor);
			if(pxCharacter!=null)then
				pxCharacter^.DeafeningRoar(m_sPath,m_fRealValue,false);
			endif;
		elseif(m_sActionName=="StartFighterDoping")then
			var ^CCRpgFighter4 pxFighter=cast<CCRpgFighter4>(pxActor);
			if(pxFighter!=null)then
				pxFighter^.StartFighterDopingFull(m_sPath,false);
			endif;
		elseif(m_sActionName=="KnightIntimidate")then
			var ^CCRpgKnight2 pxKnight=cast<CCRpgKnight2>(pxActor);
			if(pxKnight!=null)then
				pxKnight^.KnightIntimidate(m_sPath,false);
			endif;
		elseif(m_sActionName=="ShadowCloneJutsu")then
			var ^CCRpgNovice3 pxNovice=cast<CCRpgNovice3>(pxActor);
			if(pxNovice!=null)then
				pxNovice^.ShadowCloneJutsu(m_sPath,false);
			endif;
		elseif(m_sActionName=="StartShooterVanish")then
			var ^CCRpgShooter4 pxShooter=cast<CCRpgShooter4>(pxActor);
			if(pxShooter!=null)then
				pxShooter^.StartShooterVanish(m_sPath,false);
			endif;
		elseif(m_sActionName=="StartDoping")then
			var ^CSaltasaurus pxSaltasaurus=cast<CSaltasaurus>(pxActor);
			if(pxSaltasaurus!=null)then
				pxSaltasaurus^.StartDoping(m_sPath,false);
			endif;
		elseif(m_sActionName=="CreateIllusions")then
			var ^CCharacter pxCharacter=cast<CCharacter>(pxActor);
			if(pxCharacter!=null)then
				pxCharacter^.CreateIllusions(m_sPath,false);
			endif;
		endif;
		m_sState="EndTask";
		if(m_sState=="EndTask")then
			EndTask();
			return;
		endif;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
	endproc;
	
	export proc bool Break()
		return true;
	endproc;
	
	export proc void Skip()
	endproc;
	
	export proc void EndTask()
		super.EndTask();
	endproc;
	
endclass;

class CEnterPortal inherit CTask
	
	var CObjHndl		m_xPassenger;
	var CObjHndl		m_xBuilding;
	var int					m_iState;
	var int					m_iRetryCounter;
	var bool				m_bRegistered;
	
	const int				STATE_QUIT = 0;
	const int				STATE_GOTO = 1;
	const int				STATE_ON_THE_WAY = 2;
	const int				STATE_ENTER = 3;
	
	export constructor()
		SetName("EntrPortal");
		SetCivil(false);
		m_bRegistered=false;
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CEnterPortal] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xType="EnPo";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,2);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xPassenger.DoKArc(pxArc^);
		m_xBuilding.DoKArc(pxArc^);
		(pxArc^) << m_iState;
		(pxArc^) << m_bRegistered;
		(pxArc^) << m_iRetryCounter;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="EnPo")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xPassenger.DoKArc(pxArc^);
			m_xBuilding.DoKArc(pxArc^);
			(pxArc^) << m_iState;
			(pxArc^) << m_bRegistered;
			if(pxArc^.GetVersion()>=2)then
				(pxArc^) << m_iRetryCounter;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;	
	
	export proc bool Init(CObjHndl p_xPassenger, CObjHndl p_xBuilding)
		m_xPassenger=p_xPassenger;
		m_xBuilding=p_xBuilding;
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		if(!m_xPassenger.IsValid()||!m_xBuilding.IsValid())then EndTask(); return; endif;
		var ^CFightingObj pxF=cast<CFightingObj>(m_xPassenger.GetObj());
		var ^CPortalTerminus pxB=cast<CPortalTerminus>(m_xBuilding.GetObj());
		if(pxF!=null && pxB!=null)then
			if(!pxB^.RegisterPassenger(m_xPassenger))then
				EndTask();
				return;
			endif;
		endif;
		m_bRegistered=true;
		m_iState=STATE_GOTO;
		m_iRetryCounter=5;
	endproc;
	
	proc void USLOnTick(int p_iTime)
		var ^CFightingObj pxF=cast<CFightingObj>(m_xPassenger.GetObj());
		var ^CPortalTerminus pxB=cast<CPortalTerminus>(m_xBuilding.GetObj());
		if(pxF!=null && pxB!=null)then
			if(m_iState==STATE_GOTO)then
				var vec3 vP;
				var real fMinDis=3.0f;
				pxF^.AdvanceAction(m_xBuilding, fMinDis, pxF^.GetMaxSpeed());
				m_iState=STATE_ON_THE_WAY;
				return;
			elseif(m_iState==STATE_ON_THE_WAY)then
				var real fMaxDis=pxB^.GetCollisionRadius();
				var real fMaxDiff=pxB^.GetCollisionRadius()+10.0f;
				var bool bLOS=pxF^.CheckLineOfSightFight(pxB,fMaxDis);
				if(bLOS&&(pxB^.GetPos()-pxF^.GetPos()).Abs2()<fMaxDiff)then
					m_iState=STATE_ENTER; 
				else
					if(m_iRetryCounter--<=0)then
						m_iState=STATE_QUIT;
						return;
					endif;
					pxF^.WaitAction(0.8f);
					m_iState=STATE_GOTO;
				endif;
				return;
			elseif(m_iState==STATE_ENTER)then
				var bool bBreak=false, bDone=pxB^.CanTeleportIt(m_xPassenger, bBreak, pxF^.GetOwner());
				if(!bDone)then
					if(bBreak)then
						pxB^.UnregisterPassenger(m_xPassenger);
						m_bRegistered=false;
						m_iState=STATE_QUIT;
						return;
					else
						pxF^.WaitAction(CPortalTerminus.RELEASE_FREQUENCY);
						return;
					endif;
				else
					pxB^.UnregisterPassenger(m_xPassenger);
					m_bRegistered=false;
				endif;
				m_iState=STATE_QUIT;
				return;
			else
				EndTask();
				return;
			endif;
		endif;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
		if(m_xPassenger.IsValid() && m_xBuilding.IsValid() && m_bRegistered)then
			var ^CPortalTerminus pxB=cast<CPortalTerminus>(m_xBuilding.GetObj());
			if(pxB!=null)then
				pxB^.UnregisterPassenger(m_xPassenger);
			endif;
		endif;
	endproc;
	
	export proc bool Break()
		if(m_xPassenger.IsValid())then m_xPassenger.GetObj()^.TerminateAction(); endif;
		if(m_xPassenger.IsValid() && m_xBuilding.IsValid() && m_bRegistered)then
			var ^CPortalTerminus pxB=cast<CPortalTerminus>(m_xBuilding.GetObj());
			if(pxB!=null)then
				pxB^.UnregisterPassenger(m_xPassenger);
			endif;
		endif;
		EndTask();
		return false;
	endproc;
	
	export proc void Skip()
	endproc;
	
	export proc void EndTask()
		UpdateAggressionPos(m_xPassenger);
		if(m_xPassenger.IsValid() && m_xBuilding.IsValid() && m_bRegistered)then
			var ^CPortalTerminus pxB=cast<CPortalTerminus>(m_xBuilding.GetObj());
			if(pxB!=null)then
				pxB^.UnregisterPassenger(m_xPassenger);
			endif;
		endif;
		super.EndTask();
	endproc;
	
endclass;
	
	//========================================================================================
	//=== Vehicle Specials ===================================================================
	//========================================================================================
	
class CExoBash inherit CActionTask
	
	var CObjHndl		m_xActor;
	var string			m_sState;
	var string			m_sAnim;
	var real				m_fRange;
	var real				m_fTimeOffset;
	var real				m_fTime;
	var real				m_fAnimLength;
	var real				m_fDmg;
	var real				m_fEndDmg;
	
	export constructor()
		SetName("ExoBash");
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CExoBash] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xType="ExBa";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,2);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xActor.DoKArc(pxArc^);
		(pxArc^) << m_sState;
		(pxArc^) << m_sAnim;
		(pxArc^) << m_fRange;
		(pxArc^) << m_fTimeOffset;
		(pxArc^) << m_fTime;
		(pxArc^) << m_fAnimLength;
		(pxArc^) << m_fDmg;
		(pxArc^) << m_fEndDmg;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="ExBa")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			if(p_pxReaderNode^.GetVersion()>=1)then
				m_xActor.DoKArc(pxArc^);
				(pxArc^) << m_sState;
				(pxArc^) << m_sAnim;
			endif;
			if(p_pxReaderNode^.GetVersion()>=2)then
				(pxArc^) << m_fRange;
				(pxArc^) << m_fTimeOffset;
				(pxArc^) << m_fTime;
				(pxArc^) << m_fAnimLength;
				(pxArc^) << m_fDmg;
				(pxArc^) << m_fEndDmg;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool Init(CObjHndl p_xActor, real p_fRange, real p_fTimeOffset, real p_fTime, real p_fDmg, real p_fEndDmg, string p_sPath)
		m_sState="start_anim";
		if(!p_xActor.IsValid())then
			m_sState="EndTask";
			return false;
		endif;
		if(p_fDmg>0.0)then
			m_fDmg=p_fDmg;
		else
			m_fDmg=5.0;
		endif;
		if(p_fEndDmg>0.0)then
			m_fEndDmg=p_fEndDmg;
		else
			m_fEndDmg=1.0;
		endif;
		m_xActor=p_xActor;
		if(p_fRange>0.0)then
			m_fRange=p_fRange;
		else
			m_fRange=5.0;
		endif;
		m_fTimeOffset=p_fTimeOffset;
		m_fTime=p_fTime;
		SetSpecialActionPath(p_sPath);
		SetPrepareActionPath(m_xActor, p_sPath, true);
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		if(m_sState=="EndTask")then
			EndTask();
		endif;
	endproc;
	
	proc void USLOnTick(int p_iTime)
		var ^CVehicle pxActor=cast<CVehicle>(m_xActor.GetObj());
		if(pxActor==null)then EndTask(); return; endif;
		if(m_sState=="start_anim")then
			if(!StartSpecialActionTimer(pxActor,true))then
				EndTask();
				return;
			endif;
			pxActor^.MemorizeCurrentFightState(CObjHndl.Invalid(),false,false);
			pxActor^.SetAnim("seas_mobile_suit_sm_0",1);
			m_fAnimLength=pxActor^.GetCurrentAnimLength();
			pxActor^.WaitAction(m_fTimeOffset);
			m_sState="calc_dmg";
		elseif(m_sState=="calc_dmg")then
			//calc
			var int iOwner=pxActor^.GetOwner();
			if(iOwner>=0)then
				if(m_fRange<=0.0)then
					m_fRange=5.0;
				endif;
				var CObjList xList;
				var ^CObjList pxEnemies=CSrvWrap.GetObjMgr()^.GetOwnerEnemyList(iOwner);
				if(pxEnemies==null)then return; endif;
				pxEnemies^.CopySorted(xList, pxActor^.GetPos(), m_fRange);
				var int i, iC=xList.NumEntries();
				for(i=0)cond(i<iC)iter(i++)do
					var ^CCharacter pxChar=cast<CCharacter>(xList[i].GetObj());
					if(pxChar!=null && !pxChar^.GetTransportObj().IsValid() && !pxChar^.GetOnWall())then
						if(pxChar^.GetOnWall())then continue; endif;
						var real fDiffTime=(((Random.GetInt()%100).ToReal())/100.0f) * m_fTime;
						var real fDiffDistance=(Random.GetInt()%40).ToReal()/10.0;
						var vec3 vDir=(pxChar^.GetPos() - pxActor^.GetPos());
						vDir.Normalize();
						vDir.SetZ(vDir.GetZ()+0.5);
						vDir.Normalize();
						pxChar^.SetHitReactionTimer(0.1+fDiffTime,vDir*(1.0f+fDiffDistance));
					endif;
				endfor;
				var ^CAreaDamage pxDmg=new CAreaDamage(m_fRange, m_fDmg, m_fEndDmg, pxActor^.GetOwner(), pxActor^.GetPos());
			endif;
			if(m_fAnimLength>m_fTimeOffset)then
				pxActor^.WaitAction(m_fAnimLength-m_fTimeOffset);
			endif;
			m_sState="finished";
		elseif(m_sState=="finished")then
			m_sState="EndTask";
			pxActor^.ReturnToFight();
		elseif(m_sState=="EndTask")then
			EndTask();
			return;
		endif;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
	endproc;
	
	export proc bool OnActionEnd(bool p_bBroken)
		return false;
	endproc;
	
	export proc void EndTask()
		SetPrepareActionPath(m_xActor, GetSpecialActionPath(), false);
		super.EndTask();
	endproc;
	
	export proc bool Break()
		return false;
	endproc;
	
	export proc void Skip()
	endproc;
	
endclass;
	
class CExoKick inherit CActionTask
	
	var CObjHndl		m_xActor;
	var CObjHndl		m_xTarget;
	var string			m_sState;
	
	export constructor()
		SetName("ExoKick");
		SetCivil(false);
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CExoKick] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xType="ExKi";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xActor.DoKArc(pxArc^);
		m_xTarget.DoKArc(pxArc^);
		(pxArc^) << m_sState;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="ExKi")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xActor.DoKArc(pxArc^);
			m_xTarget.DoKArc(pxArc^);
			(pxArc^) << m_sState;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool Init(CObjHndl p_xActor, CObjHndl p_xTarget, string p_sPath)
		m_sState="start_anim";
		if(!p_xActor.IsValid()||!p_xTarget.IsValid())then
			m_sState="EndTask";
			return false;
		endif;
		m_xActor=p_xActor;
		m_xTarget=p_xTarget;
		SetSpecialActionPath(p_sPath);
		SetPrepareActionPath(m_xActor, p_sPath, true);
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		if(m_sState=="EndTask")then
			EndTask();
		endif;
	endproc;
	
	proc void USLOnTick(int p_iTime)
		var ^CVehicle pxActor=cast<CVehicle>(m_xActor.GetObj());
		if(pxActor==null)then EndTask(); return; endif;
		if(m_sState=="start_anim")then
			if(!StartSpecialActionTimer(pxActor,true))then
				EndTask();
				return;
			endif;
			pxActor^.MemorizeCurrentFightState(CObjHndl.Invalid(),false,false);
			pxActor^.AnimAction("seas_mobile_suit_fm_0");
			var int iOwner=pxActor^.GetOwner();
			if(iOwner>=0)then
				var ^CFightingObj pxFight=cast<CFightingObj>(m_xTarget.GetObj());
				if(pxFight!=null)then
					if(!pxFight^.GetOnWall())then
						pxFight^.TakeDmg(pxActor,false,2.0);
					endif;
				endif;
				var ^CCharacter pxChar=cast<CCharacter>(pxFight);
				if(pxChar!=null && !pxChar^.GetTransportObj().IsValid())then
					if(!pxChar^.GetOnWall())then
						var vec3 vDir=(pxChar^.GetPos() - pxActor^.GetPos());
						vDir.Normalize();
						vDir.SetZ(vDir.GetZ()+0.5);
						vDir.Normalize();
						pxChar^.SetHitReactionTimer(0.7,vDir*(10.0f));
					endif;
				endif;
			endif;
			m_sState="finished";
		elseif(m_sState=="finished")then
			m_sState="EndTask";
			pxActor^.ReturnToFight();
		elseif(m_sState=="EndTask")then
			EndTask();
			return;
		endif;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
	endproc;
	
	export proc void EndTask()
		SetPrepareActionPath(m_xActor, GetSpecialActionPath(), false);
		super.EndTask();
	endproc;
	
	export proc bool Break()
		return false;
	endproc;
	
	export proc void Skip()
	endproc;
	
endclass;
	
class CGetFoodTask inherit CGenericHarvest
	
	var vec3					m_vLastJobPos;
	var bool					m_bIsFruit;
	var CObjQuery			m_xDeliverSearch;
	var CObjQuery			m_xFoodSearch;
	var CObjQuery			m_xFruitSearch;
//	var CObjQuery			m_xHuntSearch;
//	var string				m_sHuntClass;
	var real					m_fTargetRadius;
	var CObjList			m_xInvalidHarvestSites;
	var bool					m_bAllHarvestSitesInvalid;
	var string				m_sLastGFX;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CGetFoodTask] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xType="GFoT";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,3);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		(pxArc^) << m_vLastJobPos;
		(pxArc^) << m_bIsFruit;
//		(pxArc^) << m_sHuntClass;
		(pxArc^) << m_fTargetRadius;
		(pxArc^) << m_sLastGFX;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="GFoT")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			if(p_pxReaderNode^.GetVersion()>=1)then
				(pxArc^) << m_vLastJobPos;
				(pxArc^) << m_bIsFruit;
			endif;
			if(p_pxReaderNode^.GetVersion()>=2)then
//				(pxArc^) << m_sHuntClass;
				(pxArc^) << m_fTargetRadius;
			endif;
			if(p_pxReaderNode^.GetVersion()>=3)then
				(pxArc^) << m_sLastGFX;
			endif;
			var ^CGameObj pxWorker=m_xWorker.GetObj();
			if(pxWorker!=null)then
				m_xDeliverSearch.SetOwner(pxWorker^.GetOwner());
				m_xDeliverSearch.SetAttribsNeg("CurTask","BuildUp");
				m_xDeliverSearch.SetAttribsPos("foodDelivery",true);
				m_xFoodSearch.SetType("FOOD");
				m_xFoodSearch.SetAttribsPos("Meat",true);
				m_xFoodSearch.SetAttribsNeg("skip_this",1);
				m_xFruitSearch.SetType("FRUI");
	//			if(!m_sHuntClass.IsEmpty())then
	//				m_xHuntSearch.SetClass(m_sHuntClass);
	//				m_xHuntSearch.SetOwner(-1);
	//			endif;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool Init(CObjHndl p_xWorker,CObjHndl p_xFood)
		SetName("GetFoodTask");
		m_xWorker=p_xWorker;
		m_xHarvestSite=p_xFood;
		m_sState="goto_food";
		var ^CGameObj pxWorker=m_xWorker.GetObj();
		if(pxWorker==null)then return false; endif;
		pxWorker^.AnnounceState("getfood");
		//Check if unit may harvest
		var ^CFightingObj pxFightingObj=cast<CFightingObj>(pxWorker);
		if(!pxFightingObj^.CanHarvest())then return false;endif;
		var ^CFood pxResi=cast<CFood>(m_xHarvestSite.GetObj());
		if(pxResi==null||pxResi^.SkipThis())then return false; endif;
		var string sSetting=CSrvWrap.GetCurLevel()^.GetLevelInfo().GetAttribs().GetValue("Setting");
		if(sSetting=="Cave3")then
			sSetting="Oasis";
		endif;
		if(pxResi^.GetClassName()==sSetting+"_Fruit_Bush")then
			m_bIsFruit=true;
		else
			m_bIsFruit=false;
		endif;
		var ^CDino_Food pxDinoFood=cast<CDino_Food>(pxResi);
		if(pxDinoFood!=null && pxDinoFood^.IsFeignDeathProduct())then return false; endif;
		m_xDeliverSearch.SetOwner(pxWorker^.GetOwner());
		m_xDeliverSearch.SetAttribsNeg("CurTask","BuildUp");
		m_xDeliverSearch.SetAttribsPos("foodDelivery",true);
		m_xFoodSearch.SetType("FOOD");
		m_xFoodSearch.SetAttribsPos("Meat",true);
		m_xFoodSearch.SetAttribsNeg("skip_this",1);
		m_xFruitSearch.SetType("FRUI");
		m_xFruitSearch.SetAttribsNeg("fish",1);
		if(!m_xHarvestSite.IsValid())then return false; endif;
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel!=null)then
			var ^CPlayer pxPlayer=pxLevel^.GetPlayer(pxWorker^.GetOwner());
			var ^CPropDB pxRes;
			var ^CPropDB.CNode pxResTable;
			if(pxPlayer!=null)then
				var ^CBasePlayer pxBasePlayer=cast<CBasePlayer>(pxPlayer);
				pxRes=pxBasePlayer^.GetResourceTable();
			endif;
			if(pxRes!=null)then
				if(m_xHarvestSite.GetObj()^.GetType()=="FRUI")then
					pxResTable=pxRes^.GetRoot().Get("FRUI");
				else
					pxResTable=pxRes^.GetRoot().Get("FOOD");
				endif;
			endif;
//			if(m_xHarvestSite.GetObj()^.GetType()=="FOOD")then
//				var ^CDino_Food pxFood=cast<CDino_Food>(m_xHarvestSite.GetObj());
//				if(pxFood!=null && pxFood^.GetAggressive()==-1 && pxFood^.GetOwner()==-1)then
//					m_sHuntClass=pxFood^.GetClassName();
//					m_sHuntClass=m_sHuntClass.Left(m_sHuntClass.Find("_food"));
//					m_xHuntSearch.SetOwner(-1);
//					m_xHuntSearch.SetClass(m_sHuntClass);
//				endif;
//			endif;
			m_asResources=0;
			var int i;
			if(pxResTable!=null)then
				for(i=0)cond(i<pxResTable^.NumSubs())iter(i++)do
					m_asResources.AddEntry((pxResTable^)[i].Name());
				endfor;
			endif;
			m_afMineVal=m_asResources.NumEntries();
		endif;
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom,^CState p_pxTo)
		if(m_xWorker.GetObj()==null||m_sState=="end_task")then EndTask();return; endif;
		var ^CGameObj pxFood=m_xHarvestSite.GetObj();
		if(pxFood==null)then EndTask();return; endif;
		if(pxFood^.GetType()!="FOOD" && pxFood^.GetType()!="FRUI")then EndTask();return; endif;
		var ^CFood pxResi=cast<CFood>(m_xHarvestSite.GetObj());
		if(pxResi==null||pxResi^.SkipThis())then return; endif;
		var ^CDino_Food pxDinoFood=cast<CDino_Food>(pxResi);
		if(pxDinoFood!=null && pxDinoFood^.IsFeignDeathProduct())then EndTask();return; endif;
		var ^CTransportObj pxWorker=cast<CTransportObj>(m_xWorker.GetObj());
		if(pxWorker==null)then EndTask(); return; endif;
		if(m_asResources.NumEntries()>0)then
			pxWorker^.SetTaskDescription(m_asResources[0]);
		endif;
		var ^CAttribs pxAttr=pxWorker^.GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("CurTask",GetName());
		endif;
		SetMaxCounter(4);
	endproc;
	
	proc void USLOnTick(int p_iTime)
		var ^CTransportObj pxWorker;
		begin CheckWorker;
			pxWorker=cast<CTransportObj>(m_xWorker.GetObj());
			if(pxWorker==null)then
				EndTask();
				return;
			endif;
			if(
				(cast<CHarvester>(pxWorker)==null) &&
				(cast<CMammoth>(pxWorker)==null || !(cast<CMammoth>(pxWorker))^.CanHarvest()) &&
				(cast<CMechWalker>(pxWorker)==null || !(cast<CMechWalker>(pxWorker))^.CanHarvest())  &&
				(cast<CLumberjack>(pxWorker)==null || !(cast<CLumberjack>(pxWorker))^.CanHarvest())
			)then
				EndTask();
				return;
			endif;
		end CheckWorker;
		var ^CFood pxFood;
		begin CheckFood;
			var ^CGameObj pxTmp=m_xHarvestSite.GetObj();
			if(pxTmp!=null)then
				pxFood=cast<CFood>(pxTmp);
			endif;
		end CheckFood;
		begin CheckInventory;
			if(m_sState!="drop_food")then
				var bool bResFull=true;
				if(!pxWorker^.LinkOccupied())then
					bResFull=false;
				endif;
				if(m_sState!="goto_deliver" && m_sState!="goto_food")then
					if(bResFull)then
						m_sState="goto_deliver";
					endif;
				endif;
				if((pxFood==null||pxFood^.SkipThis()) && m_sState!="search_for_jobs")then
					m_sState="goto_deliver";
				endif;
			endif;
		end CheckInventory;	
		if((pxFood==null||pxFood^.SkipThis()) && m_sState!="drop_food"&&m_sState!="goto_deliver")then
			m_sState="search_for_jobs";
		endif;
		if(m_sState=="goto_food")then
			CSrvWrap.GetObjMgr()^.GetFreePos(m_vCurTarget,pxWorker,pxFood^.GetPos());
			m_vLastJobPos=pxFood^.GetPos();
			if(pxWorker^.GetOnWall())then
				pxWorker^.WallWalkAction(m_vCurTarget,true,pxWorker^.GetDefaultSpeed(),false);
			else
				pxWorker^.WalkAction(m_vCurTarget,pxWorker^.GetDefaultSpeed(),true);
			endif;
			SetCurrentTarget(m_vCurTarget);
			m_sState="rotate_to_target";
		elseif(m_sState=="rotate_to_target")then
			if(pxFood==null||pxFood^.SkipThis())then
				m_sState="search_for_jobs";
				return;
			endif;
			if(!HasArrivedTarget(pxWorker^.GetPos(),4.0))then
				if(!CanFollow())then
					ResetCounter();
					m_xInvalidHarvestSites.Include(pxFood^.GetHandle());
					m_sState="search_for_jobs";
					return;
				else
					m_sState="goto_food";
					return;
				endif;
			else
				var vec3 vDir=pxFood^.GetPos()-pxWorker^.GetPos();
				var Quat qTRot;
				qTRot.FromXYDir(vDir.GetX(),vDir.GetY());
				pxWorker^.RotateAction(qTRot);
				m_sState="bash_food";
			endif;
		elseif(m_sState=="bash_food")then
			if((pxWorker^.GetPos()-m_vCurTarget).Abs()>=2.0)then
				m_sState="goto_food";
			else
				m_sState="add_food_to_inv";
				pxWorker^.DoMineAnim();
				var CGameTime xNow=CTimeMgr.Get().GetTime();
				m_xLastTick=xNow;
			endif;
		elseif(m_sState=="add_food_to_inv")then
			if(pxFood==null||pxFood^.SkipThis())then
				m_sState="search_for_jobs";
			else
				var ^CFruit_Food pxTmp=cast<CFruit_Food>(pxFood);
				if(pxTmp!=null)then
					m_sLastGFX=pxTmp^.GetGfxName();
				else
					m_sLastGFX="";
				endif;
//				if(pxWorker^.GetClassName()=="seas_mechanical_walker")then
					var real fMined=pxFood^.Mine(pxWorker^.GetResInvCapFood());
					pxWorker^.SetResInvFood(fMined);
//				else
//					pxWorker^.SetResInvFood(pxFood^.Mine(pxFood^.GetValueLeft()+1.0f));
//				endif;
				m_sState="goto_deliver";
				if(pxTmp!=null)then
					pxTmp^.OnUpdateFlags();
				endif;
			endif;
		elseif(m_sState=="goto_deliver")then
			var CObjList xDeliveries;
//			if(pxFood!=null && pxFood^.GetType()=="FRUI")then
			var ^CFruit_Food pxTmp=cast<CFruit_Food>(pxFood);
			if(!m_sLastGFX.IsEmpty())then
				pxWorker^.LinkToStock(m_sLastGFX);
			else
				pxWorker^.LinkToStock("aje_meat_01");
			endif;
			CSrvWrap.GetDiplomacyMgr().AddOtherFriendsToSearch(pxWorker^.GetOwner(), m_xDeliverSearch);
			if(m_xDeliverSearch.Execute(xDeliveries))then
				xDeliveries.SortDistance(pxWorker^.GetPos());
				var ^CGameObj pxDel=xDeliveries[0].GetObj();
				m_vCurDelivery=pxDel^.GetPos();
				m_xCurDelivery=xDeliveries[0];
				m_vCurTarget=m_vCurDelivery;
				m_fTargetRadius=pxDel^.GetRadius();
				var CGameObj.CAdvanceActionParams xAWAP;
				xAWAP.m_fMinDistance=0.0f;
				xAWAP.m_iPrefSpeed=pxWorker^.GetDefaultSpeed();
				xAWAP.m_xWalkSet="def";
				if(pxWorker^.GetOnWall())then
					pxWorker^.AdvanceWallAction(pxDel^.GetHandle(),xAWAP,true,false);
				else
					pxWorker^.AdvanceAction(pxDel^.GetHandle(),xAWAP);
				endif;
				m_sState="drop_food";
			else
				EndTask();
				return;
			endif;
		elseif(m_sState=="search_for_jobs")then
			m_xFoodSearch.RegionCircle(m_vLastJobPos,100.0);
			m_xFruitSearch.RegionCircle(m_vLastJobPos,100.0);
//			m_xHuntSearch.RegionCircle(m_vLastJobPos,100.0);
			var CObjList xL;
			if(m_xFoodSearch.Execute(xL))then
				xL.SortDistance(pxWorker^.GetPos());
				while(xL.NumEntries()>0)do
					if(m_xInvalidHarvestSites.FindEntry(xL[0])!=-1)then
						xL.DeleteEntry(0);
						continue;
					endif;
					if(!pxWorker^.CheckMaxAutoprodDist(xL[0]))then
						xL.DeleteEntry(0);
						continue;
					endif;
					break;
				endwhile;
				if(xL.NumEntries()>0)then
					m_xHarvestSite=xL[0];
					m_xInvalidHarvestSites.Clear();
					m_sState="goto_food";
					return;
				else
					if(m_bAllHarvestSitesInvalid)then
						CSrvWrap.SendGenericEvtToPlayer(pxWorker^.GetOwner(), "NoMoreFood");
						EndTask();
						return;
					else
						m_bAllHarvestSitesInvalid=true;
						m_xInvalidHarvestSites.Clear();
						return;
					endif;
				endif;
			elseif(m_xFruitSearch.Execute(xL))then
				xL.SortDistance(pxWorker^.GetPos());
				while(xL.NumEntries()>0)do
					if(m_xInvalidHarvestSites.FindEntry(xL[0])!=-1)then
						xL.DeleteEntry(0);
						continue;
					endif;
					if(!pxWorker^.CheckMaxAutoprodDist(xL[0]))then
						xL.DeleteEntry(0);
						continue;
					endif;
					break;
				endwhile;
				if(xL.NumEntries()>0)then
					m_xHarvestSite=xL[0];
					m_xInvalidHarvestSites.Clear();
					m_sState="goto_food";
					return;
				else
					if(m_bAllHarvestSitesInvalid)then
						CSrvWrap.SendGenericEvtToPlayer(pxWorker^.GetOwner(), "NoMoreFood");
						EndTask();
						return;
					else
						m_bAllHarvestSitesInvalid=true;
						m_xInvalidHarvestSites.Clear();
						return;
					endif;
				endif;
			else
				CSrvWrap.SendGenericEvtToPlayer(pxWorker^.GetOwner(), "NoMoreFood");
				var bool bResInvEmtpy=true;
				bResInvEmtpy=pxWorker^.GetResInvFood()<=0.0;
				if(!bResInvEmtpy)then
					m_sState="goto_deliver";
					return;
				else
					EndTask();
					return();
				endif;
			endif;
		elseif(m_sState=="drop_food")then
			if(!m_xCurDelivery.IsValid())then
				m_sState="goto_deliver";
				return;
			endif;
			if((pxWorker^.GetPos()-m_vCurTarget).Abs()>=m_fTargetRadius*1.3)then
				m_sState="goto_deliver";
			else
				var bool bPutSomethingDown=false;
				if(pxWorker^.CheckInResInvFood())then
					bPutSomethingDown=true;
				endif;
				if(bPutSomethingDown)then
					var ^CFightingObj pxDelivery=cast<CFightingObj>(m_xCurDelivery.GetObj());
					if(pxDelivery!=null)then
						pxDelivery^.AcceptDeliveries();
					endif;
					pxWorker^.ClearLink();
					//pxWorker^.WaitAction(1.0f);
					if(pxFood==null||pxFood^.SkipThis())then
						m_sState="search_for_jobs";
					else
						m_sState="goto_food";
					endif;
					return;
				else
					pxWorker^.WaitAction(2.0f); //wait 2 secs for free checkin
					return;
				endif;
			endif;
		else
			pxWorker^.ClearLink();
			EndTask();
		endif;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
		var ^CMechWalker pxWorker=cast<CMechWalker>(m_xWorker.GetObj());
		if(pxWorker==null)then return; endif;
		pxWorker^.SetTaskDescription("");
	endproc;
	
	export proc bool Break()
		var ^CGameObj pxWorker=m_xWorker.GetObj();
		if(pxWorker!=null)then pxWorker^.TerminateAction(); endif;
		return true;
	endproc;
	
endclass;
	
class CMKHand inherit CActionTask
	
	var CObjHndl		m_xHandle;
	var string			m_sState;
	
	export constructor()
		SetName("MKHand");
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CMKHand] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xType="MKHn";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xHandle.DoKArc(pxArc^);
		(pxArc^) << m_sState;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="MKHn")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xHandle.DoKArc(pxArc^);
			(pxArc^) << m_sState;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;	
	
	export proc bool Init(CObjHndl p_xHandle, string p_sPath)
		m_sState="start_anim";
		if(!p_xHandle.IsValid())then
			m_sState="EndTask";
			return false;
		endif;
		m_xHandle=p_xHandle;
		SetSpecialActionPath(p_sPath);
		SetPrepareActionPath(m_xHandle, p_sPath, true);
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		if(m_sState=="EndTask")then
			EndTask();
		endif;
	endproc;
	
	proc void USLOnTick(int p_iTime)
		var ^CVehicle pxHandle=cast<CVehicle>(m_xHandle.GetObj());
		if(pxHandle==null)then EndTask(); return; endif;
		if(m_sState=="start_anim")then
			if(!StartSpecialActionTimer(pxHandle))then
				EndTask();
				return;
			endif;
			pxHandle^.AnimAction("lumberjack_sm_0");
			m_sState="intimidate";
			return;
		elseif(m_sState=="intimidate")then
			var real fRange=50.0f, fDuration=20.0f;
			var CObjList xEnemies;
			var CObjQuery xQuery;
			CSrvWrap.GetDiplomacyMgr().AddMyEnemiesToSearch(pxHandle^.GetOwner(), xQuery, false);
			xQuery.SetOwner(-1, true);
			xQuery.SetType("CHTR");
			xQuery.SetType("SHIP",true);
			xQuery.SetType("ANML",true);
			xQuery.SetType("VHCL",true);
			xQuery.SetType("BLDG",true);
			xQuery.SetType("FGHT",true);
			xQuery.RegionCircle(pxHandle^.GetPos(), fRange);
			xQuery.Execute(xEnemies);
			var int i, iC=xEnemies.NumEntries();
			for(i=0)cond(i<iC)iter(++i)do
				var ^CFightingObj pxFO=cast<CFightingObj>(xEnemies[i].GetObj());
				if(pxFO==null)then continue; endif;
				pxFO^.Intimidate(m_xHandle,fDuration);
			endfor;
			CFightingObj.InvokeAreaThrow(pxHandle^.GetPos(), 10.0f, pxHandle^.GetOwner(), 10);
			m_sState="EndTask";
		elseif(m_sState=="EndTask")then
			EndTask();
			return;
		endif;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
	endproc;
	
	export proc bool Break()
		if(m_xHandle.IsValid())then
			m_xHandle.GetObj()^.TerminateAction();
		endif;
		return true;
	endproc;
	
	export proc void EndTask()
		SetPrepareActionPath(m_xHandle, GetSpecialActionPath(), false);
		super.EndTask();
	endproc;
	
	export proc void Skip()
	endproc;
	
endclass;
	
class CSpecialJumpjet inherit CSpecialActionTask
	
	var CObjHndl		m_xActor;
	var string			m_sState;
	var vec3				m_vJumpPos;
	const real			m_fMaxDistance=300.0f;	//Maximum jumping distance.
	
	export constructor()
		SetName("SpecSuitJ");
		SetCivil(false);
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CSpecialJumpjet] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xType="SMSJ";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,2);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xActor.DoKArc(pxArc^);
		(pxArc^) << m_sState;
		(pxArc^) << m_vJumpPos;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="SMSJ")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xActor.DoKArc(pxArc^);
			(pxArc^) << m_sState;
			(pxArc^) << m_vJumpPos;
			if(p_pxReaderNode^.GetVersion()==1)then
				var string sInvalid;
				(pxArc^) << sInvalid;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool Init(CObjHndl p_xActor, vec3 p_vPos, string p_sTTPath)
		SetSpecialActionPath(p_sTTPath);
		SetName("SpecSuitJ");
		var ^CSpecialMobileSuit pxActr=cast<CSpecialMobileSuit>(p_xActor.GetObj());
		var ^CSeasTerminator pxUnit=cast<CSeasTerminator>(p_xActor.GetObj());
		if(pxActr==null&&pxUnit==null)then return false; endif;
		m_xActor=p_xActor;
		m_vJumpPos=p_vPos;
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		var ^CFightingObj pxFightingObj=cast<CFightingObj>(m_xActor.GetObj());
		if(pxFightingObj==null||!pxFightingObj^.CheckSpecialActionTimer(GetSpecialActionPath()))then
			EndTask();
			return;
		endif;
		if(m_xActor.IsValid())then
			var ^CSpecialMobileSuit pxActor=cast<CSpecialMobileSuit>(m_xActor.GetObj());
			var ^CSeasTerminator pxUnit=cast<CSeasTerminator>(m_xActor.GetObj());
			if(pxActor==null&&pxUnit==null)then EndTask();return;endif;
			var vec3 vPos;
			var vec3 vWay=m_vJumpPos-pxFightingObj^.GetPos();
			var real fLength=vWay.Abs();
			if(fLength>m_fMaxDistance)then
				vWay.Normalize();
				var real fTemp=fLength-m_fMaxDistance;
				m_vJumpPos=GetAdoptedDest(pxFightingObj^.GetPos(),m_vJumpPos,fTemp);
			endif;
		endif;
		m_sState="rotate_to_target";
	endproc;
	
	proc void USLOnTick(int p_iTime)
		if(!m_xActor.IsValid())then EndTask();return;endif;
		var ^CFightingObj pxFO=cast<CFightingObj>(m_xActor.GetObj());
//		var ^CSeasTerminator pxUnit=cast<CSeasTerminator>(m_xActor.GetObj());
//		var ^CSpecialMobileSuit pxActor=cast<CSpecialMobileSuit>(m_xActor.GetObj());
		if(pxFO==null)then EndTask();return;endif;
		if(m_sState=="rotate_to_target")then
			var vec3 vWay=m_vJumpPos-pxFO^.GetPos();
			var Quat qRot;
			qRot.FromXYDir(vWay.GetX(), vWay.GetY());
			pxFO^.RotateAction(qRot);
			m_sState="prepare_to_jump_3";
		elseif(m_sState=="prepare_to_jump_3")then
			if(!pxFO^.GetFreePos(m_vJumpPos,15.0))then
				EndTask();
				return;
			endif;
			if(!CheckSpecialActionTimer(pxFO))then
				EndTask();
				return;
			endif;
			SetUnStoppable(true);
			pxFO^.AnimAction("jumpjet",0,true,false);
			m_sState="jump_to_target";
		elseif(m_sState=="jump_to_target")then
			m_vJumpPos.SetZ(CSrvWrap.GetScapeMgr().GetHeight(m_vJumpPos.GetX(), m_vJumpPos.GetY()));
			pxFO^.SetSLEAnim("jumpjet",9999,false,false);
			pxFO^.RemoveFromWall();
			pxFO^.JetPackAction(m_vJumpPos);
			m_sState="land_1";
		elseif(m_sState=="land_1")then
//			pxFO^.EndCurrentLoopAnim();
//			pxFO^.AnimActionStopLoop();
			pxFO^.SetAnim("jumpjet",2);
			pxFO^.WaitAction(pxFO^.GetCurrentAnimLength());
			m_sState="land_2";
		elseif(m_sState=="land_2")then
//			pxFO^.SetAnim("jumpjet",2,36);
			SetUnStoppable(false);
			StartSpecialActionTimer(pxFO);
			m_sState="end";
		elseif(m_sState=="end")then
			EndTask();
		endif;
	endproc;
	
	export proc void RandomizePos(ref vec3 po_rvPos)
		po_rvPos.SetX(po_rvPos.GetX()+(Random.GetInt()%10+1).ToReal());
		po_rvPos.SetY(po_rvPos.GetY()+(Random.GetInt()%10+1).ToReal());
		po_rvPos.SetZ(CSrvWrap.GetScapeMgr().GetHeight(po_rvPos.GetX(), po_rvPos.GetY()));
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
	endproc;
	
	export proc bool Break()
		if(GetUnStoppable())then
			return false;
		endif;
		if(m_xActor.IsValid())then
			m_xActor.GetObj()^.TerminateAction();
		endif;
		return true;
	endproc;
	
	export proc void EndTask()
		UpdateAggressionPos(m_xActor);
		super.EndTask();
	endproc;
	
endclass;
	
class CSpecialMinigun inherit CSpecialActionTask
	
	//Badgun Tuning: Babbage Special Move
	const real				RANGE=35.0;
	const real				ANGLE=30.0;
	const real				DAMAGE_PERCENT=60.0;
	const real				DAMAGE_MINIMAL=300.0;
	const real				DAMAGE_MAXIMAL=3000.0;
	
	var CObjHndl			m_xCharacter;
	var CObjHndl			m_xTarget;
	var string				m_sState;
	var int						m_iRetryCounter;
	var array string	m_asValidTargets;
	var vec3					m_vPos;
	
	export constructor()
		SetName("SpecSuitM");
		SetCivil(false);
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		KLog.LogWarn("CArc.Save","[CSpecialMinigun] Saving '"+p_pxWriterNode^.GetType().ToString()+"'");
		super.Save(p_pxWriterNode);
		var CFourCC xType="SMSM";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,2);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xCharacter.DoKArc(pxArc^);
		m_xTarget.DoKArc(pxArc^);
		(pxArc^) << m_sState;
		(pxArc^) << m_iRetryCounter;
		var int i,iC=m_asValidTargets.NumEntries();
		(pxArc^) << iC;
		for(i=0) cond(i<iC) iter(i++)do
			(pxArc^) << m_asValidTargets[i];
		endfor;
		(pxArc^) << m_vPos;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="SMSM")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xCharacter.DoKArc(pxArc^);
			m_xTarget.DoKArc(pxArc^);
			(pxArc^) << m_sState;
			(pxArc^) << m_iRetryCounter;
			var int i,iC;
			(pxArc^) << iC;
			m_asValidTargets=iC;
			for(i=0) cond(i<iC) iter(i++)do
				(pxArc^) << m_asValidTargets[i];
			endfor;
			if(p_pxReaderNode^.GetVersion()>=2)then
				(pxArc^) << m_vPos;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool Init(CObjHndl p_xCharacter,CObjHndl p_xTarget, vec3 p_vPos, string p_sPath)
		m_sState="goto_target";
		if(!p_xCharacter.IsValid()||(!p_xTarget.IsValid() && p_vPos=={0.0,0.0,0.0}))then
			m_sState="EndTask";
			return false;
		endif;
		if(p_xTarget.IsValid() && p_xTarget.GetObj()^.GetOwner()==p_xCharacter.GetObj()^.GetOwner())then
			m_sState="EndTask";
			return false;
		endif;
		m_xCharacter=p_xCharacter;
		m_xTarget=p_xTarget;
		m_vPos=p_vPos;
		SetSpecialActionPath(p_sPath);
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		var ^CFightingObj pxFightingObj=cast<CFightingObj>(m_xCharacter.GetObj());
		if(pxFightingObj==null||!pxFightingObj^.CheckSpecialActionTimer(GetSpecialActionPath()))then
			EndTask();
			return;
		endif;
		if(m_sState=="EndTask")then
			EndTask();
		endif;
	endproc;

	proc void USLOnTick(int p_iTime)
		var ^CSpecialMobileSuit pxCharacter=cast<CSpecialMobileSuit>(m_xCharacter.GetObj());
		var ^CFightingObj pxTarget=cast<CFightingObj>(m_xTarget.GetObj());
		if(pxCharacter==null)then EndTask(); return; endif;
		if(m_sState=="goto_target")then
			var real fAttackRange=pxCharacter^.GetAttackRange();
			var bool bInvalid;
			var CObjHndl xInvalid;
			if(pxTarget!=null)then
				if(!pxCharacter^.IsInCombatRange(pxTarget, bInvalid, xInvalid))then
//					if(pxCharacter^.GetOnWall())then
//						EndTask();
//						return;
//					endif;
					pxCharacter^.AdvanceAction(pxTarget^.GetHandle(),fAttackRange,pxCharacter^.GetMaxSpeed());
				endif;
			else
				if(!pxCharacter^.IsInScapeCombatRange(m_vPos, bInvalid))then
//					if(pxCharacter^.GetOnWall())then
//						EndTask();
//						return;
//					endif;
					pxCharacter^.AdvanceAction(CObjHndl.Invalid(),fAttackRange,pxCharacter^.GetMaxSpeed(),pxCharacter^.GetWalkSet(),99999.9,pxCharacter^.GetPos(),m_vPos);
				endif;
			endif;
			m_sState="rotate";
		elseif(m_sState=="rotate")then
			var bool bInvalid;
			var CObjHndl xInvalid;
			var bool bContinue=false;
			if(pxTarget!=null)then
				if(!pxCharacter^.IsInCombatRange(pxTarget, bInvalid, xInvalid))then
					if(m_iRetryCounter>3)then
						EndTask();
						return;
					else
						m_iRetryCounter++;
						m_sState="goto_target";
						return;
					endif;
				else
					m_vPos=pxTarget^.GetPos();
					bContinue=true;
				endif;
			else
				if(!pxCharacter^.IsInScapeCombatRange(m_vPos, bInvalid))then
					if(m_iRetryCounter>3)then
						EndTask();
						return;
					else
						m_iRetryCounter++;
						m_sState="goto_target";
						return;
					endif;
				else
					bContinue=true;
				endif;
			endif;
			if(bContinue)then
				var vec3 vDir=m_vPos-pxCharacter^.GetPos();
				var Quat qTRot;
				qTRot.FromXYDir(vDir.GetX(),vDir.GetY());
				pxCharacter^.RotateAction(qTRot);
				pxCharacter^.ActivatePiercing(true,15.0f);
				m_sState="throw";
				m_iRetryCounter=0;
				if(!StartSpecialActionTimer(pxCharacter))then
					EndTask();
					return;
				endif;
				pxCharacter^.MemorizeCurrentFightState(m_xTarget,true,false);
				SetUnStoppable(true);
				return;
			endif;
		elseif(m_sState=="throw")then
			if(m_iRetryCounter>=7)then
				m_sState="finished";
				pxCharacter^.SetSLEAnim("attack_ranged", 4, false, true);
			else
				m_iRetryCounter++;
				pxCharacter^.SetSLEAnim("attack_ranged", 4, m_iRetryCounter==0, false);
			endif;
			var CObjList xList;
			pxCharacter^.GetPenetratedObjs(m_vPos, pxCharacter^.GetAttackRange(), xList, ANGLE);
			var int i, iC=xList.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				var ^CFightingObj pxFight=cast<CFightingObj>(xList[i].GetObj());
				if(pxFight!=null)then
					if(pxCharacter^.Disarmed())then continue; endif; //Kr1s1m: GetDmg() = 0, zero division on next line if disarmed
					var real fDamageFactor=(Math.Clamp((pxFight^.GetHitpoints()*0.01)*DAMAGE_PERCENT,DAMAGE_MINIMAL,DAMAGE_MAXIMAL) / pxCharacter^.GetDmg())*0.125;
					pxFight^.ClearDamageCache();
					pxFight^.TakeDmg(pxCharacter, true, fDamageFactor);
				endif;
			endfor;
		elseif(m_sState=="finished")then
			SetUnStoppable(false);
			m_sState="EndTask";
			pxCharacter^.ActivatePiercing(false,0.0f);
			pxCharacter^.ReturnToFight();
			return;
		elseif(m_sState=="finished")then
			EndTask();
			return;
		endif;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
	endproc;
	
	export proc bool Break()
		if(GetUnStoppable())then
			return false;
		endif;
		if(m_xCharacter.IsValid())then
			m_xCharacter.GetObj()^.TerminateAction();
		endif;
		return true;
	endproc;
	
	export proc void Skip()
	endproc;
	
	export proc void EndTask()
		UpdateAggressionPos(m_xCharacter);
		var ^CSpecialMobileSuit pxCharacter=cast<CSpecialMobileSuit>(m_xCharacter.GetObj());
		if(pxCharacter!=null)then
			pxCharacter^.ActivatePiercing(false,0.0f);
		endif;
		super.EndTask();
	endproc;
	
endclass;