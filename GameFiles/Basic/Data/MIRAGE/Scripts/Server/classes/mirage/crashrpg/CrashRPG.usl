
	//========================================================================================
	//=== Crash RPG ==========================================================================
	//========================================================================================
	
class CCrashRPGMgr inherit CFightingObj
	
	export static var CObjHndl ms_xCrashRPGMgr;
	export static var bool ms_bFlyPickup;
	
//	class CUnitRespawn inherit CEvtSink
	class CUnitRespawn
	
		export var procref <void, string, int, int, bool, int, int, int, CObjList, CObjHndl, int> m_xOnRespawn;
		
		var string m_sClass;
		var int m_iLevel;
		var int m_iOwner;
		var bool m_bAI;
		var int m_iKillerCount;
		var int m_iKillerHistory;
		var int m_iAggressionState;
		var CObjList m_xFountains;
		var CObjHndl m_xZeppelin;
		var int m_iTimer;
		var real m_fDuration;
		var int m_iID;
		
		export constructor()
			m_xOnRespawn=OnRespawn;
//			m_iTimer=-1;
		endconstructor;
		
		export destructor()
//			if(m_iTimer!=-1)then
//				CTimeMgr.Get().GetTimer(m_iTimer)^.Unsubscribe(this);
//				CTimeMgr.Get().DeleteTimer(m_iTimer);
//			endif;
		enddestructor;
		
		proc void OnRespawn(string p_sClass, int p_iLevel, int p_iOwner, bool p_bAI, int p_iKCnt, int p_iKHistory, int p_iAState, CObjList p_xHWells, CObjHndl p_xBlimp, int p_iID)
		endproc;
		
//		export proc bool OnPush(ref CEvtPointer p_rxEP)
//			if(!m_xOnRespawn.IsNull())then
//				m_xOnRespawn.Call(m_sClass,m_iLevel,m_iOwner,m_bAI,m_iKillerCount,m_iKillerHistory,m_iAggressionState,m_xFountains,m_xZeppelin,m_iID);
//			endif;
//			return true;
//		endproc;
		
		export proc void Initialize(string p_sClass, int p_iLevel, int p_iOwner, bool p_bAI, int p_iKCnt, int p_iKHistory, int p_iAState, CObjList p_xHWells, CObjHndl p_xBlimp, int p_iID, real p_fDuration, procref <void, string, int, int, bool, int, int, int, CObjList, CObjHndl, int> p_xProcRef)
			m_sClass=p_sClass;
			m_iLevel=p_iLevel;
			m_iOwner=p_iOwner;
			m_bAI=p_bAI;
			m_iKillerCount=p_iKCnt;
			m_iKillerHistory=p_iKHistory;
			m_iAggressionState=p_iAState;
			m_xFountains=p_xHWells;
			m_xZeppelin=p_xBlimp;
			m_iID=p_iID;
			m_fDuration=p_fDuration;
			m_xOnRespawn=p_xProcRef;
			if(m_fDuration<=0.0f)then
				m_fDuration=1.0f;
			endif;
//			if(m_iTimer==-1)then
//				m_iTimer=CTimeMgr.Get().CreateTimer(CGameTimeSpan.OneSecond() * m_fDuration, false);
//				CTimeMgr.Get().GetTimer(m_iTimer)^.Subscribe(this);
//			endif;
		endproc;
		
		export proc void SetProcRef(procref <void, string, int, int, bool, int, int, int, CObjList, CObjHndl, int> p_xProcRef)
			m_xOnRespawn=p_xProcRef;
		endproc;
		
		export proc void SetTimerID(int p_iID)
			m_iTimer=p_iID;
		endproc;
		
		export proc int GetTimerID()
			return m_iTimer;
		endproc;
		
		export proc bool op_Equal(ref CCrashRPGMgr.CUnitRespawn p_rxO)
			return m_iTimer==p_rxO.GetTimerID();
		endproc;
		
		export proc bool Execute()
			if(!m_xOnRespawn.IsNull())then
				m_xOnRespawn.Call(m_sClass,m_iLevel,m_iOwner,m_bAI,m_iKillerCount,m_iKillerHistory,m_iAggressionState,m_xFountains,m_xZeppelin,m_iID);
			endif;
			return true;
		endproc;
		
		export proc void DoKArc(ref CArc p_rxArc, int p_iVersion)
			p_rxArc << m_sClass;
			p_rxArc << m_iLevel;
			p_rxArc << m_iOwner;
			p_rxArc << m_bAI;
			p_rxArc << m_iKillerCount;
			p_rxArc << m_iKillerHistory;
			p_rxArc << m_iAggressionState;
			p_rxArc << m_iID;
			m_xFountains.DoKArc(p_rxArc);
			m_xZeppelin.DoKArc(p_rxArc);
			p_rxArc << m_iTimer;
//			p_rxArc << m_fDuration;
//			var bool bTimerStart=(m_iTimer==-1);
//			p_rxArc << m_iTimer;
//			if(m_iTimer!=-1&&bTimerStart)then
//				var ^CTimerObj pxTimer=CTimeMgr.Get().GetTimer(m_iTimer);
//				if(pxTimer==null)then
//					m_iTimer=CTimeMgr.Get().CreateTimer(CGameTimeSpan.OneSecond() * m_fDuration, false);
//					CTimeMgr.Get().GetTimer(m_iTimer)^.Subscribe(this);
//				endif;
//			endif;
		endproc;
		
	endclass;
	
	class CSpawnInfo inherit CEvtSink
//	class CSpawnInfo
	
		export var CRegionSink	m_xRegionSink;
		export var CObjHndl			m_xBldgHndl;
		var int									m_iOwner;
		export var bool					m_bContinue;
		var string							m_sClass;
		var string							m_sBuildup;
		var string							m_sPassengers;
		var int									m_iLevel;
		var int									m_iMinAmount;
		var int									m_iMaxAmount;
		var string							m_sRegion;
		export var string				m_sBuilding;
		var real								m_fTimerAlive;
		var real								m_fTimerDead;
		export var real					m_fStartTime;
		var real								m_fEndTime;
		var real								m_fDelay;
		export var bool					m_bActivated;
		var bool								m_bDeactivated;
		var bool								m_bCheck;
		var vec3								m_vDefault;
		var vec3								m_vTarget;
		var int									m_iTimer;
		var int									m_iRepeat;
		var int									m_iSpeed;
		var int									m_iStopper;
		export var real					m_fFrequency;
		var real								m_fPostTime;
		var string							m_sPostTask;
		var bool								m_bRandom;
		var array int						m_aiAmount;
		var int									m_iRandom;
		var int									m_iThreshold;
		
		export constructor()
			m_iTimer = -1;
			m_iStopper = -1;
			m_bDeactivated=false;
		endconstructor;
		
		export destructor()
			if(m_iStopper!=-1)then
				var ^CTimerObj pxTimer=CTimeMgr.Get().GetTimer(m_iStopper);
				if(pxTimer!=null)then
					pxTimer^.Unsubscribe(this);
					CTimeMgr.Get().DeleteTimer(m_iStopper);
				endif;
			endif;
//			delete this;
		enddestructor;
		
		export proc bool OnPush(ref CEvtPointer p_rxEP)
			m_bDeactivated=true;
			return true;
		endproc;
		
		export proc void DoKArc(ref CArc p_rxArc, int p_iVersion)
			m_xBldgHndl.DoKArc(p_rxArc);
			p_rxArc << m_iOwner;
			p_rxArc << m_bContinue;
			p_rxArc << m_sClass;
			p_rxArc << m_sBuildup;
			p_rxArc << m_sPassengers;
			p_rxArc << m_iLevel;
			p_rxArc << m_iMinAmount;
			p_rxArc << m_iMaxAmount;
			p_rxArc << m_sRegion;
			p_rxArc << m_sBuilding;
			p_rxArc << m_fTimerAlive;
			p_rxArc << m_fTimerDead;
			p_rxArc << m_fStartTime;
			p_rxArc << m_fEndTime;
			p_rxArc << m_fDelay;
			p_rxArc << m_bActivated;
			p_rxArc << m_bCheck;
			p_rxArc << m_bRandom;
			p_rxArc << m_vDefault;
			p_rxArc << m_vTarget;
			p_rxArc << m_iTimer;
			p_rxArc << m_iRepeat;
			p_rxArc << m_iSpeed;
			p_rxArc << m_bDeactivated;
			p_rxArc << m_iStopper;
			p_rxArc << m_fFrequency;
			p_rxArc << m_fPostTime;
			p_rxArc << m_sPostTask;
			p_rxArc << m_iThreshold;
			if(m_bRandom && p_rxArc.Reading())then
				var int i;
				for(i=m_iMinAmount)cond(i<=m_iMaxAmount)iter(i++)do
					m_aiAmount.AddEntry(i);
				endfor;
				m_iRandom=m_aiAmount.NumEntries();
			endif;
		endproc;
		
//		var int iIdx=m_axCamouflageLayers.FindEntry(xLayer);
//		export proc bool op_Equal(ref CCrashRPGMgr.CSpawnInfo p_rxInfo)
//			return (m_iTimer==p_rxInfo.m_iTimer);
//			return false;
//		endproc;
		
		export proc bool Init(int p_iPlayers, ^CPropDB.CNode p_pxNode)
			if(p_pxNode==null)then return false; endif;
			m_bActivated=m_bDeactivated=m_bCheck=false;
			m_iOwner=p_pxNode^.GetValueI("owner",-1);
			if(m_iOwner<0||m_iOwner>7)then return false; endif;
			if(p_pxNode^.GetValueS("disabled","false")=="true")then return false; endif;
			m_iThreshold=p_pxNode^.GetValueI("threshold",0);
			if(m_iThreshold>p_iPlayers)then return false; endif;
			m_bContinue=p_pxNode^.GetValueS("continue","true")=="true";
			m_sBuilding=p_pxNode^.GetValueS("building","");
			m_vDefault.FromString(p_pxNode^.GetValueS("position",""));
			if(m_sBuilding=="" && m_vDefault=={0.0,0.0,0.0} && m_sBuildup!="Invention")then return false; endif;
			m_fTimerAlive=p_pxNode^.GetValueR("timer_alive",45.0);
			m_fTimerDead=p_pxNode^.GetValueR("timer_dead",135.0);
			var ^CGameObj pxObj=CSrvWrap.GetObjMgr()^.GetObjByName(m_sBuilding);
			if(pxObj!=null)then
				if(m_vDefault=={0.0,0.0,0.0})then m_vDefault = pxObj^.GetPos(); endif;
				m_xBldgHndl=pxObj^.GetHandle();
				m_fFrequency=m_fTimerAlive;
			elseif(!m_bContinue)then
				return false;
			else
				m_fFrequency=m_fTimerDead;
			endif;
			m_sClass=p_pxNode^.GetValueS("class","");
			if(m_sClass=="")then return false; endif;
			m_sBuildup=p_pxNode^.GetValueS("buildup","");
			m_sPassengers=p_pxNode^.GetValueS("passengers","");
			m_vTarget.FromString(p_pxNode^.GetValueS("target",""));
			if(m_vTarget=={0.0,0.0,0.0}&&m_sBuildup!="Invention")then return false; endif;
			m_fStartTime=p_pxNode^.GetValueR("start_time",0.0);
			if(m_fStartTime<=0.0)then m_bActivated=true; endif;
			m_fEndTime=p_pxNode^.GetValueR("end_time",0.0);
			if(m_fEndTime>0.0)then
				if(m_iStopper==-1)then
					m_iStopper=CTimeMgr.Get().CreateTimer(CGameTimeSpan.OneSecond() * m_fEndTime, false);
					var ^CTimerObj pxTimer=CTimeMgr.Get().GetTimer(m_iStopper);
					if(pxTimer!=null)then
						pxTimer^.Subscribe(this);
					endif;
				endif;
			endif;
			m_fDelay=p_pxNode^.GetValueR("delay",0.0);
			m_iMinAmount=p_pxNode^.GetValueI("min_amount",1);
			m_iMaxAmount=p_pxNode^.GetValueI("max_amount",1);
			if(m_iMaxAmount<m_iMinAmount)then
				m_iMaxAmount=m_iMinAmount;
			endif;
			m_iRepeat=p_pxNode^.GetValueI("repeat_count",0);
			m_iSpeed=p_pxNode^.GetValueI("pref_speed",2);
			m_iLevel=p_pxNode^.GetValueI("level",1);
			m_fPostTime=p_pxNode^.GetValueR("post_time",0.0);
			m_sPostTask=p_pxNode^.GetValueS("post_task","");
			m_bRandom=m_iMaxAmount>m_iMinAmount;
			m_bCheck=m_iRepeat>0;
			if(m_bRandom)then
				var int i;
				for(i=m_iMinAmount)cond(i<=m_iMaxAmount)iter(i++)do
					m_aiAmount.AddEntry(i);
				endfor;
				m_iRandom=m_aiAmount.NumEntries();
			endif;
			return true;
		endproc;
		
		export proc bool SpawnUnit(int p_iSurvivors)
			if(m_iThreshold>p_iSurvivors)then return false; endif;
			if(m_bDeactivated)then return false; endif;
			if(m_bActivated)then
				if(m_sBuildup=="Invention")then
					var ^CBasePlayer pxB=CBasePlayer.GetPlayer(m_iOwner);
					if(pxB!=null)then
						var ^CTechTreeDef pxTTDef=^(pxB^.GetPlayerTechTreeDef());
						if(pxTTDef!=null && !pxTTDef^.HasFilter(m_sClass))then
							pxTTDef^.EnableFilter(m_sClass);
							var ^CGameObj pxO=m_xBldgHndl.GetObj();
							if(pxO!=null)then
								pxO^.InvokeGenericSCEvent(9,4.0f);
								if(m_sClass.Find("/age_")!=-1)then
									var int iNextAge=m_sClass.Right(1).ToInt();
									var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
									if(pxLevel!=null)then
										var ^CStatisticMgr pxStatisticMgr=^(pxLevel^.GetStatisticMgr());
										pxStatisticMgr^.AddSample(CStatisticSample.Epoch.ToInt(), m_iOwner,iNextAge);
									endif;
								endif;
							endif;
						endif;
					endif;
					return false;
				else
					var ^CRPGSpawner pxSpawner = cast<CRPGSpawner>(CSrvWrap.GetObjMgr()^.CreateObj("crash_spawner", m_iOwner));
					if(pxSpawner==null)then return false; endif;
					var ^CGameObj pxBuilding = m_xBldgHndl.GetObj();
					var vec3 vSpawnPos, vExitPos;
					if(pxBuilding!=null)then
						var CFourCC xLink="Spwn";
						if(!pxBuilding^.GetLinkPosWorld(xLink, vSpawnPos))then
							vSpawnPos = pxBuilding^.GetPos();
						endif;
						xLink="Ex_1";
						if(!pxBuilding^.GetLinkPosWorld(xLink, vExitPos))then
							vExitPos = pxBuilding^.GetPos();
							CSrvWrap.GetObjMgr()^.GetFreePos(vExitPos, pxBuilding, vExitPos);
						endif;
						var ^CFightingObj pxFightingObj=cast<CFightingObj>(pxBuilding);
						if(pxFightingObj!=null)then
							pxFightingObj^.SetRallyPoint(vExitPos,CObjHndl.Invalid());
						endif;
					else
						vSpawnPos=vExitPos=m_vDefault;
					endif;
					pxSpawner^.SetSpawnPos(vSpawnPos);
	//				pxSpawner^.SetExitPos(vExitPos);
	//				pxSpawner^.SetDestinationPos(vExitPos);
					pxSpawner^.SetSourceObj(m_xBldgHndl);
					pxSpawner^.SetSpawnDelay(m_fDelay);
					pxSpawner^.SetOwner(m_iOwner);
					pxSpawner^.SetSpeed(m_iSpeed);
					pxSpawner^.SetTargetPos(m_vTarget);
					var int iAmount;
					if(m_bRandom)then
//						Random.Seed();
						iAmount=m_aiAmount[Random.GetInt()%m_iRandom];
					else
						iAmount=m_iMinAmount;
					endif;
					var int i, iC=iAmount;
					if(m_bCheck)then
						iC=Math.Min(iAmount,m_iRepeat);
						m_iRepeat-=iC;
					endif;
					for(i=0)cond(i<iC)iter(i++)do
						pxSpawner^.AddSpawnTask(m_sClass, m_iLevel, m_sBuildup, m_sPassengers, m_fPostTime, m_sPostTask);
					endfor;
					pxSpawner^.StartProduction();
				endif;
			endif;
			if(m_bCheck)then
				if(m_iRepeat<1)then m_bDeactivated=true; endif;
				return m_iRepeat>0;
			endif;
			return true;
		endproc;
		
		export proc void SetTimer(int p_iTimer)
			m_iTimer=p_iTimer;
		endproc;
		
		export proc void Switch()
			m_fFrequency=m_fTimerDead;
		endproc;
		
		export proc void DeactivateUnit()
			if(m_sBuildup!="Invention")then
				m_bDeactivated=true;
			endif;
		endproc;
		
	endclass;
	
	const int TIMER_CRASH_MERCY=40150;
	const int TIMER_CRASH_VISIBILITY=40142;
	const int TIMER_CRASH_FARWELL=40151;
	const int TIMER_CRASH_HEALING=40134;
	const int TIMER_CRASH_TRADER=40123;
	const int TIMER_CRASH_SET_OFF=40124;
	const int SPAWN_START=40200;
	const int SPAWN_MID=40300;
	const int SPAWN_END=40400;
	const int UNIT_RESPAWN=40135;
	const int TIMER_CRASH_CHECK_BUILDUP=40169;
	
	var CRegionSink m_xSinkC; // center region
	var CRegionSink m_xSinkE; // exit region
	var CRegionSink m_xSinkG; // farewell region
	var CRegionSink m_xSinkF; // fighter region
	var CRegionSink m_xSinkH; // hunter region
	var CRegionSink m_xSinkI; // island region
	var CRegionSink m_xSinkK; // knight region
	var CRegionSink m_xSinkN; // novice region
	var CRegionSink m_xSinkP; // pilot region
	var CRegionSink m_xSinkS; // shooter region
	var CRegionSink m_xSinkZ; // zeppelin region
	var CRegionSink m_xSinkT; // tolerance region
	var array CObjHndl m_axStartlocs;
	var CObjList m_xPeasants;
	var CObjList m_xRPGPassengers;
	var array string m_asRPG;
	var array int m_aiRegionOwner;
	var bool m_bCreatedPeasants;
	var bool m_bAssignedUnits;
	var int m_iHumans;
	var int m_iToolKits;
	var CObjHndl m_xTrader;
	var CObjHndl m_xZeppelin;
	var bool m_bFlyerPickUp;
	var int m_iDifficulty;
	var bool m_bGOMEnable;
	var ^CRegion m_pxHealing;
	var bool m_bHealAura;
	var real m_fHealFrequency;
	var real m_fHealAmount;
	var int m_iAlive;
	var array int m_aiTiers;
	var bool m_bRespawn;
	var real m_fPenalty;
	var real m_fIncrease;
	var bool m_bDemote;
	var bool m_bDevolution;
	var bool m_bStartAgain;
	var bool m_bNoScalps;
	var array int m_aiRSCounter;
	var array CUnitRespawn m_axRespawns;
	var array string m_asItemNames;
	var bool m_bCollectedToolkits;
	var bool m_bMercy;
	var int m_iRPGPlayers;
	var int m_iEnemies;
	
	var array int m_aiMidSpawnTimer;
	var array int m_aiEndSpawnTimer;
	var array CSpawnInfo m_axMidSpawnInfo;
	var array CSpawnInfo m_axEndSpawnInfo;
	var array string m_asMidBuildings;
	var array string m_asEndBuildings;
	var ^CPropDB.CNode m_pxSpawnSource;
	
	export constructor()
		m_iAlive=0;
		m_bGOMEnable=false;
		m_bRespawn=false;
		m_bDemote=false;
		m_bDevolution=false;
		m_bStartAgain=false;
		m_bNoScalps=false;
		m_bHealAura=false;
		m_bCreatedPeasants=false;
		m_bAssignedUnits=false;
		m_bCollectedToolkits=false;
		m_bMercy=false;
		m_iRPGPlayers=1;
		m_iEnemies=0;
		m_bFlyerPickUp=false;
		m_iDifficulty=0;
		m_iHumans=0;
		m_iToolKits=0;
		m_aiRegionOwner=0;
		m_aiTiers=0;
		m_asItemNames=0;
		m_aiRSCounter=0;
		m_asRPG=0;
		m_asRPG.AddEntry("fighter");
		m_asRPG.AddEntry("hunter");
		m_asRPG.AddEntry("knight");
		m_asRPG.AddEntry("novice");
		m_asRPG.AddEntry("pilot");
		m_asRPG.AddEntry("shooter");
		var ^CGameOverMgr pxGOM=^(CGameOverMgr.Get());
		pxGOM^.SetReplace(true);
	endconstructor;
	
	export destructor()
		var ^CGameOverMgr pxGOM=^(CGameOverMgr.Get());
		pxGOM^.SetReplace(false);
		KillMidSpawnInfos();
		KillEndSpawnInfos();
		var int i, iC=6;
		for(i=0)cond(i<iC)iter(i++)do
			var ^CObjTime pxTimerObj=CObjTime.FindTimerObj("ActionTimer",UNIT_RESPAWN+i);
			if(pxTimerObj!=null)then
				pxTimerObj^.Kill();
			endif;
		endfor;
	enddestructor;
	
	export static proc ^CCrashRPGMgr GetCrashRPGMgr()
		if(!ms_xCrashRPGMgr.IsValid())then
			var CObjQuery xQuery;
			xQuery.SetOwner(-1);
			xQuery.SetClass("crash_rpg_mgr");
			var CObjList xList;
			if(xQuery.Execute(xList))then
				var int i, iC=xList.NumEntries();
				for(i=0)cond(i<iC)iter(i++)do
					if(!xList[i].IsValid())then continue; endif;
					ms_xCrashRPGMgr = xList[i];
					break;
				endfor;
			endif;
			if(!ms_xCrashRPGMgr.IsValid())then
				var ^CObjMgrHost pxObjMgr=CSrvWrap.GetObjMgr();
				var ^CCrashRPGMgr pxMgr = cast<CCrashRPGMgr>(pxObjMgr^.CreateObj("crash_rpg_mgr", -1, {0.0, 0.0, 0.0}));
				if(pxMgr!=null)then
					ms_xCrashRPGMgr = pxMgr^.GetHandle();
				else
					ms_xCrashRPGMgr = CObjHndl.Invalid();
					return null;
				endif;
			endif;
		endif;
		return cast<CCrashRPGMgr>(ms_xCrashRPGMgr.GetObj());
	endproc;
	
	export static proc ^CCrashRPGMgr GetCrashRPGMgrNC() // w/o creating if a new there is no instance...
		return cast<CCrashRPGMgr>(ms_xCrashRPGMgr.GetObj());
	endproc;
	
	export static proc void SetCrashRPGMgr(CObjHndl p_xH)
		if(!ms_xCrashRPGMgr.IsValid()&&p_xH.IsValid())then
			ms_xCrashRPGMgr=p_xH;
		endif;
	endproc;

	export proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="RPGM";
		var int iVersion=1;
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,iVersion);
		var ^CArc pxArc=^(pxN^.GetArc());
		var int i, iC=m_axStartlocs.NumEntries();
		(pxArc^) << iC;
		for(i=0)cond(i<iC)iter(i++)do
			m_axStartlocs[i].DoKArc(pxArc^);
		endfor;
		m_xPeasants.DoKArc(pxArc^);
		m_xRPGPassengers.DoKArc(pxArc^);
		iC=m_aiRegionOwner.NumEntries();
		(pxArc^) << iC;
		for(i=0)cond(i<iC)iter(i++)do
			pxArc^<<m_aiRegionOwner[i];
		endfor;
		pxArc^<<m_bCreatedPeasants;
		pxArc^<<m_bGOMEnable;
		pxArc^<<m_bAssignedUnits;
		pxArc^<<m_iHumans;
		pxArc^<<m_iToolKits;
		m_xTrader.DoKArc(pxArc^);
		m_xZeppelin.DoKArc(pxArc^);
		pxArc^<<m_bFlyerPickUp;
		pxArc^<<m_iDifficulty;
		iC=m_aiMidSpawnTimer.NumEntries();
		(pxArc^) << iC;
		for(i=0)cond(i<iC)iter(i++)do
			(pxArc^) << m_aiMidSpawnTimer[i];
			(pxArc^) << m_asMidBuildings[i];
			m_axMidSpawnInfo[i].DoKArc(pxArc^,iVersion);
		endfor;
		iC=m_aiEndSpawnTimer.NumEntries();
		(pxArc^) << iC;
		for(i=0)cond(i<iC)iter(i++)do
			(pxArc^) << m_aiEndSpawnTimer[i];
			(pxArc^) << m_asEndBuildings[i];
			m_axEndSpawnInfo[i].DoKArc(pxArc^,iVersion);
		endfor;
		pxArc^<<m_fHealFrequency;
		pxArc^<<m_fHealAmount;
		pxArc^<<m_bHealAura;
		pxArc^<<m_iAlive;
		iC=m_aiTiers.NumEntries();
		(pxArc^) << iC;
		for(i=0)cond(i<iC)iter(i++)do
			pxArc^<<m_aiTiers[i];
		endfor;
		pxArc^<<m_bRespawn;
		pxArc^<<m_fPenalty;
		pxArc^<<m_fIncrease;
		pxArc^<<m_bDemote;
		pxArc^<<m_bDevolution;
		pxArc^<<m_bStartAgain;
		pxArc^<<m_bNoScalps;
		iC=m_aiRSCounter.NumEntries();
		(pxArc^) << iC;
		for(i=0)cond(i<iC)iter(i++)do
			pxArc^<<m_aiRSCounter[i];
		endfor;
		iC=m_axRespawns.NumEntries();
		(pxArc^) << iC;
		for(i=0)cond(i<iC)iter(i++)do
			m_axRespawns[i].DoKArc(pxArc^,iVersion);
		endfor;
		iC=m_asItemNames.NumEntries();
		(pxArc^) << iC;
		for(i=0)cond(i<iC)iter(i++)do
			pxArc^<<m_asItemNames[i];
		endfor;
		pxArc^<<m_bCollectedToolkits;
		pxArc^<<m_bMercy;
		pxArc^<<m_iRPGPlayers;
		pxArc^<<m_iEnemies;
		pxN^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="RPGM")then
			var int iVersion=p_pxNode^.GetVersion();
			var ^CArc pxArc=^(p_pxNode^.GetArc());
			var int i, iC;
			(pxArc^) << iC;
			m_axStartlocs=iC;
			for(i=0)cond(i<iC)iter(i++)do
				m_axStartlocs[i].DoKArc(pxArc^);
			endfor;
			m_xPeasants.DoKArc(pxArc^);
			m_xRPGPassengers.DoKArc(pxArc^);
			(pxArc^) << iC;
			m_aiRegionOwner=iC;
			for(i=0)cond(i<iC)iter(i++)do
				pxArc^<<m_aiRegionOwner[i];
			endfor;
			pxArc^<<m_bCreatedPeasants;
			pxArc^<<m_bGOMEnable;
			var ^CGameOverMgr pxGOM=^(CGameOverMgr.Get());
			pxGOM^.SetEnabled(m_bGOMEnable);
			pxArc^<<m_bAssignedUnits;
			pxArc^<<m_iHumans;
			pxArc^<<m_iToolKits;
			m_xTrader.DoKArc(pxArc^);
			m_xZeppelin.DoKArc(pxArc^);
			pxArc^<<m_bFlyerPickUp;
			CCrashRPGMgr.ms_bFlyPickup=m_bFlyerPickUp;
			pxArc^<<m_iDifficulty;
			(pxArc^) << iC;
			for(i=0)cond(i<iC)iter(i++)do
				var int iValue;
				(pxArc^) << iValue;
				m_aiMidSpawnTimer.AddEntry(iValue);
				var string sValue;
				(pxArc^) << sValue;
				m_asMidBuildings.AddEntry(sValue);
				var ^CCrashRPGMgr.CSpawnInfo pxInfo=^(m_axMidSpawnInfo.NewEntryRef());
				pxInfo^.DoKArc(pxArc^,iVersion);
			endfor;
			(pxArc^) << iC;
			for(i=0)cond(i<iC)iter(i++)do
				var int iValue;
				(pxArc^) << iValue;
				m_aiEndSpawnTimer.AddEntry(iValue);
				var string sValue;
				(pxArc^) << sValue;
				m_asEndBuildings.AddEntry(sValue);
				var ^CCrashRPGMgr.CSpawnInfo pxInfo=^(m_axEndSpawnInfo.NewEntryRef());
				pxInfo^.DoKArc(pxArc^,iVersion);
			endfor;
			pxArc^<<m_fHealFrequency;
			pxArc^<<m_fHealAmount;
			pxArc^<<m_bHealAura;
			pxArc^<<m_iAlive;
			(pxArc^) << iC;
			m_aiTiers=iC;
			for(i=0)cond(i<iC)iter(i++)do
				pxArc^<<m_aiTiers[i];
			endfor;
			pxArc^<<m_bRespawn;
			pxArc^<<m_fPenalty;
			pxArc^<<m_fIncrease;
			pxArc^<<m_bDemote;
			pxArc^<<m_bDevolution;
			pxArc^<<m_bStartAgain;
			pxArc^<<m_bNoScalps;
			(pxArc^) << iC;
			m_aiRSCounter=iC;
			for(i=0)cond(i<iC)iter(i++)do
				pxArc^<<m_aiRSCounter[i];
			endfor;
			(pxArc^) << iC;
			for(i=0)cond(i<iC)iter(i++)do
				var ^CCrashRPGMgr.CUnitRespawn pxRS=^(m_axRespawns.NewEntryRef());
				pxRS^.DoKArc(pxArc^,iVersion);
				pxRS^.SetProcRef(OnUnitRespawn);
			endfor;
			(pxArc^) << iC;
			m_asItemNames=iC;
			for(i=0)cond(i<iC)iter(i++)do
				pxArc^<<m_asItemNames[i];
			endfor;
//			if(iVersion>=2)then
//			endif;
			pxArc^<<m_bCollectedToolkits;
			pxArc^<<m_bMercy;
			pxArc^<<m_iRPGPlayers;
			pxArc^<<m_iEnemies;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(GetOwner()!=-1)then
			Delete();
			return;
		endif;
		begin Query;
			var bool bDuplication=false;
			var CObjQuery xQuery;
			xQuery.SetOwner(-1);
			xQuery.SetClass("crash_rpg_mgr");
			var CObjList xList;
			if(xQuery.Execute(xList))then
				var int i, iC=xList.NumEntries();
				for(i=0)cond(i<iC)iter(i++)do
					if(!xList[i].IsValid())then continue; endif;
					if(xList[i]==GetHandle())then continue; endif;
					bDuplication=true;
					break;
				endfor;
			endif;
			if(bDuplication)then
				Delete();
				return;
			endif;
		end Query;
		SetCrashRPGMgr(GetHandle());
		if(!p_bLoad)then
			SetType("RPGM");
			var ^CAttribs pxAttr=CheckAttribs();
			begin TimerInit;
			end TimerInit;
			m_aiRegionOwner=6;
			m_aiTiers=6;
			m_aiRSCounter=6;
		endif;
		SetHitable(false);
		SetSelectable(false);
		SetFreeBorderBlocker(false);
		SetPlaceBlocker(false);
		CSrvWrap.GetPathfinder().RemPFBlocker(this);
		SetDynamicBBox(false);
		var ^CAttribs pxAttribs=GetAttribs();
		if(pxAttribs!=null)then
			pxAttribs^.SetValue("started",true);
		endif;
		begin SEASHQ;
			var ^CFightingObj pxHQ;
			var CObjQuery xQuery;
			xQuery.SetOwner(7);
			xQuery.SetClass("seas_headquarters");
			var CObjList xList;
			if(xQuery.Execute(xList))then
				var int i, iC=xList.NumEntries();
				for(i=0)cond(i<iC)iter(i++)do
					if(!xList[i].IsValid())then continue; endif;
					pxHQ=cast<CFightingObj>(xList[i].GetObj());
					if(pxHQ==null)then continue; endif;
					pxHQ^.SetSlaveInvincible(true);
				endfor;
			endif;
		end SEASHQ;
		m_xSinkF.m_xOnObjAdd=OnSetFighter;
		m_xSinkF.m_xOnObjRem=OnSetFighter;
		m_xSinkH.m_xOnObjAdd=OnSetHunter;
		m_xSinkH.m_xOnObjRem=OnSetHunter;
		m_xSinkK.m_xOnObjAdd=OnSetKnight;
		m_xSinkK.m_xOnObjRem=OnSetKnight;
		m_xSinkN.m_xOnObjAdd=OnSetNovice;
		m_xSinkN.m_xOnObjRem=OnSetNovice;
		m_xSinkP.m_xOnObjAdd=OnSetPilot;
		m_xSinkP.m_xOnObjRem=OnSetPilot;
		m_xSinkS.m_xOnObjAdd=OnSetShooter;
		m_xSinkS.m_xOnObjRem=OnSetShooter;
		m_xSinkZ.m_xOnObjAdd=OnCheckToolkit;
//		m_xSinkZ.m_xOnObjRem=OnCheckItem;
		m_xSinkE.m_xOnObjAdd=OnCheckExit;
		m_xSinkG.m_xOnObjAdd=OnCheckFarewell;
		m_xSinkI.m_xOnObjRem=OnCheckBuildings;
		m_xSinkT.m_xOnObjAdd=OnAddEnemies;
		m_xSinkT.m_xOnObjRem=OnRemEnemies;
		var int j, iJ=6;
		for(j=0)cond(j<iJ)iter(j++)do
			var ^CObjTime pxTimerObj=CObjTime.FindTimerObj("ActionTimer",UNIT_RESPAWN+j);
			if(pxTimerObj!=null)then
				pxTimerObj^.m_xOnFire=OnFireRespawnTimer;
			endif;
		endfor;
		if(!ValidateRegions())then return; endif;
//		if(!p_bLoad&&CreateRPGUnits())then
//		if(!p_bLoad&&CollectRPGUnits())then
		if(!p_bLoad)then
			InitializeDifficulty(false);
			CreatePeasants();
		endif;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		InitializeDifficulty(true);
		var int i, iC=m_aiTiers.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			SetScalpCosts(i,m_aiTiers[i]);
		endfor;
	endproc;
	
	proc bool ValidateRegions()
		var ^CRegionMgr pxRegionMgr=^(CSrvWrap.GetRegionMgr());
		if(pxRegionMgr==null)then return false; endif;
		var ^CRegion pxRegion;
		
		//healing
		m_pxHealing=pxRegionMgr^.GetRegion("lake_of_healing");
//		if(m_pxHealing==null)then return false; endif;
		
		//exit
		pxRegion=pxRegionMgr^.GetRegion("exit");
		if(pxRegion==null)then return false; endif;
		m_xSinkE.SetRegion(pxRegion);
		m_xSinkE.Subscribe();
		
		//farewell
		pxRegion=pxRegionMgr^.GetRegion("farewell");
		if(pxRegion==null)then return false; endif;
		m_xSinkG.SetRegion(pxRegion);
		m_xSinkG.Subscribe();
		
		// zeppelin
		pxRegion=pxRegionMgr^.GetRegion("zeppelin");
		if(pxRegion==null)then return false; endif;
		m_xSinkZ.SetRegion(pxRegion);
		m_xSinkZ.Subscribe();
		
		// island
		pxRegion=pxRegionMgr^.GetRegion("island");
		if(pxRegion==null)then return false; endif;
		m_xSinkI.SetRegion(pxRegion);
		m_xSinkI.Subscribe();
		
		// zeppelin
		pxRegion=pxRegionMgr^.GetRegion("tolerance");
		if(pxRegion==null)then return false; endif;
		m_xSinkT.SetRegion(pxRegion);
		m_xSinkT.Subscribe();
		
		//fighter
		pxRegion=pxRegionMgr^.GetRegion("fighter");
		if(pxRegion==null)then return false; endif;
		m_xSinkF.SetRegion(pxRegion);
		m_xSinkF.Subscribe();
		
		//hunter
		pxRegion=pxRegionMgr^.GetRegion("hunter");
		if(pxRegion==null)then return false; endif;
		m_xSinkH.SetRegion(pxRegion);
		m_xSinkH.Subscribe();
		
		//knight
		pxRegion=pxRegionMgr^.GetRegion("knight");
		if(pxRegion==null)then return false; endif;
		m_xSinkK.SetRegion(pxRegion);
		m_xSinkK.Subscribe();
		
		//novice
		pxRegion=pxRegionMgr^.GetRegion("novice");
		if(pxRegion==null)then return false; endif;
		m_xSinkN.SetRegion(pxRegion);
		m_xSinkN.Subscribe();
		
		//pilot
		pxRegion=pxRegionMgr^.GetRegion("pilot");
		if(pxRegion==null)then return false; endif;
		m_xSinkP.SetRegion(pxRegion);
		m_xSinkP.Subscribe();
		
		//shooter
		pxRegion=pxRegionMgr^.GetRegion("shooter");
		if(pxRegion==null)then return false; endif;
		m_xSinkS.SetRegion(pxRegion);
		m_xSinkS.Subscribe();
		
		return true;
	endproc;
	
	proc void CreatePeasants()
		if(m_bCreatedPeasants)then return; endif;
		var ^CLevel pxLvl=CSrvWrap.GetCurLevel();
		if(pxLvl==null)then return; endif;
		Random.Seed();
		
		// Checking and counting human players
		var array int aiHumans;
		var ^CBasePlayer pxPlayer;
		var int i, iC=6;
		for(i=0)cond(i<iC)iter(i++)do
			pxPlayer=cast<CBasePlayer>(pxLvl^.GetPlayer(i));
			if(pxPlayer==null)then continue; endif;
			if(pxPlayer^.IsHuman())then
				aiHumans.AddEntry(i);
			endif;
		endfor;
		m_iHumans=aiHumans.NumEntries();
		if(m_iHumans<1)then
			return;
		endif;
		// Getting infos about start locations
		var array vec3 avPos, avRot;
		var ^CObjMgrHost pxObjMgr=CSrvWrap.GetObjMgr();
		if(pxObjMgr==null)then return; endif;
		GetStartLocData(avPos,avRot);
		if(avPos.NumEntries()<m_iHumans)then return; endif;
		
		// Creating apprentices at random positions
		var vec3 vPos, vRot;
		var int iCnt, iR; // counter and random number
		var ^CFightingObj pxPeasant;
		iCnt=avPos.NumEntries();
		iC=m_iHumans;
		for(i=0)cond(i<iC)iter(i++)do
			iR=Random.GetInt()%iCnt;
			pxPeasant=cast<CFightingObj>(pxObjMgr^.CreateObj("apprentice",aiHumans[i],avPos[iR],avRot[iR]));
			if(pxPeasant==null)then continue; endif;
			CSrvWrap.SendGenericEvtToPlayer(aiHumans[i],"start_pos\t"+pxPeasant^.GetPos().ToString()+"\t785");
			pxPeasant^.SetSlaveInvincible(true);
			m_xPeasants.AddEntry(pxPeasant^.GetHandle());
			iCnt-=1;
			avPos.DeleteEntry(iR);
			avRot.DeleteEntry(iR);
//			Random.Seed();
		endfor;
		m_bCreatedPeasants=true;
	endproc;
	
	proc bool OnSetFighter(CObjHndl p_xHndl)
		var ^CFightingObj pxFO;
		var bool bOkay=false;
		var int iIdx=m_asRPG.FindEntry("fighter");
		if(iIdx<0)then return true; endif;
		var CObjList xObjList=m_xSinkF.GetObjects();
		var int i,iC=xObjList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			pxFO=cast<CFightingObj>(xObjList[i].GetObj());
			if(pxFO==null)then continue; endif;
			if(pxFO^.GetClassName()!="apprentice")then continue; endif;
			m_aiRegionOwner[iIdx]=pxFO^.GetOwner();
			bOkay=true;
			break;
		endfor;
		if(bOkay)then
			AssignUnits();
		else
			m_aiRegionOwner[iIdx]=-1;
		endif;
		return true;
	endproc;
	
	proc bool OnSetHunter(CObjHndl p_xHndl)
		var ^CFightingObj pxFO;
		var bool bOkay=false;
		var int iIdx=m_asRPG.FindEntry("hunter");
		if(iIdx<0)then return true; endif;
		var CObjList xObjList=m_xSinkH.GetObjects();
		var int i,iC=xObjList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			pxFO=cast<CFightingObj>(xObjList[i].GetObj());
			if(pxFO==null)then continue; endif;
			if(pxFO^.GetClassName()!="apprentice")then continue; endif;
			m_aiRegionOwner[iIdx]=pxFO^.GetOwner();
			bOkay=true;
			break;
		endfor;
		if(bOkay)then
			AssignUnits();
		else
			m_aiRegionOwner[iIdx]=-1;
		endif;
		return true;
	endproc;
	
	proc bool OnSetKnight(CObjHndl p_xHndl)
		var ^CFightingObj pxFO;
		var bool bOkay=false;
		var int iIdx=m_asRPG.FindEntry("knight");
		if(iIdx<0)then return true; endif;
		var CObjList xObjList=m_xSinkK.GetObjects();
		var int i,iC=xObjList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			pxFO=cast<CFightingObj>(xObjList[i].GetObj());
			if(pxFO==null)then continue; endif;
			if(pxFO^.GetClassName()!="apprentice")then continue; endif;
			m_aiRegionOwner[iIdx]=pxFO^.GetOwner();
			bOkay=true;
			break;
		endfor;
		if(bOkay)then
			AssignUnits();
		else
			m_aiRegionOwner[iIdx]=-1;
		endif;
		return true;
	endproc;
	
	proc bool OnSetNovice(CObjHndl p_xHndl)
		var ^CFightingObj pxFO;
		var bool bOkay=false;
		var int iIdx=m_asRPG.FindEntry("novice");
		if(iIdx<0)then return true; endif;
		var CObjList xObjList=m_xSinkN.GetObjects();
		var int i,iC=xObjList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			pxFO=cast<CFightingObj>(xObjList[i].GetObj());
			if(pxFO==null)then continue; endif;
			if(pxFO^.GetClassName()!="apprentice")then continue; endif;
			m_aiRegionOwner[iIdx]=pxFO^.GetOwner();
			bOkay=true;
			break;
		endfor;
		if(bOkay)then
			AssignUnits();
		else
			m_aiRegionOwner[iIdx]=-1;
		endif;
		return true;
	endproc;
	
	proc bool OnSetPilot(CObjHndl p_xHndl)
		var ^CFightingObj pxFO;
		var bool bOkay=false;
		var int iIdx=m_asRPG.FindEntry("pilot");
		if(iIdx<0)then return true; endif;
		var CObjList xObjList=m_xSinkP.GetObjects();
		var int i,iC=xObjList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			pxFO=cast<CFightingObj>(xObjList[i].GetObj());
			if(pxFO==null)then continue; endif;
			if(pxFO^.GetClassName()!="apprentice")then continue; endif;
			m_aiRegionOwner[iIdx]=pxFO^.GetOwner();
			bOkay=true;
			break;
		endfor;
		if(bOkay)then
			AssignUnits();
		else
			m_aiRegionOwner[iIdx]=-1;
		endif;
		return true;
	endproc;
	
	proc bool OnSetShooter(CObjHndl p_xHndl)
		var ^CFightingObj pxFO;
		var bool bOkay=false;
		var int iIdx=m_asRPG.FindEntry("shooter");
		if(iIdx<0)then return true; endif;
		var CObjList xObjList=m_xSinkS.GetObjects();
		var int i,iC=xObjList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			pxFO=cast<CFightingObj>(xObjList[i].GetObj());
			if(pxFO==null)then continue; endif;
			if(pxFO^.GetClassName()!="apprentice")then continue; endif;
			m_aiRegionOwner[iIdx]=pxFO^.GetOwner();
			bOkay=true;
			break;
		endfor;
		if(bOkay)then
			AssignUnits();
		else
			m_aiRegionOwner[iIdx]=-1;
		endif;
		return true;
	endproc;
	
	proc bool OnCheckToolkit(CObjHndl p_xHndl)
		var ^CItem pxI;
		var bool bSet=false;
		var CObjList xItems;
		var CObjList xObjList=m_xSinkZ.GetObjects();
		var int i,iC=xObjList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			pxI=cast<CItem>(xObjList[i].GetObj());
			if(pxI==null)then continue; endif;
			if(pxI^.GetClassName()!="item_toolkit")then continue; endif;
			var ^CFightingObj pxOwner=cast<CFightingObj>(pxI^.GetItemOwner().GetObj());
			if(pxOwner!=null)then
				pxOwner^.DropAllItems();
			endif;
			if(m_asItemNames.FindEntry(pxI^.GetName())==-1)then
				m_asItemNames.AddEntry(pxI^.GetName());
				xItems.Include(pxI^.GetHandle());
				bSet=true;
			endif;
		endfor;
		m_iToolKits=m_asItemNames.NumEntries();
		while(xItems.NumEntries()>0)do
			xItems[0].GetObj()^.Delete();
			xItems.DeleteEntry(0);
		endwhile;
		if(bSet)then
			var ^CLevelInfoHost pxLevelInfo=CSrvWrap.GetLevelInfo(false);
			if(pxLevelInfo==null)then return true; endif;
			var string sVar="_toolkits";
			var ^CPropDB.CNode pxNode=pxLevelInfo^.GetGenericData().FindNode("Variables/"+sVar, false);
			if(pxNode!=null)then
				pxNode^.SetValue("value", m_iToolKits);
			endif;
			pxLevelInfo^.NotifyVarsChange();
//			CMirageSrvMgr.Get().CheckAllVariableCondition(sVar);
			CheckToolKits();
		endif;
		return true;
	endproc;
	
	proc void CheckToolKits()
		if(m_iToolKits<4)then return; endif;
		var ^CCrashLaunchPad pxB=cast<CCrashLaunchPad>(CSrvWrap.GetObjMgr()^.GetObjByName("crash_launchpad_0"));
		if(pxB==null)then return; endif;
		if(m_bCollectedToolkits)then return; endif;
		m_bCollectedToolkits=true;
		var Quat qRot=pxB^.GetRot();
		qRot.SetXYZW(0.0f,0.0f,qRot.GetZ(),qRot.GetW());
		pxB^.SetRot(qRot);
		var vec3 vNew={512.48,511.96,17.04};
		pxB^.SetPos(vNew);
		pxB^.BuildUpInGame(10.0f);
//		pxB^.BuildUpInGame(97.0f);
//		pxB^.SetCanBeAttacked(true);
//		pxB^.SetSlaveInvincible(false);
//		vNew={500.58,513.02,17.55};
		vNew={505.76,512.74,17.19};
		qRot.SetXYZW(0.6798, -0.07827, 0.02685, 0.7287);
		var ^CCRpgMerchant pxM=cast<CCRpgMerchant>(CSrvWrap.GetObjMgr()^.CreateObj("merchant",6,vNew));
		if(pxM==null)then return; endif;
		m_xTrader=pxM^.GetHandle();
		pxM^.SetLevelClean(4);
		pxM^.SetRot(qRot);
		pxM^.Build(pxB^.GetHandle(),false);
		CreateTimer(TIMER_CRASH_CHECK_BUILDUP, CGameTimeSpan.OneSecond()*10.0f, true);
		var ^CLevelInfoHost pxLevelInfo=CSrvWrap.GetLevelInfo(false);
		if(pxLevelInfo!=null)then
			var string sVar="_launchpad_ready";
			var ^CPropDB.CNode pxNode=pxLevelInfo^.GetGenericData().FindNode("Variables/"+sVar, false);
			if(pxNode!=null)then
				pxNode^.SetValue("value", 1);
			endif;
			pxLevelInfo^.NotifyVarsChange();
		endif;
		var CGameEvtPtr xEvt=CGameEvtPtr.CreateEvent("DefendBlimp");
		xEvt.SetBool(0,true);
		var int i, iC=m_xRPGPassengers.Validate();
		var ^CGameObj pxRPG;
		for(i=0)cond(i<iC)iter(i++)do
			pxRPG=m_xRPGPassengers[i].GetObj();
			if(pxRPG!=null)then
				pxRPG^.HandleEvent(xEvt);
			endif;
		endfor;
//		KillMidSpawnInfos();
		DeativateMidSpawnUnits();
		InitEndSpawnInfos();
//		m_xSinkZ.Unsubscribe();
//		m_xSinkZ.DeleteRegion();
	endproc;
	
	proc bool OnCheckItem(CObjHndl p_xHndl)
		return true;
	endproc;
	
	proc bool OnCheckExit(CObjHndl p_xHndl)
		var ^CGameObj pxG;
		var bool bFound=false;
		var CObjList xObjList=m_xSinkE.GetObjects();
		var int i,iC=xObjList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			pxG=xObjList[i].GetObj();
			if(pxG==null)then continue; endif;
			if(pxG^.GetClassName()!="crash_blimp")then continue; endif;
			if(pxG^.GetOwner()!=6)then continue; endif;
			bFound=true;
		endfor;
		if(bFound)then
			CreateTimer(TIMER_CRASH_VISIBILITY, CGameTimeSpan.OneSecond()*5.0f, false);
			var ^CLevel pxLvl=CSrvWrap.GetCurLevel();
			if(pxLvl==null)then return false; endif;
			var array int aiHumans;
			var ^CBasePlayer pxPlayer;
			var int i, iC=6;
			for(i=0)cond(i<iC)iter(i++)do
				pxPlayer=cast<CBasePlayer>(pxLvl^.GetPlayer(i));
				if(pxPlayer==null)then continue; endif;
//				if(pxPlayer^.IsHuman())then
					aiHumans.AddEntry(i);
//				endif;
			endfor;
			iC=aiHumans.NumEntries();
			if(iC<1)then
				return false;
			endif;
			m_bGOMEnable=false;
			var ^CGameOverMgr pxGOM=^(CGameOverMgr.Get());
			pxGOM^.SetEnabled(false);
			pxGOM^.SetReplace(false);
			var string sQuit = "GameOver\tMultiplayer\tLose\t_GAOV_CRASH_RPG_WIN";
			for(i=0)cond(i<iC)iter(i++)do
				pxGOM^.SetPlayerWinExt(aiHumans[i], sQuit);
			endfor;
			pxGOM^.SetPlayerWinExt(6, sQuit);
			pxGOM^.SetPlayerLoseExt(7,"");
		endif;
		return true;
	endproc;
	
	proc bool OnCheckFarewell(CObjHndl p_xHndl)
		var ^CGameObj pxG;
		var bool bFound=false;
		var CObjList xObjList=m_xSinkG.GetObjects();
		var int i,iC=xObjList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			pxG=xObjList[i].GetObj();
			if(pxG==null)then continue; endif;
			if(pxG^.GetClassName()!="crash_blimp")then continue; endif;
			if(pxG^.GetOwner()!=6)then continue; endif;
			bFound=true;
		endfor;
		if(bFound)then
			CreateTimer(TIMER_CRASH_FARWELL, CGameTimeSpan.OneSecond()*2.0f, false);
			CFeedback.Print(CFeedback.ALL, CFeedback.INFO, "_MIRAGE_NT_Crash_RPG_Farewell_1");
		endif;
		return true;
	endproc;
	
	proc bool OnAddEnemies(CObjHndl p_xHndl)
		var ^CFightingObj pxO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxO==null)then return false; endif;
		if(pxO^.GetOwner()!=7||pxO^.GetType()=="BLDG")then return false; endif;
		m_xRegionObjects.Include(p_xHndl);
		m_iEnemies=m_xRegionObjects.Validate();
		return true;
	endproc;
	
	proc bool OnRemEnemies(CObjHndl p_xHndl)
		if(m_xRegionObjects.FindEntry(p_xHndl)==-1)then return false; endif;
		m_xRegionObjects.RemEntry(p_xHndl);
		m_iEnemies=m_xRegionObjects.Validate();
		return true;
	endproc;
	
	export proc void HideBlimp()
		var ^CCrashBlimp pxB=cast<CCrashBlimp>(m_xZeppelin.GetObj());
		if(pxB!=null)then
			pxB^.SetVisible(false);
		endif;
	endproc;
	
	proc bool OnCheckBuildings(CObjHndl p_xHndl)
		var ^CBuilding pxB=cast<CBuilding>(p_xHndl.GetObj());
		if(pxB!=null)then
			var string sClass=pxB^.GetClassName();
			if(sClass=="seas_barracks" || sClass=="seas_carrier" || sClass=="seas_garage" || sClass=="seas_laboratory")then
				CheckSpawnInfos(pxB^.GetName());
			endif;
		endif;
		return true;
	endproc;
	
	proc void AssignUnits()
		if(m_bAssignedUnits)then return; endif;
		// check if all the available human players have their own unit
		m_iHumans=m_xPeasants.Validate();
		var int iCnt=0, i, iC=m_aiRegionOwner.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(m_aiRegionOwner[i]>-1)then
				iCnt+=1;
			endif;
		endfor;
		if(iCnt<m_iHumans)then return; endif;
		var ^CLevel pxLvl=CSrvWrap.GetCurLevel();
		if(pxLvl==null)then return; endif;
		var ^CLevelInfoHost pxLevelInfo=CSrvWrap.GetLevelInfo(false);
		if(pxLevelInfo==null)then return; endif;
		
		// Checking and counting ai nakamas
		var array int aiAIs;
		var int iAI;
		var ^CBasePlayer pxPlayer;
		iC=6;
		for(i=0)cond(i<iC)iter(i++)do
			pxPlayer=cast<CBasePlayer>(pxLvl^.GetPlayer(i));
			if(pxPlayer==null)then continue; endif;
			if(!pxPlayer^.IsHuman())then
				aiAIs.AddEntry(i);
			endif;
		endfor;
		iAI=aiAIs.NumEntries();
		var bool bCheckAI=iAI>0;
		
		var array string asFreeUnits;
		// assign reserved units then delete leftover stuff
		var ^CGameOverMgr pxGOM=^(CGameOverMgr.Get());
		var int iAlive=pxGOM^.GetStateCode("alive");
		var ^CObjMgrHost pxObjMgr=CSrvWrap.GetObjMgr();
		if(pxObjMgr==null)then return; endif;
		m_bAssignedUnits=true;
		var ^CGameObj pxP;
		var ^CFightingObj pxU;
		var ^CAttribs pxAttr;
		iC=m_asRPG.NumEntries();
		var int iO;
		var CObjList xFountains=GetFountains();
		for(i=0)cond(i<iC)iter(i++)do
			if(bCheckAI && m_aiRegionOwner[i]==-1)then
				asFreeUnits.AddEntry(m_asRPG[i]);
				continue;
			endif;
//			pxU=cast<CFightingObj>(m_axUnits[i].GetObj());
			pxP=GetPeasant(m_aiRegionOwner[i]);
			if(pxP!=null)then
				pxU=cast<CFightingObj>(pxObjMgr^.CreateObj(m_asRPG[i]+"_lvl1", pxP^.GetOwner(), pxP^.GetPos(), pxP^.GetRotation()));
				if(pxU==null)then continue; endif;
				m_aiTiers[pxU^.GetOwner()]=1;
				m_xRPGPassengers.AddEntry(pxU^.GetHandle());
				pxAttr=pxU^.GetAttribs();
				if(pxAttr!=null)then
					pxAttr^.SetValue("clientpyramid_replacecard", pxP^.GetName());
				endif;
				pxU^.SetCustomLists("fountain",xFountains);
//				pxU^.SetSlaveInvincible(false);
//				pxU^.SetAggressionState(2);
//				pxU^.SetOwner(m_aiRegionOwner[i]);
				pxP^.Delete();
				if(!m_bRespawn)then
					pxGOM^.SetPlayerState(m_aiRegionOwner[i],iAlive);
				endif;
			endif;
		endfor;
		if(bCheckAI)then
			var array vec3 avPos, avRot;
			if(GetStartLocData(avPos,avRot))then
				var int iR, iRnd;
				var int iCnt=avPos.NumEntries();
				for(i=0)cond(i<iAI)iter(i++)do
					iRnd=Random.GetInt()%iCnt;
					iCnt-=1;
					iR=Random.GetInt()%asFreeUnits.NumEntries();
					var string sUnitForAI=asFreeUnits[iR];
					asFreeUnits.DeleteEntry(iR);
					pxU=cast<CFightingObj>(pxObjMgr^.CreateObj(sUnitForAI+"_lvl1", aiAIs[i], avPos[iRnd], avRot[iRnd]));
					if(pxU==null)then continue; endif;
					m_aiTiers[pxU^.GetOwner()]=1;
					m_iHumans+=1;
					m_xRPGPassengers.AddEntry(pxU^.GetHandle());
					pxU^.SetAIBrain(true);
					pxU^.SetCustomLists("fountain",xFountains);
					if(!m_bRespawn)then
						pxGOM^.SetPlayerState(aiAIs[i],iAlive);
					endif;
					avPos.DeleteEntry(iRnd);
					avRot.DeleteEntry(iRnd);
				endfor;
			endif;
		endif;
		iC=m_aiTiers.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			SetScalpCosts(i,m_aiTiers[i]);
		endfor;
		CheckFlyerPickUp();
		if(!m_bRespawn)then
			m_bGOMEnable=true;
			pxGOM^.SetPlayerState(6,iAlive);
			pxGOM^.SetPlayerState(7,iAlive);
			pxGOM^.SetEnabled(true);
		endif;
		// remove rpg unit regions
		m_xSinkF.Unsubscribe();
		m_xSinkF.DeleteRegion();
		m_xSinkH.Unsubscribe();
		m_xSinkH.DeleteRegion();
		m_xSinkK.Unsubscribe();
		m_xSinkK.DeleteRegion();
		m_xSinkN.Unsubscribe();
		m_xSinkN.DeleteRegion();
		m_xSinkP.Unsubscribe();
		m_xSinkP.DeleteRegion();
		m_xSinkS.Unsubscribe();
		m_xSinkS.DeleteRegion();
		var string sVar="_characters_set";
		var ^CPropDB.CNode pxNode=pxLevelInfo^.GetGenericData().FindNode("Variables/"+sVar, false);
		if(pxNode!=null)then
			pxNode^.SetValue("value", 1);
		endif;
		pxLevelInfo^.NotifyVarsChange();
		m_iAlive=m_xRPGPassengers.Validate();
		InitMidSpawnInfos();
		if(m_bHealAura)then
			CreateTimer(TIMER_CRASH_HEALING, CGameTimeSpan.OneSecond()*m_fHealFrequency, true);
		endif;
//		CMirageSrvMgr.Get().CheckAllVariableCondition(sVar);
	endproc;
	
	proc bool GetStartLocData(ref array vec3 p_ravPos, ref array vec3 p_ravRot)
		var ^CObjMgrHost pxObjMgr=CSrvWrap.GetObjMgr();
		if(pxObjMgr==null)then return false; endif;
		var ^CGameObj pxSL;
		var int i, iC=6;
		for(i=0)cond(i<iC)iter(i++)do
			pxSL=pxObjMgr^.GetObjByName("StartLocation_"+i.ToString());
			if(pxSL==null)then continue; endif;
			p_ravPos.AddEntry(pxSL^.GetPos());
			p_ravRot.AddEntry(pxSL^.GetRotation());
		endfor;
		return p_ravRot.NumEntries()==iC;
	endproc;
	
	proc ^CGameObj GetPeasant(int p_iID)
		if(p_iID<0)then return null; endif;
		var int i, iC=m_xPeasants.Validate();
		var ^CGameObj pxP;
		for(i=0)cond(i<iC)iter(i++)do
			pxP=m_xPeasants[i].GetObj();
			if(pxP!=null&&pxP^.GetOwner()==p_iID)then
				return pxP;
			endif;
		endfor;
		return null;
	endproc;
	
	proc ^CGameEvtQueue CheckEvents()
		var ^CGameEvtQueue pxQueue=GetEvents();
		if(pxQueue==null)then
			pxQueue=InitEvents();
		endif;
		return pxQueue;
	endproc;
	
	proc ^CAttribs CheckAttribs()
		var ^CAttribs pxAttribs=GetAttribs();
		if(pxAttribs==null)then
			pxAttribs=InitAttribs();
		endif;
		return pxAttribs;
	endproc;
	
	export proc void SetZeppelin(CObjHndl p_xZ)
		DeleteTimer(TIMER_CRASH_CHECK_BUILDUP);
		m_xZeppelin=p_xZ;
		if(m_xZeppelin.IsValid()&&m_xTrader.IsValid())then
			CreateTimer(TIMER_CRASH_TRADER,CGameTimeSpan.OneSecond()*1.5,false);
		endif;
		var ^CLevelInfoHost pxLevelInfo=CSrvWrap.GetLevelInfo(false);
		if(pxLevelInfo!=null)then
			var string sVar="_zeppelin_ready";
			var ^CPropDB.CNode pxNode=pxLevelInfo^.GetGenericData().FindNode("Variables/"+sVar, false);
			if(pxNode!=null)then
				pxNode^.SetValue("value", 1);
			endif;
			pxLevelInfo^.NotifyVarsChange();
		endif;
	endproc;
	
	export proc void MountBlimp()
		var ^CCrashBlimp pxB=cast<CCrashBlimp>(m_xZeppelin.GetObj());
		var ^CCRpgMerchant pxM=cast<CCRpgMerchant>(m_xTrader.GetObj());
		if(pxB!=null&&pxM!=null)then
			pxM^.BoardTransport(pxB, pxB^.GetPos(), true, "dummy");
		endif;
		CreateTimer(TIMER_CRASH_MERCY,CGameTimeSpan.OneSecond()*300.0,false);
		var ^CFightingObj pxF;
		var int i, iC=m_xRPGPassengers.Validate();
		for(i=0)cond(i<iC)iter(i++)do
			pxF=cast<CFightingObj>(m_xRPGPassengers[i].GetObj());
			if(pxF!=null)then
				pxF^.SetCustomHandles("zeppelin",m_xZeppelin);
			endif;
		endfor;
		KillEndSpawnInfos();
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==TIMER_CRASH_HEALING)then
				HealRPGUnits();
			elseif(iTimerID==TIMER_CRASH_VISIBILITY)then
				HideBlimp();
			elseif(iTimerID==TIMER_CRASH_FARWELL)then
				CFeedback.Print(CFeedback.ALL, CFeedback.INFO, "_MIRAGE_NT_Crash_RPG_Farewell_2");
			elseif(iTimerID==TIMER_CRASH_TRADER)then
				MountBlimp();
			elseif(iTimerID==TIMER_CRASH_MERCY)then
				m_bMercy=true;
			elseif(iTimerID==TIMER_CRASH_SET_OFF)then
				SetOff();
			elseif(iTimerID==TIMER_CRASH_CHECK_BUILDUP)then
				if(m_xZeppelin.IsValid())then return; endif;
				CheckBuildUpProcess();
			elseif(iTimerID>=SPAWN_START&&iTimerID<SPAWN_MID)then
				if(/*m_iAlive<1||*/m_iEnemies>50)then return; endif;
				UseMidSpawnInfo(iTimerID);
			elseif(iTimerID>=SPAWN_MID&&iTimerID<SPAWN_END)then
				if(/*m_iAlive<1||*/m_iEnemies>100)then return; endif;
				UseEndSpawnInfo(iTimerID);
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	export proc void RemoveRPGPassenger(CObjHndl p_xHndl, bool p_bDisconnect, string p_sClass, int p_iLevel, int p_iOwner, bool p_bAI, int p_iKCnt, int p_iKHistory, int p_iAState, CObjList p_xHWells, CObjHndl p_xBlimp)
		if(m_xRPGPassengers.FindEntry(p_xHndl)!=-1)then
			m_xRPGPassengers.RemEntry(p_xHndl);
			CheckFlyerPickUp();
			if(m_bRespawn && !p_bDisconnect && p_iOwner>-1 && p_iOwner<6)then
				var real fDur;
				if(!m_bMercy)then
					fDur=m_fPenalty + (m_fIncrease*m_aiRSCounter[p_iOwner].ToReal());
				else
					fDur=10.0f;
				endif;
				m_aiRSCounter[p_iOwner]+=1;
				var int iTimer=UNIT_RESPAWN+p_iOwner;
				var bool bOK=false;
				var ^CObjTime pxTimerObj=CObjTime.FindTimerObj("ActionTimer",iTimer);
				if(pxTimerObj==null)then
					pxTimerObj=cast<CObjTime>(CSrvWrap.GetObjMgr()^.CreateObj("ObjTime",0));
					if(pxTimerObj!=null)then
						var string sPlayerName;
						var ^CBasePlayer pxB=CBasePlayer.GetPlayer(p_iOwner);
						if(pxB!=null)then
							sPlayerName=pxB^.GetPName();
						else
							var ^CLevelInfo.CPlayerSlot pxPlayerSlot=(CSrvWrap.GetLevelInfo(false))^.GetOwnerPlayerSlot(p_iOwner);
							if(pxPlayerSlot!=null)then
								sPlayerName=pxPlayerSlot^.GetName();
							endif;
						endif;
						pxTimerObj^.SetID(iTimer);
						pxTimerObj^.SetOccupant("ActionTimer");
						pxTimerObj^.SetOwner(p_iOwner);
						pxTimerObj^.SetIcon("default");
						pxTimerObj^.SetTooltip("_MIRAGE_NT_Crash_RPG_Respawn\t"+sPlayerName);
						pxTimerObj^.m_xOnFire=OnFireRespawnTimer;
						bOK=true;
					endif;
				endif;
				if(bOK)then
					if(m_bDemote)then
						p_iLevel=0;
					endif;
					if(m_bNoScalps)then
						var ^CBasePlayer pxB=CBasePlayer.GetPlayer(p_iOwner);
						if(pxB!=null)then
							pxB^.SetRessource("iron", 0);
						endif;
					endif;
					var string sClass=p_sClass.Left(p_sClass.GetLength()-1);
					var int iClass=Math.Clamp((p_sClass.Right(1).ToInt()),1,4);
					if(m_bStartAgain)then
						p_sClass=sClass+"1";
					elseif(m_bDevolution)then
						p_sClass=sClass+Math.Max(iClass-1,1).ToString();
					endif;
					var int iID=m_axRespawns.NumEntries();
					var ^CUnitRespawn pxRS=^(m_axRespawns.NewEntryRef());
					pxRS^.Initialize(p_sClass, p_iLevel, p_iOwner, p_bAI, p_iKCnt, p_iKHistory, p_iAState, p_xHWells, p_xBlimp, iID, fDur, OnUnitRespawn);
					pxRS^.SetTimerID(iTimer);
					var CGameTimeSpan xInterval=CGameTimeSpan.OneSecond()*fDur;
					pxTimerObj^.Start(xInterval,false,true);
				endif;
			endif;
		endif;
		m_iAlive=m_xRPGPassengers.Validate();
		SetBlimpInvincible();
	endproc;
	
	export proc void AddRPGPassenger(CObjHndl p_xHndl)
		if(m_xRPGPassengers.FindEntry(p_xHndl)==-1)then
			m_xRPGPassengers.AddEntry(p_xHndl);
			CheckFlyerPickUp();
		endif;
		m_iAlive=m_xRPGPassengers.Validate();
		SetBlimpInvincible();
	endproc;
	
	export proc void ReplaceRPGPassenger(CObjHndl p_xOld,CObjHndl p_xNew)
		var int iIdx=m_xRPGPassengers.FindEntry(p_xOld);
		if(iIdx!=-1)then
			m_xRPGPassengers[iIdx]=p_xNew;
			CheckFlyerPickUp();
		endif;
		m_iAlive=m_xRPGPassengers.Validate();
		SetBlimpInvincible();
	endproc;
	
	proc void OnFireRespawnTimer(int p_iID)
		var CCrashRPGMgr.CUnitRespawn xS;
		xS.SetTimerID(p_iID);
		var int iIdx=m_axRespawns.FindEntry(xS);
		if(iIdx!=-1)then
			m_axRespawns[iIdx].Execute();
		endif;
	endproc;
	
	export proc void OnUnitRespawn(string p_sClass, int p_iLevel, int p_iOwner, bool p_bAI, int p_iKCnt, int p_iKHistory, int p_iAState, CObjList p_xHWells, CObjHndl p_xBlimp, int p_iID)
		var CCrashRPGMgr.CUnitRespawn xS;
		xS.SetTimerID(UNIT_RESPAWN+p_iOwner);
		var int iIdx=m_axRespawns.FindEntry(xS);
		if(iIdx!=-1)then
			m_axRespawns.DeleteEntry(iIdx);
		endif;
		var ^CObjMgrHost pxObjMgr=CSrvWrap.GetObjMgr();
		if(pxObjMgr==null)then return; endif;
		var array vec3 avPos, avRot;
		if(GetStartLocData(avPos,avRot))then
			var CObjHndl xZeppelin=p_xBlimp;
			if(!xZeppelin.IsValid() && m_xZeppelin.IsValid())then
				xZeppelin=m_xZeppelin;
			endif;
			var int iR, iRnd;
			var int iCnt=avPos.NumEntries();
			iRnd=Random.GetInt()%iCnt;
//			if(m_bMercy)then
//				var ^CCrashBlimp pxB=cast<CCrashBlimp>(m_xZeppelin.GetObj());
//				if(pxB!=null)then
//					var ^CFightingObj pxM = cast<CFightingObj>(pxObjMgr^.CreateObj(p_sClass, p_iOwner, pxB^.GetPos(), avRot[iRnd]));
//					if(pxM!=null)then
//						AddRPGPassenger(pxM^.GetHandle());
//						pxM^.SetLevelClean(p_iLevel);
//						pxM^.SetKillerNumbers(p_iKCnt,p_iKHistory);
//						CSrvWrap.SendGenericEvtToPlayer(p_iOwner,"start_pos\t"+pxM^.GetPos().ToString()+"\t785");
//						pxB^.OnMount(pxM^.GetHandle());
//						return;
//					endif;
//				endif;
//			endif;
			var ^CFightingObj pxU = cast<CFightingObj>(pxObjMgr^.CreateObj(p_sClass, p_iOwner, avPos[iRnd], avRot[iRnd]));
			if(pxU==null)then return; endif;
			if(m_bMercy)then
				pxU^.MakeLUInvulnerable(30.0f);
			endif;
			CSrvWrap.SendGenericEvtToPlayer(p_iOwner,"start_pos\t"+pxU^.GetPos().ToString()+"\t785");
			AddRPGPassenger(pxU^.GetHandle());
			pxU^.SetLevelClean(p_iLevel);
			pxU^.SetAIBrain(p_bAI);
			pxU^.SetAggressionState(p_iAState);
			pxU^.SetKillerNumbers(p_iKCnt,p_iKHistory);
			pxU^.SetCustomLists("fountain",p_xHWells);
			pxU^.SetCustomHandles("zeppelin",xZeppelin);
			var CFourCC xLink="NOPE";
			var CObjHndl xHndl;
//			xHndl=pxU^.AddFX("fx_stina_convert",4.0);
//			if(xHndl.IsValid())then
//				xHndl.GetObj()^.LinkAction(pxU^.GetHandle(),xLink);
//			endif;
			xHndl=pxU^.AddFX("Upgrade_Animal_Fx",4.0);
			if(xHndl.IsValid())then
				xHndl.GetObj()^.LinkAction(pxU^.GetHandle(),xLink);
			endif;
		endif;
	endproc;
	
	export proc void CheckRPGPassengers()
		if(m_axRespawns.NumEntries()>0)then return; endif;
		var ^CLevel pxLvl=CSrvWrap.GetCurLevel();
		if(pxLvl==null)then return; endif;
		var ^CCrashBlimp pxB=cast<CCrashBlimp>(m_xZeppelin.GetObj());
		if(pxB==null)then return; endif;
		var CObjList xBlimpPass=pxB^.GetPassengers();
		var int i, iC=m_xRPGPassengers.Validate();
		for(i=0)cond(i<iC)iter(i++)do
			if(xBlimpPass.FindEntry(m_xRPGPassengers[i])==-1)then
				return;
			endif;
		endfor;
//		KillEndSpawnInfos();
		var array int aiHumans;
		var ^CBasePlayer pxPlayer;
		iC=6;
		for(i=0)cond(i<iC)iter(i++)do
			pxPlayer=cast<CBasePlayer>(pxLvl^.GetPlayer(i));
			if(pxPlayer==null)then continue; endif;
			if(pxPlayer^.IsHuman())then
				aiHumans.AddEntry(i);
			endif;
		endfor;
		iC=aiHumans.NumEntries();
		if(iC>0)then
			var string sEvent="LinkCameraTo\t"+(m_xZeppelin.AsInt()).ToString();
			for(i=0)cond(i<iC)iter(i++)do
				CSrvWrap.SendGenericEvtToPlayer(aiHumans[i], sEvent);
			endfor;
		endif;
		pxB^.StopEverything();
		pxB^.TerminateAction();
		var vec3 vP=pxB^.GetPos();
		var real fHeight=CSrvWrap.GetScapeMgr().GetHeight(vP.GetX(),vP.GetY())+25.0f;
		vP.SetZ(fHeight);
		pxB^.MoveAction(vP, 6.0f);
		CreateTimer(TIMER_CRASH_SET_OFF,CGameTimeSpan.OneSecond()*4.0,false);
		var ^CLevelInfoHost pxLevelInfo=CSrvWrap.GetLevelInfo(false);
		if(pxLevelInfo!=null)then
			var string sVar="_blimp_set_off";
			var ^CPropDB.CNode pxNode=pxLevelInfo^.GetGenericData().FindNode("Variables/"+sVar, false);
			if(pxNode!=null)then
				pxNode^.SetValue("value", 1);
			endif;
			sVar="_spawning_allowed";
			pxNode=pxLevelInfo^.GetGenericData().FindNode("Variables/"+sVar, false);
			if(pxNode!=null)then
				pxNode^.SetValue("value", 0);
			endif;
			pxLevelInfo^.NotifyVarsChange();
		endif;
	endproc;
	
	export proc void SetOff()
		var ^CCrashBlimp pxB=cast<CCrashBlimp>(m_xZeppelin.GetObj());
		if(pxB==null)then return; endif;
		var vec3 vPos={671.25,871.71,0.0};
		var ^CRegionMgr pxRegionMgr=^(CSrvWrap.GetRegionMgr());
		if(pxRegionMgr!=null)then
			var ^CRegion pxRegion=m_xSinkE.GetRegion();
			if(pxRegion!=null)then
				vPos=pxRegion^.GetRandomPointInside();
			endif;
		endif;
		pxB^.GoTo(vPos, true, pxB^.GetMaxSpeed(), false, false);
//		pxB^.WalkAction(vPos);
	endproc;
	
	export proc void Defeat()
		var ^CLevel pxLvl=CSrvWrap.GetCurLevel();
		if(pxLvl==null)then return; endif;
		var ^CGameOverMgr pxGOM=^(CGameOverMgr.Get());
		if(!pxGOM^.GetEnabled()&&m_bAssignedUnits)then return; endif;
		pxGOM^.SetReplace(false);
		m_bGOMEnable=false;
		pxGOM^.SetEnabled(false);
		var array int aiHumans;
		var ^CBasePlayer pxPlayer;
		var int i, iC=6;
		for(i=0)cond(i<iC)iter(i++)do
			var ^CObjTime pxTimerObj=CObjTime.FindTimerObj("ActionTimer",UNIT_RESPAWN+i);
			if(pxTimerObj!=null)then
				pxTimerObj^.Kill();
			endif;
			pxPlayer=cast<CBasePlayer>(pxLvl^.GetPlayer(i));
			if(pxPlayer==null)then continue; endif;
//			if(pxPlayer^.IsHuman())then
				aiHumans.AddEntry(i);
//			endif;
		endfor;
		iC=aiHumans.NumEntries();
		if(iC<1)then
			return;
		endif;
		var string sQuit = "GameOver\tMultiplayer\tLose\t_GAOV_CRASH_RPG_LOSE";
		for(i=0)cond(i<iC)iter(i++)do
			pxGOM^.SetPlayerLoseExt(aiHumans[i], sQuit);
		endfor;
		pxGOM^.SetPlayerLoseExt(6, sQuit);
		pxGOM^.SetPlayerWinExt(7,"");
	endproc;
	
	export proc void KillRespawnTimer(int p_iOwner)
		if(true)then return; endif;
		var ^CObjTime pxTimerObj=CObjTime.FindTimerObj("ActionTimer",UNIT_RESPAWN+p_iOwner);
		if(pxTimerObj!=null)then
			pxTimerObj^.Kill();
			var CCrashRPGMgr.CUnitRespawn xS;
			xS.SetTimerID(UNIT_RESPAWN+p_iOwner);
			var int iIdx=m_axRespawns.FindEntry(xS);
			if(iIdx!=-1)then
				m_axRespawns.DeleteEntry(iIdx);
			endif;
		endif;
		CheckRPGPassengers();
	endproc;
	
	export proc bool CanFlyerPickUp()
		return m_bFlyerPickUp;
	endproc;
	
	proc void CheckFlyerPickUp()
		m_bFlyerPickUp=true;
		var int i, iC=m_xRPGPassengers.Validate();
		var ^CFightingObj pxO;
		for(i=0)cond(i<iC)iter(i++)do
			pxO=cast<CFightingObj>(m_xRPGPassengers[i].GetObj());
			if(pxO==null)then continue; endif;
			if(pxO^.CanWalk()&&!pxO^.GetAIBrain())then
				m_bFlyerPickUp=false;
				break;
			endif;
		endfor;
		CCrashRPGMgr.ms_bFlyPickup=m_bFlyerPickUp;
	endproc;
	
	proc CObjList GetFountains()
		var CObjList xF;
		var ^CPropDB pxSource=new CPropDB;
		var ^CPropDB.CNode pxRoot;
		if(pxSource^.Load(CSrvWrap.GetUrsRelPath() + "/Data/Base/Scripts/Server/settings/custom_maps/crash_rpg_spawning.txt"))then
			pxRoot=^((pxSource^).GetRoot());
		endif;
		if(pxRoot!=null)then
			var ^CPropDB.CNode pxFountains=pxRoot^.FindNode("fountains", false);
			if(pxFountains!=null)then
				var int i, iC=pxFountains^.NumSubs();
				for(i=0)cond(i<iC)iter(i++)do
					var ^CPropDB.CNode pxNode=^(pxFountains^.Get(i));
					if(pxNode==null)then continue; endif;
					var string sName=pxNode^.Value();
					if(sName=="")then continue; endif;
					var ^CGameObj pxObj=CSrvWrap.GetObjMgr()^.GetObjByName(sName);
					if(pxObj!=null)then
						xF.Include(pxObj^.GetHandle());
					endif;
				endfor;
			endif;
		endif;
		return xF;
	endproc;
	
	proc void InitializeDifficulty(bool p_bSkip)
		if(!p_bSkip)then
			m_iDifficulty=1;
//			var ^CBasePlayer pxB=CBasePlayer.GetPlayer(7);
//			if(pxB!=null)then
//				var ^CAiPlayer pxA=cast<CAiPlayer>(pxB);
//				if(pxA!=null)then
//					m_iDifficulty=pxA^.GetAIDifficulty();
//				else // human took ai's place...
//					m_iDifficulty=5;
//				endif;
//			endif;
			var ^CLevelInfoHost pxLI=CSrvWrap.GetLevelInfo(false);
			if(pxLI!=null)then
				var ^CLevelInfo.CPlayerSlot pxPS = pxLI^.GetOwnerPlayerSlot(0);
				if(pxPS!=null)then
					m_iDifficulty=pxPS^.GetValueInt("Difficulty");
//					m_iDifficulty=pxPS^.GetValueInt("game_difficulty");
				endif;
			endif;
			var ^CLevel pxLvl=CSrvWrap.GetCurLevel();
			if(pxLvl!=null)then
				var int i, iC=6, iP=0;
				var ^CBasePlayer pxPlayer;
				for(i=0)cond(i<iC)iter(i++)do
					pxPlayer=cast<CBasePlayer>(pxLvl^.GetPlayer(i));
					if(pxPlayer==null)then continue; endif;
					iP+=1;
				endfor;
				m_iRPGPlayers=iP;
			endif;
		endif;
		var ^CPropDB pxSource=new CPropDB;
		var ^CPropDB.CNode pxRoot;
		if(pxSource^.Load(CSrvWrap.GetUrsRelPath() + "/Data/Base/Scripts/Server/settings/custom_maps/crash_rpg_spawning.txt"))then
			pxRoot=^((pxSource^).GetRoot());
		endif;
		if(pxRoot!=null)then
			m_pxSpawnSource = pxRoot^.FindNode("pl_"+m_iRPGPlayers.ToString()+"/difficulty_"+m_iDifficulty.ToString(), false);
		else
			m_pxSpawnSource=null;
		endif;
		if(!p_bSkip)then
			if(m_pxSpawnSource!=null)then
				var ^CPropDB.CNode pxRespawn=m_pxSpawnSource^.FindNode("respawn", false);
				if(pxRespawn!=null)then
					m_bRespawn=pxRespawn^.GetValueS("enabled","false")=="true";
					m_fPenalty=pxRespawn^.GetValueR("penalty",1.0);
					m_fIncrease=pxRespawn^.GetValueR("increase",1.0);
					m_bDemote=pxRespawn^.GetValueS("demote","false")=="true";
					m_bDevolution=pxRespawn^.GetValueS("devolution","false")=="true";
					m_bStartAgain=pxRespawn^.GetValueS("startagain","false")=="true";
					m_bNoScalps=pxRespawn^.GetValueS("noscalps","false")=="true";
					if(m_fPenalty<=0.0f)then m_fPenalty=1.0f; endif;
					if(m_fIncrease<0.0f)then m_fIncrease=0.0f; endif;
				endif;
				var ^CPropDB.CNode pxPickup=m_pxSpawnSource^.FindNode("pickup", false);
				if(pxPickup!=null)then
					if(pxPickup^.GetValueS("enabled","false")=="true")then
						var ^CLevelInfoHost pxLevelInfo=CSrvWrap.GetLevelInfo(false);
						if(pxLevelInfo!=null)then
							var string sVar="pickup";
							var ^CPropDB.CNode pxNode=pxLevelInfo^.GetGenericData().FindNode("Variables/"+sVar, false);
							if(pxNode!=null)then
								pxNode^.SetValue("value", 1);
							endif;
							pxLevelInfo^.NotifyVarsChange();
						endif;
					endif;
				endif;
				var ^CPropDB.CNode pxHeal=m_pxSpawnSource^.FindNode("heal_aura", false);
				if(pxHeal!=null)then
					m_fHealFrequency=pxHeal^.GetValueR("heal_frequency",1.0);
					m_fHealAmount=pxHeal^.GetValueR("heal_amount",1.0);
					m_bHealAura=pxHeal^.GetValueS("heal_enable","false")=="true";
					if(m_fHealFrequency<=0.0f)then m_fHealFrequency=1.0f; endif;
					if(m_fHealAmount<=0.0f)then m_fHealAmount=1.0f; endif;
				endif;
			endif;
		endif;
	endproc;
	
	export proc bool GOMEnabled()
		return m_bGOMEnable;
	endproc;
	
	export proc void SetScalpCosts(int p_iID, int p_iTier)
		if(p_iID<0||p_iID>m_aiTiers.NumEntries())then return; endif;
		m_aiTiers[p_iID]=p_iTier;
		var ^CBasePlayer pxPlayer = CBasePlayer.GetPlayer(p_iID);
		if(m_pxSpawnSource!=null&&pxPlayer!=null)then
			var ^CPropDB.CNode pxLevelUp=m_pxSpawnSource^.FindNode("levelup", false);
			if(pxLevelUp==null)then return; endif;
			var ^CPropDB.CNode pxTier=pxLevelUp^.FindNode("tier_"+p_iTier.ToString(), false);
			if(pxTier!=null)then
				var string sData;
				var array int aiSkulls;
				aiSkulls.AddEntry(0);
				aiSkulls.AddEntry(25);
				aiSkulls.AddEntry(50);
				aiSkulls.AddEntry(100);
				aiSkulls.AddEntry(300);
				var int i, iC=aiSkulls.NumEntries();
				for(i=0)cond(i<iC)iter(i++)do
					aiSkulls[i] = pxTier^.GetValueI("scalps_"+i.ToString(),aiSkulls[i]);
					pxPlayer^.SetAttribs("foodcost_lvl_"+i.ToString(), aiSkulls[i]);
					if(i>0)then
						sData+=aiSkulls[i].ToString()+"->";
					endif;
				endfor;
				sData.TrimRight("->");
				CFeedback.Print(p_iID, CFeedback.GAMEPLAY,"_MIRAGE_NT_CrashScalpCosts\t"+sData+"\t");
				CSrvWrap.SendGenericEvtToPlayer(p_iID, "ScalpsCostsUpdate\t");
			endif;
		endif;
	endproc;
	
	proc void InitMidSpawnInfos()
		if(m_pxSpawnSource==null)then return; endif;
		var ^CPropDB.CNode pxMid=m_pxSpawnSource^.Get("mid_game");
		if(pxMid==null)then return; endif;
		var int i, iC=Math.Min(pxMid^.NumSubs(),SPAWN_MID-SPAWN_START);
		var int iTimerID;
		for(i=0)cond(i<iC)iter(i++)do
			var ^CPropDB.CNode pxNode=^(pxMid^.Get(i));
			var ^CCrashRPGMgr.CSpawnInfo pxInfo=^(m_axMidSpawnInfo.NewEntryRef());
			var int iIndex=m_aiMidSpawnTimer.NumEntries(); // be carefull!
			if(pxInfo^.Init(m_iHumans,pxNode))then
				iTimerID=SPAWN_START+iIndex;
				if(m_aiMidSpawnTimer.FindEntry(iTimerID)!=-1)then
					m_axMidSpawnInfo.DeleteEntry(iIndex);
					continue;
				endif;
				m_aiMidSpawnTimer.AddEntry(iTimerID);
				if(!m_axMidSpawnInfo[iIndex].m_bActivated)then
					CreateTimer(iTimerID, CGameTimeSpan.OneSecond()*m_axMidSpawnInfo[iIndex].m_fStartTime,false);
				else
					CreateTimer(iTimerID, CGameTimeSpan.OneSecond()*m_axMidSpawnInfo[iIndex].m_fFrequency,true);
					m_axMidSpawnInfo[iIndex].SpawnUnit(m_iAlive);
				endif;
				m_asMidBuildings.AddEntry(m_axMidSpawnInfo[iIndex].m_sBuilding);
				m_axMidSpawnInfo[iIndex].SetTimer(iTimerID);
			else
				m_axMidSpawnInfo.DeleteEntry(iIndex);
			endif;
		endfor;
	endproc;
	
	proc bool UseMidSpawnInfo(ref int p_riTimerID)
		if(m_aiMidSpawnTimer.NumEntries()==0)then
			return false;
		endif;
		var bool bStop;
		var int iTimer=m_aiMidSpawnTimer.FindEntry(p_riTimerID);
		if(iTimer==-1)then
			return false;
		elseif(m_aiMidSpawnTimer.NumEntries()!=m_axMidSpawnInfo.NumEntries())then
			return false;
		else
			if(!m_axMidSpawnInfo[iTimer].m_bActivated)then
				m_axMidSpawnInfo[iTimer].m_bActivated=true;
				m_axMidSpawnInfo[iTimer].SpawnUnit(m_iAlive);
				CreateTimer(m_aiMidSpawnTimer[iTimer], CGameTimeSpan.OneSecond()*m_axMidSpawnInfo[iTimer].m_fFrequency,true);
			elseif(!m_axMidSpawnInfo[iTimer].SpawnUnit(m_iAlive))then
				m_aiMidSpawnTimer.DeleteEntry(iTimer);
				m_axMidSpawnInfo.DeleteEntry(iTimer);
				m_asMidBuildings.DeleteEntry(iTimer);
			else
			endif;
		endif;
		return true;
	endproc;
	
	proc void KillMidSpawnInfos()
		while(m_aiMidSpawnTimer.NumEntries()>0)do
			m_aiMidSpawnTimer.DeleteEntry(0);
			m_axMidSpawnInfo.DeleteEntry(0);
			m_asMidBuildings.DeleteEntry(0);
		endwhile;
	endproc;
	
	proc void DeativateMidSpawnUnits()
		var int i, iC=m_axMidSpawnInfo.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			m_axMidSpawnInfo[i].DeactivateUnit();
		endfor;
	endproc;
	
	proc void InitEndSpawnInfos()
		if(m_pxSpawnSource==null)then return; endif;
		var ^CPropDB.CNode pxEnd=m_pxSpawnSource^.Get("end_game");
		if(pxEnd==null)then return; endif;
		var int i, iC=Math.Min(pxEnd^.NumSubs(),SPAWN_END-SPAWN_MID);
		var int iTimerID;
		for(i=0)cond(i<iC)iter(i++)do
			var ^CPropDB.CNode pxNode=^(pxEnd^.Get(i));
			var ^CCrashRPGMgr.CSpawnInfo pxInfo=^(m_axEndSpawnInfo.NewEntryRef());
			var int iIndex=m_aiEndSpawnTimer.NumEntries(); // be carefull!
			if(pxInfo^.Init(m_iHumans,pxNode))then
				iTimerID=SPAWN_MID+iIndex;
				if(m_aiEndSpawnTimer.FindEntry(iTimerID)!=-1)then
					m_axEndSpawnInfo.DeleteEntry(iIndex);
					continue;
				endif;
				if(!m_axEndSpawnInfo[iIndex].m_bActivated)then
					CreateTimer(iTimerID, CGameTimeSpan.OneSecond()*m_axEndSpawnInfo[iIndex].m_fStartTime,false);
				else
					CreateTimer(iTimerID, CGameTimeSpan.OneSecond()*m_axEndSpawnInfo[iIndex].m_fFrequency,true);
					m_axEndSpawnInfo[iIndex].SpawnUnit(m_iAlive);
				endif;
				m_aiEndSpawnTimer.AddEntry(iTimerID);
				m_asEndBuildings.AddEntry(m_axEndSpawnInfo[iIndex].m_sBuilding);
				m_axEndSpawnInfo[iIndex].SetTimer(iTimerID);
			else
				m_axEndSpawnInfo.DeleteEntry(iIndex);
			endif;
		endfor;
	endproc;
	
	proc bool UseEndSpawnInfo(ref int p_riTimerID)
		if(m_aiEndSpawnTimer.NumEntries()==0)then
			return false;
		endif;
		var bool bStop;
		var int iTimer=m_aiEndSpawnTimer.FindEntry(p_riTimerID);
		if(iTimer==-1)then
			return false;
		elseif(m_aiEndSpawnTimer.NumEntries()!=m_axEndSpawnInfo.NumEntries())then
			return false;
		else
			if(!m_axEndSpawnInfo[iTimer].m_bActivated)then
				m_axEndSpawnInfo[iTimer].m_bActivated=true;
				m_axEndSpawnInfo[iTimer].SpawnUnit(m_iAlive);
				CreateTimer(m_aiEndSpawnTimer[iTimer], CGameTimeSpan.OneSecond()*m_axEndSpawnInfo[iTimer].m_fFrequency,true);
			elseif(!m_axEndSpawnInfo[iTimer].SpawnUnit(m_iAlive))then
				m_aiEndSpawnTimer.DeleteEntry(iTimer);
				m_asEndBuildings.DeleteEntry(iTimer);
				m_axEndSpawnInfo.DeleteEntry(iTimer);
			endif;
		endif;
		return true;
	endproc;
	
	proc void KillEndSpawnInfos()
		while(m_aiEndSpawnTimer.NumEntries()>0)do
			m_aiEndSpawnTimer.DeleteEntry(0);
			m_axEndSpawnInfo.DeleteEntry(0);
			m_asEndBuildings.DeleteEntry(0);
		endwhile;
	endproc;
	
	export proc void CheckSpawnInfos(string p_sName)
		var int i, iC=m_asMidBuildings.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(m_asMidBuildings[i]!=p_sName)then continue; endif;
			if(m_axMidSpawnInfo[i].m_bContinue)then
				m_axMidSpawnInfo[i].Switch();
				DeleteTimer(m_aiMidSpawnTimer[i]);
				CreateTimer(m_aiMidSpawnTimer[i], CGameTimeSpan.OneSecond()*m_axMidSpawnInfo[i].m_fFrequency,true);
			else
				m_aiMidSpawnTimer.DeleteEntry(i);
				m_axMidSpawnInfo.DeleteEntry(i);
				m_asMidBuildings.DeleteEntry(i);
				i--; iC--;
			endif;
		endfor;
		iC=m_asEndBuildings.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(m_asEndBuildings[i]!=p_sName)then continue; endif;
			if(m_axEndSpawnInfo[i].m_bContinue)then
				m_axEndSpawnInfo[i].Switch();
				DeleteTimer(m_aiEndSpawnTimer[i]);
				CreateTimer(m_aiEndSpawnTimer[i], CGameTimeSpan.OneSecond()*m_axEndSpawnInfo[i].m_fFrequency,true);
			else
				m_aiEndSpawnTimer.DeleteEntry(i);
				m_axEndSpawnInfo.DeleteEntry(i);
				m_asEndBuildings.DeleteEntry(i);
				i--; iC--;
			endif;
		endfor;
		return;
	endproc;
	
	export proc CObjList GetRPGUnits()
		return m_xRPGPassengers;
	endproc;
	
	proc void HealRPGUnits()
		if(m_pxHealing==null)then return; endif;
		var int i, iC=m_xRPGPassengers.Validate();
		var ^CFightingObj pxO;
		for(i=0)cond(i<iC)iter(i++)do
			pxO=cast<CFightingObj>(m_xRPGPassengers[i].GetObj());
			if(pxO==null||!m_pxHealing^.IsInside(pxO^.GetPos()))then continue; endif;
			pxO^.HealMe(m_fHealAmount);
		endfor;
	endproc;
	
	proc void SetBlimpInvincible()
//		if(m_iToolKits<4)then return; endif;
		var ^CCrashLaunchPad pxB=cast<CCrashLaunchPad>(CSrvWrap.GetObjMgr()^.GetObjByName("crash_launchpad_0"));
		if(pxB==null)then return; endif;
		pxB^.SetSlaveInvincible(m_iAlive>0);
	endproc;
	
	export proc bool DefendCenter()
		return m_bCollectedToolkits;
	endproc;
	
	proc void CheckBuildUpProcess()
		var ^CCRpgMerchant pxM=cast<CCRpgMerchant>(m_xTrader.GetObj());
		if(pxM==null)then return; endif;
		var string sCurTask;
		if(pxM^.GetTaskMgr()!=null)then
			sCurTask=pxM^.GetCurTaskName();
		endif;
		if(sCurTask!="BuildUp")then
			var ^CCrashLaunchPad pxB=cast<CCrashLaunchPad>(CSrvWrap.GetObjMgr()^.GetObjByName("crash_launchpad_0"));
			if(pxB==null)then return; endif;
			pxM^.Build(pxB^.GetHandle(),false);
		endif;
	endproc;
	
endclass;
	
class CCrashBlimp inherit CVehicle
	
	const real FLYING_HEIGHT=20.0f;
	
	var bool m_bDefeatCause;
	
	export constructor()
		m_bDefeatCause=true;
	endconstructor;
	
	destructor()
		if(m_bDefeatCause)then
			if(CCrashRPGMgr.GetCrashRPGMgr()!=null)then
				CCrashRPGMgr.GetCrashRPGMgr()^.Defeat();
			endif;
		endif;
	enddestructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="CrBl"; //CrashBlimp
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		(pxArc^) << m_bDefeatCause;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="CrBl")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			(pxArc^) << m_bDefeatCause;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetCanSwim(false);
		SetCanWalk(false);
		SetCanFly(true);
		if(!p_bLoad)then
			SetTransportClass(2);
			SetBuildUp(CBuildUpBase.TYPE_TRANSPORTER);
		endif;
		m_iSizeClass=10;
		SetSlaveInvincible(true);
	endproc;
	
	export proc void SetIced(real p_fDuration,real p_fResistStart)
		return;
	endproc;
	
	export proc bool IsTrapped()
		return false;
	endproc;
	
	export proc bool IsAbleToFight()
		return false;
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj , ref CGameObj.CAdvanceActionParams p_rxParams)
		if(!p_xGoalObj.IsValid())then return; endif;
		var vec3 vObj=p_xGoalObj.GetObj()^.GetPos(), vOwn=GetPos(),vNew;
		var real fScape=Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vOwn.GetX(),vOwn.GetY()),m_fWaterLevel);
		var real fHeight=vOwn.GetZ()-fScape;
		var real fRange=GetAttackRange()+GetRadius();
		vOwn.SetZ(fScape);
		var vec3 vDirection=vOwn - vObj;
		vDirection.Normalize();
		vNew=GetPosInMap(vObj+(vDirection*fRange));
		WalkAction(vNew, GetMaxSpeed(), false);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption, ^CGameObj p_pxGoalObj, CFourCC p_xWalkSet, bool p_bUseMaterial)
		var vec3 vPosition=GetPosInMap(p_vDest);
		vPosition.SetZ(Math.Max(CSrvWrap.GetScapeMgr().GetHeight(p_vDest.GetX(),p_vDest.GetY()),m_fWaterLevel)+FLYING_HEIGHT);
		return super.WalkAction(vPosition, p_iPrefSpeed, false, false, p_pxGoalObj, p_xWalkSet, p_bUseMaterial);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption, ^CGameObj p_pxGoalObj, CFourCC p_xWalkSet)
		return WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, p_bHeightAdaption, p_pxGoalObj, p_xWalkSet, true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption, ^CGameObj p_pxGoalObj)
		return WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, p_bHeightAdaption, p_pxGoalObj, GetWalkSet(), true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption)
		return WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, p_bHeightAdaption, null, GetWalkSet(), true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder)
		return WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, true, null, GetWalkSet(), true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed)
		return WalkAction(p_vDest, p_iPrefSpeed, true, true, null, GetWalkSet(), true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest)
		return WalkAction(p_vDest, GetMaxSpeed(), true, true, null, GetWalkSet(), true);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed, CFourCC p_xWalkSet, real p_fMaxRange, ref vec3 p_rvRootPos, ref vec3 p_rvGoalOffset)
		if(!p_xGoalObj.IsValid())then return; endif;
		var vec3 vObj=p_xGoalObj.GetObj()^.GetPos(), vOwn=GetPos(),vNew;
		var real fScape=Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vOwn.GetX(),vOwn.GetY()),m_fWaterLevel);
		var real fHeight=vOwn.GetZ()-fScape, fRange=GetAttackRange();
		vOwn.SetZ(fScape);
		var vec3 vDirection=vOwn - vObj;
		vDirection.Normalize();
		vNew=GetPosInMap(vObj+(vDirection*fRange));
		WalkAction(vNew, GetMaxSpeed(), false);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed, CFourCC p_xWalkSet, real p_fMaxRange, ref vec3 p_rvRootPos)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed, p_xWalkSet, p_fMaxRange, p_rvRootPos);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed, CFourCC p_xWalkSet, real p_fMaxRange)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed, p_xWalkSet, p_fMaxRange);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed, CFourCC p_xWalkSet)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed, p_xWalkSet);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj)
		return super.AdvanceAction(p_xGoalObj);
	endproc;
	
	export proc void Die()
		AllGotDrowned();
		super.Die();
	endproc;
	
	export proc void Delete()
		var ^CZeppelinCorpse pxGameObj=cast<CZeppelinCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("zeppelin_corpse",GetOwner(),GetPos(),GetRotation()));
		if(pxGameObj!=null)then
			pxGameObj^.SetSource(this);
			pxGameObj^.Init(GetName(), 0.0001);
		endif;
		super.Delete();
	endproc;
	
	export static proc void Evacuate()
		return;
	endproc;
	
	export proc bool OnMount(CObjHndl p_xPassenger)
		if(m_bReleaseWhileDying)then return false; endif;
		if(!p_xPassenger.IsValid())then return false; endif;
		if(m_xPassengers.FindEntry(p_xPassenger)!=-1)then return false; endif;
		var ^CFightingObj pxPassenger=cast<CFightingObj>(p_xPassenger.GetObj());
		if(pxPassenger==null)then return false; endif;
		pxPassenger^.SetSlaveInvincible(true);
		var ^CTransportObj pxTransporter=cast<CTransportObj>(pxPassenger);
		if(HasBuildUp(CBuildUpBase.TYPE_TRANSPORTER))then
			cast<CBuildUpTransporter>(GetBuildUp())^.AddPassenger(p_xPassenger);
		endif;
		UnregisterPassenger(p_xPassenger);
		m_xPassengers.Include(p_xPassenger);
		pxPassenger^.GetWeaponMgr()^.SetAutoWeaponChange(true);
		if(pxTransporter!=null)then
			m_iBlockedSlots += pxTransporter^.NumPassengers();
		endif;
		CUniversalTriggerMgr.Get().OnTransportMount(GetHandle(),p_xPassenger);
		if(HasBuildUp())then
			GetBuildUp()^.UpdateLinkedObjs();
		endif;
		pxPassenger^.SetTransportObj(GetHandle());
		if(pxTransporter!=null)then
			pxTransporter^.UpdateAllLinkedPassengers();
		endif;
		UpdatePassengerAttribs();
		if(CCrashRPGMgr.GetCrashRPGMgr()!=null)then
			CCrashRPGMgr.GetCrashRPGMgr()^.CheckRPGPassengers();
		endif;
		return true;
	endproc;
	
	export proc void LetLeavePassenger(CObjHndl p_xPassenger, int p_iEvent)
		return;
	endproc;
	
	export proc void HandleGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams)
		return;
	endproc;
	
	export proc void GameOverKill(int p_iSwitch)
		m_bDefeatCause=false;
		super.GameOverKill(p_iSwitch);
	endproc;
	
endclass;
	
class CCrashHack inherit CFightingObj
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetHitable(false);
		SetSelectable(false);
		SetFreeBorderBlocker(false);
		SetPlaceBlocker(false);
		CSrvWrap.GetPathfinder().RemPFBlocker(this);
		SetDynamicBBox(false);
		if(p_bLoad&&!CMirageSrvMgr.SDK())then
			var ^CGameOverMgr pxGOM=^(CGameOverMgr.Get());
			pxGOM^.SetEnabled(false);
			var int iState=pxGOM^.GetStateCode("skip");
			var int i, iC=8;
			for(i=0)cond(i<iC)iter(i++)do
				pxGOM^.SetPlayerState(i,iState);
			endfor;
//			Delete();
		endif;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		if(!CMirageSrvMgr.SDK())then
			var vec3 vPos={515.4, 511.2, 16.88};
			var int i, iC=6;
			for(i=0)cond(i<iC)iter(i++)do
				var ^CShowFOWObj pxO=cast<CShowFOWObj>(CSrvWrap.GetObjMgr()^.CreateObj("ShowFOW_Obj",i,vPos));
				if(pxO!=null)then
					pxO^.SetFOWRange(10.0);
					pxO^.SetKillTimer(20.0);
				endif;
			endfor;
			Delete();
		endif;
	endproc;
	
endclass;
	
class CCrashLaunchPad inherit CBuilding
	
	export var vec3		m_vHeight;
	export var int		m_iBuildLevel;
	export var bool		m_bReady;
	export var int		m_iConstructLevel;
	export var bool		m_bCanBeAttacked;
	export var bool		m_bDefeatCause;
	
	export constructor()
		m_bReady = false;
		m_bCanBeAttacked = false;
		m_bDefeatCause = true;
	endconstructor;
	
	destructor()
		if(m_bDefeatCause)then
			if(CCrashRPGMgr.GetCrashRPGMgr()!=null)then
				CCrashRPGMgr.GetCrashRPGMgr()^.Defeat();
			endif;
		endif;
	enddestructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="CrLp"; //CrashLaunchpad
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		(pxArc^) << m_vHeight;
		(pxArc^) << m_iBuildLevel;
		(pxArc^) << m_bReady;
		(pxArc^) << m_bCanBeAttacked;
		(pxArc^) << m_bDefeatCause;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="CrLp")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			(pxArc^) << m_vHeight;
			(pxArc^) << m_iBuildLevel;
			(pxArc^) << m_bReady;
			(pxArc^) << m_bCanBeAttacked;
			(pxArc^) << m_bDefeatCause;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool DoesCountInUnitLimit()
		return true;
	endproc;
	
	export proc string GetCranesName()
		return "hu";
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
//		SetNoParticles(true);
		if(!p_bLoad)then
			var int iLevel=(m_xTechTree.GetValueI("/Actions/"+GetTribeName()+"/Build/"+GetType().ToString()+"/"+GetClassName()+"/results/0/flags/level",1)-1);
			SetLevelClean(iLevel);
			m_iBuildLevel=iLevel;
			CreatePersonalProduceUnit(false);
		endif;
		SetSlaveInvincible(!m_bCanBeAttacked);
		var vec3 vPosition=GetPos();
		m_vHeight=vPosition;
		m_vHeight.SetZ(vPosition.GetZ()-11.0f);
//		if(!GetProduceUnit().IsValid())then
//			CreatePersonalProduceUnit(false);
//		endif;
	endproc;
	
	export proc void CreatePersonalProduceUnit(bool p_bSetReady)
		var ^CVirtualProduceUnit pxUnit=cast<CVirtualProduceUnit>(CSrvWrap.GetObjMgr()^.CreateObj("Virtual_Produce_Unit",GetOwner(),GetPos()));
		if(pxUnit!=null)then
			pxUnit^.Init(GetHandle());
			pxUnit^.SetLevelClean(m_iBuildLevel);
			m_xProduceUnit=pxUnit^.GetHandle();
			if(p_bSetReady)then
				pxUnit^.SetReady();
			endif;
		endif;
		return;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(IsTrapped() &&!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill"))then return; endif;
		super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
	endproc;
	
	export proc bool IsBuildMode()
		if(!m_bReady)then return true; endif;
		return (GetConstructLevel()<4);
	endproc;
	
	export proc void SetReady()
		m_bReady=true;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("unit_count",false);
		endif;
		SetVisible(false);
		super.SetReady();
		Die();
	endproc;
	
	export proc void Die()
		if(!IsDead())then
			var string sTribe=GetTribeName();
			sTribe.MakeLower();
			m_fHitpoints=0.0f;
			SetDead(true);
			if(m_bReady)then
				var ^CCrashBlimp pxBlimp=cast<CCrashBlimp>(CSrvWrap.GetObjMgr()^.CreateObj("crash_blimp",GetOwner(),m_vHeight,GetRotation()));
				if(pxBlimp!=null)then
					m_bDefeatCause=false;
					var ^CAttribs pxAttr=pxBlimp^.GetAttribs();
					if(pxAttr!=null)then
						pxAttr^.SetValue("clientpyramid_replacecard", GetName());
					endif;
					pxBlimp^.SetLevelClean(m_iBuildLevel);
					if(CCrashRPGMgr.GetCrashRPGMgr()!=null)then
						CCrashRPGMgr.GetCrashRPGMgr()^.SetZeppelin(pxBlimp^.GetHandle());
					endif;
				endif;
			endif;
			Delete();
		endif;
	endproc;
	
	export proc void CreateCorpse()
	endproc;
	
	export proc bool CreateBuildingCorpse()
		return true;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		if(!IsBuildMode())then
			SetReady();
		endif;
	endproc;
	
	export proc string GetReportCode()
		return "unit";
	endproc;
	
	export proc void SetCanBeAttacked(bool p_bOn)
		m_bCanBeAttacked=p_bOn;
	endproc;
	
	proc void UpdateFOW()
		var real fFOW=m_xTechTree.GetValueR(GetObjPath()+"/FOW",25.0);
		SetFOWRange(fFOW);
		return;
	endproc;
	
	export proc void GameOverKill(int p_iSwitch)
		m_bDefeatCause=false;
		super.GameOverKill(p_iSwitch);
	endproc;
	
endclass;
	
class CCRpgApprentice inherit CCharacter
	
endclass;

class CCRpgMerchant inherit CCharacter
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetSlaveInvincible(true);
		SetGodMode(true);
	endproc;
	
endclass;

class CCRpgBaseAnml inherit CAnimal
	
	const int RPG_CHECK_ENEMY					= 40133;
	const int RPG_FOUNTAIN						= 40132;
	const int RPG_RANDOM_POS					= 40131;
	const int RPG_BOARD_ZEPPELIN			= 40130;
	const int RPG_CENTER_REGION				= 40129;
	const int RPG_LEVEL_UP						= 40128;
	const int TIMER_CRASH_EVOLUTION		= 40122;
	const int TIMER_PLAYER_INACTIVITY	= 40174;
	
	var bool m_bAIBrain;
	var bool m_bReplaceDone;
	var bool m_bDisconnect;
	var bool m_bConquer;
	var bool m_bDefend;
	var bool m_bSkipCorpse;
	var bool m_bUserAction;
	var ^CRegion m_pxCenter;
	var ^CRegion m_pxTolerance;
	var CObjList m_xFountains;
	var CObjHndl m_xZeppelin;
	
	export constructor()
		m_bAIBrain = false;
		m_bReplaceDone = false;
		m_bDisconnect = false;
		m_bConquer = false;
		m_bDefend = false;
		m_bSkipCorpse = false;
		m_bUserAction = false;
	endconstructor;
	
	export destructor()
		if(CCrashRPGMgr.GetCrashRPGMgr()!=null)then
			CCrashRPGMgr.GetCrashRPGMgr()^.RemoveRPGPassenger(GetHandle(),m_bDisconnect,GetClassName(),GetLevel(),GetOwner(),GetAIBrain(),GetKillerCount(),GetKillerHistory(),GetAggressionState(),m_xFountains,m_xZeppelin);
			CCrashRPGMgr.GetCrashRPGMgr()^.CheckRPGPassengers();
		endif;
	enddestructor;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
		if(p_pxReaderNode^.GetType()=="RPGU")then
			if(p_pxReaderNode^.GetVersion()>=1)then
				m_xFountains.DoKArc(pxArc^);
				m_xZeppelin.DoKArc(pxArc^);
//				(pxArc^) << m_bRotating;
				(pxArc^) << m_bAIBrain;
				(pxArc^) << m_bReplaceDone;
				(pxArc^) << m_bDisconnect;
				(pxArc^) << m_bConquer;
				(pxArc^) << m_bDefend;
				(pxArc^) << m_bSkipCorpse;
				(pxArc^) << m_bUserAction;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="RPGU";
		var int iVersion=1;
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,iVersion);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xFountains.DoKArc(pxArc^);
		m_xZeppelin.DoKArc(pxArc^);
//		(pxArc^) << m_bRotating;
		(pxArc^) << m_bAIBrain;
		(pxArc^) << m_bReplaceDone;
		(pxArc^) << m_bDisconnect;
		(pxArc^) << m_bConquer;
		(pxArc^) << m_bDefend;
		(pxArc^) << m_bSkipCorpse;
		(pxArc^) << m_bUserAction;
		pxWalk^.Close();
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad && CCrashRPGMgr.GetCrashRPGMgrNC()!=null)then
			m_bDefend=CCrashRPGMgr.GetCrashRPGMgr()^.DefendCenter();
		endif;
		ValidateRegions();
		if(!HasTimer(TIMER_PLAYER_INACTIVITY))then
			CreateTimer(TIMER_PLAYER_INACTIVITY,CGameTimeSpan.OneSecond()*90.0f,true);
		endif;
		if(p_bLoad && m_bAIBrain)then
			AddAutoMoves();
		endif;
	endproc;
	
	export proc void SetCustomHandles(string p_sIdentifier, CObjHndl p_xHndl)
		m_xZeppelin=p_xHndl;
		if(m_bAIBrain && p_sIdentifier=="zeppelin" && p_xHndl.IsValid())then
			MountBlimp(p_xHndl);
		endif;
	endproc;
	
	export proc void SetCustomLists(string p_sIdentifier, CObjList p_xList)
		if(p_sIdentifier=="fountain")then
			SetFountains(p_xList);
		endif;
	endproc;
	
	export proc bool GetAIBrain()
		return m_bAIBrain;
	endproc;
	
	export proc void SetAIBrain(bool p_bOn)
		var bool bOld=m_bAIBrain;
		m_bAIBrain=p_bOn;
		if(!bOld && p_bOn)then
			AddAutoMoves();
			if(!GetCurEnemy().IsValid())then
				if(!LookForEnemies() && ExamineEnemies(false))then
					SetRandomPos();
				endif;
			endif;
		endif;
		if(!HasTimer(RPG_CHECK_ENEMY))then
			CreateTimer(RPG_CHECK_ENEMY,CGameTimeSpan.OneSecond()*7.0f,true);
		endif;
		if(m_bAIBrain)then
			if(!HasTimer(RPG_LEVEL_UP))then
				CreateTimer(RPG_LEVEL_UP,CGameTimeSpan.OneSecond()*15.0f,true);
			endif;
			if(!HasTimer(RPG_CENTER_REGION))then
				CreateTimer(RPG_CENTER_REGION,CGameTimeSpan.OneSecond()*5.0f,true);
			endif;
			if(!HasTimer(RPG_RANDOM_POS))then
				CreateTimer(RPG_RANDOM_POS,CGameTimeSpan.OneSecond()*10.0f,true);
			endif;
			if(!HasTimer(RPG_FOUNTAIN))then
				CreateTimer(RPG_FOUNTAIN,CGameTimeSpan.OneSecond()*8.0f,true);
			endif;
			if(!HasTimer(RPG_CHECK_ENEMY))then
				CreateTimer(RPG_CHECK_ENEMY,CGameTimeSpan.OneSecond()*7.0f,true);
			endif;
			if(m_xZeppelin.IsValid() && !HasTimer(RPG_BOARD_ZEPPELIN))then
				CreateTimer(RPG_CHECK_ENEMY,CGameTimeSpan.OneSecond()*15.0f,true);
			endif;
		else
			DeleteTimer(RPG_LEVEL_UP);
			DeleteTimer(RPG_CENTER_REGION);
			DeleteTimer(RPG_RANDOM_POS);
			DeleteTimer(RPG_FOUNTAIN);
			DeleteTimer(RPG_CHECK_ENEMY);
			DeleteTimer(RPG_BOARD_ZEPPELIN);
			ClearAutoMoves();
		endif;
	endproc;
	
	proc bool ValidateRegions()
		var ^CRegionMgr pxRegionMgr=^(CSrvWrap.GetRegionMgr());
		if(pxRegionMgr==null)then return false; endif;
		if(m_bDefend||!m_bConquer)then
			m_pxCenter=pxRegionMgr^.GetRegion("center");
			m_pxTolerance=pxRegionMgr^.GetRegion("tolerance");
		else
			m_pxCenter=pxRegionMgr^.GetRegion("island");
			m_pxTolerance=pxRegionMgr^.GetRegion("island");
		endif;
		if(m_pxCenter==null||m_pxTolerance==null)then return false; endif;
		return true;
	endproc;
	
	export proc void AttackSrv(^CGameObj p_pxEnemy)
		if(GetAIBrain()&&p_pxEnemy!=null)then
			if(!IsInToleranceArea(p_pxEnemy^.GetPos()))then return; endif;
		endif;
//		if(GetCurTaskName()=="FntnHeal")then return; endif;
		return super.AttackSrv(p_pxEnemy);
	endproc;
	
	proc void OnDefend(^CGameObj p_pxEnemy)
		if(GetAIBrain()&&p_pxEnemy!=null)then
			if(!IsInToleranceArea(p_pxEnemy^.GetPos()))then return; endif;
		endif;
		if(GetAIBrain() || GetHPPercent()>4)then
			CallNakamas(p_pxEnemy, this);
		endif;
		super.OnDefend(p_pxEnemy);
	endproc;
	
	proc void CallNakamas(^CGameObj p_pxEnemy,^CGameObj p_pxVictim)
		if(p_pxEnemy==null || (!m_bConquer && (cast<CGate>(p_pxEnemy)!=null || cast<CWall>(p_pxEnemy)!=null)))then return; endif;
		if(!IsInToleranceArea(p_pxEnemy^.GetPos()))then return; endif;
		var CObjList xList;
		if(CCrashRPGMgr.GetCrashRPGMgr()!=null)then
			xList = CCrashRPGMgr.GetCrashRPGMgr()^.GetRPGUnits();
		endif;
		var int i,iC=xList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(xList[i]==GetHandle())then continue; endif;
			var ^CFightingObj pxFO=cast<CFightingObj>(xList[i].GetObj());
			if(pxFO!=null && pxFO^.GetAIBrain())then
				if(!pxFO^.IsInFight() && !ImportantTask(pxFO^.GetCurTaskName()))then
					pxFO^.Fight(p_pxEnemy, p_pxEnemy^.GetPos(), true, false);
				endif;
			endif;
		endfor;
	endproc;
	
	export proc vec3 GetNewRandomPos()
		var vec3 vTmp;
		if(m_pxCenter!=null)then
			return m_pxCenter^.GetRandomPointInside();
		endif;
		return vTmp;
	endproc;
	
	export proc bool IsInCenterArea(vec3 p_vPos)
		if(m_pxCenter!=null)then
			return m_pxCenter^.IsInside(p_vPos);
		endif;
		return true;
	endproc;
	
	export proc bool IsInToleranceArea(vec3 p_vPos)
		if(m_pxTolerance!=null)then
			return m_pxTolerance^.IsInside(p_vPos);
		endif;
		return true;
	endproc;
	
	export proc bool IsWildAnimal()
		return false;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(m_bAIBrain)then
			SetAIBrain(false);
		endif;
		m_bUserAction=true;
		if(IsBerserking() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1) && !(p_sMiscParams.Find("/crash_rpg_levelup")!=-1)
			)then return; endif;
		if(IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			 && !(p_sMiscParams.Find("/crash_rpg_levelup")!=-1))then return; endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("/crash_rpg_levelup")!=(-1))then
				if(CheckSpecialActionTimer(p_sMiscParams) && !GetTransportObj().IsValid())then
					CrashRpgLevelup(p_sMiscParams);
				endif;
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	proc void CrashRpgLevelup(string p_sPath)
		if(m_bReplaceDone)then return; endif;
		if(GetLevel()<4)then return; endif;
		var string sNew, sClass=GetClassName();
		var int iLvl=(sClass.Right(1).ToInt())+1;
		if(iLvl<2||iLvl>4)then return; endif;
		sNew=sClass.Left(sClass.GetLength()-1)+iLvl.ToString();
		if(CCrashRPGMgr.GetCrashRPGMgr()!=null)then
			CCrashRPGMgr.GetCrashRPGMgr()^.SetScalpCosts(GetOwner(), iLvl);
		endif;
		var ^CFightingObj pxNew = cast<CFightingObj>(CSrvWrap.GetObjMgr()^.CreateObj(sNew, GetOwner(), GetPos(), GetRotation()));
		if(pxNew==null)then return; endif;
		var vec3 vP = GetCurWalkTarget();
		var CObjHndl xCurEnemy=GetCurEnemy();
		m_bReplaceDone=true;
		pxNew^.SetAIBrain(m_bAIBrain);
		pxNew^.SetAggressionState(GetAggressionState());
		pxNew^.SetCustomLists("fountain",m_xFountains);
		pxNew^.SetCustomHandles("zeppelin",m_xZeppelin);
		if(CCrashRPGMgr.GetCrashRPGMgr()!=null)then
			CCrashRPGMgr.GetCrashRPGMgr()^.ReplaceRPGPassenger(GetHandle(), pxNew^.GetHandle());
		endif;
		var CFourCC xLink="NOPE";
		var CObjHndl xHndl;
		xHndl=pxNew^.AddFX("fx_stina_convert",4.0);
		if(xHndl.IsValid())then
			xHndl.GetObj()^.LinkAction(pxNew^.GetHandle(),xLink);
		endif;
//		xHndl=pxNew^.AddFX("Upgrade_Animal_Fx",4.0);
//		if(xHndl.IsValid())then
//			xHndl.GetObj()^.LinkAction(pxNew^.GetHandle(),xLink);
//		endif;
		var ^CInventory pxInv=GetInventory();
		if(pxInv!=null)then
			var int i, iC=pxInv^.Count();
			var CObjList xList;
			for(i=0) cond(i<iC) iter(++i) do
				if(!pxInv^.GetItem(i).IsValid())then continue; endif;
				xList.Include(pxInv^.GetItem(i));
			endfor;
			iC=xList.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				if(xList[i].IsValid())then
					var ^CGameObj pxItem=xList[i].GetObj();
					var ^CItem pxI=cast<CItem>(pxItem);
					if(pxI!=null)then
						RemoveItemSilent(pxI^.GetHandle());
						pxNew^.AddItemSilent(pxI^.GetHandle());
					endif;
				endif;
			endfor;
		endif;
		if(xCurEnemy.IsValid())then
			pxNew^.MemorizeCurrentFightState(xCurEnemy,true,false);
			pxNew^.ReturnToFight();
		elseif(HasWalkAction() && GetCurTaskName()!="FntnHeal")then
			pxNew^.WalkAction(vP,pxNew^.GetMaxSpeed());
		else
			pxNew^.ExamineEnemies(false);
		endif;
		pxNew^.SetKillerNumbers(GetKillerCount(),GetKillerHistory());
		pxNew^.SetLastEnemy(GetLastEnemy());
		pxNew^.SetLastDamage(GetLastDamage());
//		CSrvWrap.SendGenericEvtToPlayer(GetOwner(), "ScalpsCostsUpdate\t");
		m_bSkipCorpse=true;
		Delete();
	endproc;
	
	export proc bool SetLevelClean(int p_iLevel)
		var int iPrev=GetLevel();
		var bool bR=super.SetLevelClean(p_iLevel);
		var bool bOld=m_bConquer;
//		m_bConquer=GetClassName().Find("_lvl4")!=-1&&GetLevel()>0;
		m_bConquer=GetClassName().Find("_lvl4")!=-1;
		if(bOld!=m_bConquer)then
			ValidateRegions();
		endif;
		var int iNew=GetLevel();
		var string sClass=GetClassName();
		if(iPrev<iNew&&iNew==4&&sClass.Find("_lvl4")==-1)then
			CreateTimer(TIMER_CRASH_EVOLUTION,CGameTimeSpan.OneSecond()*10.0,false);
		endif;
		return bR;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==TIMER_CRASH_EVOLUTION)then
				if(GetTransportObj().IsValid())then
					CreateTimer(TIMER_CRASH_EVOLUTION,CGameTimeSpan.OneSecond()*3.0,false);
				else
//					CrashRpgLevelup("");
				endif;
			elseif(iTimerID==RPG_CENTER_REGION)then
				if(!IsInCenterArea(GetPos()))then
//					var bool bWalkInArea=false;
//					var ^CWalkToPos pxCurWalkTask=cast<CWalkToPos>(GetCurTask());
//					if(pxCurWalkTask!=null)then
//						var vec3 vTargetPos=pxCurWalkTask^.GetTargetPos();
//						if(IsInCenterArea(vTargetPos))then
//							bWalkInArea=true;
//						endif;
//					endif;
//					bWalkInArea=bWalkInArea||(IsInToleranceArea(GetPos())&&IsInFight());
					var bool bWalkInArea=IsInToleranceArea(GetPos())&&IsInFight();
					if(!bWalkInArea)then
						var vec3 vPos = GetNewRandomPos();
						CSrvWrap.GetObjMgr()^.GetFreePos(vPos,this,vPos,null,true,false,false);
						GoTo(vPos, true, GetMaxSpeed(), true, true);
					endif;
				endif;
				return;
			elseif(iTimerID==RPG_RANDOM_POS)then
				SetRandomPos();
			elseif(iTimerID==RPG_LEVEL_UP)then
				TryToEvolve();
			elseif(iTimerID==RPG_FOUNTAIN)then
				if(GetHitpoints()<GetMaxHitpoints() && !IsInFight() && GetCurTaskName()!="FntnHeal")then
					UseHealWell();
				endif;
			elseif(iTimerID==RPG_CHECK_ENEMY)then
				if(!m_xCurEnemy.IsValid() && !ImportantTask(GetCurTaskName()))then
					LookForEnemies();
				endif;
			elseif(iTimerID==RPG_BOARD_ZEPPELIN)then
				var ^CCrashBlimp pxB=cast<CCrashBlimp>(m_xZeppelin.GetObj());
				if(pxB!=null && !LookForEnemies())then
					BoardTransport(pxB, pxB^.GetPos(), true, "dummy");
				endif;
			elseif(iTimerID==TIMER_PLAYER_INACTIVITY)then
				if(!m_bUserAction)then
					if(!m_bAIBrain)then
						SetAIBrain(true);
					endif;
				endif;
				m_bUserAction=false;
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		elseif(p_rxEvtPtr.GetClass()=="DefendBlimp")then
			m_bDefend=p_rxEvtPtr.GetBool(0);
			ValidateRegions();
			if(!IsInCenterArea(GetPos()))then
				var bool bWalkInArea=false;
				var ^CWalkToPos pxCurWalkTask=cast<CWalkToPos>(GetCurTask());
				if(pxCurWalkTask!=null)then
					var vec3 vTargetPos=pxCurWalkTask^.GetTargetPos();
					if(IsInCenterArea(vTargetPos))then
						bWalkInArea=true;
					endif;
				endif;
				bWalkInArea=bWalkInArea||(IsInToleranceArea(GetPos())&&IsInFight());
				if(!bWalkInArea)then
					var vec3 vPos = GetNewRandomPos();
					CSrvWrap.GetObjMgr()^.GetFreePos(vPos,this,vPos,null,true,false,false);
					GoTo(vPos, true, GetMaxSpeed(), true, true);
				endif;
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	proc void SetRandomPos()
		var vec3 vPos = GetNewRandomPos();
		if(!IsInFight())then
			UpdateAggressionPos(vPos);
		endif;
		if(GetTaskDescription()=="Idle"||GetTaskDescription()=="")then
			CSrvWrap.GetObjMgr()^.GetFreePos(vPos,this,vPos,null,true,false,false);
			GoTo(vPos, false, GetDefaultSpeed(), true, true);
		endif;
	endproc;
	
	proc bool TryToEvolve()
		var int iLevel = GetLevel();
		if(iLevel<4)then
			return SetLevel(iLevel+1);
		elseif(iLevel==4 && GetClassName().Find("_lvl4")==-1)then
			CrashRpgLevelup("");
			return true;
		endif;
		return false;
	endproc;
	
	export proc void DoHPRelatedStuff()
		if(!m_bAIBrain)then return; endif;
		if((GetHitpoints()!=0.0f)&&(GetMaxHitpoints()!=0.0f))then
			var real fPercentage=GetHitpoints()/(GetMaxHitpoints()/100.0);
			if(fPercentage<=50.0f)then
				if(!TryToEvolve())then
					if(GetCurTaskName()!="FntnHeal")then
						UseHealWell();
					endif;
				endif;
			endif;
		endif;
	endproc;
	
	export proc void MountBlimp(CObjHndl p_xB)
		if(!m_bAIBrain||!p_xB.IsValid())then return; endif;
		m_xZeppelin=p_xB;
		if(!HasTimer(RPG_BOARD_ZEPPELIN))then
			CreateTimer(RPG_BOARD_ZEPPELIN,CGameTimeSpan.OneSecond()*15.0f,true);
		endif;
		if(m_xCurEnemy.IsValid()||LookForEnemies())then return; endif;
		var ^CCrashBlimp pxB=cast<CCrashBlimp>(p_xB.GetObj());
		if(pxB!=null)then
			BoardTransport(pxB, pxB^.GetPos(), true, "dummy");
		endif;
	endproc;
	
	export proc void SetFountains(CObjList p_xF)
		m_xFountains=p_xF;
	endproc;
	
	export proc void RemoveItemPL(CObjHndl p_xItem)
		RemoveItemSilent(p_xItem);
	endproc;
	
	export proc void RemoveItemSilent(CObjHndl p_xItem)
		var ^CInventory pxInv=GetInventory();
		if(pxInv==null)then return; endif;
		var ^CItem pxItem=cast<CItem>(p_xItem.GetObj());
		if(pxItem==null)then return; endif;
		pxInv^.RemItem(pxItem^.GetHandle());
		pxItem^.OnDroppedItem(this,false,"Silent!",true);
		pxItem^.TerminateAction();
		AddItemName("");
		return;
	endproc;
	
	export proc void AddItemSilent(CObjHndl p_xItem)
		var ^CInventory pxInv=GetInventory();
		if(pxInv==null)then return; endif;
		var ^CItem pxItem=cast<CItem>(p_xItem.GetObj());
		if(pxItem==null)then return; endif;
		pxInv^.AddItem(pxItem^.GetHandle());
		pxItem^.SetVisible(false);
		pxItem^.OnTakeItem(this,"Silent!",true);
		AddItemName(pxItem^.GetName());
		return;
	endproc;
	
	export proc void AddItem(CObjHndl p_xItem)
		var ^CInventory pxInv=GetInventory();
		if(pxInv==null)then return; endif;
		var ^CItem pxItem=cast<CItem>(p_xItem.GetObj());
		if(pxItem==null)then return; endif;
		pxInv^.AddItem(pxItem^.GetHandle());
		pxItem^.SetVisible(false);
		pxItem^.OnTakeItem(this,"normal",true);
		AddItemName(pxItem^.GetName());
		InvokeGenericSCEvent(38,0.6f);
		return;
	endproc;
	
	export proc void RemoveItem(CObjHndl p_xItem)
		var ^CInventory pxInv=GetInventory();
		if(pxInv==null)then return; endif;
		var ^CItem pxItem=cast<CItem>(p_xItem.GetObj());
		if(pxItem==null)then return; endif;
		pxInv^.RemItem(pxItem^.GetHandle());
		pxItem^.OnDropped(this);
		pxItem^.TerminateAction();
		AddItemName("");
		return;
	endproc;
	
	export proc void ReleaseItem(string p_sItemName, bool p_bQ)
		var ^CInventory pxInv=GetInventory();
		if(pxInv==null)then return; endif;
		var ^CItem pxItem=cast<CItem>(CSrvWrap.GetObjMgr()^.GetObjByName(p_sItemName));
		if(pxItem==null)then return; endif;
		if(p_bQ)then
			StartCustomTask("ReleaseItemFree","");
			return;
		endif;
		pxInv^.RemItem(pxItem^.GetHandle());
		pxItem^.OnDroppedItem(this,true,"normal",false);
		pxItem^.TerminateAction();
		if(HasAnim("put_down"))then
			AnimAction("put_down");
		endif;
		AddItemName("");
		return;
	endproc;
	
	export proc bool SkipCorpse()
		return m_bSkipCorpse;
	endproc;
	
	export proc void FilterEnemyListCustom(ref CObjList p_rxList)
		if(!m_bAIBrain)then return; endif;
		var ^CFightingObj pxE;
		var int i,iC=p_rxList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var CObjHndl xHndl=p_rxList[i];
			if(xHndl.IsValid())then
				pxE=cast<CFightingObj>(xHndl.GetObj());
				if(pxE==null)then
					p_rxList.DeleteEntry(i);i--;iC--;
				elseif(!m_bConquer && (cast<CWall>(pxE)!=null || cast<CGate>(pxE)!=null))then
					p_rxList.DeleteEntry(i);i--;iC--;
				elseif(pxE^.GetSlaveInvincible())then
					p_rxList.DeleteEntry(i);i--;iC--;
				endif;
			endif;
		endfor;
		super.FilterEnemyListCustom(p_rxList);
	endproc;
	
	export proc bool ResistantToThrow()
		return true;
	endproc;
	
	export proc void FountainArrived(CObjHndl p_xObj)
		if(!m_bAIBrain)then return; endif;
		if(!ExamineEnemies(false))then
		elseif(GetReturnEnemy().IsValid())then
			ReturnToFight();
		elseif(!LookForEnemies())then
			SetRandomPos();
		endif;
	endproc;
	
	export proc void UseHealWell()
		if(m_xFountains.NumEntries()<1)then return; endif;
		m_xFountains.SortDistance(GetPos());
		MemorizeCurrentFightState(GetCurEnemy(),true,false);
		FountainHeal(m_xFountains[0].GetObj(),false);
	endproc;
	
	proc bool LookForEnemies()
		var CObjQuery xQ;
		xQ.SetType("CHTR", false);
		xQ.SetType("ANML", true);
		xQ.SetType("VHCL", true);
		xQ.SetType("BLDG", true);
		xQ.SetAttribsNeg("invalid_enemy",true);
		if(!CanShootAir())then
			xQ.SetAttribsNeg("flying_unit",true);
		endif;
		xQ.SetAttribsNeg("not_detectable",true);
		if(m_pxTolerance!=null)then
			xQ.SetRegion(m_pxTolerance^.GetHandle());
		else
			xQ.RegionCircle(GetPos(), 100.0f);
		endif;
		var ^CGameObj pxEnemy=null;
		CSrvWrap.GetDiplomacyMgr().AddMyEnemiesToSearch(GetOwner(), xQ, false);
		var CObjList xList;
		if(!xQ.Execute(xList))then return false; endif;
		FilterEnemyListCustom(xList);
		xList.SortDistance(GetPos());
		var CObjList xEnd;
//		xList.CopySorted(xEnd, GetPos(), 100.0f);
		xEnd=xList;
		if(xEnd.NumEntries()>0)then
			var int i, iC=xEnd.NumEntries();
			for(i=0)cond(i<iC)iter(++i)do
				if(xEnd[i].IsValid())then
					var ^CGameObj pxO=xEnd[i].GetObj();
					if(pxO!=null)then
						pxEnemy=pxO;
						break;
					endif;
				endif;
			endfor;
		endif;
		if(pxEnemy!=null)then
			var vec3 vEPos=pxEnemy^.GetPos();
			Fight(pxEnemy, vEPos, true, false);
			return true;
		endif;
		return false;
	endproc;
	
	export proc void GameOverKill(int p_iSwitch)
		m_bDisconnect=p_iSwitch<1;
		if(p_iSwitch==1)then SetAIBrain(true); return; endif;
//		if(p_iSwitch==1)then m_bAIBrain=true; endif;
//		super.GameOverKill(p_iSwitch);
	endproc;
	
	export proc void DiePerHarakiri()
		return;
	endproc;
	
	export proc void CreateSpirit()
		return;
	endproc;
	
	export proc void AddAutoMoves()
	endproc;
	
	export proc bool ImportantTask(string p_sTask)
		if(p_sTask=="FntnHeal")then return true; endif;
		return false;
	endproc;
	
endclass;

class CCRpgBaseChtr inherit CCharacter
	
	const int RPG_CHECK_ENEMY					= 40133;
	const int RPG_FOUNTAIN						= 40132;
	const int RPG_RANDOM_POS					= 40131;
	const int RPG_BOARD_ZEPPELIN			= 40130;
	const int RPG_CENTER_REGION				= 40129;
	const int RPG_LEVEL_UP						= 40128;
	const int TIMER_CRASH_EVOLUTION		= 40122;
	const int TIMER_PLAYER_INACTIVITY	= 40174;
	
	var bool m_bAIBrain;
	var bool m_bReplaceDone;
	var bool m_bDisconnect;
	var bool m_bConquer;
	var bool m_bDefend;
	var bool m_bSkipCorpse;
	var bool m_bUserAction;
	var ^CRegion m_pxCenter;
	var ^CRegion m_pxTolerance;
	var CObjList m_xFountains;
	var CObjHndl m_xZeppelin;
	
	export constructor()
		m_bAIBrain = false;
		m_bReplaceDone = false;
		m_bDisconnect = false;
		m_bConquer = false;
		m_bDefend = false;
		m_bSkipCorpse = false;
		m_bUserAction = false;
	endconstructor;
	
	export destructor()
		if(CCrashRPGMgr.GetCrashRPGMgr()!=null)then
			CCrashRPGMgr.GetCrashRPGMgr()^.RemoveRPGPassenger(GetHandle(),m_bDisconnect,GetClassName(),GetLevel(),GetOwner(),GetAIBrain(),GetKillerCount(),GetKillerHistory(),GetAggressionState(),m_xFountains,m_xZeppelin);
			CCrashRPGMgr.GetCrashRPGMgr()^.CheckRPGPassengers();
		endif;
	enddestructor;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
		if(p_pxReaderNode^.GetType()=="RPGU")then
			if(p_pxReaderNode^.GetVersion()>=1)then
				m_xFountains.DoKArc(pxArc^);
				m_xZeppelin.DoKArc(pxArc^);
				(pxArc^) << m_bAIBrain;
				(pxArc^) << m_bReplaceDone;
				(pxArc^) << m_bDisconnect;
				(pxArc^) << m_bConquer;
				(pxArc^) << m_bDefend;
				(pxArc^) << m_bSkipCorpse;
				(pxArc^) << m_bUserAction;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="RPGU";
		var int iVersion=1;
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,iVersion);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xFountains.DoKArc(pxArc^);
		m_xZeppelin.DoKArc(pxArc^);
		(pxArc^) << m_bAIBrain;
		(pxArc^) << m_bReplaceDone;
		(pxArc^) << m_bDisconnect;
		(pxArc^) << m_bConquer;
		(pxArc^) << m_bDefend;
		(pxArc^) << m_bSkipCorpse;
		(pxArc^) << m_bUserAction;
		pxWalk^.Close();
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad && CCrashRPGMgr.GetCrashRPGMgrNC()!=null)then
			m_bDefend=CCrashRPGMgr.GetCrashRPGMgr()^.DefendCenter();
		endif;
		ValidateRegions();
		if(!HasTimer(TIMER_PLAYER_INACTIVITY))then
			CreateTimer(TIMER_PLAYER_INACTIVITY,CGameTimeSpan.OneSecond()*90.0f,true);
		endif;
		if(p_bLoad && m_bAIBrain)then
			AddAutoMoves();
		endif;
	endproc;
	
	export proc void SetCustomHandles(string p_sIdentifier, CObjHndl p_xHndl)
		m_xZeppelin=p_xHndl;
		if(m_bAIBrain && p_sIdentifier=="zeppelin" && p_xHndl.IsValid())then
			MountBlimp(p_xHndl);
		endif;
	endproc;
	
	export proc void SetCustomLists(string p_sIdentifier, CObjList p_xList)
		if(p_sIdentifier=="fountain")then
			SetFountains(p_xList);
		endif;
	endproc;
	
	export proc bool GetAIBrain()
		return m_bAIBrain;
	endproc;
	
	export proc void SetAIBrain(bool p_bOn)
		var bool bOld=m_bAIBrain;
		m_bAIBrain=p_bOn;
		if(!bOld && p_bOn)then
			AddAutoMoves();
			if(!GetCurEnemy().IsValid())then
				if(!LookForEnemies() && ExamineEnemies(false))then
					SetRandomPos();
				endif;
			endif;
		endif;
		if(m_bAIBrain)then
			if(!HasTimer(RPG_LEVEL_UP))then
				CreateTimer(RPG_LEVEL_UP,CGameTimeSpan.OneSecond()*15.0f,true);
			endif;
			if(!HasTimer(RPG_CENTER_REGION))then
				CreateTimer(RPG_CENTER_REGION,CGameTimeSpan.OneSecond()*5.0f,true);
			endif;
			if(!HasTimer(RPG_RANDOM_POS))then
				CreateTimer(RPG_RANDOM_POS,CGameTimeSpan.OneSecond()*10.0f,true);
			endif;
			if(!HasTimer(RPG_FOUNTAIN))then
				CreateTimer(RPG_FOUNTAIN,CGameTimeSpan.OneSecond()*8.0f,true);
			endif;
			if(!HasTimer(RPG_CHECK_ENEMY))then
				CreateTimer(RPG_CHECK_ENEMY,CGameTimeSpan.OneSecond()*7.0f,true);
			endif;
			if(m_xZeppelin.IsValid() && !HasTimer(RPG_BOARD_ZEPPELIN))then
				CreateTimer(RPG_CHECK_ENEMY,CGameTimeSpan.OneSecond()*15.0f,true);
			endif;
		else
			DeleteTimer(RPG_LEVEL_UP);
			DeleteTimer(RPG_CENTER_REGION);
			DeleteTimer(RPG_RANDOM_POS);
			DeleteTimer(RPG_FOUNTAIN);
			DeleteTimer(RPG_CHECK_ENEMY);
			DeleteTimer(RPG_BOARD_ZEPPELIN);
			ClearAutoMoves();
		endif;
	endproc;
	
	proc bool ValidateRegions()
		var ^CRegionMgr pxRegionMgr=^(CSrvWrap.GetRegionMgr());
		if(pxRegionMgr==null)then return false; endif;
		if(m_bDefend||!m_bConquer)then
			m_pxCenter=pxRegionMgr^.GetRegion("center");
			m_pxTolerance=pxRegionMgr^.GetRegion("tolerance");
		else
			m_pxCenter=pxRegionMgr^.GetRegion("island");
			m_pxTolerance=pxRegionMgr^.GetRegion("island");
		endif;
		if(m_pxCenter==null||m_pxTolerance==null)then return false; endif;
		return true;
	endproc;
	
	export proc void AttackSrv(^CGameObj p_pxEnemy)
		if(GetAIBrain()&&p_pxEnemy!=null)then
			if(!IsInToleranceArea(p_pxEnemy^.GetPos()))then return; endif;
		endif;
//		if(GetCurTaskName()=="FntnHeal")then return; endif;
		return super.AttackSrv(p_pxEnemy);
	endproc;
	
	proc void OnDefend(^CGameObj p_pxEnemy)
		if(GetAIBrain()&&p_pxEnemy!=null)then
			if(!IsInToleranceArea(p_pxEnemy^.GetPos()))then return; endif;
		endif;
		if(GetAIBrain() || GetHPPercent()>4)then
			CallNakamas(p_pxEnemy, this);
		endif;
		super.OnDefend(p_pxEnemy);
	endproc;
	
	proc void CallNakamas(^CGameObj p_pxEnemy,^CGameObj p_pxVictim)
		if(p_pxEnemy==null || (!m_bConquer && (cast<CGate>(p_pxEnemy)!=null || cast<CWall>(p_pxEnemy)!=null)))then return; endif;
		if(!IsInToleranceArea(p_pxEnemy^.GetPos()))then return; endif;
		var CObjList xList;
		if(CCrashRPGMgr.GetCrashRPGMgr()!=null)then
			xList = CCrashRPGMgr.GetCrashRPGMgr()^.GetRPGUnits();
		endif;
		var int i,iC=xList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(xList[i]==GetHandle())then continue; endif;
			var ^CFightingObj pxFO=cast<CFightingObj>(xList[i].GetObj());
			if(pxFO!=null && pxFO^.GetAIBrain())then
				if(!pxFO^.IsInFight() && !ImportantTask(pxFO^.GetCurTaskName()))then
					pxFO^.Fight(p_pxEnemy, p_pxEnemy^.GetPos(), true, false);
				endif;
			endif;
		endfor;
	endproc;
	
	export proc vec3 GetNewRandomPos()
		var vec3 vTmp;
		if(m_pxCenter!=null)then
			return m_pxCenter^.GetRandomPointInside();
		endif;
		return vTmp;
	endproc;
	
	export proc bool IsInCenterArea(vec3 p_vPos)
		if(m_pxCenter!=null)then
			return m_pxCenter^.IsInside(p_vPos);
		endif;
		return true;
	endproc;
	
	export proc bool IsInToleranceArea(vec3 p_vPos)
		if(m_pxTolerance!=null)then
			return m_pxTolerance^.IsInside(p_vPos);
		endif;
		return true;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==TIMER_CRASH_EVOLUTION)then
				if(GetTransportObj().IsValid())then
					CreateTimer(TIMER_CRASH_EVOLUTION,CGameTimeSpan.OneSecond()*3.0,false);
				else
//					CrashRpgLevelup("");
				endif;
			elseif(iTimerID==RPG_CENTER_REGION)then
				if(!IsInCenterArea(GetPos()))then
//					var bool bWalkInArea=false;
//					var ^CWalkToPos pxCurWalkTask=cast<CWalkToPos>(GetCurTask());
//					if(pxCurWalkTask!=null)then
//						var vec3 vTargetPos=pxCurWalkTask^.GetTargetPos();
//						if(IsInCenterArea(vTargetPos))then
//							bWalkInArea=true;
//						endif;
//					endif;
//					bWalkInArea=bWalkInArea||(IsInToleranceArea(GetPos())&&IsInFight());
					var bool bWalkInArea=IsInToleranceArea(GetPos())&&IsInFight();
					if(!bWalkInArea)then
						var vec3 vPos = GetNewRandomPos();
						CSrvWrap.GetObjMgr()^.GetFreePos(vPos,this,vPos,null,true,false,false);
						GoTo(vPos, true, GetMaxSpeed(), true, true);
					endif;
				endif;
				return;
			elseif(iTimerID==RPG_RANDOM_POS)then
				SetRandomPos();
			elseif(iTimerID==RPG_LEVEL_UP)then
				TryToEvolve();
			elseif(iTimerID==RPG_FOUNTAIN)then
				if(GetHitpoints()<GetMaxHitpoints() && !IsInFight() && GetCurTaskName()!="FntnHeal")then
					UseHealWell();
				endif;
			elseif(iTimerID==RPG_CHECK_ENEMY)then
				if(!m_xCurEnemy.IsValid() && !ImportantTask(GetCurTaskName()))then
					LookForEnemies();
				endif;
			elseif(iTimerID==RPG_BOARD_ZEPPELIN)then
				var ^CCrashBlimp pxB=cast<CCrashBlimp>(m_xZeppelin.GetObj());
				if(pxB!=null && !LookForEnemies())then
					BoardTransport(pxB, pxB^.GetPos(), true, "dummy");
				endif;
			elseif(iTimerID==TIMER_PLAYER_INACTIVITY)then
				if(!m_bUserAction)then
					if(!m_bAIBrain)then
						SetAIBrain(true);
					endif;
				endif;
				m_bUserAction=false;
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		elseif(p_rxEvtPtr.GetClass()=="DefendBlimp")then
			m_bDefend=p_rxEvtPtr.GetBool(0);
			ValidateRegions();
			if(!IsInCenterArea(GetPos()))then
				var bool bWalkInArea=false;
				var ^CWalkToPos pxCurWalkTask=cast<CWalkToPos>(GetCurTask());
				if(pxCurWalkTask!=null)then
					var vec3 vTargetPos=pxCurWalkTask^.GetTargetPos();
					if(IsInCenterArea(vTargetPos))then
						bWalkInArea=true;
					endif;
				endif;
				bWalkInArea=bWalkInArea||(IsInToleranceArea(GetPos())&&IsInFight());
				if(!bWalkInArea)then
					var vec3 vPos = GetNewRandomPos();
					CSrvWrap.GetObjMgr()^.GetFreePos(vPos,this,vPos,null,true,false,false);
					GoTo(vPos, true, GetMaxSpeed(), true, true);
				endif;
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	proc void SetRandomPos()
		var vec3 vPos = GetNewRandomPos();
		if(!IsInFight())then
			UpdateAggressionPos(vPos);
		endif;
		if(GetTaskDescription()=="Idle"||GetTaskDescription()=="")then
			CSrvWrap.GetObjMgr()^.GetFreePos(vPos,this,vPos,null,true,false,false);
			GoTo(vPos, false, GetDefaultSpeed(), true, true);
		endif;
	endproc;
	
	proc bool TryToEvolve()
		var int iLevel = GetLevel();
		if(iLevel<4)then
			return SetLevel(iLevel+1);
		elseif(iLevel==4 && GetClassName().Find("_lvl4")==-1)then
			CrashRpgLevelup("");
			return true;
		endif;
		return false;
	endproc;
	
	export proc void DoHPRelatedStuff()
		if(!m_bAIBrain)then return; endif;
		if((GetHitpoints()!=0.0f)&&(GetMaxHitpoints()!=0.0f))then
			var real fPercentage=GetHitpoints()/(GetMaxHitpoints()/100.0);
			if(fPercentage<=50.0f)then
				if(!TryToEvolve())then
					if(GetCurTaskName()!="FntnHeal")then
						UseHealWell();
					endif;
				endif;
			endif;
		endif;
	endproc;
	
	export proc void MountBlimp(CObjHndl p_xB)
		if(!m_bAIBrain||!p_xB.IsValid())then return; endif;
		m_xZeppelin=p_xB;
		if(!HasTimer(RPG_BOARD_ZEPPELIN))then
			CreateTimer(RPG_BOARD_ZEPPELIN,CGameTimeSpan.OneSecond()*15.0f,true);
		endif;
		if(m_xCurEnemy.IsValid()||LookForEnemies())then return; endif;
		var ^CCrashBlimp pxB=cast<CCrashBlimp>(p_xB.GetObj());
		if(pxB!=null)then
			BoardTransport(pxB, pxB^.GetPos(), true, "dummy");
		endif;
	endproc;
	
	export proc void SetFountains(CObjList p_xF)
		m_xFountains=p_xF;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(m_bAIBrain)then
			SetAIBrain(false);
		endif;
		m_bUserAction=true;
		if(IsBerserking() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			 && !(p_sMiscParams.Find("/crash_rpg_levelup")!=-1))then return; endif;
		if(IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			 && !(p_sMiscParams.Find("/crash_rpg_levelup")!=-1))then return; endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("/crash_rpg_levelup")!=(-1))then
				if(CheckSpecialActionTimer(p_sMiscParams) && !GetTransportObj().IsValid())then
					CrashRpgLevelup(p_sMiscParams);
				endif;
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	proc void CrashRpgLevelup(string p_sPath)
		if(m_bReplaceDone)then return; endif;
		if(GetLevel()<4)then return; endif;
		var string sNew, sClass=GetClassName();
		var int iLvl=(sClass.Right(1).ToInt())+1;
		if(iLvl<2||iLvl>4)then return; endif;
		sNew=sClass.Left(sClass.GetLength()-1)+iLvl.ToString();
		if(CCrashRPGMgr.GetCrashRPGMgr()!=null)then
			CCrashRPGMgr.GetCrashRPGMgr()^.SetScalpCosts(GetOwner(), iLvl);
		endif;
		var ^CFightingObj pxNew = cast<CFightingObj>(CSrvWrap.GetObjMgr()^.CreateObj(sNew, GetOwner(), GetPos(), GetRotation()));
		if(pxNew==null)then return; endif;
		var vec3 vP = GetCurWalkTarget();
		var CObjHndl xCurEnemy=GetCurEnemy();
		m_bReplaceDone=true;
		pxNew^.SetAIBrain(m_bAIBrain);
		pxNew^.SetAggressionState(GetAggressionState());
		pxNew^.SetCustomLists("fountain",m_xFountains);
		pxNew^.SetCustomHandles("zeppelin",m_xZeppelin);
		if(CCrashRPGMgr.GetCrashRPGMgr()!=null)then
			CCrashRPGMgr.GetCrashRPGMgr()^.ReplaceRPGPassenger(GetHandle(), pxNew^.GetHandle());
		endif;
		var CFourCC xLink="NOPE";
		var CObjHndl xHndl;
		xHndl=pxNew^.AddFX("fx_stina_convert",4.0);
		if(xHndl.IsValid())then
			xHndl.GetObj()^.LinkAction(pxNew^.GetHandle(),xLink);
		endif;
//		xHndl=pxNew^.AddFX("Upgrade_Animal_Fx",4.0);
//		if(xHndl.IsValid())then
//			xHndl.GetObj()^.LinkAction(pxNew^.GetHandle(),xLink);
//		endif;
		var ^CInventory pxInv=GetInventory();
		if(pxInv!=null)then
			var int i, iC=pxInv^.Count();
			var CObjList xList;
			for(i=0) cond(i<iC) iter(++i) do
				if(!pxInv^.GetItem(i).IsValid())then continue; endif;
				xList.Include(pxInv^.GetItem(i));
			endfor;
			iC=xList.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				if(xList[i].IsValid())then
					var ^CGameObj pxItem=xList[i].GetObj();
					var ^CItem pxI=cast<CItem>(pxItem);
					if(pxI!=null)then
						RemoveItemSilent(pxI^.GetHandle());
						pxNew^.AddItemSilent(pxI^.GetHandle());
					endif;
				endif;
			endfor;
		endif;
		if(xCurEnemy.IsValid())then
			pxNew^.MemorizeCurrentFightState(xCurEnemy,true,false);
			pxNew^.ReturnToFight();
		elseif(HasWalkAction() && GetCurTaskName()!="FntnHeal")then
			pxNew^.WalkAction(vP,pxNew^.GetMaxSpeed());
		else
			pxNew^.ExamineEnemies(false);
		endif;
		pxNew^.SetKillerNumbers(GetKillerCount(),GetKillerHistory());
		pxNew^.SetLastEnemy(GetLastEnemy());
		pxNew^.SetLastDamage(GetLastDamage());
//		CSrvWrap.SendGenericEvtToPlayer(GetOwner(), "ScalpsCostsUpdate\t");
		m_bSkipCorpse=true;
		Delete();
	endproc;
	
	export proc bool SetLevelClean(int p_iLevel)
		var int iPrev=GetLevel();
		var bool bR=super.SetLevelClean(p_iLevel);
		var bool bOld=m_bConquer;
//		m_bConquer=GetClassName().Find("_lvl4")!=-1&&GetLevel()>0;
		m_bConquer=GetClassName().Find("_lvl4")!=-1;
		if(bOld!=m_bConquer)then
			ValidateRegions();
		endif;
		var int iNew=GetLevel();
		var string sClass=GetClassName();
		if(iPrev<iNew&&iNew==4&&sClass.Find("_lvl4")==-1)then
			CreateTimer(TIMER_CRASH_EVOLUTION,CGameTimeSpan.OneSecond()*10.0,false);
		endif;
		return bR;
	endproc;
	
	export proc void RemoveItemPL(CObjHndl p_xItem)
		RemoveItemSilent(p_xItem);
	endproc;
	
	export proc void RemoveItemSilent(CObjHndl p_xItem)
		var ^CInventory pxInv=GetInventory();
		if(pxInv==null)then return; endif;
		var ^CItem pxItem=cast<CItem>(p_xItem.GetObj());
		if(pxItem==null)then return; endif;
		pxInv^.RemItem(pxItem^.GetHandle());
		pxItem^.OnDroppedItem(this,false,"Silent!",true);
		pxItem^.TerminateAction();
		AddItemName("");
		return;
	endproc;
	
	export proc void AddItemSilent(CObjHndl p_xItem)
		var ^CInventory pxInv=GetInventory();
		if(pxInv==null)then return; endif;
		var ^CItem pxItem=cast<CItem>(p_xItem.GetObj());
		if(pxItem==null)then return; endif;
		pxInv^.AddItem(pxItem^.GetHandle());
		pxItem^.SetVisible(false);
		pxItem^.OnTakeItem(this,"Silent!",true);
		AddItemName(pxItem^.GetName());
		return;
	endproc;
	
	export proc void AddItem(CObjHndl p_xItem)
		var ^CInventory pxInv=GetInventory();
		if(pxInv==null)then return; endif;
		var ^CItem pxItem=cast<CItem>(p_xItem.GetObj());
		if(pxItem==null)then return; endif;
		pxInv^.AddItem(pxItem^.GetHandle());
		pxItem^.SetVisible(false);
		pxItem^.OnTakeItem(this,"normal",true);
		AddItemName(pxItem^.GetName());
		InvokeGenericSCEvent(38,0.6f);
		return;
	endproc;
	
	export proc void RemoveItem(CObjHndl p_xItem)
		var ^CInventory pxInv=GetInventory();
		if(pxInv==null)then return; endif;
		var ^CItem pxItem=cast<CItem>(p_xItem.GetObj());
		if(pxItem==null)then return; endif;
		pxInv^.RemItem(pxItem^.GetHandle());
		pxItem^.OnDropped(this);
		pxItem^.TerminateAction();
		AddItemName("");
		return;
	endproc;
	
	export proc void ReleaseItem(string p_sItemName, bool p_bQ)
		var ^CInventory pxInv=GetInventory();
		if(pxInv==null)then return; endif;
		var ^CItem pxItem=cast<CItem>(CSrvWrap.GetObjMgr()^.GetObjByName(p_sItemName));
		if(pxItem==null)then return; endif;
		if(p_bQ)then
			StartCustomTask("ReleaseItemFree","");
			return;
		endif;
		pxInv^.RemItem(pxItem^.GetHandle());
		pxItem^.OnDroppedItem(this,true,"normal",false);
		pxItem^.TerminateAction();
		if(HasAnim("put_down"))then
			AnimAction("put_down");
		endif;
		AddItemName("");
		return;
	endproc;
	
	export proc bool SkipCorpse()
		return m_bSkipCorpse;
	endproc;
	
	export proc void FilterEnemyListCustom(ref CObjList p_rxList)
		if(!m_bAIBrain)then return; endif;
		var ^CFightingObj pxE;
		var int i,iC=p_rxList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var CObjHndl xHndl=p_rxList[i];
			if(xHndl.IsValid())then
				pxE=cast<CFightingObj>(xHndl.GetObj());
				if(pxE==null)then
					p_rxList.DeleteEntry(i);i--;iC--;
				elseif(!m_bConquer && (cast<CWall>(pxE)!=null || cast<CGate>(pxE)!=null))then
					p_rxList.DeleteEntry(i);i--;iC--;
				elseif(pxE^.GetSlaveInvincible())then
					p_rxList.DeleteEntry(i);i--;iC--;
				endif;
			endif;
		endfor;
		super.FilterEnemyListCustom(p_rxList);
	endproc;
	
	export proc bool ResistantToThrow()
		return true;
	endproc;
	
	export proc void FountainArrived(CObjHndl p_xObj)
		if(!m_bAIBrain)then return; endif;
		if(!ExamineEnemies(false))then
		elseif(GetReturnEnemy().IsValid())then
			ReturnToFight();
		elseif(!LookForEnemies())then
			SetRandomPos();
		endif;
	endproc;
	
	export proc void UseHealWell()
		if(m_xFountains.NumEntries()<1)then return; endif;
		m_xFountains.SortDistance(GetPos());
		MemorizeCurrentFightState(GetCurEnemy(),true,false);
		FountainHeal(m_xFountains[0].GetObj(),false);
	endproc;
	
	proc bool LookForEnemies()
		var CObjQuery xQ;
		xQ.SetType("CHTR", false);
		xQ.SetType("ANML", true);
		xQ.SetType("VHCL", true);
		xQ.SetType("BLDG", true);
		xQ.SetAttribsNeg("invalid_enemy",true);
		if(!CanShootAir())then
			xQ.SetAttribsNeg("flying_unit",true);
		endif;
		xQ.SetAttribsNeg("not_detectable",true);
		if(m_pxTolerance!=null)then
			xQ.SetRegion(m_pxTolerance^.GetHandle());
		else
			xQ.RegionCircle(GetPos(), 100.0f);
		endif;
		var ^CGameObj pxEnemy=null;
		CSrvWrap.GetDiplomacyMgr().AddMyEnemiesToSearch(GetOwner(), xQ, false);
		var CObjList xList;
		if(!xQ.Execute(xList))then return false; endif;
		FilterEnemyListCustom(xList);
		xList.SortDistance(GetPos());
		var CObjList xEnd;
//		xList.CopySorted(xEnd, GetPos(), 100.0f);
		xEnd=xList;
		if(xEnd.NumEntries()>0)then
			var int i, iC=xEnd.NumEntries();
			for(i=0)cond(i<iC)iter(++i)do
				if(xEnd[i].IsValid())then
					var ^CGameObj pxO=xEnd[i].GetObj();
					if(pxO!=null)then
						pxEnemy=pxO;
						break;
					endif;
				endif;
			endfor;
		endif;
		if(pxEnemy!=null)then
			var vec3 vEPos=pxEnemy^.GetPos();
			Fight(pxEnemy, vEPos, true, false);
			return true;
		endif;
		return false;
	endproc;
	
	export proc void GameOverKill(int p_iSwitch)
		m_bDisconnect=p_iSwitch<1;
		if(p_iSwitch==1)then SetAIBrain(true); return; endif;
//		if(p_iSwitch==1)then m_bAIBrain=true; endif;
//		super.GameOverKill(p_iSwitch);
	endproc;
	
	export proc void DiePerHarakiri()
		return;
	endproc;
	
	export proc void CreateSpirit()
		return;
	endproc;
	
	export proc void AddAutoMoves()
	endproc;
	
	export proc bool ImportantTask(string p_sTask)
		if(p_sTask=="FntnHeal")then return true; endif;
		return false;
	endproc;
	
endclass;

class CCRpgBaseVhcl inherit CVehicle
	
	const int RPG_CHECK_ENEMY					= 40133;
	const int RPG_FOUNTAIN						= 40132;
	const int RPG_RANDOM_POS					= 40131;
	const int RPG_BOARD_ZEPPELIN			= 40130;
	const int RPG_CENTER_REGION				= 40129;
	const int RPG_LEVEL_UP						= 40128;
	const int TIMER_CRASH_EVOLUTION		= 40122;
	const int TIMER_PLAYER_INACTIVITY	= 40174;
	
	var bool m_bAIBrain;
	var bool m_bReplaceDone;
	var bool m_bDisconnect;
	var bool m_bConquer;
	var bool m_bDefend;
	var bool m_bSkipCorpse;
	var bool m_bUserAction;
	var ^CRegion m_pxCenter;
	var ^CRegion m_pxTolerance;
	var CObjList m_xFountains;
	var CObjHndl m_xZeppelin;
	
	export constructor()
		m_bAIBrain = false;
		m_bReplaceDone = false;
		m_bDisconnect = false;
		m_bConquer = false;
		m_bDefend = false;
		m_bSkipCorpse = false;
		m_bUserAction = false;
	endconstructor;
	
	export destructor()
		if(CCrashRPGMgr.GetCrashRPGMgr()!=null)then
			CCrashRPGMgr.GetCrashRPGMgr()^.RemoveRPGPassenger(GetHandle(),m_bDisconnect,GetClassName(),GetLevel(),GetOwner(),GetAIBrain(),GetKillerCount(),GetKillerHistory(),GetAggressionState(),m_xFountains,m_xZeppelin);
			CCrashRPGMgr.GetCrashRPGMgr()^.CheckRPGPassengers();
		endif;
	enddestructor;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
		if(p_pxReaderNode^.GetType()=="RPGU")then
			if(p_pxReaderNode^.GetVersion()>=1)then
				m_xFountains.DoKArc(pxArc^);
				m_xZeppelin.DoKArc(pxArc^);
				(pxArc^) << m_bAIBrain;
				(pxArc^) << m_bReplaceDone;
				(pxArc^) << m_bDisconnect;
				(pxArc^) << m_bConquer;
				(pxArc^) << m_bDefend;
				(pxArc^) << m_bSkipCorpse;
				(pxArc^) << m_bUserAction;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="RPGU";
		var int iVersion=1;
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,iVersion);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xFountains.DoKArc(pxArc^);
		m_xZeppelin.DoKArc(pxArc^);
		(pxArc^) << m_bAIBrain;
		(pxArc^) << m_bReplaceDone;
		(pxArc^) << m_bDisconnect;
		(pxArc^) << m_bConquer;
		(pxArc^) << m_bDefend;
		(pxArc^) << m_bSkipCorpse;
		(pxArc^) << m_bUserAction;
		pxWalk^.Close();
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad && CCrashRPGMgr.GetCrashRPGMgrNC()!=null)then
			m_bDefend=CCrashRPGMgr.GetCrashRPGMgr()^.DefendCenter();
		endif;
		ValidateRegions();
		if(!HasTimer(TIMER_PLAYER_INACTIVITY))then
			CreateTimer(TIMER_PLAYER_INACTIVITY,CGameTimeSpan.OneSecond()*90.0f,true);
		endif;
		if(p_bLoad && m_bAIBrain)then
			AddAutoMoves();
		endif;
	endproc;
	
	export proc void SetCustomHandles(string p_sIdentifier, CObjHndl p_xHndl)
		m_xZeppelin=p_xHndl;
		if(m_bAIBrain && p_sIdentifier=="zeppelin" && p_xHndl.IsValid())then
			MountBlimp(p_xHndl);
		endif;
	endproc;
	
	export proc void SetCustomLists(string p_sIdentifier, CObjList p_xList)
		if(p_sIdentifier=="fountain")then
			SetFountains(p_xList);
		endif;
	endproc;
	
	export proc bool GetAIBrain()
		return m_bAIBrain;
	endproc;
	
	export proc void SetAIBrain(bool p_bOn)
		var bool bOld=m_bAIBrain;
		m_bAIBrain=p_bOn;
		if(!bOld && p_bOn)then
			AddAutoMoves();
			if(!GetCurEnemy().IsValid())then
				if(!LookForEnemies() && ExamineEnemies(false))then
					SetRandomPos();
				endif;
			endif;
		endif;
		if(m_bAIBrain)then
			if(!HasTimer(RPG_LEVEL_UP))then
				CreateTimer(RPG_LEVEL_UP,CGameTimeSpan.OneSecond()*15.0f,true);
			endif;
			if(!HasTimer(RPG_CENTER_REGION))then
				CreateTimer(RPG_CENTER_REGION,CGameTimeSpan.OneSecond()*5.0f,true);
			endif;
			if(!HasTimer(RPG_RANDOM_POS))then
				CreateTimer(RPG_RANDOM_POS,CGameTimeSpan.OneSecond()*10.0f,true);
			endif;
			if(!HasTimer(RPG_FOUNTAIN))then
				CreateTimer(RPG_FOUNTAIN,CGameTimeSpan.OneSecond()*8.0f,true);
			endif;
			if(!HasTimer(RPG_CHECK_ENEMY))then
				CreateTimer(RPG_CHECK_ENEMY,CGameTimeSpan.OneSecond()*7.0f,true);
			endif;
			if(m_xZeppelin.IsValid() && !HasTimer(RPG_BOARD_ZEPPELIN))then
				CreateTimer(RPG_CHECK_ENEMY,CGameTimeSpan.OneSecond()*15.0f,true);
			endif;
		else
			DeleteTimer(RPG_LEVEL_UP);
			DeleteTimer(RPG_CENTER_REGION);
			DeleteTimer(RPG_RANDOM_POS);
			DeleteTimer(RPG_FOUNTAIN);
			DeleteTimer(RPG_CHECK_ENEMY);
			DeleteTimer(RPG_BOARD_ZEPPELIN);
			ClearAutoMoves();
		endif;
	endproc;
	
	proc bool ValidateRegions()
		var ^CRegionMgr pxRegionMgr=^(CSrvWrap.GetRegionMgr());
		if(pxRegionMgr==null)then return false; endif;
		if(m_bDefend||!m_bConquer)then
			m_pxCenter=pxRegionMgr^.GetRegion("center");
			m_pxTolerance=pxRegionMgr^.GetRegion("tolerance");
		else
			m_pxCenter=pxRegionMgr^.GetRegion("island");
			m_pxTolerance=pxRegionMgr^.GetRegion("island");
		endif;
		if(m_pxCenter==null||m_pxTolerance==null)then return false; endif;
		return true;
	endproc;
	
	export proc void AttackSrv(^CGameObj p_pxEnemy)
		if(GetAIBrain()&&p_pxEnemy!=null)then
			if(!IsInToleranceArea(p_pxEnemy^.GetPos()))then return; endif;
		endif;
//		if(GetCurTaskName()=="FntnHeal")then return; endif;
		return super.AttackSrv(p_pxEnemy);
	endproc;
	
	proc void OnDefend(^CGameObj p_pxEnemy)
		if(GetAIBrain()&&p_pxEnemy!=null)then
			if(!IsInToleranceArea(p_pxEnemy^.GetPos()))then return; endif;
		endif;
		if(GetAIBrain() || GetHPPercent()>4)then
			CallNakamas(p_pxEnemy, this);
		endif;
		super.OnDefend(p_pxEnemy);
	endproc;
	
	proc void CallNakamas(^CGameObj p_pxEnemy,^CGameObj p_pxVictim)
		if(p_pxEnemy==null || (!m_bConquer && (cast<CGate>(p_pxEnemy)!=null || cast<CWall>(p_pxEnemy)!=null)))then return; endif;
		if(!IsInToleranceArea(p_pxEnemy^.GetPos()))then return; endif;
		var CObjList xList;
		if(CCrashRPGMgr.GetCrashRPGMgr()!=null)then
			xList = CCrashRPGMgr.GetCrashRPGMgr()^.GetRPGUnits();
		endif;
		var int i,iC=xList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(xList[i]==GetHandle())then continue; endif;
			var ^CFightingObj pxFO=cast<CFightingObj>(xList[i].GetObj());
			if(pxFO!=null && pxFO^.GetAIBrain())then
				if(!pxFO^.IsInFight() && !ImportantTask(pxFO^.GetCurTaskName()))then
					pxFO^.Fight(p_pxEnemy, p_pxEnemy^.GetPos(), true, false);
				endif;
			endif;
		endfor;
	endproc;
	
	export proc vec3 GetNewRandomPos()
		var vec3 vTmp;
		if(m_pxCenter!=null)then
			return m_pxCenter^.GetRandomPointInside();
		endif;
		return vTmp;
	endproc;
	
	export proc bool IsInCenterArea(vec3 p_vPos)
		if(m_pxCenter!=null)then
			return m_pxCenter^.IsInside(p_vPos);
		endif;
		return true;
	endproc;
	
	export proc bool IsInToleranceArea(vec3 p_vPos)
		if(m_pxTolerance!=null)then
			return m_pxTolerance^.IsInside(p_vPos);
		endif;
		return true;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==TIMER_CRASH_EVOLUTION)then
				if(GetTransportObj().IsValid())then
					CreateTimer(TIMER_CRASH_EVOLUTION,CGameTimeSpan.OneSecond()*3.0,false);
				else
//					CrashRpgLevelup("");
				endif;
			elseif(iTimerID==RPG_CENTER_REGION)then
				if(!IsInCenterArea(GetPos()))then
//					var bool bWalkInArea=false;
//					var ^CWalkToPos pxCurWalkTask=cast<CWalkToPos>(GetCurTask());
//					if(pxCurWalkTask!=null)then
//						var vec3 vTargetPos=pxCurWalkTask^.GetTargetPos();
//						if(IsInCenterArea(vTargetPos))then
//							bWalkInArea=true;
//						endif;
//					endif;
//					bWalkInArea=bWalkInArea||(IsInToleranceArea(GetPos())&&IsInFight());
					var bool bWalkInArea=IsInToleranceArea(GetPos())&&IsInFight();
					if(!bWalkInArea)then
						var vec3 vPos = GetNewRandomPos();
						CSrvWrap.GetObjMgr()^.GetFreePos(vPos,this,vPos,null,true,false,false);
						GoTo(vPos, true, GetMaxSpeed(), true, true);
					endif;
				endif;
				return;
			elseif(iTimerID==RPG_RANDOM_POS)then
				SetRandomPos();
			elseif(iTimerID==RPG_LEVEL_UP)then
				TryToEvolve();
			elseif(iTimerID==RPG_FOUNTAIN)then
				if(GetHitpoints()<GetMaxHitpoints() && !IsInFight() && GetCurTaskName()!="FntnHeal")then
					UseHealWell();
				endif;
			elseif(iTimerID==RPG_CHECK_ENEMY)then
				if(!m_xCurEnemy.IsValid() && !ImportantTask(GetCurTaskName()))then
					LookForEnemies();
				endif;
			elseif(iTimerID==RPG_BOARD_ZEPPELIN)then
				var ^CCrashBlimp pxB=cast<CCrashBlimp>(m_xZeppelin.GetObj());
				if(pxB!=null && !LookForEnemies())then
					BoardTransport(pxB, pxB^.GetPos(), true, "dummy");
				endif;
			elseif(iTimerID==TIMER_PLAYER_INACTIVITY)then
				if(!m_bUserAction)then
					if(!m_bAIBrain)then
						SetAIBrain(true);
					endif;
				endif;
				m_bUserAction=false;
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		elseif(p_rxEvtPtr.GetClass()=="DefendBlimp")then
			m_bDefend=p_rxEvtPtr.GetBool(0);
			ValidateRegions();
			if(!IsInCenterArea(GetPos()))then
				var bool bWalkInArea=false;
				var ^CWalkToPos pxCurWalkTask=cast<CWalkToPos>(GetCurTask());
				if(pxCurWalkTask!=null)then
					var vec3 vTargetPos=pxCurWalkTask^.GetTargetPos();
					if(IsInCenterArea(vTargetPos))then
						bWalkInArea=true;
					endif;
				endif;
				bWalkInArea=bWalkInArea||(IsInToleranceArea(GetPos())&&IsInFight());
				if(!bWalkInArea)then
					var vec3 vPos = GetNewRandomPos();
					CSrvWrap.GetObjMgr()^.GetFreePos(vPos,this,vPos,null,true,false,false);
					GoTo(vPos, true, GetMaxSpeed(), true, true);
				endif;
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	proc void SetRandomPos()
		var vec3 vPos = GetNewRandomPos();
		if(!IsInFight())then
			UpdateAggressionPos(vPos);
		endif;
		if(GetTaskDescription()=="Idle"||GetTaskDescription()=="")then
			CSrvWrap.GetObjMgr()^.GetFreePos(vPos,this,vPos,null,true,false,false);
			GoTo(vPos, false, GetDefaultSpeed(), true, true);
		endif;
	endproc;
	
	proc bool TryToEvolve()
		var int iLevel = GetLevel();
		if(iLevel<4)then
			return SetLevel(iLevel+1);
		elseif(iLevel==4 && GetClassName().Find("_lvl4")==-1)then
			CrashRpgLevelup("");
			return true;
		endif;
		return false;
	endproc;
	
	export proc void DoHPRelatedStuff()
		if(!m_bAIBrain)then return; endif;
		if((GetHitpoints()!=0.0f)&&(GetMaxHitpoints()!=0.0f))then
			var real fPercentage=GetHitpoints()/(GetMaxHitpoints()/100.0);
			if(fPercentage<=50.0f)then
				if(!TryToEvolve())then
					if(GetCurTaskName()!="FntnHeal")then
						UseHealWell();
					endif;
				endif;
			endif;
		endif;
	endproc;
	
	export proc void MountBlimp(CObjHndl p_xB)
		if(!m_bAIBrain||!p_xB.IsValid())then return; endif;
		m_xZeppelin=p_xB;
		if(!HasTimer(RPG_BOARD_ZEPPELIN))then
			CreateTimer(RPG_BOARD_ZEPPELIN,CGameTimeSpan.OneSecond()*15.0f,true);
		endif;
		if(m_xCurEnemy.IsValid()||LookForEnemies())then return; endif;
		var ^CCrashBlimp pxB=cast<CCrashBlimp>(p_xB.GetObj());
		if(pxB!=null)then
			BoardTransport(pxB, pxB^.GetPos(), true, "dummy");
		endif;
	endproc;
	
	export proc void SetFountains(CObjList p_xF)
		m_xFountains=p_xF;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(m_bAIBrain)then
			SetAIBrain(false);
		endif;
		m_bUserAction=true;
		if(IsBerserking() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1) && !(p_sMiscParams.Find("/crash_rpg_levelup")!=-1)
			)then return; endif;
		if(IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			 && !(p_sMiscParams.Find("/crash_rpg_levelup")!=-1))then return; endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("/crash_rpg_levelup")!=(-1))then
				if(CheckSpecialActionTimer(p_sMiscParams) && !GetTransportObj().IsValid())then
					CrashRpgLevelup(p_sMiscParams);
				endif;
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	proc void CrashRpgLevelup(string p_sPath)
		if(m_bReplaceDone)then return; endif;
		if(GetLevel()<4)then return; endif;
		var string sNew, sClass=GetClassName();
		var int iLvl=(sClass.Right(1).ToInt())+1;
		if(iLvl<2||iLvl>4)then return; endif;
		sNew=sClass.Left(sClass.GetLength()-1)+iLvl.ToString();
		if(CCrashRPGMgr.GetCrashRPGMgr()!=null)then
			CCrashRPGMgr.GetCrashRPGMgr()^.SetScalpCosts(GetOwner(), iLvl);
		endif;
		var ^CFightingObj pxNew = cast<CFightingObj>(CSrvWrap.GetObjMgr()^.CreateObj(sNew, GetOwner(), GetPos(), GetRotation()));
		if(pxNew==null)then return; endif;
		var vec3 vP = GetCurWalkTarget();
		var CObjHndl xCurEnemy=GetCurEnemy();
		m_bReplaceDone=true;
		pxNew^.SetAIBrain(m_bAIBrain);
		pxNew^.SetAggressionState(GetAggressionState());
		pxNew^.SetCustomLists("fountain",m_xFountains);
		pxNew^.SetCustomHandles("zeppelin",m_xZeppelin);
		if(CCrashRPGMgr.GetCrashRPGMgr()!=null)then
			CCrashRPGMgr.GetCrashRPGMgr()^.ReplaceRPGPassenger(GetHandle(), pxNew^.GetHandle());
		endif;
		var CFourCC xLink="NOPE";
		var CObjHndl xHndl;
		xHndl=pxNew^.AddFX("fx_stina_convert",4.0);
		if(xHndl.IsValid())then
			xHndl.GetObj()^.LinkAction(pxNew^.GetHandle(),xLink);
		endif;
//		xHndl=pxNew^.AddFX("Upgrade_Animal_Fx",4.0);
//		if(xHndl.IsValid())then
//			xHndl.GetObj()^.LinkAction(pxNew^.GetHandle(),xLink);
//		endif;
		var ^CInventory pxInv=GetInventory();
		if(pxInv!=null)then
			var int i, iC=pxInv^.Count();
			var CObjList xList;
			for(i=0) cond(i<iC) iter(++i) do
				if(!pxInv^.GetItem(i).IsValid())then continue; endif;
				xList.Include(pxInv^.GetItem(i));
			endfor;
			iC=xList.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				if(xList[i].IsValid())then
					var ^CGameObj pxItem=xList[i].GetObj();
					var ^CItem pxI=cast<CItem>(pxItem);
					if(pxI!=null)then
						RemoveItemSilent(pxI^.GetHandle());
						pxNew^.AddItemSilent(pxI^.GetHandle());
					endif;
				endif;
			endfor;
		endif;
		if(xCurEnemy.IsValid())then
			pxNew^.MemorizeCurrentFightState(xCurEnemy,true,false);
			pxNew^.ReturnToFight();
		elseif(HasWalkAction() && GetCurTaskName()!="FntnHeal")then
			pxNew^.WalkAction(vP,pxNew^.GetMaxSpeed());
		else
			pxNew^.ExamineEnemies(false);
		endif;
		pxNew^.SetKillerNumbers(GetKillerCount(),GetKillerHistory());
		pxNew^.SetLastEnemy(GetLastEnemy());
		pxNew^.SetLastDamage(GetLastDamage());
//		CSrvWrap.SendGenericEvtToPlayer(GetOwner(), "ScalpsCostsUpdate\t");
		m_bSkipCorpse=true;
		Delete();
	endproc;
	
	export proc bool SetLevelClean(int p_iLevel)
		var int iPrev=GetLevel();
		var bool bR=super.SetLevelClean(p_iLevel);
		var bool bOld=m_bConquer;
//		m_bConquer=GetClassName().Find("_lvl4")!=-1&&GetLevel()>0;
		m_bConquer=GetClassName().Find("_lvl4")!=-1;
		if(bOld!=m_bConquer)then
			ValidateRegions();
		endif;
		var int iNew=GetLevel();
		var string sClass=GetClassName();
		if(iPrev<iNew&&iNew==4&&sClass.Find("_lvl4")==-1)then
			CreateTimer(TIMER_CRASH_EVOLUTION,CGameTimeSpan.OneSecond()*10.0,false);
		endif;
		return bR;
	endproc;
	
	export proc void RemoveItemPL(CObjHndl p_xItem)
		RemoveItemSilent(p_xItem);
	endproc;
	
	export proc void RemoveItemSilent(CObjHndl p_xItem)
		var ^CInventory pxInv=GetInventory();
		if(pxInv==null)then return; endif;
		var ^CItem pxItem=cast<CItem>(p_xItem.GetObj());
		if(pxItem==null)then return; endif;
		pxInv^.RemItem(pxItem^.GetHandle());
		pxItem^.OnDroppedItem(this,false,"Silent!",true);
		pxItem^.TerminateAction();
		AddItemName("");
		return;
	endproc;
	
	export proc void AddItemSilent(CObjHndl p_xItem)
		var ^CInventory pxInv=GetInventory();
		if(pxInv==null)then return; endif;
		var ^CItem pxItem=cast<CItem>(p_xItem.GetObj());
		if(pxItem==null)then return; endif;
		pxInv^.AddItem(pxItem^.GetHandle());
		pxItem^.SetVisible(false);
		pxItem^.OnTakeItem(this,"Silent!",true);
		AddItemName(pxItem^.GetName());
		return;
	endproc;
	
	export proc void AddItem(CObjHndl p_xItem)
		var ^CInventory pxInv=GetInventory();
		if(pxInv==null)then return; endif;
		var ^CItem pxItem=cast<CItem>(p_xItem.GetObj());
		if(pxItem==null)then return; endif;
		pxInv^.AddItem(pxItem^.GetHandle());
		pxItem^.SetVisible(false);
		pxItem^.OnTakeItem(this,"normal",true);
		AddItemName(pxItem^.GetName());
		InvokeGenericSCEvent(38,0.6f);
		return;
	endproc;
	
	export proc void RemoveItem(CObjHndl p_xItem)
		var ^CInventory pxInv=GetInventory();
		if(pxInv==null)then return; endif;
		var ^CItem pxItem=cast<CItem>(p_xItem.GetObj());
		if(pxItem==null)then return; endif;
		pxInv^.RemItem(pxItem^.GetHandle());
		pxItem^.OnDropped(this);
		pxItem^.TerminateAction();
		AddItemName("");
		return;
	endproc;
	
	export proc void ReleaseItem(string p_sItemName, bool p_bQ)
		var ^CInventory pxInv=GetInventory();
		if(pxInv==null)then return; endif;
		var ^CItem pxItem=cast<CItem>(CSrvWrap.GetObjMgr()^.GetObjByName(p_sItemName));
		if(pxItem==null)then return; endif;
		if(p_bQ)then
			StartCustomTask("ReleaseItemFree","");
			return;
		endif;
		pxInv^.RemItem(pxItem^.GetHandle());
		pxItem^.OnDroppedItem(this,true,"normal",false);
		pxItem^.TerminateAction();
		if(HasAnim("put_down"))then
			AnimAction("put_down");
		endif;
		AddItemName("");
		return;
	endproc;
	
	export proc bool SkipCorpse()
		return m_bSkipCorpse;
	endproc;
	
	export proc void FilterEnemyListCustom(ref CObjList p_rxList)
		if(!m_bAIBrain)then return; endif;
		var ^CFightingObj pxE;
		var int i,iC=p_rxList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var CObjHndl xHndl=p_rxList[i];
			if(xHndl.IsValid())then
				pxE=cast<CFightingObj>(xHndl.GetObj());
				if(pxE==null)then
					p_rxList.DeleteEntry(i);i--;iC--;
				elseif(!m_bConquer && (cast<CWall>(pxE)!=null || cast<CGate>(pxE)!=null))then
					p_rxList.DeleteEntry(i);i--;iC--;
				elseif(pxE^.GetSlaveInvincible())then
					p_rxList.DeleteEntry(i);i--;iC--;
				endif;
			endif;
		endfor;
		super.FilterEnemyListCustom(p_rxList);
	endproc;
	
	export proc bool ResistantToThrow()
		return true;
	endproc;
	
	export proc void FountainArrived(CObjHndl p_xObj)
		if(!m_bAIBrain)then return; endif;
		if(!ExamineEnemies(false))then
		elseif(GetReturnEnemy().IsValid())then
			ReturnToFight();
		elseif(!LookForEnemies())then
			SetRandomPos();
		endif;
	endproc;
	
	export proc void UseHealWell()
		if(m_xFountains.NumEntries()<1)then return; endif;
		m_xFountains.SortDistance(GetPos());
		MemorizeCurrentFightState(GetCurEnemy(),true,false);
		FountainHeal(m_xFountains[0].GetObj(),false);
	endproc;
	
	proc bool LookForEnemies()
		var CObjQuery xQ;
		xQ.SetType("CHTR", false);
		xQ.SetType("ANML", true);
		xQ.SetType("VHCL", true);
		xQ.SetType("BLDG", true);
		xQ.SetAttribsNeg("invalid_enemy",true);
		if(!CanShootAir())then
			xQ.SetAttribsNeg("flying_unit",true);
		endif;
		xQ.SetAttribsNeg("not_detectable",true);
		if(m_pxTolerance!=null)then
			xQ.SetRegion(m_pxTolerance^.GetHandle());
		else
			xQ.RegionCircle(GetPos(), 100.0f);
		endif;
		var ^CGameObj pxEnemy=null;
		CSrvWrap.GetDiplomacyMgr().AddMyEnemiesToSearch(GetOwner(), xQ, false);
		var CObjList xList;
		if(!xQ.Execute(xList))then return false; endif;
		FilterEnemyListCustom(xList);
		xList.SortDistance(GetPos());
		var CObjList xEnd;
//		xList.CopySorted(xEnd, GetPos(), 100.0f);
		xEnd=xList;
		if(xEnd.NumEntries()>0)then
			var int i, iC=xEnd.NumEntries();
			for(i=0)cond(i<iC)iter(++i)do
				if(xEnd[i].IsValid())then
					var ^CGameObj pxO=xEnd[i].GetObj();
					if(pxO!=null)then
						pxEnemy=pxO;
						break;
					endif;
				endif;
			endfor;
		endif;
		if(pxEnemy!=null)then
			var vec3 vEPos=pxEnemy^.GetPos();
			Fight(pxEnemy, vEPos, true, false);
			return true;
		endif;
		return false;
	endproc;
	
	export proc void GameOverKill(int p_iSwitch)
		m_bDisconnect=p_iSwitch<1;
		if(p_iSwitch==1)then SetAIBrain(true); return; endif;
//		if(p_iSwitch==1)then m_bAIBrain=true; endif;
//		super.GameOverKill(p_iSwitch);
	endproc;
	
	export proc void DiePerHarakiri()
		return;
	endproc;
	
	export proc void CreateSpirit()
		return;
	endproc;
	
	export proc void AddAutoMoves()
	endproc;
	
	export proc bool ImportantTask(string p_sTask)
		if(p_sTask=="FntnHeal")then return true; endif;
		return false;
	endproc;
	
endclass;

class CCRpgFighter1 inherit CCRpgBaseChtr
	
//	export proc void OnInit(bool p_bLoad)
//		super.OnInit(p_bLoad);
//		var ^CRegionMgr pxRM=^(CSrvWrap.GetRegionMgr());
//		if(pxRM!=null)then
//			var string sName="fighter";
//			var ^CRegion pxRegion=pxRM^.GetRegion(sName);
//			if(pxRegion!=null)then
//				pxRegion^.BindToObj(GetHandle());
//				var real fRad=4.0f;
//				var vec3 vD;
//				vD.SetXYZ(fRad, fRad, 0.0);
//				var int i = pxRegion^.AddSubRegion(010b, GetPos(), vD);
//			endif;
//		endif;
//	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(IsBerserking() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			)then return; endif;
		if(IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			)then return; endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("/fighter_kick")!=(-1))then
				StartFighterKick(p_sMiscParams, p_bQ);
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	proc bool StartFighterKick(string p_sTTPath, bool p_bQ)
		if(GetClassName()!="fighter_lvl1")then return false; endif;
		if(!CheckSpecialActionTimer(p_sTTPath))then return false; endif;
//		MemorizeCurrentFightState(CObjHndl.Invalid(),false,false);
		var ^CCrashKick pxTask=cast<CCrashKick>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"CrashKck"));
		if(pxTask==null)then return false; endif;
		var bool bReturn=pxTask^.Init(GetHandle(), m_xCurEnemy, p_sTTPath);
		if(bReturn)then
			pxTask^.SetUserCommand(true);
			AddTask(pxTask,p_bQ);
		else
			pxTask^.GetFactory()^.FreeState(pxTask);
		endif;
		return bReturn;
	endproc;
	
	export proc void AddAutoMoves()
		var int iIndex;
		iIndex=AddAutoSpecialMove("Actions/World/Moves/CHTR/fighter_kick");
		m_axAutoSpecialMoves[iIndex].m_xOnCheckConditions=CheckFighterKick;
		m_axAutoSpecialMoves[iIndex].m_xOnStartAction=AutoFighterKick;
	endproc;
	
	proc bool CheckFighterKick(string p_sTTPath)
		if(!CheckSpecialActionTimer(p_sTTPath))then return false; endif;
		if(!GetAIBrain())then return false; endif;
		if(!m_xCurEnemy.IsValid())then return false; endif;
		if(GetAngleToR(m_xCurEnemy.GetObj())>0.39)then return false; endif;
		var ^CFightingObj pxEnemy=cast<CFightingObj>(m_xCurEnemy.GetObj());
		if(pxEnemy==null)then return false; endif;
		return IsInCombatRange(pxEnemy,false);
	endproc;
	
	proc void AutoFighterKick(string p_sTTPath)
		if(p_sTTPath.Find("/fighter_kick")!=(-1))then
			StartFighterKick(p_sTTPath, false);
		endif;
	endproc;
	
	export proc bool ImportantTask(string p_sTask)
		if(p_sTask=="CrashKick")then return true; endif;
		return super.ImportantTask(p_sTask);
	endproc;
	
endclass;

class CCrashKick inherit CActionTask

	var CObjHndl		m_xActor;
	var CObjHndl		m_xTarget;
	var string			m_sState;
	
	export constructor()
		SetName("CrashKick");
		SetCivil(false);
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xType="CrKi";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xActor.DoKArc(pxArc^);
		m_xTarget.DoKArc(pxArc^);
		(pxArc^) << m_sState;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="CrKi")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xActor.DoKArc(pxArc^);
			m_xTarget.DoKArc(pxArc^);
			(pxArc^) << m_sState;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool Init(CObjHndl p_xActor, CObjHndl p_xTarget, string p_sPath)
		m_sState="start_anim";
		if(!p_xActor.IsValid() || !p_xTarget.IsValid())then
			m_sState="EndTask";
			return false;
		endif;
		m_xActor = p_xActor;
		m_xTarget = p_xTarget;
		SetSpecialActionPath(p_sPath);
		SetPrepareActionPath(p_xActor, p_sPath, true);
		return true;
	endproc;

	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		if(m_sState=="EndTask")then
			EndTask();
		endif;
	endproc;
	
	proc void USLOnTick(int p_iTime)
		var ^CCharacter pxActor = cast<CCharacter>(m_xActor.GetObj());
		if(pxActor==null)then EndTask(); return; endif;
		if(m_sState == "start_anim")then
			if(!StartSpecialActionTimer(pxActor))then
				EndTask();
				return;
			endif;
			pxActor^.MemorizeCurrentFightState(CObjHndl.Invalid(),false,false);
			pxActor^.AnimAction("res_sm_kick");
			var int iOwner = pxActor^.GetOwner();
			if(iOwner>=0)then
				var ^CFightingObj pxFight = cast<CFightingObj>(m_xTarget.GetObj());
				if(pxFight!=null)then
					pxFight^.TakeDmg(pxActor,false,3.0);
				endif;
				var ^CCharacter pxChar = cast<CCharacter>(pxFight);
				if(pxChar!=null && !pxChar^.GetTransportObj().IsValid())then
					var vec3 vDir = (pxChar^.GetPos() - pxActor^.GetPos());
					vDir.Normalize();
					vDir.SetZ(vDir.GetZ()+0.5);
					vDir.Normalize();
					pxChar^.SetHitReactionTimer(0.7,vDir*(10.0f));
				endif;
			endif;
			m_sState = "finished";
		elseif(m_sState == "finished")then
			m_sState="EndTask";
			pxActor^.ReturnToFight();
		elseif(m_sState == "EndTask")then
			EndTask();
			return;
		endif;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
	endproc;
	
	export proc void EndTask()
		SetPrepareActionPath(m_xActor, GetSpecialActionPath(), false);
		super.EndTask();
	endproc;
	
	export proc bool Break()
		return false;
	endproc;
	
	export proc void Skip()
	endproc;
	
endclass;

class CCRpgFighter2 inherit CCRpgBaseChtr
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(IsBerserking() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			)then return; endif;
		if(IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			)then return; endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("/fighter_roar")!=(-1))then
				StartFighterRoar(p_sMiscParams, p_bQ);
			elseif(p_sMiscParams.Find("/fighter_quake")!=(-1))then
				StartFighterQuake(p_sMiscParams, p_bQ);
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	proc bool StartFighterRoar(string p_sTTPath, bool p_bQ)
		if(GetClassName()!="fighter_lvl2")then return false; endif;
		if(!CheckSpecialActionTimer(p_sTTPath))then return false; endif;
//		MemorizeCurrentFightState(CObjHndl.Invalid(),false,false);
		var ^CCharacterBash pxTask = cast<CCharacterBash>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"ChtrBash"));
		if(pxTask==null)then return false; endif;
		var bool bReturn=pxTask^.Init(GetHandle(),"victory_2", GetCollisionRadius()+7.0, 1.2, 0.1, p_sTTPath, false);
		if(bReturn)then
			pxTask^.SetUserCommand(true);
			AddTask(pxTask,p_bQ);
		else
			pxTask^.GetFactory()^.FreeState(pxTask);
		endif;
		return bReturn;
	endproc;
	
	proc bool StartFighterQuake(string p_sTTPath, bool p_bQ)
		if(GetClassName()!="fighter_lvl2")then return false; endif;
		if(!CheckSpecialActionTimer(p_sTTPath))then return false; endif;
//		MemorizeCurrentFightState(CObjHndl.Invalid(),false,false);
		var ^CCharacterBash pxTask=cast<CCharacterBash>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"ChtrBash"));
		if(pxTask==null)then return false; endif;
		var bool bReturn=pxTask^.Init(GetHandle(),"res_sm_jump", GetCollisionRadius()+5.0, 1.2, 0.1, p_sTTPath, false);
		if(bReturn)then
			pxTask^.SetUserCommand(true);
			AddTask(pxTask,p_bQ);
		else
			pxTask^.GetFactory()^.FreeState(pxTask);
		endif;
		return bReturn;
	endproc;
	
	export proc void AddAutoMoves()
		var int iIndex;
		iIndex=AddAutoSpecialMove("Actions/World/Moves/CHTR/fighter_roar");
		m_axAutoSpecialMoves[iIndex].m_xOnCheckConditions=CheckFighterRoar;
		m_axAutoSpecialMoves[iIndex].m_xOnStartAction=AutoFighterRoar;
		iIndex=AddAutoSpecialMove("Actions/World/Moves/CHTR/fighter_quake");
		m_axAutoSpecialMoves[iIndex].m_xOnCheckConditions=CheckFighterQuake;
		m_axAutoSpecialMoves[iIndex].m_xOnStartAction=AutoFighterQuake;
	endproc;
	
	proc bool CheckFighterRoar(string p_sTTPath)
		if(!CheckSpecialActionTimer(p_sTTPath))then return false; endif;
		if(!GetAIBrain())then return false; endif;
		var ^CObjList pxEnemies=CSrvWrap.GetObjMgr()^.GetOwnerEnemyList(GetOwner());
		if(pxEnemies==null)then return false; endif;
		var CObjList xList; pxEnemies^.CopySorted(xList,GetPos(),GetCollisionRadius()+7.0);
		if(xList.NumEntries()<3)then return false; endif;
		return true;
	endproc;
	
	proc bool CheckFighterQuake(string p_sTTPath)
		if(!CheckSpecialActionTimer(p_sTTPath))then return false; endif;
		if(!GetAIBrain())then return false; endif;
		var ^CObjList pxEnemies=CSrvWrap.GetObjMgr()^.GetOwnerEnemyList(GetOwner());
		if(pxEnemies==null)then return false; endif;
		var CObjList xList; pxEnemies^.CopySorted(xList,GetPos(),GetCollisionRadius()+5.0);
		if(xList.NumEntries()<3)then return false; endif;
		return true;
	endproc;
	
	proc void AutoFighterRoar(string p_sTTPath)
		if(p_sTTPath.Find("/fighter_roar")!=(-1))then
			StartFighterRoar(p_sTTPath, false);
		endif;
	endproc;
	
	proc void AutoFighterQuake(string p_sTTPath)
		if(p_sTTPath.Find("/fighter_quake")!=(-1))then
			StartFighterQuake(p_sTTPath, false);
		endif;
	endproc;
	
	export proc bool ImportantTask(string p_sTask)
		if(p_sTask=="ChtrBash")then return true; endif;
		return super.ImportantTask(p_sTask);
	endproc;
	
endclass;

class CCRpgFighter3 inherit CCRpgBaseChtr
	
	var CObjList m_xMotivateEntries;
	
	export proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		if(!CMirageSrvMgr.SDK())then
			var CFourCC xF="Fgr3";
			var int iVersion=1;
			var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,iVersion);
			var ^CArc pxArc=^(pxN^.GetArc());
			if(iVersion>=1)then
				m_xMotivateEntries.DoKArc(pxArc^);
			endif;
			pxN^.Close();
		endif;
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="Fgr3")then
			var int iVersion=p_pxNode^.GetVersion();
			var ^CArc pxArc=^(p_pxNode^.GetArc());
			if(iVersion>=1)then
				m_xMotivateEntries.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		var ^CGameObj pxObj=AddFX("fx_motivate_own",-1.0).GetObj();
		if(pxObj!=null)then
			var CFourCC xLink;
			pxObj^.LinkAction(GetHandle(),xLink);
		endif;
	endproc;
	
	export proc void ExamineFlags()
		if(IsMarkedForDelete())then return; endif;
		m_xSink.m_xOnObjAdd=OnObjAddMotivate;
		m_xSink.m_xOnObjRem=OnObjRemMotivate;
		if(HasPersonalRegion())then
			DeletePersonalRegion();
		endif;
		var real fRadius=15.0f;
		var vec3 vD; vD.SetXYZ(fRadius, fRadius, 0.0);
		CreatePersonalRegion("Fighter_Motivate_"+GetName()+"_"+Random.GetInt().ToString(), vD, 010b);
		AddRangedBuff("owner_more_damage");
		super.ExamineFlags();
	endproc;
	
	proc bool OnObjAddMotivate(CObjHndl p_xHndl)
		if(p_xHndl==GetHandle())then return false; endif;
		if(m_xRegionObjects.FindEntry(p_xHndl)!=-1)then
			OnObjRemMotivate(p_xHndl);
		endif;
		var ^CFightingObj pxO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxO==null)then return false; endif;
		if(pxO^.GetType()=="BLDG")then return false; endif;
//		if(!CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxO^.GetOwner()))then return false; endif;
		if(!(CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxO^.GetOwner(), GetOwner())&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxO^.GetOwner())))then return false; endif;
		var bitset dwEffect;
		m_xMotivateEntries.AddEntry(p_xHndl);
		dwEffect=MIRAGE_MOTIVATE;
		pxO^.SetMirageFlag(dwEffect, true);
		m_xRegionObjects.AddEntry(p_xHndl);
		return true;
	endproc;
	
	proc bool OnObjRemMotivate(CObjHndl p_xHndl)
		if(m_xRegionObjects.FindEntry(p_xHndl)!=-1)then
			var ^CFightingObj pxO=cast<CFightingObj>(p_xHndl.GetObj());
			if(pxO!=null)then
				var bitset dwEffect;
				if(m_xMotivateEntries.FindEntry(p_xHndl)!=-1)then
					dwEffect=MIRAGE_MOTIVATE;
					pxO^.SetMirageFlag(dwEffect, false);
				endif;
			endif;
		endif;
		m_xRegionObjects.RemEntry(p_xHndl);
		m_xMotivateEntries.RemEntry(p_xHndl);
		return true;
	endproc;
	
	export proc void Delete()
		if(HasPersonalRegion())then
			while(m_xRegionObjects.NumEntries()>0)do
				OnObjRemMotivate(m_xRegionObjects[0]);
			endwhile;
		endif;
		super.Delete();
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(IsBerserking() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			)then return; endif;
		if(IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			)then return; endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("/fighter_whirlwind")!=(-1))then
				if(CheckSpecialActionTimer(p_sMiscParams) && !GetTransportObj().IsValid())then
					StartWhirlWind(p_sMiscParams, p_bQ);
				endif;
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	proc bool StartWhirlWind(string p_sPath, bool p_bQ)
		if(GetClassName()!="fighter_lvl3")then return false; endif;
//		MemorizeCurrentFightState(CObjHndl.Invalid(),false,false);
		var ^CFighterSpecialMove pxTask=cast<CFighterSpecialMove>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"FighterSM"));
		if(pxTask==null)then return false; endif;
		var bool bReturn=false;
		if(pxTask!=null)then
			bReturn=pxTask^.Init(GetHandle(),"NS2010_amazon_kick1",p_sPath);
			if(bReturn)then
				pxTask^.SetUserCommand(true);
				AddTask(pxTask,p_bQ);
			else
				pxTask^.GetFactory()^.FreeState(pxTask);
			endif;
		endif;
		return bReturn;
	endproc;
	
	proc bool CheckWhirlWind(string p_sTTPath)
		if(!CheckSpecialActionTimer(p_sTTPath))then return false; endif;
		if(!GetAIBrain())then return false; endif;
		var ^CObjList pxEnemies=CSrvWrap.GetObjMgr()^.GetOwnerEnemyList(GetOwner());
		if(pxEnemies==null)then return false; endif;
		var CObjList xList; pxEnemies^.CopySorted(xList,GetPos(),7.0);
		if(xList.NumEntries()<2)then return false; endif;
		return true;
	endproc;
	
	export proc void AddAutoMoves()
		var int iIndex;
		iIndex=AddAutoSpecialMove("Actions/World/Moves/CHTR/fighter_whirlwind");
		m_axAutoSpecialMoves[iIndex].m_xOnCheckConditions=CheckWhirlWind;
		m_axAutoSpecialMoves[iIndex].m_xOnStartAction=AutoWhirlWind;
	endproc;
	
	proc void AutoWhirlWind(string p_sPath)
		StartWhirlWind(p_sPath,false);
	endproc;
	
	export proc bool ImportantTask(string p_sTask)
		if(p_sTask=="FighterSM")then return true; endif;
		return super.ImportantTask(p_sTask);
	endproc;
	
endclass;

class CFighterSpecialMove inherit CSpecialActionTask
	
	var CObjHndl		m_xActor;
	var string			m_sState;
	var string			m_sAnim;
	
	export constructor()
		SetName("FighterSM");
		SetCivil(false);
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xType="FiSM";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xActor.DoKArc(pxArc^);
		(pxArc^) << m_sState;
		(pxArc^) << m_sAnim;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="FiSM")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xActor.DoKArc(pxArc^);
			(pxArc^) << m_sState;
			(pxArc^) << m_sAnim;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool Init(CObjHndl p_xActor, string p_sAnim, string p_sPath)
		m_sState="calc_dmg";
		if(!p_xActor.IsValid())then
			m_sState="EndTask";
			return false;
		elseif(p_xActor.GetObj()^.GetClassName()!="fighter_lvl3")then
			m_sState="EndTask";
			return false;
		endif;
		SetSpecialActionPath(p_sPath);
		m_xActor = p_xActor;
		m_sAnim = p_sAnim;
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		var ^CFightingObj pxFightingObj=cast<CFightingObj>(m_xActor.GetObj());
		if(pxFightingObj==null || !pxFightingObj^.CheckSpecialActionTimer(GetSpecialActionPath()))then
			EndTask();
			return;
		endif;
		if(m_sState=="EndTask")then
			EndTask();
		endif;
	endproc;
	
	proc void USLOnTick(int p_iTime)
		var ^CCharacter pxActor = cast<CCharacter>(m_xActor.GetObj());
		if(pxActor==null)then EndTask(); return; endif;
		if(m_sState == "calc_dmg")then
			//calc
			if(!StartSpecialActionTimer(pxActor))then EndTask();return;endif;
			pxActor^.MemorizeCurrentFightState(CObjHndl.Invalid(),false,false);
			SetUnStoppable(true);
			var int iOwner = pxActor^.GetOwner();
			if(iOwner>=0)then
				//Badgun Tuning
				var real fRange = 7.0; // must NOT be 0.0; 
				var real fDmgPercentage = 50.0;
				var real fLevel = (pxActor^.GetLevel()+1).ToReal();
				var real fMinDmg = 100.0*fLevel;
				var real fMaxDmg = 1000.0*fLevel;
				var CObjList xList;
				var ^CObjList pxEnemies=CSrvWrap.GetObjMgr()^.GetOwnerEnemyList(iOwner);
				if(pxEnemies==null) then return; endif;
				pxEnemies^.CopySorted(xList, pxActor^.GetPos(), fRange);
				var int i, iC = xList.NumEntries();
				for(i=0)cond(i<iC)iter(i++)do
					var ^CFightingObj pxFight = cast<CFightingObj>(xList[i].GetObj());
					if(pxFight!=null && !pxFight^.GetTransportObj().IsValid())then
						var real fDamageDone = Math.Clamp(pxFight^.GetHitpoints()*fDmgPercentage*0.01, fMinDmg, fMaxDmg);
						pxFight^.TakeDirectMeleeDmg(fDamageDone,pxActor^.GetOwner(),m_xActor);
						var ^CCharacter pxChar = cast<CCharacter>(pxFight);
						if(pxChar!=null && !pxChar^.GetTransportObj().IsValid())then
							var real fDiffTime=((Random.GetInt()%150).ToReal())/100.0f;
							var real fDiffDistance=(Random.GetInt()%40).ToReal()/10.0;
							var vec3 vDir = (pxChar^.GetPos() - pxActor^.GetPos());
							vDir.Normalize();
							vDir.SetZ(vDir.GetZ()+0.5);
							vDir.Normalize();
							pxChar^.SetHitReactionTimer(0.1+fDiffTime,vDir*(1.0f+fDiffDistance));
						endif;
					endif;
				endfor;
			endif;
			pxActor^.AnimAction(m_sAnim);
			m_sState = "finished";
		elseif(m_sState=="finished")then
			SetUnStoppable(false);
			m_sState = "finished";
			pxActor^.ReturnToFight();
		elseif(m_sState=="EndTask")then
			EndTask();
			return;
		endif;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
	endproc;
	
	export proc bool Break()
		if(GetUnStoppable())then
			return false;
		endif;
		return false;
	endproc;
	
	export proc void Skip()
	endproc;
	
	export proc void EndTask()
		UpdateAggressionPos(m_xActor);
		super.EndTask();
	endproc;
	
endclass;

class CCRpgFighter4 inherit CCRpgBaseChtr

	const int FIGHTER_DOPING = 40148;
	
	/*
	var CObjList m_xMotivateEntries;
	
	export proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		if(!CMirageSrvMgr.SDK())then
			var CFourCC xF="Fgr4";
			var int iVersion=1;
			var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,iVersion);
			var ^CArc pxArc=^(pxN^.GetArc());
			if(iVersion>=1)then
				m_xMotivateEntries.DoKArc(pxArc^);
			endif;
			pxN^.Close();
		endif;
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="Fgr4")then
			var int iVersion=p_pxNode^.GetVersion();
			var ^CArc pxArc=^(p_pxNode^.GetArc());
			if(iVersion>=1)then
				m_xMotivateEntries.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		var ^CGameObj pxObj=AddFX("fx_motivate_own",-1.0).GetObj();
		if(pxObj!=null)then
			var CFourCC xLink;
			pxObj^.LinkAction(GetHandle(),xLink);
		endif;
	endproc;
	
	export proc void ExamineFlags()
		if(IsMarkedForDelete())then return; endif;
		m_xSink.m_xOnObjAdd=OnObjAddMotivate;
		m_xSink.m_xOnObjRem=OnObjRemMotivate;
		if(HasPersonalRegion())then
			DeletePersonalRegion();
		endif;
		var real fRadius=20.0f;
		var vec3 vD; vD.SetXYZ(fRadius, fRadius, 0.0);
		CreatePersonalRegion("Fighter_Motivate_"+GetName()+"_"+Random.GetInt().ToString(), vD, 010b);
		AddRangedBuff("owner_more_damage");
		super.ExamineFlags();
	endproc;
	
	proc bool OnObjAddMotivate(CObjHndl p_xHndl)
		if(p_xHndl==GetHandle())then return false; endif;
		if(m_xRegionObjects.FindEntry(p_xHndl)!=-1)then
			OnObjRemMotivate(p_xHndl);
		endif;
		var ^CFightingObj pxO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxO==null)then return false; endif;
		if(pxO^.GetType()=="BLDG")then return false; endif;
//		if(!CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxO^.GetOwner()))then return false; endif;
		if(!(CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxO^.GetOwner(), GetOwner())&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxO^.GetOwner())))then return false; endif;
		var bitset dwEffect;
		m_xMotivateEntries.AddEntry(p_xHndl);
		dwEffect=MIRAGE_MOTIVATE_2;
		pxO^.SetMirageFlag(dwEffect, true);
		m_xRegionObjects.AddEntry(p_xHndl);
		return true;
	endproc;
	
	proc bool OnObjRemMotivate(CObjHndl p_xHndl)
		if(m_xRegionObjects.FindEntry(p_xHndl)!=-1)then
			var ^CFightingObj pxO=cast<CFightingObj>(p_xHndl.GetObj());
			if(pxO!=null)then
				var bitset dwEffect;
				if(m_xMotivateEntries.FindEntry(p_xHndl)!=-1)then
					dwEffect=MIRAGE_MOTIVATE_2;
					pxO^.SetMirageFlag(dwEffect, false);
				endif;
			endif;
		endif;
		m_xRegionObjects.RemEntry(p_xHndl);
		m_xMotivateEntries.RemEntry(p_xHndl);
		return true;
	endproc;
	
	export proc void Delete()
		if(HasPersonalRegion())then
			while(m_xRegionObjects.NumEntries()>0)do
				OnObjRemMotivate(m_xRegionObjects[0]);
			endwhile;
		endif;
		super.Delete();
	endproc;
	*/
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(IsBerserking() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			)then return; endif;
		if(IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			)then return; endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("/fighter_shotgun")!=(-1))then
				if(CheckSpecialActionTimer(p_sMiscParams) && !GetTransportObj().IsValid())then
					StartShotgun(p_pxObject,p_vPos,p_sMiscParams,p_bQ);
				endif;
			elseif(p_sMiscParams.Find("/fighter_doping")!=-1)then
				if(CheckSpecialActionTimer(p_sMiscParams))then
					StartFighterDopingFull(p_sMiscParams, p_bQ);
				endif;
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	export proc void StartFighterDoping(string p_sMiscParams)
		return StartFighterDopingFull(p_sMiscParams, false);
	endproc;
	
	export proc void StartFighterDopingFull(string p_sMiscParams, bool p_bQ)
		if(p_bQ)then
			StartCustomTask("StartFighterDoping","");
			return;
		endif;
		DeleteTimer(FIGHTER_DOPING);
		CreateTimer(FIGHTER_DOPING, CGameTimeSpan.OneSecond()*10.0, false);
		var CObjHndl xHndl=AddFX("fx_saltasaurus_doping", -1.0);
		if(xHndl.IsValid())then
			var CFourCC xLink;
			xHndl.GetObj()^.LinkAction(GetHandle(),xLink);
		endif;
		AddSpecialActionTimer(p_sMiscParams);
	endproc;
	
	export proc void StopFighterDoping()
		RemoveFX("fx_saltasaurus_doping");
		DeleteTimer(FIGHTER_DOPING);
	endproc;
	
	export proc void Damage(real p_fDamage)
		if(HasTimer(FIGHTER_DOPING))then
			return;
		endif;
		super.Damage(p_fDamage);
	endproc;
	
	export proc void PoisonDamage(real p_fDamage, CObjHndl p_xEnemy, int p_iEnemy)
		if(HasTimer(FIGHTER_DOPING))then
			return;
		endif;
		return super.PoisonDamage(p_fDamage, p_xEnemy, p_iEnemy);
	endproc;
	
	export proc void BurnDamage(real p_fDamage, CObjHndl p_xEnemy, int p_iEnemy)
		if(HasTimer(FIGHTER_DOPING))then
			return;
		endif;
		return super.BurnDamage(p_fDamage, p_xEnemy, p_iEnemy);
	endproc;
	
	export proc void ChainDamage(real p_fDamage, int p_iLast, CObjHndl p_xLast)
		if(HasTimer(FIGHTER_DOPING))then
			return;
		endif;
		return super.ChainDamage(p_fDamage, p_iLast, p_xLast);
	endproc;
	
	export proc void WoundDamage(real p_fDamage, CObjHndl p_xLE, int p_iLE)
		if(HasTimer(FIGHTER_DOPING))then
			return;
		endif;
		return super.BurnDamage(p_fDamage, p_xLE, p_iLE);
	endproc;
	
	proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==FIGHTER_DOPING)then
				StopFighterDoping();
				return;
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	proc bool StartShotgun(^CGameObj p_pxTarget, vec3 p_vPos, string p_sTTPath, bool p_bQ)
		if(GetClassName()!="fighter_lvl4")then return false; endif;
		if(!CheckSpecialActionTimer(p_sTTPath))then return false; endif;
		var ^CCrashShotgun pxTask= cast<CCrashShotgun>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(), "CrashShtgn"));
		if(pxTask==null)then return false; endif;
		var CObjHndl xTarget;
		if(p_pxTarget!=null)then
			xTarget=p_pxTarget^.GetHandle();
//			MemorizeCurrentFightState(p_pxTarget^.GetHandle(),true,false);
		endif;
		var bool bReturn=pxTask^.Init(GetHandle(),xTarget,p_vPos,p_sTTPath);
		if(bReturn)then
			pxTask^.SetUserCommand(true);
			AddTask(pxTask,p_bQ);
		else
			pxTask^.GetFactory()^.FreeState(pxTask);
		endif;
		return(bReturn);
	endproc;
	
	proc bool CheckShotgun(string p_sTTPath)
		if(!CheckSpecialActionTimer(p_sTTPath))then return false; endif;
		if(!GetAIBrain())then return false; endif;
		var bool bReturn=false;
		var ^CObjList pxEnemies=CSrvWrap.GetObjMgr()^.GetOwnerEnemyList(GetOwner());
		if(pxEnemies==null)then return false; endif;
		var CObjList xList; pxEnemies^.CopySorted(xList,GetPos(),7.0);
		if(xList.NumEntries()<3)then bReturn=true; endif;
		if(!bReturn)then
			if(!m_xCurEnemy.IsValid())then return false; endif;
			if(m_xCurEnemy.GetObj()^.GetOwner()==GetOwner())then return false; endif;
			var ^CFightingObj pxObj=cast<CFightingObj>(m_xCurEnemy.GetObj());
			var bool bInvalid; var CObjHndl xInvalid;
			if(pxObj==null||pxObj^.GetHitpoints()<1500.0f)then return false; endif;
		endif;
		return bReturn;
	endproc;
	
	proc bool CheckDoping(string p_sTTPath)
		if(!CheckSpecialActionTimer(p_sTTPath))then return false; endif;
		if(!GetAIBrain())then return false; endif;
		var bool bReturn=false;
		if(!m_xCurEnemy.IsValid())then return false; endif;
		if((GetHitpoints()!=0.0f)&&(GetMaxHitpoints()!=0.0f))then
			var real fPercentage=GetHitpoints()/(GetMaxHitpoints()/100.0);
			if(fPercentage<=60.0f)then
				return true;
			endif;
		endif;
		return false;
	endproc;
	
	export proc void AddAutoMoves()
		var int iIndex;
		iIndex=AddAutoSpecialMove("Actions/World/Moves/CHTR/fighter_shotgun");
		m_axAutoSpecialMoves[iIndex].m_xOnCheckConditions=CheckShotgun;
		m_axAutoSpecialMoves[iIndex].m_xOnStartAction=AutoShotgun;
		iIndex=AddAutoSpecialMove("Actions/World/Moves/CHTR/fighter_doping");
		m_axAutoSpecialMoves[iIndex].m_xOnCheckConditions=CheckDoping;
		m_axAutoSpecialMoves[iIndex].m_xOnStartAction=StartFighterDoping;
	endproc;
	
	proc void AutoShotgun(string p_sPath)
		if(m_xCurEnemy.IsValid())then
			StartShotgun(m_xCurEnemy.GetObj(),m_xCurEnemy.GetObj()^.GetPos(),p_sPath,false);
		endif;
	endproc;
	
	export proc bool ImportantTask(string p_sTask)
		if(p_sTask=="FighterShtgn")then return true; endif;
		return super.ImportantTask(p_sTask);
	endproc;
	
endclass;

class CCrashShotgun inherit CSpecialActionTask

	const real m_fDoesCollateralDamage=1.0f;
	const real m_fDamageOnMainTarget=75.0f;
	const real m_fMinimalDamageOnMainTarget=200.0f; 
	const real m_fMaximalDamageOnMainTarget=2000.0f;

	const real m_fDamageOnCollateralTargets=50.0f;
	const real m_fMinimalDamageOnCollateralTargets=100.0f;
	const real m_fMaximalDamageOnCollateralTargets=1000.0f;

	const real m_fRange=15.0f;
	const real m_fCollateralDamageRange=10.0f;

	var CObjHndl m_xFighter;
	var CObjHndl m_xEnemy;
	var string m_sState;
	var bool m_bGroundShot;
	var vec3 m_vGroundShotPos;
	var CObjList m_xCollateralDamage;

	var CFourCC m_xFCCRightHandLink;
	var CFourCC m_xFCCShieldLink;
	var CFourCC m_xFCCLeftHandLink;
	var CFourCC m_xFCCHeadLink;
	var CFourCC m_xFCCBackLink;

	export constructor()
		SetName("FighterShtgn");
		SetCivil(false);
		m_xFCCShieldLink="Shld";
		m_xFCCRightHandLink="HndR";
		m_xFCCLeftHandLink="HndL";
		m_xFCCHeadLink="Head";
		m_xFCCBackLink="Back";
	endconstructor;

	export destructor()
	enddestructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xType="CRSG";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xFighter.DoKArc(pxArc^);
		m_xEnemy.DoKArc(pxArc^);
		(pxArc^) << m_sState;
		(pxArc^) << m_bGroundShot;
		(pxArc^) << m_vGroundShotPos;
		m_xCollateralDamage.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="CRSG")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion = p_pxReaderNode^.GetVersion();
			m_xFighter.DoKArc(pxArc^);
			m_xEnemy.DoKArc(pxArc^);
			(pxArc^) << m_sState;
			(pxArc^) << m_bGroundShot;
			(pxArc^) << m_vGroundShotPos;
			m_xCollateralDamage.DoKArc(pxArc^);
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;

	export proc bool Init(CObjHndl p_xFighter, CObjHndl p_xEnemy, vec3 p_vPos, string p_sTTPath)
		SetSpecialActionPath(p_sTTPath);
		SetName("FighterShtgn");
		m_xFighter=p_xFighter;
		m_xEnemy=p_xEnemy;
		m_vGroundShotPos=p_vPos;
		if(!m_xFighter.IsValid())then return(false);endif;
		if(!m_xEnemy.IsValid())then
			m_bGroundShot=true;
		else
			m_bGroundShot=false;
		endif;
		if(m_xFighter.GetObj()==null)then return(false);endif;
		m_xFighter.GetObj()^.TerminateAction();
		return(true);
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		var ^CFightingObj pxFightingObj=cast<CFightingObj>(m_xFighter.GetObj());
		if(pxFightingObj==null || !pxFightingObj^.CheckSpecialActionTimer(GetSpecialActionPath()))then
			EndTask();
			return;
		endif;
		pxFightingObj^.HideWeapons();
		pxFightingObj^.SetLinkGFX(m_xFCCRightHandLink,"Cole_Shotgun");
	endproc;
	
	proc void USLOnTick(int p_iTime)
		if(!m_xFighter.IsValid())then EndTask();return;endif;
		var ^CFightingObj pxFighter = cast<CFightingObj>(m_xFighter.GetObj());
		var ^CFightingObj pxEnemy;
		if(pxFighter==null)then
			EndTask();
			return;
		endif;
		if(!m_bGroundShot)then
			if(!m_xEnemy.IsValid())then EndTask();return;endif;
			if(m_xFighter==m_xEnemy)then EndTask();return;endif;
			pxEnemy = cast<CFightingObj>(m_xEnemy.GetObj());
			if(pxEnemy==null)then EndTask();return;endif;
			//Update target, in case, the enemy gets on a mount.
			if(pxEnemy^.GetType()=="CHTR")then
				var ^CCharacter pxChar = cast<CCharacter>(m_xEnemy.GetObj());
				if(pxChar!=null)then
					if(pxChar^.GetTransportObj().IsValid())then
						m_xEnemy=pxChar^.GetTransportObj();
					endif;
				endif;
			endif;
			pxFighter^.MemorizeCurrentFightState(m_xEnemy,true,false);
			if(m_sState!="finished" && m_sState!="reaction")then
				if(IsInCombatRange())then
					if(!pxEnemy^.IsDead())then
						var vec3 vTarget=GetLookAtRot(pxEnemy^.GetPos()-pxFighter^.GetPos());
						pxFighter^.SetRotation(vTarget);
						m_sState="fire";
					endif;
				else
					if(pxFighter^.GetMovableInFight() && !pxFighter^.GetOnWall())then
						pxFighter^.AdvanceAction(pxEnemy^.GetHandle(),m_fRange,pxFighter^.GetDefaultSpeed());
					else
						EndTask();
						return;
					endif;
				endif;
			endif;
		else
			if(m_sState!="finished" && m_sState!="reaction")then
				if(IsInCombatRange())then
					var vec3 vTarget=GetLookAtRot(m_vGroundShotPos-pxFighter^.GetPos());
					pxFighter^.SetRotation(vTarget);
					m_sState="fire";
				else
					if(pxFighter^.GetMovableInFight() && !pxFighter^.GetOnWall())then
						var vec3 vTarget=GetAdoptedDest(pxFighter^.GetPos(),m_vGroundShotPos,m_fRange);
						pxFighter^.WalkAction(vTarget,pxFighter^.GetDefaultSpeed());
					else
						EndTask();
						return;
					endif;
				endif;
			endif;
		endif;
		if(m_sState=="fire")then
			if(m_fDoesCollateralDamage!=0.0f)then
				GetCollateralDamage();
			endif;
			pxFighter^.UpdateAggressionPos(pxFighter^.GetPos());
			if(!StartSpecialActionTimer(pxFighter))then EndTask();return;endif;
			SetUnStoppable(true);
			var vec3 vPT;
			var vec3 vPE;
			var vec3 vDir;
			pxFighter^.AnimAction("shotgun");
			if(!m_bGroundShot)then
				vPT=pxEnemy^.GetPos();
				vPE=pxFighter^.GetPos();
				vDir=vPT-vPE;
				if(pxEnemy^.GetType()=="CHTR" && !pxEnemy^.GetTransportObj().IsValid() && pxFighter^.m_iSizeClass>pxEnemy^.m_iSizeClass)then
					if(vDir.Abs()>0.0001f) then
						vDir.Normalize();
						vDir.SetZ(vDir.GetZ()+0.5);
						vDir.Normalize();
					endif;
					pxEnemy^.SetHitReactionTimer(1.95f,vDir*9.0f);
				endif;
				var int i;
				if(m_fDoesCollateralDamage!=0.0f)then
					for(i=0)cond(i<m_xCollateralDamage.NumEntries())iter(i++)do
						var ^CFightingObj pxCollateralDamageObj = cast<CFightingObj>(m_xCollateralDamage[i].GetObj());
						if(pxCollateralDamageObj==null)then continue; endif;
						if(pxCollateralDamageObj^.GetType()=="CHTR" && !pxCollateralDamageObj^.GetTransportObj().IsValid() && pxFighter^.m_iSizeClass>pxCollateralDamageObj^.m_iSizeClass)then
							Random.Seed();
							var vec3 vVariation={0.0,0.0,0.0};
							vVariation.SetX((Random.GetInt()%150).ToReal()/100.0f);
							vVariation.SetY((Random.GetInt()%150).ToReal()/100.0f);
							vPT=pxCollateralDamageObj^.GetPos()+vVariation;
							vPE=pxFighter^.GetPos();
							vDir=vPT-vPE;
							if(vDir.Abs()>0.0001f) then
								vDir.Normalize();
								vDir.SetZ(vDir.GetZ()+0.5);
								vDir.Normalize();
							endif;
							var real fDiffTime=((Random.GetInt()%15).ToReal())/100.0f;
							var real fDiffDistance=(Random.GetInt()%4).ToReal();
							pxCollateralDamageObj^.SetHitReactionTimer(1.95f+fDiffTime,vDir*(6.0f+fDiffDistance));
						endif;
					endfor;
				endif;
			else
				var int i;
				if(m_fDoesCollateralDamage!=0.0f)then
					for(i=0)cond(i<m_xCollateralDamage.NumEntries())iter(i++)do
						var ^CFightingObj pxCollateralDamageObj = cast<CFightingObj>(m_xCollateralDamage[i].GetObj());
						if(pxCollateralDamageObj==null)then continue; endif;
						if(pxCollateralDamageObj^.GetType()!="CHTR")then continue; endif;
						if(pxCollateralDamageObj^.GetTransportObj().IsValid())then continue; endif;
						if(pxFighter^.m_iSizeClass<pxCollateralDamageObj^.m_iSizeClass)then continue; endif;
						var vec3 vVariation={0.0,0.0,0.0};
						vVariation.SetX((Random.GetInt()%150).ToReal()/100.0f);
						vVariation.SetY((Random.GetInt()%150).ToReal()/100.0f);
						vPT=pxCollateralDamageObj^.GetPos()+vVariation;
						vPE=pxFighter^.GetPos();
						vDir=vPT-vPE;
						if(vDir.Abs()>0.0001f) then
							vDir.Normalize();
							vDir.SetZ(vDir.GetZ()+0.5);
							vDir.Normalize();
						endif;
						var real fDiffTime=((Random.GetInt()%15).ToReal())/100.0f;
						var real fDiffDistance=(Random.GetInt()%4).ToReal();
						pxCollateralDamageObj^.SetHitReactionTimer(1.95f+fDiffTime,vDir*(6.0f+fDiffDistance));
					endfor;
				endif;
			endif;
			m_sState="reaction";
		elseif(m_sState=="reaction")then
			var real fDamage, fLevel=(pxFighter^.GetLevel()+1).ToReal();
			if(!m_bGroundShot)then
				if(pxEnemy^.GetType()=="BLDG" || pxEnemy^.GetType()=="NEST")then
					fDamage=(pxEnemy^.GetHitpoints()/100.0)*10.0f*fLevel;
				else
					fDamage=(pxEnemy^.GetHitpoints()/100.0)*m_fDamageOnMainTarget;
				endif;
				fDamage=Math.Clamp(fDamage,m_fMinimalDamageOnMainTarget*fLevel,m_fMaximalDamageOnMainTarget*fLevel);
				pxEnemy^.TakeDirectDmg(fDamage,pxFighter^.GetOwner(),m_xFighter);
			endif;
			var int i;
			if(m_fDoesCollateralDamage!=0.0f)then
				for(i=0)cond(i<m_xCollateralDamage.NumEntries())iter(i++)do
					var ^CFightingObj pxCollateralDamageObj = cast<CFightingObj>(m_xCollateralDamage[i].GetObj());
					if(pxCollateralDamageObj==null)then continue; endif;
					if(pxCollateralDamageObj^.GetType()=="BLDG" || pxCollateralDamageObj^.GetType()=="NEST")then
						fDamage=(pxCollateralDamageObj^.GetHitpoints()/100.0)*10.0f*fLevel;
					else
						fDamage=(pxCollateralDamageObj^.GetHitpoints()/100.0)*m_fDamageOnCollateralTargets;
					endif;
					fDamage=Math.Clamp(fDamage,m_fMinimalDamageOnCollateralTargets*fLevel,m_fMaximalDamageOnCollateralTargets*fLevel);
					pxCollateralDamageObj^.TakeDirectDmg(fDamage,pxFighter^.GetOwner(),m_xFighter);
				endfor;
			endif;
			m_sState="finished";
		elseif(m_sState=="finished")then
			SetUnStoppable(false);
			if(!m_bGroundShot)then
				pxEnemy^.AttackSrv(pxFighter);
			endif;
			pxFighter^.ShowWeapons();
			m_sState="finished";
			pxFighter^.ReturnToFight();
		elseif(m_sState=="EndTask")then
			EndTask();
			return;
		endif;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
		var ^CFightingObj pxFighter = cast<CFightingObj>(m_xFighter.GetObj());
		if(pxFighter!=null)then
			pxFighter^.ShowWeapons();
		endif;
	endproc;
	
	export proc bool Break()
		if(GetUnStoppable())then
			return false;
		endif;
		if(m_xFighter.IsValid())then
			m_xFighter.GetObj()^.TerminateAction();
		endif;
		return true;
	endproc;
	
	export proc bool IsInCombatRange()
		var ^CFightingObj pxFighter = cast<CFightingObj>(m_xFighter.GetObj());
		if(!m_bGroundShot)then
			var ^CFightingObj pxEnemy = cast<CFightingObj>(m_xEnemy.GetObj());
			var real fFightDistance = pxEnemy^.GetRadius()+pxFighter^.GetRadius();
			var real fDistVariance = pxEnemy^.GetRadius();
			return((pxFighter^.GetPos()-pxEnemy^.GetPos()).Abs()<=fFightDistance+fDistVariance+m_fRange);
		else
			return((pxFighter^.GetPos()-m_vGroundShotPos).Abs()<=5.0f+m_fRange);
		endif;
	endproc;
	
	export proc void UpdateEnemy(CObjHndl p_xEnemy)
		if(p_xEnemy.IsValid())then
			m_xEnemy=p_xEnemy;
		endif;
	endproc;
	
	proc bool GetCollateralDamage()
		var CObjQuery xCollateralQuery;
		xCollateralQuery.SetType("CHTR");
		xCollateralQuery.SetType("ANML",true);
		xCollateralQuery.SetType("VHCL",true);
		xCollateralQuery.SetType("NEST",true);
		xCollateralQuery.SetType("BLDG",true);
		xCollateralQuery.SetType("FGHT",true);
		if(m_bGroundShot)then
			xCollateralQuery.RegionCircle(m_vGroundShotPos,m_fCollateralDamageRange);
		else
			xCollateralQuery.RegionCircle(m_xEnemy.GetObj()^.GetPos(),m_fCollateralDamageRange);
		endif;
		CSrvWrap.GetDiplomacyMgr().AddMyEnemiesToSearch(m_xFighter.GetObj()^.GetOwner(), xCollateralQuery);
		var CObjList xList;
		var int i;
		if(xCollateralQuery.Execute(xList))then
			for(i=0)cond(i<xList.NumEntries())iter(i++)do
				if(!m_bGroundShot && xList[i]==m_xEnemy)then continue; endif;
				var ^CFightingObj pxObj = cast<CFightingObj>(xList[i].GetObj());
				if(pxObj==null)then continue; endif;
				if(pxObj^.GetTransportObj().IsValid())then continue; endif;
				m_xCollateralDamage.AddEntry(xList[i]);
			endfor;
		endif;
		return(true);
	endproc;
	
	export proc void EndTask()
		UpdateAggressionPos(m_xFighter);
		super.EndTask();
	endproc;
	
endclass;

class CCRpgHunter1 inherit CCRpgBaseAnml
	
//	export proc void OnInit(bool p_bLoad)
//		super.OnInit(p_bLoad);
//		SetVisInFOW(false);
//		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,true);
//		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_PARTYCOL,true);
//		var ^CRegionMgr pxRM=^(CSrvWrap.GetRegionMgr());
//		if(pxRM!=null)then
//			var string sName="hunter";
//			var ^CRegion pxRegion=pxRM^.GetRegion(sName);
//			if(pxRegion!=null)then
//				pxRegion^.BindToObj(GetHandle());
//				var real fRad=4.0f;
//				var vec3 vD;
//				vD.SetXYZ(fRad, fRad, 0.0);
//				var int i = pxRegion^.AddSubRegion(010b, GetPos(), vD);
//			endif;
//		endif;
//	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetVisInFOW(false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,true);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_PARTYCOL,true);
	endproc;
	
endclass;

class CCRpgHunter2 inherit CCRpgBaseAnml
	
	var string m_sIdleAnim;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_PARTYCOL,false);
		SetCanSwim(true);
		SetIdleAnim();
	endproc;
	
	export proc void SetIdleAnim()
		CheckWaterLand();
		SetAnim(m_sIdleAnim,3);
	endproc;
	
	export proc void CheckWaterLand()
		OnAmphibianWaterLandTransition(!IsInWater());
	endproc;
	
	export proc string GetThreatAnim()
		if(IsInWater())then
			return "";
		else
			return "menace";
		endif;
	endproc;
	
	export proc ref CFourCC GetWalkSet()
		return m_xWalkSet;
	endproc;
	
	//this function will be called from inside the walk action
	proc void OnAmphibianWaterLandTransition(bool p_bWaterToLand)
		if(p_bWaterToLand)then
			m_sIdleAnim="standanim";
			m_xWalkSet="def";
		else
			m_sIdleAnim="swim_standanim";
			m_xWalkSet="swim";
		endif;
		SetDefaultWalkSet(m_xWalkSet);
	endproc;
	
	export proc string GetFightAnim()
		if(IsInWater())then
			return "swim_attack_front";
		else
			return m_xCurrentFightAnim.m_sAnim;
		endif;
	endproc;
	
	export proc string EatAnim()
		if(IsInWater())then
			return "swim_attack_front";
		else
			return "feeding";
		endif;
	endproc;
	
	export proc bool IsBugged()
		if(IsInWater())then
			return true;
		endif;
		return m_bBugged;
	endproc;
	
	export proc string GetVictoryAnim()
		var string sAnim="menace";
		var int iR=Random.GetInt()%3;
		if(iR==1)then
			sAnim="shake";
		elseif(iR==2)then
			sAnim="scratch";
		endif;
		return sAnim;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(IsBerserking() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			)then return; endif;
		if(IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			)then return; endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("/hunter_swallow")!=(-1))then
				if(p_pxObject!=null)then
					StartHunterSwallow(p_sMiscParams, p_pxObject, p_bQ);
				endif;
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	export proc void AddAutoMoves()
		var int iIndex;
		iIndex=AddAutoSpecialMove("Actions/World/Moves/ANML/hunter_swallow");
		m_axAutoSpecialMoves[iIndex].m_xOnCheckConditions=CheckHunterSwallow;
		m_axAutoSpecialMoves[iIndex].m_xOnStartAction=AutoHunterSwallow;
	endproc;
	
	proc bool CheckHunterSwallow(string p_sTTPath)
		if(!CheckSpecialActionTimer(p_sTTPath))then return false; endif;
		if(!GetAIBrain())then return false; endif;
		if(!m_xCurEnemy.IsValid())then return false; endif;
		if(m_xCurEnemy.GetObj()^.GetOwner()==GetOwner())then return false; endif;
		var ^CFightingObj pxObj=cast<CFightingObj>(m_xCurEnemy.GetObj());
		var bool bInvalid; var CObjHndl xInvalid;
		if(pxObj==null||pxObj^.GetHitpoints()<200.0f||pxObj^.GetType()!="CHTR")then return false; endif;
		return true;
	endproc;
	
	proc void AutoHunterSwallow(string p_sTTPath)
		if(p_sTTPath.Find("hunter_swallow")!=(-1)&&m_xCurEnemy.IsValid())then
			StartHunterSwallow(p_sTTPath,m_xCurEnemy.GetObj(),false);
		endif;
	endproc;
	
	proc bool StartHunterSwallow(string p_sTTPath, ^CGameObj p_pxObject, bool p_bQ)
		if(p_pxObject!=null&&p_pxObject^.GetType()=="CHTR")then
//			MemorizeCurrentFightState(p_pxObject^.GetHandle(),true,false);
			var ^CHunterSwallow pxT=cast<CHunterSwallow>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"HunterSwllw"));
			if(pxT==null)then return false; endif;
			if(pxT^.Init(GetHandle(), p_pxObject^.GetHandle(), p_sTTPath))then
				pxT^.SetUserCommand(true);
				AddTask(pxT,p_bQ);
				return true;
			else
				pxT^.GetFactory()^.FreeState(pxT);
			endif;
		endif;
		return false;
	endproc;
	
	export proc bool ImportantTask(string p_sTask)
		if(p_sTask=="CrashSwallow")then return true; endif;
		return super.ImportantTask(p_sTask);
	endproc;
	
endclass;
	
class CHunterSwallow inherit CSpecialActionTask
	
	var CObjHndl	m_xActor;
	var CObjHndl	m_xVictim;
	var string		m_sState;
	
	export constructor()
		SetName("CrashSwallow");
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xType="CrSw";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xActor.DoKArc(pxArc^);
		m_xVictim.DoKArc(pxArc^);
		(pxArc^) << m_sState;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="CrSw")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xActor.DoKArc(pxArc^);
			m_xVictim.DoKArc(pxArc^);
			(pxArc^) << m_sState;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool Init(CObjHndl p_xActor, CObjHndl p_xVictim, string p_sPath)
		if(!p_xActor.IsValid()||!p_xVictim.IsValid())then
			m_sState="EndTask";
			return false;
		endif;
		SetSpecialActionPath(p_sPath);
		m_xActor = p_xActor;
		m_xVictim = p_xVictim;
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		var ^CFightingObj pxFightingObj=cast<CFightingObj>(m_xActor.GetObj());
		if(pxFightingObj==null || !pxFightingObj^.CheckSpecialActionTimer(GetSpecialActionPath()))then
			EndTask();
			return;
		endif;
		m_sState = "goto_chtr";
		SetMaxCounter(3);
	endproc;
	
	proc bool Check()
		var ^CFightingObj pxActor = cast<CFightingObj>(m_xActor.GetObj());
		var ^CFightingObj pxVictim = cast<CFightingObj>(m_xVictim.GetObj());
		if(pxActor!=null && pxVictim!=null)then
			return true;
		endif;
		return false;
	endproc;
	
	proc void USLOnTick(int p_iTime)
		if(Check())then
			var ^CFightingObj pxActor = cast<CFightingObj>(m_xActor.GetObj());
			var ^CFightingObj pxVictim = cast<CFightingObj>(m_xVictim.GetObj());
			if(m_sState == "goto_chtr")then
				SetCurrentTarget(m_xVictim);
				pxActor^.MemorizeCurrentFightState(m_xVictim,true,false);
				if(!IsAlreadyAtTargetPos(pxActor^.GetPos(), 8.0f))then
					var CGameObj.CAdvanceActionParams xAWAP;
					xAWAP.m_fMinDistance=2.0f;
					xAWAP.m_iPrefSpeed=pxActor^.GetMaxSpeed();
					pxActor^.AdvanceAction(pxVictim^.GetHandle(),xAWAP);
					m_sState = "check_pos";
				else
					m_sState = "do_anim";
					USLOnTick(0);
					return;
				endif;
			elseif(m_sState == "check_pos")then
				if(!HasArrivedTarget(pxActor^.GetPos(), 8.0f))then
					if(!CanFollow())then
						ResetCounter();
						m_sState = "EndTask";
						return;
					else
						m_sState = "goto_chtr";
						return;
					endif;
				else
					var vec3 vDir=pxVictim^.GetPos()-pxActor^.GetPos();
					var Quat qTRot;
					qTRot.FromXYDir(vDir.GetX(),vDir.GetY());
					pxActor^.RotateAction(qTRot);
					m_sState = "do_anim";
				endif;
			elseif(m_sState == "do_anim") then
				if(!StartSpecialActionTimer(pxActor))then
					EndTask();
					return;
				endif;
				SetUnStoppable(true);
				pxVictim^.PrepareStillStand();
				var CFourCC xLink="Fm01";
				pxActor^.AnimAction("baryonyx_fm_0");
				pxVictim^.LinkAction(m_xActor, xLink);
				pxVictim^.AnimAction("react_baryonyx_fm_0");
				m_sState = "finish";
			elseif(m_sState == "finish") then
				SetUnStoppable(false);
				var real fHitpoints = pxVictim^.GetHitpoints();
				pxActor^.HealMe(fHitpoints);
				pxVictim^.OneHitKillingSilent(pxActor^.GetOwner(),m_xActor,true);
				m_sState = "EndTask";
				pxActor^.ReturnToFight();
				return;
			elseif(m_sState == "EndTask") then
				EndTask();
			endif;
		else
			EndTask();
			return;
		endif;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
	endproc;
	
	export proc bool Break()
		if(GetUnStoppable())then
			return false;
		endif;
		if (m_xActor.IsValid()) then
			m_xActor.GetObj()^.TerminateAction();
		endif;
		return true;
	endproc;
	
	export proc void Skip()
	endproc;
	
	export proc void EndTask()
		UpdateAggressionPos(m_xActor);
		super.EndTask();
	endproc;
	
endclass;
	
class CCRpgHunter3 inherit CCRpgBaseAnml
	
	constructor()
		m_xSink.m_xOnObjAdd=OnObjAdd;
		m_xSink.m_xOnObjRem=OnObjRem;
	endconstructor;
	
	proc bool OnObjAdd(CObjHndl p_xHndl)
		if(m_bToBeDeleted)then return false; endif;
		var ^CFightingObj pxO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxO==null)then return false; endif;
		if(pxO^.GetOwner()==GetOwner())then return false; endif;
		if(CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxO^.GetOwner(), GetOwner())&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxO^.GetOwner()))then return false; endif;
		if(!CSrvWrap.GetDiplomacyMgr().GetIsEnemy(GetOwner(), pxO^.GetOwner()))then return false; endif;
		if(pxO^.GetType()=="BLDG")then return false; endif;
		m_xRegionObjects.Include(p_xHndl);
		pxO^.SetMirageFlag(CFightingObj.MIRAGE_THREATEN, true);
		return true;
	endproc;
	
	proc bool OnObjRem(CObjHndl p_xHndl)
		if(m_xRegionObjects.FindEntry(p_xHndl)==-1)then return false; endif;
		var ^CFightingObj pxO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxO==null)then return false; endif;
		pxO^.SetMirageFlag(CFightingObj.MIRAGE_THREATEN, false);
		m_xRegionObjects.RemEntry(p_xHndl);
		return true;
	endproc;
	
	export proc void UpdateGfxFlags()
		if(GetClassName()=="hunter_lvl3")then
			if(!HasPersonalRegion())then
				var vec3 vD; vD.SetXYZ(20.0, 20.0, 0.0);
				CreatePersonalRegion("Threaten_"+GetName()+"_"+Random.GetInt().ToString(), vD, 010b);
				AddRangedBuff("owner_less_damage");
			endif;
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMOR,true);
		endif;
	endproc;
	
	export proc void InitOwnRegion()
		if(!HasPersonalRegion())then
			var vec3 vD; vD.SetXYZ(20.0, 20.0, 0.0);
			CreatePersonalRegion("Threaten_"+GetName()+"_"+Random.GetInt().ToString(), vD, 010b);
			AddRangedBuff("owner_less_damage");
		endif;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(	IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			)then return; endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("/hunter_bite")!=(-1))then
				if(CheckBite(p_sMiscParams))then
					StartBiteFull(p_sMiscParams,p_bQ);
				endif;
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	proc bool CheckBite(string p_sTTPath)
		if(!CheckSpecialActionTimer(p_sTTPath))then return false; endif;
		if(!m_xCurEnemy.IsValid())then return false; endif;
		if(m_xCurEnemy.GetObj()^.GetOwner()==GetOwner())then return false; endif;
		var ^CFightingObj pxObj=cast<CFightingObj>(m_xCurEnemy.GetObj());
		var bool bInvalid; var CObjHndl xInvalid;
		if(pxObj==null||!IsInCombatRange(pxObj,false))then return false; endif;
		if(GetAngleToR(m_xCurEnemy.GetObj())>0.39)then return false; endif;
		return true;
	endproc;
	
	proc void StartBite(string p_sTTPath)
		StartBiteFull(p_sTTPath,false);
	endproc;
	
	proc void StartBiteFull(string p_sTTPath, bool p_bQ)
//		MemorizeCurrentFightState(m_xCurEnemy,false,false);
		var ^CHunterScrunch pxTask=cast<CHunterScrunch>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"HunterScr"));
		if(pxTask==null)then return; endif;
		if(pxTask^.Init(GetHandle(), m_xCurEnemy, p_sTTPath))then
			pxTask^.SetUserCommand(true);
			AddTask(pxTask,p_bQ);
		else
			pxTask^.GetFactory()^.FreeState(pxTask);
		endif;
	endproc;
	
	export proc string GetVictoryAnim()
		var string sAnim="menace";
		if(Random.GetInt()%2==1)then
			sAnim="shake";
		endif;
		return sAnim;
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		po_rxLink="Ride";
		SetCaptainAnim("ride_idle_0");
		SetCaptainAttackAnim("ride_attack_front");
		return true;
	endproc;
	
	export proc real FeedFactor()
		return 2.5;
	endproc;
	
	export proc void AddAutoMoves()
		var int iIndex;
		iIndex=AddAutoSpecialMove("Actions/World/Moves/ANML/hunter_bite");
		m_axAutoSpecialMoves[iIndex].m_xOnCheckConditions=CheckBite;
		m_axAutoSpecialMoves[iIndex].m_xOnStartAction=StartBite;
	endproc;
	
	export proc bool ImportantTask(string p_sTask)
		if(p_sTask=="HunterScr")then return true; endif;
		return super.ImportantTask(p_sTask);
	endproc;
	
endclass;

class CHunterScrunch inherit CSpecialActionTask

	var CObjHndl		m_xActor;
	var CObjHndl		m_xTarget;
	var string			m_sState;
	
	export constructor()
		SetName("HunterScr");
		SetCivil(false);
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xType="HuCr";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xActor.DoKArc(pxArc^);
		m_xTarget.DoKArc(pxArc^);
		(pxArc^) << m_sState;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="HuCr")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xActor.DoKArc(pxArc^);
			m_xTarget.DoKArc(pxArc^);
			(pxArc^) << m_sState;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool Init(CObjHndl p_xActor, CObjHndl p_xTarget, string p_sPath)
		m_sState="start_anim";
		if(!p_xActor.IsValid() || !p_xTarget.IsValid())then
			m_sState="EndTask";
			return false;
		endif;
		m_xActor = p_xActor;
		m_xTarget = p_xTarget;
		SetSpecialActionPath(p_sPath);
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		if(m_sState=="EndTask")then
			EndTask();
		endif;
		var ^CFightingObj pxFighter=cast<CFightingObj>(m_xActor.GetObj());
		if(pxFighter==null || !pxFighter^.CheckSpecialActionTimer(GetSpecialActionPath()))then
			EndTask();
			return;
		endif;
		var ^CFightingObj pxTarget=cast<CFightingObj>(m_xTarget.GetObj());
		if(pxTarget==null)then
			EndTask();
			return;
		endif;
		var bool bInvalid;
		var CObjHndl xInvalid;
		if(!pxFighter^.IsInCombatRange(pxTarget,false))then
			EndTask();
			return;
		endif;
	endproc;
	
	proc void USLOnTick(int p_iTime)
		var ^CCRpgHunter3 pxActor = cast<CCRpgHunter3>(m_xActor.GetObj());
		if(pxActor==null)then EndTask(); return; endif;
		if(m_sState == "start_anim")then
			if(!StartSpecialActionTimer(pxActor))then EndTask();return;endif;
			pxActor^.MemorizeCurrentFightState(pxActor^.GetCurEnemy(),false,false);
			SetUnStoppable(true);
			pxActor^.AnimAction("sm_scrunch");
			var int iOwner = pxActor^.GetOwner();
			if(iOwner>=0)then
				var ^CFightingObj pxFight = cast<CFightingObj>(m_xTarget.GetObj());
				if(pxFight==null)then EndTask(); return; endif;
				pxFight^.TakeDmg(pxActor, false, 3.0);
				pxFight^.ClearDamageCache();
				var ^CCharacter pxChar = cast<CCharacter>(pxFight);
				if(pxChar!=null && !pxChar^.GetTransportObj().IsValid())then
					var vec3 vDir = (pxChar^.GetPos() - pxActor^.GetPos());
					vDir.Normalize();
					vDir.SetZ(vDir.GetZ()+0.5);
					vDir.Normalize();
					pxChar^.SetHitReactionTimer(0.7,vDir*(10.0f));
				endif;
			endif;
			m_sState = "finished";
		elseif(m_sState == "finished")then
			m_sState="EndTask";
			SetUnStoppable(false);
			pxActor^.ReturnToFight();
		elseif(m_sState == "EndTask")then
			EndTask();
			return;
		endif;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
	endproc;
	
	export proc bool Break()
		return false;
	endproc;
	
	export proc void Skip()
	endproc;
	
endclass;

class CCRpgHunter4 inherit CCRpgBaseAnml
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			ReBuildWeapon();
		endif;
	endproc;
	
	export proc void ReBuildWeapon()
		var string sClassName=GetClassName();
		if(sClassName=="hunter_lvl4")then
			SetBuildUp(CBuildUpBase.TYPE_FAKE);
			var ^CCaptain pxC = cast<CCaptain>(CSrvWrap.GetObjMgr()^.CreateObj("universal_captain", GetOwner()));
			if(pxC!=null) then
				pxC^.Init(GetHandle());
				GetBuildUp()^.AddObj(pxC^.GetHandle(), "Rid2");
			endif;
			pxC = cast<CCaptain>(CSrvWrap.GetObjMgr()^.CreateObj("universal_captain", GetOwner()));
			if(pxC!=null) then
				pxC^.Init(GetHandle());
				GetBuildUp()^.AddObj(pxC^.GetHandle(), "Rid3");
			endif;
		endif;
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		po_rxLink="Ride";
		SetCaptainAnim("standanim");
		return true;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1 || p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel" || p_sMiscParams.Find("/LevelUp")!=-1)
			)then return; endif;
		if(GetActAutonomous() && p_sMiscParams.Find("AttackSrv")==-1)then return; endif;
		if(p_sCommand=="Action") then
			if(p_sMiscParams.Find("/hunter_scrunch") != -1)then
				if(CheckSpecialActionTimer(p_sMiscParams))then
					ShakeOff("trex_fm_2",0.2,2.0,p_sMiscParams,p_bQ,false,false);
				endif;
			elseif(p_sMiscParams.Find("/hunter_roar") != -1)then
				if(CheckSpecialActionTimer(p_sMiscParams))then
					StunningRoar("menace",10.0,0.8,10.0,p_sMiscParams,p_bQ,false);
				endif;
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	export proc real GetAdaption()
		return 5.5f;
	endproc;
	
	export proc string GetVictoryAnim()
		var string sAnim="menace";
		if(Random.GetInt()%2==1)then
			sAnim="idle_1";
		endif;
		return sAnim;
	endproc;
	
	export proc void AddAutoMoves()
		var int iIndex;
		iIndex=AddAutoSpecialMove("Actions/World/Moves/ANML/hunter_scrunch");
		m_axAutoSpecialMoves[iIndex].m_xOnCheckConditions=CheckScrunch;
		m_axAutoSpecialMoves[iIndex].m_xOnStartAction=StartScrunch;
		iIndex=AddAutoSpecialMove("Actions/World/Moves/ANML/hunter_roar");
		m_axAutoSpecialMoves[iIndex].m_xOnCheckConditions=CheckRoar;
		m_axAutoSpecialMoves[iIndex].m_xOnStartAction=StartRoar;
	endproc;
	
	proc bool CheckScrunch(string p_sTTPath)
		if(!CheckSpecialActionTimer(p_sTTPath))then return false; endif;
		if(!GetAIBrain())then return false; endif;
		var ^CObjList pxEnemies=CSrvWrap.GetObjMgr()^.GetOwnerEnemyList(GetOwner());
		if(pxEnemies==null)then return false; endif;
		var CObjList xList;
		pxEnemies^.CopySorted(xList,GetPos(),GetCollisionRadius()+5.0);
		if(xList.NumEntries()<3)then return false; endif;
		return true;
	endproc;
	
	proc void StartScrunch(string p_sTTPath)
		return StartScrunchFull(p_sTTPath, false);
	endproc;
	
	proc void StartScrunchFull(string p_sTTPath, bool p_bQ)
		if(p_sTTPath.Find("/hunter_scrunch") != -1)then
			ShakeOff("trex_fm_2",0.2,2.0,p_sTTPath,p_bQ,false,false);
		endif;
	endproc;
	
	proc bool CheckRoar(string p_sTTPath)
		if(!CheckSpecialActionTimer(p_sTTPath))then return false; endif;
		if(!GetAIBrain())then return false; endif;
		var ^CObjList pxEnemies=CSrvWrap.GetObjMgr()^.GetOwnerEnemyList(GetOwner());
		if(pxEnemies==null)then return false; endif;
		var CObjList xList;
		pxEnemies^.CopySorted2D(xList,GetPos(),9.0);
		if(xList.NumEntries()<1)then return false; endif;
		return true;
	endproc;
	
	proc void StartRoar(string p_sTTPath)
		if(p_sTTPath.Find("/hunter_roar") != -1)then
			StunningRoar("menace",10.0,0.8,10.0,p_sTTPath,false,false);
		endif;
	endproc;
	
	export proc bool ImportantTask(string p_sTask)
		if(p_sTask=="ShakeOff"||p_sTask=="StunRoar")then return true; endif;
		return super.ImportantTask(p_sTask);
	endproc;
	
endclass;

class CCRpgKnight0 inherit CCRpgBaseAnml
	
	export constructor()
		m_xSink.m_xOnObjAdd=OnObjAdd;
		m_xSink.m_xOnObjRem=OnObjRem;
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetVisInFOW(false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_HELMET,true);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,true);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_PARTYCOL,true);
	endproc;
	
//	export proc void OnInit(bool p_bLoad)
//		super.OnInit(p_bLoad);
//		SetVisInFOW(false);
//		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_HELMET,true);
//		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,true);
//		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_PARTYCOL,true);
//		var ^CRegionMgr pxRM=^(CSrvWrap.GetRegionMgr());
//		if(pxRM!=null)then
//			var string sName="knight";
//			var ^CRegion pxRegion=pxRM^.GetRegion(sName);
//			if(pxRegion!=null)then
//				pxRegion^.BindToObj(GetHandle());
//				var real fRad=4.0f;
//				var vec3 vD;
//				vD.SetXYZ(fRad, fRad, 0.0);
//				var int i = pxRegion^.AddSubRegion(010b, GetPos(), vD);
//			endif;
//		endif;
//	endproc;
	
	export proc void UpdateGfxFlags()
		if(GetClassName()=="knight_lvl1")then
			if(!GetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_HELMET))then
				SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_HELMET,true);
			endif;
			if(!HasPersonalRegion())then
				var vec3 vD; vD.SetXYZ(20.0, 20.0, 0.0);
				CreatePersonalRegion("KnightDrums_"+GetName()+"_"+Random.GetInt().ToString(), vD, 010b);
				AddRangedBuff("owner_more_damage");
			endif;
		endif;
	endproc;
	
	proc bool OnObjAdd(CObjHndl p_xHndl)
		if(m_bToBeDeleted)then return false; endif;
		var ^CFightingObj pxO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxO==null)then return false; endif;
		if(!(CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxO^.GetOwner(), GetOwner())&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxO^.GetOwner())))then return false; endif;
		if(pxO^.GetType()=="BLDG")then return false; endif;
		m_xRegionObjects.Include(p_xHndl);
		pxO^.SetEffectFlag(CFightingObj.EFFECT_MEGALO_DRUMS, true);
		return true;
	endproc;
	
	proc bool OnObjRem(CObjHndl p_xHndl)
		if(m_xRegionObjects.FindEntry(p_xHndl)==-1)then return false; endif;
		m_xRegionObjects.RemEntry(p_xHndl);
		var ^CFightingObj pxO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxO==null)then return false; endif;
		pxO^.SetEffectFlag(CFightingObj.EFFECT_MEGALO_DRUMS, false);
		return true;
	endproc;
	
	export proc void InitOwnRegion()
		if(!HasPersonalRegion())then
			var vec3 vD; vD.SetXYZ(20.0, 20.0, 0.0);
			CreatePersonalRegion("KnightDrums_"+GetName()+"_"+Random.GetInt().ToString(), vD, 010b);
			AddRangedBuff("owner_more_damage");
		endif;
	endproc;
	
endclass;

class CCRpgKnight1 inherit CCRpgBaseAnml
	
	export proc void OnInit(bool p_bLoad)
		if(!p_bLoad)then
//			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_HELMET,true);
		endif;
		super.OnInit(p_bLoad);
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(	IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			)then return; endif;
		if(GetActAutonomous() && p_sMiscParams.Find("AttackSrv")==-1 &&
		!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill"))then return; endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("/knight_rage")!=-1)then
				if(CheckSpecialActionTimer(p_sMiscParams))then
					ShakeOff("rage",0.1,1.4,10.0+((GetLevel()+1)*2).ToReal(),10.0+((GetLevel()+1)*2).ToReal(),8.0,p_sMiscParams,p_bQ,false,false);
				endif;
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	proc bool CheckKnightRage(string p_sTTPath)
		if(GetClassName()!="knight_lvl1")then return false; endif;
		if(!GetAIBrain())then return false; endif;
		if(!CheckSpecialActionTimer(p_sTTPath))then return false; endif;
		var ^CObjList pxEnemies=CSrvWrap.GetObjMgr()^.GetOwnerEnemyList(GetOwner());
		if(pxEnemies==null)then return false; endif;
		var CObjList xList; pxEnemies^.CopySorted(xList,GetPos(),GetCollisionRadius()+5.0);
		if(xList.NumEntries()<2)then return false; endif;
		return true;
	endproc;
	
	proc void StartKnightRage(string p_sTTPath)
		return StartKnightRageFull(p_sTTPath, false);
	endproc;
	
	proc void StartKnightRageFull(string p_sTTPath, bool p_bQ)
		if(CheckSpecialActionTimer(p_sTTPath))then
			ShakeOff("rage",0.1,1.4,10.0,10.0,8.0,p_sTTPath,p_bQ,false,false);
		endif;
		return;
	endproc;
	
	export proc void AddAutoMoves()
		var int iIndex;
		iIndex=AddAutoSpecialMove("Actions/World/Moves/ANML/knight_rage");
		m_axAutoSpecialMoves[iIndex].m_xOnCheckConditions=CheckKnightRage;
		m_axAutoSpecialMoves[iIndex].m_xOnStartAction=StartKnightRage;
	endproc;
	
	export proc bool ImportantTask(string p_sTask)
		if(p_sTask=="ShakeOff")then return true; endif;
		return super.ImportantTask(p_sTask);
	endproc;
	
//	export proc void UpdateGfxFlags()
//		if(GetClassName()=="knight_lvl1")then
//			if(!GetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_HELMET))then
//				SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_HELMET,true);
//			endif;
//		endif;
//	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		po_rxLink="Ride";
		SetCaptainAnim("ride_idle_0");
		SetCaptainAttackAnim("ride_attack_front");
		return true;
	endproc;
	
	export proc string GetVictoryAnim()
		var string sAnim="menace";
		if(Random.GetInt()%2==1)then
			sAnim="rage";
		endif;
		return sAnim;
	endproc;
	
endclass;

class CCRpgKnight2 inherit CCRpgBaseAnml
	
	var real m_fSpikeDamage;
	
	export proc void OnInit(bool p_bLoad)
		if(!p_bLoad)then
//			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMOR,true);
//			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMORSADDLE,true);
		endif;
		super.OnInit(p_bLoad);
		UpdateSpikes();
	endproc;
	
	export proc bool SetLevelClean(int p_iLevel)
		var bool bReturn=super.SetLevelClean(p_iLevel);
		UpdateSpikes();
		return bReturn;
	endproc;
	
	export proc void UpdateSpikes()
		var int iLvl=GetLevel();
		switch(iLvl)
			case(0)do m_fSpikeDamage=10.0f; endcase;
			case(1)do m_fSpikeDamage=20.0f; endcase;
			case(2)do m_fSpikeDamage=30.0f; endcase;
			case(3)do m_fSpikeDamage=40.0f; endcase;
			case(4)do m_fSpikeDamage=50.0f; endcase;
			case default do endcase;
		endswitch;
	endproc;
	
//	export proc void UpdateGfxFlags()
//		if(GetClassName()=="knight_lvl2")then
//			if(!GetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMOR))then
//				SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMOR,true);
//			endif;
//			if(!GetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMORSADDLE))then
//				SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMORSADDLE,true);
//			endif;
//		endif;
//	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy)
		return super.TakeDmg(p_pxEnemy);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile)
		return super.TakeDmg(p_pxEnemy, p_bProjectile);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, real p_fFactor)
		return super.TakeDmg(p_pxEnemy, p_fFactor);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile, real p_fFactor)
		return super.TakeDmg(p_pxEnemy, p_bProjectile, p_fFactor);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile, real p_fFactor, real p_fHitDelay)
		return super.TakeDmg(p_pxEnemy, p_bProjectile, p_fFactor, p_fHitDelay);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, bool p_bProjectile, real p_fFactor, real p_fHitDelay, real p_fArmorPiercing)
		var real fReturn=super.TakeDmg(p_pxEnemy, p_bProjectile, p_fFactor, p_fHitDelay, p_fArmorPiercing);
		if(fReturn==0.0)then
			fReturn=m_fSpikeDamage;
		endif;
		return fReturn;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(	IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			)then return; endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("/knight_intimidate") != -1)then
				if(CheckSpecialActionTimer(p_sMiscParams))then
					KnightIntimidate(p_sMiscParams,p_bQ);
				endif;
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	export proc void KnightIntimidate(string p_sTTPath, bool p_bQ)
		if(p_bQ)then
			StartCustomTask("KnightIntimidate",p_sTTPath);
			return;
		endif;
		AnimAction("attack_back");
		var real fRange=25.0f, fDuration=10.0f;
		var CObjList xEnemies;
		var CObjQuery xQuery;
		CSrvWrap.GetDiplomacyMgr().AddMyEnemiesToSearch(GetOwner(), xQuery, false);
		xQuery.SetOwner(-1, true);
		xQuery.SetType("CHTR");
		xQuery.SetType("SHIP",true);
		xQuery.SetType("ANML",true);
		xQuery.SetType("VHCL",true);
		xQuery.SetType("BLDG",true);
		xQuery.SetType("FGHT",true);
		xQuery.RegionCircle(GetPos(), fRange);
		xQuery.Execute(xEnemies);
		var int i, iC=xEnemies.NumEntries();
		for(i=0)cond(i<iC)iter(++i)do
			var ^CFightingObj pxFO=cast<CFightingObj>(xEnemies[i].GetObj());
			if(pxFO==null)then continue; endif;
			pxFO^.Intimidate(GetHandle(),fDuration);
		endfor;
		AddSpecialActionTimer(p_sTTPath);
	endproc;
	
	export proc void AddAutoMoves()
		var int iIndex;
		iIndex=AddAutoSpecialMove("Actions/World/Moves/ANML/knight_intimidate");
		m_axAutoSpecialMoves[iIndex].m_xOnCheckConditions=CheckKnightIntimidate;
		m_axAutoSpecialMoves[iIndex].m_xOnStartAction=StartKnightIntimidate;
	endproc;
	
	proc bool CheckKnightIntimidate(string p_sTTPath)
		if(GetClassName()!="knight_lvl2")then return false; endif;
		if(!GetAIBrain())then return false; endif;
		if(!CheckSpecialActionTimer(p_sTTPath))then return false; endif;
		var ^CObjList pxEnemies=CSrvWrap.GetObjMgr()^.GetOwnerEnemyList(GetOwner());
		if(pxEnemies==null)then return false; endif;
		var CObjList xList; pxEnemies^.CopySorted(xList,GetPos(),GetCollisionRadius()+10.0);
		if(xList.NumEntries()<4)then return false; endif;
		return true;
	endproc;
	
	proc void StartKnightIntimidate(string p_sTTPath)
		if(CheckSpecialActionTimer(p_sTTPath))then
			KnightIntimidate(p_sTTPath,false);
		endif;
		return;
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		po_rxLink="Ride";
		SetCaptainAnim("ride_idle_0");
		SetCaptainAttackAnim("ride_attack_front");
		return true;
	endproc;
	
	export proc string GetVictoryAnim()
		var string sAnim="attack_back";
		return sAnim;
	endproc;
	
endclass;

class CCRpgKnight3 inherit CCRpgBaseAnml
	
	var CFourCC					m_xKnightRageWalkSet;
	
	constructor()
		m_xSink.m_xOnObjAdd=OnObjAdd;
		m_xSink.m_xOnObjRem=OnObjRem;
//		m_xKnightRageWalkSet="rage";
		m_xKnightRageWalkSet="def";
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			UpdateGfxFlags();
		endif;
		SetDefaultWalkSet(m_xKnightRageWalkSet);
	endproc;
	
	export proc ref CFourCC GetWalkSet()
		return m_xKnightRageWalkSet;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		var string sClassName=GetClassName();
		if(sClassName=="knight_lvl3")then
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_STANDARTE,true);
//			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_HELMET,true);
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMOR,true);
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMORSADDLE,true);
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,false);
		endif;
	endproc;
	
	export proc void UpdateGfxFlags()
		if(GetClassName()=="knight_lvl3")then
			if(!HasPersonalRegion())then
				var vec3 vD; vD.SetXYZ(20.0, 20.0, 0.0);
				CreatePersonalRegion("KnightPennant_"+GetName()+"_"+Random.GetInt().ToString(), vD, 010b);
				AddRangedBuff("owner_more_defense");
			endif;
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_STANDARTE,true);
//			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_HELMET,true);
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMOR,true);
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMORSADDLE,true);
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,false);
		endif;
	endproc;
	
	proc bool OnObjAdd(CObjHndl p_xHndl)
		if(m_bToBeDeleted)then return false; endif;
		if(p_xHndl==GetHandle())then return false; endif;
		var ^CFightingObj pxO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxO==null)then return false; endif;
		if(!(CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxO^.GetOwner(), GetOwner())&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxO^.GetOwner())))then return false; endif;
//		if(!CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxO^.GetOwner()))then return false; endif;
		if(pxO^.GetType()=="BLDG")then return false; endif;
		m_xRegionObjects.Include(p_xHndl);
		pxO^.SetEffectFlag(CFightingObj.EFFECT_RHINO_PENNANT, true);
		return true;
	endproc;
	
	proc bool OnObjRem(CObjHndl p_xHndl)
		if(m_xRegionObjects.FindEntry(p_xHndl)==-1)then return false; endif;
		m_xRegionObjects.RemEntry(p_xHndl);
		var ^CFightingObj pxO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxO==null)then return false; endif;
		pxO^.SetEffectFlag(CFightingObj.EFFECT_RHINO_PENNANT, false);
		return true;
	endproc;
	
	export proc void InitOwnRegion()
		if(!HasPersonalRegion())then
			var vec3 vD; vD.SetXYZ(20.0, 20.0, 0.0);
			CreatePersonalRegion("KnightPennant_"+GetName()+"_"+Random.GetInt().ToString(), vD, 010b);
			AddRangedBuff("owner_more_defense");
		endif;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(	IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			)then return; endif;
		if(GetActAutonomous() && p_sMiscParams.Find("AttackSrv")==-1 &&
		!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill"))then return; endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("/knight_shake_off")!=-1)then
				if(CheckSpecialActionTimer(p_sMiscParams))then
					ShakeOff("sm_shake_off",2.0,0.4,50.0,50.0,9.0,p_sMiscParams,p_bQ,false,false);
				endif;
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	export proc string GetVictoryAnim()
		var string sAnim="menace";
		if(Random.GetInt()%2==1)then
			sAnim="shake";
		endif;
		return sAnim;
	endproc;
	
	export proc void AddAutoMoves()
		var int iIndex;
		iIndex=AddAutoSpecialMove("Actions/World/Moves/ANML/knight_shake_off");
		m_axAutoSpecialMoves[iIndex].m_xOnCheckConditions=CheckShakeOff;
		m_axAutoSpecialMoves[iIndex].m_xOnStartAction=StartShakeOff;
	endproc;
	
	proc bool CheckShakeOff(string p_sTTPath)
		if(!CheckSpecialActionTimer(p_sTTPath))then return false; endif;
		if(!GetAIBrain())then return false; endif;
		var ^CObjList pxEnemies=CSrvWrap.GetObjMgr()^.GetOwnerEnemyList(GetOwner());
		if(pxEnemies==null)then return false; endif;
		var CObjList xList;
		pxEnemies^.CopySorted(xList,GetPos(),8.0);
		if(xList.NumEntries()<2)then return false; endif;
		return true;
	endproc;
	
	proc void StartShakeOff(string p_sTTPath)
		return StartShakeOffFull(p_sTTPath, false);
	endproc;
	
	proc void StartShakeOffFull(string p_sTTPath, bool p_bQ)
		if(p_sTTPath.Find("/knight_shake_off")!=-1)then
			ShakeOff("sm_shake_off",2.0,0.4,200.0,200.0,9.0, p_sTTPath, p_bQ, false, false);
		endif;
	endproc;
	
	export proc bool ImportantTask(string p_sTask)
		if(p_sTask=="ShakeOff")then return true; endif;
		return super.ImportantTask(p_sTask);
	endproc;
	
endclass;

class CCRpgKnight4 inherit CCRpgBaseAnml
	
	const real					KNIGHT_RAGE_DURATION=30.0;
	export const int		TIMER_KNIGHT_RAGETO=40117;
	var CFourCC					m_xKnightRageWalkSet;
	var CGameTime				m_xKnightRageStart;
	
	constructor()
		var int iIndex=AddAutoSpecialMove("Actions/World/Moves/ANML/knight_stampede");
		m_axAutoSpecialMoves[iIndex].m_xOnCheckConditions=CheckKnightRageTo;
		m_axAutoSpecialMoves[iIndex].m_xOnStartAction=StartKnightRageTo;
		m_xKnightRageWalkSet="rage";
	endconstructor;
	
	destructor()
		if(HasTimer(TIMER_KNIGHT_RAGETO))then
			EndKnightRageTo();
		endif;
	enddestructor;
	
	export proc bool AttackEnemy(^CFightingObj p_pxEnemy, vec3 p_vTarget, ref bool p_rbRotated)
		if(HasTimer(TIMER_KNIGHT_RAGETO))then
			EndRageTo();
		endif;
		return super.AttackEnemy(p_pxEnemy, p_vTarget, p_rbRotated);
	endproc;
	
	proc bool CheckKnightRageTo(string p_sTTPath)
		if(GetClassName()!="knight_lvl4")then return false; endif;
		if(HasTimer(TIMER_KNIGHT_RAGETO))then return false; endif;
		var ^CFightingObj pxEnemy=cast<CFightingObj>(m_xCurEnemy.GetObj());
		if(pxEnemy==null)then return false; endif;
		var real fRangeSquare=(pxEnemy^.GetPos() - GetPos()).AbsSquare();
		if(fRangeSquare<100.0)then return false; endif;
		if(fRangeSquare>(GetFOWRange()*GetFOWRange()))then return false; endif;
		return true;
	endproc;
	
	proc void StartKnightRageTo(string p_sTTPath)
		if(!HasTimer(TIMER_KNIGHT_RAGETO))then
			CreateTimer(TIMER_KNIGHT_RAGETO,CGameTimeSpan.OneSecond()*2.0,true);
			m_xKnightRageStart=CTimeMgr.Get().GetTime();
			SetDefaultWalkSet(m_xKnightRageWalkSet);
		endif;
	endproc;
	
	proc void KnightRageTo()
		var CGameTime xNow=CTimeMgr.Get().GetTime();
		var CGameTimeSpan xDuration=KNIGHT_RAGE_DURATION;
		if((xNow - m_xKnightRageStart) >= xDuration)then
			EndRageTo();
			return;
		endif;
		if(!HasTimer(TIMER_KNIGHT_RAGETO))then
			return;
		endif;
		var vec3 vDirection={0.0,1.0,0.0};
		vDirection.RotZ(GetRotation().GetZ());
		var vec3 vLeft=(vDirection${0.0,0.0,1.0}).GetNormalized();
		var vec3 vRight=vLeft * (-1.0);
		vLeft.SetZ(0.5);
		vRight.SetZ(0.5);
		vLeft *= 10.0;
		vRight *= 10.0;
		var ^CAreaDamage pxDmg=new CAreaDamage(7.0, GetDmg(), 10.0, GetOwner(), GetPos(), m_iSizeClass);
		var ^CObjList pxEnemies=CSrvWrap.GetObjMgr()^.GetOwnerEnemyList(GetOwner());
		if(pxEnemies!=null)then
			var CObjList xList;
			pxEnemies^.CopySorted(xList,GetPos(),7.0);
			var int i, iC=xList.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				var ^CCharacter pxFight=cast<CCharacter>(xList[i].GetObj());
				if(pxFight!=null)then
					var real fAngle=GetAngleToR(pxFight);
					if(fAngle>=0.0)then
						pxFight^.SetHitReactionTimer(0.0,vRight);
					else
						pxFight^.SetHitReactionTimer(0.0,vLeft);
					endif;
				endif;
			endfor;
		endif;
	endproc;
	
	proc void EndKnightRageTo()
		DeleteTimer(TIMER_KNIGHT_RAGETO);
		SetDefaultWalkSet(GetWalkSet());
	endproc;
	
	export proc ref CFourCC GetWalkSet()
		if(HasTimer(TIMER_KNIGHT_RAGETO))then
			return m_xKnightRageWalkSet;
		else
			return super.GetWalkSet();
		endif;
	endproc;
	
	export proc void OnActionEnd(bool p_bBroken)
		super.OnActionEnd(p_bBroken);
		if(HasTimer(TIMER_KNIGHT_RAGETO))then
			EndKnightRageTo();
		endif;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==TIMER_KNIGHT_RAGETO)then
				if(GetClassName()=="knight_lvl4")then
					KnightRageTo();
				endif;
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	proc bool KnightTrumpet(string p_sTTPath, bool p_bQ)
//		MemorizeCurrentFightState(CObjHndl.Invalid(),false,false);
		var ^CKnightTrumpet pxTask=cast<CKnightTrumpet>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"KnightTrmpt"));
		if(pxTask==null)then return false; endif;
		var bool bReturn=pxTask^.Init(GetHandle(),p_sTTPath);
		if(bReturn)then
			pxTask^.SetUserCommand(true);
			NewTaskFO(pxTask,p_bQ);
		else
			pxTask^.GetFactory()^.FreeState(pxTask);
		endif;
		return bReturn;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(	IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			)then return; endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("knight_trumpet")!=(-1))then
				if(CheckSpecialActionTimer(p_sMiscParams))then
					KnightTrumpet(p_sMiscParams,p_bQ);
				endif;
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	export proc void UpdateGfxFlags()
		if(GetClassName()=="knight_lvl4")then
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_HELMET,true);
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMOR,true);
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMORSADDLE,true);
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,false);
		endif;
	endproc;
	
	export proc string GetVictoryAnim()
		var string sAnim="menace";
		var int iR=Random.GetInt()%3;
		if(iR==1)then
			sAnim="shake";
		elseif(iR==2)then
			sAnim="stomp";
		endif;
		return sAnim;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		var string sClassName=GetClassName();
		if(sClassName=="knight_lvl4")then
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_HELMET,true);
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMOR,true);
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMORSADDLE,true);
			SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,false);
		endif;
	endproc;
	
	export proc void AddAutoMoves()
		var int iIndex;
		iIndex=AddAutoSpecialMove("Actions/World/Moves/ANML/knight_trumpet");
		m_axAutoSpecialMoves[iIndex].m_xOnCheckConditions=CheckTrumpet;
		m_axAutoSpecialMoves[iIndex].m_xOnStartAction=AutoTrumpet;
	endproc;
	
	proc bool CheckTrumpet(string p_sTTPath)
		if(!CheckSpecialActionTimer(p_sTTPath))then return false; endif;
		if(!GetAIBrain())then return false; endif;
		if(!m_xCurEnemy.IsValid())then return false; endif;
		if(m_xCurEnemy.GetObj()^.GetOwner()==GetOwner())then return false; endif;
		var ^CFightingObj pxObj=cast<CFightingObj>(m_xCurEnemy.GetObj());
		var bool bInvalid; var CObjHndl xInvalid;
		if(pxObj==null||!IsInCombatRange(pxObj,false))then return false; endif;
		return true;
	endproc;
	
	proc void AutoTrumpet(string p_sTTPath)
		KnightTrumpet(p_sTTPath,false);
	endproc;
	
	export proc void ClearAutoMoves()
		super.ClearAutoMoves();
		var int iIndex=AddAutoSpecialMove("Actions/World/Moves/ANML/knight_stampede");
		m_axAutoSpecialMoves[iIndex].m_xOnCheckConditions=CheckKnightRageTo;
		m_axAutoSpecialMoves[iIndex].m_xOnStartAction=StartKnightRageTo;
		m_xKnightRageWalkSet="rage";
	endproc;
	
	export proc bool ImportantTask(string p_sTask)
		if(p_sTask=="KTrumpet")then return true; endif;
		return super.ImportantTask(p_sTask);
	endproc;
	
endclass;

class CKnightTrumpet inherit CActionTask
	
	var CObjHndl		m_xMammoth;
	var string			m_sState;
	
	export constructor()
		SetName("KTrumpet");
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xType="KnTr";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xMammoth.DoKArc(pxArc^);
		(pxArc^) << m_sState;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="KnTr")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xMammoth.DoKArc(pxArc^);
			(pxArc^) << m_sState;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool Init(CObjHndl p_xMammoth, string p_sPath)
		m_sState="start_anim";
		if(!p_xMammoth.IsValid())then
			m_sState="EndTask";
			return false;
		endif;
		m_xMammoth = p_xMammoth;
		SetSpecialActionPath(p_sPath);
		SetPrepareActionPath(m_xMammoth, p_sPath, true);
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		if(m_sState=="EndTask")then
			EndTask();
		endif;
	endproc;
	
	proc void USLOnTick(int p_iTime)
		var ^CAnimal pxMammoth = cast<CAnimal>(m_xMammoth.GetObj());
		if(pxMammoth==null)then EndTask(); return; endif;
		if(m_sState == "start_anim")then
			if(!StartSpecialActionTimer(pxMammoth))then
				m_sState=="EndTask";
				EndTask();
				return;
			endif;
			pxMammoth^.MemorizeCurrentFightState(CObjHndl.Invalid(),false,false);
			pxMammoth^.AnimAction("trumpet");
			m_sState = "calc_bonus";
		elseif(m_sState == "calc_bonus")then
			//calc
			var int iOwner = pxMammoth^.GetOwner();
			var real fZone=30.0f;
			if(iOwner>=0)then
				var CObjQuery xQuery;
				xQuery.SetType("ANML", false);
				xQuery.SetType("CHTR", true);
				xQuery.SetType("VHCL", true);
				xQuery.SetOwner(iOwner);
				CSrvWrap.GetDiplomacyMgr().AddMyFriendsToSearch(iOwner, xQuery);
				xQuery.RegionCircle(pxMammoth^.GetPos(), fZone);
				var CObjList xList;
				xQuery.Execute(xList);
				var int i, iC=xList.NumEntries();
				for(i=0)cond(i<iC)iter(++i)do
					var ^CFightingObj pxF=cast<CFightingObj>(xList[i].GetObj());
					if(pxF!=null)then
						pxF^.SetValorEffect(15.0f);
					endif;
				endfor;
			endif;
			m_sState = "finished";
		elseif(m_sState == "finished")then
			m_sState="EndTask";
			pxMammoth^.ReturnToFight();
		elseif(m_sState == "EndTask")then
			EndTask();
			return;
		endif;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
	endproc;
	
	export proc void EndTask()
		SetPrepareActionPath(m_xMammoth, GetSpecialActionPath(), false);
		super.EndTask();
	endproc;
	
	export proc bool Break()
		return false;
	endproc;
	
	export proc void Skip()
	endproc;
	
endclass;

class CCRpgNovice1 inherit CCRpgBaseChtr
	
//	export proc void OnInit(bool p_bLoad)
//		super.OnInit(p_bLoad);
//		var ^CRegionMgr pxRM=^(CSrvWrap.GetRegionMgr());
//		if(pxRM!=null)then
//			var string sName="novice";
//			var ^CRegion pxRegion=pxRM^.GetRegion(sName);
//			if(pxRegion!=null)then
//				pxRegion^.BindToObj(GetHandle());
//				var real fRad=4.0f;
//				var vec3 vD;
//				vD.SetXYZ(fRad, fRad, 0.0);
//				var int i = pxRegion^.AddSubRegion(010b, GetPos(), vD);
//			endif;
//		endif;
//	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(IsBerserking() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			)then return; endif;
		if(IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			)then return; endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("/novice_Matrix")!=(-1))then
				StartNoviceMatrix(p_sMiscParams,p_bQ);
			elseif(p_sMiscParams.Find("/novice_Twister")!=(-1))then
				StartNoviceTwister(p_sMiscParams,p_bQ);
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	proc bool StartNoviceMatrix(string p_sTTPath, bool p_bQ)
		if(GetClassName()!="novice_lvl1")then return false; endif;
		if(!CheckSpecialActionTimer(p_sTTPath))then return false; endif;
		var ^CCharacterBash pxTask=cast<CCharacterBash>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"ChtrBash"));
		if(pxTask==null)then return false; endif;
		var bool bR=pxTask^.Init(GetHandle(),"nat_sm_matrix",GetCollisionRadius()+6.0, 1.0, 0.6, p_sTTPath, false);
		if(!bR)then pxTask^.GetFactory()^.FreeState(pxTask); return false; endif;
		pxTask^.SetUserCommand(true);
		AddTask(pxTask,p_bQ);
		return bR;
	endproc;
	
	proc bool StartNoviceTwister(string p_sTTPath, bool p_bQ)
		if(GetClassName()!="novice_lvl1")then return false; endif;
		if(!CheckSpecialActionTimer(p_sTTPath))then return false; endif;
		var ^CCharacterBash pxTask=cast<CCharacterBash>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"ChtrBash"));
		if(pxTask==null)then return false; endif;
		var bool bR=pxTask^.Init(GetHandle(),"nat_sm_twister",GetCollisionRadius()+4.0, 0.6, 0.2, p_sTTPath, false);
		if(!bR)then pxTask^.GetFactory()^.FreeState(pxTask); return false; endif;
		pxTask^.SetUserCommand(true);
		AddTask(pxTask,p_bQ);
		return bR;
	endproc;
	
	export proc void AddAutoMoves()
		var int iIndex;
		iIndex=AddAutoSpecialMove("Actions/World/Moves/CHTR/novice_Matrix");
		m_axAutoSpecialMoves[iIndex].m_xOnCheckConditions=CheckNoviceMatrix;
		m_axAutoSpecialMoves[iIndex].m_xOnStartAction=AutoNoviceMatrix;
		iIndex=AddAutoSpecialMove("Actions/World/Moves/CHTR/novice_Twister");
		m_axAutoSpecialMoves[iIndex].m_xOnCheckConditions=CheckNoviceTwister;
		m_axAutoSpecialMoves[iIndex].m_xOnStartAction=AutoNoviceTwister;
	endproc;
	
	proc bool CheckNoviceMatrix(string p_sTTPath)
		if(!CheckSpecialActionTimer(p_sTTPath))then return false; endif;
		if(!GetAIBrain())then return false; endif;
		var ^CObjList pxEnemies=CSrvWrap.GetObjMgr()^.GetOwnerEnemyList(GetOwner());
		if(pxEnemies==null)then return false; endif;
		var CObjList xList; pxEnemies^.CopySorted(xList,GetPos(),GetCollisionRadius()+6.0);
		if(xList.NumEntries()<3)then return false; endif;
		return true;
	endproc;
	
	proc bool CheckNoviceTwister(string p_sTTPath)
		if(!CheckSpecialActionTimer(p_sTTPath))then return false; endif;
		if(!GetAIBrain())then return false; endif;
		var ^CObjList pxEnemies=CSrvWrap.GetObjMgr()^.GetOwnerEnemyList(GetOwner());
		if(pxEnemies==null)then return false; endif;
		var CObjList xList; pxEnemies^.CopySorted(xList,GetPos(),GetCollisionRadius()+4.0);
		if(xList.NumEntries()<3)then return false; endif;
		return true;
	endproc;
	
	proc void AutoNoviceMatrix(string p_sTTPath)
		if(p_sTTPath.Find("/novice_Matrix")!=(-1))then
			StartNoviceMatrix(p_sTTPath,false);
		endif;
	endproc;
	
	proc void AutoNoviceTwister(string p_sTTPath)
		if(p_sTTPath.Find("/novice_Twister")!=(-1))then
			StartNoviceTwister(p_sTTPath,false);
		endif;
	endproc;
	
	export proc bool ImportantTask(string p_sTask)
		if(p_sTask=="NoviceFW"||p_sTask=="ChtrBash")then return true; endif;
		return super.ImportantTask(p_sTask);
	endproc;
	
endclass;

class CCRpgNovice2 inherit CCRpgBaseChtr
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(IsBerserking() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			)then return; endif;
		if(IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			)then return; endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("/novice_fireworks")!=(-1))then
				if(CheckSpecialActionTimer(p_sMiscParams)||p_bQ)then
					StartNoviceFireworks(p_sMiscParams,p_bQ);
				endif;
			elseif(p_sMiscParams.Find("/novice_destroy")!=(-1))then
				if(p_pxObject!=null)then
					StartNoviceDestroy(p_sMiscParams, p_pxObject, p_bQ);
				endif;
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	proc bool StartNoviceFireworks(string p_sTTPath, bool p_bQ)
		if(GetClassName()!="novice_lvl2")then return(false);endif;
		if(CheckSpecialActionTimer(p_sTTPath))then
			var ^CNoviceFireworks pxTask=cast<CNoviceFireworks>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"NoviceFW"));
			if(pxTask==null)then return false; endif;
			var bool bReturn=pxTask^.Init(GetHandle());
			if(bReturn)then
				pxTask^.SetUserCommand(true);
				AddTask(pxTask,p_bQ);
			else
				pxTask^.GetFactory()^.FreeState(pxTask);
			endif;
			return bReturn;
		else
			return(false);
		endif;
	endproc;
	
	export proc void AddAutoMoves()
		var int iIndex;
		iIndex=AddAutoSpecialMove("Actions/World/Moves/CHTR/novice_destroy");
		m_axAutoSpecialMoves[iIndex].m_xOnCheckConditions=CheckNoviceDestroy;
		m_axAutoSpecialMoves[iIndex].m_xOnStartAction=AutoNoviceDestroy;
	endproc;
	
	proc bool CheckNoviceDestroy(string p_sTTPath)
		if(!CheckSpecialActionTimer(p_sTTPath))then return false; endif;
		if(!GetAIBrain())then return false; endif;
		if(!m_xCurEnemy.IsValid())then return false; endif;
		if(m_xCurEnemy.GetObj()^.GetOwner()==GetOwner())then return false; endif;
		var ^CFightingObj pxObj=cast<CFightingObj>(m_xCurEnemy.GetObj());
		var bool bInvalid; var CObjHndl xInvalid;
		if(pxObj==null||pxObj^.GetHitpoints()<500.0f||pxObj^.GetType()!="VHCL")then return false; endif;
		return true;
	endproc;
	
	proc void AutoNoviceDestroy(string p_sTTPath)
		if(p_sTTPath.Find("novice_destroy")!=(-1)&&m_xCurEnemy.IsValid())then
			StartNoviceDestroy(p_sTTPath,m_xCurEnemy.GetObj(),false);
		endif;
	endproc;
	
	proc bool StartNoviceDestroy(string p_sTTPath, ^CGameObj p_pxObject, bool p_bQ)
		if(p_pxObject!=null&&p_pxObject^.GetType()=="VHCL"&&p_pxObject^.GetClassName().Find("_zeppelin")==-1&&p_pxObject^.GetClassName()!="ninigi_cargolifter")then
//			MemorizeCurrentFightState(p_pxObject^.GetHandle(),true,false);
			var ^CCrashDestroy pxT=cast<CCrashDestroy>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"NoviceDV"));
			if(pxT==null)then return false; endif;
			if(pxT^.Init(GetHandle(), p_pxObject^.GetHandle(), p_sTTPath))then
				pxT^.SetUserCommand(true);
				AddTask(pxT,p_bQ);
				return true;
			else
				pxT^.GetFactory()^.FreeState(pxT);
			endif;
		endif;
		return false;
	endproc;
	
	export proc bool ImportantTask(string p_sTask)
		if(p_sTask=="novice_fireworks"||p_sTask=="CrashDestroy")then return true; endif;
		return super.ImportantTask(p_sTask);
	endproc;
	
endclass;

class CNoviceFireworks inherit CTask
	
	var CObjHndl		m_xCharacter;
	var string			m_sState;
	var vec3				m_vPos;
	const real			RANGE = 150.0;
	
	export constructor()
		SetName("NoviceFW");
		SetCivil(false);
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xType="NoFW";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xCharacter.DoKArc(pxArc^);
		(pxArc^) << m_sState;
		(pxArc^) << m_vPos;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="NoFW")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xCharacter.DoKArc(pxArc^);
			(pxArc^) << m_sState;
			(pxArc^) << m_vPos;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool Init(CObjHndl p_xCharacter)
		m_sState="shoot_rocket";
		if(!p_xCharacter.IsValid())then
			m_sState="EndTask";
			return false;
		endif;
		m_xCharacter = p_xCharacter;
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		if(m_sState=="EndTask")then
			EndTask();
			return;
		endif;
	endproc;
	
	proc void USLOnTick(int p_iTime)
		var ^CCharacter pxCharacter = cast<CCharacter>(m_xCharacter.GetObj());
		if(pxCharacter==null)then EndTask(); return; endif;
		if(m_sState == "shoot_rocket")then
			pxCharacter^.AnimAction("potter_ground");
			if(pxCharacter^.GetOnWall())then
				m_sState = "point_wall";
			else
				m_sState = "point";
			endif;
			return;
		elseif(m_sState == "point_wall")then
			m_vPos = pxCharacter^.GetPos();
			var vec3 vCDir = {0.0f, 1.5f, 0.0f};
			pxCharacter^.GetRot().VecRotateU(vCDir);
			var ^CFireWorkObj pxO = cast<CFireWorkObj>(CSrvWrap.GetObjMgr()^.CreateObj("ninigi_fireworks",pxCharacter^.GetOwner(),m_vPos+vCDir));
			m_sState = "EndTask";
			return;
		elseif(m_sState == "point")then
			m_vPos = pxCharacter^.GetPos();
			pxCharacter^.WalkAction(m_vPos-{3.0,0.0,0.0},3);
			var ^CFireWorkObj pxO = cast<CFireWorkObj>(CSrvWrap.GetObjMgr()^.CreateObj("ninigi_fireworks",pxCharacter^.GetOwner(),m_vPos));
			m_sState = "rotate";
			return;
		elseif(m_sState == "rotate")then
			var Quat qTRot;
			qTRot.FromXYDir(m_vPos.GetX(),m_vPos.GetY());
			pxCharacter^.RotateAction(qTRot);
			m_sState = "EndTask";
		elseif(m_sState == "EndTask")then
			EndTask();
			return;
		endif;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
	endproc;
	
	export proc bool Break()
		var ^CGameObj pxC=m_xCharacter.GetObj();
		if(pxC!=null)then
			pxC^.TerminateAction();
		endif;
		return true;
	endproc;
	
	export proc void Skip()
	endproc;
	
	export proc void EndTask()
		UpdateAggressionPos(m_xCharacter);
		super.EndTask();
	endproc;
	
endclass;

class CCrashDestroy inherit CSpecialActionTask
	
	var CObjHndl	m_xActor;
	var CObjHndl	m_xVictim;
	var string		m_sState;
	
	export constructor()
		SetName("CrashDestroy");
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xType="CrDV";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xActor.DoKArc(pxArc^);
		m_xVictim.DoKArc(pxArc^);
		(pxArc^) << m_sState;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="CrDV")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xActor.DoKArc(pxArc^);
			m_xVictim.DoKArc(pxArc^);
			(pxArc^) << m_sState;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool Init(CObjHndl p_xActor, CObjHndl p_xVictim, string p_sPath)
		if(!p_xActor.IsValid()||!p_xVictim.IsValid())then
			m_sState="EndTask";
			return false;
		endif;
		SetSpecialActionPath(p_sPath);
		m_xActor = p_xActor;
		m_xVictim = p_xVictim;
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		var ^CFightingObj pxFightingObj=cast<CFightingObj>(m_xActor.GetObj());
		if(pxFightingObj==null || !pxFightingObj^.CheckSpecialActionTimer(GetSpecialActionPath()))then
			EndTask();
			return;
		endif;
		m_sState = "goto_vhcl";
		SetMaxCounter(3);
	endproc;
	
	proc void USLOnTick(int p_iTime)
		if(Check())then
			var ^CFightingObj pxActor = cast<CFightingObj>(m_xActor.GetObj());
			var ^CFightingObj pxVictim = cast<CFightingObj>(m_xVictim.GetObj());
			if(m_sState == "goto_vhcl")then
//				SetCurrentTarget(pxVictim^.GetPos());
				SetCurrentTarget(m_xVictim);
				pxActor^.MemorizeCurrentFightState(m_xVictim,true,false);
				if(!IsAlreadyAtTargetPos(pxActor^.GetPos(), 8.0f))then
					var CGameObj.CAdvanceActionParams xAWAP;
					xAWAP.m_fMinDistance=2.0f;
					xAWAP.m_iPrefSpeed=pxActor^.GetMaxSpeed();
					pxActor^.AdvanceAction(pxVictim^.GetHandle(),xAWAP);
					m_sState = "check_pos";
				else
					m_sState = "do_anim";
					USLOnTick(0);
					return;
				endif;
			elseif(m_sState == "check_pos")then
				if(!HasArrivedTarget(pxActor^.GetPos(), 8.0f))then
					if(!CanFollow())then
						ResetCounter();
						m_sState = "EndTask";
						return;
					else
						m_sState = "goto_vhcl";
						return;
					endif;
				else
					m_sState = "do_anim";
				endif;
			elseif(m_sState == "do_anim") then
				if(!StartSpecialActionTimer(pxActor))then EndTask();return;endif;
				SetUnStoppable(true);
				pxActor^.AnimAction("potter");
				m_sState = "destroy";
			elseif(m_sState == "destroy") then
				SetUnStoppable(false);
				pxVictim^.OneHitKilling(pxActor^.GetOwner(),m_xActor);
				m_sState = "EndTask";
				pxActor^.ReturnToFight();
				return;
			elseif(m_sState == "EndTask") then
				EndTask();
			endif;
		else
			EndTask();
			return;
		endif;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
	endproc;
	
	export proc bool Break()
		if(GetUnStoppable())then
			return false;
		endif;
		if (m_xActor.IsValid()) then
			m_xActor.GetObj()^.TerminateAction();
		endif;
		return true;
	endproc;
	
	export proc void Skip()
	endproc;	
	
	proc bool Check()
		var ^CFightingObj pxActor = cast<CFightingObj>(m_xActor.GetObj());
		var ^CFightingObj pxVictim = cast<CFightingObj>(m_xVictim.GetObj());
		if(pxActor!=null && pxVictim!=null)then
			var ^CVehicle pxV = cast<CVehicle>(pxVictim);
			if(pxV!=null&&!pxV^.IsFlyingUnit())then return true; endif;
		endif;
		return false;
	endproc;
	
	export proc void EndTask()
		UpdateAggressionPos(m_xActor);
		super.EndTask();
	endproc;
	
endclass;

class CCRpgNovice3 inherit CCRpgBaseChtr
	
	var CObjList m_xShadowClones;
	
	constructor()
		m_xSink.m_xOnObjAdd=OnObjAdd;
		m_xSink.m_xOnObjRem=OnObjRem;
	endconstructor;
	
	destructor()
		var int i, iC=m_xShadowClones.Validate();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CCRpgClone pxClone=cast<CCRpgClone>(m_xShadowClones[i].GetObj());
			if(pxClone!=null)then
				pxClone^.Orphan();
				pxClone^.Die();
			endif;
		endfor;
	enddestructor;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
		if(p_pxReaderNode^.GetType()=="CRPN")then
			if(p_pxReaderNode^.GetVersion()>=1)then
				m_xShadowClones.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="CRPN";
		var int iVersion=1;
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,iVersion);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xShadowClones.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		InitOwnRegion();
	endproc;
	
	proc bool OnObjAdd(CObjHndl p_xHndl)
		if(m_bToBeDeleted)then return false; endif;
		var ^CFightingObj pxO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxO==null)then return false; endif;
		if(pxO^.GetOwner()==GetOwner())then return false; endif;
		if(CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxO^.GetOwner(), GetOwner())&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxO^.GetOwner()))then return false; endif;
		if(!CSrvWrap.GetDiplomacyMgr().GetIsEnemy(GetOwner(), pxO^.GetOwner()))then return false; endif;
		m_xRegionObjects.Include(p_xHndl);
		pxO^.SetEffectFlag(CFightingObj.EFFECT_KLEEMANN_AURA, true);
		return true;
	endproc;
	
	proc bool OnObjRem(CObjHndl p_xHndl)
		if(m_xRegionObjects.FindEntry(p_xHndl)==-1)then return false; endif;
		var ^CFightingObj pxO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxO==null)then return false; endif;
		pxO^.SetEffectFlag(CFightingObj.EFFECT_KLEEMANN_AURA, false);
		m_xRegionObjects.RemEntry(p_xHndl);
		return true;
	endproc;
	
	export proc void InitOwnRegion()
		if(!HasPersonalRegion())then
			var vec3 vD; vD.SetXYZ(20.0, 20.0, 0.0);
			CreatePersonalRegion("BonusSkull_"+GetName()+"_"+Random.GetInt().ToString(), vD, 010b);
			AddRangedBuff("owner_schliemann");
		endif;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(IsBerserking() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			)then return; endif;
		if(IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			)then return; endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("/novice_pick_lock")!=(-1))then
				PickLock(p_pxObject, p_sMiscParams, p_bQ);
			elseif(p_sMiscParams.Find("/novice_sc_jutsu")!=(-1))then
				ShadowCloneJutsu(p_sMiscParams, p_bQ);
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	export proc void ShadowCloneJutsu(string p_sPath, bool p_bQ)
		if(p_bQ)then
			StartCustomTask("ShadowCloneJutsu",p_sPath);
			return;
		endif;
		var int i, iMax=(GetLevel()+1)-m_xShadowClones.Validate();
		if(iMax<1)then return; endif;
		if(!AddSpecialActionTimer(p_sPath))then return; endif;
		var real fLife=15.0f*((GetLevel()+1).ToReal());
		var CObjHndl xMe=GetHandle();
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			for(i=0)cond(i<iMax)iter(i++)do
				var vec3 vPos={4.0,0.0,0.0};
				vPos.RotZ((Random.GetInt()%314).ToReal() / 100.0);
				var ^CCRpgClone pxCharacter=cast<CCRpgClone>(CSrvWrap.GetObjMgr()^.CreateObj("novice_shadow_clone",GetOwner(),GetPos()+vPos,GetRotation()));
				if(pxCharacter!=null)then
					pxCharacter^.SetLevelClean(GetLevel());
					pxCharacter^.MakeShadowClone(fLife);
					pxCharacter^.SetShadowOwner(xMe);
					pxCharacter^.SetAIBrain(GetAIBrain());
					m_xShadowClones.Include(pxCharacter^.GetHandle());
				endif;
			endfor;
		endif;
	endproc;
	
	export proc bool PickLock(^CGameObj p_pxObject, string p_sPath, bool p_bQ)
		if(p_pxObject==null)then return false; endif;
		if(GetClassName()!="novice_lvl3")then return false; endif;
		var ^CLockPicking pxTask=cast<CLockPicking>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"LockPick"));
		if(pxTask==null)then return false; endif;
		var bool bReturn=false;
		var CGameTimeSpan xDuration;
		xDuration=15.0;
		bReturn=pxTask^.Init(GetHandle(),p_pxObject^.GetHandle(),xDuration,p_sPath);
		if(bReturn)then
			pxTask^.SetUserCommand(true);
			AddTask(pxTask,p_bQ);
		else
			pxTask^.GetFactory()^.FreeState(pxTask);
		endif;
		return bReturn;
	endproc;
	
	export proc void AddAutoMoves()
		var int iIndex;
		iIndex=AddAutoSpecialMove("Actions/World/Moves/CHTR/novice_sc_jutsu");
		m_axAutoSpecialMoves[iIndex].m_xOnCheckConditions=CheckNoviceSCJutsu;
		m_axAutoSpecialMoves[iIndex].m_xOnStartAction=AutoNoviceSCJutsu;
	endproc;
	
	proc bool CheckNoviceSCJutsu(string p_sTTPath)
		if(!CheckSpecialActionTimer(p_sTTPath))then return false; endif;
		if(!GetAIBrain())then return false; endif;
		if(!m_xCurEnemy.IsValid())then return false; endif;
		if(m_xCurEnemy.GetObj()^.GetOwner()==GetOwner())then return false; endif;
		if(m_xShadowClones.NumEntries()>GetLevel())then return false; endif;
		return true;
	endproc;
	
	proc void AutoNoviceSCJutsu(string p_sTTPath)
		if(p_sTTPath.Find("novice_sc_jutsu")!=(-1)&&m_xCurEnemy.IsValid())then
			ShadowCloneJutsu(p_sTTPath,false);
		endif;
	endproc;
	
	export proc bool CanDisguise()
		if(GetClassName()=="novice_lvl3")then
			return true;
		endif;
		return false;
	endproc;
	
	export proc void RemoveShadow(CObjHndl p_xShadow)
		if(m_xShadowClones.FindEntry(p_xShadow)==-1)then return; endif;
		m_xShadowClones.RemEntry(p_xShadow);
	endproc;
	
	export proc bool SetLevelClean(int p_iLevel)
		var bool bReturn=super.SetLevelClean(p_iLevel);
		var int iNew=GetLevel(), i, iC=m_xShadowClones.Validate();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CCRpgClone pxClone=cast<CCRpgClone>(m_xShadowClones[i].GetObj());
			if(pxClone!=null)then
				pxClone^.SetLevelClean(iNew);
			endif;
		endfor;
		return bReturn;
	endproc;
	
	export proc void SetAIBrain(bool p_bOn)
		var CObjHndl xMe=GetHandle();
		var int i, iC=m_xShadowClones.Validate();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CCRpgClone pxClone=cast<CCRpgClone>(m_xShadowClones[i].GetObj());
			if(pxClone!=null)then
				pxClone^.SetAIBrain(p_bOn);
				pxClone^.SetSpawningPool(xMe);
			endif;
		endfor;
		super.SetAIBrain(p_bOn);
	endproc;
	
endclass;

class CCRpgClone inherit CCharacter
	
	const int RPG_CHECK_ENEMY					= 40133;
	const int RPG_RANDOM_POS					= 40131;
	const int RPG_CENTER_REGION				= 40129;
	const int TIMER_CLONE_DEATH				= 40158;
	
	var bool m_bAIBrain;
	var bool m_bDisconnect;
	var bool m_bConquer;
	var bool m_bDefend;
	var bool m_bSkipCorpse;
	var ^CRegion m_pxCenter;
	var ^CRegion m_pxTolerance;
	var CObjHndl m_xShadowOwner;
	
	export constructor()
		m_bAIBrain = false;
		m_bDisconnect = false;
		m_bConquer = false;
		m_bDefend = false;
		m_bSkipCorpse = true;
	endconstructor;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
		if(p_pxReaderNode^.GetType()=="RPGC")then
			if(p_pxReaderNode^.GetVersion()>=1)then
				m_xShadowOwner.DoKArc(pxArc^);
				(pxArc^) << m_bAIBrain;
				(pxArc^) << m_bDisconnect;
				(pxArc^) << m_bConquer;
				(pxArc^) << m_bDefend;
				(pxArc^) << m_bSkipCorpse;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="RPGC";
		var int iVersion=1;
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,iVersion);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xShadowOwner.DoKArc(pxArc^);
		(pxArc^) << m_bAIBrain;
		(pxArc^) << m_bDisconnect;
		(pxArc^) << m_bConquer;
		(pxArc^) << m_bDefend;
		(pxArc^) << m_bSkipCorpse;
		pxWalk^.Close();
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad && CCrashRPGMgr.GetCrashRPGMgrNC()!=null)then
			m_bDefend=CCrashRPGMgr.GetCrashRPGMgr()^.DefendCenter();
		endif;
		ValidateRegions();
	endproc;
	
	export proc void MakeShadowClone(real p_fTime)
		if(!HasTimer(TIMER_CLONE_DEATH))then
			CreateTimer(TIMER_CLONE_DEATH,CGameTimeSpan.OneSecond()*Math.Max(p_fTime,5.0f),false);
		endif;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("unit_count",false);
		endif;
	endproc;
	
	export proc bool GetAIBrain()
		return m_bAIBrain;
	endproc;
	
	export proc void SetAIBrain(bool p_bOn)
		var bool bOld=m_bAIBrain;
		m_bAIBrain=p_bOn;
		if(!bOld && p_bOn)then
			if(!GetCurEnemy().IsValid())then
				if(!LookForEnemies() && ExamineEnemies(false))then
					SetRandomPos();
				endif;
			endif;
		endif;
		if(m_bAIBrain)then
			if(!HasTimer(RPG_CENTER_REGION))then
				CreateTimer(RPG_CENTER_REGION,CGameTimeSpan.OneSecond()*5.0f,true);
			endif;
			if(!HasTimer(RPG_RANDOM_POS))then
				CreateTimer(RPG_RANDOM_POS,CGameTimeSpan.OneSecond()*10.0f,true);
			endif;
			if(!HasTimer(RPG_CHECK_ENEMY))then
				CreateTimer(RPG_CHECK_ENEMY,CGameTimeSpan.OneSecond()*7.0f,true);
			endif;
		else
			DeleteTimer(RPG_CENTER_REGION);
			DeleteTimer(RPG_RANDOM_POS);
			DeleteTimer(RPG_CHECK_ENEMY);
		endif;
	endproc;
	
	proc bool ValidateRegions()
		var ^CRegionMgr pxRegionMgr=^(CSrvWrap.GetRegionMgr());
		if(pxRegionMgr==null)then return false; endif;
		if(m_bDefend||!m_bConquer)then
			m_pxCenter=pxRegionMgr^.GetRegion("center");
			m_pxTolerance=pxRegionMgr^.GetRegion("tolerance");
		else
			m_pxCenter=pxRegionMgr^.GetRegion("island");
			m_pxTolerance=pxRegionMgr^.GetRegion("island");
		endif;
		if(m_pxCenter==null||m_pxTolerance==null)then return false; endif;
		return true;
	endproc;
	
	export proc void AttackSrv(^CGameObj p_pxEnemy)
		if(GetAIBrain()&&p_pxEnemy!=null)then
			if(!IsInToleranceArea(p_pxEnemy^.GetPos()))then return; endif;
		endif;
		return super.AttackSrv(p_pxEnemy);
	endproc;
	
	proc void OnDefend(^CGameObj p_pxEnemy)
		if(GetAIBrain()&&p_pxEnemy!=null)then
			if(!IsInToleranceArea(p_pxEnemy^.GetPos()))then return; endif;
		endif;
		super.OnDefend(p_pxEnemy);
	endproc;
	
	export proc vec3 GetNewRandomPos()
		var vec3 vTmp;
		if(m_pxCenter!=null)then
			return m_pxCenter^.GetRandomPointInside();
		endif;
		return vTmp;
	endproc;
	
	export proc bool IsInCenterArea(vec3 p_vPos)
		if(m_pxCenter!=null)then
			return m_pxCenter^.IsInside(p_vPos);
		endif;
		return true;
	endproc;
	
	export proc bool IsInToleranceArea(vec3 p_vPos)
		if(m_pxTolerance!=null)then
			return m_pxTolerance^.IsInside(p_vPos);
		endif;
		return true;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==RPG_CENTER_REGION)then
				if(!IsInCenterArea(GetPos()))then
					var bool bWalkInArea=IsInToleranceArea(GetPos())&&IsInFight();
					if(!bWalkInArea)then
						var vec3 vPos = GetNewRandomPos();
						CSrvWrap.GetObjMgr()^.GetFreePos(vPos,this,vPos,null,true,false,false);
						GoTo(vPos, true, GetMaxSpeed(), true, true);
					endif;
				endif;
				return;
			elseif(iTimerID==RPG_RANDOM_POS)then
				SetRandomPos();
			elseif(iTimerID==TIMER_CLONE_DEATH)then
				Die();
				return;
			elseif(iTimerID==RPG_CHECK_ENEMY)then
				if(!m_xCurEnemy.IsValid())then
					LookForEnemies();
				endif;
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		elseif(p_rxEvtPtr.GetClass()=="DefendBlimp")then
			m_bDefend=p_rxEvtPtr.GetBool(0);
			ValidateRegions();
			if(!IsInCenterArea(GetPos()))then
				var bool bWalkInArea=false;
				var ^CWalkToPos pxCurWalkTask=cast<CWalkToPos>(GetCurTask());
				if(pxCurWalkTask!=null)then
					var vec3 vTargetPos=pxCurWalkTask^.GetTargetPos();
					if(IsInCenterArea(vTargetPos))then
						bWalkInArea=true;
					endif;
				endif;
				bWalkInArea=bWalkInArea||(IsInToleranceArea(GetPos())&&IsInFight());
				if(!bWalkInArea)then
					var vec3 vPos = GetNewRandomPos();
					CSrvWrap.GetObjMgr()^.GetFreePos(vPos,this,vPos,null,true,false,false);
					GoTo(vPos, true, GetMaxSpeed(), true, true);
				endif;
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	proc void SetRandomPos()
		var vec3 vPos = GetNewRandomPos();
		if(!IsInFight())then
			UpdateAggressionPos(vPos);
		endif;
		if(GetTaskDescription()=="Idle"||GetTaskDescription()=="")then
			CSrvWrap.GetObjMgr()^.GetFreePos(vPos,this,vPos,null,true,false,false);
			GoTo(vPos, false, GetDefaultSpeed(), true, true);
		endif;
	endproc;
	
	export proc void AddItemSilent(CObjHndl p_xItem)
		return;
	endproc;
	
	export proc void AddItem(CObjHndl p_xItem)
		return;
	endproc;
	
	export proc bool SkipCorpse()
		return true;
	endproc;
	
	export proc void FilterEnemyListCustom(ref CObjList p_rxList)
		if(!m_bAIBrain)then return; endif;
		var ^CFightingObj pxE;
		var int i,iC=p_rxList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var CObjHndl xHndl=p_rxList[i];
			if(xHndl.IsValid())then
				pxE=cast<CFightingObj>(xHndl.GetObj());
				if(pxE==null)then
					p_rxList.DeleteEntry(i);i--;iC--;
				elseif(!m_bConquer && (cast<CWall>(pxE)!=null || cast<CGate>(pxE)!=null))then
					p_rxList.DeleteEntry(i);i--;iC--;
				elseif(pxE^.GetSlaveInvincible())then
					p_rxList.DeleteEntry(i);i--;iC--;
				endif;
			endif;
		endfor;
		super.FilterEnemyListCustom(p_rxList);
	endproc;
	
	export proc bool ResistantToThrow()
		return true;
	endproc;
	
	export proc void UseHealWell()
		return;
	endproc;
	
	export proc void FountainHeal(^CGameObj p_pxO, bool p_bQ)
		return;
	endproc;
	
	export proc void SeasWellHeal(^CGameObj p_pxO)
		return;
	endproc;
	
	export proc void PickUp(CObjHndl p_xItem,bool p_bQueue)
		return;
	endproc;
	
	proc bool LookForEnemies()
		var CObjQuery xQ;
		xQ.SetType("CHTR", false);
		xQ.SetType("ANML", true);
		xQ.SetType("VHCL", true);
		xQ.SetType("BLDG", true);
		xQ.SetAttribsNeg("invalid_enemy",true);
		if(!CanShootAir())then
			xQ.SetAttribsNeg("flying_unit",true);
		endif;
		xQ.SetAttribsNeg("not_detectable",true);
		if(m_pxTolerance!=null)then
			xQ.SetRegion(m_pxTolerance^.GetHandle());
		else
			xQ.RegionCircle(GetPos(), 100.0f);
		endif;
		var ^CGameObj pxEnemy=null;
		CSrvWrap.GetDiplomacyMgr().AddMyEnemiesToSearch(GetOwner(), xQ, false);
		var CObjList xList;
		if(!xQ.Execute(xList))then return false; endif;
		FilterEnemyListCustom(xList);
		xList.SortDistance(GetPos());
		var CObjList xEnd;
//		xList.CopySorted(xEnd, GetPos(), 100.0f);
		xEnd=xList;
		if(xEnd.NumEntries()>0)then
			var int i, iC=xEnd.NumEntries();
			for(i=0)cond(i<iC)iter(++i)do
				if(xEnd[i].IsValid())then
					var ^CGameObj pxO=xEnd[i].GetObj();
					if(pxO!=null)then
						pxEnemy=pxO;
						break;
					endif;
				endif;
			endfor;
		endif;
		if(pxEnemy!=null)then
			var vec3 vEPos=pxEnemy^.GetPos();
			Fight(pxEnemy, vEPos, true, false);
			return true;
		endif;
		return false;
	endproc;
	
	export proc void GameOverKill(int p_iSwitch)
		m_bDisconnect=p_iSwitch<1;
		if(p_iSwitch==1)then SetAIBrain(true); return; endif;
	endproc;
	
	export proc void DiePerHarakiri()
		return;
	endproc;
	
	export proc void CreateSpirit()
		return;
	endproc;
	
	export proc void AddAutoMoves()
		return;
	endproc;
	
//	export proc void Damage(real p_fDamage)
//		return super.Damage(p_fDamage*2.0f);
//	endproc;
	
//	export proc void PoisonDamage(real p_fDamage, CObjHndl p_xEnemy, int p_iEnemy)
//		return super.PoisonDamage(p_fDamage*2.0f,p_xEnemy,p_iEnemy);
//	endproc;
	
//	export proc void BurnDamage(real p_fDamage, CObjHndl p_xEnemy, int p_iEnemy)
//		return super.BurnDamage(p_fDamage*2.0f,p_xEnemy,p_iEnemy);
//	endproc;
	
//	export proc void ChainDamage(real p_fDamage, int p_iLast, CObjHndl p_xLast)
//		return super.ChainDamage(p_fDamage*2.0f,p_iLast,p_xLast);
//	endproc;
	
//	export proc void WoundDamage(real p_fDamage, CObjHndl p_xLE, int p_iLE)
//		return super.WoundDamage(p_fDamage*2.0f,p_xLE,p_iLE);
//	endproc;
	
	export proc void Die()
		if(!IsDead())then
			if(m_xShadowOwner.IsValid())then
				var ^CCRpgNovice3 pxObj=cast<CCRpgNovice3>(m_xShadowOwner.GetObj());
				if(pxObj!=null)then
					pxObj^.RemoveShadow(GetHandle());
				endif;
				m_xShadowOwner.FromInt(-1);
			endif;
		endif;
		CreateCorpse();
		super.Die();
	endproc;
	
	export proc void CreateCorpse()
		CreateCustomFX(7,GetPos(),true);
		return;
	endproc;
	
	export proc void Orphan()
//		m_xShadowOwner.FromInt(-1);
		m_xShadowOwner=CObjHndl.Invalid();
		return;
	endproc;
	
	export proc void SetShadowOwner(CObjHndl p_xShadowOwner)
		m_xShadowOwner=p_xShadowOwner;
	endproc;
	
	export proc bool DoesCountInUnitLimit()
		return false;
	endproc;
	
	export proc void HealMe(real p_fAddHitpoints)
		return;
	endproc;
	
	export proc void AddKillerCount(int p_iAdd)
		if(m_xSpawningPool.IsValid())then
			var ^CFightingObj pxSpawningPool=cast<CFightingObj>(m_xSpawningPool.GetObj());
			if(pxSpawningPool!=null)then
				pxSpawningPool^.AddKillerCount(p_iAdd);
			endif;
		endif;
	endproc;
	
endclass;

class CCRpgNovice4 inherit CCRpgBaseChtr
	
	const int SHAOLIN_LIFE_DRAIN_ID=40146;
	const real SHAOLIN_LIFE_DRAIN_FREQ=3.0;
	const real SHAOLIN_LIFE_DRAIN_DMG=15.0;
	const int SHAOLIN_HEALING = 40147;
	const real TIMERID_SHAOLIN_FREQ = 2.0f;
	
	var real					m_fWDOT; // Weapon Duration Over Time
	
	constructor()
		m_xSink.m_xOnObjAdd=OnObjAdd;
		m_xSink.m_xOnObjRem=OnObjRem;
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		InitOwnRegion();
		var ^CFightingObj.CSpecialAbility pxAb=m_xAbilities.GetAbility("ranged_heal", true);
		if(pxAb!=null)then
			DeleteTimer(SHAOLIN_HEALING);
			m_xLastFunctionTime=CTimeMgr.Get().GetTime();
			CreateTimer(SHAOLIN_HEALING, CGameTimeSpan.OneSecond() * TIMERID_SHAOLIN_FREQ, true);
			m_xFunctionUnits.SetType("CHTR");
			m_xFunctionUnits.SetType("ANML",true);
			m_xFunctionUnits.SetType("VHCL",true);
			AddRangedBuff("owner_healing");
		endif;
	endproc;
	
	export proc void OnTechTreeChange(ref CStringArray p_rasChanges)
		super.OnTechTreeChange(p_rasChanges);
		// check player weapons, maybe there is something for us
		var string sPlayerTribe=GetPlayerTribeName();
		if(sPlayerTribe.IsEmpty())then return;endif;
		var string sAllWeaponPath="/Objects/"+sPlayerTribe+"/Weapons";
		var bool bSARangeEffect=false;
		var bool bSASelfHeal=false;
		var bool bSARangedHeal=false;
		var bool bSARangedReplenish=false;
		var bool bSpecialAbilities=false;
		var int i,iC;
		for(i=0) cond(i<p_rasChanges.NumEntries()) iter(i++) do
			var string sVal=p_rasChanges[i];
			if(sVal.Find(sAllWeaponPath)!=-1)then
				GetBestWeapon(null, true);
				UpdateWeaponBoni();
				AddTemporaryAttackBoni(GetDmg());
				AddTemporaryDefenseBoni(GetProtection());
			elseif(sVal.Find("special_abilities")>=0)then
				if(sVal.Find("RangeEffect")>=0)then
					bSARangeEffect=true;
				elseif(sVal.Find("ranged_heal")>=0)then
					bSARangedHeal=true;
				endif;
				bSpecialAbilities=true;
			endif;
		endfor;
		if(bSpecialAbilities)then
			AddRangedBuff("owner_healing");
		endif;
		if(bSARangedHeal)then
			var ^CFightingObj.CSpecialAbility pxAb=m_xAbilities.GetAbility("ranged_heal", true);
			if(pxAb!=null)then
				DeleteTimer(SHAOLIN_HEALING);
				m_xLastFunctionTime=CTimeMgr.Get().GetTime();
				CreateTimer(SHAOLIN_HEALING, CGameTimeSpan.OneSecond() * TIMERID_SHAOLIN_FREQ, true);
				m_xFunctionUnits.SetType("CHTR");
				m_xFunctionUnits.SetType("ANML",true);
				m_xFunctionUnits.SetType("VHCL",true);
			else
				DeleteTimer(SHAOLIN_HEALING);
			endif;
		endif;
	endproc;
	
	proc void DoShaolinHeal()
		var CGameTime xNow=CTimeMgr.Get().GetTime();
		var CGameTimeSpan xDT=xNow-m_xLastFunctionTime;
		var real fTime=xDT.GetSecondsF();
		if(fTime==0.0)then return; endif;
		m_xLastFunctionTime=xNow;
		if(fTime>TIMERID_SHAOLIN_FREQ+1.0f)then return; endif;
		var CObjList xUnits;
		var vec3 vPos=GetPos();
		CSrvWrap.GetDiplomacyMgr().AddMyFriendsToSearch(GetOwner(), m_xFunctionUnits);
		m_xFunctionUnits.RegionCircle(vPos,GetShaolinHealingRadius());
		if(!m_xFunctionUnits.Execute(xUnits))then return; endif;
		xUnits.Validate();
		var int i,iC=xUnits.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(xUnits[i]==GetHandle())then continue; endif;
			var ^CFightingObj pxFWalk=cast<CFightingObj>(xUnits[i].GetObj());
			if(pxFWalk!=null)then
				var real fValue=fTime*GetShaolinHealingAmount(pxFWalk);
				pxFWalk^.HealMe(fValue);
			endif;
		endfor;
	endproc;
	
	export proc real GetShaolinHealingAmount(^CFightingObj p_pxTarget)
		var ^CFightingObj.CSpecialAbility pxA=m_xAbilities.GetAbility("ranged_heal", true);
		if(pxA==null)then return -1.0; endif;
		var real fMod=p_pxTarget^.GetMaxHitpoints() * pxA^.GetValueF("mod") * 0.01;
		var real fAmount=(pxA^.GetValueF("amount") * GetTechTreeModifier("Healing",true))+GetTechTreeModifier("Healing",false);
		return fAmount+fMod;
	endproc;
	
	export proc real GetShaolinHealingRadius()
		var ^CFightingObj.CSpecialAbility pxA=m_xAbilities.GetAbility("ranged_heal", true);
		if(pxA!=null)then
			return pxA^.GetValueF("radius");
		endif;
		return -1.0f;
	endproc;
	
	proc bool OnObjAdd(CObjHndl p_xHndl)
		if(m_bToBeDeleted)then return false; endif;
		var ^CFightingObj pxO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxO==null)then return false; endif;
		if(pxO^.GetOwner()==GetOwner())then return false; endif;
		if(CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxO^.GetOwner(), GetOwner())&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxO^.GetOwner()))then return false; endif;
		if(!CSrvWrap.GetDiplomacyMgr().GetIsEnemy(GetOwner(), pxO^.GetOwner()))then return false; endif;
		if(pxO^.GetType()=="BLDG"||pxO^.GetType()=="NEST")then return false; endif;
		m_xRegionObjects.Include(p_xHndl);
		pxO^.AddRangedBuff("drain_life");
		return true;
	endproc;
	
	proc bool OnObjRem(CObjHndl p_xHndl)
		if(m_xRegionObjects.FindEntry(p_xHndl)==-1)then return false; endif;
		var ^CFightingObj pxO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxO==null)then return false; endif;
		pxO^.RemoveRangedBuff("drain_life");
		m_xRegionObjects.RemEntry(p_xHndl);
		return true;
	endproc;
	
	export proc void InitOwnRegion()
		if(!HasPersonalRegion())then
			AddRangedBuff("owner_livingstone");
			var vec3 vD; vD.SetXYZ(20.0, 20.0, 0.0);
			CreatePersonalRegion("DrainLife_"+GetName()+"_"+Random.GetInt().ToString(), vD, 010b);
			SetIgnoreSlope(true);
			DeleteTimer(SHAOLIN_LIFE_DRAIN_ID);
			CreateTimer(SHAOLIN_LIFE_DRAIN_ID,CGameTimeSpan.OneSecond()*SHAOLIN_LIFE_DRAIN_FREQ, true);
		endif;
	endproc;
	
	export proc bool AttackEnemy(^CFightingObj p_pxEnemy, vec3 p_vTarget, ref bool p_rbRotated)
		if(GetTransportObj().IsValid() && GetTransportObj().GetObj()^.GetType()=="SHIP")then
			return false;
		endif;
		if(p_pxEnemy!=null)then
			if(p_pxEnemy^.IsFlyingUnit() && !CanShootAir())then return false; endif;
		endif;
		RemoveCamouflageEffect("disg");
		var bool bPrimary=GetCurrentWeapon()==GetRightHandWeapon();
		if(bPrimary)then
			var string sFAnim=GetNextFightAnim();
			if(HasAnim(sFAnim))then
				m_fWDOT=0.0;
				if(!m_bTecInFightPos)then
//					m_fWDOT=0.4;
					m_fWDOT=0.0;
				endif;
				if(GetTransportObj().IsValid())then
					if(!IsOnOpenTransporter())then
						return false;
					endif;
					var Quat qAddRot=GetAdditionalRot();
					var vec3 vEnemyPos;
					if(p_pxEnemy!=null)then vEnemyPos=p_pxEnemy^.GetPos(); else vEnemyPos=p_vTarget; endif;
					var vec3 vEnemyDirection=(vEnemyPos-GetPos()).GetNormalized();
					vEnemyDirection.SetZ(0.0f);
					vEnemyDirection.Normalize();
					var vec3 vSelfDirection={0.0f,1.0f,0.0};
					var Quat qRot=GetRot();
					begin RFix;var vec3 vRot;qRot.ToVec3(vRot);vRot.SetX(0.0);vRot.SetY(0.0);qRot.FromVec3(vRot);end RFix;
					qRot.VecRotateU(vSelfDirection);
					qAddRot.VecRotateU(vSelfDirection);
					vSelfDirection.SetZ(0.0f);
					vSelfDirection.Normalize();
					var real fDifference=(vEnemyDirection-vSelfDirection).Abs2();
					if(fDifference>0.1f)then
						if(GetSecActionDesc()=="CAct")then
							var Quat qR;qR.FromXYDir(vEnemyDirection.GetX(),vEnemyDirection.GetY());
							qR/=qRot;
							SecRotAction(qR, fDifference*0.5);
						endif;
					endif;
					ShowWeapons("weapon_on");
					if(GetCurrentAnimName()!=sFAnim)then
						SetSLEAnim(sFAnim,9999,true,true);
					endif;
				else
					var real fAngle;
					if(p_pxEnemy!=null)then
						fAngle=GetAngleToR(p_pxEnemy);
					else
						fAngle=GetAngleToR(p_vTarget);
					endif;
					if(fAngle>Math.Pi()/8.0)then
						var Quat qRot;
						if(p_pxEnemy!=null)then
							qRot=GetAngleToQ(p_pxEnemy);
						else
							qRot=GetAngleToQ(p_vTarget);
						endif;
						m_bRotateSLEAction=true;
						ShowWeapons("weapon_on");
						RotateActionSLE(qRot,sFAnim, 0.4, 9999, !m_bTecInFightPos, true);
						p_rbRotated=false;
					else
						ShowWeapons("weapon_on");
						if(GetCurrentAnimName()!=sFAnim)then
							SetSLEAnim(sFAnim,9999,true,true);
						endif;
					endif;
				endif;
				if(!m_bTecInFightPos)then
					SetRndInvMaskSingleFlagInv(CFightingObj.VIS_FLAG_CHTR_ACTIVATED,true);
				endif;
				m_bTecInFightPos=true;
			else
				m_fWDOT=0.0;
				if(GetCurrentAnimName()!=sFAnim)then
					SetSLEAnim(sFAnim,9999,true,true);
				endif;
			endif;
			if(GetPenetration())then
				Penetrate(p_pxEnemy,p_vTarget);
				return false;
			else
				return true;
			endif;
		endif;
		return super.AttackEnemy(p_pxEnemy,p_vTarget, p_rbRotated);
	endproc;
	
	export proc void EndFight()
		SetRndInvMaskSingleFlagInv(CFightingObj.VIS_FLAG_CHTR_ACTIVATED,false);
		if(m_bTecInFightPos && HasAnim(GetFightAnim()))then
			m_bTecInFightPos=false;
			AnimAction(GetFightAnim(),0,false,true);
		endif;
		super.EndFight();
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(IsBerserking() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			)then return; endif;
		if(IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			)then return; endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("/novice_quicksand")!=(-1))then
				if(CheckSpecialActionTimer(p_sMiscParams))then
					var vec3 vPos=p_vPos;
					if(p_pxObject!=null)then
						vPos=p_pxObject^.GetPos();
					endif;
					CrashQuicksand(vPos,p_sMiscParams, p_bQ);
				endif;
			elseif(p_sMiscParams.Find("/novice_termites")!=(-1))then
				if(CheckSpecialActionTimer(p_sMiscParams))then
					CrashTermites(p_pxObject, p_sMiscParams, p_bA, p_bQ);
				endif;
			elseif(p_sMiscParams.Find("/novice_tornado")!=(-1))then
				if(CheckSpecialActionTimer(p_sMiscParams))then
					var vec3 vPos=p_vPos;
					if(p_pxObject!=null)then
						vPos=p_pxObject^.GetPos();
					endif;
					CrashTornado(vPos, p_sMiscParams, p_bQ);
				endif;
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	proc bool CrashTornado(vec3 p_vPos, string p_sPath, bool p_bQ)
		if(p_vPos=={0.0,0.0,0.0})then return false; endif;
		if(GetClassName()!="novice_lvl4")then return false; endif;
		var ^CCrashTornado pxTask=cast<CCrashTornado>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"CrashTrnd"));
		if(pxTask==null)then return false; endif;
		var bool bReturn=pxTask^.Init(GetHandle(),p_vPos, p_sPath);
		if(bReturn)then
			pxTask^.SetUserCommand(true);
			AddTask(pxTask,p_bQ);
		else
			pxTask^.GetFactory()^.FreeState(pxTask);
		endif;
		return bReturn;
	endproc;
	
	proc bool CrashQuicksand(vec3 p_vPos, string p_sPath, bool p_bQ)
		if(p_vPos=={0.0,0.0,0.0})then return false; endif;
		if(GetClassName()!="novice_lvl4")then return false; endif;
		var ^CCrashQuicksandTask pxTask=cast<CCrashQuicksandTask>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"CrashQckSndTsk"));
		if(pxTask==null)then return false; endif;
		var bool bReturn=pxTask^.Init(GetHandle(),p_vPos,p_sPath);
		if(bReturn)then
			pxTask^.SetUserCommand(true);
			AddTask(pxTask,p_bQ);
		else
			pxTask^.GetFactory()^.FreeState(pxTask);
		endif;
		return bReturn;
	endproc;
	
	proc bool CrashTermites(^CGameObj p_pxObject, string p_sPath, bool p_bAILock, bool p_bQ)
		if(p_pxObject==null)then return false; endif;
		if(GetClassName()!="novice_lvl4")then return false; endif;
		var ^CCrashTermites pxTask=cast<CCrashTermites>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"CrashTrmts"));
		if(pxTask==null)then return false; endif;
		var bool bReturn=pxTask^.Init(GetHandle(),p_pxObject^.GetHandle(), p_sPath);
		if(bReturn)then
			SetAILock(p_bAILock);
			pxTask^.SetUserCommand(true);
			AddTask(pxTask,p_bQ);
		else
			pxTask^.GetFactory()^.FreeState(pxTask);
		endif;
		return bReturn;
	endproc;
	
	export proc void AddAutoMoves()
		var int iIndex;
		iIndex=AddAutoSpecialMove("Actions/World/Moves/CHTR/novice_quicksand");
		m_axAutoSpecialMoves[iIndex].m_xOnCheckConditions=CheckQuicksand;
		m_axAutoSpecialMoves[iIndex].m_xOnStartAction=StartQuicksand;
		iIndex=AddAutoSpecialMove("Actions/World/Moves/CHTR/novice_termites");
		m_axAutoSpecialMoves[iIndex].m_xOnCheckConditions=CheckTermites;
		m_axAutoSpecialMoves[iIndex].m_xOnStartAction=StartTermites;
		iIndex=AddAutoSpecialMove("Actions/World/Moves/CHTR/novice_tornado");
		m_axAutoSpecialMoves[iIndex].m_xOnCheckConditions=CheckTornado;
		m_axAutoSpecialMoves[iIndex].m_xOnStartAction=StartTornado;
	endproc;
	
	proc bool CheckQuicksand(string p_sTTPath)
		if(!CheckSpecialActionTimer(p_sTTPath))then return false; endif;
		if(!GetAIBrain())then return false; endif;
		if(!m_xCurEnemy.IsValid())then return false; endif;
		if(m_xCurEnemy.GetObj()^.GetOwner()==GetOwner())then return false; endif;
		var ^CFightingObj pxObj=cast<CFightingObj>(m_xCurEnemy.GetObj());
		var bool bInvalid; var CObjHndl xInvalid;
		if(pxObj==null||pxObj^.GetHitpoints()<800.0f)then return false; endif;
		return true;
	endproc;
	
	proc void StartQuicksand(string p_sTTPath)
		if(p_sTTPath.Find("novice_quicksand")!=(-1)&&m_xCurEnemy.IsValid())then
			CrashQuicksand(m_xCurEnemy.GetObj()^.GetPos(),p_sTTPath,false);
		endif;
	endproc;
	
	proc bool CheckTermites(string p_sTTPath)
		if(!CheckSpecialActionTimer(p_sTTPath))then return false; endif;
		if(!GetAIBrain())then return false; endif;
		if(!m_xCurEnemy.IsValid())then return false; endif;
		if(m_xCurEnemy.GetObj()^.GetOwner()==GetOwner())then return false; endif;
		var ^CFightingObj pxObj=cast<CFightingObj>(m_xCurEnemy.GetObj());
		var bool bInvalid; var CObjHndl xInvalid;
		if(pxObj==null||pxObj^.GetHitpoints()<500.0f||pxObj^.GetType()!="BLDG")then return false; endif;
		return true;
	endproc;
	
	proc void StartTermites(string p_sTTPath)
		if(p_sTTPath.Find("novice_termites")!=(-1)&&m_xCurEnemy.IsValid())then
			CrashTermites(m_xCurEnemy.GetObj(),p_sTTPath,false,false);
		endif;
	endproc;
	
	proc bool CheckTornado(string p_sTTPath)
		if(!CheckSpecialActionTimer(p_sTTPath))then return false; endif;
		if(!GetAIBrain())then return false; endif;
		if(!m_xCurEnemy.IsValid())then return false; endif;
		if(m_xCurEnemy.GetObj()^.GetOwner()==GetOwner())then return false; endif;
		var ^CFightingObj pxObj=cast<CFightingObj>(m_xCurEnemy.GetObj());
		var bool bInvalid; var CObjHndl xInvalid;
		if(pxObj==null||pxObj^.GetHitpoints()<1000.0f)then return false; endif;
		return true;
	endproc;
	
	proc void StartTornado(string p_sTTPath)
		if(p_sTTPath.Find("novice_tornado")!=(-1)&&m_xCurEnemy.IsValid())then
			CrashTornado(m_xCurEnemy.GetObj()^.GetPos(),p_sTTPath,false);
		endif;
	endproc;
	
	export proc real GetWeaponDuration()
		return super.GetWeaponDuration()+m_fWDOT;
	endproc;
	
	export proc bool ImportantTask(string p_sTask)
		if(p_sTask=="CrashQuickS"||p_sTask=="CrashTermites"||p_sTask=="CrashTornado")then return true; endif;
		return super.ImportantTask(p_sTask);
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==SHAOLIN_HEALING)then
				DoShaolinHeal();
			elseif(iTimerID==SHAOLIN_LIFE_DRAIN_ID)then
				DrainEnemyLife();
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	proc void DrainEnemyLife()
		var real fDamageFactor=SHAOLIN_LIFE_DRAIN_DMG / GetDmg();
		var int i,iC=m_xRegionObjects.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFightingObj pxObj=cast<CFightingObj>(m_xRegionObjects[i].GetObj());
			if(pxObj==null)then continue; endif;
			if(pxObj^.GetType()=="BLDG"||pxObj^.GetType()=="NEST")then continue; endif;
			if(GetOwner()>-1 && (pxObj^.GetVisibleMask()&(01b<<GetOwner()))==00b)then continue; endif;
			pxObj^.ClearDamageCache();
			pxObj^.TakeDmg(this, false, fDamageFactor);
		endfor;
	endproc;

endclass;
	
class CCrashQuicksandTask inherit CSpecialActionTask
	
	var CObjHndl		m_xCharacter;
	var vec3				m_vTarget;
	var string			m_sState;
	var int					m_iRetryCounter;
	
	export constructor()
		SetName("CrashQuickS");
		SetCivil(false);
		m_iRetryCounter = 0;
	endconstructor;

	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xType="CQST";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xCharacter.DoKArc(pxArc^);
		(pxArc^) << m_vTarget;
		(pxArc^) << m_sState;
		(pxArc^) << m_iRetryCounter;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="CQST")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xCharacter.DoKArc(pxArc^);
			(pxArc^) << m_vTarget;
			(pxArc^) << m_sState;
			(pxArc^) << m_iRetryCounter;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool Init(CObjHndl p_xCharacter, vec3 p_vTarget, string p_sPath)
		m_sState="goto_target";
		if(!p_xCharacter.IsValid())then
			m_sState="EndTask";
			return false;
		endif;
		if(p_vTarget=={0.0,0.0,0.0})then
			m_sState="EndTask";
			return false;
		endif;
		m_xCharacter = p_xCharacter;
		m_vTarget = p_vTarget;
		SetSpecialActionPath(p_sPath);
		SetPrepareActionPath(p_xCharacter, p_sPath, true);
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		if(m_sState=="EndTask")then
			EndTask();
			return;
		endif;
		SetMaxCounter(1);
	endproc;
	
	proc void USLOnTick(int p_iTime)
		var ^CCharacter pxCharacter = cast<CCharacter>(m_xCharacter.GetObj());
		if(pxCharacter==null)then EndTask(); return; endif;
		if(m_sState == "goto_target")then
			var real fAttackRange = 30.0; //pxCharacter^.GetAttackRange();
			if(!IsInRange())then
				if(pxCharacter^.GetOnWall())then
					EndTask();
					return;
				endif;
				pxCharacter^.AdvanceAction(CObjHndl.Invalid(),fAttackRange,pxCharacter^.GetDefaultSpeed(),pxCharacter^.GetWalkSet(),5000000.0, pxCharacter^.GetPos(), m_vTarget);
			endif;
			m_sState = "throw";
		elseif(m_sState == "throw")then
			if(!IsInRange())then
				if(m_iRetryCounter>3)then
					EndTask();
				else
					m_iRetryCounter++;
					m_sState = "goto_target";
					return;
				endif;
			else
				if(!StartSpecialActionTimer(pxCharacter))then EndTask();return;endif;
				SetUnStoppable(true);
				var vec3 vCreate=m_vTarget;
				vCreate.SetZ(Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vCreate.GetX(),vCreate.GetY()),CSrvWrap.GetScapeMgr().GetSeaLevel()));
				var ^CCrashQuicksand pxTrap = cast<CCrashQuicksand>(CSrvWrap.GetObjMgr()^.CreateObj("crash_sandtrap",pxCharacter^.GetOwner(),vCreate));
				if(pxTrap!=null)then
					pxTrap^.SetPower(pxCharacter^.GetLevel().ToReal());
					pxTrap^.SetReady();
				endif;
				pxCharacter^.AnimAction("menace");
				m_sState = "exit";
				return;
			endif;
		elseif(m_sState == "exit")then
			SetUnStoppable(false);
			m_sState = "EndTask";
		elseif(m_sState == "EndTask")then
			EndTask();
			return;
		endif;
	endproc;
	
	proc bool IsInRange()
		var ^CCharacter pxCharacter = cast<CCharacter>(m_xCharacter.GetObj());
		if(pxCharacter==null)then return false; endif;
		var real fAttackRange	= 32.0; //pxCharacter^.GetAttackRange();
		var real fDistance		= (m_vTarget - pxCharacter^.GetPos()).Abs2S();
		return fDistance <= fAttackRange*fAttackRange;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
	endproc;
	
	export proc bool Break()
		SetPrepareActionPath(m_xCharacter, GetSpecialActionPath(), false);
		if (m_xCharacter.IsValid()) then
			m_xCharacter.GetObj()^.TerminateAction();
		endif;
		return true;
	endproc;
	
	export proc bool OnActionEnd(bool p_bBroken)
		if(p_bBroken)then
			ResetCounter();
		endif;
		return true;
	endproc;
	
	export proc void Skip()
	endproc;
	
	export proc void EndTask()
		SetPrepareActionPath(m_xCharacter, GetSpecialActionPath(), false);
		UpdateAggressionPos(m_xCharacter);
		super.EndTask();
	endproc;
	
endclass;

class CCrashQuicksand inherit CTrap
	
	const real	LIFETIME			= 30.0f;		// in seconds
	const real	RADIUS				= 10.0f;		// in meter
	const real	TRAPPED_TIME	= 10.0f;		// in seconds
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		m_bHidden=true;
		AddRangedBuff("owner_hold_units");
		SetHitable(false);
		SetSelectable(false);
		if(!p_bLoad)then
			SetVisible(true);
		endif;
	endproc;
	
	export proc void SetPower(real p_fLevel)
		m_fDuration=TRAPPED_TIME+(p_fLevel*2.0f);
		SetTrapRadius(RADIUS);
		m_pxQuery^.ClearTypes();
		m_pxQuery^.AddType("CHTR");
		m_pxQuery^.AddType("ANML");
		m_pxQuery^.AddType("VHCL");
		m_pxQuery^.AddType("SHIP");
		m_pxQuery^.SetProcs(OnHoldTrap,OnHoldRelease);
		StartDeleteTimer(LIFETIME+(p_fLevel*2.0f));
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		var int i, iCountRunningEffects=m_apxRunningEffects.NumEntries();
		for(i=0)cond(i<iCountRunningEffects)iter(i++)do
			var ^CTrap.CTrapEffect pxTE=m_apxRunningEffects[i];
			if(pxTE!=null)then
				pxTE^.SetProcs(OnHoldTrap,OnHoldRelease);
				pxTE^.ReInit();
			else
				return;
			endif;
		endfor;
	endproc;
	
	export proc void IgniteBuilding(real p_fDmg, int p_iMaxCount, CObjHndl p_xSource, int p_iSource)
		return;
	endproc;
	
	export proc bool CreateBuildingCorpse()
		return true;
	endproc;
	
	export proc string GetReportCode()
		return "";
	endproc;
	
endclass;

class CCrashTermites inherit CSpecialActionTask
	
	var CObjHndl		m_xCharacter;
	var CObjHndl		m_xTarget;
	var string			m_sState;
	var int					m_iRetryCounter;
	
	export constructor()
		SetName("CrashTermites");
		SetCivil(false);
		m_iRetryCounter = 0;
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xType="CTer";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xCharacter.DoKArc(pxArc^);
		m_xTarget.DoKArc(pxArc^);
		(pxArc^) << m_sState;
		(pxArc^) << m_iRetryCounter;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="CTer")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xCharacter.DoKArc(pxArc^);
			m_xTarget.DoKArc(pxArc^);
			(pxArc^) << m_sState;
			(pxArc^) << m_iRetryCounter;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool Init(CObjHndl p_xCharacter,CObjHndl p_xTarget, string p_sPath)
		m_sState="goto_target";
		if(!p_xCharacter.IsValid() || !p_xTarget.IsValid())then
			m_sState="EndTask";
			return false;
		endif;
		if(p_xTarget.GetObj()^.GetType()!="BLDG" || p_xTarget.GetObj()^.GetOwner()==p_xCharacter.GetObj()^.GetOwner())then
			m_sState="EndTask";
			return false;
		endif;
		SetSpecialActionPath(p_sPath);
		SetPrepareActionPath(p_xCharacter, p_sPath, true);
		m_xCharacter = p_xCharacter;
		m_xTarget = p_xTarget;
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		var ^CFightingObj pxFightingObj=cast<CFightingObj>(m_xCharacter.GetObj());
		if(pxFightingObj==null || !pxFightingObj^.CheckSpecialActionTimer(GetSpecialActionPath()))then
			EndTask();
			return;
		endif;
		if(m_sState=="EndTask")then
			EndTask();
		endif;
	endproc;
	
	proc void USLOnTick(int p_iTime)
		var ^CCharacter pxCharacter = cast<CCharacter>(m_xCharacter.GetObj());
		var ^CGameObj pxTarget = m_xTarget.GetObj();
		if(pxCharacter==null || pxTarget==null)then EndTask(); return; endif;
		if(pxCharacter^.GetEffectFlag(CFightingObj.EFFECT_AJE_CAMOUFLAGE))then
			pxCharacter^.SetEffectFlag(CFightingObj.EFFECT_AJE_CAMOUFLAGE, false);
		endif;
		if(m_sState == "goto_target")then
			var real fAttackRange = 20.0; //pxCharacter^.GetAttackRange();
			if(!IsInRange())then
				if(pxCharacter^.GetOnWall())then
					EndTask();return;
				endif;
				pxCharacter^.AdvanceAction(pxTarget^.GetHandle(),fAttackRange,pxCharacter^.GetDefaultSpeed());
			endif;
			m_sState = "throw";
		elseif(m_sState == "throw")then
			if(!StartSpecialActionTimer(pxCharacter))then EndTask();return;endif;
			SetUnStoppable(true);
			if(!IsInRange())then
				if(m_iRetryCounter>3)then
					EndTask();
				else
					m_iRetryCounter++;
					m_sState = "goto_target";
					return;
				endif;
			else
				//create Insects-Object and throw it...
				var ^CCrashTermitesObj pxInsects = cast<CCrashTermitesObj>(CSrvWrap.GetObjMgr()^.CreateObj("crash_termites",pxTarget^.GetOwner(),pxCharacter^.GetPos()));
				if(pxInsects!=null)then
					pxInsects^.Set(m_xTarget,CGameTimeSpan.OneSecond() * 120.0, 175+(25*(pxCharacter^.GetLevel()+1)),m_xCharacter,false,3);
				endif;
				pxCharacter^.AnimAction("point");
				m_sState = "EndTask";
				return;
			endif;
		elseif(m_sState == "EndTask")then
			SetUnStoppable(false);
			EndTask();
			return;
		endif;
	endproc;
	
	proc bool IsInRange()
		var ^CCharacter pxCharacter = cast<CCharacter>(m_xCharacter.GetObj());
		var ^CGameObj pxTarget = m_xTarget.GetObj();
		if(pxCharacter==null || pxTarget==null)then return false; endif;
		var real fTargetRadius = pxTarget^.GetRadius();
		var real fSelfRadius = pxCharacter^.GetRadius();
		var real fAttackRange = 20.0+fSelfRadius+fTargetRadius; //pxCharacter^.GetAttackRange();
		var real fDistance = (pxTarget^.GetPos() - pxCharacter^.GetPos()).Abs2S();
		return fDistance <= (fAttackRange+fTargetRadius)*(fAttackRange+fTargetRadius);
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
	endproc;
	
	export proc bool Break()
		if(GetUnStoppable())then
			return false;
		endif;
		SetPrepareActionPath(m_xCharacter, GetSpecialActionPath(), false);
		if (m_xCharacter.IsValid()) then
			m_xCharacter.GetObj()^.TerminateAction();
		endif;
		return true;
	endproc;
	
	export proc void Skip()
	endproc;
	
	export proc void EndTask()
		SetPrepareActionPath(m_xCharacter, GetSpecialActionPath(), false);
		UpdateAggressionPos(m_xCharacter);
		super.EndTask();
	endproc;
	
endclass;

class CCrashTermitesObj inherit CInsectsObj
	
	var int m_iTermitesOwner;
	
	proc void SetGfxNew()
		SetGFX("Aje_Termites");
	endproc;
	
	export proc void Set(CObjHndl p_xTarget, CGameTimeSpan p_xTime, int p_iEatCount,CObjHndl p_xOwner, bool p_bIllusion, int p_iType)
		super.Set(p_xTarget,p_xTime,p_iEatCount,p_xOwner,p_bIllusion,p_iType);
		m_iTermitesOwner=-1;
		var ^CGameObj pxOwner=m_xOwner.GetObj();
		if(pxOwner!=null)then
			m_iTermitesOwner=pxOwner^.GetOwner();
		endif;
	endproc;
	
	proc bool Eat()
		var CGameTime xNow = CTimeMgr.Get().GetTime();
		if((xNow - m_xStartTime) > m_xTime)then
			return false;
		endif;
		var ^CBuilding pxBuilding = cast<CBuilding>(m_xTarget.GetObj());
		if(pxBuilding==null)then
			return false;
		endif;
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel==null)then return false; endif;
		var ^CPlayer pxPlayer = pxLevel^.GetPlayer(GetOwner());
		if(pxPlayer==null)then return false; endif;
		pxBuilding^.TakeDirectMeleeDmg(m_iEatCount.ToReal(),m_iTermitesOwner,m_xOwner);
		CheckAttackMessage();
		return true;
	endproc;
	
endclass;
	
class CCrashTornado inherit CSpecialActionTask
	
	var CObjHndl		m_xCharacter;
	var vec3				m_vTarget;
	var string			m_sState;
	var int					m_iRetryCounter;
	
	export constructor()
		SetName("CrashTornado");
		SetCivil(false);
		m_iRetryCounter = 0;
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xType="CTor";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xCharacter.DoKArc(pxArc^);
		(pxArc^) << m_vTarget;
		(pxArc^) << m_sState;
		(pxArc^) << m_iRetryCounter;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="CTor")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xCharacter.DoKArc(pxArc^);
			(pxArc^) << m_vTarget;
			(pxArc^) << m_sState;
			(pxArc^) << m_iRetryCounter;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool Init(CObjHndl p_xCharacter, vec3 p_vTarget, string p_sPath)
		m_sState="goto_target";
		if(!p_xCharacter.IsValid())then
			m_sState="EndTask";
			return false;
		endif;
		if(p_vTarget=={0.0,0.0,0.0})then
			m_sState="EndTask";
			return false;
		endif;
		SetSpecialActionPath(p_sPath);
		SetPrepareActionPath(p_xCharacter, p_sPath, true);
		m_xCharacter = p_xCharacter;
		m_vTarget = p_vTarget;
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		var ^CFightingObj pxFightingObj=cast<CFightingObj>(m_xCharacter.GetObj());
		if(pxFightingObj==null || !pxFightingObj^.CheckSpecialActionTimer(GetSpecialActionPath()))then
			EndTask();
			return;
		endif;
		if(m_sState=="EndTask")then
			EndTask();
		endif;
	endproc;
	
	proc void USLOnTick(int p_iTime)
		var ^CCharacter pxCharacter = cast<CCharacter>(m_xCharacter.GetObj());
		if(pxCharacter==null)then EndTask(); return; endif;
		if(pxCharacter^.GetEffectFlag(CFightingObj.EFFECT_AJE_CAMOUFLAGE))then
			pxCharacter^.SetEffectFlag(CFightingObj.EFFECT_AJE_CAMOUFLAGE, false);
		endif;
		if(m_sState == "goto_target")then
			var real fAttackRange = 30.0; //pxCharacter^.GetAttackRange();
			if(!IsInRange())then
				if(pxCharacter^.GetOnWall())then
					EndTask();return;
				endif;
				pxCharacter^.AdvanceAction(CObjHndl.Invalid(),fAttackRange,pxCharacter^.GetDefaultSpeed(),pxCharacter^.GetWalkSet(),5000000.0, pxCharacter^.GetPos(), m_vTarget);
			endif;
			m_sState = "throw";
		elseif(m_sState == "throw")then
			if(!IsInRange())then
				if(m_iRetryCounter>3)then
					EndTask();
				else
					m_iRetryCounter++;
					m_sState = "goto_target";
					return;
				endif;
			else
				//create Tornado-Object and throw it...
				if(!StartSpecialActionTimer(pxCharacter))then EndTask();return;endif;
				SetUnStoppable(true);
				var ^CCrashTornadoObj pxTornado = cast<CCrashTornadoObj>(CSrvWrap.GetObjMgr()^.CreateObj("crash_tornado",pxCharacter^.GetOwner(),m_vTarget));
				if(pxTornado!=null)then
					pxTornado^.Set(m_vTarget,m_xCharacter,pxCharacter^.GetLevel()+1);
				endif;
				pxCharacter^.AnimAction("res_sm_jump");
				m_sState = "EndTask";
				return;
			endif;
		elseif(m_sState == "EndTask")then
			SetUnStoppable(false);
			EndTask();
			return;
		endif;
	endproc;
	
	proc bool IsInRange()
		var ^CCharacter pxCharacter = cast<CCharacter>(m_xCharacter.GetObj());
		if(pxCharacter==null)then return false; endif;
		var real fAttackRange = 32.0; //pxCharacter^.GetAttackRange();
		var real fDistance = (m_vTarget - pxCharacter^.GetPos()).Abs2S();
		return fDistance <= fAttackRange*fAttackRange;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
	endproc;
	
	export proc bool Break()
		if(GetUnStoppable())then
			return false;
		endif;
		SetPrepareActionPath(m_xCharacter, GetSpecialActionPath(), false);
		if(m_xCharacter.IsValid())then
			m_xCharacter.GetObj()^.TerminateAction();
		endif;
		return true;
	endproc;
	
	export proc void Skip()
	endproc;
	
	export proc void EndTask()
		SetPrepareActionPath(m_xCharacter, GetSpecialActionPath(), false);
		UpdateAggressionPos(m_xCharacter);
		super.EndTask();
	endproc;
	
endclass;

class CCrashTornadoObj inherit CGameObj

	const int			RAGE_TIMER			= 201;
	const real		RANGE						= 10.0;
	const real		TIME						= 10.0;
	const real		PRC_DAMAGE			= 0.50;
	const real		PRC_DAMAGE_BLDG	= 0.25;
	const real		MIN_DAMAGE			= 1000.0;
	const real		MAX_DAMAGE			= 2000.0;
	
	var vec3						m_vTarget;
	var CObjHndl				m_xActor;
	var CObjList				m_xMovableTargets;
	var CObjList				m_xNonMovableTargets;
	var CGameTimeSpan		m_xTime;
	var CGameTime				m_xStartTime;
	var real						m_fLevel;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		if(!CMirageSrvMgr.SDK())then
			var CFourCC xType="CTrn";
			var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
			var ^CArc pxArc=^(pxWalk^.GetArc());
			pxArc^ << m_fLevel;
			pxWalk^.Close();
		endif;
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="CTrn")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			pxArc^ << m_fLevel;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		InitEvents();
		SetHitable(false);
		SetSelectable(false);
		SetVisible(true);
	endproc;
	
	export proc void Set(vec3 p_vTarget,CObjHndl p_xOwner,int p_iLevel)
		m_vTarget = p_vTarget;
		m_xActor = p_xOwner;
		m_xTime = TIME;
		m_fLevel = p_iLevel.ToReal();
		m_xStartTime = CTimeMgr.Get().GetTime();
		m_xMovableTargets.Clear();
		m_xNonMovableTargets.Clear();
		var CObjList xList;
		if(GetOwner()>=0)then
			var ^CObjList pxEnemies=CSrvWrap.GetObjMgr()^.GetOwnerEnemyList(GetOwner());
			if(pxEnemies==null) then return; endif;
			pxEnemies^.CopySorted(xList, p_vTarget, RANGE+20.0);
			var CObjQuery xQuery;
			xQuery.SetOwner(-1);
			xQuery.SetType("CHTR");
			xQuery.SetType("SHIP",true);
			xQuery.SetType("ANML",true);
			xQuery.SetType("VHCL",true);
			xQuery.SetType("NEST",true);
			xQuery.SetType("FGHT",true);
			xQuery.RegionCircle(p_vTarget, RANGE+20.0);
			var CObjList xQueryList;
			if(xQuery.Execute(xQueryList))then
				xList.Include(xQueryList);
			endif;
			var int i, iC;
			iC = xList.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				var ^CFightingObj pxFight = cast<CFightingObj>(xList[i].GetObj());
				if(pxFight==null)then continue; endif;
				var real fDistance=(pxFight^.GetPos()-GetPos()).Abs2();
				fDistance-=pxFight^.GetCollisionRadius();
				if(fDistance>RANGE)then continue; endif;
				if(pxFight^.GetType()!="BLDG")then
					m_xMovableTargets.Include(xList[i]);
					pxFight^.SetTrappedHandle(GetHandle());
				else
					m_xNonMovableTargets.Include(xList[i]);
					pxFight^.SetTrappedHandle(GetHandle());
				endif;
			endfor;
		endif;
		SetAnim("swirl",3);
		Swirl();
		CreateTimer(RAGE_TIMER, CGameTimeSpan.OneSecond() * 1.0, true);
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if (p_rxEvtPtr.GetClass() == ms_xTimerClass) then
			if (p_rxEvtPtr.GetInt(0) == RAGE_TIMER ) then
				if(!Swirl())then
					DeleteTimer(RAGE_TIMER);
					FreeVictims();
					Delete();
				endif;
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	proc void FreeVictims()
		var int i, iC = m_xMovableTargets.NumEntries();
//		var CObjHndl xInvalid = CObjHndl.Invalid();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFightingObj pxFight = cast<CFightingObj>(m_xMovableTargets[i].GetObj());
			if(pxFight!=null)then
				pxFight^.UntrapHandle(GetHandle());
			endif;
		endfor;
		iC = m_xNonMovableTargets.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFightingObj pxFight = cast<CFightingObj>(m_xNonMovableTargets[i].GetObj());
			if(pxFight!=null)then
				pxFight^.UntrapHandle(GetHandle());
			endif;
		endfor;
	endproc;
	
	proc bool Swirl()
		var int iOwner=GetOwner();
		var CGameTime xNow = CTimeMgr.Get().GetTime();
		if((xNow - m_xStartTime) > m_xTime)then
			return false;
		endif;
		var real fALLDmg=(PRC_DAMAGE/m_xTime.GetSecondsF());
		var real fBLDGDmg=(PRC_DAMAGE_BLDG/m_xTime.GetSecondsF());
		var real fMinDmg=(MIN_DAMAGE/m_xTime.GetSecondsF())*m_fLevel;
		var real fMaxDmg=(MAX_DAMAGE/m_xTime.GetSecondsF())*m_fLevel;
		var int i, iC = m_xMovableTargets.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFightingObj pxFight = cast<CFightingObj>(m_xMovableTargets[i].GetObj());
			if(pxFight!=null)then
				var real fDmg=Math.Clamp(pxFight^.GetHitpoints()*fALLDmg,fMinDmg,fMaxDmg);
				pxFight^.TakeDirectMeleeDmg(fDmg,iOwner,m_xActor);
			endif;
		endfor;
		iC = m_xNonMovableTargets.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFightingObj pxFight = cast<CFightingObj>(m_xNonMovableTargets[i].GetObj());
			if(pxFight!=null)then
				var real fDmg=Math.Clamp(pxFight^.GetHitpoints()*fBLDGDmg,fMinDmg,fMaxDmg);
				pxFight^.TakeDirectMeleeDmg(fDmg,iOwner,m_xActor);
			endif;
		endfor;
		return true;
	endproc;
	
endclass;

class CCRpgPilot1 inherit CCRpgBaseChtr
	
//	export proc void OnInit(bool p_bLoad)
//		super.OnInit(p_bLoad);
//		var ^CRegionMgr pxRM=^(CSrvWrap.GetRegionMgr());
//		if(pxRM!=null)then
//			var string sName="pilot";
//			var ^CRegion pxRegion=pxRM^.GetRegion(sName);
//			if(pxRegion!=null)then
//				pxRegion^.BindToObj(GetHandle());
//				var real fRad=4.0f;
//				var vec3 vD;
//				vD.SetXYZ(fRad, fRad, 0.0);
//				var int i = pxRegion^.AddSubRegion(010b, GetPos(), vD);
//			endif;
//		endif;
//	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(IsBerserking() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			)then return; endif;
		if(IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			)then return; endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("pilot_fly")!=(-1))then
				if(CheckSpecialActionTimer(p_sMiscParams) && !GetTransportObj().IsValid())then
					PilotJetpack(p_vPos,p_sMiscParams,p_bQ);
				endif;
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	export proc bool PilotJetpack(vec3 p_vPos, string p_sTTPath, bool p_bQ)
		if(!CheckSpecialActionTimer(p_sTTPath))then return false; endif;
		if(p_vPos!={0.0,0.0,0.0})then
			var ^CPilotFly pxTask= cast<CPilotFly>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(), "PilotFly"));
			if(pxTask==null)then return false; endif;
			if(pxTask^.Init(GetHandle(), p_vPos,p_sTTPath))then
				pxTask^.SetUserCommand(true);
				AddTask(pxTask,p_bQ);
				return(true);
			else
				pxTask^.GetFactory()^.FreeState(pxTask);
			endif;
		endif;
		return(false);
	endproc;
	
endclass;

class CPilotFly inherit CSpecialActionTask
	
	var CObjHndl		m_xCharacter;
	var string			m_sState;
	var vec3				m_vJumpPos;
	const real			m_fMaxDistance =120.0f; //Maximum jumping distance.
	
	export constructor()
		SetName("PilotFly");
		SetCivil(false);
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xType="PJPa";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,2);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xCharacter.DoKArc(pxArc^);
		(pxArc^) << m_sState;
		(pxArc^) << m_vJumpPos;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="PJPa")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xCharacter.DoKArc(pxArc^);
			(pxArc^) << m_sState;
			(pxArc^) << m_vJumpPos;
			if(p_pxReaderNode^.GetVersion()==1)then
				var string sInvalid;
				(pxArc^) << sInvalid;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	//On Init
	export proc bool Init(CObjHndl p_xCharacter, vec3 p_vPos, string p_sTTPath)
		if(!p_xCharacter.IsValid())then
			m_sState="EndTask";
			return false;
		endif;
		SetSpecialActionPath(p_sTTPath);
		SetName("PilotFly");
		var ^CCharacter pxChar = cast<CCharacter>(p_xCharacter.GetObj());
		if(pxChar==null || pxChar^.GetClassName()!="pilot_lvl1")then return false; endif;
		m_xCharacter=p_xCharacter;
		m_vJumpPos=p_vPos;
		return true;
	endproc;
	
	//On Enter
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		var ^CFightingObj pxFightingObj=cast<CFightingObj>(m_xCharacter.GetObj());
		if(pxFightingObj==null || !pxFightingObj^.CheckSpecialActionTimer(GetSpecialActionPath()))then
			EndTask();
			return;
		endif;
		//Turn jetpack on
		if(m_xCharacter.IsValid())then
			var ^CCharacter pxCharacter = cast<CCharacter>(m_xCharacter.GetObj());
			if(pxCharacter==null)then EndTask();return;endif;
			var vec3 vPos;
			var vec3 vWay=m_vJumpPos-pxCharacter^.GetPos();
			var real fLength=vWay.Abs();
			if(fLength>m_fMaxDistance)then
				vWay.Normalize();
				var real fTemp=fLength-m_fMaxDistance;
				m_vJumpPos=GetAdoptedDest(pxCharacter^.GetPos(),m_vJumpPos,fTemp);
			endif;
		endif;
		m_sState="rotate_to_target";
	endproc;
	
	//OnTick
	proc void USLOnTick(int p_iTime)
		if(!m_xCharacter.IsValid())then EndTask();return;endif;
		var ^CCharacter pxCharacter = cast<CCharacter>(m_xCharacter.GetObj());
		if(pxCharacter==null)then EndTask();return;endif;
		if(m_sState=="rotate_to_target")then
			var vec3 vWay=m_vJumpPos-pxCharacter^.GetPos();
			var Quat qRot;
			qRot.FromXYDir(vWay.GetX(), vWay.GetY());
			pxCharacter^.RotateAction(qRot);
			m_sState="prepare_to_jump_3";
		elseif(m_sState=="prepare_to_jump_3")then
			if(pxCharacter^.IsJetPackOn())then
				if(!CSrvWrap.GetObjMgr()^.GetFreePos(m_vJumpPos, pxCharacter, m_vJumpPos, null, true, true))then
					EndTask();
					return;
				endif;
				m_vJumpPos.SetZ(Math.Max(CSrvWrap.GetScapeMgr().GetHeight(m_vJumpPos.GetX(),m_vJumpPos.GetY()),CSrvWrap.GetScapeMgr().GetSeaLevel())+CHu.FLYING_HEIGHT);
			else
				if(!pxCharacter^.GetFreePos(m_vJumpPos,15.0)) then
					EndTask();
					return;
				endif;
				m_vJumpPos.SetZ(CSrvWrap.GetScapeMgr().GetHeight(m_vJumpPos.GetX(), m_vJumpPos.GetY()));
			endif;
			if(!StartSpecialActionTimer(pxCharacter))then
				EndTask();
				return;
			endif;
			SetUnStoppable(true);
			var CFourCC xLink = "Back";
			pxCharacter^.SetLinkGFX(xLink,"Hu_Steam_Jet_Pack");
			pxCharacter^.AnimAction("sm_jump_01",0,true,false);
			m_sState="jump_to_target";
		elseif(m_sState=="jump_to_target")then
			pxCharacter^.SetSLEAnim("sm_jump_01",9999,false,false);
			pxCharacter^.RemoveFromWall();
			pxCharacter^.JetPackAction(m_vJumpPos);
			m_sState="land_1";
		elseif(m_sState=="land_1")then
			pxCharacter^.AnimAction("sm_jump_01",0,false,true);
			m_sState="land_2";
		elseif(m_sState=="land_2")then
			SetUnStoppable(false);
			pxCharacter^.ShowWeapons();
			m_sState="end";
		elseif(m_sState=="end")then
			EndTask();
		endif;
	endproc;
	
	//called to random the landing pos
	export proc void RandomizePos(ref vec3 po_rvPos)
		po_rvPos.SetX(po_rvPos.GetX() + (Random.GetInt()%10+1).ToReal());
		po_rvPos.SetY(po_rvPos.GetY() + (Random.GetInt()%10+1).ToReal());
		po_rvPos.SetZ(CSrvWrap.GetScapeMgr().GetHeight(po_rvPos.GetX(), po_rvPos.GetY()));
	endproc;
	
	//On Leave
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
	endproc;
	
	//End Action
	export proc bool Break()
		if(GetUnStoppable())then
			return false;
		endif;
		if(m_xCharacter.IsValid())then
			m_xCharacter.GetObj()^.TerminateAction();
		endif;
		return true;
	endproc;
	
	export proc void EndTask()
		UpdateAggressionPos(m_xCharacter);
		super.EndTask();
	endproc;

endclass;

class CCRpgPilot2 inherit CCRpgBaseVhcl
	
	const real FLYING_HEIGHT=17.0f;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetCanWalk(false);
		SetCanSwim(false);
		SetCanFly(true);
	endproc;
	
	export proc bool IsAbleToWalk()
		return true;
	endproc;
	
	export proc void SetIced(real p_fDuration,real p_fResistStart)
		return;
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj , ref CGameObj.CAdvanceActionParams p_rxParams)
		if(!p_xGoalObj.IsValid())then return; endif;
		var vec3 vObj=p_xGoalObj.GetObj()^.GetPos(), vOwn=GetPos(),vNew;
		var real fScape=Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vOwn.GetX(),vOwn.GetY()),m_fWaterLevel);
		var real fHeight=vOwn.GetZ()-fScape, fRange=GetAttackRange()/*+fHeight-GetRadius()*/;
		vOwn.SetZ(fScape);
		var vec3 vDirection=vOwn - vObj;
		vDirection.Normalize();
		vNew=GetPosInMap(vObj+(vDirection*fRange));
		WalkAction(vNew, GetMaxSpeed(), false);
//		WalkAction(vObj+(vDirection*fRange), GetMaxSpeed(), false);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption, ^CGameObj p_pxGoalObj, CFourCC p_xWalkSet, bool p_bUseMaterial)
//		var vec3 vPosition=p_vDest;
//		vPosition.SetZ(p_vDest.GetZ()+FLYING_HEIGHT);
		var vec3 vPosition=GetPosInMap(p_vDest);
		vPosition.SetZ(Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vPosition.GetX(),vPosition.GetY()),m_fWaterLevel)+FLYING_HEIGHT);
		return super.WalkAction(vPosition, p_iPrefSpeed, false, false, p_pxGoalObj, p_xWalkSet, p_bUseMaterial);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption, ^CGameObj p_pxGoalObj, CFourCC p_xWalkSet)
		return WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, p_bHeightAdaption, p_pxGoalObj, p_xWalkSet, true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption, ^CGameObj p_pxGoalObj)
		return WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, p_bHeightAdaption, p_pxGoalObj, GetWalkSet(), true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption)
		return WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, p_bHeightAdaption, null, GetWalkSet(), true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder)
		return WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, true, null, GetWalkSet(), true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed)
		return WalkAction(p_vDest, p_iPrefSpeed, true, true, null, GetWalkSet(), true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest)
		return WalkAction(p_vDest, GetMaxSpeed(), true, true, null, GetWalkSet(), true);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed, CFourCC p_xWalkSet, real p_fMaxRange, ref vec3 p_rvRootPos, ref vec3 p_rvGoalOffset)
		if(!p_xGoalObj.IsValid())then return; endif;
		var vec3 vObj=p_xGoalObj.GetObj()^.GetPos(), vOwn=GetPos(),vNew;
		var real fScape=Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vOwn.GetX(),vOwn.GetY()),m_fWaterLevel);
		var real fHeight=vOwn.GetZ()-fScape, fRange=GetAttackRange()/*+fHeight-GetRadius()*/;
		vOwn.SetZ(fScape);
		var vec3 vDirection=vOwn - vObj;
		vDirection.Normalize();
		vNew=GetPosInMap(vObj+(vDirection*fRange));
		WalkAction(vNew, GetMaxSpeed(), false);
//		WalkAction(vObj+(vDirection*fRange), GetMaxSpeed(), false);
//		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed, p_xWalkSet, p_fMaxRange, p_vRootPos, p_vGoalOffset);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed, CFourCC p_xWalkSet, real p_fMaxRange, ref vec3 p_rvRootPos)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed, p_xWalkSet, p_fMaxRange, p_rvRootPos);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed, CFourCC p_xWalkSet, real p_fMaxRange)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed, p_xWalkSet, p_fMaxRange);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed, CFourCC p_xWalkSet)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed, p_xWalkSet);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj)
		return super.AdvanceAction(p_xGoalObj);
	endproc;
	
	export proc void OnActionEnd(bool p_bBroken)
		super.OnActionEnd(p_bBroken);
		SetIdleAnim();
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		return false;
	endproc;
	
	export proc ^CArrow CreateProjectileAndShoot(^CFightingObj p_pxEnemy, vec3 p_vPos)
		return super.CreateProjectileAndShoot(p_pxEnemy, p_vPos);
	endproc;
	
	export proc ^CArrow CreateProjectileAndShoot(^CFightingObj p_pxEnemy, vec3 p_vPos, string p_sProjectileType)
		var ^CArrow pxArrow=super.CreateProjectileAndShoot(p_pxEnemy,p_vPos,p_sProjectileType);
		return pxArrow;
	endproc;
	
	export proc bool AttackEnemy(^CFightingObj p_pxEnemy, vec3 p_vTarget, ref bool p_rbRotated)
		if(p_pxEnemy!=null)then
			if(p_pxEnemy^.IsFlyingUnit() && !CanShootAir())then return false; endif;
		endif;
		var string sProj=GetProjectile();
		var string sFAnim=GetNextFightAnim();
		if(sFAnim.IsEmpty())then sFAnim="attack_front"; endif;
		var bool bProj=!sProj.IsEmpty();
		var bool bFAnim=!sFAnim.IsEmpty();
		begin Rotate;
			var real fAngle;
			var Quat qRot;
			if(p_pxEnemy!=null)then
				fAngle=GetAngleToR(p_pxEnemy);
				qRot=GetAngleToQ(p_pxEnemy);
			else
				fAngle=GetAngleToR(p_vTarget);
				qRot=GetAngleToQ(p_vTarget);
			endif;
			if(!bProj&&bFAnim)then
				if(GetPenetration()&&fAngle>(Math.Pi()/16.0f))then
					RotateActionSpeed(qRot,5.0);
					DoCaptainAttackAnim();
					p_rbRotated=true;
				elseif(fAngle>Math.Pi()/8.0)then
					RotateActionSpeed(qRot,5.0);
					DoCaptainAttackAnim();
					p_rbRotated=true;
					return true;
				endif;
			else
				if(fAngle>Math.Pi()/4.0||(GetPenetration()&&fAngle>Math.Pi()/16.0f))then
					RotateActionSpeed(qRot,5.0);
					p_rbRotated=true;
					return false;
				endif;
			endif;
		end Rotate;
		if(GetPenetration())then
			Penetrate(p_pxEnemy,p_vTarget);
			if(sFAnim!=""&&HasAnim(sFAnim))then
				SetAnim(sFAnim,1);
			endif;
			return false;
		elseif(bProj)then
			CreateProjectileAndShoot(p_pxEnemy, p_vTarget);
			if(sFAnim!=""&&HasAnim(sFAnim))then
				SetAnim(sFAnim,1);
			endif;
			DoCaptainAttackAnim();
			return false;
		elseif(bFAnim)then
			if(sFAnim!=""&&HasAnim(sFAnim))then
				SetAnim(sFAnim,1);
			endif;
			DoCaptainAttackAnim();
		endif;
		return true;
	endproc;
	
	export proc void AddFlyingHeight(vec3 p_vPos, real p_fSpeed)
		var real fHeight=20.0f;
		var vec3 vPos=GetPos();
		vPos.SetZ(vPos.GetZ()+fHeight);
		MoveAction(vPos, p_fSpeed);
	endproc;
	
	export proc void PutIntoPlace(vec3 p_vPos)
		var real fHeight=20.0f;
		var vec3 vPos=p_vPos;
		vPos.SetZ(vPos.GetZ()+fHeight);
		SetPos(vPos);
		return;
	endproc;
	
	export proc CFourCC GetProjectileLink()
		var CFourCC xL="Dri1";
		return xL;
	endproc;
	
	export proc void FountainHeal(^CGameObj p_pxO, bool p_bQ)
		if(p_pxO!=null)then
			if(GetNoHealing())then return; endif;
			var ^CFountainHeal pxFH=cast<CFountainHeal>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"FntnHeal"));
			if(pxFH!=null)then
				if(pxFH^.Init(GetHandle(), p_pxO^.GetHandle()))then
					pxFH^.SetUserCommand(true);
					AddTask(pxFH, p_bQ);
				else
					pxFH^.GetFactory()^.FreeState(pxFH);
				endif;
			endif;
		endif;
		return;
	endproc;
	
	export proc void BoardTransport(^CGameObj p_pxTransport, vec3 p_vPos, bool p_bUserCommand, string p_sParams, bool p_bGoTo, bool p_bQ)
		if(GetTransportObj().IsValid())then return; endif;
		if(p_pxTransport==null)then
			GoTo(p_vPos, true, GetDefaultSpeed(), true, true, GetOnWall(), false, true);
			return;
		endif;
		var ^CFightingObj pxFO=cast<CFightingObj>(p_pxTransport);
		if(pxFO!=null&&pxFO^.GetTransportObj().IsValid())then
			pxFO=cast<CFightingObj>(pxFO^.GetTransportObj().GetObj());
		endif;
		if(pxFO==null)then
			GoTo(p_vPos, true, GetDefaultSpeed(), true, true, GetOnWall(), false, true);
			return;
		endif;
		var int i1=pxFO^.GetOwner(), i2=GetOwner();
		if(i1!=i2)then
			var bool bAlliance = Math.Min(CSrvWrap.GetDiplomacyMgr().GetRelation(i1,i2),CSrvWrap.GetDiplomacyMgr().GetRelation(i2,i1))==2;
			if(!CMirageSrvMgr.Get().DiploLocked()||!bAlliance)then
				GoTo(p_vPos, true, GetDefaultSpeed(), true, true, GetOnWall(), false, true);
				return;
			endif;
		endif;
		var ^CTransportObj pxObj=cast<CTransportObj>(pxFO);
		if(pxObj==null)then
			GoTo(p_vPos, true, GetDefaultSpeed(), true, true, GetOnWall(), false, true);
			return;
		endif;
		if(pxObj^.HasUnboardEffect())then
			GoTo(p_vPos, true, GetDefaultSpeed(), true, true, GetOnWall(), false, true);
			return;
		endif;
		var int iSelfType=GetTransportClass();
		var int iTransporterType=pxObj^.GetTransportClass();
		var string sTaskName=GetCurTaskName();
		if(iTransporterType<=iSelfType)then
			if(sTaskName!="BoardTra")then
				GoTo(p_vPos, true, GetDefaultSpeed(), true, true, GetOnWall(), false, true);
			endif;
			return;
		endif;
		var bool bQ=false;
		if(p_sParams.Find("/Queued")!=-1)then
			bQ=true;
		endif;
		if(pxObj^.NumFreeSeats()<NeededSpaceInTransport())then
			if(sTaskName!="BoardTra"&&sTaskName!="BoardPas")then
				GoTo(p_vPos, true, GetDefaultSpeed(), true, true, GetOnWall(), false, true);
			endif;
			return;
		endif;
		var ^CManagedBoardingPassenger pxTask=cast<CManagedBoardingPassenger>(GetCurTask());
		if(pxTask!=null)then
			if(bQ)then
				return;
			else
				BreakEveryTask();
			endif;
		endif;
		pxTask=cast<CManagedBoardingPassenger>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"BoardPas"));
		if(pxTask!=null)then
			pxTask^.SetUserCommand(true);
			if(pxTask^.Init(GetHandle(),pxFO^.GetHandle()))then
				AddTask(pxTask,p_bQ||bQ);
			else
				pxTask^.GetFactory()^.FreeState(pxTask);
			endif;
		endif;
		return;
	endproc;
	
	export proc void PickUp(CObjHndl p_xItem,bool p_bQueue)
		if(!CCrashRPGMgr.ms_bFlyPickup)then
			var ^CGameObj pxO=p_xItem.GetObj();
			if(pxO!=null)then
				GoTo(pxO^.GetPos(), true, GetDefaultSpeed(), true, true, GetOnWall(), false, true);
			endif;
			return;
		endif;
		return super.PickUp(p_xItem, p_bQueue);
	endproc;
	
	export proc void CreateCorpse()
		var ^CCargolifterCorpse pxGameObj=cast<CCargolifterCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("cargolifter_corpse",GetOwner(),GetPos(),GetRotation()));
		if(pxGameObj!=null)then
			pxGameObj^.SetSource(this);
			pxGameObj^.Init(GetName(), 0.0001, 0.0);
		endif;
	endproc;
	
endclass;

class CCRpgPilot3 inherit CCRpgBaseAnml
	
	const real FLYING_HEIGHT=17.0f;
	
	constructor()
		m_xSink.m_xOnObjAdd=OnObjAdd;
		m_xSink.m_xOnObjRem=OnObjRem;
	endconstructor;
	
	proc bool OnObjAdd(CObjHndl p_xHndl)
		if(m_bToBeDeleted)then return false; endif;
		var ^CFightingObj pxO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxO==null)then return false; endif;
		if(pxO^.GetOwner()==GetOwner())then return false; endif;
		if(CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxO^.GetOwner(), GetOwner())&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxO^.GetOwner()))then return false; endif;
		if(!CSrvWrap.GetDiplomacyMgr().GetIsEnemy(GetOwner(), pxO^.GetOwner()))then return false; endif;
		if(pxO^.GetType()=="BLDG")then return false; endif;
		m_xRegionObjects.Include(p_xHndl);
		pxO^.SetMirageFlag(CFightingObj.MIRAGE_KING_JAW, true);
		return true;
	endproc;
	
	proc bool OnObjRem(CObjHndl p_xHndl)
		if(m_xRegionObjects.FindEntry(p_xHndl)==-1)then return false; endif;
		var ^CFightingObj pxO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxO==null)then return false; endif;
		pxO^.SetMirageFlag(CFightingObj.MIRAGE_KING_JAW, false);
		m_xRegionObjects.RemEntry(p_xHndl);
		return true;
	endproc;
	
	export proc void UpdateGfxFlags()
		if(GetClassName()=="pilot_lvl3")then
			if(!HasPersonalRegion())then
				var vec3 vD; vD.SetXYZ(20.0, 20.0, 0.0);
				CreatePersonalRegion("KeenEyes_"+GetName()+"_"+Random.GetInt().ToString(), vD, 010b);
				AddRangedBuff("owner_less_defense");
			endif;
		endif;
	endproc;
	
	export proc void InitOwnRegion()
		if(!HasPersonalRegion())then
			var vec3 vD; vD.SetXYZ(20.0, 20.0, 0.0);
			CreatePersonalRegion("KeenEyes_"+GetName()+"_"+Random.GetInt().ToString(), vD, 010b);
			AddRangedBuff("owner_less_defense");
		endif;
	endproc;
	
	export destructor()
	enddestructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetCanSwim(false);
		SetCanWalk(false);
		SetCanFly(true);
	endproc;
	
	export proc bool AttackEnemy(^CFightingObj p_pxEnemy, vec3 p_vTarget, ref bool p_rbRotated)
		if(p_pxEnemy!=null)then
			if(p_pxEnemy^.IsFlyingUnit() && !CanShootAir())then return false; endif;
		endif;
		var string sProj=GetProjectile();
		var string sFAnim="idle";
		if(!HasAnim(sFAnim))then sFAnim="attack_front"; endif;
		var bool bProj=!sProj.IsEmpty();
		var bool bFAnim=!sFAnim.IsEmpty();
		begin Rotate;
			var real fAngle;
			var Quat qRot;
			if(p_pxEnemy!=null)then
				fAngle=GetAngleToR(p_pxEnemy);
				qRot=GetAngleToQ(p_pxEnemy);
			else
				fAngle=GetAngleToR(p_vTarget);
				qRot=GetAngleToQ(p_vTarget);
			endif;
			if(!bProj&&bFAnim)then
				if(GetPenetration()&&fAngle>(Math.Pi()/16.0f))then
					RotateAction(qRot,"idle");
					DoCaptainAttackAnim();
					p_rbRotated=true;
				elseif(fAngle>Math.Pi()/8.0)then
					RotateAction(qRot,"idle");
					DoCaptainAttackAnim();
					p_rbRotated=true;
					return true;
				endif;
			else
				if(fAngle>Math.Pi()/4.0||(GetPenetration()&&fAngle>Math.Pi()/16.0f))then
					RotateActionSpeed(qRot,100.0);
					p_rbRotated=true;
					return false;
				endif;
			endif;
		end Rotate;
		if(bProj)then
			CreateProjectileAndShoot(p_pxEnemy, p_vTarget);
			if(sFAnim!=""&&HasAnim(sFAnim)&&GetCurrentAnimName()!=sFAnim)then
				SetAnim(sFAnim,3);
			endif;
			DoCaptainAttackAnim();
			return false;
		elseif(bFAnim)then
			if(sFAnim!=""&&HasAnim(sFAnim)&&GetCurrentAnimName()!=sFAnim)then
				SetAnim(sFAnim,3);
			endif;
			DoCaptainAttackAnim();
		endif;
		return true;
	endproc;
	
	export proc void DoCaptainAttackAnim()
		if(m_xCaptain.IsValid())then
			var ^CGameObj pxCaptain=m_xCaptain.GetObj();
			if(pxCaptain^.HasAnim(m_sCaptainAttackAnim))then
				pxCaptain^.SetAnim(m_sCaptainAttackAnim, 1);
			endif;
		endif;
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		po_rxLink="Ride";
		SetCaptainAnim("ride_idle_0");
		SetCaptainAttackAnim("ride_bow");
		return true;
	endproc;
	
	export proc void SetIdleAnim()
		DoCaptainAnim();
		if(HasAnim("idle")&&GetCurrentAnimName()!="idle")then
			SetAnim("idle",3);
		endif;
		return;
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj , ref CGameObj.CAdvanceActionParams p_rxParams)
		if(!p_xGoalObj.IsValid())then return; endif;
		var vec3 vObj=p_xGoalObj.GetObj()^.GetPos(), vOwn=GetPos(),vNew;
		var real fScape=Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vOwn.GetX(),vOwn.GetY()),m_fWaterLevel);
		var real fHeight=vOwn.GetZ()-fScape, fRange=GetAttackRange()/*+fHeight-GetRadius()*/;
		vOwn.SetZ(fScape);
		var vec3 vDirection=vOwn - vObj;
		vDirection.Normalize();
		vNew=GetPosInMap(vObj+(vDirection*fRange));
		WalkAction(vNew, GetMaxSpeed(), false);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption, ^CGameObj p_pxGoalObj, CFourCC p_xWalkSet, bool p_bUseMaterial)
		var vec3 vPosition=GetPosInMap(p_vDest);
		vPosition.SetZ(Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vPosition.GetX(),vPosition.GetY()),m_fWaterLevel)+FLYING_HEIGHT);
		return super.WalkAction(vPosition, p_iPrefSpeed, false, false, p_pxGoalObj, p_xWalkSet, p_bUseMaterial);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption, ^CGameObj p_pxGoalObj, CFourCC p_xWalkSet)
		return WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, p_bHeightAdaption, p_pxGoalObj, p_xWalkSet, true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption, ^CGameObj p_pxGoalObj)
		return WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, p_bHeightAdaption, p_pxGoalObj, GetWalkSet(), true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption)
		return WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, p_bHeightAdaption, null, GetWalkSet(), true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder)
		return WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, true, null, GetWalkSet(), true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed)
		return WalkAction(p_vDest, p_iPrefSpeed, true, true, null, GetWalkSet(), true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest)
		return WalkAction(p_vDest, GetMaxSpeed(), true, true, null, GetWalkSet(), true);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed, CFourCC p_xWalkSet, real p_fMaxRange, ref vec3 p_rvRootPos, ref vec3 p_rvGoalOffset)
		if(!p_xGoalObj.IsValid())then return; endif;
		var vec3 vObj=p_xGoalObj.GetObj()^.GetPos(), vOwn=GetPos(),vNew;
		var real fScape=Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vOwn.GetX(),vOwn.GetY()),m_fWaterLevel);
		var real fHeight=vOwn.GetZ()-fScape, fRange=GetAttackRange()/*+fHeight-GetRadius()*/;
		vOwn.SetZ(fScape);
		var vec3 vDirection=vOwn - vObj;
		vDirection.Normalize();
		vNew=GetPosInMap(vObj+(vDirection*fRange));
		WalkAction(vNew, GetMaxSpeed(), false);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed, CFourCC p_xWalkSet, real p_fMaxRange, ref vec3 p_rvRootPos)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed, p_xWalkSet, p_fMaxRange, p_rvRootPos);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed, CFourCC p_xWalkSet, real p_fMaxRange)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed, p_xWalkSet, p_fMaxRange);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed, CFourCC p_xWalkSet)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed, p_xWalkSet);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj)
		return super.AdvanceAction(p_xGoalObj);
	endproc;
	
	export proc void Die()
		if(!IsDead())then
			if(m_xTransportObj.IsValid())then
				var ^CTransportObj pxObj=cast<CTransportObj>(m_xTransportObj.GetObj());
				if(pxObj!=null)then
					pxObj^.OnDismount(GetHandle(),true,GetPos());
				endif;
			endif;
			m_fHitpoints=0.0f;
			SetVisible(false);
			SetDead(true);
			Delete();
		endif;
	endproc;
	
	export proc void StopEverything()
		super.StopEverything();
		SetIdleAnim();
	endproc;
	
	export proc void SetIced(real p_fDuration,real p_fResistStart)
		return;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(IsBerserking() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			 && !(p_sMiscParams.Find("/crash_rpg_levelup")!=-1))then return; endif;
		if(IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			 && !(p_sMiscParams.Find("/crash_rpg_levelup")!=-1))then return; endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("pilot_Snipershot")!=(-1))then
				if(CheckSpecialActionTimer(p_sMiscParams) && !GetTransportObj().IsValid())then
					PilotThrowdownshot(p_pxObject,p_sMiscParams,p_bQ);
				endif;
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	export proc bool PilotThrowdownshot(^CGameObj p_pxTarget, string p_sTTPath, bool p_bQ)
		if(p_pxTarget!=null)then
//			MemorizeCurrentFightState(p_pxTarget^.GetHandle(),true,false);
			var ^CPilotThrowdownshot pxTask= cast<CPilotThrowdownshot>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(), "PilotThrowdwn"));
			if(pxTask==null)then return false; endif;
			if(pxTask^.Init(GetHandle(), p_pxTarget^.GetHandle(), p_sTTPath))then
				pxTask^.SetUserCommand(true);
				AddTask(pxTask,p_bQ);
			else
				pxTask^.GetFactory()^.FreeState(pxTask);
			endif;
			return(true);
		else
			return(false);
		endif;
	endproc;
	
	export proc void FountainHeal(^CGameObj p_pxO, bool p_bQ)
		if(p_pxO!=null)then
			if(GetNoHealing())then return; endif;
			var ^CFountainHeal pxFH=cast<CFountainHeal>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"FntnHeal"));
			if(pxFH!=null)then
				if(pxFH^.Init(GetHandle(), p_pxO^.GetHandle()))then
					pxFH^.SetUserCommand(true);
					AddTask(pxFH, p_bQ);
				else
					pxFH^.GetFactory()^.FreeState(pxFH);
				endif;
			endif;
		endif;
		return;
	endproc;
	
	export proc void BoardTransport(^CGameObj p_pxTransport, vec3 p_vPos, bool p_bUserCommand, string p_sParams, bool p_bGoTo, bool p_bQ)
		if(GetTransportObj().IsValid())then return; endif;
		if(p_pxTransport==null)then
			GoTo(p_vPos, true, GetDefaultSpeed(), true, true, GetOnWall(), false, true);
			return;
		endif;
		var ^CFightingObj pxFO=cast<CFightingObj>(p_pxTransport);
		if(pxFO!=null&&pxFO^.GetTransportObj().IsValid())then
			pxFO=cast<CFightingObj>(pxFO^.GetTransportObj().GetObj());
		endif;
		if(pxFO==null)then
			GoTo(p_vPos, true, GetDefaultSpeed(), true, true, GetOnWall(), false, true);
			return;
		endif;
		var int i1=pxFO^.GetOwner(), i2=GetOwner();
		if(i1!=i2)then
			var bool bAlliance = Math.Min(CSrvWrap.GetDiplomacyMgr().GetRelation(i1,i2),CSrvWrap.GetDiplomacyMgr().GetRelation(i2,i1))==2;
			if(!CMirageSrvMgr.Get().DiploLocked()||!bAlliance)then
				GoTo(p_vPos, true, GetDefaultSpeed(), true, true, GetOnWall(), false, true);
				return;
			endif;
		endif;
		var ^CTransportObj pxObj=cast<CTransportObj>(pxFO);
		if(pxObj==null)then
			GoTo(p_vPos, true, GetDefaultSpeed(), true, true, GetOnWall(), false, true);
			return;
		endif;
		if(pxObj^.HasUnboardEffect())then
			GoTo(p_vPos, true, GetDefaultSpeed(), true, true, GetOnWall(), false, true);
			return;
		endif;
		var int iSelfType=GetTransportClass();
		var int iTransporterType=pxObj^.GetTransportClass();
		var string sTaskName=GetCurTaskName();
		if(iTransporterType<=iSelfType)then
			if(sTaskName!="BoardTra")then
				GoTo(p_vPos, true, GetDefaultSpeed(), true, true, GetOnWall(), false, true);
			endif;
			return;
		endif;
		var bool bQ=false;
		if(p_sParams.Find("/Queued")!=-1)then
			bQ=true;
		endif;
		if(pxObj^.NumFreeSeats()<NeededSpaceInTransport())then
			if(sTaskName!="BoardTra"&&sTaskName!="BoardPas")then
				GoTo(p_vPos, true, GetDefaultSpeed(), true, true, GetOnWall(), false, true);
			endif;
			return;
		endif;
		var ^CManagedBoardingPassenger pxTask=cast<CManagedBoardingPassenger>(GetCurTask());
		if(pxTask!=null)then
			if(bQ)then
				return;
			else
				BreakEveryTask();
			endif;
		endif;
		pxTask=cast<CManagedBoardingPassenger>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"BoardPas"));
		if(pxTask!=null)then
			pxTask^.SetUserCommand(true);
			if(pxTask^.Init(GetHandle(),pxFO^.GetHandle()))then
				AddTask(pxTask,p_bQ||bQ);
			else
				pxTask^.GetFactory()^.FreeState(pxTask);
			endif;
		endif;
		return;
	endproc;
	
	export proc void PickUp(CObjHndl p_xItem,bool p_bQueue)
		if(!CCrashRPGMgr.ms_bFlyPickup)then
			var ^CGameObj pxO=p_xItem.GetObj();
			if(pxO!=null)then
				GoTo(pxO^.GetPos(), true, GetDefaultSpeed(), true, true, GetOnWall(), false, true);
			endif;
			return;
		endif;
		return super.PickUp(p_xItem, p_bQueue);
	endproc;
	
	export proc void AddAutoMoves()
		var int iIndex;
		iIndex=AddAutoSpecialMove("Actions/World/Moves/ANML/pilot_Snipershot");
		m_axAutoSpecialMoves[iIndex].m_xOnCheckConditions=CheckSniperShoot;
		m_axAutoSpecialMoves[iIndex].m_xOnStartAction=StartSniperShoot;
	endproc;
	
	proc bool CheckSniperShoot(string p_sTTPath)
		if(!CheckSpecialActionTimer(p_sTTPath))then return false; endif;
		if(!GetAIBrain())then return false; endif;
		if(!m_xCurEnemy.IsValid())then return false; endif;
		if(m_xCurEnemy.GetObj()^.GetOwner()==GetOwner())then return false; endif;
		var ^CFightingObj pxObj=cast<CFightingObj>(m_xCurEnemy.GetObj());
		var bool bInvalid; var CObjHndl xInvalid;
		if(pxObj==null||pxObj^.GetHitpoints()<1200.0f)then return false; endif;
		return true;
	endproc;
	
	proc void StartSniperShoot(string p_sTTPath)
		if(p_sTTPath.Find("pilot_Snipershot")!=(-1)&&m_xCurEnemy.IsValid())then
			PilotThrowdownshot(m_xCurEnemy.GetObj(),p_sTTPath,false);
		endif;
	endproc;
	
	export proc void Delete()
		if(!m_bSkipCorpse)then
			var ^CPteranodonCorpse pxGameObj=cast<CPteranodonCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("aje_pteranodon_corpse",GetOwner(),GetPos(),GetRotation()));
			if(pxGameObj!=null)then
				pxGameObj^.SetSource(this);
				pxGameObj^.Init(GetName(), 0.0001);
			endif;
		endif;
		super.Delete();
	endproc;
	
	export proc bool ImportantTask(string p_sTask)
		if(p_sTask=="PilotThrowdownshot")then return true; endif;
		return super.ImportantTask(p_sTask);
	endproc;
	
endclass;

class CPilotThrowdownshot inherit CSpecialActionTask
	
	const real		m_fRange=50.0f; // Range of the weapon
	
	var CObjHndl	m_xFighter;
	var CObjHndl	m_xEnemy;
	var string		m_sState;
		
	export constructor()
		SetName("PilotThrowdownshot");
		SetCivil(false);
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xType="PTDS";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xFighter.DoKArc(pxArc^);
		m_xEnemy.DoKArc(pxArc^);
		(pxArc^) << m_sState;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="PTDS")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xFighter.DoKArc(pxArc^);
			m_xEnemy.DoKArc(pxArc^);
			(pxArc^) << m_sState;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool Init(CObjHndl p_xFighter, CObjHndl p_xEnemy, string p_sPath)
		if(!p_xFighter.IsValid()||!p_xEnemy.IsValid())then
			m_sState="EndTask";
			return false;
		endif;
		SetName("PilotThrowdownshot");
		SetSpecialActionPath(p_sPath);
		m_xFighter=p_xFighter;
		m_xEnemy=p_xEnemy;
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		var ^CFightingObj pxFightingObj=cast<CFightingObj>(m_xFighter.GetObj());
		if(pxFightingObj==null||!pxFightingObj^.CheckSpecialActionTimer(GetSpecialActionPath())||!m_xEnemy.IsValid())then
			EndTask();
			return;
		endif;
	endproc;
	
	proc void USLOnTick(int p_iTime)
		if(!m_xFighter.IsValid())then EndTask();return;endif;
		if(!m_xEnemy.IsValid())then	EndTask();return;endif;
		if(m_xFighter==m_xEnemy)then EndTask();return;endif;
		var ^CFightingObj pxFighter = cast<CFightingObj>(m_xFighter.GetObj());
		var ^CFightingObj pxEnemy = cast<CFightingObj>(m_xEnemy.GetObj());
		if(pxEnemy==null)then EndTask();return;endif;
		if(m_sState!="finished" && m_sState!="fire")then
			var bool bInvalid; var CObjHndl xInvalid;
			if(pxFighter^.IsInCombatRange(pxEnemy, bInvalid, xInvalid,m_fRange))then
				if(!pxEnemy^.IsDead())then
					var vec3 vTarget=GetLookAtRot(pxEnemy^.GetPos()-pxFighter^.GetPos());
					//pxFighter^.SetRotation(vTarget);
					pxFighter^.RotateToEnemy(pxEnemy,pxEnemy^.GetPos());
					m_sState="fire";
					return;
				endif;
			else
				if(pxFighter^.GetMovableInFight() && !pxFighter^.GetOnWall())then
					var CGameObj.CAdvanceActionParams xAWAP;
					xAWAP.m_fMinDistance=pxFighter^.GetAttackRange()-2.0f;
					xAWAP.m_iPrefSpeed=pxFighter^.GetMaxSpeed();
					xAWAP.m_fProjectileFallOff=pxFighter^.GetProjectileFallOffCone();
					pxFighter^.AdvanceAction(pxEnemy^.GetHandle(),xAWAP);
				else
					EndTask();
					return;
				endif;
			endif;
		endif;
		if(m_sState=="fire")then
			if(!StartSpecialActionTimer(pxFighter))then EndTask();return;endif;
			pxFighter^.MemorizeCurrentFightState(m_xEnemy,true,false);
			SetUnStoppable(true);
			var string sFAnim="idle";
			if(!pxFighter^.HasAnim(sFAnim))then sFAnim="attack_front"; endif;
			pxFighter^.CreateProjectileAndShoot(pxEnemy, pxEnemy^.GetPos(), "bela_special_arrow");
			if(sFAnim!=""&&pxFighter^.HasAnim(sFAnim)&&pxFighter^.GetCurrentAnimName()!=sFAnim)then
				pxFighter^.SetAnim(sFAnim,1);
				pxFighter^.AnimAction(sFAnim);
			endif;
			pxFighter^.DoCaptainAttackAnim();
			pxFighter^.CreateProjectileAndShoot(pxEnemy, pxEnemy^.GetPos(), "pilot_special_arrow");
			m_sState="finished";
		elseif(m_sState=="finished")then
			SetUnStoppable(false);
			pxFighter^.ShowWeapons();
			m_sState="EndTask";
			pxFighter^.ReturnToFight();
			return;
		elseif(m_sState=="EndTask")then
			EndTask();
			return;
		endif;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
	endproc;
	
	export proc bool Break()
		if(GetUnStoppable())then
			return false;
		endif;
		var ^CFightingObj pxObj = cast<CFightingObj>(m_xFighter.GetObj());
		if(pxObj!=null)then
			pxObj^.TerminateAction();
			if(m_sState!="finished")then
				pxObj^.ResetSpecialActionTimer("Actions/World/Moves/ANML/pilot_Snipershot");
			endif;
		endif;
		return true;
	endproc;
	
	//Updates enemy
	export proc void UpdateEnemy(CObjHndl p_xEnemy)
		if(p_xEnemy.IsValid())then
			m_xEnemy=p_xEnemy;
		endif;
	endproc;
	
	export proc void EndTask()
		UpdateAggressionPos(m_xFighter);
		super.EndTask();
	endproc;
	
endclass;

class CPilotSniperArrow inherit CArrow
	
	//BadGun Tuning: Pilot SniperShot
	const real MIN_DAMAGE = 500.0;
	const real MAX_DAMAGE = 2000.0;
	const real PERCENTAGE = 50.0;
	
	proc void OnImpact()
		ValidateObjects();
		if(m_pxEnemy!=null)then
//			m_pxEnemy^.SetPinnedDown(true,10.0);
			var real fDamage = Math.Clamp(m_pxEnemy^.GetHitpoints()*PERCENTAGE*0.01, MIN_DAMAGE, MAX_DAMAGE);
			if(m_pxFighter!=null)then
				m_pxEnemy^.TakeDirectDmg(fDamage,m_pxFighter^.GetOwner(),m_xFighter);
			else
				m_pxEnemy^.TakeDirectDmg(fDamage,m_xFighter);
			endif;
		endif;
		Delete();
	endproc;
	
	export proc void Set(^CFightingObj p_pxFighter, ^CFightingObj p_pxEnemy)
		Set(p_pxFighter, p_pxEnemy, p_pxFighter^.GetDmg(), p_pxFighter^.GetEndDmg(), p_pxFighter^.GetHitRange(), p_pxFighter^.GetProjectileJitter(), p_pxFighter^.GetProjectileDelay(), p_pxFighter^.GetWeaponSizeClass());
		m_bDirect = false;
	endproc;
	
	export proc void SetXtraDelay(^CFightingObj p_pxFighter, ^CFightingObj p_pxEnemy, real p_fXtraDelay)
		Set(p_pxFighter, p_pxEnemy, p_pxFighter^.GetDmg(), p_pxFighter^.GetEndDmg(), p_pxFighter^.GetHitRange(), p_pxFighter^.GetProjectileJitter(), p_pxFighter^.GetProjectileDelay() * p_fXtraDelay,p_pxFighter^.GetWeaponSizeClass());
		m_bDirect = false;
	endproc;
	
	export proc void Set(^CFightingObj p_pxFighter, ^CFightingObj p_pxEnemy, real p_fDmg)
		Set(p_pxFighter, p_pxEnemy, p_fDmg,  p_pxFighter^.GetEndDmg(), p_pxFighter^.GetHitRange(),  p_pxFighter^.GetProjectileJitter(), p_pxFighter^.GetProjectileDelay(),p_pxFighter^.GetWeaponSizeClass());
		m_bDirect = true;
	endproc;
	
	export proc void Set(^CFightingObj p_pxFighter, ^CFightingObj p_pxEnemy, real p_fDmg, real p_fEndDmg, real p_fHitRange)
		Set(p_pxFighter, p_pxEnemy, p_fDmg, p_fEndDmg, p_fHitRange,  p_pxFighter^.GetProjectileJitter(), 0.75f,p_pxFighter^.GetWeaponSizeClass());
	endproc;
	
	export proc void Set(^CFightingObj p_pxFighter, ^CFightingObj p_pxEnemy, real p_fDmg, real p_fEndDmg, real p_fHitRange, real p_fJitterRange, real p_fDelay, int p_iSizeClass)
		super.Set(p_pxFighter, p_pxEnemy, p_fDmg, p_fEndDmg, p_fHitRange, p_fJitterRange, 2.0, p_iSizeClass);
	endproc;
	
	export proc void Set(^CFightingObj p_pxFighter, ^CFightingObj p_pxEnemy, ^CBuildUpWeapon p_pxBuildUp)
		super.Set(p_pxFighter, p_pxEnemy, p_pxBuildUp);
	endproc;
	
endclass;

class CCRpgPilot4 inherit CCRpgBaseVhcl
	
	const real FLYING_HEIGHT=20.0f;
	
	var CObjList m_xPteras;
	var CObjList m_xCargos;
	var CObjHndl m_xBody;
	var string m_sPteraAnim;
	var string m_sCargoAnim;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
		if(p_pxReaderNode^.GetType()=="CRPF")then
			if(p_pxReaderNode^.GetVersion()>=1)then
				m_xPteras.DoKArc(pxArc^);
				m_xCargos.DoKArc(pxArc^);
				m_xBody.DoKArc(pxArc^);
//				(pxArc^) << m_bRotating;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="CRPF";
		var int iVersion=1;
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,iVersion);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xPteras.DoKArc(pxArc^);
		m_xCargos.DoKArc(pxArc^);
		m_xBody.DoKArc(pxArc^);
//		(pxArc^) << m_bRotating;
		pxWalk^.Close();
	endproc;
	
	export constructor()
		m_sPteraAnim="fly";
		m_sCargoAnim="standanim";
	endconstructor;
	
	export destructor()
		var int i,iC=m_xPteras.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(!m_xPteras[i].IsValid())then continue; endif;
			m_xPteras[i].GetObj()^.Delete();
		endfor;
		iC=m_xCargos.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(!m_xCargos[i].IsValid())then continue; endif;
			m_xCargos[i].GetObj()^.Delete();
		endfor;
		if(m_xBody.IsValid())then
			m_xBody.GetObj()^.Delete();
		endif;
	enddestructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetNoParticles(true);
		if(!p_bLoad)then
			if(m_xBody.IsValid())then
				m_xBody.GetObj()^.Delete();
			endif;
			var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("pilot_buildup",GetOwner(),GetPos(),GetRotation());
			if(pxO!=null)then
				var CFourCC xLink="psh2";
				pxO^.LinkAction(GetHandle(),xLink);
//				pxO^.FlexLinkAction(GetHandle(),xLink,0.0,{0.0,0.0,0.0},"swim_1");
				m_xBody=pxO^.GetHandle();
				AddGroupedChildren(pxO^.GetGuid());
			endif;
		endif;
		SetCanWalk(false);
		SetCanSwim(false);
		SetCanFly(true);
		GivePteras();
	endproc;
	
	export proc bool IsAbleToWalk()
		return true;
	endproc;
	
	export proc void SetIced(real p_fDuration,real p_fResistStart)
		return;
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj , ref CGameObj.CAdvanceActionParams p_rxParams)
		if(!p_xGoalObj.IsValid())then return; endif;
		var vec3 vObj=p_xGoalObj.GetObj()^.GetPos(), vOwn=GetPos(),vNew;
		var real fScape=Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vOwn.GetX(),vOwn.GetY()),m_fWaterLevel);
		var real fHeight=vOwn.GetZ()-fScape, fRange=GetAttackRange()/*+fHeight-GetRadius()*/;
		vOwn.SetZ(fScape);
		var vec3 vDirection=vOwn - vObj;
		vDirection.Normalize();
		vNew=GetPosInMap(vObj+(vDirection*fRange));
		WalkAction(vNew, GetMaxSpeed(), false);
//		PilotWalk(vNew);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption, ^CGameObj p_pxGoalObj, CFourCC p_xWalkSet, bool p_bUseMaterial)
		var vec3 vPosition=GetPosInMap(p_vDest);
		vPosition.SetZ(Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vPosition.GetX(),vPosition.GetY()),m_fWaterLevel)+FLYING_HEIGHT);
		DoAddonWalkAnim();
		return super.WalkAction(vPosition, p_iPrefSpeed, false, false, p_pxGoalObj, p_xWalkSet, p_bUseMaterial);
//		PilotWalk(vPosition);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption, ^CGameObj p_pxGoalObj, CFourCC p_xWalkSet)
		return WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, p_bHeightAdaption, p_pxGoalObj, p_xWalkSet, true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption, ^CGameObj p_pxGoalObj)
		return WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, p_bHeightAdaption, p_pxGoalObj, GetWalkSet(), true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption)
		return WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, p_bHeightAdaption, null, GetWalkSet(), true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder)
		return WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, true, null, GetWalkSet(), true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed)
		return WalkAction(p_vDest, p_iPrefSpeed, true, true, null, GetWalkSet(), true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest)
		return WalkAction(p_vDest, GetMaxSpeed(), true, true, null, GetWalkSet(), true);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed, CFourCC p_xWalkSet, real p_fMaxRange, ref vec3 p_rvRootPos, ref vec3 p_rvGoalOffset)
		if(!p_xGoalObj.IsValid())then return; endif;
		var vec3 vObj=p_xGoalObj.GetObj()^.GetPos(), vOwn=GetPos(),vNew;
		var real fScape=Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vOwn.GetX(),vOwn.GetY()),m_fWaterLevel);
		var real fHeight=vOwn.GetZ()-fScape, fRange=GetAttackRange()/*+fHeight-GetRadius()*/;
		vOwn.SetZ(fScape);
		var vec3 vDirection=vOwn - vObj;
		vDirection.Normalize();
		vNew=GetPosInMap(vObj+(vDirection*fRange));
		WalkAction(vNew, GetMaxSpeed(), false);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed, CFourCC p_xWalkSet, real p_fMaxRange, ref vec3 p_rvRootPos)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed, p_xWalkSet, p_fMaxRange, p_rvRootPos);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed, CFourCC p_xWalkSet, real p_fMaxRange)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed, p_xWalkSet, p_fMaxRange);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed, CFourCC p_xWalkSet)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed, p_xWalkSet);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj)
		return super.AdvanceAction(p_xGoalObj);
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		return false;
	endproc;
	
	export proc ^CArrow CreateProjectileAndShoot(^CFightingObj p_pxEnemy, vec3 p_vPos)
		return super.CreateProjectileAndShoot(p_pxEnemy, p_vPos);
	endproc;
	
	export proc ^CArrow CreateProjectileAndShoot(^CFightingObj p_pxEnemy, vec3 p_vPos, string p_sProjectileType)
		var ^CArrow pxArrow=super.CreateProjectileAndShoot(p_pxEnemy,p_vPos,p_sProjectileType);
		return pxArrow;
	endproc;
	
	export proc bool AttackEnemy(^CFightingObj p_pxEnemy, vec3 p_vTarget, ref bool p_rbRotated)
		if(p_pxEnemy!=null)then
			if(p_pxEnemy^.IsFlyingUnit() && !CanShootAir())then return false; endif;
		endif;
		var string sProj=GetProjectile();
		var string sFAnim=GetNextFightAnim();
		if(sFAnim.IsEmpty())then sFAnim="hit_back"; endif;
		var bool bProj=!sProj.IsEmpty();
		var bool bFAnim=!sFAnim.IsEmpty();
		if(bProj)then
			CreateProjectileAndShoot(p_pxEnemy, p_vTarget);
//			if(sFAnim!=""&&HasAnim(sFAnim))then
			if(sFAnim!="")then
				SetAnim(sFAnim,1);
			endif;
			DoCaptainAttackAnim();
			return false;
		elseif(bFAnim)then
//			if(sFAnim!=""&&HasAnim(sFAnim))then
			if(sFAnim!="")then
				SetAnim(sFAnim,1);
			endif;
			DoCaptainAttackAnim();
		endif;
		return true;
	endproc;
	
	export proc void AddFlyingHeight(vec3 p_vPos, real p_fSpeed)
		var real fHeight=20.0f;
		var vec3 vPos=GetPos();
		vPos.SetZ(vPos.GetZ()+fHeight);
		MoveAction(vPos, p_fSpeed);
	endproc;
	
	export proc void PutIntoPlace(vec3 p_vPos)
		var real fHeight=20.0f;
		var vec3 vPos=p_vPos;
		vPos.SetZ(vPos.GetZ()+fHeight);
		SetPos(vPos);
		return;
	endproc;
	
	export proc CFourCC GetProjectileLink()
//		var CFourCC xL="Dri1";
		var CFourCC xL="psh2";
		return xL;
	endproc;
	
	export proc void GivePteras()
		if(m_xPteras.NumEntries()==0&&m_xCargos.NumEntries()==0)then
//			var array string asLinks;
//			asLinks.AddEntry("Cr_1");
//			asLinks.AddEntry("Cr_2");
//			asLinks.AddEntry("Cr_3");
//			asLinks.AddEntry("Cr_4");
//			var string sLink="NONE";
			var string sLink="psh2";
			var array vec3 avOffsetsP, avOffsetsC;
			avOffsetsP.AddEntry({12.0, -10.0, 2.0});
			avOffsetsP.AddEntry({-12.0, 12.5, 2.0});
			avOffsetsP.AddEntry({12.0, 12.5, 2.0});
			avOffsetsP.AddEntry({-12.0, -10.0, 2.0 });
			avOffsetsC.AddEntry({11.5, -11.2, -3.0});
			avOffsetsC.AddEntry({-12.5, 11.3, -3.0});
			avOffsetsC.AddEntry({11.5, 11.3, -3.0});
			avOffsetsC.AddEntry({-12.5, -11.2, -3.0});
//			var ^CPropDB.CNode pxCustom;
//			var ^CPropDB pxSource=new CPropDB;
//			if(pxSource^.Load(CSrvWrap.GetUrsRelPath()+"/Data/Base/Scripts/Server/settings/source.txt"))then
//				pxCustom=^((pxSource^).GetRoot());
//				var int i;
//				var vec3 vTmp;
//				for(i=0)cond(i<4)iter(i++)do
//					vTmp.FromString(pxCustom^.GetValueS("cargo_"+i.ToString(),"[0.0 0.0 0.0]"));
//					avOffsetsC.AddEntry(vTmp);
//				endfor;
//			endif;
			var ^CGameObj pxObj;
			var CObjHndl xMe=GetHandle();
			var CFourCC xLink;
			var int i, iC=avOffsetsP.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				pxObj=CSrvWrap.GetObjMgr()^.CreateObj("crash_ptera",GetOwner());
				xLink=sLink;
				pxObj^.RideAction(xMe,xLink,avOffsetsP[i]);
				AddGroupedChildren(pxObj^.GetGuid());
				m_xPteras.Include(pxObj^.GetHandle());
				pxObj=CSrvWrap.GetObjMgr()^.CreateObj("crash_cargo",GetOwner());
				pxObj^.RideAction(xMe,xLink,avOffsetsC[i]);
				AddGroupedChildren(pxObj^.GetGuid());
				m_xCargos.Include(pxObj^.GetHandle());
			endfor;
//			if(!m_xBody.IsValid())then return; endif;
//			iC=asLinks.NumEntries();
//			for(i=0)cond(i<iC)iter(i++)do
//				pxObj=CSrvWrap.GetObjMgr()^.CreateObj("crash_cargo",GetOwner());
//				xLink=asLinks[i];
//				pxObj^.FlexLinkAction(m_xBody,xLink,0.0,{0.0,0.0,0.0},"walk_2");
//				AddGroupedChildren(pxObj^.GetGuid());
//				m_xCargos.Include(pxObj^.GetHandle());
//			endfor;
		endif;
		DoAddonIdleAnim();
	endproc;
	
	export proc void DoAddonIdleAnim()
		if(m_xBody.IsValid())then
			m_xBody.GetObj()^.SetAnim("standanim",3);
		endif;
		var int i,iC=m_xPteras.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(!m_xPteras[i].IsValid())then continue; endif;
			m_xPteras[i].GetObj()^.SetAnim("idle", 3);
		endfor;
		iC=m_xCargos.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(!m_xCargos[i].IsValid())then continue; endif;
			m_xCargos[i].GetObj()^.SetAnim("standanim", 3);
		endfor;
	endproc;
	
	export proc void DoAddonWalkAnim()
		if(m_xBody.IsValid())then
			m_xBody.GetObj()^.SetAnim("swim_1",3);
		endif;
		var int i,iC=m_xPteras.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(!m_xPteras[i].IsValid())then continue; endif;
			m_xPteras[i].GetObj()^.SetAnim("fly", 3);
		endfor;
		iC=m_xCargos.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(!m_xCargos[i].IsValid())then continue; endif;
			m_xCargos[i].GetObj()^.SetAnim("walk_2", 3);
		endfor;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			)then return; endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("/crash_barrage")!=-1)then
				if(CheckSpecialActionTimer(p_sMiscParams))then
					CrashBarrage("standanim",2.0,1.0,250.0,250.0,25.0,p_sMiscParams,p_bQ);
				endif;
			elseif(p_sMiscParams.Find("/crash_enchain")!= -1)then
				if(p_pxObject!=null && CheckSpecialActionTimer(p_sMiscParams))then
					CrashEnchain(p_pxObject^.GetHandle(), p_sMiscParams, p_bQ);
				endif;
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	export proc void AddAutoMoves()
		var int iIndex;
		iIndex=AddAutoSpecialMove("Actions/World/Moves/VHCL/crash_barrage");
		m_axAutoSpecialMoves[iIndex].m_xOnCheckConditions=CheckBarrage;
		m_axAutoSpecialMoves[iIndex].m_xOnStartAction=StartBarrage;
		iIndex=AddAutoSpecialMove("Actions/World/Moves/VHCL/crash_enchain");
		m_axAutoSpecialMoves[iIndex].m_xOnCheckConditions=CheckEnchain;
		m_axAutoSpecialMoves[iIndex].m_xOnStartAction=StartEnchain;
	endproc;
	
	proc bool CheckBarrage(string p_sTTPath)
		if(!CheckSpecialActionTimer(p_sTTPath))then return false; endif;
		if(!GetAIBrain())then return false; endif;
		var ^CObjList pxEnemies=CSrvWrap.GetObjMgr()^.GetOwnerEnemyList(GetOwner());
		if(pxEnemies==null)then return false; endif;
		var CObjList xList;
		pxEnemies^.CopySorted2D(xList,GetPos(),GetCollisionRadius()+15.0);
		if(xList.NumEntries()<3)then return false; endif;
		return true;
	endproc;
	
	proc void StartBarrage(string p_sTTPath)
		if(p_sTTPath.Find("/crash_barrage")!=-1)then
			CrashBarrage("standanim",2.0,1.0,250.0,250.0,25.0,p_sTTPath,false);
		endif;
	endproc;
	
	proc bool CheckEnchain(string p_sTTPath)
		if(!CheckSpecialActionTimer(p_sTTPath))then return false; endif;
		if(!GetAIBrain())then return false; endif;
		if(!m_xCurEnemy.IsValid())then return false; endif;
		if(m_xCurEnemy.GetObj()^.GetOwner()==GetOwner())then return false; endif;
		var ^CFightingObj pxObj=cast<CFightingObj>(m_xCurEnemy.GetObj());
		var bool bInvalid; var CObjHndl xInvalid;
		if(pxObj==null)then return false; endif;
		if(pxObj^.GetType()!="ANML"&&pxObj^.GetType()!="CHTR"&&pxObj^.GetType()!="SHIP"&&pxObj^.GetType()!="VHCL")then return false; endif;
		if(pxObj^.GetHitpoints()<1500.0f)then return false; endif;
		return true;
	endproc;
	
	proc void StartEnchain(string p_sTTPath)
		if(p_sTTPath.Find("crash_enchain")!=(-1)&&m_xCurEnemy.IsValid())then
			CrashEnchain(m_xCurEnemy,p_sTTPath,false);
		endif;
	endproc;
	
	export proc bool CrashEnchain(CObjHndl p_xTarget, string p_sMiscParams, bool p_bQ)
//		MemorizeCurrentFightState(p_xTarget,true,false);
		var ^CCrashEnchain pxTask=cast<CCrashEnchain>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"CrashEnchn"));
		if(pxTask==null)then return false; endif;
		var bool bReturn=pxTask^.Init(GetHandle(),p_xTarget,p_sMiscParams,20.0f);
		if(bReturn)then
			pxTask^.SetUserCommand(true);
			NewTaskFO(pxTask,p_bQ);
		else
			pxTask^.GetFactory()^.FreeState(pxTask);
		endif;
		return bReturn;
	endproc;
	
	export proc bool CrashBarrage(string p_sAnimName, real p_fTimeIntervall, real p_fTimeOffset, real p_fDamage, real p_fEndDamage, real p_fRange, string p_sTTPath, bool p_bQ)
//		MemorizeCurrentFightState(CObjHndl.Invalid(),false,false);
		var ^CCrashBarrage pxTask=cast<CCrashBarrage>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"CrashBrrg"));
		if(pxTask==null)then return false; endif;
		var bool bReturn=pxTask^.Init(GetHandle(),p_sAnimName, p_fTimeIntervall, p_fTimeOffset, p_fDamage, p_fEndDamage, p_fRange, p_sTTPath);
		if(!bReturn)then pxTask^.GetFactory()^.FreeState(pxTask); return false; endif;
		pxTask^.SetUserCommand(true);
		NewTaskFO(pxTask,p_bQ);
		return bReturn;
	endproc;
	
	export proc void PickUp(CObjHndl p_xItem,bool p_bQueue)
		if(!CCrashRPGMgr.ms_bFlyPickup)then
			var ^CGameObj pxO=p_xItem.GetObj();
			if(pxO!=null)then
				GoTo(pxO^.GetPos(), true, GetDefaultSpeed(), true, true, GetOnWall(), false, true);
			endif;
			return;
		endif;
		return super.PickUp(p_xItem, p_bQueue);
	endproc;
	
	export proc void FountainHeal(^CGameObj p_pxO, bool p_bQ)
		if(p_pxO!=null)then
			if(GetNoHealing())then return; endif;
			var ^CFountainHeal pxFH=cast<CFountainHeal>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"FntnHeal"));
			if(pxFH!=null)then
				if(pxFH^.Init(GetHandle(), p_pxO^.GetHandle()))then
					pxFH^.SetUserCommand(true);
					AddTask(pxFH, p_bQ);
				else
					pxFH^.GetFactory()^.FreeState(pxFH);
				endif;
			endif;
		endif;
		return;
	endproc;
	
	export proc void OnActionEnd(bool p_bBroken)
		super.OnActionEnd(p_bBroken);
		SetIdleAnim();
		DoAddonIdleAnim();
	endproc;
	
	export proc bool SetAnim(string p_sAnim, int p_iMod)
		return SetAnim(p_sAnim,p_iMod,1);
	endproc;
	
	export proc bool SetAnim(string p_sAnim, int p_iMod, int p_iStart)
		var real fDur;
		return SetAnim(p_sAnim,p_iMod,p_iStart,fDur);
	endproc;
	
	export proc bool SetAnim(string p_sAnim, int p_iMod, int p_iStart, ref real p_rfDur)
		if(m_xBody.IsValid()&&m_xBody.GetObj()^.HasAnim(p_sAnim))then
			m_xBody.GetObj()^.SetAnim("standanim",3);
		endif;
		if(!HasAnim(p_sAnim))then return false; endif;
		return super.SetAnim(p_sAnim,p_iMod,p_iStart,p_rfDur);
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		var CFourCC xLink="psh2";
		if(m_xBody.IsValid())then
			var ^CGameObj pxO=m_xBody.GetObj();
			if(pxO!=null)then
				pxO^.LinkAction(GetHandle(),xLink);
//				pxO^.FlexLinkAction(GetHandle(),xLink,0.0,{0.0,0.0,0.0},"swim_1");
				AddGroupedChildren(pxO^.GetGuid());
			endif;
		endif;
	endproc;
	
	export proc void StopEverything()
		super.StopEverything();
		SetIdleAnim();
	endproc;
	
	export proc void SetIdleAnim()
		SetAnim("standanim",3);
		DoAddonIdleAnim();
	endproc;
	
	export proc void BoardTransport(^CGameObj p_pxTransport, vec3 p_vPos, bool p_bUserCommand, string p_sParams, bool p_bGoTo, bool p_bQ)
		if(GetTransportObj().IsValid())then return; endif;
		if(p_pxTransport==null)then
			GoTo(p_vPos, true, GetDefaultSpeed(), true, true, GetOnWall(), false, true);
			return;
		endif;
		var ^CFightingObj pxFO=cast<CFightingObj>(p_pxTransport);
		if(pxFO!=null&&pxFO^.GetTransportObj().IsValid())then
			pxFO=cast<CFightingObj>(pxFO^.GetTransportObj().GetObj());
		endif;
		if(pxFO==null)then
			GoTo(p_vPos, true, GetDefaultSpeed(), true, true, GetOnWall(), false, true);
			return;
		endif;
		var int i1=pxFO^.GetOwner(), i2=GetOwner();
		if(i1!=i2)then
			var bool bAlliance = Math.Min(CSrvWrap.GetDiplomacyMgr().GetRelation(i1,i2),CSrvWrap.GetDiplomacyMgr().GetRelation(i2,i1))==2;
			if(!CMirageSrvMgr.Get().DiploLocked()||!bAlliance)then
				GoTo(p_vPos, true, GetDefaultSpeed(), true, true, GetOnWall(), false, true);
				return;
			endif;
		endif;
		var ^CTransportObj pxObj=cast<CTransportObj>(pxFO);
		if(pxObj==null)then
			GoTo(p_vPos, true, GetDefaultSpeed(), true, true, GetOnWall(), false, true);
			return;
		endif;
		if(pxObj^.HasUnboardEffect())then
			GoTo(p_vPos, true, GetDefaultSpeed(), true, true, GetOnWall(), false, true);
			return;
		endif;
		var int iSelfType=GetTransportClass();
		var int iTransporterType=pxObj^.GetTransportClass();
		var string sTaskName=GetCurTaskName();
		if(iTransporterType<=iSelfType)then
			if(sTaskName!="BoardTra")then
				GoTo(p_vPos, true, GetDefaultSpeed(), true, true, GetOnWall(), false, true);
			endif;
			return;
		endif;
		var bool bQ=false;
		if(p_sParams.Find("/Queued")!=-1)then
			bQ=true;
		endif;
		if(pxObj^.NumFreeSeats()<NeededSpaceInTransport())then
			if(sTaskName!="BoardTra"&&sTaskName!="BoardPas")then
				GoTo(p_vPos, true, GetDefaultSpeed(), true, true, GetOnWall(), false, true);
			endif;
			return;
		endif;
		var ^CManagedBoardingPassenger pxTask=cast<CManagedBoardingPassenger>(GetCurTask());
		if(pxTask!=null)then
			if(bQ)then
				return;
			else
				BreakEveryTask();
			endif;
		endif;
		pxTask=cast<CManagedBoardingPassenger>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"BoardPas"));
		if(pxTask!=null)then
			pxTask^.SetUserCommand(true);
			if(pxTask^.Init(GetHandle(),pxFO^.GetHandle()))then
				AddTask(pxTask,p_bQ||bQ);
			else
				pxTask^.GetFactory()^.FreeState(pxTask);
			endif;
		endif;
		return;
	endproc;
	
	export proc void CreateCorpse()
		var ^CPilotCorpse pxGameObj=cast<CPilotCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("pilot_corpse",GetOwner(),GetPos(),GetRotation()));
		if(pxGameObj!=null)then
			pxGameObj^.SetSource(this);
			pxGameObj^.Init(GetName(), 0.2);
		endif;
	endproc;
	
	export proc bool ImportantTask(string p_sTask)
		if(p_sTask=="CrashBarrage"||p_sTask=="CrashEnchain")then return true; endif;
		return super.ImportantTask(p_sTask);
	endproc;
	
	proc bool UpdateDestructionFlags()
		if(m_xBody.IsValid())then
			var ^CGameObj pxBody=m_xBody.GetObj();
			if(pxBody==null)then return false; endif;
//			if(pxBody^.GetConstructLevel()<4)then return false; endif;
			if(((GetHitpoints()!=0.0f)&&(GetMaxHitpoints()!=0.0f)))then
				var real fPercentage=GetHitpoints()/(GetMaxHitpoints()/100.0f);
				if(fPercentage<=25.0f)then
					if(pxBody^.GetDestructLevel()!=2)then
						pxBody^.SetDestructLevel(2);
					endif;
					return true;
				elseif(fPercentage<=50.0f)then
					if(pxBody^.GetDestructLevel()!=1)then
						pxBody^.SetDestructLevel(1);
					endif;
					return true;
				else
					pxBody^.SetDestructLevel(0);
					return true;
				endif;
			endif;
		endif;
		return true;
	endproc;
	
endclass;

class CPilotCorpse inherit CUniversalCorpse
	
	var int m_iState;
	var vec3 m_vHeight;
	export const int TIMERID_SINK=40011;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="CPiC")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			pxArc^ << m_iState;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="CPiC";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,2);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		pxArc^ << m_iState;
		pxWalk^.Close();
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetVisible(true);
	endproc;
	
	export proc void Init(string p_sName, real p_fDuration)
		SetName(p_sName);
		InvokeGenericSCEvent(40,4.0);
		if(p_fDuration>0.0)then
			CreateTimer(TIMER_DELETE, CGameTimeSpan.OneSecond()*p_fDuration,false);
		endif;
		PlayDestAnim();
		m_iState=1;
	endproc;
	
	export proc void OnActionEnd(bool p_bBroken)
		if(m_iState==2)then
			Delete();
		endif;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==TIMER_DELETE)then
				m_iState=2;
				var vec3 vP=GetPos();
				vP.SetZ(0.0f);
				MoveAction(vP, 15.0f);
			endif;
		endif;
	endproc;
	
	proc void PlayDestAnim()
		SetAnim("destroy",1);
	endproc;
	
	export destructor()
	enddestructor;
	
endclass;
	
class CCrashBarrage inherit CActionTask
	
	var CObjHndl		m_xHandle;
	var string			m_sState;
	var real				m_fTimeIntervall;
	var real				m_fTimeOffSet;
	var real				m_fAnimLength;
	var string			m_sAnim;
	var real				m_fDamage;
	var real				m_fEndDamage;
	var real				m_fRange;
	var bool				m_bCustom;
	
	export constructor()
		SetName("CrashBarrage");
		m_fDamage=0.0;
		m_fEndDamage=0.0;
		m_fRange=0.0;
		m_bCustom=false;
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xType="CrBa";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xHandle.DoKArc(pxArc^);
		(pxArc^) << m_sState;
		(pxArc^) << m_fTimeIntervall;
		(pxArc^) << m_fTimeOffSet;
		(pxArc^) << m_sAnim;
		(pxArc^) << m_fAnimLength;
		(pxArc^) << m_fDamage;
		(pxArc^) << m_fEndDamage;
		(pxArc^) << m_fRange;
		(pxArc^) << m_bCustom;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="CrBa")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xHandle.DoKArc(pxArc^);
			(pxArc^) << m_sState;
			(pxArc^) << m_fTimeIntervall;
			(pxArc^) << m_fTimeOffSet;
			(pxArc^) << m_sAnim;
			(pxArc^) << m_fAnimLength;
			(pxArc^) << m_fDamage;
			(pxArc^) << m_fEndDamage;
			(pxArc^) << m_fRange;
			(pxArc^) << m_bCustom;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool Init(CObjHndl p_xHandle, string p_sAnim, real p_fTimeIntervall, real p_fTimeOffSet, real p_fDamage, real p_fEndDamage, real p_fRange, string p_sPath)
		m_sState="start_anim";
		if(!p_xHandle.IsValid())then
			m_sState="EndTask";
			return false;
		endif;
		m_xHandle=p_xHandle;
		m_fTimeIntervall=p_fTimeIntervall;
		m_fTimeOffSet=p_fTimeOffSet;
		m_sAnim=p_sAnim;
		m_fDamage=p_fDamage;
		m_fEndDamage=p_fEndDamage;
		m_fRange=p_fRange;
		m_bCustom=true;
		SetSpecialActionPath(p_sPath);
		SetPrepareActionPath(p_xHandle, p_sPath, true);
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		if(m_sState=="EndTask")then
			EndTask();
		endif;
	endproc;
	
	export proc bool OnActionEnd(bool p_bBroken)
		return false;
	endproc;
	
	proc void USLOnTick(int p_iTime)
		var ^CVehicle pxHandle = cast<CVehicle>(m_xHandle.GetObj());
		if(pxHandle==null)then EndTask(); return; endif;
		var real fRange = pxHandle^.GetCollisionRadius()+5.0; // must NOT be 0.0;
		if(m_fRange!=0.0)then
			fRange = pxHandle^.GetCollisionRadius()+m_fRange;
		endif;
		var real fDmg = pxHandle^.GetDmg();
		var real fEndDmg = fDmg;
		if(m_sState == "start_anim")then
			if(!StartSpecialActionTimer(pxHandle))then
				m_sState=="EndTask";
				EndTask();
				return;
			endif;
			var vec3 vPos=pxHandle^.GetPos();
			vPos.SetZ(vPos.GetZ()-14.0f);
			var CObjHndl xHndl=pxHandle^.AddFX("fx_ninigi_seismo_barrage", 2.8, vPos);
			if(xHndl.IsValid())then
				xHndl.GetObj()^.SetAnim("anim",1);
			endif;
			pxHandle^.SetAnim(m_sAnim,1);
			pxHandle^.MemorizeCurrentFightState(CObjHndl.Invalid(),false,false);
			m_fAnimLength=pxHandle^.GetCurrentAnimLength();
			pxHandle^.WaitAction(m_fTimeOffSet);
			var int iOwner = pxHandle^.GetOwner();
			if(iOwner>=0)then
				var CObjList xList;
				var ^CObjList pxEnemies=CSrvWrap.GetObjMgr()^.GetOwnerEnemyList(iOwner);
				if(pxEnemies==null) then return; endif;
				pxEnemies^.CopySorted2D(xList, pxHandle^.GetPos(), fRange);
				var int i, iC = xList.NumEntries();
				for(i=0)cond(i<iC)iter(i++)do
					var ^CFightingObj pxFight = cast<CFightingObj>(xList[i].GetObj());
					if(pxFight!=null)then
						var ^CCharacter pxChar = cast<CCharacter>(pxFight);
						if(pxChar!=null && !pxChar^.GetTransportObj().IsValid())then
							var real fDiffTime=(((Random.GetInt()%100).ToReal())/100.0f) * m_fTimeIntervall;
							var real fDiffDistance=(Random.GetInt()%70).ToReal()/10.0;
							var vec3 vDir = (pxChar^.GetPos() - pxHandle^.GetPos());
							vDir.Normalize();
							vDir.SetZ(vDir.GetZ()+0.5);
							vDir.Normalize();
							pxChar^.SetHitReactionTimer(m_fTimeOffSet+fDiffTime,vDir*(3.0f+fDiffDistance));
						endif;
					endif;
				endfor;
			endif;
			m_sState = "do_damage";
		elseif(m_sState == "do_damage")then
			if(m_bCustom)then
				fDmg += m_fDamage;
				fEndDmg += m_fEndDamage;
			endif;
			var vec3 vPos=pxHandle^.GetPos();
			vPos.SetZ(Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vPos.GetX(),vPos.GetY()),pxHandle^.GetWaterHeight()));
			var ^CAreaDamage pxDmg = new CAreaDamage(fRange, fDmg, fEndDmg, pxHandle^.GetOwner(), vPos, 10, pxHandle);
			if(m_fAnimLength>m_fTimeOffSet)then
				pxHandle^.WaitAction(m_fAnimLength-m_fTimeOffSet);
			endif;
			m_sState = "finished";
		elseif(m_sState == "finished")then
			m_sState="EndTask";
			pxHandle^.ReturnToFight();
		elseif(m_sState == "EndTask")then
			EndTask();
			return;
		endif;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
	endproc;
	
	export proc void EndTask()
		SetPrepareActionPath(m_xHandle, GetSpecialActionPath(), false);
		super.EndTask();
	endproc;
	
	export proc bool Break()
		return false;
	endproc;
	
	export proc void Skip()
	endproc;
	
endclass;

class CCrashEnchain inherit CSpecialActionTask
	
	var CObjHndl	m_xActor;
	var CObjHndl	m_xTarget;
	var string		m_sState;
	var real			m_fDuration;
	
	export constructor()
		SetName("CrashEnchain");
		SetCivil(false);
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xType="CrEn";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xActor.DoKArc(pxArc^);
		m_xTarget.DoKArc(pxArc^);
		(pxArc^) << m_sState;
		(pxArc^) << m_fDuration;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="CrEn")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xActor.DoKArc(pxArc^);
			m_xTarget.DoKArc(pxArc^);
			(pxArc^) << m_sState;
			(pxArc^) << m_fDuration;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool Init(CObjHndl p_xActor,CObjHndl p_xTarget, string p_sPath, real p_fLength)
		m_xActor=p_xActor;
		m_xTarget=p_xTarget;
		if(!m_xActor.IsValid()||(!m_xTarget.IsValid()))then
			return false;
		endif;
		SetName("CrashEnchain");
		SetSpecialActionPath(p_sPath);
		SetPrepareActionPath(p_xActor, p_sPath, true);
		m_fDuration=p_fLength;
		m_sState="start";
		return true;
	endproc;

	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		var ^CFightingObj pxFightingObj=cast<CFightingObj>(m_xActor.GetObj());
		if(pxFightingObj==null || !pxFightingObj^.CheckSpecialActionTimer(GetSpecialActionPath()))then
			EndTask();
			return;
		endif;
	endproc;

	proc void USLOnTick(int p_iTime)
		if(!m_xActor.IsValid())then EndTask(); return; endif;
		if(!m_xTarget.IsValid())then EndTask(); return; endif;
		if(m_xActor==m_xTarget)then EndTask(); return; endif;
		var ^CFightingObj pxTarget=cast<CFightingObj>(m_xTarget.GetObj());
		var ^CTransportObj pxActor=cast<CTransportObj>(m_xActor.GetObj());
		if(pxTarget==null)then EndTask(); return; endif;
		if(pxActor==null)then EndTask(); return; endif;
		if(m_sState=="start")then
			var CObjHndl xInvalid; var bool bMinAttackRange;
			var bool bInCombatRange=pxActor^.IsInCombatRange(pxTarget, bMinAttackRange, xInvalid);
			if(bInCombatRange || bMinAttackRange)then
				m_sState="prepare";
			elseif(!pxActor^.FollowEnemy(pxTarget,false))then
				EndTask();
				return;
			endif;
		endif;
		if(m_sState=="prepare")then
			if(!StartSpecialActionTimer(pxActor))then EndTask(); return; endif;
			if(!pxTarget^.GetTransportObj().IsValid())then
				pxActor^.MemorizeCurrentFightState(m_xTarget,true,false);
				pxTarget^.SetTrappedTime(m_fDuration);
				pxTarget^.SetTrappedGfx("ninigi_seismo_trap",m_fDuration);
				pxTarget^.TerminateAction();
			endif;
			m_sState="EndTask";
			pxActor^.ReturnToFight();
			return;
		elseif(m_sState=="EndTask")then
			EndTask();
			return;
		endif;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
	endproc;
	
	export proc bool Break()
		SetPrepareActionPath(m_xActor, GetSpecialActionPath(), false);
		if(m_xActor.IsValid())then
			m_xActor.GetObj()^.TerminateAction();
		endif;
		return true;
	endproc;
	
	export proc void EndTask()
		SetPrepareActionPath(m_xActor, GetSpecialActionPath(), false);
		UpdateAggressionPos(m_xActor);
		super.EndTask();
	endproc;
	
endclass;

class CCRpgShooter1 inherit CCRpgBaseChtr
	
//	export proc void OnInit(bool p_bLoad)
//		super.OnInit(p_bLoad);
//		var ^CRegionMgr pxRM=^(CSrvWrap.GetRegionMgr());
//		if(pxRM!=null)then
//			var string sName="shooter";
//			var ^CRegion pxRegion=pxRM^.GetRegion(sName);
//			if(pxRegion!=null)then
//				pxRegion^.BindToObj(GetHandle());
//				var real fRad=4.0f;
//				var vec3 vD;
//				vD.SetXYZ(fRad, fRad, 0.0);
//				var int i = pxRegion^.AddSubRegion(010b, GetPos(), vD);
//			endif;
//		endif;
//	endproc;
	
endclass;

class CCRpgShooter2 inherit CCRpgBaseChtr
	
endclass;

class CCRpgShooter3 inherit CCRpgBaseChtr
	
	constructor()
		m_xSink.m_xOnObjAdd=OnObjAdd;
		m_xSink.m_xOnObjRem=OnObjRem;
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		InitOwnRegion();
	endproc;
	
	proc bool OnObjAdd(CObjHndl p_xHndl)
		if(m_bToBeDeleted)then return false; endif;
		var ^CFightingObj pxO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxO==null)then return false; endif;
		if(pxO^.GetOwner()==GetOwner() || pxO^.GetType()=="BLDG")then return false; endif;
		if(CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxO^.GetOwner(), GetOwner())&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxO^.GetOwner()))then return false; endif;
		if(!CSrvWrap.GetDiplomacyMgr().GetIsEnemy(GetOwner(), pxO^.GetOwner()))then return false; endif;
		m_xRegionObjects.Include(p_xHndl);
//		pxO^.ActivateCustomFilterAndUpdate(true,"/Filters/Special/Upgrades/lovelace_s0/RangeEffect");
		pxO^.ActivateCustomFilterAndUpdate(true,CNinigiTriceratops.FRIGHTENING_PATH);
//		pxO^.AddRangedBuff("less_attack_speed");
		pxO^.AddRangedBuff("lower_fighting_rate");
		return true;
	endproc;
	
	proc bool OnObjRem(CObjHndl p_xHndl)
		if(m_xRegionObjects.FindEntry(p_xHndl)==-1)then return false; endif;
		var ^CFightingObj pxO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxO==null)then return false; endif;
//		pxO^.ActivateCustomFilterAndUpdate(false,"/Filters/Special/Upgrades/lovelace_s0/RangeEffect");
		pxO^.ActivateCustomFilterAndUpdate(false,CNinigiTriceratops.FRIGHTENING_PATH);
//		pxO^.RemoveRangedBuff("less_attack_speed");
		pxO^.RemoveRangedBuff("lower_fighting_rate");
		m_xRegionObjects.RemEntry(p_xHndl);
		return true;
	endproc;
	
	export proc int GetProjectilesNumber()
		return 3;
	endproc;
	
	export proc void InitOwnRegion()
		if(!HasPersonalRegion())then
			var vec3 vD; vD.SetXYZ(25.0, 25.0, 0.0);
			CreatePersonalRegion("SlowHand_"+GetName()+"_"+Random.GetInt().ToString(), vD, 010b);
			AddRangedBuff("owner_less_attack_speed");
		endif;
	endproc;
	
endclass;

class CCRpgShooter4 inherit CCRpgBaseChtr
	
	const string CRASH_PIERCING_FILTER="/Filters/World/Upgrades/crash_rpg/minigun";
	const int CRASH_PIERCING_TIMER =40141;
	const int SHOOTER_VANISH=40149;
	const real SHOOTER_VANISH_TIME=15.0;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(IsBerserking() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			)then return; endif;
		if(IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			)then return; endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("/shooter_Minigun")!=(-1))then
				if(CheckSpecialActionTimer(p_sMiscParams) && !GetTransportObj().IsValid())then
					StartShooterMinigun(p_sMiscParams, p_pxObject, p_vPos, p_bQ);
				endif;
			elseif(p_sMiscParams.Find("/shooter_vanish")!=(-1))then
				if(CheckSpecialActionTimer(p_sMiscParams) && !GetTransportObj().IsValid())then
					StartShooterVanish(p_sMiscParams,p_bQ);
				endif;
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	export proc void AddPiercing(bool p_bOn, real p_fDur)
		if(HasTimer(CRASH_PIERCING_TIMER))then DeleteTimer(CRASH_PIERCING_TIMER); endif;
		ActivateCustomFilterAndUpdate(p_bOn,CRASH_PIERCING_FILTER);
		if(p_bOn)then
			CreateTimer(CRASH_PIERCING_TIMER,CGameTimeSpan.OneSecond()*p_fDur, false);
		endif;
		return;
	endproc;
	
	proc bool StartShooterMinigun(string p_sTTPath, ^CGameObj p_pxEnemy, vec3 p_vPos, bool p_bQ)
		if(GetIsVanished())then return false; endif;
		var CObjHndl xEnemy;
		if(p_pxEnemy!=null)then
			xEnemy=p_pxEnemy^.GetHandle();
		endif;
		var ^CShooterMinigun pxTask=cast<CShooterMinigun>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"ShooterM"));
		if(pxTask==null)then return false; endif;
		var bool bReturn=pxTask^.Init(GetHandle(), xEnemy, p_vPos, p_sTTPath);
		if(!bReturn)then pxTask^.GetFactory()^.FreeState(pxTask); return false; endif;
//		MemorizeCurrentFightState(xEnemy,true,false);
		pxTask^.SetUserCommand(true);
		AddTask(pxTask,p_bQ);
		return bReturn;
	endproc;
	
	export proc bool StartShooterVanish(string p_sPath, bool p_bQ)
		if(p_bQ)then
			return StartCustomTask("StartShooterVanish",p_sPath);
		endif;
		if(HasTimer(SHOOTER_VANISH))then return false; endif;
		CreateTimer(SHOOTER_VANISH, CGameTimeSpan.OneSecond()*SHOOTER_VANISH_TIME, false);
		if(!HasValidCamouflageEffect("hero"))then
			AddCamouflageEffect("hero");
		endif;
		AddSpecialActionTimer(p_sPath);
		SetIsVanished(true);
		var CObjHndl xHndl=AddFX("fx_ninja_disguise",-1.0);
		if(xHndl.IsValid())then
			var CFourCC xLink="";
			xHndl.GetObj()^.LinkAction(GetHandle(),xLink);
		endif;
		InvokeGenericSCEvent(32,0.1f);
		return true;
	endproc;
	
	export proc void EndShooterVanish()
		DeleteTimer(SHOOTER_VANISH);
		RemoveCamouflageEffect("hero");
		SetIsVanished(false);
		RemoveFX("fx_ninja_disguise");
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==CRASH_PIERCING_TIMER)then
				ActivateCustomFilterAndUpdate(false,CRASH_PIERCING_FILTER);
			elseif(iTimerID==SHOOTER_VANISH)then
				EndShooterVanish();
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	export proc void AddAutoMoves()
		var int iIndex;
		iIndex=AddAutoSpecialMove("Actions/World/Moves/CHTR/shooter_Minigun");
		m_axAutoSpecialMoves[iIndex].m_xOnCheckConditions=CheckMinigun;
		m_axAutoSpecialMoves[iIndex].m_xOnStartAction=StartMinigun;
	endproc;
	
	proc bool CheckMinigun(string p_sTTPath)
		if(!CheckSpecialActionTimer(p_sTTPath))then return false; endif;
		if(!GetAIBrain())then return false; endif;
		if(GetIsVanished())then return false; endif;
		if(!m_xCurEnemy.IsValid())then return false; endif;
		if(m_xCurEnemy.GetObj()^.GetOwner()==GetOwner())then return false; endif;
		var ^CFightingObj pxObj=cast<CFightingObj>(m_xCurEnemy.GetObj());
		var bool bInvalid; var CObjHndl xInvalid;
		if(pxObj==null||pxObj^.GetHitpoints()<1500.0f)then return false; endif;
		return true;
	endproc;
	
	proc void StartMinigun(string p_sTTPath)
		if(p_sTTPath.Find("shooter_Minigun")!=(-1)&&m_xCurEnemy.IsValid())then
			StartShooterMinigun(p_sTTPath,m_xCurEnemy.GetObj(),m_xCurEnemy.GetObj()^.GetPos(),false);
		endif;
	endproc;
	
	export proc void DoHPRelatedStuff()
		if(!m_bAIBrain)then return; endif;
		if((GetHitpoints()!=0.0f)&&(GetMaxHitpoints()!=0.0f))then
			var real fPercentage=GetHitpoints()/(GetMaxHitpoints()/100.0);
			if(fPercentage<=20.0f)then
				StartShooterVanish("Actions/World/Moves/CHTR/shooter_vanish",false);
			endif;
		endif;
		super.DoHPRelatedStuff();
	endproc;
	
endclass;

class CShooterMinigun inherit CSpecialActionTask
	
	//Badgun Tuning
	const real				RANGE = 35.0;
	const real				ANGLE = 30.0;
	const real				DAMAGE_PERCENT = 30.0;
	const real				DAMAGE_MINIMAL = 400.0;
	const real				DAMAGE_MAXIMAL = 4000.0;
	
	var CObjHndl			m_xCharacter;
	var CObjHndl			m_xTarget;
	var string				m_sState;
	var int						m_iRetryCounter;
	var array string	m_asValidTargets;
	var vec3					m_vPos;
	
	export constructor()
		SetName("ShooterM");
		SetCivil(false);
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xType="ShMG";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,2);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xCharacter.DoKArc(pxArc^);
		m_xTarget.DoKArc(pxArc^);
		(pxArc^) << m_sState;
		(pxArc^) << m_iRetryCounter;
		var int i,iC=m_asValidTargets.NumEntries();
		(pxArc^) << iC;
		for(i=0) cond(i<iC) iter(i++) do
			(pxArc^) << m_asValidTargets[i];
		endfor;
		(pxArc^) << m_vPos;
		pxWalk^.Close();
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="ShMG")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xCharacter.DoKArc(pxArc^);
			m_xTarget.DoKArc(pxArc^);
			(pxArc^) << m_sState;
			(pxArc^) << m_iRetryCounter;
			var int i,iC;
			(pxArc^) << iC;
			m_asValidTargets=iC;
			for(i=0) cond(i<iC) iter(i++) do
				(pxArc^) << m_asValidTargets[i];
			endfor;
			if(p_pxReaderNode^.GetVersion()>=2)then
				(pxArc^) << m_vPos;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool Init(CObjHndl p_xCharacter,CObjHndl p_xTarget, vec3 p_vPos, string p_sPath)
		m_sState="goto_target";
		if(!p_xCharacter.IsValid()||(!p_xTarget.IsValid() && p_vPos=={0.0,0.0,0.0}))then
			m_sState="EndTask";
			return false;
		endif;
		if(p_xTarget.IsValid() && p_xTarget.GetObj()^.GetOwner()==p_xCharacter.GetObj()^.GetOwner())then
			m_sState="EndTask";
			return false;
		endif;
		m_xCharacter = p_xCharacter;
		m_xTarget = p_xTarget;
		m_vPos = p_vPos;
		SetSpecialActionPath(p_sPath);
		return true;
	endproc;
	
	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		var ^CFightingObj pxFightingObj=cast<CFightingObj>(m_xCharacter.GetObj());
		if(pxFightingObj==null || !pxFightingObj^.CheckSpecialActionTimer(GetSpecialActionPath()))then
			EndTask();
			return;
		endif;
		if(m_sState=="EndTask")then
			EndTask();
		endif;
	endproc;
	
	proc void USLOnTick(int p_iTime)
		var ^CCRpgShooter4 pxCharacter = cast<CCRpgShooter4>(m_xCharacter.GetObj());
		var ^CFightingObj pxTarget = cast<CFightingObj>(m_xTarget.GetObj());
		if(pxCharacter==null)then EndTask(); return; endif;
		if(m_sState == "goto_target")then
			var real fAttackRange = pxCharacter^.GetAttackRange();
			var bool bInvalid;
			var CObjHndl xInvalid;
			if(pxTarget!=null)then
				if(!pxCharacter^.IsInCombatRange(pxTarget, bInvalid, xInvalid))then
					if(pxCharacter^.GetOnWall())then
						EndTask();return;
					endif;
					pxCharacter^.AdvanceAction(pxTarget^.GetHandle(),fAttackRange,pxCharacter^.GetDefaultSpeed());
				endif;
			else
				if(!pxCharacter^.IsInScapeCombatRange(m_vPos, bInvalid))then
					if(pxCharacter^.GetOnWall())then
						EndTask();return;
					endif;
					pxCharacter^.AdvanceAction(CObjHndl.Invalid(),fAttackRange,pxCharacter^.GetDefaultSpeed(),pxCharacter^.GetWalkSet(),99999.9,pxCharacter^.GetPos(),m_vPos);
				endif;
			endif;
			m_sState = "rotate";
		elseif(m_sState == "rotate")then
			var bool bInvalid;
			var CObjHndl xInvalid;
			var bool bContinue=false;
			if(pxTarget!=null)then
				if(!pxCharacter^.IsInCombatRange(pxTarget, bInvalid, xInvalid))then
					if(m_iRetryCounter>3)then
						EndTask();
						return;
					else
						m_iRetryCounter++;
						m_sState = "goto_target";
						return;
					endif;
				else
					m_vPos=pxTarget^.GetPos();
					bContinue=true;
				endif;
			else
				if(!pxCharacter^.IsInScapeCombatRange(m_vPos, bInvalid))then
					if(m_iRetryCounter>3)then
						EndTask();
						return;
					else
						m_iRetryCounter++;
						m_sState = "goto_target";
						return;
					endif;
				else
					bContinue=true;
				endif;
			endif;
			if(bContinue)then
				var vec3 vDir=m_vPos-pxCharacter^.GetPos();
				var Quat qTRot;
				qTRot.FromXYDir(vDir.GetX(),vDir.GetY());
				pxCharacter^.RotateAction(qTRot);
				pxCharacter^.AddPiercing(true,12.0f);
				m_sState = "throw";
				m_iRetryCounter = 0;
				if(!StartSpecialActionTimer(pxCharacter))then EndTask();return;endif;
				pxCharacter^.MemorizeCurrentFightState(m_xTarget,true,false);
				SetUnStoppable(true);
				return;
			endif;
		elseif(m_sState == "throw")then
			if(m_iRetryCounter>=15)then
				m_sState = "finished";
				pxCharacter^.SetSLEAnim("marksman_gatling", 4, false, true);
			else
				m_iRetryCounter++;
				pxCharacter^.SetSLEAnim("marksman_gatling", 10, m_iRetryCounter==0, false);
			endif;
			var CObjList xList;
			pxCharacter^.GetPenetratedObjs(m_vPos, RANGE, xList, ANGLE);
			var int i, iC = xList.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				var ^CFightingObj pxFight = cast<CFightingObj>(xList[i].GetObj());
				if(pxFight!=null)then
					var real fDamageFactor = (Math.Clamp((pxFight^.GetHitpoints()*0.01)*DAMAGE_PERCENT,DAMAGE_MINIMAL,DAMAGE_MAXIMAL) / pxCharacter^.GetDmg())*0.125;
					pxFight^.ClearDamageCache();
					pxFight^.TakeDmg(pxCharacter, true, fDamageFactor);
				endif;
			endfor;
		elseif(m_sState == "finished")then
			SetUnStoppable(false);
			m_sState="EndTask";
			pxCharacter^.AddPiercing(false,0.0f);
			pxCharacter^.ReturnToFight();
			return;
		elseif(m_sState == "finished")then
			EndTask();
			return;
		endif;
	endproc;
	
	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.USLOnLeave(p_pxFrom, p_pxTo);
		var ^CFightingObj pxFighter = cast<CFightingObj>(m_xCharacter.GetObj());
		if(pxFighter!=null)then
			pxFighter^.ShowWeapons();
		endif;
	endproc;
	
	export proc bool Break()
		if(GetUnStoppable())then
			return false;
		endif;
		if(m_xCharacter.IsValid()) then
			m_xCharacter.GetObj()^.TerminateAction();
			var ^CFightingObj pxFighter = cast<CFightingObj>(m_xCharacter.GetObj());
			if(pxFighter!=null)then
				pxFighter^.ShowWeapons();
			endif;
		endif;
		return true;
	endproc;
	
	export proc void Skip()
	endproc;
	
	export proc void EndTask()
		UpdateAggressionPos(m_xCharacter);
		var ^CCRpgShooter4 pxFighter = cast<CCRpgShooter4>(m_xCharacter.GetObj());
		if(pxFighter!=null)then
			pxFighter^.AddPiercing(false,0.0f);
			pxFighter^.ShowWeapons();
		endif;
		super.EndTask();
	endproc;
	
endclass;

class CRPGSpawner inherit CGameObj
	
	class CSpawnTask
		
		export var string m_sClass;
		export var string m_sForm;
		export var int m_iLevel;
		export var string m_sPassengers;
		export var string m_sPostTask;
		export var real m_fPostTime;
		
	endclass;
	
	class CSpawnQueue
		
		var array CSpawnTask m_axSpawnTasks;
		
		export proc void Push(CRPGSpawner.CSpawnTask p_xSpawnTask)
			m_axSpawnTasks.AddEntry(p_xSpawnTask);
		endproc;
		
		export proc ^CRPGSpawner.CSpawnTask Push()
			return ^(m_axSpawnTasks.NewEntryRef());
		endproc;
		
		export proc CRPGSpawner.CSpawnTask Pop()
			var CSpawnTask xSpawnTask = m_axSpawnTasks[0];
			m_axSpawnTasks.DeleteEntry(0);
			return xSpawnTask;
		endproc;
		
		export proc int NumEntries()
			return m_axSpawnTasks.NumEntries();
		endproc;
		
		export proc bool IsEmpty()
			return m_axSpawnTasks.NumEntries()<=0;
		endproc;
		
		export proc void DoKArc(ref CArc p_rxArc)
			var int iC = m_axSpawnTasks.NumEntries();
			p_rxArc << iC;
			m_axSpawnTasks = iC;
			var int i;
			for(i=0)cond(i<iC)iter(++i)do
				p_rxArc << m_axSpawnTasks[i].m_sClass;
				p_rxArc << m_axSpawnTasks[i].m_iLevel;
				p_rxArc << m_axSpawnTasks[i].m_sForm;
				p_rxArc << m_axSpawnTasks[i].m_sPassengers;
				p_rxArc << m_axSpawnTasks[i].m_sPostTask;
				p_rxArc << m_axSpawnTasks[i].m_fPostTime;
			endfor;
		endproc;
		
	endclass;
	
	var CSpawnQueue m_xSpawns;
	var real m_fSpawnDelay;
	var vec3 m_vSpawnPos;
//	var vec3 m_vExitPos;
//	var vec3 m_vDestination;
	var vec3 m_vTarget;
	var int m_iSpeed;
	var int m_iOwner;
	var CObjHndl m_xSource;
	
	const int CRASH_SPAWNER_ID = 40128;
	
	export constructor()
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		InitEvents();
		SetVisible(false);
	endproc;
	
	export proc void SetSpawnDelay(real p_fDelay)
		m_fSpawnDelay = p_fDelay;
	endproc;
	
	export proc void SetSpawnPos(vec3 p_vPos)
		m_vSpawnPos = p_vPos;
	endproc;
	
//	export proc void SetExitPos(vec3 p_vPos)
//		m_vExitPos = p_vPos;
//	endproc;
	
//	export proc void SetDestinationPos(vec3 p_vPos)
//		m_vDestination = p_vPos;
//	endproc;
	
	export proc void SetSourceObj(CObjHndl p_xSource)
		m_xSource=p_xSource;
	endproc;
	
	export proc void SetOwner(int p_iOwner)
		m_iOwner=p_iOwner;
	endproc;
	
	export proc void SetSpeed(int p_iSpeed)
		m_iSpeed=p_iSpeed;
	endproc;
	
	export proc void SetTargetPos(vec3 p_vPos)
		m_vTarget = p_vPos;
	endproc;
	
	export proc void AddSpawnTask(string p_sClass, int p_iLevel, string p_sForm, string p_sPassengers, real p_fPostTime, string p_sPostTask)
		var ^CSpawnTask pxSpawnTask = m_xSpawns.Push();
		pxSpawnTask^.m_sClass = p_sClass;
		pxSpawnTask^.m_iLevel = Math.Clamp(p_iLevel-1,0,4);
		pxSpawnTask^.m_sForm = p_sForm;
		pxSpawnTask^.m_sPassengers = p_sPassengers;
		pxSpawnTask^.m_fPostTime = p_fPostTime;
		pxSpawnTask^.m_sPostTask = p_sPostTask;
	endproc;

	export proc void StartProduction()
		var bool bSkip=false;
		if(m_fSpawnDelay==-1.0)then
			bSkip=true;
			m_fSpawnDelay=OpenDoorLength();
		endif;
		StartSpawn(bSkip);
	endproc;
	
	export proc void StartSpawn(bool p_bSkip)
		var bool bC=m_xSpawns.NumEntries()>1;
		if(!p_bSkip)then
			OpenDoor();
		endif;
		Spawn();
		if(bC)then
			DeleteTimer(CRASH_SPAWNER_ID);
			CreateTimer(CRASH_SPAWNER_ID, CGameTimeSpan.OneSecond() * m_fSpawnDelay, true);
		else
			Delete();
		endif;
	endproc;
	
	export proc void Spawn()
		if(!m_xSpawns.IsEmpty())then
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return; endif;
			var ^CStatisticMgr pxStatisticMgr=^(pxLevel^.GetStatisticMgr());
			var bool bMount=false;
			var CObjList xPass, xTmp;
			var CObjHndl xInv;
			var vec3 vTmp;
			var CSpawnTask xSpawnTask = m_xSpawns.Pop();
			if(CNPCMgr.Get().CheckHero(xSpawnTask.m_sClass))then
				if(CNPCMgr.Get().GetPlayerNPC(m_iOwner,xSpawnTask.m_sClass).IsValid())then
					return;
				endif;
			endif;
			var ^CGameObj pxO = CSrvWrap.GetObjMgr()^.CreateObj(xSpawnTask.m_sClass, m_iOwner, m_vSpawnPos);
			var ^CFightingObj pxFO = cast<CFightingObj>(pxO);
			if(pxFO!=null)then
				if(pxFO^.DoesCountInUnitLimit() && pxFO^.CountInStatistic())then
					pxStatisticMgr^.AddUnit(pxFO^.GetOwner(), pxFO^.GetClassName(), pxFO^.GetType(), 1);
				endif;
				pxFO^.SetLevelClean(xSpawnTask.m_iLevel);
				var ^CTransportObj pxTO =cast<CTransportObj>(pxFO);
				if(pxTO!=null)then
					if(xSpawnTask.m_sForm!="")then
						var string sFilter="/Filters/"+pxTO^.GetTribeName()+"/Upgrades/"+xSpawnTask.m_sClass+"/"+xSpawnTask.m_sForm;
						pxFO^.GetTechTreeDef()^.ClearFilters();
						pxFO^.GetTechTreeDef()^.EnableFilter(sFilter);
					endif;
					if(xSpawnTask.m_sPassengers!="")then
						var array string asPass;
						xSpawnTask.m_sPassengers.Split(asPass,"|",true);
						var int i, iC = asPass.NumEntries();
						var int iFreeSlots=pxTO^.NumFreeSeats();
						for(i=0)cond(i<iC)iter(++i)do
							if(iFreeSlots<=0)then break; endif;
							var string sCurPas = asPass[i];
							var array string asTok;
							sCurPas.Split(asTok,"/",true);
							if(asTok.NumEntries() < 2)then continue; endif;
							if(CNPCMgr.Get().CheckHero(asTok[0]))then
								if(CNPCMgr.Get().GetPlayerNPC(m_iOwner,asTok[0]).IsValid())then
									continue;
								endif;
							endif;
							var ^CGameObj pxPas = CSrvWrap.GetObjMgr()^.CreateObj(asTok[0], m_iOwner, pxTO^.GetPos());
							var ^CFightingObj pxF = cast<CFightingObj>(pxPas);
							if(pxF!=null)then
								if(pxF^.DoesCountInUnitLimit() && pxF^.CountInStatistic())then
									pxStatisticMgr^.AddUnit(pxF^.GetOwner(), pxF^.GetClassName(), pxF^.GetType(), 1);
								endif;
								xPass.AddEntry(pxF^.GetHandle());
								pxF^.SetLevelClean(asTok[1].ToInt()-1);
								if(asTok.NumEntries()>3)then
									var string sSubF="/Filters/"+pxF^.GetTribeName()+"/Upgrades/"+xSpawnTask.m_sClass+"/"+asTok[3];
									pxF^.GetTechTreeDef()^.ClearFilters();
									pxF^.GetTechTreeDef()^.EnableFilter(sSubF);
								endif;
							endif;
							iFreeSlots-=1;
							if(asTok.NumEntries()>2)then
								var string sSubPas = asTok[2];
								sSubPas.TrimLeft('(');
								sSubPas.TrimRight(')');
								var array string asSubPas;
								sSubPas.Split(asSubPas, "&", true);
								var ^CTransportObj pxTP = cast<CTransportObj>(pxPas);
								if(pxTP!=null)then
									var CObjList xSubPass;
									var int iFreeSubs=pxTP^.NumFreeSeats();
									var int j, iJC = asSubPas.NumEntries();
									for(j=0)cond(j<iJC) iter(++j)do
										if(iFreeSlots<=0||iFreeSubs<=0)then break; endif;
										var array string asSubPasData;
										asSubPas[j].Split(asSubPasData, ":", true);
										if(asSubPasData.NumEntries()>=1)then
											if(asTok.NumEntries() < 2)then continue; endif;
											if(CNPCMgr.Get().CheckHero(asSubPasData[0]))then
												if(CNPCMgr.Get().GetPlayerNPC(m_iOwner,asSubPasData[0]).IsValid())then
													continue;
												endif;
											endif;
											var ^CGameObj pxSubPas = CSrvWrap.GetObjMgr()^.CreateObj(asSubPasData[0], m_iOwner);
											var ^CCharacter pxC = cast<CCharacter>(pxSubPas);
											if(pxC!=null)then
												if(pxC^.DoesCountInUnitLimit() && pxC^.CountInStatistic())then
													pxStatisticMgr^.AddUnit(pxC^.GetOwner(), pxC^.GetClassName(), pxC^.GetType(), 1);
												endif;
												xSubPass.AddEntry(pxC^.GetHandle());
												if(asSubPasData.NumEntries()>=2)then
													pxC^.SetLevelClean(asSubPasData[1].ToInt()-1);
												endif;
											endif;
											iFreeSlots-=1;
											iFreeSubs-=1;
//												pxTP^.OnMount(pxSubPas^.GetHandle());
										endif;
									endfor;
									pxTP^.AddToDoTask("MountPass",xInv,xSubPass,vTmp,"",0.1,0.0);
								endif;
							endif;
//							pxTO^.OnMount(pxO^.GetHandle());
						endfor;
						pxTO^.AddToDoTask("MountPass",xInv,xPass,vTmp,"",0.2,0.5);
					endif;
				endif;
			endif;
			if(pxFO==null)then return; endif;
			// let's go
			if(m_xSource.IsValid())then
				pxFO^.AddToDoTask("CTheLite",m_xSource,xTmp,vTmp,"",0.2,4.0);
//			else
//				pxFO^.AddToDoTask("WalkToPos",xInv,xTmp,m_vExitPos,"0|0|",0.1,0.0);
//				pxFO^.AddToDoTask("WalkToPos",xInv,xTmp,m_vDestination,"1|1|",0.1,0.0);
			endif;
			pxFO^.AddToDoTask("MarchToWar",xInv,xTmp,m_vTarget,m_iSpeed.ToString(),0.2,1.0);
			if(xSpawnTask.m_sPostTask!="" && xSpawnTask.m_fPostTime>0.0f)then
				pxFO^.AddToDoTask(xSpawnTask.m_sPostTask,xInv,xTmp,m_vTarget,"",xSpawnTask.m_fPostTime,1.0);
			endif;
		else
//			CloseDoor();
			DeleteTimer(CRASH_SPAWNER_ID);
			Delete();
		endif;
	endproc;
	
	export proc void OpenDoor()
		if(!m_xSource.IsValid())then return; endif;
		var ^CGameObj pxObj=m_xSource.GetObj();
		if(pxObj^.HasAnim("open"))then
			pxObj^.SetAnim("open",1);
		elseif(pxObj^.HasAnim("work_finished"))then
			pxObj^.SetAnim("work_finished",1);
		elseif(pxObj^.HasAnim("spawn"))then
			pxObj^.SetAnim("spawn",1);
		endif;
	endproc;
	
	export proc real OpenDoorLength()
		var real fAnim=0.0f;
		if(!m_xSource.IsValid())then return 0.0; endif;
		var ^CGameObj pxObj=m_xSource.GetObj();
		if(pxObj^.HasAnim("open"))then
			pxObj^.SetAnim("open",1);
			fAnim = pxObj^.GetCurrentAnimLength();
		elseif(pxObj^.HasAnim("work_finished"))then
			pxObj^.SetAnim("work_finished",1);
			fAnim = pxObj^.GetCurrentAnimLength();
		elseif(pxObj^.HasAnim("spawn"))then
			pxObj^.SetAnim("spawn",1);
			fAnim = pxObj^.GetCurrentAnimLength();
		endif;
		return fAnim;
	endproc;
	
	export proc void CloseDoor()
		if(!m_xSource.IsValid())then return; endif;
		var ^CGameObj pxObj=m_xSource.GetObj();
		if(!pxObj^.HasAnim("close"))then return; endif;
		pxObj^.SetAnim("close",1);
	endproc;
	
	proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==CRASH_SPAWNER_ID)then
				OpenDoor();
				Spawn();
			endif;
		endif;
	endproc;

 	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="CRAS";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xSpawns.DoKArc(pxArc^);
		pxArc^<< m_fSpawnDelay;
		pxArc^<< m_vSpawnPos;
//		pxArc^<< m_vExitPos;
//		pxArc^<< m_vDestination;
		pxArc^<< m_iOwner;
		pxArc^<< m_iSpeed;
		pxArc^<< m_vTarget;
		m_xSource.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="CRAS")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xSpawns.DoKArc(pxArc^);
			pxArc^<< m_fSpawnDelay;
			pxArc^<< m_vSpawnPos;
//			pxArc^<< m_vExitPos;
//			pxArc^<< m_vDestination;
			pxArc^<< m_iOwner;
			pxArc^<< m_iSpeed;
			pxArc^<< m_vTarget;
			m_xSource.DoKArc(pxArc^);
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
endclass;
