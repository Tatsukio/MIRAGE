
	//========================================================================================
	//=== TEST ===============================================================================
	//========================================================================================
	
	//========================================================================================
	//=== Heroes =============================================================================
	//========================================================================================
	
class CSBaryonyx inherit CAnimal
	
	const int RIDER_ANIM_TIMER=40002;
	var string m_sIdleAnim;
	var string m_sRangedEffectPath;
	var bool m_bRangedEffectOnEnemy;
	var string m_sHump;
	
	export constructor()
		m_xSink.m_xOnObjAdd=OnObjAdd;
		m_xSink.m_xOnObjRem=OnObjRem;
		if(CMirageSrvMgr.Get().NoHumpWalking())then
			m_sHump="def";
		else
			m_sHump="hump";
		endif;
	endconstructor;
	
	export destructor()
		if(GetClassName()=="Miyagi_s0")then
			CNPCMgr.Get().RemoveNPC(GetOwner(),GetHandle());
		endif;
	enddestructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			var string sClassName=GetClassName();
			var string sBitmapName="";
			var ^CAttribs pxAttribs=GetAttribs();
			if(pxAttribs!=null)then
				if(sClassName.Find("Miyagi_s")!=(-1))then
					sBitmapName="miyagi";
				else
					sBitmapName=sClassName.Left(sClassName.FindRev('_'));
				endif;
				pxAttribs^.SetValue("unique_name",sBitmapName);
			endif;
			if(GetClassName()=="Miyagi_s0")then
				SetUnique(true);
			endif;
		endif;
		if(GetClassName()=="Miyagi_s0")then
			if(!CNPCMgr.Get().AddNPC(GetOwner(),GetHandle()))then
				Delete();
			endif;
		endif;
		SetCanSwim(true);
		SetIdleAnim();
	endproc;
	
	export proc void SetOwner(int p_iNewOwner)
		if(GetClassName()=="Miyagi_s0")then
			CNPCMgr.Get().RemoveNPC(GetOwner(),GetHandle());
		endif;
		super.SetOwner(p_iNewOwner);
		if(GetClassName()=="Miyagi_s0")then
			if(!CNPCMgr.Get().AddNPC(GetOwner(),GetHandle()))then
				Delete();
			endif;
		endif;
	endproc;
	
	proc void SetIdleAnim()
		CheckWaterLand();
		if(IsInWater())then
			SetAnim("swim_standanim",3);
		else
			SetAnim(m_sIdleAnim,3);
		endif;
	endproc;
	
	export proc void CheckWaterLand()
		OnAmphibianWaterLandTransition(!IsInWater());
	endproc;
	
	export proc string GetThreatAnim()
		if(IsInWater())then
			return "";
		else
			return "menace";
		endif;
	endproc;
	
	export proc ref CFourCC GetWalkSet()
		return m_xWalkSet;
	endproc;
	
	export proc bool AttackEnemy(^CFightingObj p_pxEnemy, vec3 p_vTarget, ref bool p_rbRotated)
		DoCaptainAttackAnim();
		return super.AttackEnemy(p_pxEnemy, p_vTarget, p_rbRotated);
	endproc;
	
	proc void OnAmphibianWaterLandTransition(bool p_bWaterToLand)
		if(p_bWaterToLand)then
			m_sIdleAnim="standanim";
			m_xWalkSet="def";
			m_xHumpWalkSet=m_sHump;
		else
			m_sIdleAnim="swim_standanim";
			m_xWalkSet="swim";
			m_xHumpWalkSet="swim";
		endif;
		SetDefaultWalkSet(m_xWalkSet);
	endproc;
	
	export proc string GetFightAnim()
		if(IsInWater())then
			return "swim_attack_front";
		else
			return m_xCurrentFightAnim.m_sAnim;
		endif;
	endproc;
	
	export proc void EquipTargetWithExplosives()
		var CFourCC xBomb="HndR";
		var string sBomb="hu_cannonball";
		if(m_xCaptain.IsValid())then
			var ^CCaptain pxCaptain=cast<CCaptain>(m_xCaptain.GetObj());
			if(pxCaptain^.HasAnim("hu_wooden_lance_anim"))then
				pxCaptain^.RemAllLinkGFX();
				pxCaptain^.SetLinkGFX(xBomb,sBomb);
				pxCaptain^.SetAnim("hu_wooden_lance_anim", 1);
			endif;
		endif;
	endproc;
	
	export proc void DoTaskAnim(string p_sName)
		if(!m_xCaptain.IsValid())then return; endif;
		var ^CCaptain pxCaptain=cast<CCaptain>(m_xCaptain.GetObj());
		if(pxCaptain==null)then return; endif;
		if(p_sName=="plunder")then
			if(pxCaptain^.HasAnim("victory_2"))then;
				pxCaptain^.SetAnim("victory_2", 1);
			endif;
		elseif(p_sName=="suborn")then
			if(pxCaptain^.HasAnim("follow_me"))then;
				pxCaptain^.SetAnim("follow_me", 1);
			endif;
		endif;
	endproc;
	
	export proc void ResetCaptain()
		if(m_xCaptain.IsValid())then
			var ^CCaptain pxCaptain=cast<CCaptain>(m_xCaptain.GetObj());
			pxCaptain^.UpdateGfx();
		endif;
		DoCaptainAnim();
	endproc;
	
	export proc void DoCaptainAttackAnim()
		if(m_xCaptain.IsValid())then
			var ^CGameObj pxCaptain=m_xCaptain.GetObj();
			if(pxCaptain==null)then return; endif;
			if(pxCaptain^.HasAnim(m_sCaptainAttackAnim))then
				pxCaptain^.SetAnim(m_sCaptainAttackAnim, 1);
			endif;
		endif;
	endproc;
	
	export proc void LinkCaptainObj()
		var ^CGameObj pxCaptain=m_xCaptain.GetObj();
		if(pxCaptain==null)then return; endif;
		AddGroupedChildren(pxCaptain^.GetGuid());
		var bool bBuildUpLink; var CFourCC xLink;
		var CFourCC xNoNo="NOPE";
		if(GetCaptainLink(xLink, bBuildUpLink))then
			pxCaptain^.SetVisible(true);
			if(GetClassName()=="Miyagi_s0")then
				pxCaptain^.RideAction(GetHandle(),xLink,{0.1,0.0,-2.2});
			else
				pxCaptain^.RideAction(GetHandle(),xLink,{0.0,0.0,0.0});
			endif;
			DoCaptainAnim();
			return;
		endif;
		xLink="NONE";
		pxCaptain^.LinkAction(GetHandle(),xLink);
		pxCaptain^.SetVisible(false);
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		po_rxLink="Ride";
		po_rbIsBuildUpLink=false;
		SetCaptainAnim("standanim");
		//SetCaptainAnim("sitting_chair");
		SetCaptainAttackAnim("jans_anim_2");
		//SetCaptainAttackAnim("menace");
		//SetCaptainAttackAnim("victory_2");
		//SetCaptainAttackAnim("res_threat");
		return true;
	endproc;
	
	export proc void DoCaptainAnim()
		if(m_xCaptain.IsValid())then
			if(GetEvents()==null)then
				InitEvents();
			endif;
			if(HasTimer(RIDER_ANIM_TIMER))then
				DeleteTimer(RIDER_ANIM_TIMER);
			endif;
			var string sCaptainAnim="standanim";
			var ^CGameObj pxCaptain=m_xCaptain.GetObj();
			if(pxCaptain^.HasAnim(sCaptainAnim))then
				pxCaptain^.SetAnim(sCaptainAnim, 3);
				CreateTimer(RIDER_ANIM_TIMER, CGameTimeSpan.OneSecond() * (pxCaptain^.GetCurrentAnimLength()*3.0), false);
			endif;
		endif;
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="SpBa")then
			var int iVersion=p_pxNode^.GetVersion();
			var ^CArc pxArc=^(p_pxNode^.GetArc());
			(pxArc^) << m_sRangedEffectPath;
			(pxArc^) << m_bRangedEffectOnEnemy;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="SpBa";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,1);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_sRangedEffectPath;
		(pxArc^) << m_bRangedEffectOnEnemy;
		pxN^.Close();
	endproc;
	
	proc bool OnObjAdd(CObjHndl p_xHndl)
		if(m_bToBeDeleted)then return false; endif;
		if(p_xHndl==GetHandle())then return false; endif;
		var ^CFightingObj pxO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxO==null)then return false; endif;
		if(pxO^.GetType()=="BLDG")then return false; endif;
		if(m_sRangedEffectPath.IsEmpty())then return false; endif;
//		var bool bFriend=CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxO^.GetOwner());
//		var bool bEnemy=CSrvWrap.GetDiplomacyMgr().GetIsEnemy(GetOwner(), pxO^.GetOwner());
		var bool bFriend = (GetOwner()==pxO^.GetOwner()) || (AuraSharing()&&(CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxO^.GetOwner(), GetOwner())&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxO^.GetOwner())));
		var bool bEnemy=CSrvWrap.GetDiplomacyMgr().GetIsEnemy(GetOwner(), pxO^.GetOwner())||CSrvWrap.GetDiplomacyMgr().GetIsEnemy(pxO^.GetOwner(),GetOwner());
		if(bFriend&&m_bRangedEffectOnEnemy)then
			return false;
		elseif(bEnemy&&!m_bRangedEffectOnEnemy)then
			return false;
		elseif(!bFriend&&!bEnemy)then
			return false;
		endif;
		m_xRegionObjects.Include(p_xHndl);
		var ^CTechTreeDef pxTTDef=pxO^.GetTechTreeDef();
		if(pxTTDef!=null)then
			pxTTDef^.EnableFilter(m_sRangedEffectPath);
			pxO^.AddRangedBuff("higher_attack_speed");
		endif;
		return true;
	endproc;
	
	proc bool OnObjRem(CObjHndl p_xHndl)
		if(m_xRegionObjects.FindEntry(p_xHndl)==-1)then return false; endif;
		m_xRegionObjects.RemEntry(p_xHndl);
		var ^CFightingObj pxO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxO==null)then return false; endif;
		var ^CTechTreeDef pxTTDef=pxO^.GetTechTreeDef();
		if(pxTTDef!=null)then
			pxTTDef^.DisableFilter(m_sRangedEffectPath);
			pxO^.RemoveRangedBuff("higher_attack_speed");
		endif;
		return true;
	endproc;
	
	export proc void OnTechTreeChange()
		super.OnTechTreeChange();
	endproc;
	
	export proc void CheckLevelFlag()
		return;
	endproc;
	
	export proc void OnTechTreeChange(ref CStringArray p_rasChanges)
		super.OnTechTreeChange(p_rasChanges);
		if(GetClassName()=="Miyagi_s0")then
			var bool bSARangeEffect=false;
			var int i,iC;
			for(i=0) cond(i<p_rasChanges.NumEntries()) iter(i++)do
				var string sVal=p_rasChanges[i];
				if(sVal.Find("special_abilities")>=0)then
					if(sVal.Find("RangeEffect")>=0)then
						bSARangeEffect=true;
					endif;
				endif;
			endfor;
			if(bSARangeEffect)then
				var ^CFightingObj.CSpecialAbility pxAb=m_xAbilities.GetAbility("RangeEffect", true);
				if(pxAb!=null&&!HasPersonalRegion())then
					m_sRangedEffectPath="/Filters/Special/Upgrades/"+GetClassName()+"/RangeEffect";
					m_bRangedEffectOnEnemy=pxAb^.GetValueB("OnEnemy");
					var real fRange=pxAb^.GetValueF("radius");
					var vec3 vDimension; vDimension.SetXYZ(fRange, fRange, 0.0);
					CreatePersonalRegion("RangedEffect_"+GetName()+"_"+Random.GetInt().ToString(), vDimension, 010b);
					AddRangedBuff("owner_miyagi");
				endif;
				if(pxAb==null&&HasPersonalRegion())then
					DeletePersonalRegion();
				endif;
			endif;
		endif;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			)then return; endif;
		if(GetTransportObj().IsValid()&&!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/LeaveTransport")>=0))then return; endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("/plunder")>=0)then
				if(CheckSpecialActionTimer(p_sMiscParams)&&p_pxObject!=null&&!GetTransportObj().IsValid())then
					Plunder(p_pxObject^.GetHandle(), p_sMiscParams, p_bA, p_bQ);
				endif;
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	proc void BurnUp(vec3 p_vTarget, string p_sTTPath)
		AddSpecialActionTimer(p_sTTPath);
		var real fRange=50.0f, fDamage=100.0f;
		var int iTime=50;
		var CObjList xEnemies;
		var CObjQuery xQuery;
		CSrvWrap.GetDiplomacyMgr().AddMyEnemiesToSearch(GetOwner(), xQuery, false);
		xQuery.SetOwner(-1, true);
		xQuery.SetType("BLDG");
		xQuery.RegionCircle(GetPos(), fRange);
		xQuery.Execute(xEnemies);
		var int i, iC=xEnemies.NumEntries();
		for (i=0) cond(i<iC) iter(++i)do
			var ^CBuilding pxB=cast<CBuilding>(xEnemies[i].GetObj());
			if(pxB==null||pxB^.GetClassName()=="Virtual_Produce_Unit")then continue; endif;
			pxB^.IgniteBuilding(fDamage,iTime,GetHandle(),GetOwner());
		endfor;
	endproc;
	
	proc bool Plunder(CObjHndl p_xEnemy, string p_sTTPath, bool p_bAILock, bool p_bQ)
		var ^CPlunder pxTask=cast<CPlunder>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"Plunder"));
		if(pxTask==null)then return false; endif;
		var bool bReturn=pxTask^.Init(GetHandle(), p_xEnemy, p_sTTPath);
		if(bReturn)then
			SetAILock(p_bAILock);
			pxTask^.SetUserCommand(true);
			AddTask(pxTask,p_bQ);
		else
			pxTask^.GetFactory()^.FreeState(pxTask);
		endif;
		return bReturn;
	endproc;
	
	export proc string EatAnim()
		if(IsInWater())then
			return "swim_attack_front";
		else
			return "feeding";
		endif;
	endproc;
	
	export proc bool IsBugged()
		if(IsInWater())then
			return true;
		endif;
		return m_bBugged;
	endproc;
	
	export proc void InitOwnRegion()
		var ^CFightingObj.CSpecialAbility pxAb=m_xAbilities.GetAbility("RangeEffect", true);
		if(pxAb!=null&&!HasPersonalRegion())then
			m_sRangedEffectPath="/Filters/Special/Upgrades/"+GetClassName()+"/RangeEffect";
			m_bRangedEffectOnEnemy=pxAb^.GetValueB("OnEnemy");
			var real fRange=pxAb^.GetValueF("radius");
			var vec3 vDimension; vDimension.SetXYZ(fRange, fRange, 0.0);
			CreatePersonalRegion("RangedEffect_"+GetName()+"_"+Random.GetInt().ToString(), vDimension, 010b);
			AddRangedBuff("owner_miyagi");
		endif;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==RIDER_ANIM_TIMER)then
				DoCaptainAnim();
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	export proc void RemoveBuff()
		RemoveRangedBuff("owner_miyagi");
	endproc;
	
endclass;
	
class CSpecialMobileSuit inherit CTransportObj
	
	const string DEMECHANIZATION="/Filters/Special/Upgrades/babbage_s0/mechanization";
	const string PIERCINGTHROUGH="/Filters/Special/Upgrades/xenage/PiercingThrough";
	const int TIMER_BABBAGE =40091; //Henry: for babbage to return
	const int PIERCING_THROUGH =40093; //Henry: for babbage to return
	const int TIMER_DESCENT=40095;
	const real BUILDING_DAMAGE_BONUS=25.0f; // in percent
	var bool m_bTecInFightPos;
	var bool m_bDestroyed;
	var bool m_bDying;
	var bool m_bDescending;
	var bool m_bPiercing;
	var bool m_bGameOver;
	var string m_sDriver;
	var real m_fHPRatio;
	var string m_sRangedEffectPath;
	var bool m_bRangedEffectOnEnemy;
	var vec3 m_vWalk;
	var vec3 m_vAirpos;
	var CObjHndl m_xNextEnemy;
	
	export constructor()
//		m_bDescending=true;
		m_bGameOver=false;
		m_bTecInFightPos=false;
		m_bDestroyed=false;
		m_bDying=false;
		m_bPiercing=false;
		m_xSink.m_xOnObjAdd=OnObjAdd;
		m_xSink.m_xOnObjRem=OnObjRem;
		m_vWalk={0.0,0.0,0.0};
		m_vAirpos={0.0,0.0,0.0};
		m_fHPRatio=1.0;
	endconstructor;
	
	export destructor()
		CNPCMgr.Get().RemoveNPC(GetOwner(),GetHandle());
	enddestructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="SpMS";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,2);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		pxArc^ << m_bDescending;
		pxArc^ << m_bDestroyed;
		pxArc^ << m_bDying;
		pxArc^ << m_bTecInFightPos;
		pxArc^ << m_bPiercing;
		pxArc^ << m_sDriver;
		pxArc^ << m_sRangedEffectPath;
		pxArc^ << m_bRangedEffectOnEnemy;
		pxArc^ << m_vWalk;
		pxArc^ << m_vAirpos;
		pxArc^ << m_fHPRatio;
		m_xNextEnemy.DoKArc(pxArc^);
		pxArc^ << m_bGameOver;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="SpMS")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			if(iVersion>=1)then
				pxArc^ << m_bDescending;
				pxArc^ << m_bDestroyed;
				pxArc^ << m_bDying;
				pxArc^ << m_bTecInFightPos;
				pxArc^ << m_bPiercing;
				pxArc^ << m_sDriver;
				pxArc^ << m_sRangedEffectPath;
				pxArc^ << m_bRangedEffectOnEnemy;
				pxArc^ << m_vWalk;
				pxArc^ << m_vAirpos;
				pxArc^ << m_fHPRatio;
				m_xNextEnemy.DoKArc(pxArc^);
			endif;
			if(iVersion>=2)then
				pxArc^ << m_bGameOver;
			endif;
//			if(iVersion>=3)then
//				pxArc^ << ;
//			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			SetType("VHCL");
			InitAttribs();
		endif;
		UpdateAttribs(p_bLoad);
		AddUnit();
		if(GetInventory()==null)then
			InitInventory(1);
		endif;
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,true);
		m_iSizeClass=10;
		OnTechTreeChange();
		if(!p_bLoad)then
			StartTT();
			SetCanFightAttrib(true);
			var string sBitmapName="babbage";
			var ^CAttribs pxAttribs=GetAttribs();
			if(pxAttribs!=null)then
				pxAttribs^.SetValue("unique_name",sBitmapName);
			endif;
		endif;
		if(!CNPCMgr.Get().AddNPC(GetOwner(),GetHandle()))then
			Delete();
		endif;
		SetIdleAnim();
	endproc;
	
	export proc void SetOwner(int p_iNewOwner)
		CNPCMgr.Get().RemoveNPC(GetOwner(),GetHandle());
		super.SetOwner(p_iNewOwner);
		if(!CNPCMgr.Get().AddNPC(GetOwner(),GetHandle()))then
			Delete();
		endif;
	endproc;
	
	export proc bool AttackEnemy(^CFightingObj p_pxEnemy, vec3 p_vTarget, ref bool p_rbRotated)
		if(GetIncapacitated()||GetTransportObj().IsValid())then
			m_bTecInFightPos=false;
			return false;
		endif;
		if(p_pxEnemy!=null)then
			if(p_pxEnemy^.IsFlyingUnit() && !CanShootAir())then
				m_bTecInFightPos=false;
				return false;
			endif;
		endif;
		var string sFAnim=GetNextFightAnim();
		if(sFAnim.IsEmpty())then sFAnim="attack_front"; endif;
		var bool bFAnim=!sFAnim.IsEmpty();
		var string sProj=GetProjectile();
		var bool bProj=!sProj.IsEmpty();
		begin Rotate;
			var real fAngle;
			if(p_pxEnemy!=null)then
				fAngle=GetAngleToR(p_pxEnemy);
			else
				fAngle=GetAngleToR(p_vTarget);
			endif;
			var Quat qRot;
			if(p_pxEnemy!=null)then
				qRot=GetAngleToQ(p_pxEnemy);
			else
				qRot=GetAngleToQ(p_vTarget);
			endif;
			if(!bProj&&bFAnim)then
				m_bTecInFightPos=false;
				if(GetPenetration()&&fAngle>(Math.Pi()/16.0f))then
					RotateToEnemy(p_pxEnemy, p_vTarget, sFAnim, 0.5);
					p_rbRotated=true;
				elseif(fAngle>Math.Pi()/8.0)then
					RotateToEnemy(p_pxEnemy, p_vTarget, sFAnim, 0.5);
					p_rbRotated=true;
					return true;
				endif;
			else
				if(fAngle>Math.Pi()/4.0||(GetPenetration()&&fAngle>Math.Pi()/16.0f))then
//					RotateToEnemy(p_pxEnemy, p_vTarget);
//					p_rbRotated=true;
//					m_bTecInFightPos=false;
//					return false;
					m_bRotateSLEAction=true;
					RotateActionSLE(qRot,sFAnim, 0.4, 1, !m_bTecInFightPos,false);
					p_rbRotated=true;
				endif;
			endif;
		end Rotate;
		if(GetPenetration())then
			m_bTecInFightPos=false;
			Penetrate(p_pxEnemy,p_vTarget);
			if(sFAnim!="" && HasAnim(sFAnim))then
				SetAnim(sFAnim,1);
			endif;
			return false;
		elseif(bProj)then
			var int j, iK=GetProjectilesNumber();
			for(j=0)cond(j<iK)iter(j++)do
				CreateProjectileAndShoot(p_pxEnemy, p_vTarget);
			endfor;
			SetSLEAnim(sFAnim, 1, !m_bTecInFightPos, false);
			m_bTecInFightPos=true;
			return false;
		elseif(bFAnim)then
			m_bTecInFightPos=false;
			if(sFAnim!=""&&HasAnim(sFAnim))then
				SetAnim(sFAnim,1);
			endif;
		endif;
		return true;
	endproc;
	
	proc bool OnObjAdd(CObjHndl p_xHndl)
		if(m_bToBeDeleted)then return false; endif;
		if(p_xHndl==GetHandle())then return false; endif;
		var ^CFightingObj pxO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxO==null)then return false; endif;
		if(m_sRangedEffectPath.IsEmpty())then return false; endif;
		var bool bFriend = (GetOwner()==pxO^.GetOwner()) || (AuraSharing()&&(CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxO^.GetOwner(), GetOwner())&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxO^.GetOwner())));
		var bool bEnemy=CSrvWrap.GetDiplomacyMgr().GetIsEnemy(GetOwner(), pxO^.GetOwner())||CSrvWrap.GetDiplomacyMgr().GetIsEnemy(pxO^.GetOwner(),GetOwner());
		if(bFriend&&m_bRangedEffectOnEnemy)then
			return false;
		elseif(bEnemy&&!m_bRangedEffectOnEnemy)then
			return false;
		elseif(!bFriend&&!bEnemy)then
			return false;
		endif;
		m_xRegionObjects.Include(p_xHndl);
		if(m_sRangedEffectPath.Find("special_mobile_suit")>=0 && pxO^.GetType()!="BLDG")then
			var ^CBoniBucket pxBB=pxO^.GetBoniBucket(CFightingObj.BONUS_DAMAGE_BLDG);
			if(pxBB!=null)then
				pxBB^.AddEntry("spec_mobile_suit_dmg", BUILDING_DAMAGE_BONUS);
			endif;
			pxO^.AddRangedBuff("more_bldg_damage");
			pxO^.UpdateWeaponBoni();
		endif;
		return true;
	endproc;
	
	proc bool OnObjRem(CObjHndl p_xHndl)
		if(m_xRegionObjects.FindEntry(p_xHndl)==-1)then return false; endif;
		m_xRegionObjects.RemEntry(p_xHndl);
		var ^CFightingObj pxO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxO==null)then return false; endif;
		if(m_sRangedEffectPath.Find("special_mobile_suit")>=0)then
			var ^CBoniBucket pxBB=pxO^.GetBoniBucket(CFightingObj.BONUS_DAMAGE_BLDG);
			if(pxBB!=null)then
				pxBB^.RemEntry("spec_mobile_suit_dmg");
			endif;
			pxO^.RemoveRangedBuff("more_bldg_damage");
			pxO^.UpdateWeaponBoni();
		endif;
		return true;
	endproc;
	
	export proc void CheckLevelFlag()
		return;
	endproc;
	
	export proc void OnTechTreeChange()
		super.OnTechTreeChange();
	endproc;
	
	export proc void OnTechTreeChange(ref CStringArray p_rasChanges)
		super.OnTechTreeChange(p_rasChanges);
		if(GetClassName()=="special_mobile_suit")then
			var bool bSARangeEffect=false;
			var int i,iC;
			for(i=0) cond(i<p_rasChanges.NumEntries()) iter(i++)do
				var string sVal=p_rasChanges[i];
				if(sVal.Find("special_abilities")>=0)then
					if(sVal.Find("RangeEffect")>=0)then
						bSARangeEffect=true;
					endif;
				endif;
			endfor;
			if(bSARangeEffect)then
				var ^CFightingObj.CSpecialAbility pxAb=m_xAbilities.GetAbility("RangeEffect", true);
				if(pxAb!=null&&!HasPersonalRegion())then
					m_sRangedEffectPath="/Filters/Special/Upgrades/"+GetClassName()+"/RangeEffect";
					m_bRangedEffectOnEnemy=pxAb^.GetValueB("OnEnemy");
					var real fRange=pxAb^.GetValueF("radius");
					var vec3 vDimension; vDimension.SetXYZ(fRange, fRange, 0.0);
					CreatePersonalRegion("RangedEffect_"+GetName()+"_"+Random.GetInt().ToString(), vDimension, 010b);
					AddRangedBuff("owner_more_bldg_damage");
				endif;
				if(pxAb==null&&HasPersonalRegion())then
					DeletePersonalRegion();
				endif;
			endif;
		endif;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(m_bDescending)then return; endif;
		if(	IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
		)then return; endif;
		if(m_bDestroyed||m_bDying)then
			return;
		endif;
		if(GetTransportObj().IsValid()&&!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/LeaveTransport")>=0))then return; endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("Babbage_ExoJumpjet_0")!=-1)then
				if(CheckSpecialActionTimer(p_sMiscParams) && !GetTransportObj().IsValid())then
					SMSJumpjet(p_vPos,p_sMiscParams, p_bQ);
				endif;
			elseif(p_sMiscParams.Find("Babbage_ExoMinigun_0")!=-1)then
				if(CheckSpecialActionTimer(p_sMiscParams) && !GetTransportObj().IsValid())then
					SMSMinigun(p_sMiscParams, p_pxObject, p_vPos, p_bQ);
				endif;
			elseif(p_sMiscParams.Find("Babbage_ExoPiercing_0")!=-1)then
				if(CheckSpecialActionTimer(p_sMiscParams) && !GetTransportObj().IsValid())then
					SMSPiercing(p_sMiscParams);
				endif;
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	export proc bool SMSJumpjet(vec3 p_vPos, string p_sTTPath, bool p_bQ)
		if(p_vPos!={0.0,0.0,0.0})then
			var ^CSpecialJumpjet pxTask= cast<CSpecialJumpjet>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(), "SpecSuitJ"));
			if(pxTask==null)then return false; endif;
			if(pxTask^.Init(GetHandle(), p_vPos,p_sTTPath))then
				pxTask^.SetUserCommand(true);
				AddTask(pxTask,p_bQ);
				return(true);
			else
				pxTask^.GetFactory()^.FreeState(pxTask);
			endif;
		endif;
		return(false);
	endproc;
	
	export proc bool SMSMinigun(string p_sTTPath, ^CGameObj p_pxEnemy, vec3 p_vPos, bool p_bQ)
		var CObjHndl xEnemy;
		if(p_pxEnemy!=null)then
			xEnemy=p_pxEnemy^.GetHandle();
		endif;
//		MemorizeCurrentFightState(xEnemy,true,false);
		var ^CSpecialMinigun pxTask=cast<CSpecialMinigun>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"SMSMinigun"));
		if(pxTask==null)then return false; endif;
		var bool bReturn=pxTask^.Init(GetHandle(),xEnemy,p_vPos,p_sTTPath);
		if(bReturn)then
			pxTask^.SetUserCommand(true);
			AddTask(pxTask,p_bQ);
		else
			pxTask^.GetFactory()^.FreeState(pxTask);
		endif;
		return bReturn;
	endproc;
	
	proc void SMSPiercing(string p_sPath)
		if(m_bPiercing)then return; endif;
		m_bPiercing=true;
		AddSpecialActionTimer(p_sPath);
		if(HasTimer(PIERCING_THROUGH))then DeleteTimer(PIERCING_THROUGH); endif;
		ActivateCustomFilterAndUpdate(true,PIERCINGTHROUGH);
		CreateTimer(PIERCING_THROUGH,CGameTimeSpan.OneSecond()*15.0f, false);
		return;
	endproc;
	
	export proc void ActivatePiercing(bool p_bOn, real p_fDur)
		if(p_bOn==m_bPiercing)then return; endif;
		m_bPiercing=p_bOn;
		if(HasTimer(PIERCING_THROUGH))then DeleteTimer(PIERCING_THROUGH); endif;
		ActivateCustomFilterAndUpdate(p_bOn,PIERCINGTHROUGH);
		if(p_bOn)then
			CreateTimer(PIERCING_THROUGH,CGameTimeSpan.OneSecond()*p_fDur, false);
		endif;
		return;
	endproc;
	
	export proc void EndFight()
		super.EndFight();
		if(m_bTecInFightPos)then
			m_bTecInFightPos=false;
			if(HasAnim(GetFightAnim()))then
				AnimAction(GetFightAnim(),0,false,true);
			endif;
		endif;
	endproc;
	
	export proc void GameOverKill(int p_iSwitch)
		m_bGameOver=true;
		Die();
	endproc;
	
	export proc void Die()
		if(!m_bGameOver&&m_sDriver!="")then
			SetNoHitReaction();
			m_bDying=true;
			SetSelectable(false);
			SetHitable(false);
			m_xNextEnemy=GetCurEnemy();
			if(HasWalkAction())then
				m_vWalk=GetCurWalkTarget();
			endif;
			StopEverything();
			TerminateAction();
			SetIsVanished(true);
			var real fDuration;
			SetAnim("dying",1,0,fDuration);
			CreateTimer(TIMER_BABBAGE, CGameTimeSpan.OneSecond()*fDuration, false);
			AnimAction("dying");
			return;
		else
			if(!IsDead())then
				CreateCorpse();
			endif;
			super.Die();
		endif;
	endproc;
	
	export proc void CreateCorpse()
		if(!m_bGameOver||IsDyingInTPO())then return; endif;
		var string sModel;
		if(!CorpseAvailable(sModel))then return; endif;
		if(CMirageSrvMgr.Get().UnitResources())then
			var ^CStone_Corpse pxStone=cast<CStone_Corpse>(CSrvWrap.GetObjMgr()^.CreateObj("StoneCorpse",GetOwner(),GetPos(),GetRotation()));
			if(pxStone!=null)then
				pxStone^.SetName(GetName());
				pxStone^.SetGFX(sModel);
				pxStone^.Initialize(this);
				pxStone^.SetDieAnim("destroy",true);
				pxStone^.SetAggressive(GetTechTreeAggressiv());
				pxStone^.Init();
			endif;
		else
			var ^CVehicleCorpse pxGameObj=cast<CVehicleCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("VehicleCorpse",GetOwner(),GetPos(),GetRotation()));
			if(pxGameObj!=null)then
				pxGameObj^.SetSource(this);
				pxGameObj^.SetCanSwim(CanSwim());
				pxGameObj^.Init(sModel, GetName(), 10.0);
			endif;
		endif;
	endproc;
	
	export proc bool CorpseAvailable(ref string p_rsClass)
		p_rsClass=GetGfxName()+"_dest";
		return CSrvWrap.GetGfxMgrBase().FindGraphicSetEntry(p_rsClass);
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==TIMER_BABBAGE)then
				RemoveUnitInternally();
				m_bDestroyed=CNPCMgr.Get().RemoveNPC(GetOwner(),GetHandle());
				DeletePersonalRegion();
				SetStartFilter(false);
				SetLevelFilter(false);
				SetAnim("dying",0,95);
//				if(m_sDriver!="")then
					var ^CHero pxHero=cast<CHero>(CSrvWrap.GetObjMgr()^.CreateObj(m_sDriver,GetOwner(),GetPos(),GetRotation()));
					if(pxHero!=null)then
						var ^CTechTreeDef pxTTDef=pxHero^.GetTechTreeDef();
						if(pxTTDef!=null&&pxTTDef^.HasFilter(DEMECHANIZATION))then
							pxTTDef^.DisableFilter(DEMECHANIZATION);
						endif;
						var ^CPlayer pxPlayer=CSrvWrap.GetCurLevel()^.GetPlayer(pxHero^.GetOwner());
						if(pxPlayer!=null)then
							pxTTDef=^(pxPlayer^.GetPlayerTechTreeDef());
							if(pxTTDef!=null&&pxTTDef^.HasFilter(DEMECHANIZATION))then
								pxTTDef^.DisableFilter(DEMECHANIZATION);
							endif;
						endif;
						var ^CAttribs pxAttr=pxHero^.GetAttribs();
						if(pxAttr!=null)then
							pxAttr^.SetValue("clientpyramid_replacecard", GetName());
						endif;
						var vec3 vPos=GetPos();
						var real fScapeZ=CSrvWrap.GetScapeMgr().GetHeight(vPos.GetX(),vPos.GetY());
						var real fSea=m_fWaterLevel;
						if(fScapeZ+5.0f<fSea)then
							pxHero^.HarakiriFastAndSilent();
						else
							pxHero^.SetKillerNumbers(GetKillerCount(),GetKillerHistory());
							pxHero^.SetAggressionState(GetAggressionState());
							pxHero^.SetLastEnemy(GetLastEnemy());
							pxHero^.SetLastDamage(GetLastDamage());
							pxHero^.SetLevelClean(GetLevel());
							var array string asExActions,asNewActions;
							asExActions=1;asNewActions=1;
							asExActions[0]="Actions/Special/Moves/VHCL/Babbage_ExoMinigun_0";
							asNewActions[0]="Actions/Special/Moves/CHTR/Babbage_Minigun_0";
							var real fDur; var CGameTime xTime;
							var int i;
							for(i=0)cond(i<asExActions.NumEntries())iter(i++)do
								if(GetSpecialActionTimerInfo(asExActions[i],xTime,fDur))then
									pxHero^.AddSpecialActionTimerPrecisely(asNewActions[i],xTime,fDur);
								endif;
							endfor;
							pxHero^.AddSpecialActionTimer("Actions/Special/Upgrades/babbage_s0/mechanization");
							pxHero^.MemorizeCurrentFightState(m_xNextEnemy,true,false);
							vPos.SetZ(Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vPos.GetX(),vPos.GetY()),m_fWaterLevel));
							pxHero^.SetPos(vPos);
							var string sEvent="update_groups\t";
							CSrvWrap.SendGenericEvtToPlayer(GetOwner(),sEvent);
							var ^CInventory pxInv=GetInventory();
							if(pxInv!=null)then
								var int i, iC=pxInv^.Count();
								var CObjList xList;
								for(i=0) cond(i<iC) iter(++i)do
									if(!pxInv^.GetItem(i).IsValid())then continue; endif;
									xList.Include(pxInv^.GetItem(i));
								endfor;
								iC=xList.NumEntries();
								for(i=0)cond(i<iC)iter(i++)do
									if(xList[i].IsValid())then
										var ^CGameObj pxItem=xList[i].GetObj();
										var ^CItem pxI=cast<CItem>(pxItem);
										if(pxI!=null)then
											RemoveItemSilent(pxI^.GetHandle());
											pxHero^.AddItemSilent(pxI^.GetHandle());
										endif;
									endif;
								endfor;
								pxHero^.SetHitpoints(pxHero^.GetMaxHitpoints()/2.0);
	//							pxHero^.SetHitpoints(pxHero^.GetMaxHitpoints()*m_fHPRatio);
								pxHero^.SetVisible(true);
								pxHero^.ReturnToFight();
								if(m_vWalk!={0.0,0.0,0.0})then
									pxHero^.WalkAction(m_vWalk,pxHero^.GetMaxSpeed());
								endif;
	//							pxHero^.AnimAction("getting_up");
								pxHero^.SetAnim("getting_up",1);
							endif;
							SetVisible(false);
						endif;
						RecycledByUpgrade();
					else
						HarakiriFastAndSilent();
	//					RecycledByUpgrade();
					endif;
//				else
//				endif;
			elseif(iTimerID==PIERCING_THROUGH)then
				ActivateCustomFilterAndUpdate(false,PIERCINGTHROUGH);
				m_bPiercing=false;
			elseif(iTimerID==TIMER_DESCENT)then
				StartWorking();
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	export proc void SetDriver(string p_sClass,real p_fRatio,vec3 p_vWalk, CObjHndl p_xEnemy, vec3 p_vAir)
		m_bGodMode=true;
		m_sDriver=p_sClass;
		m_fHPRatio=p_fRatio;
		m_vWalk=p_vWalk;
		m_xNextEnemy=p_xEnemy;
		m_vAirpos=p_vAir;
	endproc;
	
	export proc void RemoveUnitInternally()
		if(m_bDestroyed)then return; endif;
		m_bDestroyed=true;
		super.RemoveUnit();
	endproc;
	
	export proc void StopEverything()
		super.StopEverything();
		SetIdleAnim();
	endproc;
	
	export proc void OnActionEnd(bool p_bBroken)
		if(m_bDescending)then
			if(p_bBroken&&GetPos()!=m_vAirpos)then
				if(HasTimer(TIMER_DESCENT))then DeleteTimer(TIMER_DESCENT); endif;
				SetPos(m_vAirpos);
				Descent();
				return;
			endif;
			EndCurrentLoopAnim();
			m_bDescending=false;
			StartWorking();
			return;
		endif;
		super.OnActionEnd(p_bBroken);
		if(m_bRotateSLEAction)then
			m_bRotateSLEAction=false;
//			return;
		endif;
		super.OnActionEnd(p_bBroken);
		var bool bSetIdleAnim=true;
		var ^CTask pxCurTask=GetCurTask();
		if(pxCurTask!=null)then
			bSetIdleAnim=pxCurTask^.OnActionEnd(p_bBroken);
		endif;
		if(bSetIdleAnim)then
			if(!IsDead() && m_fHitpoints>0.0f && !IsFeignDeath() && !m_bRotateSLEAction && !IsGroupWalkPending())then
				SetIdleAnim();
			endif;
		endif;
//		SetIdleAnim();
	endproc;
	
	export proc void OnKill() // Henry: gives no skull, because babbit gets respawned...
		return;
	endproc;
	
	export proc void Descent()
		CreateTimer(TIMER_DESCENT,CGameTimeSpan.OneSecond()*30.0, false);
		var vec3 vGround=GetPos();
		vGround.SetZ(Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vGround.GetX(),vGround.GetY()),m_fWaterLevel));
		SetSLEAnim("jumpjet",99999,false,false);
		MoveAction(vGround, 15.0);
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		if(m_bDescending)then
			m_bDescending=false;
			StartWorking();
		endif;
	endproc;
	
	export proc void StartWorking()
		if(HasTimer(TIMER_DESCENT))then DeleteTimer(TIMER_DESCENT); endif;
		MemorizeCurrentFightState(m_xNextEnemy,true,false);
		m_bGodMode=false;
		m_bDescending=false;
		var vec3 vGround=GetPos();
		vGround.SetZ(Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vGround.GetX(),vGround.GetY()),m_fWaterLevel));
		SetPos(vGround);
		EndCurrentLoopAnim();
		ReturnToFight();
//		SetAnim("jumpjet",2,14);
		SetAnim("jumpjet",2);
		if(m_vWalk!={0.0,0.0,0.0})then
			WalkAction(m_vWalk,GetMaxSpeed());
		endif;
	endproc;
	
	export proc void InitOwnRegion()
		var ^CFightingObj.CSpecialAbility pxAb=m_xAbilities.GetAbility("RangeEffect", true);
		if(pxAb!=null&&!HasPersonalRegion())then
			m_sRangedEffectPath="/Filters/Special/Upgrades/"+GetClassName()+"/RangeEffect";
			m_bRangedEffectOnEnemy=pxAb^.GetValueB("OnEnemy");
			var real fRange=pxAb^.GetValueF("radius");
			var vec3 vDimension; vDimension.SetXYZ(fRange, fRange, 0.0);
			CreatePersonalRegion("RangedEffect_"+GetName()+"_"+Random.GetInt().ToString(), vDimension, 010b);
			AddRangedBuff("owner_more_bldg_damage");
		endif;
	endproc;
	
	export proc void RemoveBuff()
		RemoveRangedBuff("owner_more_bldg_damage");
	endproc;
	
	export proc void SetIced(real p_fDuration,real p_fResistStart)
		if(GetCurTaskName()=="SpecSuitJ")then
			return;
		else
			return super.SetIced(p_fDuration,p_fResistStart);
		endif;
	endproc;
	
	export proc void TriggerSpawn()
		m_sDriver="babbage_s0";
//		m_bGodMode=false;
		m_bDescending=false;
	endproc;
	
	export proc void SetDescending(bool p_bOn)
		m_bDescending=p_bOn;
	endproc;
	
endclass;
	
	//========================================================================================
	//=== Characters =========================================================================
	//========================================================================================
	
class CHuZombie inherit CCharacter
	
	const int TIMER_POISON_AURA					= 40008;
	const real POISON_AURA_INTERVAL			= 2.0;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
//		m_xFunctionUnits.SetType("ANML");
//		m_xFunctionUnits.SetType("CHTR",true);
//		CreateTimer(TIMER_POISON_AURA, CGameTimeSpan.OneSecond() * POISON_AURA_INTERVAL, true);
//		m_xLastFunctionTime=CTimeMgr.Get().GetTime();
	endproc;
	
	proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==TIMER_POISON_AURA)then
//				RewardTheAudienceWithPoison(); //Henry: ;)
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
//	proc void RewardTheAudienceWithPoison()
//		if(GetEntrenched()!=0)then return; endif;
//		var CGameTime xNow=CTimeMgr.Get().GetTime();
//		var CGameTimeSpan xDT=xNow-m_xLastFunctionTime;
//		var real fTime=xDT.GetSecondsF();
//		if(fTime==0.0)then return; endif;
//		var real fRadius=10.0f;
//		var ^CFightingObj.CSpecialAbility pxAb=m_xAbilities.GetAbility("poison_aura", true);
//		if(pxAb!=null)then
//			var real fRadius=pxAb^.GetValueF("radius");
//		else
//			return;
//		endif;
//		m_xLastFunctionTime=xNow;
//		var CObjList xUnits;
//		CSrvWrap.GetDiplomacyMgr().AddMyEnemiesToSearch(GetOwner(), m_xFunctionUnits, false);
//		//CSrvWrap.GetDiplomacyMgr().AddMyFriendsToSearch(GetOwner(), m_xFunctionUnits); //Henry: for testing on own units :)
//		m_xFunctionUnits.RegionCircle(GetPos(),fRadius);
//		if(!m_xFunctionUnits.Execute(xUnits))then return; endif;
//		var int i,iC=xUnits.NumEntries();
//		for(i=0)cond(i<iC)iter(i++)do
//			var ^CFightingObj pxFWalk=cast<CFightingObj>(xUnits[i].GetObj());
//			if(pxFWalk!=null)then
//				var real fPoison=pxAb^.GetValueF("damage");
//				var int iTickCount=pxAb^.GetValueI("count");
//				pxFWalk^.ProvidePoison(fPoison,iTickCount,GetHandle(),GetOwner());
//			endif;
//		endfor;
//	endproc;
	
	export proc void ProvidePoison(real p_fDmg, int p_iMaxCount, CObjHndl p_xSource, int p_iSource)
		return;
	endproc;
	
endclass;
	
class CSEASMercenary inherit CSEAS
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		EquipCustom();
	endproc;
	
	export proc void EquipCustom()
		var CFourCC xLink = "Back";
		var string sDeco = "seax_flamethrower_x3";
		SetLinkGFX(xLink,sDeco);
		xLink = "Blfa";
		sDeco = "seax_rider_b";
		SetLinkGFX(xLink,sDeco);
	endproc;
	
	export proc bool RemAllLinkGFX()
		var bool bReturn=super.RemAllLinkGFX();
		EquipCustom();
		return bReturn;
	endproc;
	
endclass;
	
class CTwins inherit CHero
	
	const real	STAYTIME						= 60.0f;
	const int		STAYTIME_TIMER_ID		= 667;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			SetUnique(true);
			CreateTimer(STAYTIME_TIMER_ID, CGameTimeSpan.OneSecond() * STAYTIME, false);
		endif;
	endproc;
	
	proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==STAYTIME_TIMER_ID)then
				Die();
				return;
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	export proc bool DoesCountInUnitLimit()
		return false;
	endproc;
	
	export proc void Die()
		if(!IsDead())then
			if(m_xTransportObj.IsValid())then
				var ^CTransportObj pxObj=cast<CTransportObj>(m_xTransportObj.GetObj());
				if(pxObj!=null)then
					pxObj^.OnDismount(GetHandle(),true,GetPos());
				endif;
			endif;
			m_fHitpoints=0.0f;
			SetVisible(false);
			SetDead(true);
			Delete();
		endif;
	endproc;
	
endclass;
	
	//========================================================================================
	//=== Animals ============================================================================
	//========================================================================================
	
class CAjeCarcharodontosaurus inherit CAnimal
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetActAutonomous(true);
	endproc;
	
	export proc bool DoesCountInUnitLimit()
		return false;
	endproc;
	
endclass;
	
class CAjeCatapultRex inherit CAnimal
	
	const vec3 BASKET_OFFSET_1			= {0.13,-1.0,-1.5};
	const vec3 CATAPULT_OFFSET_1		= {-3.0,-2.5,-0.7};
	const vec3 CATAPULT_OFFSET_2		= {3.0,-2.5,-0.7};
	
	var int m_iBuildUp;
	
	constructor()
		m_iBuildUp=0;
	endconstructor;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="ACTx")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			if(iVersion>=1)then
				pxArc^<<m_iBuildUp;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="ACTx";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		pxArc^<<m_iBuildUp;
		pxWalk^.Close();
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			ReBuildWeapon();
			StartTT();
			CreatePersonalProduceUnit();
		endif;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		var ^CTechTreeDef pxDef=GetTechTreeDef();
		if(pxDef!=null)then
			var string sNormal="/Filters/Aje/Upgrades/aje_catapult_rex/aje_catapult_rex_spear", sNew="/Filters/Aje/Upgrades/aje_catapult_rex/aje_catapult_rex_egg";
			if(!pxDef^.HasFilter(sNormal)&&!pxDef^.HasFilter(sNew))then
				pxDef^.EnableFilter(sNormal);
			endif;
		endif;
	endproc;
	
	export proc void HandleAction(string p_sAction)
		if(p_sAction.Find("aje_catapult_rex_spear")>=0)then
			if(m_iBuildUp!=1)then
				m_iBuildUp=0;
				DestroyAdditionalBuildUps();
				if(BuildSpears())then
					UpdateGfx();
				endif;
			endif;
		elseif(p_sAction.Find("aje_catapult_rex_egg")>=0)then
			if(m_iBuildUp!=2)then
				m_iBuildUp=0;
				DestroyAdditionalBuildUps();
				if(BuildEggs())then
					UpdateGfx();
				endif;
			endif;
		endif;
		GetBestWeapon(null, true);
	endproc;
	
	export proc void ReBuildWeapon()
		BuildBaseBuildUp();
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/Dismount")!=-1)
			)then return;
		endif;
		if(GetTransportObj().IsValid()&&!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/LeaveTransport")>=0))then return; endif;
		var ^CVirtualProduceUnit pxUnit=cast<CVirtualProduceUnit>(GetProduceUnit().GetObj());
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("/Aje/Upgrades/aje_catapult_rex/")!=-1&&pxUnit!=null)then
				pxUnit^.ReactToGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams, p_bQ, p_bS, p_bA);
				return;
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		elseif(p_sCommand=="Cancel"&&pxUnit!=null)then
			pxUnit^.ReactToGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams, p_bQ, p_bS, p_bA);
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	export proc bool BuildBaseBuildUp()
		SetBuildUp(CBuildUpBase.TYPE_TRANSPORTER_OPEN);
		var ^CBuildUpTransporterOpen pxTransBuildUp=cast<CBuildUpTransporterOpen>(GetBuildUp());
		pxTransBuildUp^.AddIgnoreLink("Dri1");
		pxTransBuildUp^.AddIgnoreLink("Dri2");
		pxTransBuildUp^.AddIgnoreLink("Dri3");
		pxTransBuildUp^.AddIgnoreLink("Dri4");
		var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("aje_stegosaurus_transporter", GetOwner());
		if(pxO!=null)then
			GetBuildUp()^.AddObj(pxO^.GetHandle(), "Ride");
//			GetBuildUp()^.AddObj(pxO^.GetHandle(), "Ride");
			GetBuildUp()^.AddObjCustomized(pxO^.GetHandle(), "Ride", BASKET_OFFSET_1);
		endif;
		return true;
	endproc;
	
	export proc bool BuildSpears()
		if(!HasBuildUp())then return false; endif;
		var ^CGameObj pxO=GetBuildUp()^.GetPrimaryLinkedObj().GetObj();
		if(pxO==null)then return false; endif;
		m_iBuildUp=1;
		AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
		var ^CBuildUpWeapon pxWeaponBuildUp=cast<CBuildUpWeapon>(GetAdditionalBuildUp(0));
		var ^CCaptain pxC=cast<CCaptain>(CSrvWrap.GetObjMgr()^.CreateObj("universal_captain", GetOwner()));
		pxC^.Init(GetHandle());
		pxWeaponBuildUp^.AddObjCaptain(pxC^.GetHandle(), "Dri2", -1.0, pxO^.GetHandle(), true);
		pxWeaponBuildUp^.SetWeaponClass("aje_arena_captain");
		pxWeaponBuildUp^.SetCanRotate(true);
		pxWeaponBuildUp^.SetAdditionalWeapon(true);
		pxWeaponBuildUp^.SetAutoAttack(true);
		
		AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
		pxWeaponBuildUp=cast<CBuildUpWeapon>(GetAdditionalBuildUp(1));
		pxC=cast<CCaptain>(CSrvWrap.GetObjMgr()^.CreateObj("universal_captain", GetOwner()));
		pxC^.Init(GetHandle());
		pxWeaponBuildUp^.AddObjCaptain(pxC^.GetHandle(), "Dri3", -1.0, pxO^.GetHandle(), true);
		pxWeaponBuildUp^.SetWeaponClass("aje_arena_captain");
		pxWeaponBuildUp^.SetCanRotate(true);
		pxWeaponBuildUp^.SetAdditionalWeapon(true);
		pxWeaponBuildUp^.SetAutoAttack(true);
		
		AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
		pxWeaponBuildUp=cast<CBuildUpWeapon>(GetAdditionalBuildUp(2));
		pxC=cast<CCaptain>(CSrvWrap.GetObjMgr()^.CreateObj("universal_captain", GetOwner()));
		pxC^.Init(GetHandle());
		pxWeaponBuildUp^.AddObjCaptain(pxC^.GetHandle(), "Dri1", -1.0, pxO^.GetHandle(), true);
		pxWeaponBuildUp^.SetWeaponClass("aje_arena_captain");
		pxWeaponBuildUp^.SetCanRotate(true);
		pxWeaponBuildUp^.SetAdditionalWeapon(true);
		pxWeaponBuildUp^.SetAutoAttack(true);
		
		AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
		pxWeaponBuildUp=cast<CBuildUpWeapon>(GetAdditionalBuildUp(3));
		pxC=cast<CCaptain>(CSrvWrap.GetObjMgr()^.CreateObj("universal_captain", GetOwner()));
		pxC^.Init(GetHandle());
		pxWeaponBuildUp^.AddObjCaptain(pxC^.GetHandle(), "Dri4", -1.0, pxO^.GetHandle(), true);
		pxWeaponBuildUp^.SetWeaponClass("aje_arena_captain");
		pxWeaponBuildUp^.SetCanRotate(true);
		pxWeaponBuildUp^.SetAdditionalWeapon(true);
		pxWeaponBuildUp^.SetAutoAttack(true);
		return true;
	endproc;
	
	export proc bool BuildEggs()
		m_iBuildUp=2;
		AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
		var ^CBuildUpWeapon pxWeaponBuildUp=cast<CBuildUpWeapon>(GetAdditionalBuildUp(0));
		var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("aje_ankylosaurus_catapult", GetOwner());
		pxWeaponBuildUp^.AddObjCustomized(pxO^.GetHandle(), "Ride",CATAPULT_OFFSET_1);
		var ^CCaptain pxC=cast<CCaptain>(CSrvWrap.GetObjMgr()^.CreateObj("universal_captain", GetOwner()));
		pxC^.Init(GetHandle());
		pxWeaponBuildUp^.AddObjCaptain(pxC^.GetHandle(), "Dri1", -1.0, pxO^.GetHandle(), true);
		pxWeaponBuildUp^.SetWeaponClass("aje_boss_catapult");
		pxWeaponBuildUp^.SetCanRotate(true);
		pxWeaponBuildUp^.SetAdditionalWeapon(true);
		pxWeaponBuildUp^.SetAutoAttack(true);
	
		AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
		pxWeaponBuildUp=cast<CBuildUpWeapon>(GetAdditionalBuildUp(1));
		pxO=CSrvWrap.GetObjMgr()^.CreateObj("aje_ankylosaurus_catapult", GetOwner());
		pxWeaponBuildUp^.AddObjCustomized(pxO^.GetHandle(), "Ride",CATAPULT_OFFSET_2);
	
		pxC=cast<CCaptain>(CSrvWrap.GetObjMgr()^.CreateObj("universal_captain", GetOwner()));
		pxC^.Init(GetHandle());
		pxWeaponBuildUp^.AddObjCaptain(pxC^.GetHandle(), "Dri1", -1.0, pxO^.GetHandle(), true);
		pxWeaponBuildUp^.SetWeaponClass("aje_boss_catapult");
		pxWeaponBuildUp^.SetCanRotate(true);
		pxWeaponBuildUp^.SetAdditionalWeapon(true);
		pxWeaponBuildUp^.SetAutoAttack(true);
		return true;
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		if(m_iBuildUp==1)then
			po_rxLink="Ride";
			po_rbIsBuildUpLink=true;
			SetCaptainAnim("nat_fight_standanim");
			SetCaptainAttackAnim("nat_throw");
		elseif(m_iBuildUp==2)then
			po_rxLink="Dri1";
			po_rbIsBuildUpLink=true;
			SetCaptainAnim("standanim");
			SetCaptainAttackAnim("aje_attack_ankylo");
		endif;
		return false;
	endproc;
	
	export proc void UpdateCaptainClass()
		super.UpdateCaptainClass();
		var int i, iC=NumAdditionalBuildUps();
		for(i=0)cond(i<iC)iter(i++)do
			cast<CBuildUpWeapon>(GetAdditionalBuildUp(i))^.UpdateCaptainObj();
		endfor;
	endproc;
	
//	export proc bool IsPoisonImmun()
//		return true;
//	endproc;
	
endclass;
	
class CAjeGallimimus inherit CAnimal
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_PARTYCOL,false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_HELMET,false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMOR,false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_STANDARTE,false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMORSADDLE,false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_MISC,false);
		SetActAutonomous(true);
	endproc;
	
	export proc void SetOwner(int p_iOwner)
		super.SetOwner(p_iOwner);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_PARTYCOL,false);
	endproc;
	
	export proc bool DoesCountInUnitLimit()
		return false;
	endproc;
	
	export proc void AddKillerCount(int p_iAdd)
		super.AddKillerCount(p_iAdd);
		if(GetLevel()<4)then
			if(m_iKillerCount>125)then
				SetLevelClean(4);
			elseif(m_iKillerCount>85)then
				SetLevelClean(3);
			elseif(m_iKillerCount>50)then
				SetLevelClean(2);
			elseif(m_iKillerCount>20)then
				SetLevelClean(1);
			endif;
		endif;
	endproc;
	
endclass;
	
class CAjeHeterodontosaurus inherit CAnimal
	
	const real LIFTIME										= 40.0f;
	const real ALARM_RANGE_CHECK_INTERVAL	= 3.0f;
	
	const int	LIFETIME_TIMER_ID = 666;
	const int	CHECK_ALARM_RANGE = 667;
	const int	CHOOSE_NEW_DEST = 668;
	
	var bool m_bExplooooded; // ^^
	
	export constructor()
		m_bExplooooded = false;
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetActAutonomous(true);
		SetCanUseSiege(false);
		if(!p_bLoad)then
			CreateTimer(LIFETIME_TIMER_ID, CGameTimeSpan.OneSecond() * LIFTIME, false);
			CreateTimer(CHECK_ALARM_RANGE, CGameTimeSpan.OneSecond() * ALARM_RANGE_CHECK_INTERVAL, true);
//			OnActionEnd(false);
			ExamineEnemies(true);
//			AutoScout();
		endif;
//		OnActionEnd(false);
	endproc;
	
	export proc bool IsAbleToWalk()
		return true;
	endproc;
	
	proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass() == ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0) == LIFETIME_TIMER_ID)then
				Die();
				//Explode();
			elseif(p_rxEvtPtr.GetInt(0) == CHECK_ALARM_RANGE) then
				if(m_xCurEnemy.IsValid())then
					if(!CheckForNearbyEnemies()&&!HasWalkAction())then
						AutoScout();
					endif;
				endif;
			endif;
		elseif(p_rxEvtPtr.GetClass()=="CTheLite")then
			var ^CTheLite pxTask = cast<CTheLite>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"CTheLite"));
			if(pxTask^.Init(GetHandle(), p_rxEvtPtr.GetObjHandle(0), true))then
				AddTask(pxTask,true);
			else
				pxTask^.GetFactory()^.FreeState(pxTask);
			endif;
			return;
		endif;
		super.HandleEvent(p_rxEvtPtr);
	endproc;
	
	proc vec3 ChooseRandomDestination(real p_fRadius, real p_fAng)
		var real fAng = (Random.GetInt()%(p_fAng*2.0f).ToInt() - (p_fAng.ToInt())).ToReal() * 0.3f;
		var vec3 vCurPos = GetPos();
		var vec3 vCurDir = {0.0, 1.0, 0.0};
		var vec3 vRotVec;
		vRotVec.SetZ(fAng);
		var Quat qRot;
		qRot.FromVec3(vRotVec);
		qRot = GetRot() * qRot;
		qRot.VecRotateU(vCurDir);
		vCurDir*=p_fRadius;
		return vCurPos+vCurDir;
	endproc;
	
	proc void OnActionStart()
		GetFSM()^.Enable(false);
	endproc;
	
	proc bool CheckForNearbyEnemies()
		var CObjQuery xQ;
		xQ.RegionCircle(GetPos(), 50.0f);
		xQ.SetType("CHTR", false);
		xQ.SetType("ANML", true);
		xQ.SetType("VHCL", true);
		xQ.SetType("BLDG", true);
		xQ.SetAttribsNeg("flying_unit",true);
		xQ.SetAttribsNeg("not_detectable",true);
		var int i, iC=8;
		var int iMyOwner = GetOwner();
		var bool bApp = false;
		for (i=0) cond(i<iC) iter(++i) do
			if (i!=iMyOwner && CSrvWrap.GetDiplomacyMgr().GetIsEnemy(iMyOwner, i)) then
				xQ.SetOwner(i, bApp);
				if (!bApp) then bApp=true; endif;
			endif;
		endfor;
		var ^CGameObj pxEnemy = null;
		var ^CObjList pxList = CSrvWrap.GetObjMgr()^.GetOwnerEnemyList(GetOwner());
		var CObjList xL;
		if (pxList != null) then
			pxList^.CopySorted(xL, GetPos(), 100.0f);
		endif;
		if (xL.NumEntries() > 0) then
			var int i, iC = xL.NumEntries();
			for(i=0) cond(i<iC) iter(++i) do
				if (xL[i].IsValid()) then
					var ^CGameObj pxO = xL[i].GetObj();
					if (pxO!=null) then
						pxEnemy = pxO;
						break;
					endif;
				endif;
			endfor;
		endif;
		if (pxEnemy!=null) then
			var vec3 vEPos = pxEnemy^.GetPos();
			Fight(pxEnemy, vEPos, true, false);
			if((vEPos-GetPos()).Abs2() < (pxEnemy^.GetRadius()+GetRadius()))then
				Explode(pxEnemy^.GetPos());
			elseif(!(m_xCurEnemy==pxEnemy^.GetHandle()))then
				GoTo(vEPos, true, GetDefaultSpeed(), true, true, false, false, true);
				m_xCurEnemy = pxEnemy^.GetHandle();
			endif;
			return true;
		endif;
		return false;
	endproc;
	
	export proc bool AttackEnemy(^CFightingObj p_pxEnemy, vec3 p_vTarget, ref bool p_rbRotated)
		if(p_pxEnemy==null)then return false; endif;
		if(p_pxEnemy^.IsFlyingUnit()/* && !CanShootAir()*/)then return false; endif;
		if(IsInCombatRange(p_pxEnemy))then
			Explode(p_pxEnemy^.GetPos());
			return false;
		endif;
		return super.AttackEnemy(p_pxEnemy, p_vTarget, p_rbRotated);
	endproc;

	export proc void OnActionEnd(bool p_bBroken)
		super.OnActionEnd(p_bBroken);
//		if(m_bExplooooded)then
//			Die();
//			return;
//		endif;
		if(!p_bBroken&&!CheckForNearbyEnemies()) then
			var vec3 vP = ChooseRandomDestination(25.0f, 2.0f);
			GoTo(vP, true, GetDefaultSpeed(), true, true, false, false, true);
		endif;
	endproc;
	
	export proc void HandleGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams)
		if(p_sMiscParams.Find("/Kill")!=-1)then
			Die();
		elseif(p_sCommand=="Attack" || p_sCommand=="Fight")then
			if(p_pxObject!=null)then
				Fight(p_pxObject, p_pxObject^.GetPos(), true, false);
			endif;
		endif;
		return;
	endproc;
	
	export proc void Explode(vec3 p_vPos)
		if(m_bExplooooded)then return; endif;
		m_bExplooooded=true;
		var real fDmg=GetDmg();
		var real fEnd=GetEndDmg();
		var real fHit=GetHitRange();
		fDmg *= GetTechTreeModifier("Damage",true);
		fDmg += GetTechTreeModifier("Damage",false);
		AnimAction("dying");
		CreateCustomFX(8,GetPos(),true);
//		var ^CAreaDamage pxDmg = new CAreaDamage(this, "/Objects/Aje/Weapons/aje_kamikaze_dino_ammo", p_vPos);
//		var ^CAreaDamage pxDmg = new CAreaDamage(this, m_xSpawningPool, GetHitRange(), fDmg, GetEndDmg(), GetOwner(), p_vPos, GetWeaponSizeClass());
		var ^CAreaDamage pxDmg = new CAreaDamage(null, m_xSpawningPool, fHit, fDmg, fEnd, GetOwner(), p_vPos, GetWeaponSizeClass());
		Die();
	endproc;
	
	export proc void Die()
		if(!IsDead())then
			m_fHitpoints = 0.0f;
			SetDead(true);
			Delete();
		endif;
	endproc;
	
	proc void OnIdleTick(int p_iTime)
		if (!CheckForNearbyEnemies()) then
			var vec3 vP = ChooseRandomDestination(25.0f, 2.0f);
			GoTo(vP, true, GetMaxSpeed(), true, true);
			return;
		endif;
		super.OnIdleTick(p_iTime);
	endproc;
	
	export proc bool DoesCountInUnitLimit()
		return false;
	endproc;
	
	export proc CObjHndl GetEnemyHandle()
		return m_xSpawningPool;
	endproc;
	
	export proc bool ExamineEnemies(bool p_bAlarm)
		return super.ExamineEnemies(p_bAlarm, true);
	endproc;
	
	export proc bool ExamineEnemies(bool p_bAlarm, bool p_bFillEnemyList)
		return super.ExamineEnemies(true, p_bFillEnemyList);
	endproc;
	
endclass;

class CAjeKamikazePsittacosaurus inherit CAnimal
	
	const real LIFETIME=30.0f;
	const int LIFETIME_TIMER=666;
	const int CHECK_ALARM_RANGE=667;
	const int CHOOSE_NEW_DEST=668;
	const real ALARM_RANGE_CHECK_INTERVAL = 3.0f;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetActAutonomous(true);
		SetCanUseSiege(false);
		if(!p_bLoad)then
			CreateTimer(LIFETIME_TIMER, CGameTimeSpan.OneSecond() * LIFETIME, false);
			CreateTimer(CHECK_ALARM_RANGE, CGameTimeSpan.OneSecond() * ALARM_RANGE_CHECK_INTERVAL, true);
			ExamineEnemies(true);
//			OnActionEnd(false);
//			AutoScout();
		endif;
	endproc;
	
	export proc bool IsAbleToWalk()
		return true;
	endproc;
	
	proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==LIFETIME_TIMER)then
				Die();
				return;
			elseif(p_rxEvtPtr.GetInt(0)==CHECK_ALARM_RANGE)then
				if(!m_xCurEnemy.IsValid())then
					if(!CheckForNearbyEnemies()&&!HasWalkAction())then
						AutoScout();
					endif;
				endif;
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	proc vec3 ChooseRandomDestination(real p_fRadius, real p_fAng)
		var real fAng=(Random.GetInt()%(p_fAng*2.0f).ToInt() - (p_fAng.ToInt())).ToReal() * 0.3f;
		var vec3 vCurPos=GetPos();
		var vec3 vCurDir={0.0, 1.0, 0.0};
		var vec3 vRotVec;
		vRotVec.SetZ(fAng);
		var Quat qRot;
		qRot.FromVec3(vRotVec);
		qRot=GetRot() * qRot;
		qRot.VecRotateU(vCurDir);
		vCurDir*=p_fRadius;
		return vCurPos+vCurDir;
	endproc;
	
	proc void OnActionStart()
		GetFSM()^.Enable(false);
	endproc;
	
	proc bool CheckForNearbyEnemies()
		var CObjQuery xQ;
		xQ.RegionCircle(GetPos(), 50.0f);
		xQ.SetType("CHTR", false);
		xQ.SetType("ANML", true);
		xQ.SetType("VHCL", true);
		xQ.SetType("BLDG", true);
		var int i, iC=8;
		var int iMyOwner=GetOwner();
		var bool bApp=false;
		for (i=0) cond(i<iC) iter(++i)do
			if(i!=iMyOwner && CSrvWrap.GetDiplomacyMgr().GetIsEnemy(iMyOwner, i))then
				xQ.SetOwner(i, bApp);
				if(!bApp)then bApp=true; endif;
			endif;
		endfor;
		var ^CGameObj pxEnemy=null;
		var ^CObjList pxList=CSrvWrap.GetObjMgr()^.GetOwnerEnemyList(GetOwner());
		var CObjList xL;
		if(pxList!=null)then
			pxList^.CopySorted(xL, GetPos(), 100.0f);
		endif;
		if(xL.NumEntries() > 0)then
			var int i, iC=xL.NumEntries();
			for(i=0) cond(i<iC) iter(++i)do
				if(xL[i].IsValid())then
					var ^CGameObj pxO=xL[i].GetObj();
					if(pxO!=null)then
						pxEnemy=pxO;
						break;
					endif;
				endif;
			endfor;
		endif;
		if(pxEnemy!=null)then
			var vec3 vEPos=pxEnemy^.GetPos();
			Fight(pxEnemy, vEPos, true, false);
			return true;
		endif;
		return false;
	endproc;
	
	proc void OnIdleTick(int p_iTime)
		if(!CheckForNearbyEnemies())then
			var vec3 vP=ChooseRandomDestination(25.0f, 2.0f);
			GoTo(vP, true, GetMaxSpeed(), true, true);
			return;
		endif;
		super.OnIdleTick(p_iTime);
	endproc;
	
	export proc void OnActionEnd(bool p_bBroken)
		super.OnActionEnd(p_bBroken);
	endproc;
	
	export proc bool DoesCountInUnitLimit()
		return false;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(p_sMiscParams.Find("/Kill")!=-1)then
			Die();
		endif;
		return;
	endproc;
	
	export proc void AddKillerCount(int p_iAdd)
		if(m_xSpawningPool.IsValid())then
			var ^CFightingObj pxSpawningPool=cast<CFightingObj>(m_xSpawningPool.GetObj());
			if(pxSpawningPool!=null)then
				pxSpawningPool^.AddKillerCount(p_iAdd);
			endif;
		endif;
	endproc;
	
	export proc void Die()
		Delete();
	endproc;
	
	export proc void Delete()
		if(GetOwner()!=-1)then
			RemoveUnit();
		endif;
		super.Delete();
	endproc;
	
	export proc bool ExamineEnemies(bool p_bAlarm)
		return super.ExamineEnemies(p_bAlarm, true);
	endproc;
	
	export proc bool ExamineEnemies(bool p_bAlarm, bool p_bFillEnemyList)
		return super.ExamineEnemies(true, p_bFillEnemyList);
	endproc;
	
endclass;
	
class CAjePteranodon inherit CAnimal
	
	const real FLYING_HEIGHT=15.0f;
	const real COLLISION_FIX=4.0f;
	const real COLLISION_CHECK=3.5f;
	const real COLLISION_PLUS=0.5f;
	const int TIMER_COLLISION_HANDLER=40157;
	var array string m_asClasses;
	
	var real m_fCollisionRadius;
	var CRegionSink m_xCollisionSink;
	var CGuid m_xCollisionGuid;
	var CObjList m_xCollisionObjects;
	
	export constructor()
		m_xCollisionSink.m_xOnObjAdd=OnCollObjAdd;
		m_xCollisionSink.m_xOnObjRem=OnCollObjRem;
		if(m_asClasses.NumEntries()==0)then
			m_asClasses.AddEntry("aje_pteranodon");
			m_asClasses.AddEntry("hu_pteranodon");
			m_asClasses.AddEntry("ninigi_cargolifter");
			m_asClasses.AddEntry("ninigi_dirigible");
			m_asClasses.AddEntry("seas_helicopter");
			m_asClasses.AddEntry("aje_zeppelin");
			m_asClasses.AddEntry("hu_zeppelin");
			m_asClasses.AddEntry("ninigi_zeppelin");
			m_asClasses.AddEntry("seas_zeppelin");
		endif;
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="AjPt")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			if(iVersion>=1)then
				pxArc^<<m_xRegionGuid;
				pxArc^<<m_fCollisionRadius;
				m_xRegionObjects.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="AjPt";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		pxArc^<<m_xRegionGuid;
		pxArc^<<m_fCollisionRadius;
		m_xRegionObjects.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetCanWalk(false);
		SetCanSwim(false);
		SetCanFly(true);
//		m_fCollisionRadius=GetCollisionRadius()+0.5f;
		m_fCollisionRadius=3.5f;
		if(!p_bLoad)then
			if(m_xCollisionGuid.IsNull())then
				var vec3 vD;
				vD.SetXYZ(m_fCollisionRadius, m_fCollisionRadius, 0.0);
				CreateCollisionRegion(vD, 010b);
			endif;
		endif;
	endproc;
	
	proc void CreateCollisionRegion(vec3 p_vDimension, bitset p_dwType)
		if(!m_xCollisionGuid.IsNull())then return; endif;
		var ^CRegionMgr pxRM=^(CSrvWrap.GetRegionMgr());
		if(pxRM!=null)then
			var int iIdx=pxRM^.CreateRegion(GetName()+"_CollReg", p_dwType, GetPos(), p_vDimension);
			if(iIdx>=0)then
				var ^CRegion pxRegion=pxRM^.GetRegion(iIdx);
				m_xCollisionGuid=pxRegion^.GetGUID();
				m_xCollisionSink.SetRegion(pxRegion);
				pxRegion^.BindToObj(GetHandle());
				m_xCollisionSink.Subscribe();
			endif;
		endif;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		if(!m_xCollisionGuid.IsNull())then
			var int iIdx=CSrvWrap.GetRegionMgr().FindRegion(m_xCollisionGuid);
			if(iIdx>=0)then
				var ^CRegion pxRegion=CSrvWrap.GetRegionMgr().GetRegion(iIdx);
				if(pxRegion!=null)then
					m_xCollisionSink.SetRegion(pxRegion);
					pxRegion^.BindToObj(GetHandle());
					m_xCollisionSink.Subscribe();
				endif;
			else
				var CGuid xG; m_xCollisionGuid=xG;
			endif;
		endif;
	endproc;
	
	proc void DeleteCollisionRegion()
		if(!m_xCollisionGuid.IsNull())then
			var ^CRegionMgr pxRM=^(CSrvWrap.GetRegionMgr());
			if(pxRM!=null)then
				var int iIdx=CSrvWrap.GetRegionMgr().FindRegion(m_xCollisionGuid);
				if(iIdx>=0)then
					var ^CRegion pxRegion=pxRM^.GetRegion(iIdx);
					m_xCollisionSink.Unsubscribe();
					if(pxRegion!=null)then
						pxRegion^.Unbind();
					endif;
					m_xCollisionSink.DeleteRegion();
					var CGuid xNew;
					m_xCollisionGuid=xNew;
				endif;
			endif;
		endif;
	endproc;
	
	proc bool OnCollObjAdd(CObjHndl p_xHndl)
		if(m_bToBeDeleted)then return false; endif;
		if(p_xHndl==GetHandle())then return false; endif;
		var ^CFightingObj pxFO=cast<CFightingObj>(p_xHndl.GetObj());
//		if(pxFO!=null&&pxFO^.IsFlyingUnit()&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxFO^.GetOwner(), GetOwner())&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxFO^.GetOwner()))then
		if(pxFO!=null&&pxFO^.IsFlyingUnit()&&pxFO^.GetOwner()==GetOwner())then
			if(m_asClasses.FindEntry(pxFO^.GetClassName())>=0)then
				m_xRegionObjects.Include(p_xHndl);
				Disengage();
				if(!HasTimer(TIMER_COLLISION_HANDLER))then
					CreateTimer(TIMER_COLLISION_HANDLER, CGameTimeSpan.OneSecond() * COLLISION_CHECK, true);
				endif;
			endif;
		endif;
		return true;
	endproc;
	
	proc bool OnCollObjRem(CObjHndl p_xHndl)
		if(m_xRegionObjects.FindEntry(p_xHndl)==-1)then return false; endif;
		m_xRegionObjects.RemEntry(p_xHndl);
		if(m_xRegionObjects.NumEntries()<1)then
			DeleteTimer(TIMER_COLLISION_HANDLER);
		endif;
		return true;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==TIMER_COLLISION_HANDLER)then
				Disengage();
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	export proc void Disengage()
		var string sAct=GetActionDesc();
		if(sAct!="CActWalk"&&sAct!="CActFlight"&&!HasSecondaryAction())then
			var real fD=Random.MTRandF(Math.Pi()*2.0f);
			var vec3 vOffset, vNew;
			vOffset.SetX(m_fCollisionRadius+COLLISION_PLUS);
			vOffset.RotZ((Random.GetInt()%628).ToReal() / 100.0);
//			vOffset.SetXYZ(Math.Sin(fD),Math.Cos(fD),0.0f);
			vNew=GetPosInMap(GetPos()+vOffset);
			vNew.SetZ(Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vNew.GetX(),vNew.GetY()),m_fWaterLevel)+FLYING_HEIGHT);
			SecondaryMoveAction(vNew,COLLISION_FIX);
			UpdateAggressionPos(vNew);
		endif;
	endproc;
	
	export proc bool AttackEnemy(^CFightingObj p_pxEnemy, vec3 p_vTarget, ref bool p_rbRotated)
		if(p_pxEnemy!=null)then
			if(p_pxEnemy^.IsFlyingUnit() && !CanShootAir())then return false; endif;
		endif;
		var string sProj=GetProjectile();
//		var string sFAnim=GetNextFightAnim();
		var string sFAnim="idle";
		if(!HasAnim(sFAnim))then sFAnim="attack_front"; endif;
		var bool bProj=!sProj.IsEmpty();
		var bool bFAnim=!sFAnim.IsEmpty();
		begin Rotate;
			var real fAngle;
			var Quat qRot;
			if(p_pxEnemy!=null)then
				fAngle=GetAngleToR(p_pxEnemy);
				qRot=GetAngleToQ(p_pxEnemy);
			else
				fAngle=GetAngleToR(p_vTarget);
				qRot=GetAngleToQ(p_vTarget);
			endif;
			if(!bProj&&bFAnim)then
				if(GetPenetration()&&fAngle>(Math.Pi()/16.0f))then
					//AnimAction("idle");
					//SecRotAction(qRot,1.5)
//					RotateActionSpeed(qRot,100.0);
					RotateAction(qRot,"idle");
					DoCaptainAttackAnim();
					p_rbRotated=true;
				elseif(fAngle>Math.Pi()/8.0)then
//					RotateActionSpeed(qRot,100.0);
					RotateAction(qRot,"idle");
					DoCaptainAttackAnim();
					p_rbRotated=true;
					return true;
				endif;
			else
				if(fAngle>Math.Pi()/4.0||(GetPenetration()&&fAngle>Math.Pi()/16.0f))then
					RotateActionSpeed(qRot,100.0);
					//RotateAction(qRot,"idle",10.0);
					p_rbRotated=true;
					return false;
				endif;
			endif;
		end Rotate;
		if(bProj)then
			var int j, iK=GetProjectilesNumber();
			for(j=0)cond(j<iK)iter(j++)do
				CreateProjectileAndShoot(p_pxEnemy, p_vTarget);
			endfor;
			if(sFAnim!=""&&HasAnim(sFAnim)&&GetCurrentAnimName()!=sFAnim)then
				SetAnim(sFAnim,3);
			endif;
			DoCaptainAttackAnim();
			return false;
		elseif(bFAnim)then
			if(sFAnim!=""&&HasAnim(sFAnim)&&GetCurrentAnimName()!=sFAnim)then
				SetAnim(sFAnim,3);
			endif;
			DoCaptainAttackAnim();
		endif;
		return true;
	endproc;
	
	export proc void DoCaptainAttackAnim()
		if(m_xCaptain.IsValid())then
			var ^CGameObj pxCaptain=m_xCaptain.GetObj();
			if(pxCaptain^.HasAnim(m_sCaptainAttackAnim))then
				pxCaptain^.SetAnim(m_sCaptainAttackAnim, 1);
			endif;
		endif;
	endproc;
	
	export proc void PickUp(CObjHndl p_xItem,bool p_bQueue)
		var ^CGameObj pxO=p_xItem.GetObj();
		if(pxO!=null)then
			GoTo(pxO^.GetPos(), true, GetDefaultSpeed(), true, true, GetOnWall(), false, true);
		endif;
		return;
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		po_rxLink="Ride";
		SetCaptainAnim("ride_idle_0");
		SetCaptainAttackAnim("ride_bow");
		return true;
	endproc;
	
	export proc void SetIdleAnim()
		DoCaptainAnim();
		if(HasAnim("idle")&&GetCurrentAnimName()!="idle")then
			SetAnim("idle",3);
		endif;
		return;
	endproc;
	
	export proc void OnIdleEnter(^CState p_pxFrom, ^CState p_pxTo)
//		Flight();
		super.OnIdleEnter(p_pxFrom,p_pxTo);
	endproc;
	
	export proc void Flight()
		var string sAct=GetActionDesc();
		if(sAct!="CActFlight")then
			var ^CAttribs pxAttr=GetAttribs();
			if(pxAttr!=null)then
				if(pxAttr^.GetValue("CurTask")!="Idle")then
					pxAttr^.SetValue("CurTask","Idle");
				endif;
				SetTaskDescription("idle");
			endif;
			var real fD=Random.MTRandF(Math.Pi()*2.0f);
			var vec3 vO;
			vO.SetXYZ(Math.Sin(fD),Math.Cos(fD),0.0f);
			FlightAction(GetAggressionPos()+vO,GetMaxSpeed(),GetWalkSet(),03h,FLYING_HEIGHT);
		endif;
	endproc;
	
	export proc void CPDF()
		var string sAct=GetActionDesc();
		if(sAct=="CActFlight")then
			CheckPatrol();
		endif;
	endproc;
	
//	export proc void OnActionStart()
//		super.OnActionStart();
//	endproc;
	
//	export proc void OnActionPreEnd(bool p_bBroken)
//		super.OnActionPreEnd(p_bBroken);
//	endproc;
	
//	export proc void OnActionEnd(bool p_bBroken)
//		super.OnActionEnd(p_bBroken);
//	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj , ref CGameObj.CAdvanceActionParams p_rxParams)
		if(!p_xGoalObj.IsValid())then return; endif;
		var vec3 vObj=p_xGoalObj.GetObj()^.GetPos(), vOwn=GetPos(),vNew;
		var real fScape=Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vOwn.GetX(),vOwn.GetY()),m_fWaterLevel);
		var real fHeight=vOwn.GetZ()-fScape, fRange=GetAttackRange()/*+fHeight-GetRadius()*/;
		vOwn.SetZ(fScape);
		var vec3 vDirection=vOwn - vObj;
		vDirection.Normalize();
		vNew=GetPosInMap(vObj+(vDirection*fRange));
		WalkAction(vNew, GetMaxSpeed(), false);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption, ^CGameObj p_pxGoalObj, CFourCC p_xWalkSet, bool p_bUseMaterial)
		var vec3 vPosition=GetPosInMap(p_vDest);
//		vPosition.SetZ(p_vDest.GetZ()+FLYING_HEIGHT);
		vPosition.SetZ(Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vPosition.GetX(),vPosition.GetY()),m_fWaterLevel)+FLYING_HEIGHT);
		return super.WalkAction(vPosition, p_iPrefSpeed, false, false, p_pxGoalObj, p_xWalkSet, p_bUseMaterial);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption, ^CGameObj p_pxGoalObj, CFourCC p_xWalkSet)
		return WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, p_bHeightAdaption, p_pxGoalObj, p_xWalkSet, true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption, ^CGameObj p_pxGoalObj)
		return WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, p_bHeightAdaption, p_pxGoalObj, GetWalkSet(), true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption)
		return WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, p_bHeightAdaption, null, GetWalkSet(), true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder)
		return WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, true, null, GetWalkSet(), true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed)
		return WalkAction(p_vDest, p_iPrefSpeed, true, true, null, GetWalkSet(), true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest)
		return WalkAction(p_vDest, GetMaxSpeed(), true, true, null, GetWalkSet(), true);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed, CFourCC p_xWalkSet, real p_fMaxRange, ref vec3 p_rvRootPos, ref vec3 p_rvGoalOffset)
		if(!p_xGoalObj.IsValid())then return; endif;
		var vec3 vObj=p_xGoalObj.GetObj()^.GetPos(), vOwn=GetPos(),vNew;
		var real fScape=Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vOwn.GetX(),vOwn.GetY()),m_fWaterLevel);
		var real fHeight=vOwn.GetZ()-fScape, fRange=GetAttackRange()/*+fHeight-GetRadius()*/;
		vOwn.SetZ(fScape);
		var vec3 vDirection=vOwn - vObj;
		vDirection.Normalize();
		vNew=GetPosInMap(vObj+(vDirection*fRange));
		WalkAction(vNew, GetMaxSpeed(), false);
//		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed, p_xWalkSet, p_fMaxRange, p_vRootPos, p_vGoalOffset);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed, CFourCC p_xWalkSet, real p_fMaxRange, ref vec3 p_rvRootPos)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed, p_xWalkSet, p_fMaxRange, p_rvRootPos);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed, CFourCC p_xWalkSet, real p_fMaxRange)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed, p_xWalkSet, p_fMaxRange);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed, CFourCC p_xWalkSet)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed, p_xWalkSet);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj)
		return super.AdvanceAction(p_xGoalObj);
	endproc;
	
//	export proc void Die()
//		if(!IsDead())then
//			if(m_xTransportObj.IsValid())then
//				var ^CTransportObj pxObj=cast<CTransportObj>(m_xTransportObj.GetObj());
//				if(pxObj!=null)then
//					pxObj^.OnDismount(GetHandle(),true,GetPos());
//				endif;
//			endif;
//			m_fHitpoints=0.0f;
//			SetVisible(false);
//			SetDead(true);
//			Delete();
//		endif;
//	endproc;
	
	export proc void Delete()
		DeleteCollisionRegion();
		var ^CPteranodonCorpse pxGameObj=cast<CPteranodonCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("aje_pteranodon_corpse",GetOwner(),GetPos(),GetRotation()));
		if(pxGameObj!=null)then
			pxGameObj^.SetSource(this);
			pxGameObj^.Init(GetName(), 0.0001);
		endif;
		super.Delete();
	endproc;
	
	export proc void AddFlyingHeight(vec3 p_vPos, real p_fSpeed)
		var real fHeight=FLYING_HEIGHT;
		var vec3 vPos=GetPos();
		vPos.SetZ(vPos.GetZ()+fHeight);
		MoveAction(vPos, p_fSpeed);
		return;
	endproc;
	
	export proc void PutIntoPlace(vec3 p_vPos)
		var real fHeight=FLYING_HEIGHT;
		var vec3 vPos=p_vPos;
		vPos.SetZ(vPos.GetZ()+fHeight);
		SetPos(vPos);
		return;
	endproc;
	
	export proc void StopEverything()
		super.StopEverything();
		SetIdleAnim();
	endproc;
	
	export proc void SetIced(real p_fDuration,real p_fResistStart)
		return;
	endproc;
	
	export proc bool SkipCorpse()
		return true;
	endproc;
	
	export proc real GetFlyingHeight()
		return FLYING_HEIGHT;
	endproc;
	
endclass;
	
class CAjeTyrannosaurus inherit CAnimal
	
	constructor()
		m_xSink.m_xOnObjAdd=OnObjAdd;
		m_xSink.m_xOnObjRem=OnObjRem;
	endconstructor;
	
	export destructor()
	enddestructor;
	
	proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			ReBuildWeapon();
		endif;
	endproc;
	
	export proc void ReBuildWeapon()
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_PARTYCOL,true);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,true);
		SetBuildUp(CBuildUpBase.TYPE_FAKE);
		AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
		var ^CBuildUpWeapon pxWeaponBuildUp=cast<CBuildUpWeapon>(GetAdditionalBuildUp(0));
		pxWeaponBuildUp^.AddObjCaptain(m_xCaptain, "Ride", -1.0, GetHandle());
		pxWeaponBuildUp^.SetWeaponClass("aje_tyranno_char");
		pxWeaponBuildUp^.SetCanRotate(true);
		pxWeaponBuildUp^.SetAdditionalWeapon(true);
	endproc;
	
	proc bool OnObjAdd(CObjHndl p_xHndl)
		if(m_bToBeDeleted)then return false; endif;
		var ^CFightingObj pxO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxO==null)then return false; endif;
		if(pxO^.GetOwner()==GetOwner())then return false; endif;
		if(CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxO^.GetOwner(), GetOwner())&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxO^.GetOwner()))then return false; endif;
		if(!CSrvWrap.GetDiplomacyMgr().GetIsEnemy(GetOwner(), pxO^.GetOwner()))then return false; endif;
		if(pxO^.GetType()=="BLDG")then return false; endif;
		m_xRegionObjects.Include(p_xHndl);
		pxO^.SetMirageFlag(CFightingObj.MIRAGE_KING_JAW, true);
		return true;
	endproc;
	
	proc bool OnObjRem(CObjHndl p_xHndl)
		if(m_xRegionObjects.FindEntry(p_xHndl)==-1)then return false; endif;
		var ^CFightingObj pxO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxO==null)then return false; endif;
		pxO^.SetMirageFlag(CFightingObj.MIRAGE_KING_JAW, false);
		m_xRegionObjects.RemEntry(p_xHndl);
		return true;
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		po_rxLink="Ride";
		po_rbIsBuildUpLink=false;
		SetCaptainAnim("ride_idle_0");
		SetCaptainAttackAnim("ride_bow");
		return true;
	endproc;
	
	export proc string GetThreatAnim()
		return "roaring";
	endproc;
	
endclass;
	
class CEusmilusRider inherit CAnimal
	/*
	proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			ReBuildWeapon();
		endif;
	endproc;
	
	export proc void ReBuildWeapon()
		SetBuildUp(CBuildUpBase.TYPE_FAKE);
		AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
		var ^CBuildUpWeapon pxWeaponBuildUp=cast<CBuildUpWeapon>(GetAdditionalBuildUp(0));
		pxWeaponBuildUp^.AddObjCaptain(m_xCaptain, "Ride", -1.0, GetHandle());
		var string sClass=GetClassName().Left(GetClassName().Find("_"));
		pxWeaponBuildUp^.SetWeaponClass(sClass+"_cat_rider");
		pxWeaponBuildUp^.SetCanRotate(true);
		pxWeaponBuildUp^.SetAdditionalWeapon(true);
		pxWeaponBuildUp^.SetAutoAttack(true);
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		po_rxLink="Ride";
		po_rbIsBuildUpLink=false;
		SetCaptainAnim("ride_idle_0");
		SetCaptainAttackAnim("ride_bow");
		return true;
	endproc;
	*/
	export proc string GetVictoryAnim()
		var string sAnim="menace";
		if(Random.GetInt()%2==1)then
			sAnim="shake";
		endif;
		return sAnim;
	endproc;
	
	export proc string EatAnim()
		return "feeding";
	endproc;
	
endclass;
	
class CHuCarcharodontosaurus inherit CAnimal
	
	const vec3 BALLISTA_OFFSET={0.0,-0.75,0.0};
	
	export constructor()
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			ReBuildWeapon();
		endif;
	endproc;
	
	export proc void ReBuildWeapon()
		if(GetClassName()=="hu_carcharodontosaurus")then
			SetBuildUp(CBuildUpBase.TYPE_FAKE);
//			CreateCaptain();
			var ^CGameObj pxMisc = CSrvWrap.GetObjMgr()^.CreateObj("hu_rhino_ballista_buildup_bottom", GetOwner());
			if(pxMisc!=null)then
				GetBuildUp()^.AddObjCustomized(pxMisc^.GetHandle(), "Rider",BALLISTA_OFFSET);
				pxMisc^.SetRndInvMaskSingleFlagInv(VIS_FLAG_VHCL_RAM_LOW, true);
			endif;
			AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
			var ^CBuildUpWeapon pxWeaponBuildUp = cast<CBuildUpWeapon>(GetAdditionalBuildUp(0));
			var ^CGameObj pxO = CSrvWrap.GetObjMgr()^.CreateObj("hu_rhino_ballista_buildup_top", GetOwner());
			if(pxO!=null)then
				pxWeaponBuildUp^.AddObjCustomized(pxO^.GetHandle(), "Rider",BALLISTA_OFFSET);
				pxO^.SetRndInvMaskSingleFlagInv(VIS_FLAG_VHCL_RAM_HIGH,true);
			endif;
//			pxWeaponBuildUp^.AddObjCaptain(m_xCaptain, "Dri1", -1.0, pxO^.GetHandle());
			var ^CCaptain pxC=cast<CCaptain>(CSrvWrap.GetObjMgr()^.CreateObj("universal_captain", GetOwner()));
			pxC^.Init(GetHandle());
			pxWeaponBuildUp^.AddObjCaptain(pxC^.GetHandle(), "Dri1", -1.0, pxO^.GetHandle());
			pxWeaponBuildUp^.SetWeaponClass("hu_predator_ballista");
			pxWeaponBuildUp^.SetCanRotate(true);
			pxWeaponBuildUp^.SetAutoAttack(true);
			pxWeaponBuildUp^.SetAdditionalWeapon(true);
		endif;
	endproc;
	
//	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
//		if(	IsTrapped() &&
//			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
//			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
//			)then return; endif;
//		if(p_sCommand=="walk")then
//			GoTo(p_vPos, true, GetDefaultSpeed(), true, true);
//		else
//			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
//		endif;
//	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		po_rxLink="Dri1";
		po_rbIsBuildUpLink=true;
		SetCaptainAnim("hu_balista_steamtank_sitpos");
		SetCaptainAttackAnim("hu_balista_steamtank_attack");
		return false;
	endproc;
	
endclass;
	
class CHuLogTitan inherit CAnimal
	
	const vec3 CANNON_OFFSET_LOWER = {-0.075,0.36,0.09};
	const vec3 CANNON_OFFSET_MIDLE = {-0.075,0.36,1.49};
	const vec3 CANNON_OFFSET_UPPER = {-0.075,0.36,1.59};
	
	constructor()
	endconstructor;
	
	proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			ReBuildWeapon();
		endif;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/Dismount")!=-1)
			)then return;
		endif;
		if(GetTransportObj().IsValid()&&!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/LeaveTransport")>=0))then return; endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("/titan_paw")!=-1)then
				if(CheckSpecialActionTimer(p_sMiscParams))then
					Paw(true,p_sMiscParams,p_bQ,p_bA);
				endif;
			elseif(p_sMiscParams.Find("/titan_shake_off")!=-1)then
				if(CheckSpecialActionTimer(p_sMiscParams))then
					ShakeOff("titan_rage",1.8,0.1,100.0,100.0,12.0,p_sMiscParams,p_bQ,false,p_bA);
				endif;
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		po_rxLink="Dri1";
		po_rbIsBuildUpLink=true;
		SetCaptainAnim("hu_balista_steamtank_sitpos");
		SetCaptainAttackAnim("hu_balista_steamtank_attack");
		return false;
	endproc;
	
	export proc void ReBuildWeapon()
		SetBuildUp(CBuildUpBase.TYPE_TRANSPORTER_OPEN);
		var ^CGameObj pxT, pxO=CSrvWrap.GetObjMgr()^.CreateObj("hu_titan_transporter_buildup", GetOwner());
		var CObjHndl xBasket=pxO^.GetHandle();
		GetBuildUp()^.AddObj(xBasket, "con");
		AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
		var ^CBuildUpWeapon pxWeaponBuildUp=cast<CBuildUpWeapon>(GetAdditionalBuildUp(0));
		pxO=CSrvWrap.GetObjMgr()^.CreateObj("hu_rhino_ballista_buildup_top", GetOwner());
		pxWeaponBuildUp^.AddObj(pxO^.GetHandle(), "con2");
		var ^CCaptain pxC=cast<CCaptain>(CSrvWrap.GetObjMgr()^.CreateObj("universal_captain", GetOwner()));
		pxC^.Init(GetHandle());
		pxWeaponBuildUp^.AddObjCaptain(pxC^.GetHandle(), "Dri1", -1.0, pxO^.GetHandle(), true);
		pxWeaponBuildUp^.SetWeaponClass("hu_titan_ballista");
		pxWeaponBuildUp^.SetCanRotate(true);
		pxWeaponBuildUp^.SetAdditionalWeapon(true);
		pxWeaponBuildUp^.SetAutoAttack(true);
		AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
		pxWeaponBuildUp=cast<CBuildUpWeapon>(GetAdditionalBuildUp(1));
		pxO=CSrvWrap.GetObjMgr()^.CreateObj("hu_rhino_ballista_buildup_top", GetOwner());
		pxWeaponBuildUp^.AddObj(pxO^.GetHandle(), "con3");
		pxC=cast<CCaptain>(CSrvWrap.GetObjMgr()^.CreateObj("universal_captain", GetOwner()));
		pxC^.Init(GetHandle());
		pxWeaponBuildUp^.AddObjCaptain(pxC^.GetHandle(), "Dri1", -1.0, pxO^.GetHandle(), true);
		pxWeaponBuildUp^.SetWeaponClass("hu_titan_ballista");
		pxWeaponBuildUp^.SetCanRotate(true);
		pxWeaponBuildUp^.SetAdditionalWeapon(true);
		pxWeaponBuildUp^.SetAutoAttack(true);
		AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
		pxWeaponBuildUp=cast<CBuildUpWeapon>(GetAdditionalBuildUp(2));
		pxO=CSrvWrap.GetObjMgr()^.CreateObj("hu_mammoth_log_cannon_buildup_top", GetOwner());
		pxWeaponBuildUp^.AddCustWithParent(pxO^.GetHandle(), "Dri4", CANNON_OFFSET_UPPER, xBasket);
		pxC=cast<CCaptain>(CSrvWrap.GetObjMgr()^.CreateObj("universal_captain", GetOwner()));
		pxC^.Init(GetHandle());
		pxWeaponBuildUp^.AddObjCaptain(pxC^.GetHandle(), "Dri1", -1.0, pxO^.GetHandle(), true);
		pxWeaponBuildUp^.SetWeaponClass("hu_titan_logcannon");
		pxWeaponBuildUp^.SetCanRotate(true);
		pxWeaponBuildUp^.SetAdditionalWeapon(true);
		pxWeaponBuildUp^.SetAutoAttack(true);
		pxWeaponBuildUp^.SetSecond(true);
		pxO=CSrvWrap.GetObjMgr()^.CreateObj("hs_steam_boat_cannon", GetOwner());
		pxWeaponBuildUp^.AddCustWithParent(pxO^.GetHandle(), "Dri4", CANNON_OFFSET_LOWER, xBasket);
		pxO=CSrvWrap.GetObjMgr()^.CreateObj("hs_steam_boat_cannon", GetOwner());
		pxWeaponBuildUp^.AddCustWithParent(pxO^.GetHandle(), "Dri4", CANNON_OFFSET_MIDLE, xBasket);
	endproc;
	
	export proc void CheckLevelFlag()
		var int iLevel=GetLevel();
		var string sTribe=GetPlayerTribeName();
		var string sFlagGFX=sTribe+"_animal_flag_0"+(iLevel+1).ToString();
		var string sFlagDesc=sFlagGFX+"_"+m_iBuildUpType.ToString();
		if(m_sCurFlagDesc==sFlagDesc)then return; endif;
		if(!CSrvWrap.GetGfxMgrBase().FindGraphicSetEntry(sFlagGFX))then return; endif;
		m_sCurFlagDesc=sFlagDesc;
		var CFourCC xFlag="flag";
		if(HasBuildUp())then
			if(HasAdditionalBuildUp(2))then
				var ^CGameObj pxObj=GetAdditionalBuildUp(2)^.GetPrimaryLinkedObj().GetObj();
				if(pxObj!=null && pxObj^.HasLink(xFlag))then
					if(HasLink(xFlag))then RemLinkGFX(xFlag); endif;
					pxObj^.SetLinkGFX(xFlag,sFlagGFX);
					return;
				endif;
			endif;
			var ^CGameObj pxLinkedObj=GetBuildUp()^.GetPrimaryLinkedObj().GetObj();
			if(pxLinkedObj!=null && pxLinkedObj^.HasLink(xFlag))then
				if(HasLink(xFlag))then RemLinkGFX(xFlag); endif;
				pxLinkedObj^.SetLinkGFX(xFlag,sFlagGFX);
				return;
			endif;
		endif;
		if(HasLink(xFlag))then
			SetLinkGFX(xFlag,sFlagGFX);
		endif;
		return;
	endproc;
	
	export proc string GetVictoryAnim()
		var string sAnim="menace";
		var int iR=Random.GetInt()%3;
		if(iR==1)then
			sAnim="sm_shake_off";
		elseif(iR==2)then
			sAnim="idle_2";
		endif;
		return sAnim;
	endproc;
	
endclass;
	
class CHuPteranodon inherit CAnimal
	
	const real FLYING_HEIGHT=15.0f;
//	const vec3 BALLISTA_OFFSET={0.0,0.0,-0.7};
	const real COLLISION_FIX=4.0f;
	const real COLLISION_CHECK=3.5f;
	const real COLLISION_PLUS=0.5f;
	const int TIMER_COLLISION_HANDLER=40157;
	var array string m_asClasses;
	
	var real m_fCollisionRadius;
	var CRegionSink m_xCollisionSink;
	var CGuid m_xCollisionGuid;
	var CObjList m_xCollisionObjects;
	
	export constructor()
		m_xCollisionSink.m_xOnObjAdd=OnCollObjAdd;
		m_xCollisionSink.m_xOnObjRem=OnCollObjRem;
		if(m_asClasses.NumEntries()==0)then
			m_asClasses.AddEntry("aje_pteranodon");
			m_asClasses.AddEntry("hu_pteranodon");
			m_asClasses.AddEntry("ninigi_cargolifter");
			m_asClasses.AddEntry("ninigi_dirigible");
			m_asClasses.AddEntry("seas_helicopter");
			m_asClasses.AddEntry("aje_zeppelin");
			m_asClasses.AddEntry("hu_zeppelin");
			m_asClasses.AddEntry("ninigi_zeppelin");
			m_asClasses.AddEntry("seas_zeppelin");
		endif;
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="AjPt")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			if(iVersion>=1)then
				pxArc^<<m_xRegionGuid;
				pxArc^<<m_fCollisionRadius;
				m_xRegionObjects.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="AjPt";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		pxArc^<<m_xRegionGuid;
		pxArc^<<m_fCollisionRadius;
		m_xRegionObjects.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetCanWalk(false);
		SetCanSwim(false);
		SetCanFly(true);
//		m_fCollisionRadius=GetCollisionRadius()+0.5f;
		m_fCollisionRadius=3.5f;
		if(!p_bLoad)then
			if(m_xCollisionGuid.IsNull())then
				var vec3 vD;
				vD.SetXYZ(m_fCollisionRadius, m_fCollisionRadius, 0.0);
				CreateCollisionRegion(vD, 010b);
			endif;
		endif;
	endproc;
	
	proc void CreateCollisionRegion(vec3 p_vDimension, bitset p_dwType)
		if(!m_xCollisionGuid.IsNull())then return; endif;
		var ^CRegionMgr pxRM=^(CSrvWrap.GetRegionMgr());
		if(pxRM!=null)then
			var int iIdx=pxRM^.CreateRegion(GetName()+"_CollReg", p_dwType, GetPos(), p_vDimension);
			if(iIdx>=0)then
				var ^CRegion pxRegion=pxRM^.GetRegion(iIdx);
				m_xCollisionGuid=pxRegion^.GetGUID();
				m_xCollisionSink.SetRegion(pxRegion);
				pxRegion^.BindToObj(GetHandle());
				m_xCollisionSink.Subscribe();
			endif;
		endif;
//		if(!p_bLoad)then
//			if(GetClassName()=="hu_pteranodon")then
//				SetBuildUp(CBuildUpBase.TYPE_WEAPON);
//				var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("hu_rhino_ballista_buildup_top", GetOwner());
//				if(pxO!=null)then
//					GetBuildUp()^.AddObjCustomized(pxO^.GetHandle(), "Ride", BALLISTA_OFFSET);
//					cast<CBuildUpWeapon>(GetBuildUp())^.SetWeaponClass(GetClassName());
//					cast<CBuildUpWeapon>(GetBuildUp())^.SetCanRotate(true);
//					cast<CBuildUpWeapon>(GetBuildUp())^.SetAutoAttack(true);
////					pxO^.SetRndInvMaskSingleFlagInv(VIS_FLAG_VHCL_RAM_HIGH,true);
//				endif;
//			endif;
//		endif;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		if(!m_xCollisionGuid.IsNull())then
			var int iIdx=CSrvWrap.GetRegionMgr().FindRegion(m_xCollisionGuid);
			if(iIdx>=0)then
				var ^CRegion pxRegion=CSrvWrap.GetRegionMgr().GetRegion(iIdx);
				if(pxRegion!=null)then
					m_xCollisionSink.SetRegion(pxRegion);
					pxRegion^.BindToObj(GetHandle());
					m_xCollisionSink.Subscribe();
				endif;
			else
				var CGuid xG; m_xCollisionGuid=xG;
			endif;
		endif;
	endproc;
	
	proc void DeleteCollisionRegion()
		if(!m_xCollisionGuid.IsNull())then
			var ^CRegionMgr pxRM=^(CSrvWrap.GetRegionMgr());
			if(pxRM!=null)then
				var int iIdx=CSrvWrap.GetRegionMgr().FindRegion(m_xCollisionGuid);
				if(iIdx>=0)then
					var ^CRegion pxRegion=pxRM^.GetRegion(iIdx);
					m_xCollisionSink.Unsubscribe();
					if(pxRegion!=null)then
						pxRegion^.Unbind();
					endif;
					m_xCollisionSink.DeleteRegion();
					var CGuid xNew;
					m_xCollisionGuid=xNew;
				endif;
			endif;
		endif;
	endproc;
	
	proc bool OnCollObjAdd(CObjHndl p_xHndl)
		if(m_bToBeDeleted)then return false; endif;
		if(p_xHndl==GetHandle())then return false; endif;
		var ^CFightingObj pxFO=cast<CFightingObj>(p_xHndl.GetObj());
//		if(pxFO!=null&&pxFO^.IsFlyingUnit()&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxFO^.GetOwner(), GetOwner())&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxFO^.GetOwner()))then
		if(pxFO!=null&&pxFO^.IsFlyingUnit()&&pxFO^.GetOwner()==GetOwner())then
			if(m_asClasses.FindEntry(pxFO^.GetClassName())>=0)then
				m_xRegionObjects.Include(p_xHndl);
				Disengage();
				if(!HasTimer(TIMER_COLLISION_HANDLER))then
					CreateTimer(TIMER_COLLISION_HANDLER, CGameTimeSpan.OneSecond() * COLLISION_CHECK, true);
				endif;
			endif;
		endif;
		return true;
	endproc;
	
	proc bool OnCollObjRem(CObjHndl p_xHndl)
		if(m_xRegionObjects.FindEntry(p_xHndl)==-1)then return false; endif;
		m_xRegionObjects.RemEntry(p_xHndl);
		if(m_xRegionObjects.NumEntries()<1)then
			DeleteTimer(TIMER_COLLISION_HANDLER);
		endif;
		return true;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==TIMER_COLLISION_HANDLER)then
				Disengage();
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	export proc void Disengage()
		var string sAct=GetActionDesc();
		if(sAct!="CActWalk"&&sAct!="CActFlight"&&!HasSecondaryAction())then
			var real fD=Random.MTRandF(Math.Pi()*2.0f);
			var vec3 vOffset, vNew;
			vOffset.SetX(m_fCollisionRadius+COLLISION_PLUS);
			vOffset.RotZ((Random.GetInt()%628).ToReal() / 100.0);
//			vOffset.SetXYZ(Math.Sin(fD),Math.Cos(fD),0.0f);
			vNew=GetPosInMap(GetPos()+vOffset);
			vNew.SetZ(Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vNew.GetX(),vNew.GetY()),m_fWaterLevel)+FLYING_HEIGHT);
			SecondaryMoveAction(vNew,COLLISION_FIX);
			UpdateAggressionPos(vNew);
		endif;
	endproc;
	
//	export proc void RotateToEnemy(^CFightingObj p_pxEnemy, vec3 p_vPos, string p_sOverlayAnim, real p_fOverlayRatio)
//		var string sAnim="idle";
//		return super.RotateToEnemy(p_pxEnemy, p_vPos, sAnim, p_fOverlayRatio);
//	endproc;
	
//	export proc bool AttackEnemy(^CFightingObj p_pxEnemy, vec3 p_vTarget, ref bool p_rbRotated)
//		if(!HasBuildUp())then return false; endif;
//		var string sFAnim="idle";
//		if(!HasAnim(sFAnim))then sFAnim="attack_front"; endif;
//		var ^CBuildUpWeapon pxWeapon=cast<CBuildUpWeapon>(GetBuildUp());
//		if(pxWeapon!=null)then
//			if(GetRightHandWeapon()==GetCurrentWeapon())then
//				if(pxWeapon^.AttackEnemy(p_pxEnemy, p_vTarget))then
//					if(sFAnim!=""&&HasAnim(sFAnim)&&GetCurrentAnimName()!=sFAnim)then
//						SetAnim(sFAnim,3);
//					endif;
//					return false;
//				endif;
//			endif;
//		endif;
//		return super.AttackEnemy(p_pxEnemy, p_vTarget, p_rbRotated);
//	endproc;
	
	export proc void PickUp(CObjHndl p_xItem,bool p_bQueue)
		var ^CGameObj pxO=p_xItem.GetObj();
		if(pxO!=null)then
			GoTo(pxO^.GetPos(), true, GetDefaultSpeed(), true, true, GetOnWall(), false, true);
		endif;
		return;
	endproc;
	
	export proc void OnIdleEnter(^CState p_pxFrom, ^CState p_pxTo)
//		Flight();
		super.OnIdleEnter(p_pxFrom,p_pxTo);
	endproc;
	
	export proc void Flight()
		var string sAct=GetActionDesc();
		if(sAct!="CActFlight")then
			var ^CAttribs pxAttr=GetAttribs();
			if(pxAttr!=null)then
				if(pxAttr^.GetValue("CurTask")!="Idle")then
					pxAttr^.SetValue("CurTask","Idle");
				endif;
				SetTaskDescription("idle");
			endif;
			var real fD=Random.MTRandF(Math.Pi()*2.0f);
			var vec3 vO;
			vO.SetXYZ(Math.Sin(fD),Math.Cos(fD),0.0f);
			FlightAction(GetAggressionPos()+vO,GetMaxSpeed(),GetWalkSet(),03h,FLYING_HEIGHT);
		endif;
	endproc;
	
	export proc void CPDF()
		var string sAct=GetActionDesc();
		if(sAct=="CActFlight")then
			CheckPatrol();
		endif;
	endproc;
	
//	export proc void RotIdleAnim()
//		if(HasAnim("idle")&&GetCurrentAnimName()!="idle")then
////			SetAnim("idle",3);
//			AnimAction("idle");
//		endif;
//	endproc;
	
	export proc bool AttackEnemy(^CFightingObj p_pxEnemy, vec3 p_vTarget, ref bool p_rbRotated)
		if(p_pxEnemy!=null)then
			if(p_pxEnemy^.IsFlyingUnit() && !CanShootAir())then return false; endif;
		endif;
		var string sProj=GetProjectile();
//		var string sFAnim=GetNextFightAnim();
		var string sFAnim="idle";
		if(!HasAnim(sFAnim))then sFAnim="attack_front"; endif;
		var bool bProj=!sProj.IsEmpty();
		var bool bFAnim=!sFAnim.IsEmpty();
		begin Rotate;
			var real fAngle;
			var Quat qRot;
			if(p_pxEnemy!=null)then
				fAngle=GetAngleToR(p_pxEnemy);
				qRot=GetAngleToQ(p_pxEnemy);
			else
				fAngle=GetAngleToR(p_vTarget);
				qRot=GetAngleToQ(p_vTarget);
			endif;
			if(!bProj&&bFAnim)then
				if(GetPenetration()&&fAngle>(Math.Pi()/16.0f))then
					//AnimAction("idle");
					//SecRotAction(qRot,1.5)
//					RotateActionSpeed(qRot,100.0);
					RotateAction(qRot,"idle");
					DoCaptainAttackAnim();
					p_rbRotated=true;
				elseif(fAngle>Math.Pi()/8.0)then
//					RotateActionSpeed(qRot,100.0);
					RotateAction(qRot,"idle");
					DoCaptainAttackAnim();
					p_rbRotated=true;
					return true;
				endif;
			else
				if(fAngle>Math.Pi()/4.0||(GetPenetration()&&fAngle>Math.Pi()/16.0f))then
					RotateActionSpeed(qRot,100.0);
					//RotateAction(qRot,"idle",10.0);
					p_rbRotated=true;
					return false;
				endif;
			endif;
		end Rotate;
		if(bProj)then
			var int j, iK=GetProjectilesNumber();
			for(j=0)cond(j<iK)iter(j++)do
				CreateProjectileAndShoot(p_pxEnemy, p_vTarget);
			endfor;
			if(sFAnim!=""&&HasAnim(sFAnim)&&GetCurrentAnimName()!=sFAnim)then
				SetAnim(sFAnim,3);
			endif;
			DoCaptainAttackAnim();
			return false;
		elseif(bFAnim)then
			if(sFAnim!=""&&HasAnim(sFAnim)&&GetCurrentAnimName()!=sFAnim)then
				SetAnim(sFAnim,3);
			endif;
			DoCaptainAttackAnim();
		endif;
		return true;
	endproc;
	
	export proc void DoCaptainAttackAnim()
		if(m_xCaptain.IsValid())then
			var ^CGameObj pxCaptain=m_xCaptain.GetObj();
			if(pxCaptain^.HasAnim(m_sCaptainAttackAnim))then
				pxCaptain^.SetAnim(m_sCaptainAttackAnim, 1);
			endif;
		endif;
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		po_rxLink="Ride";
		SetCaptainAnim("ride_idle_0");
		SetCaptainAttackAnim("ride_bow");
		return true;
	endproc;
	
	export proc void SetIdleAnim()
		DoCaptainAnim();
		if(HasAnim("idle")&&GetCurrentAnimName()!="idle")then
			SetAnim("idle",3);
		endif;
		return;
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj , ref CGameObj.CAdvanceActionParams p_rxParams)
		if(!p_xGoalObj.IsValid())then return; endif;
		var vec3 vObj=p_xGoalObj.GetObj()^.GetPos(), vOwn=GetPos(),vNew;
		var real fScape=Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vOwn.GetX(),vOwn.GetY()),m_fWaterLevel);
		var real fHeight=vOwn.GetZ()-fScape, fRange=GetAttackRange()/*+fHeight-GetRadius()*/;
		vOwn.SetZ(fScape);
		var vec3 vDirection=vOwn - vObj;
		vDirection.Normalize();
		vNew=GetPosInMap(vObj+(vDirection*fRange));
		WalkAction(vNew, GetMaxSpeed(), false);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption, ^CGameObj p_pxGoalObj, CFourCC p_xWalkSet, bool p_bUseMaterial)
		var vec3 vPosition=GetPosInMap(p_vDest);
//		vPosition.SetZ(p_vDest.GetZ()+FLYING_HEIGHT);
		vPosition.SetZ(Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vPosition.GetX(),vPosition.GetY()),m_fWaterLevel)+FLYING_HEIGHT);
		return super.WalkAction(vPosition, p_iPrefSpeed, false, false, p_pxGoalObj, p_xWalkSet, p_bUseMaterial);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption, ^CGameObj p_pxGoalObj, CFourCC p_xWalkSet)
		return WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, p_bHeightAdaption, p_pxGoalObj, p_xWalkSet, true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption, ^CGameObj p_pxGoalObj)
		return WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, p_bHeightAdaption, p_pxGoalObj, GetWalkSet(), true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption)
		return WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, p_bHeightAdaption, null, GetWalkSet(), true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder)
		return WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, true, null, GetWalkSet(), true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed)
		return WalkAction(p_vDest, p_iPrefSpeed, true, true, null, GetWalkSet(), true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest)
		return WalkAction(p_vDest, GetMaxSpeed(), true, true, null, GetWalkSet(), true);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed, CFourCC p_xWalkSet, real p_fMaxRange, ref vec3 p_rvRootPos, ref vec3 p_rvGoalOffset)
		if(!p_xGoalObj.IsValid())then return; endif;
		var vec3 vObj=p_xGoalObj.GetObj()^.GetPos(), vOwn=GetPos(),vNew;
		var real fScape=Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vOwn.GetX(),vOwn.GetY()),m_fWaterLevel);
		var real fHeight=vOwn.GetZ()-fScape, fRange=GetAttackRange()/*+fHeight-GetRadius()*/;
		vOwn.SetZ(fScape);
		var vec3 vDirection=vOwn - vObj;
		vDirection.Normalize();
		vNew=GetPosInMap(vObj+(vDirection*fRange));
		WalkAction(vNew, GetMaxSpeed(), false);
//		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed, p_xWalkSet, p_fMaxRange, p_vRootPos, p_vGoalOffset);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed, CFourCC p_xWalkSet, real p_fMaxRange, ref vec3 p_rvRootPos)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed, p_xWalkSet, p_fMaxRange, p_rvRootPos);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed, CFourCC p_xWalkSet, real p_fMaxRange)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed, p_xWalkSet, p_fMaxRange);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed, CFourCC p_xWalkSet)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed, p_xWalkSet);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj)
		return super.AdvanceAction(p_xGoalObj);
	endproc;
	
//	export proc void Die()
//		if(!IsDead())then
//			if(m_xTransportObj.IsValid())then
//				var ^CTransportObj pxObj=cast<CTransportObj>(m_xTransportObj.GetObj());
//				if(pxObj!=null)then
//					pxObj^.OnDismount(GetHandle(),true,GetPos());
//				endif;
//			endif;
//			m_fHitpoints=0.0f;
//			SetVisible(false);
//			SetDead(true);
//			Delete();
//		endif;
//	endproc;
	
	export proc void Delete()
		DeleteCollisionRegion();
		var ^CPteranodonCorpse pxGameObj=cast<CPteranodonCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("hu_pteranodon_corpse",GetOwner(),GetPos(),GetRotation()));
		if(pxGameObj!=null)then
			pxGameObj^.SetSource(this);
			pxGameObj^.Init(GetName(), 0.0001);
		endif;
		super.Delete();
	endproc;
	
	export proc void AddFlyingHeight(vec3 p_vPos, real p_fSpeed)
		var real fHeight=FLYING_HEIGHT;
		var vec3 vPos=GetPos();
		vPos.SetZ(vPos.GetZ()+fHeight);
		MoveAction(vPos, p_fSpeed);
	endproc;
	
	export proc void PutIntoPlace(vec3 p_vPos)
		var real fHeight=FLYING_HEIGHT;
		var vec3 vPos=p_vPos;
		vPos.SetZ(vPos.GetZ()+fHeight);
		SetPos(vPos);
		return;
	endproc;
	
	export proc void StopEverything()
		super.StopEverything();
		SetIdleAnim();
	endproc;
	
//	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
//		if(GetClassName()=="hu_pteranodon")then
//			po_rxLink="Dri1";
//			po_rbIsBuildUpLink=true;
//			SetCaptainAnim("hu_balista_steamtank_sitpos");
//			SetCaptainAttackAnim("hu_balista_steamtank_attack");
//			return true;
//		else
//			return super.GetCaptainLink(po_rxLink, po_rbIsBuildUpLink);
//		endif;
//	endproc;
	
	export proc void SetIced(real p_fDuration,real p_fResistStart)
		return;
	endproc;
	
	export proc bool SkipCorpse()
		return true;
	endproc;
	
	export proc real GetFlyingHeight()
		return FLYING_HEIGHT;
	endproc;
	
endclass;
	
class CHuSmilodon inherit CAnimal
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetActAutonomous(true);
	endproc;
	
	export proc bool DoesCountInUnitLimit()
		return false;
	endproc;
	
	export proc void AddKillerCount(int p_iAdd)
		super.AddKillerCount(p_iAdd);
		if(GetLevel()<4)then
			if(m_iKillerCount>125)then
				SetLevelClean(4);
			elseif(m_iKillerCount>85)then
				SetLevelClean(3);
			elseif(m_iKillerCount>50)then
				SetLevelClean(2);
			elseif(m_iKillerCount>20)then
				SetLevelClean(1);
			endif;
		endif;
	endproc;
	
endclass;
	
class CNinigiKong inherit CAnimal
	
	var CFourCC m_xKongWSet;
	
	constructor()
		m_xKongWSet="hump";
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_HELMET, true);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMOR, true);
	endconstructor;
	
//	export proc void OnInit(bool p_bLoad)
//		super.OnInit(p_bLoad);
//	endproc;
	
	export proc ref CFourCC GetWalkSet()
		return m_xKongWSet;
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		po_rxLink="Proj";
//		SetCaptainAnim("flamebuggy_standanim");
		SetCaptainAnim("ride_idle_0");
		SetCaptainAttackAnim("eusmilus_stina_sm");
		return true;
	endproc;
	
//	export proc void CreateCaptain()
//		return;
//	endproc;
	
endclass;
	
class CNinigiSamuraiSquirrel inherit CAnimal
	
	var string m_sIdleAnim;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetCanWalk(true);
//		SetCanSwim(true);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_HELMET,true);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMOR,true);
		SetIdleAnim();
	endproc;
	
	export proc void SetIdleAnim()
		CheckWaterLand();
		if(m_sIdleAnim=="rest")then
			SetSLEAnim(m_sIdleAnim,99999,true,true);
		else
			SetAnim(m_sIdleAnim,3);
		endif;
	endproc;
	
	proc void OnAmphibianWaterLandTransition(bool p_bWaterToLand)
		if(p_bWaterToLand)then
			m_sIdleAnim="standanim";
		else
			m_sIdleAnim="rest";
		endif;
	endproc;
	
	export proc void CheckWaterLand()
		OnAmphibianWaterLandTransition(!IsInWater());
	endproc;
	
	export proc string GetVictoryAnim()
		var string sAnim="idle_0";
		var int iR=Random.GetInt()%2;
		if(iR==1)then
			sAnim="idle_1";
		endif;
		return sAnim;
	endproc;
	
	export proc void CreateCaptain()
		return;
	endproc;
	
endclass;
	
class CNinigiSlothWarrior inherit CAnimal
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_HELMET,true);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMOR,true);
	endproc;
	
endclass;
	
class CNinigiSpinosaurus inherit CAnimal
	
	const vec3 BASKET_OFFSET_1			= {0.0,0.0,0.0};
	const vec3 GATTLING_OFFSET_1		= {1.9,1.3,0.5};
	const vec3 GATTLING_OFFSET_2		= {-2.2,1.3,0.5};
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			ReBuildWeapon();
		endif;
		var CFourCC xLink="flag";
		var string sDeco="saltasaurud";
		SetLinkGFX(xLink,sDeco);
	endproc;
	
	export proc void ReBuildWeapon()
		SetBuildUp(CBuildUpBase.TYPE_FAKE);
		var ^CGameObj pxO = CSrvWrap.GetObjMgr()^.CreateObj("ninigi_triceratops_transporter", GetOwner());
		if(pxO!=null)then
			GetBuildUp()^.AddObjCustomized(pxO^.GetHandle(), "Ride", BASKET_OFFSET_1);
		endif;
		
		AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
		var ^CBuildUpWeapon pxWeaponBuildUp = cast<CBuildUpWeapon>(GetAdditionalBuildUp(0));
		pxO = CSrvWrap.GetObjMgr()^.CreateObj("ninigi_parasaurolophus_gatling_obj", GetOwner());
		pxWeaponBuildUp^.AddObjCustomized(pxO^.GetHandle(), "Ride", GATTLING_OFFSET_1);
		
		var ^CCaptain pxC = cast<CCaptain>(CSrvWrap.GetObjMgr()^.CreateObj("universal_captain", GetOwner()));
		pxC^.Init(GetHandle());
		pxWeaponBuildUp^.AddObjCaptain(pxC^.GetHandle(), "Dri1", -1.0, pxO^.GetHandle());
		pxWeaponBuildUp^.SetWeaponClass("ninigi_titan_gatling");
		pxWeaponBuildUp^.SetCanRotate(true);
		pxWeaponBuildUp^.SetAdditionalWeapon(true);
		pxWeaponBuildUp^.SetAutoAttack(true);
		
		AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
		pxWeaponBuildUp = cast<CBuildUpWeapon>(GetAdditionalBuildUp(1));
		pxO = CSrvWrap.GetObjMgr()^.CreateObj("ninigi_parasaurolophus_gatling_obj", GetOwner());
		pxWeaponBuildUp^.AddObjCustomized(pxO^.GetHandle(), "Ride", GATTLING_OFFSET_2);
		
		pxC = cast<CCaptain>(CSrvWrap.GetObjMgr()^.CreateObj("universal_captain", GetOwner()));
		pxC^.Init(GetHandle());
		pxWeaponBuildUp^.AddObjCaptain(pxC^.GetHandle(), "Dri1", -1.0, pxO^.GetHandle());
		pxWeaponBuildUp^.SetWeaponClass("ninigi_titan_gatling");
		pxWeaponBuildUp^.SetCanRotate(true);
		pxWeaponBuildUp^.SetAdditionalWeapon(true);
		pxWeaponBuildUp^.SetAutoAttack(true);
		
	endproc;
	/*
	proc void HandleGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams)
		if(	IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1 || p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel" || p_sMiscParams.Find("/LevelUp")!=-1)
			)then return; endif;
		if(p_sCommand == "walk")then
			GoTo(p_vPos, true, GetDefaultSpeed(), true, true);
		else
			super.HandleGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams);
		endif;
	endproc;
	*/
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		if(HasBuildUp(CBuildUpBase.TYPE_FAKE))then
			po_rxLink="Dri1";
			po_rbIsBuildUpLink = true;
			SetCaptainAnim("gatling_rider_standanim");
			SetCaptainAttackAnim("gatling_rider_attack");
			return false;
		else
			return super.GetCaptainLink(po_rxLink, po_rbIsBuildUpLink);
		endif;
	endproc;
	
	export proc void LinkCaptainObj()
		var ^CGameObj pxCaptain=m_xCaptain.GetObj();
		if(pxCaptain==null)then return; endif;
		SetCaptainAnim("idle_0");
		SetCaptainAttackAnim("victory_0");
		if(!HasBuildUp())then
			SetBuildUp(CBuildUpBase.TYPE_FAKE);
			GetBuildUp()^.AddObjFlex(pxCaptain^.GetHandle(), "Db_1", 3.0, GetHandle());
			GetBuildUp()^.UpdateLinkedObjs();
		endif;
	endproc;
	
endclass;
	
class CNinigiStyracosaurus inherit CAnimal
	
	const vec3 BASKET_BASE_OFFSET = {0.0,0.79,-0.25};
	
	export constructor()
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			ReBuildWeapon();
		endif;
	endproc;
	
	export proc void ReBuildWeapon()
		var string sClassName=GetClassName();
		if(sClassName=="ninigi_styracosaurus")then
			SetBuildUp(CBuildUpBase.TYPE_STYRA_TRANSPORTER);
			cast<CBuildUpTransporterCustom>(GetBuildUp())^.AddIgnoreLink("Dri1");
			var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("ninigi_saltasaurus_transporter", GetOwner());
			GetBuildUp()^.AddObjCustomized(pxO^.GetHandle(), "con", BASKET_BASE_OFFSET);
			AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
			cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.AddObjCaptain(m_xCaptain, "Dri1", -1.0, pxO^.GetHandle());
			cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.SetWeaponClass("ninigi_archer");
			cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.SetCanRotate(true);
			cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.SetAdditionalWeapon(true);
		endif;
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		if(HasBuildUp(CBuildUpBase.TYPE_STYRA_TRANSPORTER))then
			po_rxLink="Dri1";
			po_rbIsBuildUpLink=true;
			SetCaptainAnim("standanim");
			SetCaptainAttackAnim("bow_1");
		else
			return super.GetCaptainLink(po_rxLink, po_rbIsBuildUpLink);
		endif;
		return true;
	endproc;
	
	export proc void DoCaptainAttackAnim()
		if(HasBuildUp(CBuildUpBase.TYPE_WEAPON))then
			if(m_xCaptain.IsValid())then
				var ^CGameObj pxCaptain=m_xCaptain.GetObj();
				if(pxCaptain^.HasAnim(m_sCaptainAttackAnim))then
					pxCaptain^.SetAnim(m_sCaptainAttackAnim, 1);
				endif;
			endif;
		else
			return super.DoCaptainAttackAnim();
		endif;
	endproc;
	
endclass;
	
class CNinigiTarbosaurus inherit CAnimal
	
	const vec3 GATTLING_BASE_OFFSET			= {0.0,0.0,1.0};
	const vec3 PARA_GATTLING_OFFSET			= {0.0,0.0,1.0};
	
	export constructor()
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			ReBuildWeapon();
		endif;
	endproc;
	
	export proc void ReBuildWeapon()
		if(GetClassName()=="ninigi_tarbosaurus")then
			SetBuildUp(CBuildUpBase.TYPE_FAKE);
//			CreateCaptain();
			var ^CGameObj pxMisc=CSrvWrap.GetObjMgr()^.CreateObj("ninigi_predator_gatling_base", GetOwner());
			if(pxMisc!=null)then
				GetBuildUp()^.AddObjCustomized(pxMisc^.GetHandle(), "Rider",GATTLING_BASE_OFFSET);
			endif;
			AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
			var ^CBuildUpWeapon pxWeaponBuildUp=cast<CBuildUpWeapon>(GetAdditionalBuildUp(0));
			var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("ninigi_parasaurolophus_gatling_obj", GetOwner());
			if(pxO!=null)then
				pxWeaponBuildUp^.AddObjCustomized(pxO^.GetHandle(), "Rider",PARA_GATTLING_OFFSET);
			endif;
//			pxWeaponBuildUp^.AddObjCaptain(m_xCaptain, "Dri1", -1.0, pxO^.GetHandle());
			var ^CCaptain pxC=cast<CCaptain>(CSrvWrap.GetObjMgr()^.CreateObj("universal_captain", GetOwner()));
			pxC^.Init(GetHandle());
			pxWeaponBuildUp^.AddObjCaptain(pxC^.GetHandle(), "Dri1", -1.0, pxO^.GetHandle());
			pxWeaponBuildUp^.SetWeaponClass("ninigi_predator_gatling");
			pxWeaponBuildUp^.SetCanRotate(true);
			pxWeaponBuildUp^.SetAutoAttack(true);
			pxWeaponBuildUp^.SetAdditionalWeapon(true);
		endif;
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		po_rxLink="Dri1";
		po_rbIsBuildUpLink=true;
		SetCaptainAnim("gatling_rider_standanim");
		SetCaptainAttackAnim("gatling_rider_attack");
		return false;
	endproc;
	
endclass;
	
class CNinigiTriceratops inherit CAnimal
	
	export const string FRIGHTENING_PATH="/Filters/Ninigi/Upgrades/xenage/frightening";
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			ReBuildWeapon();
		endif;
	endproc;
	
//	export proc void ReBuildWeapon()
//		SetBuildUp(CBuildUpBase.TYPE_FAKE);
//		var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("ninigi_saltasaurus_transporter", GetOwner());
//		if(pxO!=null)then
//			GetBuildUp()^.AddObjCustomized(pxO^.GetHandle(), "con", {0.0,1.0,0.0});
//		endif;
//		AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
//		cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.AddObjCaptain(m_xCaptain, "Dri1", -1.0, pxO^.GetHandle());
//		cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.SetWeaponClass("ninigi_spearman");
//		cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.SetCanRotate(true);
//		cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.SetAdditionalWeapon(true);
//	endproc;
	
	export proc void ReBuildWeapon()
		SetBuildUp(CBuildUpBase.TYPE_FAKE);
		var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("ninigi_triceratops_launcher_base", GetOwner());
		if(pxO!=null)then
			GetBuildUp()^.AddObj(pxO^.GetHandle(), "Ride");
		endif;
//		pxO=CSrvWrap.GetObjMgr()^.CreateObj("ninigi_parasaurolophus_gatling_base", GetOwner());
//		if(pxO!=null)then
//			GetBuildUp()^.AddObj(pxO^.GetHandle(), "Rider");
//		endif;
	endproc;
	
//	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
//		if(HasBuildUp(CBuildUpBase.TYPE_FAKE))then
//			po_rxLink="Dri1";
//			po_rbIsBuildUpLink=true;
//			SetCaptainAnim("nat_fight_standanim");
//			SetCaptainAttackAnim("nat_throw");
//		else
//			return super.GetCaptainLink(po_rxLink, po_rbIsBuildUpLink);
//		endif;
//		return true;
//	endproc;
	
//	export proc void ReBuildWeapon()
//		SetBuildUp(CBuildUpBase.TYPE_TRANSPORTER_FAKE);
//		var ^CBuildUpTransporterOpen pxTransBuildUp=cast<CBuildUpTransporterOpen>(GetBuildUp());
//		pxTransBuildUp^.AddIgnoreLink("Dri3");
//		pxTransBuildUp^.AddIgnoreLink("Dri4");
//		var ^CGameObj pxB = CSrvWrap.GetObjMgr()^.CreateObj("ninigi_saltasaurus_transporter", GetOwner());
//		if(pxB!=null)then
//			GetBuildUp()^.AddObjCustomized(pxB^.GetHandle(), "con", {0.0,1.0,0.0});
//		endif;
//		AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
//		var ^CBuildUpWeapon pxWeaponBuildUp = cast<CBuildUpWeapon>(GetAdditionalBuildUp(0));
//		var ^CGameObj pxO = CSrvWrap.GetObjMgr()^.CreateObj("ninigi_triceratops_launcher", GetOwner());
//		pxWeaponBuildUp^.AddCustWithParent(pxO^.GetHandle(), "Dri1",{1.8,0.0,-0.5},pxB^.GetHandle());
//		var ^CCaptain pxC = cast<CCaptain>(CSrvWrap.GetObjMgr()^.CreateObj("universal_captain", GetOwner()));
//		pxC^.Init(GetHandle());
//		pxWeaponBuildUp^.AddObjCaptain(pxC^.GetHandle(), "Dri1", -1.0, pxO^.GetHandle());
//		pxWeaponBuildUp^.SetWeaponClass("ninigi_boss_launcher");
//		pxWeaponBuildUp^.SetCanRotate(true);
//		pxWeaponBuildUp^.SetAdditionalWeapon(true);
//		pxWeaponBuildUp^.SetAutoAttack(true);
//		AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
//		pxWeaponBuildUp = cast<CBuildUpWeapon>(GetAdditionalBuildUp(1));
//		pxO = CSrvWrap.GetObjMgr()^.CreateObj("ninigi_triceratops_launcher", GetOwner());
//		pxWeaponBuildUp^.AddCustWithParent(pxO^.GetHandle(), "Dri1",{-1.8,0.0,-0.5},pxB^.GetHandle());
//		pxC = cast<CCaptain>(CSrvWrap.GetObjMgr()^.CreateObj("universal_captain", GetOwner()));
//		pxC^.Init(GetHandle());
//		pxWeaponBuildUp^.AddObjCaptain(pxC^.GetHandle(), "Dri1", -1.0, pxO^.GetHandle());
//		pxWeaponBuildUp^.SetWeaponClass("ninigi_boss_launcher");
//		pxWeaponBuildUp^.SetCanRotate(true);
//		pxWeaponBuildUp^.SetAdditionalWeapon(true);
//		pxWeaponBuildUp^.SetAutoAttack(true);
//	endproc;
	
//	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
//		if(HasBuildUp(CBuildUpBase.TYPE_TRANSPORTER_OPEN))then
//			po_rxLink="Dri1";
//			po_rbIsBuildUpLink = true;
//			SetCaptainAnim("gatling_rider_standanim");
//			SetCaptainAttackAnim("gatling_rider_attack");
//			return false;
//		else
//			return super.GetCaptainLink(po_rxLink, po_rbIsBuildUpLink);
//		endif;
//	endproc;
	
	export proc void LinkCaptainObj()
		var ^CGameObj pxCaptain=m_xCaptain.GetObj();
		if(pxCaptain==null)then return; endif;
		AddGroupedChildren(pxCaptain^.GetGuid());
		var bool bBuildUpLink; var CFourCC xLink;
		var CFourCC xNoNo="NOPE";
		if(GetCaptainLink(xLink, bBuildUpLink))then
			pxCaptain^.SetVisible(true);
			var vec3 vOffset={0.0,0.0,-0.6};
			pxCaptain^.RideAction(GetHandle(),xLink,vOffset);
			DoCaptainAnim();
			return;
		endif;
		xLink="NONE";
		pxCaptain^.LinkAction(GetHandle(),xLink);
		pxCaptain^.SetVisible(false);
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			)then return; endif;
		if(GetTransportObj().IsValid()&&!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/LeaveTransport")>=0))then return; endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("frightening")!=(-1))then
				if(CheckSpecialActionTimer(p_sMiscParams))then
					Frightening(p_sMiscParams,p_bQ, p_bA);
				endif;
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	proc bool Frightening(string p_sPath, bool p_bQ, bool p_bAILock)
//		MemorizeCurrentFightState(CObjHndl.Invalid(),false,false);
		var ^CFrightening pxTask=cast<CFrightening>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"Frightening"));
		if(pxTask==null)then return false; endif;
		var bool bReturn=pxTask^.Init(GetHandle(), p_sPath);
		if(bReturn)then
			SetAILock(p_bAILock);
			pxTask^.SetUserCommand(true);
			NewTaskFO(pxTask, p_bQ);
		else
			pxTask^.GetFactory()^.FreeState(pxTask);
		endif;
		return bReturn;
	endproc;
	
endclass;
	
class CSeasGigantosaurus inherit CAnimal
	
////	const vec3 RCB_OFFSET={0.0,0.0,0.5};
	
	export constructor()
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			ReBuildWeapon();
		endif;
	endproc;
	
	export proc void ReBuildWeapon()
		if(GetClassName()=="seas_gigantosaurus")then
			SetBuildUp(CBuildUpBase.TYPE_FAKE);
			var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("seas_triceratops_resource_collector_buildup", GetOwner());
			if(pxO!=null)then
				GetBuildUp()^.AddObj(pxO^.GetHandle(), "Rider");
				CreateCaptain();
				AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
				cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.AddObjCaptain(m_xCaptain, "Dri1", -1.0, pxO^.GetHandle());
				cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.SetWeaponClass("seas_beast_rider");
				cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.SetCanRotate(true);
				cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.SetAdditionalWeapon(true);
				var ^CGameObj pxObj=m_xCaptain.GetObj();
				if(pxObj!=null)then
					pxObj^.SetAnim("standanim",3);
				endif;
			endif;
		endif;
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		if(HasBuildUp(CBuildUpBase.TYPE_FAKE))then
			po_rxLink="Dri1";
			po_rbIsBuildUpLink=true;
			SetCaptainAnim("standanim");
			SetCaptainAttackAnim("seas_rocketman_0");
//			SetCaptainAnim("gatling_rider_standanim");
//			SetCaptainAttackAnim("gatling_rider_standanim");
			return true;
		endif;
		return false;
	endproc;
	
endclass;

class CSeasPolakanthus inherit CAnimal
	
	export constructor()
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			ReBuildWeapon();
		endif;
	endproc;
	
	export proc void ReBuildWeapon()
		var string sClass=GetClassName();
		if(sClass=="seas_polakanthus")then
			SetBuildUp(CBuildUpBase.TYPE_TRANSPORTER_OPEN);
			cast<CBuildUpTransporterOpen>(GetBuildUp())^.AddIgnoreLink("Dri1");
			var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("seas_triceratops_transporter_buildup", GetOwner());
			GetBuildUp()^.AddObj(pxO^.GetHandle(), "con");
			AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
			CreateCaptain();
			cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.AddObjCaptain(m_xCaptain, "Dri1", -1.0, pxO^.GetHandle());
			cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.SetWeaponClass("seas_marksman");
			cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.SetCanRotate(true);
			cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.SetAdditionalWeapon(true);
			var ^CGameObj pxObj=m_xCaptain.GetObj();
			if(pxObj!=null)then
				pxObj^.SetAnim("standanim",3);
			endif;
		endif;
	endproc;
	
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		if(HasBuildUp(CBuildUpBase.TYPE_TRANSPORTER_OPEN))then
			po_rxLink="Dri1";
			po_rbIsBuildUpLink=true;
			SetCaptainAnim("standanim");
//			SetCaptainAttackAnim("tec_sm_cocktail");
			SetCaptainAttackAnim("seas_marksman_0");
			return true;
		endif;
		return false;
	endproc;
	
	export proc void LinkCaptainObj()
		var ^CGameObj pxCaptain=m_xCaptain.GetObj();
		if(pxCaptain==null)then return; endif;
		AddGroupedChildren(pxCaptain^.GetGuid());
		var bool bBuildUpLink; var CFourCC xLink;
		var CFourCC xNoNo="NOPE";
		if(GetCaptainLink(xLink, bBuildUpLink))then
			pxCaptain^.SetVisible(true);
			if(bBuildUpLink&&HasBuildUp())then
				pxCaptain^.RideAction(GetBuildUp()^.GetPrimaryLinkedObj(),xLink,{0.0,0.0,0.0});
			else
				var vec3 vOffset={0.0,1.0,-0.8};
				pxCaptain^.RideAction(GetHandle(),xLink,vOffset);
			endif;
			DoCaptainAnim();
			return;
		endif;
		xLink="NONE";
		pxCaptain^.LinkAction(GetHandle(),xLink);
		pxCaptain^.SetVisible(false);
	endproc;
	/*
	export proc real TakeDmg(^CFightingObj p_pxEnemy)
		return super.TakeDmg(p_pxEnemy);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, real p_fFactor)
		return super.TakeDmg(p_pxEnemy, p_fFactor);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, real p_fFactor, real p_fHitDelay)
		return super.TakeDmg(p_pxEnemy, p_fFactor, p_fHitDelay);
	endproc;
	
	export proc real TakeDmg(^CFightingObj p_pxEnemy, real p_fFactor, real p_fHitDelay, real p_fArmorPiercing)
		var real fReturn=super.TakeDmg(p_pxEnemy,p_fFactor, p_fHitDelay, p_fArmorPiercing);
		if(fReturn==0.0)then
			fReturn=m_xTechTree.GetValueR("MiscValues/SEAS/Polakanthus_Damage",15.0);
		endif;
		return fReturn;
	endproc;
	*/
endclass;
	
class CSeasRex inherit CAnimal
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			ReBuildWeapon();
		endif;
		SetNoParticles(true);
	endproc;
	
	export proc void ReBuildWeapon()
		SetBuildUp(CBuildUpBase.TYPE_TRANSPORTER_OPEN);
//			var ^CBuildUpTransporterOpen pxTransBuildUp=cast<CBuildUpTransporterOpen>(GetBuildUp());
		var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("seas_triceratops_transporter_buildup", GetOwner());
		if(pxO!=null)then
			var vec3 vTransporter={0.0,0.0,-1.61};
			GetBuildUp()^.AddObjCustomized(pxO^.GetHandle(), "Ride", vTransporter);
			var array vec3 avNests;
//				avNests.AddEntry({0.0,0.0,1.71});
//				avNests.AddEntry({0.0,0.0,1.55});
//				avNests.AddEntry({0.0,0.0,1.02});
//				avNests.AddEntry({0.0,0.0,1.02});
			avNests.AddEntry({3.04,-1.15,-1.21});
			avNests.AddEntry({-3.04,-1.15,-1.21});
			var int i, iC=avNests.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
				var ^CBuildUpWeapon pxWeaponBuildUp=cast<CBuildUpWeapon>(GetAdditionalBuildUp(i));
				var ^CGameObj pxMG=CSrvWrap.GetObjMgr()^.CreateObj("seas_triceratops_machinegun", GetOwner());
				if(pxMG==null)then continue; endif;
//					pxWeaponBuildUp^.AddCustWithParent(pxMG^.GetHandle(), "Dri"+(i+3).ToString(),avNests[i],pxO^.GetHandle());
				pxWeaponBuildUp^.AddObjCustomized(pxMG^.GetHandle(), "Ride",avNests[i]);
				pxWeaponBuildUp^.SetWeaponClass("seas_arena_mg");
				pxWeaponBuildUp^.SetCanRotate(true);
				pxWeaponBuildUp^.SetAdditionalWeapon(true);
				pxWeaponBuildUp^.SetAutoAttack(true);
//					pxWeaponBuildUp^.ResetRotation();
			endfor;
//			AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
//			var ^CBuildUpWeapon pxWeapon=cast<CBuildUpWeapon>(GetAdditionalBuildUp(iC));
//			var ^CGameObj pxT=CSrvWrap.GetObjMgr()^.CreateObj("seas_trex_turret", GetOwner());
//			if(pxT!=null)then
//				pxWeapon^.AddObjCustomized(pxT^.GetHandle(), "Ride", {0.0,-0.96,0.42});
//				pxWeapon^.SetWeaponClass("seas_arena_turret");
//				pxWeapon^.SetCanRotate(true);
//				pxWeapon^.SetAdditionalWeapon(true);
//				pxWeapon^.SetAutoAttack(true);
////					pxWeapon^.ResetRotation();
//			endif;
		endif;
	endproc;
	
//	export proc void OnPostLoad()
//		super.OnPostLoad();
//		ForceGeneralUpdate();
//	endproc;
	
//	export proc real GetBURot(^CBuildUpWeapon p_pxBuildUp)
//		if(NumAdditionalBuildUps()<2)then return 0.0; endif;
//		var ^CBuildUpWeapon pxWeaponBuildUp=cast<CBuildUpWeapon>(GetAdditionalBuildUp(1));
//		if(pxWeaponBuildUp==null)then return 0.0; endif;
//		if(pxWeaponBuildUp==p_pxBuildUp)then return Math.Pi(); endif;
//		return 0.0f;
//	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		return false;
	endproc;
	
//	export proc real GetBuildupRotSpeed()
//		return 0.4f;
//	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/Dismount")!=-1)
			)then return; endif;
		if(GetTransportObj().IsValid()&&!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/LeaveTransport")>=0))then return; endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("cyborg_roar")!=-1)then
				if(CheckSpecialActionTimer(p_sMiscParams))then
					CyborgRoar("roaring",7.0,0.8,12.0,3.0,10.0,p_sMiscParams,p_bQ, p_bA);
				endif;
			elseif(p_sMiscParams.Find("/cyborg_tnt")!=-1)then
				if(CheckSpecialActionTimer(p_sMiscParams))then
					ShakeOff("shake",0.2,0.1,100.0,100.0,20.0,p_sMiscParams,p_bQ,false,p_bA);
				endif;
			endif;
		endif;
		super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
	endproc;
	
	export proc bool CyborgRoar(string p_sAnimName, real p_fTime, real p_fTimeOffset, real p_fRadius, real p_fMultiplier, real p_fDuration, string p_sPath, bool p_bQ, bool p_bAILock)
//		MemorizeCurrentFightState(CObjHndl.Invalid(),false,false);
		var ^CCyborgRoar pxTask=cast<CCyborgRoar>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"CyborgRoar"));
		if(pxTask==null)then return false; endif;
		var bool bReturn=pxTask^.Init(GetHandle(), p_sAnimName, p_fTime, p_fTimeOffset, p_fRadius, p_fMultiplier, p_fDuration, p_sPath);
		if(bReturn)then
			SetAILock(p_bAILock);
			pxTask^.SetUserCommand(true);
			NewTaskFO(pxTask,p_bQ);
		else
			pxTask^.GetFactory()^.FreeState(pxTask);
		endif;
		return bReturn;
	endproc;
	
	export proc bool IsPoisonImmun()
		return true;
	endproc;
	
endclass;
	
class CSeasStygimoloch inherit CAnimal
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetActAutonomous(true);
	endproc;
	
	export proc bool DoesCountInUnitLimit()
		return false;
	endproc;
	
	export proc void AddKillerCount(int p_iAdd)
		super.AddKillerCount(p_iAdd);
		if(GetLevel()<4)then
			if(m_iKillerCount>125)then
				SetLevelClean(4);
			elseif(m_iKillerCount>85)then
				SetLevelClean(3);
			elseif(m_iKillerCount>50)then
				SetLevelClean(2);
			elseif(m_iKillerCount>20)then
				SetLevelClean(1);
			endif;
		endif;
	endproc;
	
endclass;
	
class CSeasTradeDino inherit CTradeTransporter
	
	export constructor()
	endconstructor;
	
	export destructor()
	enddestructor;
	
	proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			SetType("ANML");
			SetCanFightAttrib(false);
			InitAttribs();
		endif;
		UpdateAttribs(p_bLoad);
		AddUnit();
		if(!p_bLoad)then
			StartTT();
			if(GetClassName()=="seas_trade_dino")then
				SetCanFightAttrib(false);
			endif;
		endif;
		OnTechTreeChange();
		//item inventory -> all levels can now have one item
		if(GetInventory()==null)then
			InitInventory(1);
		endif;
		if(!p_bLoad)then
			if(GetClassName()=="seas_trade_dino")then
				SetBuildUp(CBuildUpBase.TYPE_FAKE);
				var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("seas_triceratops_resource_collector_buildup", GetOwner());
				if(pxO!=null)then
					GetBuildUp()^.AddObj(pxO^.GetHandle(), "con");
				endif;
			endif;
		endif;
		SetAnimalType();
	endproc;
	
	export proc void SetAnimalType()
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("Herbivore", true);
		endif;
	endproc;
	
	export proc void PrepareBuildUpTransferLinkedObjs()
	endproc;
	
	export proc void Die()
		if(!IsDead()&&!IsDyingInTPO())then
			var ^CGameObj pxGameObj=CSrvWrap.GetObjMgr()^.CreateObj(GetClassName()+"_food",GetOwner(),GetPos(),GetRotation());
			if(pxGameObj!=null)then
				pxGameObj^.SetName(GetName());
				var ^CFood pxFood=cast<CFood>(pxGameObj);
				if(pxFood!=null)then
					pxFood^.SetRndInvMask(GetRndInvMask());
				endif;
				PrepareBuildUpTransferLinkedObjs();
				var ^CDino_Food pxDinoFood=cast<CDino_Food>(pxFood);
				if(pxDinoFood!=null)then
					pxDinoFood^.Initialize(this, m_iSizeClass, false);
					pxDinoFood^.SetAggressive(GetTechTreeAggressiv());
					if(HasBuildUp())then
//						pxDinoFood^.SetBuildUp(CBuildUpBase.TYPE_FAKE);
//						GetBuildUp()^.TransferLinkedObjs(pxDinoFood^.GetBuildUp());
						GetBuildUp()^.TransferLinkedObjs(pxDinoFood);
						pxDinoFood^.UpdateLinkedObjs();
					endif;
				endif;
				var real fNow=CTimeMgr.Get().GetVirtualTime();
				var ^CAttribs pxFoodAttribs=pxGameObj^.GetAttribs();
				if(pxFoodAttribs!=null)then
					pxFoodAttribs^.SetValue("birth_time",GetAttribs()^.GetValueFloat("birth_time"));
					pxFoodAttribs^.SetValue("growup_duration",GetAttribs()^.GetValueFloat("growup_duration"));
					pxFoodAttribs^.SetValue("die_time",fNow);
					var real fMaxHP=GetTechTreeHitpoints();
					var real fCurHP=CalculateHitpointsFromGrowUpSize(fMaxHP);
					var real fMaxValue=pxFoodAttribs^.GetValueInt("value").ToReal();
					pxFoodAttribs^.SetValue("value",((fCurHP*fMaxValue)/fMaxHP).ToInt());
				endif;
				var real fRadius=GetRadius();
				if(fRadius<=3.5)then
					pxGameObj^.InvokeGenericSCEvent(16,4.0f);
				elseif(fRadius<=5.0)then
					pxGameObj^.InvokeGenericSCEvent(10,4.0f);
				else
					pxGameObj^.InvokeGenericSCEvent(17,4.0f);
				endif;
			endif;
		endif;
		super.Die();
	endproc;
	
	export proc real CalculateHitpointsFromGrowUpSize(real p_fMaxHitpoints)
		var real fValue=p_fMaxHitpoints;
		var ^CAttribs pxAttr=GetAttribs();
		var real fNow=CTimeMgr.Get().GetVirtualTime();
		var real fBirthTime=pxAttr^.GetValueFloat("birth_time");
		var real fVF=CTimeMgr.Get().GetVirtualFactor();
		var real fGrowUp=GetTechTreeValueR("growup_duration",CTimeMgr.Get().GetVirtualDayLength()/fVF)*fVF;
		if(fBirthTime!=0.0f&&fNow<(fBirthTime+fGrowUp))then
			if(fGrowUp>0.0f)then
				var real fStrength=((fNow-fBirthTime)/fGrowUp);
				if(fStrength<0.2f)then fStrength=0.2f; endif;//min 20%
				fValue=(fValue*fStrength);
			else
				var real fStrength=0.2f;
				fValue=(fValue*fStrength);
			endif;
		endif;
		return fValue;
	endproc;
/*
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		if(GetClassName()=="seas_trade_dino")then
			if(HasBuildUp(CBuildUpBase.TYPE_FAKE))then
				po_rxLink="Dri1";
				po_rbIsBuildUpLink=true;
				SetCaptainAnim("standanim");
				return true;
			else
				return super.GetCaptainLink(po_rxLink, po_rbIsBuildUpLink);
			endif;
		else
			return false;
		endif;
	endproc;
*/
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		if(HasBuildUp(CBuildUpBase.TYPE_FAKE))then
			po_rxLink="Dri1";
			po_rbIsBuildUpLink=true;
			SetCaptainAnim("gatling_rider_standanim");
			SetCaptainAttackAnim("gatling_rider_standanim");
			return true;
		endif;
		return false;
	endproc;
	
	export proc bool AttackEnemy(^CFightingObj p_pxEnemy, vec3 p_vTarget, ref bool p_rbRotated)
		//return super.AttackEnemy(p_pxEnemy,p_vTarget,p_rbRotated);
		return false;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(	IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			)then return; endif;
		if(GetTransportObj().IsValid()&&!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/LeaveTransport")>=0))then return; endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("/EatSomethingFast")>=0)then
				EatPlantsOrMeat(null, GetPos(), true, p_bQ);
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		elseif(p_sCommand=="EatThatThing")then
			EatPlantsOrMeat(p_pxObject, p_vPos, false, p_bQ);
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	proc void EatPlantsOrMeat(^CGameObj p_pxObject, vec3 p_vPos, bool p_bFastFood, bool p_bQ)
		if(HasFullHP())then return; endif;
		var ^CEating pxTask=cast<CEating>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(), "Eating"));
		if(pxTask==null)then return; endif;
		var bool bInit=false;
		if(p_pxObject!=null)then
			bInit=pxTask^.Init(GetHandle(),p_pxObject^.GetHandle());
		else
			bInit=pxTask^.Init(GetHandle(),p_vPos, p_bFastFood);
		endif;
		if(!bInit)then pxTask^.GetFactory()^.FreeState(pxTask); return; endif;
		NewTaskFO(pxTask,p_bQ);
		pxTask^.SetUserCommand(true);
		//pxTask^.SetUserCommand(p_iUserCmd==1);
	endproc;
	
	export proc real GetAdaption()
		return 4.0f;
	endproc;
	
	export proc void DoChopAnim()
		AnimAction("attack_front");
	endproc;
	
	export proc string EatAnim()
		return "feeding";
	endproc;
	
//	export proc bool IsBugged()
//		return false;
//	endproc;
	
	export proc bool IsHerbivore()
		return true;
	endproc;
	
endclass;
	
class CSeasTriceratops inherit CAnimal
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			StartTT();
			CreatePersonalProduceUnit();
		endif;
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE, true);
	endproc;
	
//	export proc void OnPostLoad()
//		super.OnPostLoad();
//		// Henry: HACK for old units...
//		if(!GetProduceUnit().IsValid())then
//			CreatePersonalProduceUnit();
//		endif;
//		if(!HasBuildUp())then
//			var ^CTechTreeDef pxDef=GetTechTreeDef();
//			if(pxDef!=null)then
//				var string sDefault="/Filters/SEAS/Upgrades/seas_triceratops/seas_triceratops";
//				if(!pxDef^.HasFilter(sDefault))then
//					pxDef^.EnableFilter(sDefault);
//				endif;
//			endif;
//		endif;
//	endproc;
	
	export proc void HandleAction(string p_sAction)
		var string sName="Invalid";
		if(HasBuildUp()&&GetBuildUp()^.GetPrimaryLinkedObj().IsValid())then
			sName=GetBuildUp()^.GetPrimaryLinkedObj().GetObj()^.GetClassName();
		endif;
		if(p_sAction.Find("seas_triceratops_machinegun")>=0)then
			if(sName!="seas_triceratops_machinegun")then
				DestroyBuildUp();
				SetBuildUp(CBuildUpBase.TYPE_WEAPON);
				var ^CGameObj pxO = CSrvWrap.GetObjMgr()^.CreateObj("seas_triceratops_machinegun", GetOwner());
				GetBuildUp()^.AddObj(pxO^.GetHandle(), "con");
				cast<CBuildUpWeapon>(GetBuildUp())^.SetWeaponClass(GetClassName());
				cast<CBuildUpWeapon>(GetBuildUp())^.SetAutoAttack(true);
				cast<CBuildUpWeapon>(GetBuildUp())^.SetCanRotate(true);
				cast<CBuildUpWeapon>(GetBuildUp())^.SetAdditionalWeapon(true);
				SetCanFightAttrib(true);
			endif;
		elseif(p_sAction.Find("seas_triceratops_carrier")>=0)then
			if(sName!="seas_triceratops_carrier")then
				DestroyBuildUp();
				SetBuildUp(CBuildUpBase.TYPE_TRANSPORTER_OPEN);
				cast<CBuildUpTransporterOpen>(GetBuildUp())^.AddIgnoreLink("Dri1");
				var ^CGameObj pxO = CSrvWrap.GetObjMgr()^.CreateObj("seas_triceratops_carrier", GetOwner());
				GetBuildUp()^.AddObj(pxO^.GetHandle(), "con");
				AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
				CreateCaptain();
				cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.AddObjCaptain(m_xCaptain, "Dri1", -1.0, pxO^.GetHandle());
				cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.SetWeaponClass("seas_marksman");
				cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.SetCanRotate(true);
				cast<CBuildUpWeapon>(GetAdditionalBuildUp(0))^.SetAdditionalWeapon(true);
				SetCanFightAttrib(true);
				var ^CGameObj pxObj=m_xCaptain.GetObj();
				if(pxObj!=null)then
					pxObj^.SetAnim("standanim",3);
				endif;
			endif;
		else
			DestroyBuildUp();
			SetCanFightAttrib(true);
		endif;
		GetBestWeapon(null, true);
	endproc;
	
	export proc void DestroyBuildUp()
		super.DestroyBuildUp();
		GetBestWeapon(null, true);
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
			)then return; endif;
		if(GetTransportObj().IsValid()&&!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/LeaveTransport")>=0))then return; endif;
		var ^CVirtualProduceUnit pxUnit=cast<CVirtualProduceUnit>(GetProduceUnit().GetObj());
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("/SEAS/Upgrades/seas_triceratops/")!=-1&&pxUnit!=null)then
				pxUnit^.ReactToGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams, p_bQ, p_bS, p_bA);
				return;
			endif;
			if(p_sMiscParams.Find("/triceratops_shake_off")!=-1)then
				if(!HasBuildUp()&&CheckSpecialActionTimer(p_sMiscParams))then
					ShakeOff("sm_shake_off",2.0,0.4,50.0,50.0,8.0,p_sMiscParams,p_bQ,false,p_bA);
				endif;
			elseif(p_sMiscParams.Find("/triceratops_tusk")!=(-1))then
				if(!HasBuildUp()&&CheckHook(p_sMiscParams))then
					StartHook(p_sMiscParams, p_bQ);
				endif;
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		elseif(p_sCommand=="Cancel"&&pxUnit!=null)then
			pxUnit^.ReactToGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams, p_bQ, p_bS, p_bA);
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		if(HasBuildUp(CBuildUpBase.TYPE_TRANSPORTER_OPEN))then
			po_rxLink="Dri1";
			po_rbIsBuildUpLink=true;
			SetCaptainAnim("standanim");
			SetCaptainAttackAnim("seas_marksman_0");
			return true;
		elseif(HasBuildUp(CBuildUpBase.TYPE_WEAPON))then
			return false;
		else
			return super.GetCaptainLink(po_rxLink, po_rbIsBuildUpLink);
		endif;
	endproc;
	
//	export proc void UpdateHitpoints()
//		super.UpdateHitpoints();
//		UpdateBuildupDestruction();
//	endproc;
	
//	proc bool UpdateBuildupDestruction()
//		if(HasBuildUp())then
//			var ^CGameObj pxMGNest=GetBuildUp()^.GetPrimaryLinkedObj().GetObj();
//			if(pxMGNest==null)then return false; endif;
//			if(((GetHitpoints()!=0.0f)&&(GetMaxHitpoints()!=0.0f)))then
//				var real fPercentage=GetHitpoints()/(GetMaxHitpoints()/100.0f);
//				if(fPercentage<=25.0f)then
//					if(pxMGNest^.GetDestructLevel()!=2)then
//						InvokeGenericSCEvent(14,4.0f);
//						pxMGNest^.SetDestructLevel(2);
//					endif;
//					return true;
//				elseif(fPercentage<=50.0f)then
//					if(pxMGNest^.GetDestructLevel()!=1)then
//						InvokeGenericSCEvent(14,4.0f);
//						pxMGNest^.SetDestructLevel(1);
//					endif;
//					return true;
//				else
//					pxMGNest^.SetDestructLevel(0);
//					return true;
//				endif;
//			endif;
//		endif;
//		return true;
//	endproc;
	
	proc bool CheckHook(string p_sTTPath)
		if(!CRequirementsMgr.Get().CheckInvention(this, GetOwner(), "triceratops_tusk", GetTribeName()))then return false; endif;
		if(!CheckSpecialActionTimer(p_sTTPath))then return false; endif;
		if(!m_xCurEnemy.IsValid())then return false; endif;
		if(m_xCurEnemy.GetObj()^.GetOwner()==GetOwner())then return false; endif;
		var ^CFightingObj pxObj=cast<CFightingObj>(m_xCurEnemy.GetObj());
		var bool bInvalid; var CObjHndl xInvalid;
		if(pxObj==null||!IsInCombatRange(pxObj,false))then return false; endif;
		if(GetAngleToR(m_xCurEnemy.GetObj())>0.39)then return false; endif;
		return true;
	endproc;
	
	proc bool StartHook(string p_sTTPath)
		return StartHook(p_sTTPath, false);
	endproc;
	
	proc bool StartHook(string p_sTTPath, bool p_bQ)
//		MemorizeCurrentFightState(m_xCurEnemy,false,false);
		var ^CTriceratopsHook pxTask=cast<CTriceratopsHook>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"TricHook"));
		if(pxTask==null)then return false; endif;
		var bool bReturn = pxTask^.Init(GetHandle(), m_xCurEnemy, p_sTTPath);
		if(bReturn)then
			pxTask^.SetUserCommand(true);
			AddTask(pxTask,p_bQ);
		else
			pxTask^.GetFactory()^.FreeState(pxTask);
		endif;
		return bReturn;
	endproc;
	
	export proc string GetVictoryAnim()
		var string sAnim="menace";
		var int iR=Random.GetInt()%2;
		if(iR==1)then
			sAnim="shake";
		endif;
		return sAnim;
	endproc;
	
endclass;
	
	//========================================================================================
	//=== Vehicles ===========================================================================
	//========================================================================================
	
class CHuAvatar inherit CVehicle
	
//	const int GOLEM_LIFE_TIME=40107;
//	const real LIFTIME=75.0f;
	
//	export proc void OnInit(bool p_bLoad)
//		super.OnInit(p_bLoad);
//		if(!p_bLoad)then
//			CreateTimer(GOLEM_LIFE_TIME, CGameTimeSpan.OneSecond()*LIFTIME, false);
//		endif;
//	endproc;
	
//	export proc bool DoesCountInUnitLimit()
//		return false;
//	endproc;
	
//	export proc void OnPostLoad()
//		super.OnPostLoad();
//		if(!HasTimer(GOLEM_LIFE_TIME))then
//			CreateTimer(GOLEM_LIFE_TIME, CGameTimeSpan.OneSecond()*LIFTIME, false);
//		endif;
//	endproc;
	
//	proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
//		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
//			if(p_rxEvtPtr.GetInt(0)==GOLEM_LIFE_TIME)then
//				Die();
//			else
//				super.HandleEvent(p_rxEvtPtr);
//			endif;
//		else
//			super.HandleEvent(p_rxEvtPtr);
//		endif;
//	endproc;
	
	export proc void SetIdleAnim()
		Random.Seed();
		var int iRand=Random.GetInt()%3;
		switch(iRand)
			case(0)do SetAnim("standanim",3); endcase;
			case(1)do SetAnim("idle_1",3); endcase;
			case(2)do SetAnim("idle_2",3); endcase;
			case default do endcase;
		endswitch;
	endproc;
	
	export proc void CreateCorpse()
		var string sGfx="Golex_dest";
//		var string sGfx="Avatar";
		if(!CSrvWrap.GetGfxMgrBase().FindGraphicSetEntry(sGfx))then return; endif;
		if(CMirageSrvMgr.Get().UnitResources())then
			var ^CStone_Corpse pxStone=cast<CStone_Corpse>(CSrvWrap.GetObjMgr()^.CreateObj("StoneCorpse",GetOwner(),GetPos(),GetRotation()));
			if(pxStone!=null)then
				pxStone^.SetName(GetName());
				pxStone^.SetGFX(sGfx);
				pxStone^.Initialize(this);
//				pxStone^.SetDieAnim("dying",true);
				pxStone^.SetDieAnim("destroy",true);
				pxStone^.AreaDamage(3.0);
				pxStone^.SetAggressive(GetTechTreeAggressiv());
				pxStone^.Init();
			endif;
		else
			var ^CVehicleCorpse pxGameObj=cast<CVehicleCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("VehicleCorpse",GetOwner(),GetPos(),GetRotation()));
			if(pxGameObj!=null)then
				pxGameObj^.SetSource(this);
//				pxGameObj^.Init(sGfx, "dying", GetName(), 10.0);
				pxGameObj^.Init(sGfx, "destroy", GetName(), 10.0);
				if(GetClassName()=="hu_colossi")then
					pxGameObj^.AreaDamage(3.0);
				endif;
			endif;
		endif;
	endproc;
	
endclass;
	
class CHuStoneKiller inherit CVehicle
	
	class CWeaponGfx
		export var CFourCC m_xLink;
		export var string m_sGfx;

		export constructor()
		endconstructor;

		export destructor()
		enddestructor;

		export proc bool IsValid()
			return (m_xLink!="" && !m_sGfx.IsEmpty());
		endproc;

		export proc void DoKArc(ref CArc p_rxArc)
			var string sLink=m_xLink.AsString();
			p_rxArc << sLink;
			m_xLink=sLink;
			p_rxArc << m_sGfx;
		endproc;
	endclass;

	var array CHuStoneKiller.CWeaponGfx m_axWeaponsGfx;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="HSKV";
		if(CMirageSrvMgr.SDK())then
			return;
		endif;
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		var int i, iC;
		iC=m_axWeaponsGfx.NumEntries();
		pxArc^ << iC;
		for(i=0)cond(i<iC)iter(i++)do
			m_axWeaponsGfx[i].DoKArc(pxArc^);
		endfor;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="HSKV")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			if(iVersion>=1)then
				var int i,iC;
				pxArc^ << iC;
				for(i=0)cond(i<iC)iter(i++)do
					var ^CHuStoneKiller.CWeaponGfx pxGfx=^(m_axWeaponsGfx.NewEntryRef());
					pxGfx^.DoKArc(pxArc^);
				endfor;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void UpdateWeaponsGfx()
		m_axWeaponsGfx=0;
		var string sCurWeapon = GetCurrentWeapon();
		var string sLeftH = GetLeftHandWeapon();
		var string sArmor = GetArmor();
		var array string asWeapons;
		asWeapons=3;
		asWeapons[0]=sCurWeapon+"/Parts";
		asWeapons[1]=sLeftH+"/Parts";
		asWeapons[2]=sArmor+"/Parts";
		var array string asVariation;
		asVariation=3;
		asVariation[0]=GetWeaponMgr()^.GetRightHVariationPostfix();
		asVariation[1]=GetWeaponMgr()^.GetLeftHVariationPostfix();
		asVariation[2]="";
		var int iWeaponID, iNumWeapons=asWeapons.NumEntries();
		for(iWeaponID=0)cond(iWeaponID<iNumWeapons)iter(iWeaponID++)do
			var ^CTechTree.CNode pxNode=m_xTechTree.FindNode(asWeapons[iWeaponID]);
			if(pxNode!=null)then
				var int i, iC=pxNode^.NumSubs();
				var ^CTechTree.CNode pxPart=null;
				var CFourCC xLink;
				for(i=0)cond(i<iC)iter(++i)do
					pxPart=pxNode^.GetSub(i);
					if(pxPart!=null)then
						xLink=pxPart^.GetSubValue("Links");
						if(xLink=="")then xLink="HndR"; endif;
						RemLinkGFX(xLink);
						var ^CTechTree.CNode pxN=pxPart^.GetSub("Gfx");
						var string sGFX;
						if(pxN!=null)then sGFX=pxN^.GetSubValue(0); endif;
						if(!sGFX.IsEmpty())then
							var ^CHuStoneKiller.CWeaponGfx pxGfx=^(m_axWeaponsGfx.NewEntryRef());
							var string sGFXName=CSrvWrap.GetObjMgr()^.GetClassGFXName(sGFX+asVariation[iWeaponID]);
							if(sGFXName.IsEmpty())then
								sGFXName=CSrvWrap.GetObjMgr()^.GetClassGFXName(sGFX);
							endif;
							pxGfx^.m_xLink=xLink;
							pxGfx^.m_sGfx=sGFXName;
						endif;
					endif;
				endfor;
			endif;
		endfor;
		ShowWeapons();
	endproc;
	
	export proc void ShowWeapons()
		RemAllLinkGFX();
		ShowWeapons("weapon_off");
	endproc;
	
	export proc void ShowWeapons(string p_sAnim)
		if(GetEffectFlag(CFightingObj.EFFECT_AJE_CAMOUFLAGE))then return; endif;
		if(p_sAnim=="weapon_off")then SetRndInvMaskSingleFlagInv(VIS_FLAG_CHTR_ACTIVATED,false); endif;
		var int i, iC=m_axWeaponsGfx.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CHuStoneKiller.CWeaponGfx pxGfx=^(m_axWeaponsGfx[i]);
			if(pxGfx^.IsValid())then
				if(p_sAnim.IsEmpty())then
					SetLinkGFX(pxGfx^.m_xLink,pxGfx^.m_sGfx);
				else
					SetLinkGFX(pxGfx^.m_xLink,pxGfx^.m_sGfx,p_sAnim);
				endif;
			endif;
		endfor;
	endproc;
	
	export proc void HideWeapons()
		if(GetCamouflage())then return; endif;
		RemAllLinkGFX();
		var ^CPlayer pxPlayer=CSrvWrap.GetCurLevel()^.GetPlayer(GetOwner());
		if(pxPlayer==null)then return; endif;
		var int i=0;
		var string sPartName=m_xTechTree.GetValueS(GetArmor()+"/Parts/"+i.ToString(),"");
		while(sPartName!="")do
			var CFourCC xLink=m_xTechTree.GetValueS(GetArmor()+"/Parts/"+i.ToString()+"/Links","HndR");
			RemLinkGFX(xLink);
			SetLinkGFX(xLink,m_xTechTree.GetValueS(GetArmor()+"/Parts/"+i.ToString()+"/Gfx/0",""));
			i++;
			sPartName=m_xTechTree.GetValueS(GetArmor()+"/Parts/"+i.ToString(),"");
		endwhile;
	endproc;
	
	export proc void OnTechTreeChange()
		super.OnTechTreeChange();
	endproc;
	
	export proc void OnTechTreeChange(ref CStringArray p_rasChanges)
		super.OnTechTreeChange(p_rasChanges);
		ShowWeapons();
	endproc;
	
	export proc void CreateCorpse()
		var string sGfx="hu_undead_killer";
		if(!CSrvWrap.GetGfxMgrBase().FindGraphicSetEntry(sGfx))then return; endif;
		if(CMirageSrvMgr.Get().UnitResources())then
			var ^CStone_Corpse pxStone=cast<CStone_Corpse>(CSrvWrap.GetObjMgr()^.CreateObj("StoneCorpse",GetOwner(),GetPos(),GetRotation()));
			if(pxStone!=null)then
				pxStone^.SetName(GetName());
				pxStone^.SetGFX(sGfx);
				pxStone^.Initialize(this);
				pxStone^.SetDieAnim("dying",true);
				pxStone^.SetAggressive(GetTechTreeAggressiv());
				pxStone^.Init();
			endif;
		else
			var ^CVehicleCorpse pxGameObj=cast<CVehicleCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("VehicleCorpse",GetOwner(),GetPos(),GetRotation()));
			if(pxGameObj!=null)then
				pxGameObj^.SetSource(this);
				pxGameObj^.Init(sGfx, "dying", GetName(), 10.0);
			endif;
		endif;
	endproc;
	
endclass;
	
class CNinigiCargoLifter inherit CVehicle
	
	const real FLYING_HEIGHT=15.0f;
	const real COLLISION_FIX=3.0f;
	const real COLLISION_CHECK=3.5f;
	const real COLLISION_PLUS=0.5f;
	const int TIMER_COLLISION_HANDLER=40157;
	var array string m_asClasses;
	
	var real m_fCollisionRadius;
	var CRegionSink m_xCollisionSink;
	var CGuid m_xCollisionGuid;
	var CObjList m_xCollisionObjects;
	
	export constructor()
		m_xCollisionSink.m_xOnObjAdd=OnCollObjAdd;
		m_xCollisionSink.m_xOnObjRem=OnCollObjRem;
		if(m_asClasses.NumEntries()==0)then
			m_asClasses.AddEntry("aje_pteranodon");
			m_asClasses.AddEntry("hu_pteranodon");
			m_asClasses.AddEntry("ninigi_cargolifter");
			m_asClasses.AddEntry("ninigi_dirigible");
			m_asClasses.AddEntry("seas_helicopter");
			m_asClasses.AddEntry("aje_zeppelin");
			m_asClasses.AddEntry("hu_zeppelin");
			m_asClasses.AddEntry("ninigi_zeppelin");
			m_asClasses.AddEntry("seas_zeppelin");
		endif;
	endconstructor;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="NiCL")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			if(iVersion>=1)then
				pxArc^<<m_xRegionGuid;
				pxArc^<<m_fCollisionRadius;
				m_xRegionObjects.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="NiCL";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		pxArc^<<m_xRegionGuid;
		pxArc^<<m_fCollisionRadius;
		m_xRegionObjects.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetCanWalk(false);
		SetCanSwim(false);
		SetCanFly(true);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,true);
		m_fCollisionRadius=3.5f;
		if(!p_bLoad)then
			if(m_xCollisionGuid.IsNull())then
				var vec3 vD;
				vD.SetXYZ(m_fCollisionRadius, m_fCollisionRadius, 0.0);
				CreateCollisionRegion(vD, 010b);
			endif;
		endif;
	endproc;
	
	proc void CreateCollisionRegion(vec3 p_vDimension, bitset p_dwType)
		if(!m_xCollisionGuid.IsNull())then return; endif;
		var ^CRegionMgr pxRM=^(CSrvWrap.GetRegionMgr());
		if(pxRM!=null)then
			var int iIdx=pxRM^.CreateRegion(GetName()+"_CollReg", p_dwType, GetPos(), p_vDimension);
			if(iIdx>=0)then
				var ^CRegion pxRegion=pxRM^.GetRegion(iIdx);
				m_xCollisionGuid=pxRegion^.GetGUID();
				m_xCollisionSink.SetRegion(pxRegion);
				pxRegion^.BindToObj(GetHandle());
				m_xCollisionSink.Subscribe();
			endif;
		endif;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		if(!m_xCollisionGuid.IsNull())then
			var int iIdx=CSrvWrap.GetRegionMgr().FindRegion(m_xCollisionGuid);
			if(iIdx>=0)then
				var ^CRegion pxRegion=CSrvWrap.GetRegionMgr().GetRegion(iIdx);
				if(pxRegion!=null)then
					m_xCollisionSink.SetRegion(pxRegion);
					pxRegion^.BindToObj(GetHandle());
					m_xCollisionSink.Subscribe();
				endif;
			else
				var CGuid xG; m_xCollisionGuid=xG;
			endif;
		endif;
	endproc;
	
	proc void DeleteCollisionRegion()
		if(!m_xCollisionGuid.IsNull())then
			var ^CRegionMgr pxRM=^(CSrvWrap.GetRegionMgr());
			if(pxRM!=null)then
				var int iIdx=CSrvWrap.GetRegionMgr().FindRegion(m_xCollisionGuid);
				if(iIdx>=0)then
					var ^CRegion pxRegion=pxRM^.GetRegion(iIdx);
					m_xCollisionSink.Unsubscribe();
					if(pxRegion!=null)then
						pxRegion^.Unbind();
					endif;
					m_xCollisionSink.DeleteRegion();
					var CGuid xNew;
					m_xCollisionGuid=xNew;
				endif;
			endif;
		endif;
	endproc;
	
	proc bool OnCollObjAdd(CObjHndl p_xHndl)
		if(m_bToBeDeleted)then return false; endif;
		if(p_xHndl==GetHandle())then return false; endif;
		var ^CFightingObj pxFO=cast<CFightingObj>(p_xHndl.GetObj());
//		if(pxFO!=null&&pxFO^.IsFlyingUnit()&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxFO^.GetOwner(), GetOwner())&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxFO^.GetOwner()))then
		if(pxFO!=null&&pxFO^.IsFlyingUnit()&&pxFO^.GetOwner()==GetOwner())then
			if(m_asClasses.FindEntry(pxFO^.GetClassName())>=0)then
				m_xRegionObjects.Include(p_xHndl);
				Disengage();
				if(!HasTimer(TIMER_COLLISION_HANDLER))then
					CreateTimer(TIMER_COLLISION_HANDLER, CGameTimeSpan.OneSecond() * COLLISION_CHECK, true);
				endif;
			endif;
		endif;
		return true;
	endproc;
	
	proc bool OnCollObjRem(CObjHndl p_xHndl)
		if(m_xRegionObjects.FindEntry(p_xHndl)==-1)then return false; endif;
		m_xRegionObjects.RemEntry(p_xHndl);
		if(m_xRegionObjects.NumEntries()<1)then
			DeleteTimer(TIMER_COLLISION_HANDLER);
		endif;
		return true;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==TIMER_COLLISION_HANDLER)then
				Disengage();
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	export proc void Disengage()
		var string sAct=GetActionDesc();
		if(sAct!="CActWalk"&&sAct!="CActFlight"&&!HasSecondaryAction())then
			var real fD=Random.MTRandF(Math.Pi()*2.0f);
			var vec3 vOffset, vNew;
			vOffset.SetX(m_fCollisionRadius+COLLISION_PLUS);
			vOffset.RotZ((Random.GetInt()%628).ToReal() / 100.0);
//			vOffset.SetXYZ(Math.Sin(fD),Math.Cos(fD),0.0f);
			vNew=GetPosInMap(GetPos()+vOffset);
			vNew.SetZ(Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vNew.GetX(),vNew.GetY()),m_fWaterLevel)+FLYING_HEIGHT);
			SecondaryMoveAction(vNew,COLLISION_FIX);
			UpdateAggressionPos(vNew);
		endif;
	endproc;
	
	export proc bool IsAbleToWalk()
		return true;
	endproc;
	
	export proc void SetIced(real p_fDuration,real p_fResistStart)
		return;
	endproc;
	
	export proc void Flight()
		if(true)then return; endif;
		var string sAct=GetActionDesc();
		if(sAct!="CActFlight")then
			var ^CAttribs pxAttr=GetAttribs();
			if(pxAttr!=null)then
				if(pxAttr^.GetValue("CurTask")!="Idle")then
					pxAttr^.SetValue("CurTask","Idle");
				endif;
				SetTaskDescription("idle");
			endif;
			var real fD=Random.MTRandF(Math.Pi()*2.0f);
			var vec3 vO;
			vO.SetXYZ(Math.Sin(fD),Math.Cos(fD),0.0f);
			FlightAction(GetAggressionPos()+vO,GetMaxSpeed(),GetWalkSet(),03h,FLYING_HEIGHT);
		endif;
	endproc;
	
	export proc void CPDF()
		var string sAct=GetActionDesc();
		if(sAct=="CActFlight")then
			CheckPatrol();
		endif;
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj , ref CGameObj.CAdvanceActionParams p_rxParams)
		if(!p_xGoalObj.IsValid())then return; endif;
		var vec3 vObj=p_xGoalObj.GetObj()^.GetPos(), vOwn=GetPos(),vNew;
		var real fScape=Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vOwn.GetX(),vOwn.GetY()),m_fWaterLevel);
		var real fHeight=vOwn.GetZ()-fScape, fRange=GetAttackRange()/*+fHeight-GetRadius()*/;
		vOwn.SetZ(fScape);
		var vec3 vDirection=vOwn - vObj;
		vDirection.Normalize();
		vNew=GetPosInMap(vObj+(vDirection*fRange));
		WalkAction(vNew, GetMaxSpeed(), false);
//		WalkAction(vObj+(vDirection*fRange), GetMaxSpeed(), false);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption, ^CGameObj p_pxGoalObj, CFourCC p_xWalkSet, bool p_bUseMaterial)
//		var vec3 vPosition=p_vDest;
//		vPosition.SetZ(p_vDest.GetZ()+FLYING_HEIGHT);
		var vec3 vPosition=GetPosInMap(p_vDest);
		vPosition.SetZ(Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vPosition.GetX(),vPosition.GetY()),m_fWaterLevel)+FLYING_HEIGHT);
		return super.WalkAction(vPosition, p_iPrefSpeed, false, false, p_pxGoalObj, p_xWalkSet, p_bUseMaterial);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption, ^CGameObj p_pxGoalObj, CFourCC p_xWalkSet)
		return WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, p_bHeightAdaption, p_pxGoalObj, p_xWalkSet, true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption, ^CGameObj p_pxGoalObj)
		return WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, p_bHeightAdaption, p_pxGoalObj, GetWalkSet(), true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption)
		return WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, p_bHeightAdaption, null, GetWalkSet(), true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder)
		return WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, true, null, GetWalkSet(), true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed)
		return WalkAction(p_vDest, p_iPrefSpeed, true, true, null, GetWalkSet(), true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest)
		return WalkAction(p_vDest, GetMaxSpeed(), true, true, null, GetWalkSet(), true);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed, CFourCC p_xWalkSet, real p_fMaxRange, ref vec3 p_rvRootPos, ref vec3 p_rvGoalOffset)
		if(!p_xGoalObj.IsValid())then return; endif;
		var vec3 vObj=p_xGoalObj.GetObj()^.GetPos(), vOwn=GetPos(),vNew;
		var real fScape=Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vOwn.GetX(),vOwn.GetY()),m_fWaterLevel);
		var real fHeight=vOwn.GetZ()-fScape, fRange=GetAttackRange()/*+fHeight-GetRadius()*/;
		vOwn.SetZ(fScape);
		var vec3 vDirection=vOwn - vObj;
		vDirection.Normalize();
		vNew=GetPosInMap(vObj+(vDirection*fRange));
		WalkAction(vNew, GetMaxSpeed(), false);
//		WalkAction(vObj+(vDirection*fRange), GetMaxSpeed(), false);
//		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed, p_xWalkSet, p_fMaxRange, p_vRootPos, p_vGoalOffset);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed, CFourCC p_xWalkSet, real p_fMaxRange, ref vec3 p_rvRootPos)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed, p_xWalkSet, p_fMaxRange, p_rvRootPos);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed, CFourCC p_xWalkSet, real p_fMaxRange)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed, p_xWalkSet, p_fMaxRange);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed, CFourCC p_xWalkSet)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed, p_xWalkSet);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj)
		return super.AdvanceAction(p_xGoalObj);
	endproc;
	
	export proc void PickUp(CObjHndl p_xItem,bool p_bQueue)
		if(!p_xItem.IsValid())then return; endif;
		var ^CGameObj pxO=p_xItem.GetObj();
		if(pxO!=null)then
			GoTo(pxO^.GetPos(), true, GetDefaultSpeed(), true, true, GetOnWall(), false, true);
		endif;
		return;
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
//		po_rxLink="Dri1";
//		po_rbIsBuildUpLink=false;
//		SetCaptainAnim("cargolifter_sitpos");
//		SetCaptainAttackAnim("cargolifter_sitpos");
//		return true;
		return false;
	endproc;
	
	export proc ^CArrow CreateProjectileAndShoot(^CFightingObj p_pxEnemy, vec3 p_vPos)
		return super.CreateProjectileAndShoot(p_pxEnemy, p_vPos);
	endproc;
	
	export proc ^CArrow CreateProjectileAndShoot(^CFightingObj p_pxEnemy, vec3 p_vPos, string p_sProjectileType)
		var ^CArrow pxArrow=super.CreateProjectileAndShoot(p_pxEnemy,p_vPos,p_sProjectileType);
		return pxArrow;
	endproc;
	
	export proc bool AttackEnemy(^CFightingObj p_pxEnemy, vec3 p_vTarget, ref bool p_rbRotated)
		if(p_pxEnemy!=null)then
			if(p_pxEnemy^.IsFlyingUnit() && !CanShootAir())then return false; endif;
		endif;
		var string sProj=GetProjectile();
		var string sFAnim=GetNextFightAnim();
		if(sFAnim.IsEmpty())then sFAnim="attack_front"; endif;
		var bool bProj=!sProj.IsEmpty();
		var bool bFAnim=!sFAnim.IsEmpty();
		begin Rotate;
			var real fAngle;
			var Quat qRot;
			if(p_pxEnemy!=null)then
				fAngle=GetAngleToR(p_pxEnemy);
				qRot=GetAngleToQ(p_pxEnemy);
			else
				fAngle=GetAngleToR(p_vTarget);
				qRot=GetAngleToQ(p_vTarget);
			endif;
			if(!bProj&&bFAnim)then
				if(GetPenetration()&&fAngle>(Math.Pi()/16.0f))then
					RotateActionSpeed(qRot,5.0);
					DoCaptainAttackAnim();
					p_rbRotated=true;
				elseif(fAngle>Math.Pi()/8.0)then
					RotateActionSpeed(qRot,5.0);
					DoCaptainAttackAnim();
					p_rbRotated=true;
					return true;
				endif;
			else
				if(fAngle>Math.Pi()/4.0||(GetPenetration()&&fAngle>Math.Pi()/16.0f))then
					RotateActionSpeed(qRot,5.0);
					p_rbRotated=true;
					return false;
				endif;
			endif;
		end Rotate;
		if(GetPenetration())then
			Penetrate(p_pxEnemy,p_vTarget);
			if(sFAnim!=""&&HasAnim(sFAnim))then
				SetAnim(sFAnim,1);
			endif;
			return false;
		elseif(bProj)then
			var int j, iK=GetProjectilesNumber();
			for(j=0)cond(j<iK)iter(j++)do
				CreateProjectileAndShoot(p_pxEnemy, p_vTarget);
			endfor;
			if(sFAnim!=""&&HasAnim(sFAnim))then
				SetAnim(sFAnim,1);
			endif;
			DoCaptainAttackAnim();
			return false;
		elseif(bFAnim)then
			if(sFAnim!=""&&HasAnim(sFAnim))then
				SetAnim(sFAnim,1);
			endif;
			DoCaptainAttackAnim();
		endif;
		return true;
	endproc;
	
	export proc void Die()
		if(!IsDead())then
			CreateCorpse();
		endif;
		super.Die();
	endproc;
	
	export proc void CreateCorpse()
		var ^CCargolifterCorpse pxGameObj=cast<CCargolifterCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("cargolifter_corpse",GetOwner(),GetPos(),GetRotation()));
		if(pxGameObj!=null)then
			pxGameObj^.SetSource(this);
			pxGameObj^.Init(GetName(), 0.0001, 0.0);
		endif;
	endproc;
	
	export proc void AddFlyingHeight(vec3 p_vPos, real p_fSpeed)
		var real fHeight=FLYING_HEIGHT;
		var vec3 vPos=GetPos();
		vPos.SetZ(vPos.GetZ()+fHeight);
		MoveAction(vPos, p_fSpeed);
	endproc;
	
	export proc void PutIntoPlace(vec3 p_vPos)
		var real fHeight=FLYING_HEIGHT;
		var vec3 vPos=p_vPos;
		vPos.SetZ(vPos.GetZ()+fHeight);
		SetPos(vPos);
		return;
	endproc;
	
	export proc CFourCC GetProjectileLink()
		var CFourCC xL="Dri1";
		return xL;
	endproc;
	
	export proc void Delete()
		DeleteCollisionRegion();
		super.Delete();
	endproc;
	
	export proc void OnActionEnd(bool p_bBroken)
		super.OnActionEnd(p_bBroken);
		var bool bSetIdleAnim=true;
		var ^CTask pxCurTask=GetCurTask();
		if(pxCurTask!=null)then
			bSetIdleAnim=pxCurTask^.OnActionEnd(p_bBroken);
		endif;
		if(bSetIdleAnim)then
			if(!IsDead() && m_fHitpoints>0.0f && !m_bRotateSLEAction && !IsGroupWalkPending())then
				SetIdleAnim();
			endif;
		endif;
		if(HasBuildUp())then
			GetBuildUp()^.OnActionEnd(p_bBroken);
		endif;
	endproc;
	
	export proc void OnIdleEnter(^CState p_pxFrom, ^CState p_pxTo)
//		Flight();
		super.OnIdleEnter(p_pxFrom,p_pxTo);
		if(!IsDead() && m_fHitpoints>0.0f && !m_bRotateSLEAction && !IsGroupWalkPending())then
			SetIdleAnim();
		endif;
	endproc;
	
	export proc string GetReportCode()
		return "unit";
	endproc;
	
	export proc real GetFlyingHeight()
		return FLYING_HEIGHT;
	endproc;
	
	export proc bool IsAbleToFight()
		return true;
	endproc;
	
endclass;
	
class CNinigiDirigible inherit CVehicle
	
	const real FLYING_HEIGHT=18.5f;
	const real COLLISION_FIX=4.0f;
	const real COLLISION_CHECK=3.5f;
	const real COLLISION_PLUS=0.5f;
	const int TIMER_COLLISION_HANDLER=40157;
	var array string m_asClasses;
	
	var real m_fCollisionRadius;
	var CRegionSink m_xCollisionSink;
	var CGuid m_xCollisionGuid;
	var CObjList m_xCollisionObjects;
	
	export constructor()
		m_xCollisionSink.m_xOnObjAdd=OnCollObjAdd;
		m_xCollisionSink.m_xOnObjRem=OnCollObjRem;
		if(m_asClasses.NumEntries()==0)then
			m_asClasses.AddEntry("aje_pteranodon");
			m_asClasses.AddEntry("hu_pteranodon");
			m_asClasses.AddEntry("ninigi_cargolifter");
			m_asClasses.AddEntry("ninigi_dirigible");
			m_asClasses.AddEntry("seas_helicopter");
			m_asClasses.AddEntry("aje_zeppelin");
			m_asClasses.AddEntry("hu_zeppelin");
			m_asClasses.AddEntry("ninigi_zeppelin");
			m_asClasses.AddEntry("seas_zeppelin");
		endif;
	endconstructor;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="NiCL")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			if(iVersion>=1)then
				pxArc^<<m_xRegionGuid;
				pxArc^<<m_fCollisionRadius;
				m_xRegionObjects.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="NiCL";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		pxArc^<<m_xRegionGuid;
		pxArc^<<m_fCollisionRadius;
		m_xRegionObjects.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetCanWalk(false);
		SetCanSwim(false);
		SetCanFly(true);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,true);
		m_fCollisionRadius=GetCollisionRadius()+0.5f;
		if(!p_bLoad)then
			if(m_xCollisionGuid.IsNull())then
				var vec3 vD;
				vD.SetXYZ(m_fCollisionRadius, m_fCollisionRadius, 0.0);
				CreateCollisionRegion(vD, 010b);
			endif;
		endif;
	endproc;
	
	proc void CreateCollisionRegion(vec3 p_vDimension, bitset p_dwType)
		if(!m_xCollisionGuid.IsNull())then return; endif;
		var ^CRegionMgr pxRM=^(CSrvWrap.GetRegionMgr());
		if(pxRM!=null)then
			var int iIdx=pxRM^.CreateRegion(GetName()+"_CollReg", p_dwType, GetPos(), p_vDimension);
			if(iIdx>=0)then
				var ^CRegion pxRegion=pxRM^.GetRegion(iIdx);
				m_xCollisionGuid=pxRegion^.GetGUID();
				m_xCollisionSink.SetRegion(pxRegion);
				pxRegion^.BindToObj(GetHandle());
				m_xCollisionSink.Subscribe();
			endif;
		endif;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		if(!m_xCollisionGuid.IsNull())then
			var int iIdx=CSrvWrap.GetRegionMgr().FindRegion(m_xCollisionGuid);
			if(iIdx>=0)then
				var ^CRegion pxRegion=CSrvWrap.GetRegionMgr().GetRegion(iIdx);
				if(pxRegion!=null)then
					m_xCollisionSink.SetRegion(pxRegion);
					pxRegion^.BindToObj(GetHandle());
					m_xCollisionSink.Subscribe();
				endif;
			else
				var CGuid xG; m_xCollisionGuid=xG;
			endif;
		endif;
	endproc;
	
	proc void DeleteCollisionRegion()
		if(!m_xCollisionGuid.IsNull())then
			var ^CRegionMgr pxRM=^(CSrvWrap.GetRegionMgr());
			if(pxRM!=null)then
				var int iIdx=CSrvWrap.GetRegionMgr().FindRegion(m_xCollisionGuid);
				if(iIdx>=0)then
					var ^CRegion pxRegion=pxRM^.GetRegion(iIdx);
					m_xCollisionSink.Unsubscribe();
					if(pxRegion!=null)then
						pxRegion^.Unbind();
					endif;
					m_xCollisionSink.DeleteRegion();
					var CGuid xNew;
					m_xCollisionGuid=xNew;
				endif;
			endif;
		endif;
	endproc;
	
	proc bool OnCollObjAdd(CObjHndl p_xHndl)
		if(m_bToBeDeleted)then return false; endif;
		if(p_xHndl==GetHandle())then return false; endif;
		var ^CFightingObj pxFO=cast<CFightingObj>(p_xHndl.GetObj());
//		if(pxFO!=null&&pxFO^.IsFlyingUnit()&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxFO^.GetOwner(), GetOwner())&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxFO^.GetOwner()))then
		if(pxFO!=null&&pxFO^.IsFlyingUnit()&&pxFO^.GetOwner()==GetOwner())then
			if(m_asClasses.FindEntry(pxFO^.GetClassName())>=0)then
				m_xRegionObjects.Include(p_xHndl);
				Disengage();
				if(!HasTimer(TIMER_COLLISION_HANDLER))then
					CreateTimer(TIMER_COLLISION_HANDLER, CGameTimeSpan.OneSecond() * COLLISION_CHECK, true);
				endif;
			endif;
		endif;
		return true;
	endproc;
	
	proc bool OnCollObjRem(CObjHndl p_xHndl)
		if(m_xRegionObjects.FindEntry(p_xHndl)==-1)then return false; endif;
		m_xRegionObjects.RemEntry(p_xHndl);
		if(m_xRegionObjects.NumEntries()<1)then
			DeleteTimer(TIMER_COLLISION_HANDLER);
		endif;
		return true;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==TIMER_COLLISION_HANDLER)then
				Disengage();
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	export proc void Disengage()
		var string sAct=GetActionDesc();
		if(sAct!="CActWalk"&&sAct!="CActFlight"&&!HasSecondaryAction())then
			var real fD=Random.MTRandF(Math.Pi()*2.0f);
			var vec3 vOffset, vNew;
			vOffset.SetX(m_fCollisionRadius+COLLISION_PLUS);
			vOffset.RotZ((Random.GetInt()%628).ToReal() / 100.0);
//			vOffset.SetXYZ(Math.Sin(fD),Math.Cos(fD),0.0f);
			vNew=GetPosInMap(GetPos()+vOffset);
			vNew.SetZ(Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vNew.GetX(),vNew.GetY()),m_fWaterLevel)+FLYING_HEIGHT);
			SecondaryMoveAction(vNew,COLLISION_FIX);
			UpdateAggressionPos(vNew);
		endif;
	endproc;
	
	export proc bool IsAbleToWalk()
		return true;
	endproc;
	
	export proc void SetIced(real p_fDuration,real p_fResistStart)
		return;
	endproc;
	
	export proc void Flight()
		if(true)then return; endif;
		var string sAct=GetActionDesc();
		if(sAct!="CActFlight")then
			var ^CAttribs pxAttr=GetAttribs();
			if(pxAttr!=null)then
				if(pxAttr^.GetValue("CurTask")!="Idle")then
					pxAttr^.SetValue("CurTask","Idle");
				endif;
				SetTaskDescription("idle");
			endif;
			var real fD=Random.MTRandF(Math.Pi()*2.0f);
			var vec3 vO;
			vO.SetXYZ(Math.Sin(fD),Math.Cos(fD),0.0f);
			FlightAction(GetAggressionPos()+vO,GetMaxSpeed(),GetWalkSet(),03h,FLYING_HEIGHT);
		endif;
	endproc;
	
	export proc void CPDF()
		var string sAct=GetActionDesc();
		if(sAct=="CActFlight")then
			CheckPatrol();
		endif;
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj , ref CGameObj.CAdvanceActionParams p_rxParams)
		if(!p_xGoalObj.IsValid())then return; endif;
		var vec3 vObj=p_xGoalObj.GetObj()^.GetPos(), vOwn=GetPos(),vNew;
		var real fScape=Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vOwn.GetX(),vOwn.GetY()),m_fWaterLevel);
		var real fHeight=vOwn.GetZ()-fScape, fRange=GetAttackRange()/*+fHeight-GetRadius()*/;
		vOwn.SetZ(fScape);
		var vec3 vDirection=vOwn - vObj;
		vDirection.Normalize();
		vNew=GetPosInMap(vObj+(vDirection*fRange));
		WalkAction(vNew, GetMaxSpeed(), false);
//		WalkAction(vObj+(vDirection*fRange), GetMaxSpeed(), false);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption, ^CGameObj p_pxGoalObj, CFourCC p_xWalkSet, bool p_bUseMaterial)
//		var vec3 vPosition=p_vDest;
//		vPosition.SetZ(p_vDest.GetZ()+FLYING_HEIGHT);
		var vec3 vPosition=GetPosInMap(p_vDest);
		vPosition.SetZ(Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vPosition.GetX(),vPosition.GetY()),m_fWaterLevel)+FLYING_HEIGHT);
		return super.WalkAction(vPosition, p_iPrefSpeed, false, false, p_pxGoalObj, p_xWalkSet, p_bUseMaterial);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption, ^CGameObj p_pxGoalObj, CFourCC p_xWalkSet)
		return WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, p_bHeightAdaption, p_pxGoalObj, p_xWalkSet, true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption, ^CGameObj p_pxGoalObj)
		return WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, p_bHeightAdaption, p_pxGoalObj, GetWalkSet(), true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption)
		return WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, p_bHeightAdaption, null, GetWalkSet(), true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder)
		return WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, true, null, GetWalkSet(), true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed)
		return WalkAction(p_vDest, p_iPrefSpeed, true, true, null, GetWalkSet(), true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest)
		return WalkAction(p_vDest, GetMaxSpeed(), true, true, null, GetWalkSet(), true);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed, CFourCC p_xWalkSet, real p_fMaxRange, ref vec3 p_rvRootPos, ref vec3 p_rvGoalOffset)
		if(!p_xGoalObj.IsValid())then return; endif;
		var vec3 vObj=p_xGoalObj.GetObj()^.GetPos(), vOwn=GetPos(),vNew;
		var real fScape=Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vOwn.GetX(),vOwn.GetY()),m_fWaterLevel);
		var real fHeight=vOwn.GetZ()-fScape, fRange=GetAttackRange()/*+fHeight-GetRadius()*/;
		vOwn.SetZ(fScape);
		var vec3 vDirection=vOwn - vObj;
		vDirection.Normalize();
		vNew=GetPosInMap(vObj+(vDirection*fRange));
		WalkAction(vNew, GetMaxSpeed(), false);
//		WalkAction(vObj+(vDirection*fRange), GetMaxSpeed(), false);
//		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed, p_xWalkSet, p_fMaxRange, p_vRootPos, p_vGoalOffset);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed, CFourCC p_xWalkSet, real p_fMaxRange, ref vec3 p_rvRootPos)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed, p_xWalkSet, p_fMaxRange, p_rvRootPos);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed, CFourCC p_xWalkSet, real p_fMaxRange)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed, p_xWalkSet, p_fMaxRange);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed, CFourCC p_xWalkSet)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed, p_xWalkSet);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj)
		return super.AdvanceAction(p_xGoalObj);
	endproc;
	
	export proc void PickUp(CObjHndl p_xItem,bool p_bQueue)
		if(!p_xItem.IsValid())then return; endif;
		var ^CGameObj pxO=p_xItem.GetObj();
		if(pxO!=null)then
			GoTo(pxO^.GetPos(), true, GetDefaultSpeed(), true, true, GetOnWall(), false, true);
		endif;
		return;
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
//		po_rxLink="Dri1";
//		po_rbIsBuildUpLink=false;
//		SetCaptainAnim("cargolifter_sitpos");
//		SetCaptainAttackAnim("cargolifter_sitpos");
//		return true;
		return false;
	endproc;
	
	export proc ^CArrow CreateProjectileAndShoot(^CFightingObj p_pxEnemy, vec3 p_vPos)
		return super.CreateProjectileAndShoot(p_pxEnemy, p_vPos);
	endproc;
	
	export proc ^CArrow CreateProjectileAndShoot(^CFightingObj p_pxEnemy, vec3 p_vPos, string p_sProjectileType)
		var ^CArrow pxArrow=super.CreateProjectileAndShoot(p_pxEnemy,p_vPos,p_sProjectileType);
		return pxArrow;
	endproc;
	
	export proc bool AttackEnemy(^CFightingObj p_pxEnemy, vec3 p_vTarget, ref bool p_rbRotated)
		if(p_pxEnemy!=null)then
			if(p_pxEnemy^.IsFlyingUnit() && !CanShootAir())then return false; endif;
		endif;
		var string sProj=GetProjectile();
		var string sFAnim=GetNextFightAnim();
		if(sFAnim.IsEmpty())then sFAnim="attack_front"; endif;
		var bool bProj=!sProj.IsEmpty();
		var bool bFAnim=!sFAnim.IsEmpty();
		begin Rotate;
			var real fAngle;
			var Quat qRot;
			if(p_pxEnemy!=null)then
				fAngle=GetAngleToR(p_pxEnemy);
				qRot=GetAngleToQ(p_pxEnemy);
			else
				fAngle=GetAngleToR(p_vTarget);
				qRot=GetAngleToQ(p_vTarget);
			endif;
			if(!bProj&&bFAnim)then
				if(GetPenetration()&&fAngle>(Math.Pi()/16.0f))then
					RotateActionSpeed(qRot,5.0);
					DoCaptainAttackAnim();
					p_rbRotated=true;
				elseif(fAngle>Math.Pi()/8.0)then
					RotateActionSpeed(qRot,5.0);
					DoCaptainAttackAnim();
					p_rbRotated=true;
					return true;
				endif;
			else
				if(fAngle>Math.Pi()/4.0||(GetPenetration()&&fAngle>Math.Pi()/16.0f))then
					RotateActionSpeed(qRot,5.0);
					p_rbRotated=true;
					return false;
				endif;
			endif;
		end Rotate;
		if(GetPenetration())then
			Penetrate(p_pxEnemy,p_vTarget);
			if(sFAnim!=""&&HasAnim(sFAnim))then
				SetAnim(sFAnim,1);
			endif;
			return false;
		elseif(bProj)then
			var int j, iK=GetProjectilesNumber();
			for(j=0)cond(j<iK)iter(j++)do
				CreateProjectileAndShoot(p_pxEnemy, p_vTarget);
			endfor;
			if(sFAnim!=""&&HasAnim(sFAnim))then
				SetAnim(sFAnim,1);
			endif;
			DoCaptainAttackAnim();
			return false;
		elseif(bFAnim)then
			if(sFAnim!=""&&HasAnim(sFAnim))then
				SetAnim(sFAnim,1);
			endif;
			DoCaptainAttackAnim();
		endif;
		return true;
	endproc;
	
	export proc void Die()
		if(!IsDead())then
			CreateCorpse();
		endif;
		super.Die();
	endproc;
	
	export proc void CreateCorpse()
		var ^CCargolifterCorpse pxGameObj=cast<CCargolifterCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("dirigible_corpse",GetOwner(),GetPos(),GetRotation()));
		if(pxGameObj!=null)then
			pxGameObj^.SetSource(this);
			pxGameObj^.Init(GetName(), 0.0001, 3.0f);
		endif;
	endproc;
	
	export proc void AddFlyingHeight(vec3 p_vPos, real p_fSpeed)
		var real fHeight=FLYING_HEIGHT;
		var vec3 vPos=GetPos();
		vPos.SetZ(vPos.GetZ()+fHeight);
		MoveAction(vPos, p_fSpeed);
	endproc;
	
	export proc void PutIntoPlace(vec3 p_vPos)
		var real fHeight=FLYING_HEIGHT;
		var vec3 vPos=p_vPos;
		vPos.SetZ(vPos.GetZ()+fHeight);
		SetPos(vPos);
		return;
	endproc;
	
	export proc CFourCC GetProjectileLink()
		var CFourCC xL="Dri1";
		return xL;
	endproc;
	
	export proc void Delete()
		DeleteCollisionRegion();
		super.Delete();
	endproc;
	
	export proc void OnActionEnd(bool p_bBroken)
		super.OnActionEnd(p_bBroken);
		var bool bSetIdleAnim=true;
		var ^CTask pxCurTask=GetCurTask();
		if(pxCurTask!=null)then
			bSetIdleAnim=pxCurTask^.OnActionEnd(p_bBroken);
		endif;
		if(bSetIdleAnim)then
			if(!IsDead() && m_fHitpoints>0.0f && !m_bRotateSLEAction && !IsGroupWalkPending())then
				SetIdleAnim();
			endif;
		endif;
		if(HasBuildUp())then
			GetBuildUp()^.OnActionEnd(p_bBroken);
		endif;
	endproc;
	
	export proc void OnIdleEnter(^CState p_pxFrom, ^CState p_pxTo)
//		Flight();
		super.OnIdleEnter(p_pxFrom,p_pxTo);
		if(!IsDead() && m_fHitpoints>0.0f && !m_bRotateSLEAction && !IsGroupWalkPending())then
			SetIdleAnim();
		endif;
	endproc;
	
	export proc string GetReportCode()
		return "unit";
	endproc;
	
	export proc real GetFlyingHeight()
		return FLYING_HEIGHT;
	endproc;
	
	export proc bool IsAbleToFight()
		return true;
	endproc;
	
endclass;
	
class CNinigiHelicopter inherit CVehicle
	
	export constructor()
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetCanWalk(true);
		SetCanSwim(true);
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		po_rxLink = "Dri1";
		po_rbIsBuildUpLink = true;
		SetCaptainAnim("helicopter_rider");
		return true;
	endproc;
	
	export proc void CreateCorpse()
		var string sGfx;
		if(!CorpseAvailable(sGfx))then return; endif;
		if(CMirageSrvMgr.Get().UnitResources() && !IsInWater())then
			var ^CStone_Corpse pxStone=cast<CStone_Corpse>(CSrvWrap.GetObjMgr()^.CreateObj("StoneCorpse",GetOwner(),GetPos(),GetRotation()));
			if(pxStone!=null)then
				pxStone^.SetName(GetName());
				pxStone^.SetGFX(sGfx);
				pxStone^.Initialize(this);
				pxStone^.SetDieAnim("destroy",true);
				pxStone^.SetAggressive(GetTechTreeAggressiv());
				pxStone^.Init();
			endif;
		else
			super.CreateCorpse();
		endif;
	endproc;
	
	export proc void StopEverything()
		super.StopEverything();
		SetIdleAnim();
	endproc;
	
	export proc vec3 GetCaptainOffset()
		return {0.0,-0.2,0.38};
	endproc;
	
endclass;
	
class CLumberjackWreckage inherit CVehicle
	
	const int TIMER_CREATE_WRECKAGE						= 40043; //Henry: to create vehicle wreckage
	const int TIMER_REMAIN_WRECKAGE						= 40044; //Henry: to prevent idle animations
	const int INITIATE_IMMORTALITY_PROTOCOL		= 40045; //Henry: to recreate seas robots from the wreckage
	const int AUTO_INITIATE_REPAIR_SEQUENCE		= 40108; //Henry: for ai to automatically recreate seas robots from the wreckage
	var CObjHndl m_xWeapon;
	var int m_iLast;
	var string m_sWreckage;
	var string m_sRobot;
	var bool m_bAutoStart;
	
	constructor()
		m_bReactivated=false;
		m_bAutoStart=false;
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="LuWr";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		pxArc^ << m_iLast;
		pxArc^ << m_sWreckage;
		pxArc^ << m_sRobot;
		m_xWeapon.DoKArc(pxArc^);
		pxArc^ << m_bAutoStart;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="LuWr")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			pxArc^ << m_iLast;
			pxArc^ << m_sWreckage;
			pxArc^ << m_sRobot;
			m_xWeapon.DoKArc(pxArc^);
			pxArc^ << m_bAutoStart;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetNoHitReaction();
		if(!p_bLoad)then
			m_bCollapsing=true;
			m_bFountainHealed=true;
			SetIsVanished(true);
//			AnimAction("dying");
			SetAnim("dying",1);
			CollapseTimer(GetCurrentAnimLength());
		endif;
		SetCanWalk(false);
		if(!m_bReactivated)then
			if(!m_bCollapsing)then
				WreckageInit(false);
			endif;
		endif;
		if(!p_bLoad)then
			StartTT();
			CreatePersonalProduceUnit();
		endif;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		var CFourCC xLink="we";
		if(m_xWeapon.IsValid())then
			var ^CGameObj pxO=m_xWeapon.GetObj();
			if(pxO!=null)then
				pxO^.LinkAction(GetHandle(),xLink);
			endif;
		endif;
	endproc;
	
	export proc void SetRobot(string p_sClass,bool p_bAutoStart,int p_iLevel)
		m_sRobot=p_sClass;
		if(p_bAutoStart)then
			m_bAutoStart=true;
			var real fStart=20.0f;
			if(p_iLevel==5)then
				fStart=18.0;
			elseif(p_iLevel==6)then
				fStart=16.0;
			elseif(p_iLevel==7)then
				fStart=14.0;
			elseif(p_iLevel==8)then
				fStart=12.0;
			elseif(p_iLevel==9)then
				fStart=10.0;
			endif;
			CreateTimer(AUTO_INITIATE_REPAIR_SEQUENCE, CGameTimeSpan.OneSecond()*(fStart+GetCurrentAnimLength()), false);
		endif;
	endproc;
	
	export proc void CollapseTimer(real p_fTime)
		CreateTimer(TIMER_CREATE_WRECKAGE, CGameTimeSpan.OneSecond()*p_fTime, false);
	endproc;
	
	export proc void WreckageInit(bool p_bTimer)
		m_bCollapsing=false;
		m_bFountainHealed=false;
		SetIsVanished(false);
		m_iLast=60;
		m_sWreckage=GetClassName();
		if(m_sWreckage=="seas_flamer_wreckage"||m_sWreckage=="seas_suit_wreckage"||m_sWreckage=="seas_terminator_wreckage"||m_sWreckage=="babbage_wreckage")then
			m_iLast=95;
		elseif(m_sWreckage=="seas_boss_wreckage")then
			m_iLast=249;
		endif;
		SetAnim("dying",0,m_iLast);
		if(p_bTimer)then
			CreateTimer(TIMER_REMAIN_WRECKAGE, CGameTimeSpan.OneSecond()*10.0f, true);
		endif;
	endproc;
	
	export proc void ReConstruction()
		var real fRemade=1.0f;
		SetAnim("dying",2,0,fRemade);
		CreateTimer(INITIATE_IMMORTALITY_PROTOCOL, CGameTimeSpan.OneSecond()*fRemade, false);
	endproc;
	
	export proc void ActionTask(string p_sAction)
		var ^CVirtualProduceUnit pxProduceUnit=cast<CVirtualProduceUnit>(GetProduceUnit().GetObj());
		if(pxProduceUnit==null)then return; endif;
		pxProduceUnit^.Action(p_sAction);
	endproc;
	
	export proc void HandleAction(string p_sAction)
		if(p_sAction.Find("immortality_protocol")>=0)then
			m_bReactivated=true;
			m_bGodMode=true;
			if(HasTimer(TIMER_REMAIN_WRECKAGE))then
				DeleteTimer(TIMER_REMAIN_WRECKAGE);
			endif;
			ReConstruction();
		endif;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(p_sCommand=="setlevel")then
			InvalidateAttrib("level");
			return;
		elseif(m_bCollapsing)then
			return;
		elseif(p_sCommand=="Action")then
			var string sUpgradePath="Actions/"+GetTribeName()+"/Upgrades/"+GetClassName();
			if(p_sMiscParams.Find(sUpgradePath)!=-1)then
				ActionTask(p_sMiscParams);
			elseif(p_sMiscParams.Find("LevelUp")!=(-1))then
				InvalidateAttrib("level");
				return;
			elseif(p_sMiscParams.Find("/BoardTransporter")!=-1)then
				return;
			endif;
		endif;
		var ^CVirtualProduceUnit pxUnit=cast<CVirtualProduceUnit>(GetProduceUnit().GetObj());
		if(pxUnit==null)then
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
		if(p_sCommand=="Cancel")then
			pxUnit^.ReactToGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams, p_bQ, p_bS, p_bA);
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==TIMER_CREATE_WRECKAGE)then
				WreckageInit(true);
			elseif(iTimerID==AUTO_INITIATE_REPAIR_SEQUENCE)then
				var string sProtocol="Actions/"+GetTribeName()+"/Upgrades/"+GetClassName()+"/immortality_protocol";
				ActionTask(sProtocol);
				CreateTimer(AUTO_INITIATE_REPAIR_SEQUENCE, CGameTimeSpan.OneSecond()*15.0f, false);
			elseif(iTimerID==TIMER_REMAIN_WRECKAGE)then
				SetAnim("dying",0,m_iLast);
			elseif(iTimerID==INITIATE_IMMORTALITY_PROTOCOL)then
				var ^CVehicle pxVehicle=cast<CVehicle>(CSrvWrap.GetObjMgr()^.CreateObj(m_sRobot,GetOwner(),GetPos(),GetRotation()));
				if(pxVehicle!=null)then
					SetVisible(false);
					var ^CAttribs pxAttr=pxVehicle^.GetAttribs();
					if(pxAttr!=null)then
						pxAttr^.SetValue("clientpyramid_replacecard", GetName());
					endif;
//					pxVehicle^.AdjustHitpoints(GetInjuries());
					pxVehicle^.SetLevelClean(GetLevel());
					pxVehicle^.SetIdleAnim();
					pxVehicle^.ExamineEnemies(false);
				endif;
				if(m_xWeapon.IsValid())then
					var ^CGameObj pxO=m_xWeapon.GetObj();
					if(pxO!=null)then
						pxO^.Delete();
					endif;
				endif;
				DieFastAndSilent();
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	export proc void SetTrappedHandle(CObjHndl p_xTrapHndl)
		return;
	endproc;
	
	export proc void SetTrappedTime(real p_fDuration)
		return;
	endproc;
	
	export proc void SetTrappedBool(bool p_bTrapped)
		return;
	endproc;
	
	export proc void SetIced(real p_fDuration,real p_fResistStart)
		return;
	endproc;
	
	export proc void CreateCorpse()
		if(!m_bReactivated)then
			var string sGfxName=m_sRobot;
			if(m_sRobot=="seas_scorpion")then
				sGfxName="scorpion";
			elseif(m_sRobot=="seas_mobile_terminator")then
				sGfxName="babbagx_mobile_suit";
			endif;
			var ^CWreckageStill pxGameObj=cast<CWreckageStill>(CSrvWrap.GetObjMgr()^.CreateObj("seas_wreckage_still",GetOwner(),GetPos(),GetRotation()));
			if(pxGameObj!=null)then
				pxGameObj^.SetSource(this);
				pxGameObj^.Init(sGfxName,GetName(),1.5,m_iLast);
			endif;
		endif;
		if(m_xWeapon.IsValid())then
			var ^CGameObj pxO=m_xWeapon.GetObj();
			if(pxO!=null)then
				pxO^.Delete();
			endif;
		endif;
		return;
	endproc;
	
	export proc real GetInjuries()
		var real fPercentage=1.0;
		if(GetHitpoints()!=0.0f&&GetMaxHitpoints()!=0.0f)then
			fPercentage=(GetHitpoints()/GetMaxHitpoints());
		endif;
		return fPercentage;
	endproc;
	
	export proc bool GetNoHealing()
		return true;
	endproc;
	
endclass;
	
class CSeasScorpion inherit CVehicle
	
	const int SCORPION_BUSY_TIME =40098;
	const int SCORPION_FLAMER =40099;
	var CObjHndl m_xScorpion;
	var string m_sFlamethrower;
	
	constructor()
		m_sFlamethrower="";
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			if(m_xScorpion.IsValid())then
				m_xScorpion.GetObj()^.Delete();
			endif;
			var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("seas_eb_buildup",GetOwner(),GetPos(),GetRotation());
			if(pxO!=null)then
				var CFourCC xLink="psh2";
				pxO^.LinkAction(GetHandle(),xLink);
				m_xScorpion=pxO^.GetHandle();
				AddGroupedChildren(pxO^.GetGuid());
				var ^CAttribs pxA=pxO^.GetAttribs();
				if(pxA!=null)then
					pxA^.SetValue("maxhitpoints", GetAttribs()^.GetValueFloat("maxhitpoints"));
					pxA^.SetValue("hitpoints", GetAttribs()^.GetValueFloat("hitpoints"));
				endif;
			endif;
		endif;
		SetCanWalk(true);
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="ScSc")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			if(iVersion>=1)then
				pxArc^<<m_sFlamethrower;
				m_xScorpion.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="ScSc";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		pxArc^<<m_sFlamethrower;
		m_xScorpion.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;
	
	export proc bool IsAbleToFight()
		return true;
	endproc;
	
	export proc bool AttackEnemy(^CFightingObj p_pxEnemy, vec3 p_vTarget, ref bool p_rbRotated)
		if(IsTrapped())then return false; endif;
		if(p_pxEnemy!=null)then
			if(p_pxEnemy^.IsFlyingUnit() && !CanShootAir())then return false; endif;
		endif;
		var string sFAnim=GetNextFightAnim();
		if(sFAnim.IsEmpty())then return false; endif;
		if(m_xScorpion.IsValid())then
			var ^CScorpionBuildup pxWeapon=cast<CScorpionBuildup>(m_xScorpion.GetObj());
			if(pxWeapon!=null)then
				begin Rotate;
					var real fAngle;
//					var string sPrepAnim;
//					var int iIndex=sFAnim.Right(1).ToInt();
//					switch(iIndex)
//						case(1)do sPrepAnim="prepare_1"; endcase;
//						case(2)do sPrepAnim="prepare_2"; endcase;
//						case(3)do sPrepAnim="prepare_3"; endcase;
//						case(4)do sPrepAnim="prepare_1"; endcase;
//						case default do endcase;
//					endswitch;
					if(p_pxEnemy!=null)then
						fAngle=GetAngleToR(p_pxEnemy);
					else
						fAngle=GetAngleToR(p_vTarget);
					endif;
					if(GetPenetration()&&fAngle>(Math.Pi()/16.0f))then
						RotateToEnemy(p_pxEnemy, p_vTarget, "standanim", 0.5);
//						if(sPrepAnim!=""&&pxWeapon^.HasAnim(sPrepAnim)&&pxWeapon^.GetCurrentAnimName()!=sPrepAnim)then
//							pxWeapon^.SetAnim(sPrepAnim,3);
//						endif;
						p_rbRotated=true;
						return false;
					elseif(fAngle>Math.Pi()/8.0)then
						RotateToEnemy(p_pxEnemy, p_vTarget, "standanim", 0.5);
//						if(sPrepAnim!=""&&pxWeapon^.HasAnim(sPrepAnim)&&pxWeapon^.GetCurrentAnimName()!=sPrepAnim)then
//							pxWeapon^.SetAnim(sPrepAnim,3);
//						endif;
						p_rbRotated=true;
//						return false;
					endif;
				end Rotate;
				var real fDuration=GetWeaponDuration();
				if(GetPenetration())then
					Penetrate(p_pxEnemy,GetPenetrationAngle());
					if(sFAnim!=""&&pxWeapon^.HasAnim(sFAnim)&&!HasTimer(SCORPION_FLAMER))then
						var real fDur;
						pxWeapon^.SetAnim(sFAnim,1,0,fDur);
						CreateTimer(SCORPION_FLAMER,CGameTimeSpan.OneSecond()*(fDur-0.5f),false);
					endif;
					SetBuildUpBusy(fDuration);
//					WaitAction(fDuration);
					return false;
				else
					if(sFAnim!=""&&pxWeapon^.HasAnim(sFAnim))then
						pxWeapon^.SetAnim(sFAnim,1);
					endif;
					SetBuildUpBusy(fDuration);
//					WaitAction(fDuration);
					return true;
				endif;
			endif;
		endif;
		return false;
	endproc;
	
	export proc void Prepare()
		if(m_xScorpion.IsValid())then
			var ^CGameObj pxWeapon=m_xScorpion.GetObj();
			if(pxWeapon==null)then return; endif;
			if(pxWeapon^.GetCurrentAnimName().Find("attack_")!=-1)then return; endif;
			var string sAnim="standanim", sFAnim=GetNextFightAnim();
			var int iIndex=sFAnim.Right(1).ToInt();
			switch(iIndex)
				case(1)do sAnim="prepare_1"; endcase;
				case(2)do sAnim="prepare_2"; endcase;
				case(3)do sAnim="prepare_3"; endcase;
				case(4)do sAnim="prepare_1"; endcase;
				case default do endcase;
			endswitch;
			if(sAnim!=""&&pxWeapon^.HasAnim(sAnim)&&pxWeapon^.GetCurrentAnimName()!=sAnim)then
				pxWeapon^.SetAnim(sAnim,3);
			endif;
		endif;
	endproc;
	
	export proc bool SetAnim(string p_sAnim, int p_iMod)
		return SetAnim(p_sAnim,p_iMod,1);
	endproc;
	
	export proc bool SetAnim(string p_sAnim, int p_iMod, int p_iStart)
		var real fDur;
		return SetAnim(p_sAnim,p_iMod,p_iStart,fDur);
	endproc;
	
	export proc bool SetAnim(string p_sAnim, int p_iMod, int p_iStart, ref real p_rfDur)
		if(p_sAnim=="standanim"&&m_xScorpion.IsValid())then
			m_xScorpion.GetObj()^.SetAnim("standanim",3);
		endif;
		return super.SetAnim(p_sAnim,p_iMod,p_iStart,p_rfDur);
	endproc;
	
//	export proc void WaitAction(real p_fDuration)
//		Prepare();
//		return super.WaitAction(p_fDuration);
//	endproc;
	
//	export proc bool CanDoNextHit(real p_fDuration)
//		var bool bR=super.CanDoNextHit(p_fDuration);
//		if(!bR)then Prepare(); endif;
//		return bR;
//	endproc;
	
//	export proc real GetWeaponDuration()
//		if(GetCurrentWeapon().Find("seas_boss_weapon_flamer_")>=0)then return 1.0f; endif;
////		if(m_xScorpion.IsValid())then
////			return m_xScorpion.GetObj()^.GetCurrentAnimLength();
////		endif;
//		return super.GetWeaponDuration();
//	endproc;
	
	proc bool UpdateDestructionFlags()
		return false;
	endproc;
	
	export proc void CreateCorpse()
		var string sModel;
		if(CMirageSrvMgr.Get().UnitResources()&&!m_bCollapsing && CorpseAvailable(sModel))then
			var ^CStone_Corpse pxStone=cast<CStone_Corpse>(CSrvWrap.GetObjMgr()^.CreateObj("StoneCorpse",GetOwner(),GetPos(),GetRotation()));
			if(pxStone!=null)then
				pxStone^.SetName(GetName());
				pxStone^.SetGFX(sModel);
				pxStone^.Initialize(this);
				pxStone^.SetDieAnim("destroy",true);
				pxStone^.SetAggressive(GetTechTreeAggressiv());
				pxStone^.Init(10.0f,249);
			endif;
		else
			if(m_bCollapsing)then return; endif;
			var ^CScorpionCorpse pxGameObj=cast<CScorpionCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("seas_scorpion_corpse",GetOwner(),GetPos(),GetRotation()));
			if(pxGameObj!=null)then
				pxGameObj^.SetSource(this);
				pxGameObj^.Init("scorpion", GetName(), 14.0,10.0);
			endif;
			return;
		endif;
	endproc;
	
	export proc bool CorpseAvailable(ref string p_rsClass)
		p_rsClass="scorpion_dest";
		return CSrvWrap.GetGfxMgrBase().FindGraphicSetEntry(p_rsClass);
	endproc;
	
	export proc void Die()
//		var string sPlayerName="";
//		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
//		if(pxLevel!=null)then
//			var ^CPlayer pxPlayer=pxLevel^.GetPlayer(GetOwner());
//			if(pxPlayer!=null)then
//				sPlayerName=pxLevel^.GetLevelInfo().GetPlayerSlot(pxPlayer^.GetPlayerSlotID()).GetName();
//				CFeedback.Print(CFeedback.ALL, CFeedback.ATTACK, "_MIRAGE_NT_ScorpionDestroyed\t"+sPlayerName);
//			endif;
//		endif;
		super.Die();
	endproc;
	
//	export proc void SetIced(real p_fDuration,real p_fResistStart)
//		return;
//	endproc;
	
	export proc bool IsBusy()
		return HasTimer(SCORPION_BUSY_TIME);
	endproc;
	
	export proc void SetBuildUpBusy(real p_fDuration)
		if(!IsBusy())then
			CreateTimer(SCORPION_BUSY_TIME, CGameTimeSpan.OneSecond()*p_fDuration, false);
		endif;
		return;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==SCORPION_BUSY_TIME)then
				DeleteTimer(SCORPION_BUSY_TIME);
			elseif(iTimerID==SCORPION_FLAMER)then
				DeleteTimer(SCORPION_FLAMER);
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	export proc void SetCurEnemy(CObjHndl p_xHndl)
		super.SetCurEnemy(p_xHndl);
		UpdateEquipment();
	endproc;
	
	export proc string GetRightHandWeapon()
		if(/*GetClassName()=="seas_scorpion"&&*/m_xCurEnemy.IsValid()&&m_xCurEnemy.GetObj()^.GetType()=="BLDG")then
			if(m_sFlamethrower.IsEmpty())then
				UpdateEquipment();
			endif;
			return m_sFlamethrower;
		endif;
		return m_pxWeaponMgr^.GetRightHandWeapon();
	endproc;
	
	export proc void UpdateEquipment()
		if(/*GetClassName()=="seas_scorpion"&&*/m_xCurEnemy.IsValid()&&m_xCurEnemy.GetObj()^.GetType()=="BLDG")then
			m_sFlamethrower="/Objects/SEAS/Weapons/seas_boss_weapon_flamer_";
			if(GetLevel()==0)then
				m_sFlamethrower+="a";
			elseif(GetLevel()==1)then
				m_sFlamethrower+="b";
			elseif(GetLevel()==2)then
				m_sFlamethrower+="c";
			elseif(GetLevel()==3)then
				m_sFlamethrower+="d";
			elseif(GetLevel()==4)then
				m_sFlamethrower+="e";
			endif;
			if(GetCurrentWeapon()!=m_sFlamethrower)then
				ClearWeaponCache();
				UpdateWeapons(m_sFlamethrower);
				var ^CAttribs pxAttr=GetAttribs();
				if(pxAttr!=null && pxAttr^.GetValue("Equip_Slot_0")!=m_sFlamethrower)then
					pxAttr^.SetValue("Equip_Slot_0",m_sFlamethrower);
				endif;
				m_bWeaponHasChanged=true;
				m_bOwnWeaponHasChanged=true;
			endif;
			return;
		endif;
		if(!m_sFlamethrower.IsEmpty())then
			ClearWeaponCache();
			m_sFlamethrower="";
		endif;
		super.UpdateEquipment();
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		var CFourCC xLink="psh2";
		if(m_xScorpion.IsValid())then
			var ^CGameObj pxO=m_xScorpion.GetObj();
			if(pxO!=null)then
				pxO^.LinkAction(GetHandle(),xLink);
				AddGroupedChildren(pxO^.GetGuid());
			endif;
		endif;
	endproc;
	
	export proc void StopEverything()
		super.StopEverything();
		SetIdleAnim();
	endproc;
	
	export proc void SetIdleAnim()
		SetAnim("standanim",3);
	endproc;
	
//	export proc void Collapse()
//		StopEverything();
//		SetIsVanished(true);
//		var real fDur=10.0f;
//		if(m_xScorpion.IsValid())then
//			var ^CScorpionBuildup pxWeapon=cast<CScorpionBuildup>(m_xScorpion.GetObj());
//			if(pxWeapon!=null)then
////				pxWeapon^.SetSLEAnim("dying", 1, true, true , fDur);
//				pxWeapon^.AnimAction("dying");
//			endif;
//		endif;
//		CollapseTimer(fDur);
//		return;
//	endproc;
	
//	export proc void SetDyingAnim(string p_sAnim, int p_iLast)
//		if(m_xScorpion.IsValid())then
//			var ^CScorpionBuildup pxWeapon=cast<CScorpionBuildup>(m_xScorpion.GetObj());
//			if(pxWeapon!=null)then
//				pxWeapon^.SetAnim(p_sAnim,0,p_iLast);
//			endif;
//		endif;
//		return;
//	endproc;
	
endclass;
	
class CScorpionBuildup inherit CProduct
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		var ^CFSM pxFSM=GetFSM();
		if(pxFSM!=null)then
			pxFSM^.Enable(true);
		endif;
	endproc;
	
	export proc void Delete()
		TerminateAction();
		super.Delete();
	endproc;
	
endclass;
	
class CSeasTerminator inherit CVehicle
	
	var bool m_bTecInFightPos;
	
	export constructor()
		m_bTecInFightPos=false;
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="MSTR";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		pxArc^ << m_bTecInFightPos;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="MSTR")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			if(iVersion>=1)then
				pxArc^ << m_bTecInFightPos;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetIdleAnim();
	endproc;
	
	export proc bool AttackEnemy(^CFightingObj p_pxEnemy, vec3 p_vTarget, ref bool p_rbRotated)
		if(GetIncapacitated()||GetTransportObj().IsValid())then
			m_bTecInFightPos=false;
			return false;
		endif;
		if(p_pxEnemy!=null)then
			if(p_pxEnemy^.IsFlyingUnit() && !CanShootAir())then
				m_bTecInFightPos=false;
				return false;
			endif;
		endif;
		var string sFAnim=GetNextFightAnim();
		if(sFAnim.IsEmpty())then sFAnim="attack_front"; endif;
		var bool bFAnim=!sFAnim.IsEmpty();
		var string sProj=GetProjectile();
		var bool bProj=!sProj.IsEmpty();
		begin Rotate;
			var real fAngle;
			if(p_pxEnemy!=null)then
				fAngle=GetAngleToR(p_pxEnemy);
			else
				fAngle=GetAngleToR(p_vTarget);
			endif;
			var Quat qRot;
			if(p_pxEnemy!=null)then
				qRot=GetAngleToQ(p_pxEnemy);
			else
				qRot=GetAngleToQ(p_vTarget);
			endif;
			if(!bProj&&bFAnim)then
				m_bTecInFightPos=false;
				if(GetPenetration()&&fAngle>(Math.Pi()/16.0f))then
					RotateToEnemy(p_pxEnemy, p_vTarget, sFAnim, 0.5);
					p_rbRotated=true;
				elseif(fAngle>Math.Pi()/8.0)then
					RotateToEnemy(p_pxEnemy, p_vTarget, sFAnim, 0.5);
					p_rbRotated=true;
					return true;
				endif;
			else
				if(fAngle>Math.Pi()/4.0||(GetPenetration()&&fAngle>Math.Pi()/16.0f))then
					m_bRotateSLEAction=true;
					RotateActionSLE(qRot,sFAnim, 0.4, 1, !m_bTecInFightPos,false);
					p_rbRotated=true;
				endif;
			endif;
		end Rotate;
		if(GetPenetration())then
			m_bTecInFightPos=false;
			Penetrate(p_pxEnemy,p_vTarget);
			if(sFAnim!="" && HasAnim(sFAnim))then
				SetAnim(sFAnim,1);
			endif;
			return false;
		elseif(bProj)then
			var int j, iK=GetProjectilesNumber();
			for(j=0)cond(j<iK)iter(j++)do
				CreateProjectileAndShoot(p_pxEnemy, p_vTarget);
			endfor;
			SetSLEAnim(sFAnim, 1, !m_bTecInFightPos, false);
			m_bTecInFightPos=true;
			return false;
		elseif(bFAnim)then
			m_bTecInFightPos=false;
			if(sFAnim!=""&&HasAnim(sFAnim))then
				SetAnim(sFAnim,1);
			endif;
		endif;
		return true;
	endproc;
	/*
	export proc void CheckLevelFlag()
		return;
	endproc;
	*/
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(	IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1)
		)then return; endif;
		if(GetTransportObj().IsValid()&&!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/LeaveTransport")>=0))then return; endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("seas_jumpjet")!=-1)then
				if(CheckSpecialActionTimer(p_sMiscParams) && !GetTransportObj().IsValid())then
					SMSJumpjet(p_vPos,p_sMiscParams, p_bQ);
				endif;
//			elseif(p_sMiscParams.Find("Babbage_ExoMinigun_0")!=-1)then
//				if(CheckSpecialActionTimer(p_sMiscParams) && !GetTransportObj().IsValid())then
//					SMSMinigun(p_sMiscParams, p_pxObject, p_vPos, p_bQ);
//				endif;
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	export proc bool SMSJumpjet(vec3 p_vPos, string p_sTTPath, bool p_bQ)
		if(p_vPos!={0.0,0.0,0.0})then
			var ^CSpecialJumpjet pxTask= cast<CSpecialJumpjet>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(), "SpecSuitJ"));
			if(pxTask==null)then return false; endif;
			if(pxTask^.Init(GetHandle(), p_vPos,p_sTTPath))then
				pxTask^.SetUserCommand(true);
				AddTask(pxTask,p_bQ);
				return(true);
			else
				pxTask^.GetFactory()^.FreeState(pxTask);
			endif;
		endif;
		return(false);
	endproc;
	
	export proc bool SMSMinigun(string p_sTTPath, ^CGameObj p_pxEnemy, vec3 p_vPos, bool p_bQ)
		var CObjHndl xEnemy;
		if(p_pxEnemy!=null)then
			xEnemy=p_pxEnemy^.GetHandle();
		endif;
//		MemorizeCurrentFightState(xEnemy,true,false);
		var ^CSpecialMinigun pxTask=cast<CSpecialMinigun>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"SMSMinigun"));
		if(pxTask==null)then return false; endif;
		var bool bReturn=pxTask^.Init(GetHandle(),xEnemy,p_vPos,p_sTTPath);
		if(bReturn)then
			pxTask^.SetUserCommand(true);
			AddTask(pxTask,p_bQ);
		else
			pxTask^.GetFactory()^.FreeState(pxTask);
		endif;
		return bReturn;
	endproc;
	
	export proc void EndFight()
		super.EndFight();
		if(m_bTecInFightPos)then
			m_bTecInFightPos=false;
			if(HasAnim(GetFightAnim()))then
				AnimAction(GetFightAnim(),0,false,true);
			endif;
		endif;
	endproc;
	
	export proc void StopEverything()
		super.StopEverything();
		SetIdleAnim();
	endproc;
	
	export proc void OnActionEnd(bool p_bBroken)
		super.OnActionEnd(p_bBroken);
		if(m_bRotateSLEAction)then
			m_bRotateSLEAction=false;
//			return;
		endif;
		super.OnActionEnd(p_bBroken);
		var bool bSetIdleAnim=true;
		var ^CTask pxCurTask=GetCurTask();
		if(pxCurTask!=null)then
			bSetIdleAnim=pxCurTask^.OnActionEnd(p_bBroken);
		endif;
		if(bSetIdleAnim)then
			if(!IsDead() && m_fHitpoints>0.0f && !IsFeignDeath() && !m_bRotateSLEAction && !IsGroupWalkPending())then
				SetIdleAnim();
			endif;
		endif;
//		SetIdleAnim();
	endproc;
	
	export proc void SetIced(real p_fDuration,real p_fResistStart)
		if(GetCurTaskName()=="SpecSuitJ")then
			return;
		else
			return super.SetIced(p_fDuration,p_fResistStart);
		endif;
	endproc;
	
	export proc void OnKill()
		if(m_bScalpsGiven)then return; endif;
		var vec3 vPos=GetPos();
		vPos.SetZ(CSrvWrap.GetScapeMgr().GetHeight(GetPosX(), GetPosY()));
		SetPos(vPos);
		return super.OnKill();
	endproc;
	
endclass;
	
class CZeppelin inherit CTradeTransporter
	
	const real FLYING_HEIGHT=3.5f;
	const real COLLISION_FIX=4.0f;
	const real COLLISION_CHECK=3.5f;
	const real COLLISION_PLUS=0.5f;
	const int TIMER_COLLISION_HANDLER=40157;
	var array string m_asClasses;
	
	var real m_fCollisionRadius;
	var CRegionSink m_xCollisionSink;
	var CGuid m_xCollisionGuid;
	var CObjList m_xCollisionObjects;
	
	var bool m_bFlying;
	
	export constructor()
		m_bFlying=CMirageSrvMgr.Get().FlyingEnabled();
		m_xCollisionSink.m_xOnObjAdd=OnCollObjAdd;
		m_xCollisionSink.m_xOnObjRem=OnCollObjRem;
		if(m_asClasses.NumEntries()==0)then
			m_asClasses.AddEntry("aje_pteranodon");
			m_asClasses.AddEntry("hu_pteranodon");
			m_asClasses.AddEntry("ninigi_cargolifter");
			m_asClasses.AddEntry("ninigi_dirigible");
			m_asClasses.AddEntry("seas_helicopter");
			m_asClasses.AddEntry("aje_zeppelin");
			m_asClasses.AddEntry("hu_zeppelin");
			m_asClasses.AddEntry("ninigi_zeppelin");
			m_asClasses.AddEntry("seas_zeppelin");
		endif;
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		m_bFlying=CMirageSrvMgr.Get().FlyingEnabled();
		SetCanSwim(!m_bFlying);
		SetCanWalk(!m_bFlying);
		SetCanFly(m_bFlying);
		if(!p_bLoad)then
			SetType("VHCL");
			InitAttribs();
//			SetTransportClass(2);
			SetTransportClass(1);
			SetBuildUp(CBuildUpBase.TYPE_TRANSPORTER);
		endif;
		UpdateAttribs(p_bLoad);
		AddUnit();
		if(GetInventory()==null)then
			InitInventory(1);
		endif;
		if(!p_bLoad)then
			StartTT();
			SetCanFightAttrib(false);
		endif;
		m_iSizeClass=10;
		OnTechTreeChange();
		m_fCollisionRadius=GetCollisionRadius()+0.5f;
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="Zepp")then
			var int iVersion=p_pxNode^.GetVersion();
			var ^CArc pxArc=^(p_pxNode^.GetArc());
			(pxArc^) << m_xRegionGuid;
			m_xRegionObjects.DoKArc(pxArc^);
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		if(!CMirageSrvMgr.SDK())then
			var CFourCC xF="Zepp";
			var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,1);
			var ^CArc pxArc=^(pxN^.GetArc());
			(pxArc^) << m_xRegionGuid;
			m_xRegionObjects.DoKArc(pxArc^);
			pxN^.Close();
		endif;
	endproc;
	
	proc void CreateCollisionRegion(vec3 p_vDimension, bitset p_dwType)
		if(!m_xCollisionGuid.IsNull())then return; endif;
		var ^CRegionMgr pxRM=^(CSrvWrap.GetRegionMgr());
		if(pxRM!=null)then
			var int iIdx=pxRM^.CreateRegion(GetName()+"_CollReg", p_dwType, GetPos(), p_vDimension);
			if(iIdx>=0)then
				var ^CRegion pxRegion=pxRM^.GetRegion(iIdx);
				m_xCollisionGuid=pxRegion^.GetGUID();
				m_xCollisionSink.SetRegion(pxRegion);
				pxRegion^.BindToObj(GetHandle());
				m_xCollisionSink.Subscribe();
			endif;
		endif;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		if(!m_xCollisionGuid.IsNull())then
			var int iIdx=CSrvWrap.GetRegionMgr().FindRegion(m_xCollisionGuid);
			if(iIdx>=0)then
				var ^CRegion pxRegion=CSrvWrap.GetRegionMgr().GetRegion(iIdx);
				if(pxRegion!=null)then
					m_xCollisionSink.SetRegion(pxRegion);
					pxRegion^.BindToObj(GetHandle());
					m_xCollisionSink.Subscribe();
				endif;
			else
				var CGuid xG; m_xCollisionGuid=xG;
			endif;
		endif;
	endproc;
	
	proc void DeleteCollisionRegion()
		if(!m_xCollisionGuid.IsNull())then
			var ^CRegionMgr pxRM=^(CSrvWrap.GetRegionMgr());
			if(pxRM!=null)then
				var int iIdx=CSrvWrap.GetRegionMgr().FindRegion(m_xCollisionGuid);
				if(iIdx>=0)then
					var ^CRegion pxRegion=pxRM^.GetRegion(iIdx);
					m_xCollisionSink.Unsubscribe();
					if(pxRegion!=null)then
						pxRegion^.Unbind();
					endif;
					m_xCollisionSink.DeleteRegion();
					var CGuid xNew;
					m_xCollisionGuid=xNew;
				endif;
			endif;
		endif;
	endproc;
	
	proc bool OnCollObjAdd(CObjHndl p_xHndl)
		if(m_bToBeDeleted)then return false; endif;
		if(p_xHndl==GetHandle())then return false; endif;
		var ^CFightingObj pxFO=cast<CFightingObj>(p_xHndl.GetObj());
//		if(pxFO!=null&&pxFO^.IsFlyingUnit()&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxFO^.GetOwner(), GetOwner())&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxFO^.GetOwner()))then
		if(pxFO!=null&&pxFO^.IsFlyingUnit()&&pxFO^.GetOwner()==GetOwner())then
			if(m_asClasses.FindEntry(pxFO^.GetClassName())>=0)then
				m_xRegionObjects.Include(p_xHndl);
				Disengage();
				if(!HasTimer(TIMER_COLLISION_HANDLER))then
					CreateTimer(TIMER_COLLISION_HANDLER, CGameTimeSpan.OneSecond() * COLLISION_CHECK, true);
				endif;
			endif;
		endif;
		return true;
	endproc;
	
	proc bool OnCollObjRem(CObjHndl p_xHndl)
		if(m_xRegionObjects.FindEntry(p_xHndl)==-1)then return false; endif;
		m_xRegionObjects.RemEntry(p_xHndl);
		if(m_xRegionObjects.NumEntries()<1)then
			DeleteTimer(TIMER_COLLISION_HANDLER);
		endif;
		return true;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==TIMER_COLLISION_HANDLER)then
				Disengage();
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	export proc void Disengage()
		var string sAct=GetActionDesc();
		if(sAct!="CActWalk"&&sAct!="CActFlight"&&!HasSecondaryAction())then
			var real fD=Random.MTRandF(Math.Pi()*2.0f);
			var vec3 vOffset, vNew;
			vOffset.SetX(m_fCollisionRadius+COLLISION_PLUS);
			vOffset.RotZ((Random.GetInt()%628).ToReal() / 100.0);
//			vOffset.SetXYZ(Math.Sin(fD),Math.Cos(fD),0.0f);
			vNew=GetPosInMap(GetPos()+vOffset);
			vNew.SetZ(Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vNew.GetX(),vNew.GetY()),m_fWaterLevel)+FLYING_HEIGHT);
			SecondaryMoveAction(vNew,COLLISION_FIX);
			UpdateAggressionPos(vNew);
		endif;
	endproc;
	
	export proc void SetIced(real p_fDuration,real p_fResistStart)
		return;
	endproc;
	
	export proc bool IsTrapped()
		return false;
	endproc;
	
	export proc bool IsAbleToFight()
		return GetDmg()>0.0;
	endproc;
	
	export proc CFourCC GetProjectileLink()
		var CFourCC xL="Dri2";
		return xL;
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj , ref CGameObj.CAdvanceActionParams p_rxParams)
		if(!m_bFlying)then return super.AdvanceAction(p_xGoalObj, p_rxParams); endif;
		var vec3 vObj=p_rxParams.m_vGoalOffset, vOwn=GetPos(),vNew;
		if(p_xGoalObj.IsValid())then
			vObj=p_xGoalObj.GetObj()^.GetPos();
		endif;
		var real fScape=Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vOwn.GetX(),vOwn.GetY()),m_fWaterLevel);
		var real fHeight=vOwn.GetZ()-fScape;
		var real fRange=GetAttackRange()+GetRadius();
		vOwn.SetZ(fScape);
		var vec3 vDirection=vOwn - vObj;
		vDirection.Normalize();
		vNew=GetPosInMap(vObj+(vDirection*fRange));
		WalkAction(vNew, GetMaxSpeed(), false);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption, ^CGameObj p_pxGoalObj, CFourCC p_xWalkSet, bool p_bUseMaterial)
		if(!m_bFlying)then return super.WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, p_bHeightAdaption, p_pxGoalObj, p_xWalkSet, p_bUseMaterial); endif;
		var vec3 vPosition=GetPosInMap(p_vDest);
		vPosition.SetZ(Math.Max(CSrvWrap.GetScapeMgr().GetHeight(p_vDest.GetX(),p_vDest.GetY()),m_fWaterLevel)+FLYING_HEIGHT);
		return super.WalkAction(vPosition, p_iPrefSpeed, false, false, p_pxGoalObj, p_xWalkSet, p_bUseMaterial);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption, ^CGameObj p_pxGoalObj, CFourCC p_xWalkSet)
		return WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, p_bHeightAdaption, p_pxGoalObj, p_xWalkSet, true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption, ^CGameObj p_pxGoalObj)
		return WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, p_bHeightAdaption, p_pxGoalObj, GetWalkSet(), true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption)
		return WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, p_bHeightAdaption, null, GetWalkSet(), true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed, bool p_bUsePathfinder)
		return WalkAction(p_vDest, p_iPrefSpeed, p_bUsePathfinder, true, null, GetWalkSet(), true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest, int p_iPrefSpeed)
		return WalkAction(p_vDest, p_iPrefSpeed, true, true, null, GetWalkSet(), true);
	endproc;
	
	export proc void WalkAction(vec3 p_vDest)
		return WalkAction(p_vDest, GetMaxSpeed(), true, true, null, GetWalkSet(), true);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed, CFourCC p_xWalkSet, real p_fMaxRange, ref vec3 p_rvRootPos, ref vec3 p_rvGoalOffset)
		if(!m_bFlying)then return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed, p_xWalkSet, p_fMaxRange, p_rvRootPos, p_rvGoalOffset); endif;
		var vec3 vObj=p_rvGoalOffset, vOwn=GetPos(),vNew;
		if(p_xGoalObj.IsValid())then
			vObj=p_xGoalObj.GetObj()^.GetPos();
		endif;
		var real fScape=Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vOwn.GetX(),vOwn.GetY()),m_fWaterLevel);
		var real fHeight=vOwn.GetZ()-fScape, fRange=GetAttackRange();
		vOwn.SetZ(fScape);
		var vec3 vDirection=vOwn - vObj;
		vDirection.Normalize();
		vNew=GetPosInMap(vObj+(vDirection*fRange));
		WalkAction(vNew, GetMaxSpeed(), false);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed, CFourCC p_xWalkSet, real p_fMaxRange, ref vec3 p_rvRootPos)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed, p_xWalkSet, p_fMaxRange, p_rvRootPos);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed, CFourCC p_xWalkSet, real p_fMaxRange)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed, p_xWalkSet, p_fMaxRange);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed, CFourCC p_xWalkSet)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed, p_xWalkSet);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance, int p_iPrefSpeed)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance, p_iPrefSpeed);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj, real p_fMinDistance)
		return super.AdvanceAction(p_xGoalObj, p_fMinDistance);
	endproc;
	
	export proc void AdvanceAction(CObjHndl p_xGoalObj)
		return super.AdvanceAction(p_xGoalObj);
	endproc;
	
	export proc void Die()
		if(m_bFlying)then
			AllGotDrowned();
		else
			SetReleaseWhileDying();
			DismountAll();
			if(m_xPassengers.NumEntries()>0)then
				CFeedback.Print(GetOwner(), CFeedback.ATTACK, "_NT_TransportUnitsDiedInVehicle");
			endif;
			while(m_xPassengers.NumEntries()>0)do
				var ^CFightingObj pxPassenger=cast<CFightingObj>(m_xPassengers[0].GetObj());
				m_xPassengers.DeleteEntry(0);
				if(pxPassenger!=null)then
					pxPassenger^.TerminateAction();
					pxPassenger^.SetVisible(false);
					pxPassenger^.DieFastAndSilent();
				endif;
			endwhile;
		endif;
		super.Die();
	endproc;
	
	export proc void Delete()
		DeleteCollisionRegion();
		var ^CZeppelinCorpse pxGameObj=cast<CZeppelinCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("zeppelin_corpse",GetOwner(),GetPos(),GetRotation()));
		if(pxGameObj!=null)then
			pxGameObj^.SetSource(this);
			pxGameObj^.Init(GetName(), 0.0001);
		endif;
		super.Delete();
	endproc;
	
	export static proc void Evacuate()
		return;
	endproc;
	
	export proc void SetHome(CObjHndl p_xHome)
		if(p_xHome.IsValid())then
			var ^CAttribs pxAttr=p_xHome.GetObj()^.GetAttribs();
			if(pxAttr==null)then return; endif;
			if(pxAttr^.GetValueInt("TradeBuilding")!=1)then return; endif;;
			m_xHome=p_xHome;
			var ^CAttribs pxAttribs=GetAttribs();
			if(pxAttribs!=null&&m_xHome.GetObj()!=null)then
				pxAttribs^.SetValue("trade_home", m_xHome.GetObj()^.GetGuid().ToString());
			endif;
		endif;
		return;
	endproc;
	
	export proc bool AttackEnemy(^CFightingObj p_pxEnemy, vec3 p_vTarget, ref bool p_rbRotated)
		if(!m_bFlying)then return super.AttackEnemy(p_pxEnemy, p_vTarget, p_rbRotated); endif;
		if(p_pxEnemy!=null)then
			if(p_pxEnemy^.IsFlyingUnit() && !CanShootAir())then return false; endif;
		endif;
		var string sProj=GetProjectile();
		var string sFAnim=GetNextFightAnim();
		if(sFAnim.IsEmpty())then sFAnim="attack_front"; endif;
		var bool bProj=!sProj.IsEmpty();
		var bool bFAnim=!sFAnim.IsEmpty();
		begin Rotate;
			var real fAngle;
			var Quat qRot;
			if(p_pxEnemy!=null)then
				fAngle=GetAngleToR(p_pxEnemy);
				qRot=GetAngleToQ(p_pxEnemy);
			else
				fAngle=GetAngleToR(p_vTarget);
				qRot=GetAngleToQ(p_vTarget);
			endif;
			if(fAngle>Math.Pi()/2.0)then
				RotateActionSpeed(qRot,5.0);
				p_rbRotated=true;
				return false;
			endif;
		end Rotate;
		if(bProj)then
			var int j, iK=GetProjectilesNumber();
			for(j=0)cond(j<iK)iter(j++)do
				CreateProjectileAndShoot(p_pxEnemy, p_vTarget);
			endfor;
			if(sFAnim!=""&&HasAnim(sFAnim))then
				SetAnim(sFAnim,1);
			endif;
			DoCaptainAttackAnim();
			return false;
		elseif(bFAnim)then
			if(sFAnim!=""&&HasAnim(sFAnim))then
				SetAnim(sFAnim,1);
			endif;
			DoCaptainAttackAnim();
		endif;
		return true;
	endproc;
	
	export proc void Trade(^CGameObj p_pxTarget, bool p_bUserCommand, bool p_bQ)
		if(IsAbleToWalk())then
			if(p_pxTarget==null)then return; endif;
			var ^CTask pxOldTask=GetCurTask();
			var bool bOldUserCommand=false;
			if(pxOldTask!=null)then
				bOldUserCommand=pxOldTask^.IsUserCommand();
			endif;
			if(bOldUserCommand && !p_bUserCommand)then return; endif;
			var ^CAttribs pxAttr=p_pxTarget^.GetAttribs();
			if(pxAttr==null)then return; endif;
//			if(p_pxTarget^.GetClassName()=="aje_floating_harbour"||p_pxTarget^.GetClassName()=="hu_harbour"||p_pxTarget^.GetClassName()=="ninigi_harbour"||p_pxTarget^.GetClassName()=="seas_carrier")then return; endif;
			if(!pxAttr^.ContainsKey("TradeBuilding")||pxAttr^.GetValueInt("TradeBuilding")!=1)then
				GoTo(p_pxTarget^.GetPos(), true, GetDefaultSpeed(), true, true);
			endif;
			if(!CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), p_pxTarget^.GetOwner()))then
				GoTo(p_pxTarget^.GetPos(), true, GetDefaultSpeed(), true, true);
			endif;
			if(!m_xHome.IsValid())then SetHome(p_pxTarget^.GetHandle()); return; endif;
			var ^CTrade pxTask=cast<CTrade>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"Trade"));
			if(pxTask==null)then return; endif;
			if(pxTask^.Init(GetHandle(),p_pxTarget^.GetHandle()))then
				pxTask^.SetUserCommand(p_bUserCommand);
				NewTaskFO(pxTask,p_bQ);
			else
				pxTask^.GetFactory()^.FreeState(pxTask);
			endif;
		endif;
	endproc;
	
	export proc CObjHndl GetHome()
		if(!m_xHome.IsValid())then
			var ^CAttribs pxAttribs=GetAttribs();
			m_xHome=CObjHndl.Invalid();
			if(pxAttribs!=null)then pxAttribs^.SetValue("trade_home","0"); endif;
//			var CObjQuery xQuery;
//			xQuery.SetOwner(GetOwner());
//			xQuery.SetAttribsPos("TradeBuilding",1);
//			xQuery.SetAttribsNeg("CurTask","BuildUpB");
//			var CObjList xList;
//			if(xQuery.Execute(xList))then
//				var int iIndex=xList.FindNearest(GetPos());
//				if(iIndex!=-1)then
//					SetHome(xList[iIndex]);
//				endif;
//			endif;
		endif;
		return m_xHome;
	endproc;
	
	export proc void PickUp(CObjHndl p_xItem,bool p_bQueue)
		if(!m_bFlying)then return super.PickUp(p_xItem, p_bQueue); endif;
		var ^CGameObj pxO=p_xItem.GetObj();
		if(pxO!=null)then
			GoTo(pxO^.GetPos(), true, GetDefaultSpeed(), true, true, GetOnWall(), false, true);
		endif;
		return;
	endproc;
	
	export proc real GetFlyingHeight()
		return FLYING_HEIGHT;
	endproc;
	
endclass;
	
	//========================================================================================
	//=== Ships ==============================================================================
	//========================================================================================
	
class CAjeMosasaurus inherit CShip
	
//	export proc void OnInit(bool p_bLoad)
//		super.OnInit(p_bLoad);
//		SetDestructionType(GetGfxName(),"dying");
//	endproc;
//	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			ReBuildWeapon();
		endif;
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,false);
		SetDestructionType(GetGfxName(),"dying");
	endproc;
	
	export proc void ReBuildWeapon()
		var string sClassName=GetClassName();
		if(sClassName=="aje_mosasaurus")then
			if(!HasBuildUp(CBuildUpBase.TYPE_WEAPON))then
				SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,false);
				SetBuildUp(CBuildUpBase.TYPE_WEAPON);
				var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("aje_ankylosaurus_catapult", GetOwner());
				if(pxO!=null)then
					GetBuildUp()^.AddObj(pxO^.GetHandle(), "Rider");
				endif;
				pxO=CSrvWrap.GetObjMgr()^.CreateObj("aje_mosa_base", GetOwner());
				if(pxO!=null)then
					GetBuildUp()^.AddObj(pxO^.GetHandle(), "Rider");
				endif;
				pxO=CSrvWrap.GetObjMgr()^.CreateObj("aje_mosa_buildup", GetOwner());
				if(pxO!=null)then
					GetBuildUp()^.AddObj(pxO^.GetHandle(), "Rider");
				endif;
				cast<CBuildUpWeapon>(GetBuildUp())^.SetWeaponClass(GetClassName());
				cast<CBuildUpWeapon>(GetBuildUp())^.SetCanRotate(true);
				cast<CBuildUpWeapon>(GetBuildUp())^.SetAutoAttack(true);
			endif;
		endif;
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		if(HasBuildUp())then
			po_rxLink="Dri1";
			po_rbIsBuildUpLink=true;
			SetCaptainAnim("ride_idle_0");
			SetCaptainAttackAnim("aje_attack_ankylo");
			return true;
		else
			return super.GetCaptainLink(po_rxLink, po_rbIsBuildUpLink);
		endif;
	endproc;
	
//	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
//		po_rxLink="Ride";
//		SetCaptainAnim("ride_idle_0");
//		SetCaptainAttackAnim("ride_attack_front");
//		return true;
//	endproc;
	
//	export proc ^CArrow CreateProjectileAndShoot(^CFightingObj p_pxEnemy, vec3 p_vPos)
//		return super.CreateProjectileAndShoot(p_pxEnemy, p_vPos);
//	endproc;
//	
//	export proc ^CArrow CreateProjectileAndShoot(^CFightingObj p_pxEnemy, vec3 p_vPos, string p_sProjectileType)
//		var ^CArrow pxArrow=super.CreateProjectileAndShoot(p_pxEnemy,p_vPos,p_sProjectileType);
//		return pxArrow;
//	endproc;
	
	export proc real GetAdaption()
		return 7.0f;
	endproc;
	
endclass
	
class CAjeLiopleurodon inherit CShip
	
	export const int FORCE_HEALING = 40003;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			ReBuildWeapon();
		endif;
		SetTransportClass(1);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,false);
		SetDestructionType(GetGfxName(),"dying");
	endproc;
	
	export proc void ReBuildWeapon()
		var string sClassName=GetClassName();
		if(sClassName=="aje_liopleurodon")then
			SetBuildUp(CBuildUpBase.TYPE_TRANSPORTER_OPEN);
			var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("aje_stegosaurus_transporter", GetOwner());
			if(pxO!=null)then
				var vec3 vOffset={0.0,-1.5,-0.5};
				GetBuildUp()^.AddObjCustomized(pxO^.GetHandle(), "Rider", vOffset);
				AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
				var ^CBuildUpWeapon pxWeaponBuildUp=cast<CBuildUpWeapon>(GetAdditionalBuildUp(0));
				pxWeaponBuildUp^.AddObjCaptain(m_xCaptain, "Dri5", -1.0, pxO^.GetHandle(), true);
				pxWeaponBuildUp^.SetWeaponClass("aje_archer");
				pxWeaponBuildUp^.SetCanRotate(true);
				pxWeaponBuildUp^.SetAdditionalWeapon(true);
				pxWeaponBuildUp^.SetAutoAttack(true);
			endif;
		endif;
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		if(HasBuildUp(CBuildUpBase.TYPE_TRANSPORTER_OPEN))then
			po_rxLink="Dri5";
			po_rbIsBuildUpLink=true;
			SetCaptainAnim("standanim");
			SetCaptainAttackAnim("bow_1");
			return true;
		else
			return super.GetCaptainLink(po_rxLink, po_rbIsBuildUpLink);
		endif;
	endproc;
	
	export proc real GetAdaption()
		return 5.0f;
	endproc;
	
//	export proc void ReBuildWeapon()
//		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,true);
//		SetBuildUp(CBuildUpBase.TYPE_FAKE);
//		CreateCaptain();
//		AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
//		var ^CBuildUpWeapon pxWeaponBuildUp=cast<CBuildUpWeapon>(GetAdditionalBuildUp(0));
//		pxWeaponBuildUp^.AddObjCaptain(m_xCaptain, "Ride", -1.0, GetHandle());
//		pxWeaponBuildUp^.SetWeaponClass("aje_liop_char");
//		pxWeaponBuildUp^.SetCanRotate(true);
//		pxWeaponBuildUp^.SetAdditionalWeapon(true);
//	endproc;
	
//	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
//		po_rxLink="Ride";
//		po_rbIsBuildUpLink=false;
//		SetCaptainAnim("ride_idle_0");
//		SetCaptainAttackAnim("ride_bow");
//		return true;
//	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		ForceHealing();
	endproc;
	
	export proc void UpdatePassengerAttribs()
		super.UpdatePassengerAttribs();
		ForceHealing();
		return;
	endproc;
	
	export proc void ForceHealing()
		if(HasTimer(FORCE_HEALING))then DeleteTimer(FORCE_HEALING); endif;
		if(GetPassengers().NumEntries()>=0 && HasOpenBuildUp())then
			CreateTimer(FORCE_HEALING, CGameTimeSpan.OneSecond() * 10.0, true);
		endif;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==FORCE_HEALING)then
				if(GetPassengers().NumEntries()<=0)then
					DeleteTimer(FORCE_HEALING);
					return;
				endif;
				var int i, iC=m_xPassengers.NumEntries();
				for(i=0)cond(i<iC)iter(i++)do
					var ^CCharacter pxChar=cast<CCharacter>(m_xPassengers[i].GetObj());
					if(pxChar!=null)then
						if(pxChar^.GetClassName()=="hu_druid"||pxChar^.GetClassName()=="aje_shaman"||pxChar^.GetClassName()=="ninigi_monk"||pxChar^.GetClassName()=="seas_medic")then
							if(pxChar^.GetHealingRadius()>0.0f && pxChar^.SomeoneToHeal(false))then
								pxChar^.HealUnits(false, true);
							endif;
						endif;
					endif;
				endfor;
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
endclass
	
class CSeasCannonTurtle inherit CAmphibian
//class CSeasCannonShip inherit CShip
	
	var CFourCC m_xTurretLink;
	const vec3 WEAPON_OFFSET = {0.0,0.0,0.53};
//	const vec3 WEAPON_OFFSET = {0.0,-2.62,-1.36};
	
	export constructor()
		m_xTurretLink="we";
	endconstructor;
	
	export proc void WaterToLand()
		SetGFX("Macrolemyd_Land");
		SetSpraySize(0);
		SetDestructionType(GetGfxName(),"dying_land");
		SetTurtleOnLand(true);
	endproc;
	
	export proc void LandToWater()
		SetSpraySize(2);
		SetGFX("Macrolemyd_Water");
		SetDestructionType(GetGfxName(),"dying");
		SetTurtleOnLand(false);
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			if(GetClassName()=="seas_cannon_turtle")then
				SetBuildUp(CBuildUpBase.TYPE_WEAPON);
				var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("seas_wehrspinne_top", GetOwner());
				if(pxO!=null)then
					GetBuildUp()^.AddObjCustomized(pxO^.GetHandle(), "con",WEAPON_OFFSET);
//					GetBuildUp()^.AddObjCustomized(pxO^.GetHandle(), "Rider",WEAPON_OFFSET);
				endif;
				cast<CBuildUpWeapon>(GetBuildUp())^.SetWeaponClass(GetClassName());
				cast<CBuildUpWeapon>(GetBuildUp())^.SetAutoAttack(true);
				cast<CBuildUpWeapon>(GetBuildUp())^.SetCanRotate(true);
				cast<CBuildUpWeapon>(GetBuildUp())^.SetAdditionalWeapon(true);
				SetAttackType(1);
			endif;
		endif;
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMOR,false);
//		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,false);
		SetDestructionType(GetGfxName(),"dying");
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		po_rxLink="Dri1";
		po_rbIsBuildUpLink=true;
		SetCaptainAnim("balista_stand");
		return true;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="CaTu";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,2);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		var string sLink=m_xTurretLink.AsString();
		(pxArc^) << sLink;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="CaTu")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			if(p_pxReaderNode^.GetVersion()>=2)then
				var string sLink;
				(pxArc^) << sLink;
				m_xTurretLink=sLink;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void ProjectileOn()
		if(GetProjectile().IsEmpty())then return; endif;
		if(HasBuildUp())then
			var ^CGameObj pxObj=GetBuildUp()^.GetPrimaryLinkedObjFight().GetObj();
			if(pxObj==null)then return; endif;
			var CFourCC xLink="Dri1"; var vec3 vP;
			if(pxObj^.GetLinkPosObj(xLink, vP))then
				pxObj^.SetLinkGFX(xLink, GetProjectile()+GetWeaponMgr()^.GetRightHVariationPostfix());
				return;
			endif;
		else
			super.ProjectileOn();
		endif;
	endproc;
	
	export proc void ProjectileOff()
		if(GetProjectile().IsEmpty())then return; endif;
		if(HasBuildUp())then
			var ^CGameObj pxObj=GetBuildUp()^.GetPrimaryLinkedObjFight().GetObj();
			if(pxObj==null)then return; endif;
			var CFourCC xLink="Dri1"; var vec3 vP;
			if(pxObj^.GetLinkPosObj(xLink, vP))then
				pxObj^.RemLinkGFX(xLink);
				return;
			endif;
		else
			super.ProjectileOff();
		endif;
	endproc;
	
	export proc vec3 GetProjectileStartPos()
		if(!HasBuildUp())then return super.GetProjectileStartPos(); endif;
		var vec3 vBuildUpBasePos;
		var vec3 vProjectilePos;
		var CFourCC xProjectileLink="";
		if(!GetLinkPosWorld(m_xTurretLink, vBuildUpBasePos))then return super.GetProjectileStartPos(); endif;
		var ^CGameObj pxObj=GetBuildUp()^.GetPrimaryLinkedObjFight().GetObj();
		if(pxObj==null)then return super.GetProjectileStartPos(); endif;
		if(!pxObj^.GetLinkPosWorld(xProjectileLink, vProjectilePos))then return super.GetProjectileStartPos(); endif;
		vProjectilePos=vProjectilePos-vBuildUpBasePos;
		var Quat qAdditionalRot=pxObj^.GetAdditionalRot();
		qAdditionalRot.VecRotateU(vProjectilePos);
		return (vBuildUpBasePos+vProjectilePos);
	endproc;
	
	export proc vec3 GetProjectileStartPos(int p_iIdx)
		return super.GetProjectileStartPos(p_iIdx);
	endproc;
	
	export proc bool SetAttackAnim()
		SetSLEAnim("attack_front",0,false,false);
		return(true);
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(p_sCommand=="WaterOnly")then
			SetCanWalk(false);
		elseif(p_sCommand=="UnWaterOnly")then
			SetCanWalk(true);
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	proc bool UpdateGfx()
		return false;
	endproc;
	
endclass;
	
class CSeasMosasaurus inherit CShip
	
	export const int FORCE_HEALING = 40003;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			ReBuildWeapon();
		endif;
		SetTransportClass(1);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,false);
		SetDestructionType(GetGfxName(),"dying");
	endproc;
	
	export proc void ReBuildWeapon()
		var string sClassName=GetClassName();
		if(sClassName=="seas_mosasaurus")then
			SetBuildUp(CBuildUpBase.TYPE_CYBORG_TRANSPORTER);
			cast<CBuildUpTransporterCustom>(GetBuildUp())^.AddIgnoreLink("Dri1");
			var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("seas_triceratops_transporter_buildup", GetOwner());
			if(pxO!=null)then
//				var ^CPropDB.CNode pxCustom;
//				var ^CPropDB pxSource=new CPropDB;
//				var vec3 vOffset;
//				if(pxSource^.Load("C:/source.txt"))then
//					pxCustom=^((pxSource^).GetRoot());
//					vOffset.SetXYZ(pxCustom^.GetValueR("x",0.0),pxCustom^.GetValueR("y",0.0),pxCustom^.GetValueR("z",0.0));
//				endif;
				var vec3 vOffset={0.0,-1.5,-1.0};
				GetBuildUp()^.AddObjCustomized(pxO^.GetHandle(), "Rider", vOffset);
				AddAdditionalBuildUp(CBuildUpBase.TYPE_WEAPON);
				var ^CBuildUpWeapon pxWeaponBuildUp=cast<CBuildUpWeapon>(GetAdditionalBuildUp(0));
				pxWeaponBuildUp^.AddObjCaptain(m_xCaptain, "Dri1", -1.0, pxO^.GetHandle(), true);
				pxWeaponBuildUp^.SetWeaponClass("seas_mosa_rider");
				pxWeaponBuildUp^.SetCanRotate(true);
				pxWeaponBuildUp^.SetAdditionalWeapon(true);
				pxWeaponBuildUp^.SetAutoAttack(true);
			endif;
		endif;
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		if(HasBuildUp(CBuildUpBase.TYPE_TRANSPORTER_OPEN)||HasBuildUp(CBuildUpBase.TYPE_CYBORG_TRANSPORTER))then
			po_rxLink="Dri1";
			po_rbIsBuildUpLink=true;
			SetCaptainAnim("standanim");
			SetCaptainAttackAnim("seas_marksman_0");
			return true;
		else
			return super.GetCaptainLink(po_rxLink, po_rbIsBuildUpLink);
		endif;
	endproc;
	
	export proc real GetAdaption()
		return 7.0f;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		ForceHealing();
	endproc;
	
	export proc void UpdatePassengerAttribs()
		super.UpdatePassengerAttribs();
		ForceHealing();
		return;
	endproc;
	
	export proc void ForceHealing()
		if(HasTimer(FORCE_HEALING))then DeleteTimer(FORCE_HEALING); endif;
		if(GetPassengers().NumEntries()>=0 && HasOpenBuildUp())then
			CreateTimer(FORCE_HEALING, CGameTimeSpan.OneSecond() * 10.0, true);
		endif;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==FORCE_HEALING)then
				if(GetPassengers().NumEntries()<=0)then
					DeleteTimer(FORCE_HEALING);
					return;
				endif;
				var int i, iC=m_xPassengers.NumEntries();
				for(i=0)cond(i<iC)iter(i++)do
					var ^CCharacter pxChar=cast<CCharacter>(m_xPassengers[i].GetObj());
					if(pxChar!=null)then
						if(pxChar^.GetClassName()=="hu_druid"||pxChar^.GetClassName()=="aje_shaman"||pxChar^.GetClassName()=="ninigi_monk"||pxChar^.GetClassName()=="seas_medic")then
							if(pxChar^.GetHealingRadius()>0.0f && pxChar^.SomeoneToHeal(false))then
								pxChar^.HealUnits(false, true);
							endif;
						endif;
					endif;
				endfor;
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
endclass
	
class CSeasSubmarine inherit CMediumSizeShip
	
	var bool		m_bIntendedDive;
	var bool		m_bCloak;
	
	export constructor()
		m_bIntendedDive=false;
		m_bCloak=false;
	endconstructor;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="SeSu")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			(pxArc^) << m_bCloak;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="SeSu";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		(pxArc^) << m_bCloak;
		pxWalk^.Close();
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetSpraySize(2);
//		SetAggressionState(2);
		if(!p_bLoad)then
			if(CanDisguise())then
//				SetAggressionState(1);
				AddCamouflageEffect("disg");
			endif;
		endif;
	endproc;
	
	export proc bool AttackEnemy(^CFightingObj p_pxEnemy, vec3 p_vTarget, ref bool p_rbRotated)
		RemoveCamouflageEffect("disg");
		return super.AttackEnemy(p_pxEnemy,p_vTarget,p_rbRotated);
	endproc;
	
	export proc void OnTechTreeChange()
		super.OnTechTreeChange();
	endproc;
	
	export proc void OnTechTreeChange(ref CStringArray p_rasChanges)
		super.OnTechTreeChange(p_rasChanges);
		if(CanDisguise()&&!m_bCloak)then
			m_bCloak=true;
			SetAggressionState(1);
			AddCamouflageEffect("disg");
		endif;
	endproc;
	
	export proc ^CArrow CreateProjectileAndShoot(^CFightingObj p_pxEnemy, vec3 p_vPos, string p_sProjectileType)
		var ^CArrow pxArrow=super.CreateProjectileAndShoot(p_pxEnemy,p_vPos,p_sProjectileType);
		if(CanDisguise())then
			if(pxArrow!=null)then pxArrow^.SetVisible(false); endif;
		endif;
		return pxArrow;
	endproc;
	
endclass;
	
class CTradeMuraeno inherit CTradeTransporter
	
	var string				m_sSinkAnim;
	var string				m_sDestructionObjName;
	const int					TIMER_NIGHT=196;
	var bool					m_bNight;
	var CObjHndl			m_xBuildUp;
	var bool					m_bIntendedDive;
	const vec3 AJE_OFFSET			= {0.0,0.0,1.1};
	const vec3 SEAS_OFFSET		= {0.0,0.0,0.48};
	
	export constructor()
		m_bIntendedDive=false;
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		SetSwimming(true);
		super.OnInit(p_bLoad);
		m_iSizeClass=3; //ships are big
		if(!p_bLoad)then
			SetType("SHIP");
			InitAttribs();
			if(GetClassName()=="aje_muraenosaurus")then
				SetBuildUp(CBuildUpBase.TYPE_FAKE);
				var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("aje_trade_dino_buildup", GetOwner());
				GetBuildUp()^.AddObjCustomized(pxO^.GetHandle(), "con", AJE_OFFSET);
			elseif(GetClassName()=="seas_muraenosaurus")then
				SetBuildUp(CBuildUpBase.TYPE_FAKE);
				var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("seas_triceratops_resource_collector_buildup", GetOwner());
				GetBuildUp()^.AddObjCustomized(pxO^.GetHandle(), "con", SEAS_OFFSET);
			endif;
			StartTT();
			SetCanFightAttrib(false);
			CreateTimer(TIMER_NIGHT,CGameTimeSpan.OneSecond()*20.0f,true);
		endif;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null&&pxAttr^.GetValueInt("trade")!=1)then
			pxAttr^.SetValue("trade",1);
		endif;
		SetSpraySize(2);
		SetDestructionType(GetGfxName(),"dying");
		UpdateAttribs(p_bLoad);
		AddUnit();
		SetCanWalk(false);
		SetCanSwim(true);
		//item inventory -> all levels can now have one item
		if(GetInventory()==null)then
			InitInventory(1);
		endif;
		SetAnim("standanim", 3);
		SetTransportClass(2);
		OnTechTreeChange();
		SetEatingType();
	endproc;
	
	export proc void SetEatingType()
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("Carnivore", true);
		endif;
	endproc;
	
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		if(GetClassName()=="aje_muraenosaurus")then
			if(HasBuildUp(CBuildUpBase.TYPE_FAKE))then
				po_rxLink="Dri1";
				po_rbIsBuildUpLink=true;
				SetCaptainAnim("standanim");
				SetCaptainAttackAnim("standanim");
				return true;
			else
				return super.GetCaptainLink(po_rxLink, po_rbIsBuildUpLink);
			endif;
		elseif(GetClassName()=="seas_muraenosaurus")then
			if(HasBuildUp(CBuildUpBase.TYPE_FAKE))then
				po_rxLink="Dri1";
				po_rbIsBuildUpLink=true;
				SetCaptainAnim("gatling_rider_standanim");
				SetCaptainAttackAnim("gatling_rider_standanim");
				return true;
			else
				return super.GetCaptainLink(po_rxLink, po_rbIsBuildUpLink);
			endif;
		else
			return false;
		endif;
	endproc;
	
	export proc void SetSpraySize(int p_iSize)
		if(p_iSize>=1&&p_iSize<=3)then
			var CFourCC xLink="SpBa";
			if(HasLink(xLink))then
				SetLinkGFX(xLink,"spray_back_"+p_iSize.ToString());
			endif;
			xLink="SpFr";
			if(HasLink(xLink))then
				SetLinkGFX(xLink,"spray_front_"+p_iSize.ToString());
			endif;
		else
			var CFourCC xLink="SpBa";
			RemLinkGFX(xLink);
			xLink="SpFr";
			RemLinkGFX(xLink);
		endif;
	endproc;
	
	proc bool SetDestructionType(string p_sDestructionObjName, string p_sSinkAnim)
		m_sDestructionObjName=p_sDestructionObjName;
		m_sSinkAnim=p_sSinkAnim;
		return(true);
	endproc;
	
	export proc void Die()
		AllGotDrowned();
		if(!IsDead())then
			CreateShipCorpse();
		endif;
		super.Die();
	endproc;
	
	export proc ^CGameObj CreateShipCorpse()
		var bool bBiological=m_xTechTree.GetValueR(GetObjPath()+"/spirit_life",0.0f)>0.0f;
		if(bBiological)then
			var ^CGameObj pxGameObj=CSrvWrap.GetObjMgr()^.CreateObj(GetClassName()+"_food",GetOwner(),GetPos(),GetRotation());
			if(pxGameObj!=null)then
				pxGameObj^.SetGFX(GetGfxName());
				pxGameObj^.SetName(GetName());
				var ^CFood pxFood=cast<CFood>(pxGameObj);
				if(pxFood!=null)then
					pxFood^.SetRndInvMask(GetRndInvMask());
				endif;
				var ^CDino_Food pxDinoFood=cast<CDino_Food>(pxGameObj);
				if(pxDinoFood!=null)then
					pxDinoFood^.Initialize(this, m_iSizeClass, false);
					pxDinoFood^.SetAggressive(GetTechTreeAggressiv());
					if(HasBuildUp())then
//						pxDinoFood^.SetBuildUp(CBuildUpBase.TYPE_FAKE);
//						GetBuildUp()^.TransferLinkedObjs(pxDinoFood^.GetBuildUp());
						GetBuildUp()^.TransferLinkedObjs(pxDinoFood);
						var int j, jC=NumAdditionalBuildUps();
						for(j=0)cond(j<jC)iter(j++)do
							if(HasAdditionalBuildUp(j))then
//								GetAdditionalBuildUp(j)^.TransferLinkedObjsAdd(pxDinoFood^.GetBuildUp());
								GetAdditionalBuildUp(j)^.TransferLinkedObjsAdd(pxDinoFood);
							endif;
						endfor;
						pxDinoFood^.UpdateLinkedObjs();
					endif;
				endif;
				var real fRadius=GetRadius();
				pxGameObj^.SetOwner(GetOwner());
				if(fRadius<=3.5)then
					pxGameObj^.InvokeGenericSCEvent(16,4.0f);
				elseif(fRadius<=5.0)then
					pxGameObj^.InvokeGenericSCEvent(10,4.0f);
				else
					pxGameObj^.InvokeGenericSCEvent(17,4.0f);
				endif;
				pxGameObj^.SetAnim("sink",1);
			endif;
			return pxGameObj;
		else
			var ^CShipCorpse pxGameObj=cast<CShipCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("ShipCorpse",GetOwner(),GetPos(),GetRotation()));
			if(pxGameObj!=null)then
				pxGameObj^.SetSource(this);
				pxGameObj^.Init(m_sDestructionObjName,m_sSinkAnim,GetName(), 10.0);
				pxGameObj^.SetDestructLevel(2);
			endif;
			return pxGameObj;
		endif;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==TIMER_NIGHT)then
				var bool bNight=!CTimeMgr.Get().IsVirtualDay();
				if(m_bNight!=bNight)then
					m_bNight=bNight;
					SetRndInvMaskSingleFlagInv(VIS_FLAG_BLDG_NIGHTMODE,m_bNight);
					SetRndInvMaskSingleFlagInv(VIS_FLAG_BLDG_INIGHTMODE,!m_bNight);
				endif;
				return;
			endif;
		elseif(p_rxEvtPtr.GetClass()=="CTheLite")then
			m_xHome=p_rxEvtPtr.GetObjHandle(0);
			var ^CAttribs pxAttribs=GetAttribs();
			if(pxAttribs!=null&&m_xHome.GetObj()!=null)then
				pxAttribs^.SetValue("trade_home", m_xHome.GetObj()^.GetGuid().ToString());
			endif;
			var CObjHndl xHndl=p_rxEvtPtr.GetObjHandle(0);
			if(xHndl.IsValid())then
				var ^CHarbour pxHarbour=cast<CHarbour>(xHndl.GetObj());
				if(pxHarbour!=null)then
					pxHarbour^.ShipBuildFinished();
					var vec3 vDockPos;
					var Quat qDockRot;
					if(!pxHarbour^.GetDockPos(vDockPos, qDockRot))then
						vDockPos=pxHarbour^.GetPos();
						qDockRot=pxHarbour^.GetRot();
					endif;
					SetPos(vDockPos);
					SetRot(qDockRot);
					var vec3 vRallyPoint=pxHarbour^.GetRallyPosition(0);
					var CObjHndl xTarget=pxHarbour^.GetRallyTarget();
					var CObjList xInvalid;
					if(xTarget.IsValid()&&NextJob(xTarget, xInvalid))then
					else
						if(vRallyPoint.Abs2S()<=1.0f)then
							vRallyPoint=pxHarbour^.GetPos();
						endif;
						var CFourCC xLink=pxHarbour^.GetDockLink();
						CSrvWrap.GetObjMgr()^.GetFreePos(vDockPos,this,vDockPos);
						GoTo(vRallyPoint, true, GetDefaultSpeed(), true, true);
					endif;
				endif;
			endif;
			return;
		endif;
		super.HandleEvent(p_rxEvtPtr);
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(IsTrapped() &&
			!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill") &&
			!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/Dismount")!=-1)
			)then return; endif;
		if(GetTransportObj().IsValid()&&!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1||p_sMiscParams.Find("/LeaveTransport")>=0))then return; endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("/EatSomethingFast")>=0)then
				EatPlantsOrMeat(null, GetPos(), true, p_bQ);
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		elseif(p_sCommand=="EatThatThing")then
			EatPlantsOrMeat(p_pxObject, p_vPos, false, p_bQ);
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	proc void EatPlantsOrMeat(^CGameObj p_pxObject, vec3 p_vPos, bool p_bFastFood, bool p_bQ)
		if(HasFullHP())then return; endif;
		var ^CEating pxTask=cast<CEating>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(), "Eating"));
		if(pxTask==null)then return; endif;
		var bool bInit=false;
		if(p_pxObject!=null)then
			bInit=pxTask^.Init(GetHandle(),p_pxObject^.GetHandle());
		else
			bInit=pxTask^.Init(GetHandle(),p_vPos, p_bFastFood);
		endif;
		if(!bInit)then pxTask^.GetFactory()^.FreeState(pxTask); return; endif;
		NewTaskFO(pxTask,p_bQ);
		pxTask^.SetUserCommand(true);
		//pxTask^.SetUserCommand(p_iUserCmd==1);
	endproc;
	
	export proc real GetAdaption()
		return 5.0f;
	endproc;
	
	export proc string EatAnim()
		return "swim_2";
	endproc;
	
	export proc bool IsBugged()
		return true;
	endproc;
	
	export proc bool IsCarnivore()
		return true;
	endproc;
	
	export proc bool NextJob(CObjHndl p_xTarget, CObjList p_xIgnoreBuildUps)
		if(!p_xTarget.IsValid())then return false; endif;
		var ^CBuilding pxBuilding=cast<CBuilding>(p_xTarget.GetObj());
		if(pxBuilding!=null&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxBuilding^.GetOwner()))then
			if(pxBuilding^.IsReady())then
				var string sClassName=pxBuilding^.GetClassName();
				if((sClassName=="aje_floating_harbour"||sClassName=="hu_harbour"||sClassName=="ninigi_harbour"||sClassName=="seas_carrier")&&!(p_xTarget==GetHome()))then
					Trade(pxBuilding, true,false);
					return true;
				else
					return super.NextJob(p_xTarget,p_xIgnoreBuildUps);
				endif;
			else
				return super.NextJob(p_xTarget,p_xIgnoreBuildUps);
			endif;
		endif;
		return super.NextJob(p_xTarget,p_xIgnoreBuildUps);
	endproc;
	
endclass;
	
class CPirateShip inherit CBigSizeShip
	
	const int TIMER_LEVELING=40029;
	const int TIMER_DEATH=40030;
	var CObjHndl m_xHeck;
	var CObjHndl m_xSegel;
	var CObjHndl m_xBug;
	var CObjHndl m_xKanone;
	var CObjList m_xParts;
	var CObjList m_xDummies;
	var bool m_bDeadBoat;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		var vec3 vPos=GetPos();
		vPos.SetZ(m_fWaterLevel);
		SetPos(vPos);
		if(!p_bLoad)then
			SetAttackType(1);
			SetUnique(true);
			var bool bDone=BuildParts();
			if(!bDone)then
				Die();
				//return;
			endif;
		endif;
		SetDestructionType("ninigi_pirate_ship_dest","destroy");
		SetAttackDirection(Math.Pi()*0.5);
	endproc;
	
	export proc bool SetLevel(int p_iLevel)
		StopEverything();
		TerminateAction();
		DeleteTimer(TIMER_LEVELING);
		CreateTimer(TIMER_LEVELING,CGameTimeSpan.OneSecond()*9.0,true);
		super.SetLevel(p_iLevel);
		StopEverything();
		TerminateAction();
		if(m_xKanone.IsValid())then
			RemGroupedChildren(m_xKanone.GetObj()^.GetGuid());
			m_xKanone.GetObj()^.Delete();
		endif;
		var int i, iC=m_xParts.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(m_xParts[i].IsValid())then
				RemGroupedChildren(m_xParts[i].GetObj()^.GetGuid());
				m_xParts[i].GetObj()^.Delete();
			endif;
		endfor;
		var int j, jC=m_xDummies.NumEntries();
		for(j=0)cond(j<jC)iter(j++)do
			if(m_xDummies[j].IsValid())then
				RemGroupedChildren(m_xDummies[j].GetObj()^.GetGuid());
				m_xDummies[j].GetObj()^.Delete();
			endif;
		endfor;
		m_xHeck=CObjHndl.Invalid();
		m_xSegel=CObjHndl.Invalid();
		m_xBug=CObjHndl.Invalid();
		m_xKanone=CObjHndl.Invalid();
		DeleteTimer(TIMER_DEATH);
		var bool bDone=BuildParts();
		if(bDone)then
			return true;
		else
			return false;
		endif;
	endproc;
	
	export proc bool SetLevelClean(int p_iLevel)
		var bool bReturn=super.SetLevelClean(p_iLevel);
		var ^CFightingObj pxPart=null;
		var int i,iC=m_xParts.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(m_xParts[i].IsValid())then
				pxPart=cast<CFightingObj>(m_xParts[i].GetObj());
				if(pxPart!=null)then
					pxPart^.SetLevelClean(p_iLevel);
				endif;
			endif;
		endfor;
		return bReturn;
	endproc;
	
	export proc bool BuildParts()
		var ^CPirateShipBuildUp pxBuildUp;
		pxBuildUp=cast<CPirateShipBuildUp>(CSrvWrap.GetObjMgr()^.CreateObj("ninigi_pirate_ship_tail", GetOwner()));
		if(pxBuildUp!=null)then
			pxBuildUp^.SetLevelClean(GetLevel());
		endif;
		pxBuildUp^.SetParent(GetHandle(),"psh1");
		m_xHeck=pxBuildUp^.GetHandle();
		pxBuildUp=cast<CPirateShipBuildUp>(CSrvWrap.GetObjMgr()^.CreateObj("ninigi_pirate_ship_sail", GetOwner()));
		if(pxBuildUp!=null)then
			pxBuildUp^.SetLevelClean(GetLevel());
		endif;
		pxBuildUp^.SetParent(GetHandle(),"psh2");
		m_xSegel=pxBuildUp^.GetHandle();
		pxBuildUp=cast<CPirateShipBuildUp>(CSrvWrap.GetObjMgr()^.CreateObj("ninigi_pirate_ship_row", GetOwner()));
		if(pxBuildUp!=null)then
			pxBuildUp^.SetLevelClean(GetLevel());
		endif;
		pxBuildUp^.SetParent(GetHandle(),"psh3");
		m_xBug=pxBuildUp^.GetHandle();
		var ^CGameObj pxCannons=CSrvWrap.GetObjMgr()^.CreateObj("ninigi_pirate_ship_cannons", GetOwner());
		var CFourCC xLink="psh2";
		pxCannons^.LinkAction(GetHandle(),xLink);
		AddGroupedChildren(pxCannons^.GetGuid());
		pxCannons^.SetHitable(false);
		pxCannons^.SetSelectable(false);
		m_xKanone=pxCannons^.GetHandle();
		m_bDeadBoat=false;
		DeleteTimer(TIMER_DEATH);
		m_xParts.Include(m_xHeck);
		m_xParts.Include(m_xBug);
		m_xParts.Include(m_xSegel);
//		AddKillerCount(0);
//		RefreshRangeNDamageInformation();
		return true;
	endproc;
	
	export proc void Die()
		if(!IsDead())then
			if(m_xKanone.IsValid())then
				RemGroupedChildren(m_xKanone.GetObj()^.GetGuid());
				m_xKanone.GetObj()^.Delete();
			endif;
			var int i, iC=m_xParts.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				if(m_xParts[i].IsValid())then
					RemGroupedChildren(m_xParts[i].GetObj()^.GetGuid());
					m_xParts[i].GetObj()^.Delete();
				endif;
			endfor;
			var int j, jC=m_xDummies.NumEntries();
			for(j=0)cond(j<jC)iter(j++)do
				if(m_xDummies[j].IsValid())then
					RemGroupedChildren(m_xDummies[j].GetObj()^.GetGuid());
					m_xDummies[j].GetObj()^.Delete();
				endif;
			endfor;
			/*
			m_xHeck=CObjHndl.Invalid();
			m_xSegel=CObjHndl.Invalid();
			m_xBug=CObjHndl.Invalid();
			m_xKanone=CObjHndl.Invalid();
			*/
			CreateShipCorpse();
		endif;
		super.Die();
	endproc;
	
	export proc ^CGameObj CreateShipCorpse()
		var ^CShipCorpse pxGameObj=cast<CShipCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("ninigi_pirate_ship_dest",GetOwner(),GetPos(),GetRotation()));
		if(pxGameObj!=null)then
			pxGameObj^.Init("ninigi_pirate_ship_dest",m_sSinkAnim,GetName(), 10.0);
			pxGameObj^.SetDestructLevel(2);
		endif;
		return pxGameObj;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(HasTimer(TIMER_LEVELING)&&!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill"))then
			return;
		endif;
		if(HasTimer(TIMER_DEATH)&&!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill")&&!(p_sCommand=="setlevel"||p_sMiscParams.Find("/LevelUp")!=-1))then
			return;
		endif;
		super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
	endproc;
	
//	export proc void SetIced(real p_fDuration,real p_fResistStart)
//		return;
//	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="PiSh"; //Pirate Ship
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,4);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xHeck.DoKArc(pxArc^);
		m_xSegel.DoKArc(pxArc^);
		m_xBug.DoKArc(pxArc^);
		m_xParts.DoKArc(pxArc^);
		m_xDummies.DoKArc(pxArc^);
		m_xKanone.DoKArc(pxArc^);
		pxArc^ << m_bDeadBoat;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="PiSh")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			if(iVersion>=1)then
				m_xHeck.DoKArc(pxArc^);
				m_xSegel.DoKArc(pxArc^);
				m_xBug.DoKArc(pxArc^);
			endif;
			if(iVersion>=2)then
				m_xParts.DoKArc(pxArc^);
				m_xDummies.DoKArc(pxArc^);
			endif;
			if(iVersion>=3)then
				m_xKanone.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void SetOwner(int p_iOwner)
		super.SetOwner(p_iOwner);
		if(m_xHeck.IsValid())then
			m_xHeck.GetObj()^.SetOwner(p_iOwner);
		endif;
		if(m_xSegel.IsValid())then
			m_xSegel.GetObj()^.SetOwner(p_iOwner);
		endif;
		if(m_xBug.IsValid())then
			m_xBug.GetObj()^.SetOwner(p_iOwner);
		endif;
		if(m_xKanone.IsValid())then
			m_xKanone.GetObj()^.SetOwner(p_iOwner);
		endif;
	endproc;
	
	export proc bool AttackEnemy(^CFightingObj p_pxEnemy, vec3 p_vTarget, ref bool p_rbRotated)
		if(m_bDeadBoat)then return false; endif;
		if(p_pxEnemy!=null)then
			if(p_pxEnemy^.IsFlyingUnit() && !CanShootAir())then return false; endif;
		endif;
		var real fAngle=0.0;
		var Quat qRot=GetRot();
		if(p_pxEnemy!=null)then
			qRot=GetAngleToQ(p_pxEnemy);
			fAngle=GetAngleToR(p_pxEnemy);
			if(fAngle>Math.Pi()/4.0)then
				RotateActionSpeed(qRot,0.20);
				return false;
			endif;
		elseif(p_vTarget!={0.0,0.0,0.0})then
			qRot=GetAngleToQ(p_vTarget);
			fAngle=GetAngleToR(p_vTarget);
			if(fAngle>Math.Pi()/4.0)then
				RotateActionSpeed(qRot,0.20);
				return false;
			endif;
		else
			return false;
		endif;
		if(p_pxEnemy!=null)then
			if(GetProjectile()!="")then
				var ^CGameObj pxObj=m_xKanone.GetObj();
				if(pxObj!=null)then
					pxObj^.SetAnim("attack_front",1);
					var int i,iC=15;
					var int iStart=1;
//					if(!m_xHeck.IsValid())then
//						iStart=7;
//					endif;
					var Quat qRot=GetRot();
					for(i=iStart)cond(i<iC)iter(i++)do
						var CFourCC xL="D_"+i.ToReal().ToString("02.0");
						var vec3 vPos;
						pxObj^.GetLinkPosObj(xL, vPos);
						vPos.SetZ(0.0);
						var real fRandom=((Random.GetInt()%1000).ToReal()*0.01)-5.0;
						vPos.SetX(fRandom);
						qRot.VecRotateU(vPos);
						var ^CPirateShipArrow pxArrow=cast<CPirateShipArrow>(CSrvWrap.GetObjMgr()^.CreateObj(GetProjectile(),GetOwner()));
						pxArrow^.SetAttackScape(this, p_pxEnemy^.GetPos()+vPos);
						pxArrow^.SetIndex(i);
					endfor;
				endif;
				return false;
			else
				return super.AttackEnemy(p_pxEnemy, p_vTarget, p_rbRotated);
			endif;
		elseif(p_vTarget!={0.0,0.0,0.0})then
			if(GetProjectile()!="")then
				var ^CGameObj pxObj=m_xKanone.GetObj();
				if(pxObj!=null)then
					pxObj^.SetAnim("attack_front",1);
					var int i,iC=15;
					var int iStart=1;
//					if(!m_xHeck.IsValid())then
//						iStart=7;
//					endif;
					var Quat qRot=GetRot();
					for(i=iStart)cond(i<iC)iter(i++)do
						var CFourCC xL="D_"+i.ToReal().ToString("02.0");
						var vec3 vPos;
						pxObj^.GetLinkPosObj(xL, vPos);
						vPos.SetZ(0.0);
						var real fRandom=((Random.GetInt()%1000).ToReal()*0.01)-5.0;
						vPos.SetX(fRandom);
						qRot.VecRotateU(vPos);
						var ^CPirateShipArrow pxArrow=cast<CPirateShipArrow>(CSrvWrap.GetObjMgr()^.CreateObj(GetProjectile(),GetOwner()));
						pxArrow^.SetAttackScape(this, p_vTarget+vPos);
						pxArrow^.SetIndex(i);
					endfor;
				endif;
				return false;
			else
				return super.AttackEnemy(p_pxEnemy, p_vTarget, p_rbRotated);
			endif;
		endif;
		return true;
	endproc;
	
	export proc CObjHndl GetHeck()
		return m_xHeck;
	endproc;
	
	export proc CObjHndl GetSegel()
		return m_xSegel;
	endproc;
	
	export proc CObjHndl GetBug()
		return m_xBug;
	endproc;
	
	export proc real GetProjectileDelay()
		var real fRandom=((Random.GetInt()%20).ToReal()*0.01)-0.1;
		return super.GetProjectileDelay()+fRandom;
	endproc;
	
	export proc vec3 GetProjectileStartPos()
		return super.GetProjectileStartPos();
	endproc;
	
	export proc vec3 GetProjectileStartPos(int p_iIdx)
		var ^CGameObj pxObj=m_xKanone.GetObj();
		var vec3 vPos=GetPos();
		if(pxObj!=null)then
			var CFourCC xL="D_"+p_iIdx.ToReal().ToString("02.0");
			if(!pxObj^.GetLinkPosWorld(xL, vPos))then
				var vec3 vSize=GetSize();
				vPos=GetPos();
				vPos.SetZ(vPos.GetZ()+vSize.GetZ()*0.7);
			endif;
		endif;
		return vPos;
	endproc;
	/*
	export proc void Damage(real p_fDamage)
		return;
	endproc;
	
	export proc void PoisonDamage(real p_fDamage, CObjHndl p_xEnemy, int p_iEnemy)
		return;
	endproc;
	
	export proc void BurnDamage(real p_fDamage, CObjHndl p_xEnemy, int p_iEnemy)
		return;
	endproc;
	
	export proc void ChainDamage(real p_fDamage, int p_iLast, CObjHndl p_xLast)
		return;
	endproc;
	
	export proc void WoundDamage(real p_fDamage, CObjHndl p_xLE, int p_iLE)
		return;
	endproc;
	*/
	export proc void ReplacePart(string p_sClass, CFourCC p_xLink)
		StopEverything();
		TerminateAction();
		var ^CGameObj pxGameObj=CSrvWrap.GetObjMgr()^.CreateObj(p_sClass, GetOwner());
		pxGameObj^.LinkAction(GetHandle(), p_xLink);
		AddGroupedChildren(pxGameObj^.GetGuid());
		pxGameObj^.SetAnim("destroy",1);
		var real fDuration=(pxGameObj^.GetCurrentAnimLength().ToInt()/1).ToReal();
		if(p_sClass.Find("_row")!=-1)then
			m_xBug=CObjHndl.Invalid();
		elseif(p_sClass.Find("_sail")!=-1)then
			m_xSegel=CObjHndl.Invalid();
		elseif(p_sClass.Find("_tail")!=-1)then
			m_xHeck=CObjHndl.Invalid();
			var ^CGameObj pxKanone=m_xKanone.GetObj();
			if(pxKanone!=null)then
				pxKanone^.Delete();
			endif;
			var ^CGameObj pxCannons=CSrvWrap.GetObjMgr()^.CreateObj("ninigi_pirate_ship_cannons_reduced", GetOwner());
			var CFourCC xLink="psh2";
			pxCannons^.LinkAction(GetHandle(),xLink);
			AddGroupedChildren(pxCannons^.GetGuid());
			pxCannons^.SetHitable(false);
			pxCannons^.SetSelectable(false);
			m_xKanone=pxCannons^.GetHandle();
		endif;
		if(!m_xHeck.IsValid()&&!m_xSegel.IsValid()&&!m_xBug.IsValid())then
			m_bDeadBoat=true;
		endif;
		DeleteTimer(TIMER_DEATH);
		CreateTimer(TIMER_DEATH,CGameTimeSpan.OneSecond()*fDuration,false);
		m_xDummies.Include(pxGameObj^.GetHandle());
	endproc;
	
	export proc void CheckDeath()
		if(HasTimer(TIMER_DEATH))then return; endif;
		if(!m_xHeck.IsValid()&&!m_xSegel.IsValid()&&!m_xBug.IsValid())then
			var int i,iC=m_xDummies.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				if(m_xDummies[i].IsValid())then
					RemGroupedChildren(m_xDummies[i].GetObj()^.GetGuid());
					m_xDummies[i].GetObj()^.Delete();
				endif;
			endfor;
			if(m_xKanone.IsValid())then
				RemGroupedChildren(m_xKanone.GetObj()^.GetGuid());
				m_xKanone.GetObj()^.Delete();
			endif;
			Die();
		endif;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==TIMER_DEATH)then
				DeleteTimer(TIMER_DEATH);
				CheckDeath();
			elseif(p_rxEvtPtr.GetInt(0)==TIMER_LEVELING)then
				DeleteTimer(TIMER_LEVELING);
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
//	export proc void SetAggressionState(int p_iState)
//		super.SetAggressionState(p_iState);
//		var ^CFightingObj pxPart=null;
//		var int i,iC=m_xParts.NumEntries();
//		for(i=0)cond(i<iC)iter(i++)do
//			if(m_xParts[i].IsValid())then
//				pxPart=cast<CFightingObj>(m_xParts[i].GetObj());
//				if(pxPart!=null)then
//					pxPart^.SetAggressionState(p_iState);
//				endif;
//			endif;
//		endfor;
//	endproc;
	
//	export proc void AddKillerCount(int p_iAdd)
//		super.AddKillerCount(p_iAdd);
//		var ^CFightingObj pxPart=null;
//		var int i,iC=m_xParts.NumEntries();
//		for(i=0)cond(i<iC)iter(i++)do
//			if(m_xParts[i].IsValid())then
//				pxPart=cast<CFightingObj>(m_xParts[i].GetObj());
//				if(pxPart!=null)then
//					pxPart^.SetKillerCount(GetKillerCount());
//				endif;
//			endif;
//		endfor;
//	endproc;
	
//	export proc void UpdateWeaponAttribs(real p_fMinRange, real p_fMaxRange, real p_fMeleeDmg, real p_fRangeDmg, real p_fSecondaryDmg, real p_fMeleeDur, real p_fRangeDur, real p_fMeleePiercing, real p_fRangePiercing, int p_iDamageType, int p_iMSlot, int p_iRSlot, string p_sSlot3)
//		super.UpdateWeaponAttribs(p_fMinRange, p_fMaxRange, p_fMeleeDmg, p_fRangeDmg, p_fSecondaryDmg, p_fMeleeDur, p_fRangeDur, p_fMeleePiercing, p_fRangePiercing, p_iDamageType, p_iMSlot, p_iRSlot, p_sSlot3);
//		var ^CFightingObj pxPart=null;
//		var ^CAttribs pxAttr=null;
//		var int i,iC=m_xParts.NumEntries();
//		for(i=0)cond(i<iC)iter(i++)do
//			if(m_xParts[i].IsValid())then
//				pxPart=cast<CFightingObj>(m_xParts[i].GetObj());
//				if(pxPart!=null)then
//					pxPart^.UpdateWeaponAttribs(p_fMinRange, p_fMaxRange, p_fMeleeDmg, p_fRangeDmg, p_fSecondaryDmg, p_fMeleeDur, p_fRangeDur, p_iDamageType, p_iMSlot, p_iRSlot, p_sSlot3);
//				endif;
//			endif;
//		endfor;
//	endproc;
	
	export proc void UpdateWeaponAttribs(real p_fMinRange, real p_fMaxRange, real p_fMeleeDmg, real p_fRangeDmg, real p_fSecondaryDmg, real p_fMeleeDur, real p_fRangeDur, real p_fMeleePiercing, real p_fRangePiercing, int p_iDamageType, int p_iMSlot, int p_iRSlot, string p_sSlot3)
		p_fRangeDmg*=14.0f;
		super.UpdateWeaponAttribs(p_fMinRange, p_fMaxRange, p_fMeleeDmg, p_fRangeDmg, p_fSecondaryDmg, p_fMeleeDur, p_fRangeDur, p_fMeleePiercing, p_fRangePiercing, p_iDamageType, p_iMSlot, p_iRSlot, p_sSlot3);
	endproc;
	
	proc bool UpdateDestructionFlags()
		if(((GetHitpoints()!=0.0f)&&(GetMaxHitpoints()!=0.0f)))then
			var real fPercentage=GetHitpoints()/(GetMaxHitpoints()/100.0f);
			var int i, iC=m_xParts.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				if(m_xParts[i].IsValid())then
					var ^CGameObj pxPart=m_xParts[i].GetObj();
					if(pxPart==null)then continue; endif;
					if(fPercentage>50.0f)then
						pxPart^.SetDestructLevel(0);
					elseif(fPercentage>25.0f)then
						if(pxPart^.GetDestructLevel()!=1)then
							pxPart^.SetDestructLevel(1);
						endif;
					elseif(pxPart^.GetDestructLevel()!=2)then
						pxPart^.SetDestructLevel(2);
					endif;
				endif;
			endfor;
		endif;
		return true;
	endproc;
	
endclass;
	
class CPirateShipBuildUp inherit CFightingObj
	
	var CObjHndl m_xParent;
	var CFourCC m_xLink;
//	var ^CGameObj m_pxTest;
	
	export proc void OnInit(bool p_bLoad)
		SetSwimming(true);
		super.OnInit(p_bLoad);
		SetCanWalk(false);
		SetCanSwim(false);
		SetSelectable(true);
		SetHitable(true);
		m_iSizeClass=10; //ships are big
		if(!p_bLoad)then
			SetType("SHIP");
			InitAttribs();
		endif;
		var ^CAttribs pxAttr=GetAttribs();
		UpdateAttribs(p_bLoad);
		if(GetInventory()==null)then
			InitInventory(1);
		endif;
		SetAnim("standanim", 3);
		OnTechTreeChange();
		if(!p_bLoad)then
			StartTT();
			SetCanFightAttrib(true);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="PiSU"; //Pirate Ship Build Up
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xParent.DoKArc(pxArc^);
		var string sLink=m_xLink.AsString();
		pxArc^ << sLink;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="PiSU")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			if(iVersion>=1)then
				m_xParent.DoKArc(pxArc^);
				var string sLink;
				pxArc^ << sLink;
				m_xLink=sLink;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		LinkAction(m_xParent,m_xLink);
		var ^CGameObj pxParent = m_xParent.GetObj();
		if(pxParent!=null)then
			pxParent^.AddGroupedChildren(GetGuid());
		endif;
	endproc;
	
	export proc void SetParent(CObjHndl p_xParent, string p_sLink)
		m_xParent=p_xParent;
		m_xLink=p_sLink;
		LinkAction(m_xParent,m_xLink);
		var ^CGameObj pxParent = p_xParent.GetObj();
		if(pxParent!=null)then
			pxParent^.AddGroupedChildren(GetGuid());
		endif;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null&&p_xParent.IsValid())then
			pxAttr^.SetValue("parent_guids",p_xParent.GetObj()^.GetGuid().ToString());
		endif;
	endproc;
	
	export proc void DieFastAndSilent()
		if(!IsDead())then
//			m_bBuildingReady=false;
			var ^CGameObj pxParent = m_xParent.GetObj();
			if(pxParent!=null)then
				pxParent^.RemGroupedChildren(GetGuid());
			endif;
			TerminateAction();
			m_fHitpoints=0.0f;
			SetVisible(false);
			SetDead(true);
			Delete();
		endif;
	endproc;
	
	export proc void Die()
		if(!IsDead())then
			var ^CGameObj pxParent = m_xParent.GetObj();
			if(pxParent!=null)then
				pxParent^.RemGroupedChildren(GetGuid());
			endif;
			TerminateAction();
			var ^CPirateShip pxBoss=cast<CPirateShip>(m_xParent.GetObj());
			pxBoss^.ReplacePart(GetClassName()+"_dest",m_xLink);
//			m_bBuildingReady=false;
		endif;
		super.Die();
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		var bool bShip=false;
		var ^CPirateShip pxShip=null;
		if(m_xParent.IsValid())then
			pxShip=cast<CPirateShip>(m_xParent.GetObj());
			if(pxShip!=null)then
				bShip=true;
			endif;
		endif;
		if(GetIncapacitated()&&(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill")&&!(p_sCommand=="Cancel"))then return; endif;
		if(p_sCommand=="Delete")then
			Delete();
		elseif(p_sCommand=="Action")then
			if(p_sMiscParams.Find("/Attack")==-1&&p_sMiscParams.Find("/GoAway")==-1&&p_sMiscParams.Find("/AttackSrv")==-1&&p_sMiscParams.Find("/Walk")==-1 
				&& p_sMiscParams.Find("/Stop")==-1&&p_sMiscParams.Find("/LevelUp")==-1&&p_sMiscParams.Find("/AggressiveTarget")==-1&&p_sMiscParams.Find("/AggroState_")==-1)then
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			else
				if(bShip)then
					pxShip^.ReactToGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams, p_bQ, p_bS, p_bA);
				endif;
			endif;
		elseif(p_sCommand=="setlevel"||p_sCommand=="Attack"||p_sCommand=="Fight")then
			if(bShip)then
				pxShip^.ReactToGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams, p_bQ, p_bS, p_bA);
			endif;
//		elseif(p_sCommand=="BuildUp")then
//			BuildUp(p_sMiscParams);
//		elseif(p_sCommand=="Cancel")then
//			CancelAction(p_sMiscParams);
		else
			return;
			//super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	export proc void Damage(real p_fDamage)
		return;
	endproc;
	
	export proc void PoisonDamage(real p_fDamage, CObjHndl p_xEnemy, int p_iEnemy)
		return;
	endproc;
	
	export proc void BurnDamage(real p_fDamage, CObjHndl p_xEnemy, int p_iEnemy)
		return;
	endproc;
	
	export proc void ChainDamage(real p_fDamage, int p_iLast, CObjHndl p_xLast)
		return;
	endproc;
	
	export proc void WoundDamage(real p_fDamage, CObjHndl p_xLE, int p_iLE)
		return;
	endproc;
	
	proc void UpdateRangeNDamageInformation()
		return;
	endproc;
	
	export proc bool DoesCountInUnitLimit()
		return false;
	endproc;
	
	export proc string GetReportCode()
		return "unit";
	endproc;
	
endclass;
	
class CPirateShipRow inherit CPirateShipBuildUp
endclass;
	
class CPirateShipSail inherit CPirateShipBuildUp
endclass;
	
class CPirateShipTail inherit CPirateShipBuildUp
endclass;
	
class CPirateShipCannons inherit CPirateShipBuildUp
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetSelectable(false);
		SetHitable(false);
	endproc;
	
	export proc string GetReportCode()
		return "";
	endproc;
	
endclass;
	
	//========================================================================================
	//=== Buildings ==========================================================================
	//========================================================================================
	
class CAjeAmazonTemple inherit CTemple
	
	export proc bool CreateBuildingCorpse()
		if(GetGfxName()=="amazon_temple")then
			var ^CAjeAmazonTempleCorpse pxGameObj = cast<CAjeAmazonTempleCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("aje_amazon_temple_corpse",GetOwner(),GetPos(),GetRotation()));
			if(pxGameObj!=null)then
				pxGameObj^.SetSource(this);
				pxGameObj^.Init(GetName(), 3.0);
			endif;
			return true;
		endif;
		return false;
	endproc;
	
	export proc bool ShallBeRevealedAutomaticaly()
		if(GetClassName()=="aje_amazon_temple")then return false; endif;
		return true;
	endproc;
	
	export proc string GetReportCode()
		return "center";
	endproc;
	
endclass;
	
class CAjeFireplace inherit CFireplace
	
	proc void CheckAge()
		var CGameTime xTime=CTimeMgr.Get().GetTime();
		var int iOldAge=GetAge();
		var string sTribe=GetTribeName();
		if(m_xTechTree.GetValueB("/Objects/"+sTribe+"/InventObjects/age_5/invented",false))then
			CSrvWrap.GetGameLogger().Log("Age",GetOwner().ToString(),"5");
		elseif(m_xTechTree.GetValueB("/Objects/"+sTribe+"/InventObjects/age_4/invented",false))then
			CSrvWrap.GetGameLogger().Log("Age",GetOwner().ToString(),"4");
		elseif(m_xTechTree.GetValueB("/Objects/"+sTribe+"/InventObjects/age_3/invented",false))then
			CSrvWrap.GetGameLogger().Log("Age",GetOwner().ToString(),"3");
		elseif(m_xTechTree.GetValueB("/Objects/"+sTribe+"/InventObjects/age_2/invented",false))then
			CSrvWrap.GetGameLogger().Log("Age",GetOwner().ToString(),"2");
		endif;
		var int iMaxAge=GetAge()+1;
		CheckEpoch(iMaxAge);
		var ^CAttribs pxAttribs=GetPlayerAttribs();
		if(pxAttribs!=null&&iOldAge!=GetAge()&&iOldAge<GetAge()&&GetTribeName()==GetPlayerTribeName())then
			pxAttribs^.SetValue("age", GetAge());
		endif;
		return;
	endproc;
	
endclass;
	
class CAjeGalliNest inherit CBuilding
	
	var CObjHndl m_xNest;
	//var CObjHndl m_xSecondNest;
	var CObjHndl m_xDecoNest;
	const real NEST_RADIUS_1 = 70.0f; // the nests territory (Deino)
	const real NEST_RADIUS_2 = 140.0f; // the nests tolerance zone
	const vec3 DECO_OFFSET = {0.0,0.0,-0.1};
	var bool m_bNestGrow;
	const real NEST_GROW = 360.0f; // time which after more animal spawns from the nest
	const int NEW_EGGS = 2; // increasement of max spawned animals from the nest
	
	export constructor()
		m_bNestGrow=false;
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			var CFourCC xLink="Nest";
			var ^CNestBuildUp pxNest=cast<CNestBuildUp>(CSrvWrap.GetObjMgr()^.CreateObj("aje_fake_nest",GetOwner(),GetPos()));
			m_xDecoNest=pxNest^.GetHandle();
			pxNest^.LinkAction(GetHandle(),xLink,DECO_OFFSET);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="DeNe";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,2);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xNest.DoKArc(pxArc^);
		//m_xSecondNest.DoKArc(pxArc^);
		m_xDecoNest.DoKArc(pxArc^);
		(pxArc^) << m_bNestGrow;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="DeNe")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xNest.DoKArc(pxArc^);
			//m_xSecondNest.DoKArc(pxArc^);
			m_xDecoNest.DoKArc(pxArc^);
			if(p_pxReaderNode^.GetVersion()>=2)then
				(pxArc^) << m_bNestGrow;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		if(!m_bNestGrow)then
			if(HasTimer(NEST_GROW_TIMER))then DeleteTimer(NEST_GROW_TIMER); endif;
			CreateTimer(NEST_GROW_TIMER,CGameTimeSpan.OneSecond()*NEST_GROW,false);
		endif;
		if(m_xNest.IsValid())then return; endif;
//		var ^CNest pxNest=cast<CNest>(CSrvWrap.GetObjMgr()^.CreateObj("aje_deino_nest_spawn",GetOwner(),GetPos()+{0.0,0.0,0.0},GetRotation()));
		var ^CNest pxNest=cast<CNest>(CSrvWrap.GetObjMgr()^.CreateObj("aje_galli_nest_spawn",GetOwner(),GetPos()+{0.0,0.0,0.0},GetRotation()));
		if(pxNest!=null)then
			m_xNest=pxNest^.GetHandle();
			AdjustNestAreas(pxNest);
			var CFourCC xT="NOPE";
			pxNest^.LinkAction(GetHandle(), xT);
			pxNest^.SetVisible(false);
		endif;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==NEST_GROW_TIMER)then
				var ^CNest pxN=cast<CNest>(m_xNest.GetObj());
				if(pxN!=null)then
					if(pxN^.ChangeSpawnAmount(NEW_EGGS))then
						m_bNestGrow=true;
					endif;
				else
					DeleteTimer(NEST_GROW_TIMER);
					CreateTimer(NEST_GROW_TIMER,CGameTimeSpan.OneSecond()*NEST_GROW,false);
				endif;
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
/*
	export proc void UpdateGfxFlags()
		if(!m_xSecondNest.IsValid()&&GetClassName()=="aje_deinonychus_nest")then
			var bool bCreateSecNest=CRequirementsMgr.Get().CheckInvention(this, GetOwner(), "aje_nest_upgrade", GetTribeName());
			if(bCreateSecNest)then
				if(m_bBuildingReady)then
					var ^CNest pxSecondNest=cast<CNest>(CSrvWrap.GetObjMgr()^.CreateObj("aje_carcha_nest_spawn",GetOwner(),GetPos(),GetRotation()));
					if(pxSecondNest!=null)then
						m_xSecondNest=pxSecondNest^.GetHandle();
						AdjustSecondNestAreas(pxSecondNest);
						pxSecondNest^.SetVisible(false);
						var CFourCC xT="NOPE";
						pxSecondNest^.LinkAction(GetHandle(), xT);
					endif;
				endif;
			endif;
		endif;
	endproc;
*/
	export proc void OnPostLoad()
		super.OnPostLoad();
		if(!IsBuildMode())then
			SetReady();
		endif;
		var CFourCC xLink="Nest";
		if(m_xDecoNest.IsValid())then
			var ^CGameObj pxO=m_xDecoNest.GetObj();
			if(pxO!=null)then
				pxO^.LinkAction(GetHandle(),xLink,DECO_OFFSET);
			endif;
		endif;
	endproc;
	
	proc void AdjustNestAreas(^CNest p_pxNest)
		//var real fRange=m_xTechTree.GetValueR("MiscValues/Aje/Deinonest_radius",50.0);
		//var vec3 vE; vE.SetXYZ(fRange, fRange, 0.0f);
		var ^CRegion pxRgn=p_pxNest^.GetActionAreaPtr();
		var vec3 vE; vE.SetXYZ(NEST_RADIUS_1, NEST_RADIUS_1, 0.0f);
		if(pxRgn!=null)then
			pxRgn^.Clear();
			pxRgn^.AddSubRegion(010b, GetPos(), vE);
		endif;
		pxRgn=p_pxNest^.GetSafeAreaPtr();
		if(pxRgn!=null)then
			pxRgn^.Clear();
			pxRgn^.AddSubRegion(010b, GetPos(), vE);
		endif;
		vE.SetXYZ(NEST_RADIUS_2, NEST_RADIUS_2, 0.0f);
		pxRgn=p_pxNest^.GetToleranceAreaForced();
		if(pxRgn!=null)then
			pxRgn^.Clear();
			pxRgn^.AddSubRegion(010b, GetPos(), vE);
		endif;
	endproc;
/*
	proc void AdjustSecondNestAreas(^CNest p_pxNest)
		var ^CRegion pxRgn=p_pxNest^.GetActionAreaPtr();
		//var real fRange=m_xTechTree.GetValueR("MiscValues/Aje/Carchanest_radius",50.0);
		//var vec3 vE; vE.SetXYZ(fRange, fRange, 0.0f);
		var vec3 vE; vE.SetXYZ(NEST_RADIUS_1, NEST_RADIUS_2, 0.0f);
		pxRgn^.Clear();
		pxRgn^.AddSubRegion(010b, GetPos(), vE);
		pxRgn=p_pxNest^.GetSafeAreaPtr();
		pxRgn^.Clear();
		pxRgn^.AddSubRegion(010b, GetPos(), vE);
	endproc;
*/
	export proc void Die()
		var ^CNest pxN=cast<CNest>(m_xNest.GetObj());
		//var ^CNest pxSN=cast<CNest>(m_xSecondNest.GetObj());
		if(pxN!=null)then
			pxN^.Die();
		endif;
		//if(pxSN!=null)then
			//pxSN^.Die();
		//endif;
		var ^CGameObj pxNest=m_xDecoNest.GetObj();
		if(pxNest!=null)then
			pxNest^.Delete();
		endif;
		super.Die();
	endproc;
	
	export proc void TieUpAllLooseEnds()
		var ^CGameObj pxNest=m_xDecoNest.GetObj();
		if(pxNest!=null)then
			pxNest^.Delete();
		endif;
		var ^CNest pxN=cast<CNest>(m_xNest.GetObj());
		if(pxN!=null)then
			pxN^.Extermination();
		endif;
	endproc;
	
	export proc string GetReportCode()
		return "defence";
	endproc;
	
endclass;
	
class CAjeSensorTower inherit CTower
	
	var CObjHndl			m_xGuard;
	const vec3				GUARD_OFFSET		= {0.0,0.0,24.88};
	const int				SENSOR_TIMER		= 40048;
	const real				SENSOR_INTERVALL	= 2.0;
	const int				GUARD_TIMER			= 40049;
	var int					m_iRotCounter;
	
	export constructor()
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			m_iRotCounter=0;
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="AjSe"; //Henry: Aje Sensor
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xGuard.DoKArc(pxArc^);
		(pxArc^) << m_iRotCounter;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="AjSe")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xGuard.DoKArc(pxArc^);
			(pxArc^) << m_iRotCounter;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		if(m_bBuildingReady)then
			if(GetClassName()=="aje_sensor_tower")then
				var vec3 vPos=GetPos();
				vPos.SetZ(CSrvWrap.GetScapeMgr().GetHeight(vPos.GetX(),vPos.GetY())-11.0f);
				SetPos(vPos);
			endif;
		endif;
		AddGuard();
		RevealTracesAndTraps();
		GuardAnim();
		DeleteTimer(SENSOR_TIMER);
		CreateTimer(SENSOR_TIMER,CGameTimeSpan.OneSecond()*SENSOR_INTERVALL, true);
	endproc;
	
	export proc void AddGuard()
		if(!m_xGuard.IsValid())then
			var CFourCC xLink="NOPE";
			var ^CMirageDeco pxDeco=cast<CMirageDeco>(CSrvWrap.GetObjMgr()^.CreateObj("aje_guard",GetOwner(),GetPos(),GetRotation()));
			if(pxDeco!=null)then
				m_xGuard=pxDeco^.GetHandle();
				pxDeco^.LinkAction(GetHandle(),xLink,GUARD_OFFSET);
			endif;
		endif;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		var CFourCC xLink="NOPE";
		var ^CGameObj pxO=m_xGuard.GetObj();
		if(pxO!=null)then
			pxO^.LinkAction(GetHandle(),xLink,GUARD_OFFSET);
		endif;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==SENSOR_TIMER)then
				RevealTracesAndTraps();
			elseif(iTimerID==GUARD_TIMER)then
				GuardAnim();
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	export proc void GuardAnim()
		if(!m_xGuard.IsValid())then return; endif;
		var ^CGameObj pxGuard=m_xGuard.GetObj();
		if(pxGuard!=null)then
			DeleteTimer(GUARD_TIMER);
			var int iRand=Random.GetInt()%5;
			switch(iRand)
				case (0)do 		pxGuard^.SetAnim("attention",1);				endcase;
				case (1)do 		pxGuard^.SetAnim("look_arround",1);				endcase;
				case (2)do 		pxGuard^.SetAnim("look_arround_careful",1);		endcase;
				case (3)do 		pxGuard^.SetAnim("standanim",1);				endcase;
				case (4)do 		pxGuard^.SetAnim("standanim",1);				endcase;
				case default do endcase;
			endswitch;
			CreateTimer(GUARD_TIMER,CGameTimeSpan.OneSecond()*pxGuard^.GetCurrentAnimLength(), false);
		endif;
	endproc;
	
	export proc void RevealTracesAndTraps()
		var CObjQuery xSearch;
		xSearch.Clear();
		xSearch.SetType("CHTR");
		xSearch.SetType("ANML",true);
		xSearch.SetType("BLDG",true);
		xSearch.SetType("SHIP",true);
		xSearch.SetType("VHCL",true);
		xSearch.RegionCircle(GetPos(), GetFOWRange());
		CSrvWrap.GetDiplomacyMgr().AddMyEnemiesToSearch(GetOwner(), xSearch, false);
		//CSrvWrap.GetDiplomacyMgr().AddMyFriendsToSearch(GetOwner(), xSearch); //Henry: for testing...
		var CObjList xList;
		if(!xSearch.Execute(xList))then return; endif;
		var int i,iC=xList.NumEntries();
		for (i=0) cond (i<xList.NumEntries()) iter (++i)do
			var ^CFightingObj pxObj=cast<CFightingObj>(xList[i].GetObj());
			if(pxObj==null)then continue; endif;
			if(pxObj^.GetCamouflage()||pxObj^.IsFeignDeath())then
				pxObj^.Reveal();
			endif;
			if(pxObj^.GetEffectFlag(CFightingObj.EFFECT_AJE_CAMOUFLAGE))then
				pxObj^.SetEffectFlag(CFightingObj.EFFECT_AJE_CAMOUFLAGE, false);
			endif;
			var ^CTrap pxTrap=cast<CTrap>(pxObj);
			if(pxTrap!=null)then
				pxTrap^.TrapFound(GetOwner());
				pxTrap^.StartHiddenTimer(20.0f);
			endif;
		endfor;
	endproc;
	
	export proc void Die()
		var ^CGameObj pxGuard=m_xGuard.GetObj();
		if(pxGuard!=null)then
			//var vec3 vPos = pxGuard^.GetPos();
			//vPos.SetXYZ(vPos.GetX()+3.0f, vPos.GetY()+3.0f, CSrvWrap.GetScapeMgr().GetHeight(vPos.GetX(), vPos.GetY()));
			//pxGuard^.FallActionDest(vPos, "jump_of_wall", "getting_up", 0.0);
			pxGuard^.Delete();
		endif;
		super.Die();
	endproc;
	
	export proc string GetReportCode()
		return "defence";
	endproc;
	
endclass;
	
class CAjeSkullController inherit CBuilding
	
	//BadGun Tuning: Skull Protector
	const real	TOTEM_RADIUS=50.0f;
	export const string PROTECT_PATH="/Filters/Aje/Upgrades/aje_skull_protector/reduce_skulls";
	export const string BOOST_PATH="/Filters/Aje/Upgrades/aje_skull_protector/boost_skulls";
	var CObjList m_xSecondaryObjects;
	
	static var array string ms_asTypes;
	
	export constructor()
		if(ms_asTypes.NumEntries()==0)then
			ms_asTypes.AddEntry("CHTR");
			ms_asTypes.AddEntry("ANML");
			ms_asTypes.AddEntry("VHCL");
			ms_asTypes.AddEntry("SHIP");
			ms_asTypes.AddEntry("BLDG");
			ms_asTypes.AddEntry("NEST");
		endif;
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		m_xSink.m_xOnObjAdd=OnObjAdd;
		m_xSink.m_xOnObjRem=OnObjRem;
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="SkPrBo")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var CGuid xG;
			pxArc^<< xG;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		//var real fRange=m_xTechTree.GetValueR("MiscValues/Aje/Skullprotector_range",50.0);
		if(!HasPersonalRegion())then
			//var vec3 vE;vE.SetXYZ(fRange, fRange, 0.0f);
			var vec3 vE;vE.SetXYZ(TOTEM_RADIUS, TOTEM_RADIUS, 0.0f);
			CreatePersonalRegion("SkullProtector_"+GetName()+"_"+Random.GetInt().ToString(), vE, 010b);
		endif;
	endproc;
	
	proc bool OnObjAdd(CObjHndl p_xHndl)
		if(m_bToBeDeleted)then return false; endif;
		var ^CFightingObj pxFO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxFO==null||pxFO^.GetClassName()=="aje_skull_protector")then return false; endif;
		if(ms_asTypes.FindEntry(pxFO^.GetType().AsString())<0)then return false; endif;
		if((GetOwner()==pxFO^.GetOwner()) || (AuraSharing() && CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxFO^.GetOwner(), GetOwner())&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxFO^.GetOwner())))then
			m_xRegionObjects.Include(p_xHndl);
			pxFO^.SetMirageFlag(CFightingObj.MIRAGE_SKULL_PROTECT,true);
		elseif(CSrvWrap.GetDiplomacyMgr().GetIsEnemy(GetOwner(), pxFO^.GetOwner())||CSrvWrap.GetDiplomacyMgr().GetIsEnemy(pxFO^.GetOwner(),GetOwner()))then
			m_xSecondaryObjects.Include(p_xHndl);
			pxFO^.SetMirageFlag(CFightingObj.MIRAGE_SKULL_BOOST,true);
		endif;
		return true;
	endproc;
	
	proc bool OnObjRem(CObjHndl p_xHndl)
		if(m_xRegionObjects.FindEntry(p_xHndl)==-1&&m_xSecondaryObjects.FindEntry(p_xHndl)==-1)then return false; endif;
		var ^CFightingObj pxFO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxFO==null)then return false; endif;
		if(m_xRegionObjects.FindEntry(p_xHndl)!=-1)then
			m_xRegionObjects.RemEntry(p_xHndl);
			pxFO^.SetMirageFlag(CFightingObj.MIRAGE_SKULL_PROTECT,false);
		endif;
		if(m_xSecondaryObjects.FindEntry(p_xHndl)!=-1)then
			m_xSecondaryObjects.RemEntry(p_xHndl);
			pxFO^.SetMirageFlag(CFightingObj.MIRAGE_SKULL_BOOST,false);
		endif;
		return true;
	endproc;
	
	export proc void InitOwnRegion()
		if(!HasPersonalRegion())then
			var vec3 vE;vE.SetXYZ(TOTEM_RADIUS, TOTEM_RADIUS, 0.0f);
			CreatePersonalRegion("SkullProtector_"+GetName()+"_"+Random.GetInt().ToString(), vE, 010b);
		endif;
	endproc;
	
	export proc string GetReportCode()
		return "defence";
	endproc;
	
endclass;
	
class CFault inherit CBuilding
	
	export const real RUMBLE_RADIUS=100.0;
	const real RUMBLE_DAMAGE=75.0;
	const real RUMBLE_FREQUENCY=1.0;
	const real RUMBLE_DURATION=20.0;
	const real RUMBLE_SHAKE=0.1;
	const int EARTHQUAKE_DURATION=40068;
	const int EARTHQUAKE_DAMAGE=40069;
	const int EARTHQUAKE_SHAKE=40070;
	var CObjHndl m_xCaster;
	var int m_iCaster;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xType="Faul";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xCaster.DoKArc(pxArc^);
		(pxArc^) << m_iCaster;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="Faul")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xCaster.DoKArc(pxArc^);
			(pxArc^) << m_iCaster;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void OnInit(bool p_bLoad)
//		SetVisible(false);
		super.OnInit(p_bLoad);
		SetPlaceBlocker(false);
		m_xSink.m_xOnObjAdd=EnterRumbleZone;
		m_xSink.m_xOnObjRem=LeaveRumbleZone;
		if(!p_bLoad)then
			InitEvents();
			SetHitable(false);
			SetSelectable(false);
			SetFOW(0.0);
			//Henry: for leveled placement...
			if(CSrvWrap.GetGame().IsLevelEd())then
				Commence();
			endif;
			if(!HasPersonalRegion())then
				var vec3 vP;
				vP.SetXYZ(RUMBLE_RADIUS,RUMBLE_RADIUS,RUMBLE_RADIUS);
				CreatePersonalRegion("EarthQuakeRegion_"+GetName()+"_"+Random.GetInt().ToString(), vP, 010b);
			endif;
		endif;
	endproc;
	
	export proc void IgniteBuilding(real p_fDmg, int p_iMaxCount, CObjHndl p_xSource, int p_iSource)
		return;
	endproc;
	
	export proc bool CreateBuildingCorpse()
		return true;
	endproc;
	
	export proc void SetCaster(int p_iCaster, CObjHndl p_xCaster)
		m_iCaster=p_iCaster;
		if(p_xCaster.IsValid())then
			var ^CFightingObj pxCaster=cast<CFightingObj>(p_xCaster.GetObj());
			if(pxCaster!=null)then
				m_xCaster=p_xCaster;
			endif;
		endif;
	endproc;
	
	proc bool EnterRumbleZone(CObjHndl p_xObj)
		var ^CFightingObj pxFO=cast<CFightingObj>(p_xObj.GetObj());
		if(pxFO!=null /*&& CSrvWrap.GetDiplomacyMgr().GetIsEnemy(GetOwner(), pxFO^.GetOwner())*/)then
			m_xRegionObjects.Include(p_xObj);
		endif;
		return true;
	endproc;
	
	proc bool LeaveRumbleZone(CObjHndl p_xObj)
		if(m_xRegionObjects.FindEntry(p_xObj)==-1)then return false; endif;
		m_xRegionObjects.RemEntry(p_xObj);
		return true;
	endproc;
	
	export proc void Commence()
		if(HasTimer(EARTHQUAKE_DAMAGE))then DeleteTimer(EARTHQUAKE_DAMAGE); endif;
		if(HasTimer(EARTHQUAKE_DURATION))then DeleteTimer(EARTHQUAKE_DURATION); endif;
		if(HasTimer(EARTHQUAKE_SHAKE))then DeleteTimer(EARTHQUAKE_SHAKE); endif;
		CreateTimer(EARTHQUAKE_DAMAGE, CGameTimeSpan.OneSecond() * RUMBLE_FREQUENCY, true);
		CreateTimer(EARTHQUAKE_SHAKE, CGameTimeSpan.OneSecond() * RUMBLE_SHAKE, true);
		CreateTimer(EARTHQUAKE_DURATION, CGameTimeSpan.OneSecond() * RUMBLE_DURATION, false);
	endproc;
	
	proc void Shake()
		var CObjList xThrow=m_xRegionObjects;
		var array string asTypes;
		asTypes.AddEntry("ANML");
		asTypes.AddEntry("BLDG");
		asTypes.AddEntry("CHTR");
		asTypes.AddEntry("FGHT");
		asTypes.AddEntry("SHIP");
		asTypes.AddEntry("VHCL");
		var int i,iC=m_xRegionObjects.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(m_xRegionObjects[i]==m_xCaster)then
				xThrow.RemEntry(m_xRegionObjects[i]);
				continue;
			endif;
			var ^CFightingObj pxObj=cast<CFightingObj>(m_xRegionObjects[i].GetObj());
			if(pxObj==null)then
				xThrow.RemEntry(m_xRegionObjects[i]);
				continue;
			endif;
			if(pxObj^.GetClassName()=="volcano"||pxObj^.GetClassName()=="fault"||asTypes.FindEntry(pxObj^.GetType().AsString())<0||!pxObj^.IsHitable())then
				xThrow.RemEntry(m_xRegionObjects[i]);
				continue;
			endif;
			//if(!CSrvWrap.GetDiplomacyMgr().GetIsEnemy(m_iCaster, pxObj^.GetOwner()))then continue; endif;
			var CObjHndl xEnemy=CObjHndl.Invalid();
			var int iEnemy=-1;
			//if(m_xCaster.IsValid())then
				//xEnemy=m_xCaster;
				//iEnemy=m_iCaster;
			//endif;
			if(pxObj^.GetType()=="BLDG")then
				pxObj^.TakeDirectMeleeDmg(RUMBLE_DAMAGE, xEnemy);
				pxObj^.SetLastEnemy(xEnemy);
				pxObj^.SetLastDamage(iEnemy);
				xThrow.RemEntry(m_xRegionObjects[i]);
			endif;
		endfor;
		CFightingObj.ShakeZone(GetPos(),xThrow);
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==EARTHQUAKE_SHAKE)then
				InvokeGenericSCEvent(43,2.0);
			elseif(p_rxEvtPtr.GetInt(0)==EARTHQUAKE_DAMAGE)then
				Shake();
			elseif(p_rxEvtPtr.GetInt(0)==EARTHQUAKE_DURATION)then
				if(HasTimer(EARTHQUAKE_DAMAGE))then DeleteTimer(EARTHQUAKE_DAMAGE); endif;
				if(HasTimer(EARTHQUAKE_SHAKE))then DeleteTimer(EARTHQUAKE_SHAKE); endif;
				Delete();
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	export proc void OnKill()
		return;
	endproc;
	
	export proc void Damage(real p_fDamage)
		return;
	endproc;
	
	export proc void PoisonDamage(real p_fDamage, CObjHndl p_xEnemy, int p_iEnemy)
		return;
	endproc;
	
	export proc void BurnDamage(real p_fDamage, CObjHndl p_xEnemy, int p_iEnemy)
		return;
	endproc;
	
	export proc void ChainDamage(real p_fDamage, int p_iLast, CObjHndl p_xLast)
		return;
	endproc;
	
	export proc void WoundDamage(real p_fDamage, CObjHndl p_xLE, int p_iLE)
		return;
	endproc;
	
	export proc bool GetNeutralObject()
		return true;
	endproc;
	
	export proc string GetReportCode()
		return "";
	endproc;
	
endclass;
	
class CGoods inherit CBuilding
	
	const int					GOODS_TIMER=40057;
	const real				FOOD_FROM_DEVITO=0.0;
	const real				WOOD_FROM_DEVITO=25.0;
	const real				STONE_FROM_DEVITO=25.0;
	const real				GOODS_RADIUS=15.0f;
	var array string	m_asValidTargets;
	
	export constructor()
		m_asValidTargets.AddEntry("ANML");
		m_asValidTargets.AddEntry("CHTR");
		m_asValidTargets.AddEntry("SHIP");
		m_asValidTargets.AddEntry("VHCL");
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		m_xSink.m_xOnObjAdd=EnterVaultArea;
		m_xSink.m_xOnObjRem=LeaveVaultArea;
	endproc;
	
	proc bool EnterVaultArea(CObjHndl p_xObj)
		var ^CFightingObj pxFO=cast<CFightingObj>(p_xObj.GetObj());
		if(pxFO!=null)then
			if(m_asValidTargets.FindEntry(pxFO^.GetType().AsString())==-1)then return false; endif;
			if(pxFO^.GetOwner()==-1)then return false; endif;
			var bool bCheck=CheckVaultArea(p_xObj.GetObj()^.GetOwner());
			m_xRegionObjects.Include(p_xObj);
		endif;
		return true;
	endproc;
	
	proc bool LeaveVaultArea(CObjHndl p_xObj)
		if(m_xRegionObjects.FindEntry(p_xObj)==-1)then return false; endif;
		m_xRegionObjects.RemEntry(p_xObj);
		if(p_xObj.IsValid()&&p_xObj.GetObj()!=null)then
			CheckVaultArea(-1);
		endif;
		return true;
	endproc;
	
	proc bool CheckVaultArea(int p_iCandidat)
		if(true)then return true; endif; // Henry: forget about this for now...
		if(p_iCandidat==GetOwner())then return true; endif;
		var int i, iC=m_xRegionObjects.NumEntries();
		var int iNewOwner, iCurOwner=0;
		if(p_iCandidat==-1)then
			var array int aiPlayers;
			aiPlayers=8;
			for(i=0)cond(i<iC)iter(i++)do
				var ^CFightingObj pxObj=cast<CFightingObj>(m_xRegionObjects[i].GetObj());
				if(pxObj==null)then continue; endif;
				if(pxObj^.GetOwner()<0||pxObj^.GetOwner()>7)then continue; endif;
				aiPlayers[pxObj^.GetOwner()]++;
			endfor;
			iNewOwner=GetOwner();
			for(i=0)cond(i<8)iter(i++)do
				if(iNewOwner==i)then continue; endif;
				if(aiPlayers[iNewOwner]<aiPlayers[i])then
					iNewOwner=i;
				endif;
			endfor;
			if(GetOwner()!=iNewOwner)then
				SetOwner(iNewOwner);
			endif;
			return true;
		endif;
		iNewOwner=1;
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFightingObj pxObj=cast<CFightingObj>(m_xRegionObjects[i].GetObj());
			if(pxObj==null)then continue; endif;
			if(pxObj^.GetOwner()<0||pxObj^.GetOwner()>7)then continue; endif;
			if(pxObj^.GetOwner()==GetOwner())then
				iCurOwner++;
			elseif(pxObj^.GetOwner()==p_iCandidat)then
				iNewOwner++;
			endif;
		endfor;
		if(iNewOwner>iCurOwner)then
			SetOwner(iNewOwner);
		endif;
		return true;
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		if(HasTimer(GOODS_TIMER))then DeleteTimer(GOODS_TIMER); endif;
		CreateTimer(GOODS_TIMER, CGameTimeSpan.OneSecond()*5.0,true);
		if(!HasPersonalRegion())then
			var vec3 vE;vE.SetXYZ(GOODS_RADIUS, GOODS_RADIUS, 0.0f);
			CreatePersonalRegion("TraderGoods_"+GetName()+"_"+Random.GetInt().ToString(), vE, 010b);
		endif;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==GOODS_TIMER)then
				var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
				if(pxLevel!=null)then
					var ^CBasePlayer pxPlayer=cast<CBasePlayer>(pxLevel^.GetPlayer(GetOwner()));
					if(pxPlayer!=null)then
						var ^CAttribs pxPlAttr=pxPlayer^.GetAttribs();
						if(pxPlAttr!=null)then
							var ^CLevelInfoHost pxLevelInfo=CSrvWrap.GetLevelInfo(false);
							if(pxLevelInfo!=null)then
								var ^CLevelInfo.CPlayerSlot pxPlSlot=pxLevelInfo^.GetOwnerPlayerSlot(GetOwner());
								if(pxPlSlot!=null)then
									pxPlayer^.AddResource("food",FOOD_FROM_DEVITO,false);
									pxPlayer^.AddResource("wood",WOOD_FROM_DEVITO,false);
									pxPlayer^.AddResource("stone",STONE_FROM_DEVITO,false);
								endif;
							endif;
						endif;
					endif;
				endif;
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
endclass;
	
class CHuBigHorn inherit CBuilding
	
	var CObjHndl			m_xEffect;
	const real				HORN_RADIUS=50.0f;
	const vec3				CRANE_O={5.0,0.0,0.0};
	
	export constructor()
		m_avCranes.AddEntry(CRANE_O);
		m_bCustomConstruction=true;
		m_fStartHeight=6.0;
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
//		m_xSink.m_xOnObjAdd=BlowTheRedHorn;
//		m_xSink.m_xOnObjRem=DiedInHonor;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="HuHo";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xEffect.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="HuHo")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xEffect.DoKArc(pxArc^);
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	proc bool BlowTheRedHorn(CObjHndl p_xObj)
		var ^CCharacter pxChar=cast<CCharacter>(p_xObj.GetObj());
		if(pxChar!=null&&pxChar^.GetClassName()!="aje_poisoner")then
			if(CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxChar^.GetOwner()))then
				pxChar^.SetMirageFlag(CFightingObj.MIRAGE_BIG_HORN,true);
			endif;
		endif;
		return true;
	endproc;
	
	proc bool DiedInHonor(CObjHndl p_xObj)
		var ^CCharacter pxChar=cast<CCharacter>(p_xObj.GetObj());
		if(pxChar!=null&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxChar^.GetOwner()))then
			pxChar^.SetMirageFlag(CFightingObj.MIRAGE_BIG_HORN,false);
		endif;
		return true;
	endproc;
/*
	proc bool BlowTheRedHorn(CObjHndl p_xObj)
		var ^CGate pxGa=cast<CGate>(p_xObj.GetObj());
		if(pxGa!=null&&pxGa^.GetGfxName()!="tutorial_vikingpark_gate")then
			if(CSrvWrap.GetDiplomacyMgr().GetIsEnemy(GetOwner(), pxGa^.GetOwner()))then
				pxGa^.SetMirageFlag(CFightingObj.MIRAGE_BIG_HORN,true);
			endif;
		endif;
		return true;
	endproc;
	
	proc bool DiedInHonor(CObjHndl p_xObj)
		var ^CGate pxGa=cast<CGate>(p_xObj.GetObj());
		if(pxGa!=null&&CSrvWrap.GetDiplomacyMgr().GetIsEnemy(GetOwner(), pxGa^.GetOwner()))then
			pxGa^.SetMirageFlag(CFightingObj.MIRAGE_BIG_HORN,false);
		endif;
		return true;
	endproc;
*/
	export proc void SetReady()
		super.SetReady();
		m_xEffect=AddFX("fx_will_o_wisp_sml",-1.0);
		var CFourCC xLink;
		if(m_xEffect.IsValid())then
			m_xEffect.GetObj()^.LinkAction(GetHandle(),xLink);
		endif;
		//var real fRange=m_xTechTree.GetValueR("MiscValues/Hu/Horn_Radius",50.0);
		if(!HasPersonalRegion())then
			//var vec3 vE;vE.SetXYZ(fRange, fRange, 0.0f);
			var vec3 vE;vE.SetXYZ(HORN_RADIUS, HORN_RADIUS, 0.0f);
			CreatePersonalRegion("BigHorn_"+GetName()+"_"+Random.GetInt().ToString(), vE, 010b);
		endif;
	endproc;
	
	export proc void InitOwnRegion()
		if(!HasPersonalRegion())then
			var vec3 vE;vE.SetXYZ(HORN_RADIUS, HORN_RADIUS, 0.0f);
			CreatePersonalRegion("BigHorn_"+GetName()+"_"+Random.GetInt().ToString(), vE, 010b);
		endif;
	endproc;
	
	export proc string GetReportCode()
		return "defence";
	endproc;
	
endclass;
	
class CHuMine inherit CGrowingField
	
endclass;
	
class CPortalTerminus inherit CBuilding
	
	export const real RELEASE_FREQUENCY=1.0;
	const int TERMINUS_RELEASE=40071;
	var CObjList m_xReleases;
	var CObjList m_xPartners;
	var bool m_bOccupiedATM;
	var vec3 m_vReleasePos1;
	var CObjHndl m_xDestination;
	
	export constructor()
		m_bOccupiedATM=false;
		m_vReleasePos1=GetPos();
	endconstructor;
	
	destructor()
		var int i, iC=m_xPartners.Validate();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CPortalTerminus pxPortal=cast<CPortalTerminus>(m_xPartners[i].GetObj());
			if(pxPortal!=null)then
				pxPortal^.RemovePartner(GetHandle());
			endif;
		endfor;
	enddestructor;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="PoTe")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xReleases.DoKArc(pxArc^);
			m_xPartners.DoKArc(pxArc^);
			var int iOwner;
			pxArc^ << iOwner;
			var int iVersion=p_pxReaderNode^.GetVersion();
			pxArc^ << m_bOccupiedATM;
			m_xDestination.DoKArc(pxArc^);
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="PoTe";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xReleases.DoKArc(pxArc^);
		m_xPartners.DoKArc(pxArc^);
		var int iOwner=GetOwner();
		pxArc^ << iOwner;
		pxArc^ << m_bOccupiedATM;
		m_xDestination.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetRallySite(true);
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==TERMINUS_RELEASE)then
				m_bOccupiedATM=false;
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	export proc bool RegisterPartner(CObjHndl p_xPartner)
		if(!p_xPartner.IsValid())then return false; endif;
		var int iPart=p_xPartner.GetObj()^.GetOwner();
		if(iPart!=GetOwner() && !(CSrvWrap.GetDiplomacyMgr().GetIsFriend(iPart, GetOwner()) && CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), iPart)))then return false; endif;
		m_xPartners.Include(p_xPartner);
		return true;
	endproc;
	
	export proc bool UnregisterPartner(CObjHndl p_xPartner)
		if(!p_xPartner.IsValid())then return false; endif;
		if(m_xPartners.FindEntry(p_xPartner)==-1)then return false; endif;
		m_xPartners.RemEntry(p_xPartner);
		return true;
	endproc;
	
	export proc bool RemovePartner(CObjHndl p_xPartner)
		if(!p_xPartner.IsValid())then return false; endif;
		if(!(m_xDestination==p_xPartner))then return false; endif;
		m_xDestination=CObjHndl.Invalid();
		UpdateDestAttrib(m_xDestination);
		return true;
	endproc;
	
	proc void UpdateDestAttrib(CObjHndl p_xPartner)
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			if(p_xPartner.IsValid())then
				pxAttr^.SetValue("CurDest",p_xPartner.AsInt());
			else
				pxAttr^.SetValue("CurDest",-1);
			endif;
		endif;
	endproc;
	
	export proc bool RegisterPassenger(CObjHndl p_xPassenger)
		if(!p_xPassenger.IsValid()||!m_xDestination.IsValid())then return false; endif;
//		if(m_xDestination.GetObj()^.GetConstructLevel()<4)then return false; endif;
		var int iDest=m_xDestination.GetObj()^.GetOwner();
		if(iDest!=GetOwner() && !(CSrvWrap.GetDiplomacyMgr().GetIsFriend(iDest, GetOwner()) && CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), iDest)))then return false; endif;
		m_xReleases.Include(p_xPassenger);
		return true;
	endproc;
	
	export proc bool UnregisterPassenger(CObjHndl p_xPassenger)
		if(!p_xPassenger.IsValid())then return false; endif;
		if(m_xReleases.FindEntry(p_xPassenger)==-1)then return false; endif;
		m_xReleases.RemEntry(p_xPassenger);
		return true;
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		CalculateReleasePos();
	endproc;
	
	export proc bool IsFree(CObjHndl p_xPassenger, int p_iID, ref bool p_rbBreak, int p_iPass)
		var int iMe=GetOwner();
		if(iMe!=p_iID && !(CSrvWrap.GetDiplomacyMgr().GetIsFriend(p_iID, iMe) && CSrvWrap.GetDiplomacyMgr().GetIsFriend(iMe, p_iID)))then p_rbBreak=true; return false; endif;
		if(!IsReady())then return false; endif;
		var ^CFightingObj pxPass=cast<CFightingObj>(p_xPassenger.GetObj());
		if(pxPass==null)then p_rbBreak=true; return false; endif;
		if(!m_bOccupiedATM)then
			m_bOccupiedATM=true;
			CreateTimer(TERMINUS_RELEASE, CGameTimeSpan.OneSecond() * RELEASE_FREQUENCY, false);
			var vec3 vNew=m_vReleasePos1;
			vNew.SetZ(vNew.GetZ()+pxPass^.GetFlyingHeight());
			pxPass^.SetPos(vNew);
			pxPass^.SetRot(GetRot());
			if(p_iPass==iMe)then
				pxPass^.WalkAction(GetRallyPosSimple(),pxPass^.GetMaxSpeed(),true);
			endif;
			return true;
		endif;
		return false;
	endproc;
	
	export proc bool CanTeleportIt(CObjHndl p_xPassenger, ref bool p_rbBreak, int p_iPass)
		if(m_xReleases.FindEntry(p_xPassenger)==-1)then p_rbBreak=true; return false; endif;
		var int iMe=GetOwner();
		if(iMe!=p_iPass && !(CSrvWrap.GetDiplomacyMgr().GetIsFriend(p_iPass, iMe) && CSrvWrap.GetDiplomacyMgr().GetIsFriend(iMe, p_iPass)))then p_rbBreak=true; return false; endif;
		if(!m_xDestination.IsValid())then p_rbBreak=true; return false; endif;
		var ^CPortalTerminus pxD=cast<CPortalTerminus>(m_xDestination.GetObj());
		if(pxD==null)then p_rbBreak=true; return false; endif;
		return pxD^.IsFree(p_xPassenger, GetOwner(), p_rbBreak, p_iPass);
	endproc;
	
	export proc vec3 GetReleasePos()
		return m_vReleasePos1;
	endproc;
	
	export proc void SetReleasePos(vec3 p_vNew)
		m_vReleasePos1=p_vNew;
	endproc;
	
	export proc void CalculateReleasePos()
		var vec3 vPos=GetPos();
		var CFourCC xLink1="Bl_0", xLink2="Bl_1";
		var vec3 vTmp1, vTmp2, vTmp3;
		GetLinkPosWorld(xLink1,vTmp1);
		GetLinkPosWorld(xLink2,vTmp2);
		var vec3 vDirection=vTmp1 - vTmp2;
		var real fDist=vDirection.Abs();
		var bool bHuModel=GetGfxName()=="hu_warpgate";
		if(bHuModel)then
			fDist*=2.0f; fDist/=5.0f;
		else
			fDist*=0.5f;
		endif;
		vDirection.Normalize();
		vTmp3=vTmp2+vDirection*fDist;
		if(bHuModel)then
			vDirection=vTmp3-vPos;
			fDist=vDirection.Abs();
			fDist*=1.5f;
			vDirection.Normalize();
			vPos=vPos+vDirection*fDist;
		else
			vPos=vTmp3;
		endif;
		vPos.SetZ(CSrvWrap.GetScapeMgr().GetHeight(vPos.GetX(),vPos.GetY()));
		m_vReleasePos1=vPos;
	endproc;
	
	export proc vec3 GetCustomRallyPos()
		return m_vReleasePos1;
	endproc;
	
	export proc void CheckDestination(CObjHndl p_xRally)
		if(p_xRally.IsValid())then
			if(p_xRally==GetHandle())then
				m_xDestination=CObjHndl.Invalid();
				UpdateDestAttrib(m_xDestination);
				return;
			endif;
			var ^CPortalTerminus pxD=cast<CPortalTerminus>(p_xRally.GetObj());
			if(pxD==null)then
				/*m_xDestination=CObjHndl.Invalid();
				UpdateDestAttrib(m_xDestination);*/
				return;
			endif;
			if(pxD^.GetOwner()!=GetOwner() && !(CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxD^.GetOwner(), GetOwner()) && CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxD^.GetOwner())))then
				if(m_xDestination.IsValid()&&p_xRally==m_xDestination)then
					m_xDestination=CObjHndl.Invalid();
					UpdateDestAttrib(m_xDestination);
				endif;
				return;
			endif;
			if(m_xDestination.IsValid())then
				var ^CPortalTerminus pxOld=cast<CPortalTerminus>(m_xDestination.GetObj());
				if(pxOld!=null)then
					pxD^.UnregisterPartner(GetHandle());
				endif;
			endif;
			pxD^.RegisterPartner(GetHandle());
			m_xDestination=pxD^.GetHandle();
			UpdateDestAttrib(m_xDestination);
		else
//			m_xDestination=CObjHndl.Invalid();
//			UpdateDestAttrib(m_xDestination);
		endif;
	endproc;
	
	export proc CObjHndl GetDestinationPos(ref vec3 p_rvPos,ref vec3 p_rvRot)
		if(m_xDestination.IsValid()&&m_xDestination.GetObj()^.GetConstructLevel()>=4)then
			p_rvPos=m_xDestination.GetObj()^.GetPos()+({0.0,1.0,0.0}*m_xDestination.GetObj()^.GetRadius());
			p_rvRot=m_xDestination.GetObj()^.GetRotation();
			return m_xDestination;
		endif;
		return CObjHndl.Invalid();
	endproc;
	
	export proc void UpdateRegion()
		SetDestination(m_xDestination.GetObj());
		var int i, iC=m_xPartners.Validate();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CPortalTerminus pxPortal=cast<CPortalTerminus>(m_xPartners[i].GetObj());
			if(pxPortal!=null)then
				pxPortal^.UpdatePartner(GetHandle());
			endif;
		endfor;
		return;
	endproc;
	
	export proc void UpdatePartner(CObjHndl p_xPartner)
		if(!m_xDestination.IsValid()||!(p_xPartner==m_xDestination))then return; endif;
		SetDestination(p_xPartner.GetObj());
	endproc;
	
	export proc bool IsFunctionable()
		if(!m_xDestination.IsValid())then return false; endif;
		if(m_xDestination.GetObj()^.GetConstructLevel()<4)then return false; endif;
		var int iOwner=m_xDestination.GetObj()^.GetOwner(), iMe=GetOwner();
		if(iOwner!=iMe && !(CSrvWrap.GetDiplomacyMgr().GetIsFriend(iOwner, iMe) && CSrvWrap.GetDiplomacyMgr().GetIsFriend(iMe, iOwner)))then return false; endif;
		return true;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("set_destination")!=-1)then
				SetDestination(p_pxObject);
				return;
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	export proc void SetDestination(^CGameObj p_pxObject)
		if(p_pxObject!=null)then
			if(p_pxObject^.GetHandle()==GetHandle())then
				m_xDestination=CObjHndl.Invalid();
				UpdateDestAttrib(m_xDestination);
				return;
			endif;
			var ^CPortalTerminus pxD=cast<CPortalTerminus>(p_pxObject);
			if(pxD==null)then return; endif;
			if(pxD^.GetOwner()!=GetOwner() && !(CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxD^.GetOwner(), GetOwner()) && CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxD^.GetOwner())))then
				if(m_xDestination.IsValid()&&p_pxObject^.GetHandle()==m_xDestination)then
					m_xDestination=CObjHndl.Invalid();
					UpdateDestAttrib(m_xDestination);
				endif;
				return;
			endif;
			if(m_xDestination.IsValid())then
				var ^CPortalTerminus pxOld=cast<CPortalTerminus>(m_xDestination.GetObj());
				if(pxOld!=null)then
					pxD^.UnregisterPartner(GetHandle());
				endif;
			endif;
			pxD^.RegisterPartner(GetHandle());
			m_xDestination=pxD^.GetHandle();
			UpdateDestAttrib(m_xDestination);
		else
//			m_xDestination=CObjHndl.Invalid();
//			UpdateDestAttrib(m_xDestination);
		endif;
	endproc;
	
endclass;
	
class CSandStorm inherit CBuilding
	
	export const real STORM_DURATION=15.0;
	export const real STORM_RADIUS=20.0;
	const int STORM_BLINDNESS=40063;
	const int STORM_SOUND=40064;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		m_xSink.m_xOnObjAdd=EnterCloud;
		m_xSink.m_xOnObjRem=LeaveCloud;
		if(!p_bLoad)then
			SetReadyManually(true);
			var ^CAttribs pxAttr=GetAttribs();
			if(pxAttr!=null)then
				pxAttr^.SetValue("building_ready",true);
			endif;
			SetConstructLevel(4);
			InitEvents();
			SetHitable(false);
			SetSelectable(false);
			if(!HasPersonalRegion())then
				var vec3 vP;
				vP.SetXYZ(STORM_RADIUS,STORM_RADIUS,STORM_RADIUS);
				CreatePersonalRegion("SandCloud_"+GetName()+"_"+Random.GetInt().ToString(), vP, 010b);
			endif;
			CreateTimer(STORM_BLINDNESS, CGameTimeSpan.OneSecond() * STORM_DURATION, false);
			CreateTimer(STORM_SOUND, CGameTimeSpan.OneSecond() * 6.0f, true);
		endif;
	endproc;
	
	export proc void IgniteBuilding(real p_fDmg, int p_iMaxCount, CObjHndl p_xSource, int p_iSource)
		return;
	endproc;
	
	export proc bool CreateBuildingCorpse()
		return true;
	endproc;
	
	export proc void Damage()
		return;
	endproc;
	
	export proc bool GetNeutralObject()
		return true;
	endproc;
	
	proc bool EnterCloud(CObjHndl p_xObj)
		var ^CFightingObj pxFO=cast<CFightingObj>(p_xObj.GetObj());
//		if(pxFO!=null && (CSrvWrap.GetDiplomacyMgr().GetIsEnemy(GetOwner(), pxFO^.GetOwner()) || GetOwner()==-1))then
		if(pxFO!=null)then
			m_xRegionObjects.Include(p_xObj);
			pxFO^.SetMirageFlag(CFightingObj.MIRAGE_BLINDING_STORM, true);
		endif;
		return true;
	endproc;
	
	proc bool LeaveCloud(CObjHndl p_xObj)
		if(m_xRegionObjects.FindEntry(p_xObj)==-1)then return false; endif;
		m_xRegionObjects.RemEntry(p_xObj);
		var ^CFightingObj pxFO=cast<CFightingObj>(p_xObj.GetObj());
		if(pxFO!=null )then
			pxFO^.SetMirageFlag(CFightingObj.MIRAGE_BLINDING_STORM, false);
		endif;
		return true;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==STORM_BLINDNESS)then
				if(HasTimer(STORM_SOUND))then DeleteTimer(STORM_SOUND); endif;
				Die();
			elseif(p_rxEvtPtr.GetInt(0)==STORM_SOUND)then
				CSoundEvent.PlayAll("FX_CBlinding_Storm",1,GetPos());
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	export proc void InitOwnRegion()
		if(!HasPersonalRegion())then
			var vec3 vP;
			vP.SetXYZ(STORM_RADIUS,STORM_RADIUS,STORM_RADIUS);
			CreatePersonalRegion("SandCloud_"+GetName()+"_"+Random.GetInt().ToString(), vP, 010b);
		endif;
	endproc;
	
	export proc string GetReportCode()
		return "";
	endproc;
	
endclass;
	
class CSandTrap inherit CBuilding
	
	export const string SAND_PATH="/Filters/Aje/Upgrades/xenage/reduce_speed";
	const real SAND_LIFETIME					= 10.0f;		// in seconds
	const real SAND_RADIUS						= 10.0f;		// in meter
	const real SAND_TRAPPED_TIME			= 7.0f;		// in seconds
	const int SAND_LIFE_TIME					= 40176;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		m_bHidden=true;
		m_xSink.m_xOnObjAdd=EnterSand;
		m_xSink.m_xOnObjRem=LeaveSand;
		if(!p_bLoad)then
			InitEvents();
			SetVisible(true);
			SetHitable(false);
			SetSelectable(false);
			AddRangedBuff("owner_less_attack_speed");
			if(!HasPersonalRegion())then
				var vec3 vP;
				vP.SetXYZ(SAND_RADIUS,SAND_RADIUS,SAND_RADIUS);
				CreatePersonalRegion("SandTrap_"+GetName()+"_"+Random.GetInt().ToString(), vP, 010b);
			endif;
			CreateTimer(SAND_LIFE_TIME, CGameTimeSpan.OneSecond() * SAND_LIFETIME, false);
		endif;
	endproc;
	
	export proc void IgniteBuilding(real p_fDmg, int p_iMaxCount, CObjHndl p_xSource, int p_iSource)
		return;
	endproc;
	
	export proc bool CreateBuildingCorpse()
		return true;
	endproc;
	
	export proc void Damage()
		return;
	endproc;
	
	export proc bool GetNeutralObject()
		return true;
	endproc;
	
	proc bool EnterSand(CObjHndl p_xObj)
		var ^CFightingObj pxFO=cast<CFightingObj>(p_xObj.GetObj());
//		if(pxFO!=null && !pxFO^.IsFlyingUnit() && (CSrvWrap.GetDiplomacyMgr().GetIsEnemy(GetOwner(), pxFO^.GetOwner()) || GetOwner()==-1))then
		if(pxFO!=null && !pxFO^.IsFlyingUnit())then
			m_xRegionObjects.Include(p_xObj);
			pxFO^.SetMirageFlag(CFightingObj.MIRAGE_SAND_TRAP, true);
		endif;
		return true;
	endproc;
	
	proc bool LeaveSand(CObjHndl p_xObj)
		if(m_xRegionObjects.FindEntry(p_xObj)==-1)then return false; endif;
		m_xRegionObjects.RemEntry(p_xObj);
		var ^CFightingObj pxFO=cast<CFightingObj>(p_xObj.GetObj());
		if(pxFO!=null )then
			pxFO^.SetMirageFlag(CFightingObj.MIRAGE_SAND_TRAP, false);
		endif;
		return true;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==SAND_LIFE_TIME)then
				Die();
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	export proc void InitOwnRegion()
		if(!HasPersonalRegion())then
			var vec3 vP;
			vP.SetXYZ(SAND_RADIUS,SAND_RADIUS,SAND_RADIUS);
			CreatePersonalRegion("SandTrap_"+GetName()+"_"+Random.GetInt().ToString(), vP, 010b);
		endif;
	endproc;
	
	export proc string GetReportCode()
		return "";
	endproc;
	
endclass;
	
class CSeasFortress inherit CBunker
	
	var CObjHndl m_xEffect;
	var CObjHndl m_xTeslaM;
	
	constructor()
		m_bSkipTowerStuff=true;
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		m_bHealthBuilding=true;
		m_bManaBuilding=false;
		SetRallySite(true);
		m_xFunctionUnits.SetType("CHTR");
		m_xFunctionUnits.SetType("ANML",true);
		m_xFunctionUnits.SetType("VHCL",true);
		if(!p_bLoad)then
			SetTransportClass(1);
		endif;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("max_passengers",m_xTechTree.GetValueI(GetObjPath()+"/max_passengers",0));
		endif;
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="SeOu")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xEffect.DoKArc(pxArc^);
			if(p_pxReaderNode^.GetVersion()>=2)then
				m_xTeslaM.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="SeOu";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,2);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xEffect.DoKArc(pxArc^);
		m_xTeslaM.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		if(m_bBuildingReady)then
			//HACK Henry: for it to be higher
			if(GetClassName()=="seas_fortress")then
				var vec3 vPos=GetPos();
				vPos.SetZ(CSrvWrap.GetScapeMgr().GetHeight(vPos.GetX(),vPos.GetY())+3.99f);
				SetPos(vPos);
			endif;
		endif;
		if(!m_xEffect.IsValid())then
			m_xEffect=AddFX("fx_heal_area",-1.0);
			AddRangedBuff("owner_healing_temple");
		endif;
		var CFourCC xLink;
		if(m_xEffect.IsValid())then
			m_xEffect.GetObj()^.LinkAction(GetHandle(),xLink);
		endif;
		var ^CVirtualProduceUnit pxUnit=cast<CVirtualProduceUnit>(m_xReactor.GetObj());
		if(pxUnit!=null)then
			pxUnit^.SetReady();
		endif;
		pxUnit=cast<CVirtualProduceUnit>(m_xProduceUnit.GetObj());
		if(pxUnit!=null)then
			pxUnit^.SetReady();
		endif;
	endproc;
	
	export proc void SetTurret(string p_sObjName)
		if(m_xTurret.IsValid())then
			m_xTurret.GetObj()^.Delete();
		endif;
		if(p_sObjName.IsEmpty())then return; endif;
		var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj(p_sObjName, GetOwner());
		if(pxO==null)then return();endif;
		pxO^.LinkAction(GetHandle(), m_xTurretLink, {0.0,0.0,1.1});
		m_xTurret=pxO^.GetHandle();
		AddGroupedChildren(pxO^.GetGuid());
		var ^CAttribs pxA=pxO^.GetAttribs();
		if(pxA!=null)then
			pxA^.SetValue("maxhitpoints", GetAttribs()^.GetValueFloat("maxhitpoints"));
			pxA^.SetValue("hitpoints", GetAttribs()^.GetValueFloat("hitpoints"));
		endif;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		var ^CGameObj pxO=m_xTurret.GetObj();
		if(pxO!=null)then
			pxO^.LinkAction(GetHandle(), m_xTurretLink, {0.0,0.0,1.1});
		endif;
	endproc;
	
	export proc bool AttackEnemy(^CFightingObj p_pxEnemy, vec3 p_vTarget, ref bool p_rbRotated)
		if(IsBuildMode())then return false; endif;
		if(m_xChars.NumEntries() <= 0)then return false; endif;
		if(GetIncapacitated())then return false; endif;
		if(p_pxEnemy!=null)then
			if(p_pxEnemy^.IsFlyingUnit() && !CanShootAir())then return false; endif;
		endif;
		if(GetProjectile()!="")then
			if(m_xTurret.IsValid())then
				var ^CGameObj pxWO=m_xTurret.GetObj();
				var vec3 vCurDir={0.0,1.0,0.0};
				pxWO^.GetRot().VecRotateU(vCurDir);
				var vec3 vCur=vCurDir;
				pxWO^.GetAdditionalRot().VecRotateU(vCur);
				var vec3 vAEDir;
				if(p_pxEnemy!=null)then
					vAEDir=(p_pxEnemy^.GetPos() - GetPos());
				else
					vAEDir=(p_vTarget - GetPos());
				endif;
				var Quat qOld; qOld.FromXYDir(vCur.GetX(), vCur.GetY());
				var Quat qR; qR.FromXYDir(vAEDir.GetX(), vAEDir.GetY());
				var real fD=(qR - qOld).Abs();//(vAEDir-vCur).Abs();
				if(pxWO^.GetSecActionDesc()=="CAct"&&(fD > 0.0001f||fD<-0.0001f))then
					qR /= pxWO^.GetRot();
					pxWO^.SecRotAction(qR, 0.8f);
					p_rbRotated=true;
					ResetHitDone();
					return false;
				endif;
			endif;
			CreateProjectileAndShoot(p_pxEnemy, p_vTarget);
			if(GetFightAnim()!=""&&HasAnim(GetFightAnim()))then
				SetAnim(GetFightAnim(),1);
			endif;
			if(!m_sTurretAttackAnim.IsEmpty()&&m_xTurret.IsValid())then
				m_xTurret.GetObj()^.SetAnim(m_sTurretAttackAnim, 1);
			endif;
			return false;
		endif;
		return false;
	endproc;
	
	export proc void UpdateGfxFlags()
		if(GetClassName()=="seas_fortress")then
			if(!m_xReactor.IsValid() && m_xTechTree.GetValueB("/Objects/SEAS/InventObjects/"+GetClassName()+"_reactor/invented",false))then
				if(!m_xProduceUnit.IsValid())then
					CreatePersonalProduceUnit(m_bBuildingReady);
				endif;
				CreateReactor(m_bBuildingReady);
			endif;
			if(!m_xTurret.IsValid() && m_xTechTree.GetValueB("/Objects/SEAS/InventObjects/planetary_upgrade/invented",false))then
				m_xTurretLink="we";
				if(m_bBuildingReady)then
					SetTurret("seas_carrier_turret");
				endif;
				var ^CAttribs pxAttr=GetAttribs();
				if(pxAttr!=null)then
					pxAttr^.SetValue("max_passengers",m_xTechTree.GetValueI(GetObjPath()+"/max_passengers",10));
				endif;
			endif;
		endif;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		var ^CVirtualProduceUnit pxReactor=cast<CVirtualProduceUnit>(GetReactor().GetObj());
		if(pxReactor==null)then
			return super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("/Build/CHTR/seas")!=-1/*||p_sMiscParams.Find("/Upgrades/seas")!=-1*/)then
				if(p_bS)then
					pxReactor^.ActionReactored(p_sMiscParams);
					ActionVPU(p_sMiscParams);
				elseif(GetPQENO() >= GetPQENR() && pxReactor^.IsReady())then
					pxReactor^.ActionReactored(p_sMiscParams);
				else
					ActionVPU(p_sMiscParams);
				endif;
			elseif(p_sMiscParams.Find("/Upgrades/seas")!=-1)then
				ActionVPU(p_sMiscParams);
			else
				super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
			endif;
		elseif(p_sCommand=="Cancel")then
			CancelAction(p_sMiscParams, p_bS);
//			return;
		else
			super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
		endif;
	endproc;
	
	export proc bool StornoLast()
		var ^CVirtualProduceUnit pxReactor=null;
		if(m_xReactor.IsValid())then
			pxReactor=cast<CVirtualProduceUnit>(m_xReactor.GetObj());
		endif;
		if(GetPQENR() > GetPQENO())then
			if(pxReactor==null||!pxReactor^.StornoLast())then
				return super.StornoLast();
			else
				return true;
		endif;
		else
			return super.StornoLast();
		endif;
	endproc;
	
	export proc void ActionVPU(string p_sTTPath)
		var ^CVirtualProduceUnit pxProduceUnit=cast<CVirtualProduceUnit>(GetProduceUnit().GetObj());
		if(pxProduceUnit==null)then
			super.Action(p_sTTPath);
		else
			pxProduceUnit^.Action(p_sTTPath);
		endif;
	endproc;
	
	export proc void CancelAction(string p_sTTPath)
		if(m_xReactor.IsValid())then
			var ^CVirtualProduceUnit pxProduceUnit=cast<CVirtualProduceUnit>(GetProduceUnit().GetObj());
			if(pxProduceUnit==null||!pxProduceUnit^.HasCanceledAction(p_sTTPath))then
				if(m_pxTaskMgr!=null)then
					m_pxTaskMgr^.RemoveAction(p_sTTPath);
				endif;
			endif;
			return;
		else
			return super.CancelAction(p_sTTPath);
		endif;
	endproc;
	
	export proc void CancelAction(string p_sTTPath, bool p_bShift)
		var ^CVirtualProduceUnit pxReactor=null;
//		var bool bRCA=false;
		if(m_xReactor.IsValid())then
			pxReactor=cast<CVirtualProduceUnit>(m_xReactor.GetObj());
			if(pxReactor!=null)then
				if(p_bShift)then
					pxReactor^.CancelAction(p_sTTPath);
					CancelAction(p_sTTPath);
					return;
				elseif(GetPQENR() > GetPQENO())then
					if(pxReactor^.HasCanceledAction(p_sTTPath))then
						return;
					endif;
				endif;
			endif;
		endif;
		if(!HasCanceledAction(p_sTTPath) && pxReactor!=null)then
			pxReactor^.CancelAction(p_sTTPath);
		endif;
	endproc;
	
	export proc void CheckTeslaMachine(CObjHndl p_xRally)
		var string sClass=GetClassName();
		if(sClass!="seas_fortress")then m_xTeslaM=CObjHndl.Invalid(); return; endif;
		if(p_xRally.IsValid())then
			var ^CTeslaMachine pxM=cast<CTeslaMachine>(p_xRally.GetObj());
			if(pxM==null)then m_xTeslaM=CObjHndl.Invalid(); return; endif;
//			if(pxM^.GetOwner()!=GetOwner()/*||!pxM^.IsReady()*/)then m_xTeslaM=CObjHndl.Invalid(); return; endif;
			if(!CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxM^.GetOwner(), GetOwner())||!CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxM^.GetOwner())||!pxM^.IsReady())then m_xTeslaM=CObjHndl.Invalid(); return; endif;
			m_xTeslaM=pxM^.GetHandle();
		else
			m_xTeslaM=CObjHndl.Invalid();
		endif;
	endproc;
	
	export proc CObjHndl GetSpawnPos(ref vec3 p_rvPos,ref vec3 p_rvRot)
		if(m_xTeslaM.IsValid()&&m_xTeslaM.GetObj()^.GetConstructLevel()>=4)then
			p_rvPos=m_xTeslaM.GetObj()^.GetPos()+({0.0,1.0,0.0}*m_xTeslaM.GetObj()^.GetRadius());
			p_rvRot=m_xTeslaM.GetObj()^.GetRotation();
			return m_xTeslaM;
		endif;
		return CObjHndl.Invalid();
	endproc;
	
endclass;
	
class CSeasGreatCannon inherit CTower
	
	const real INTERNAL_DAMAGE=300.0f; //selfdamage by attacking enemies. ex: 350
	var CObjHndl m_xBirdie;
	
	export proc void OnInit(bool p_bLoad)
		SetTurretLink("we");
		super.OnInit(p_bLoad);
		//	modified by ParaworldFan
		if(!p_bLoad)then
			SetTurret("seas_great_cannon_rotator");
			m_sTurretAttackAnim="attack_front";
//			var string sPlayerName="";
//			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
//			if(pxLevel!=null)then
//				var ^CPlayer pxPlayer=pxLevel^.GetPlayer(GetOwner());
//				if(pxPlayer!=null)then
//					sPlayerName=pxLevel^.GetLevelInfo().GetPlayerSlot(pxPlayer^.GetPlayerSlotID()).GetName();
//					CFeedback.Print(CFeedback.ALL, CFeedback.ATTACK, "_MIRAGE_NT_CannonStarted\t"+sPlayerName);
//				endif;
//			endif;
		endif;
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		// added by ParaworldFan
		if(m_bBuildingReady)then	//PwFan
			var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("seas_great_cannon_cannon", GetOwner());	//PwFan
			AddGroupedChildren(pxO^.GetGuid());	//PwFan
			var CFourCC xLink="we";	//PwFan
			pxO^.LinkAction(m_xTurret,xLink);	//PwFan
			m_xBirdie=pxO^.GetHandle();	//PwFan
		endif;	//PwFan
//		var string sPlayerName="";
//		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
//		if(pxLevel!=null)then
//			var ^CPlayer pxPlayer=pxLevel^.GetPlayer(GetOwner());
//			if(pxPlayer!=null)then
//				sPlayerName=pxLevel^.GetLevelInfo().GetPlayerSlot(pxPlayer^.GetPlayerSlotID()).GetName();
//				CFeedback.Print(CFeedback.ALL, CFeedback.ATTACK, "_MIRAGE_NT_CannonFinished\t"+sPlayerName);
//			endif;
//		endif;
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="SeGr")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xBirdie.DoKArc(pxArc^);
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="SeGr";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xBirdie.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;
	
	export proc bool CreateBuildingCorpse()
		var Quat qRot, qAdditionalRot;
		var ^CBuildingCorpse pxGameObj=cast<CBuildingCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("BuildingCorpse",GetOwner(),GetPos(),GetRotation()));
		if(pxGameObj!=null)then
			pxGameObj^.SetSource(m_xTurret.GetObj());
			pxGameObj^.Init("seas_hq_big_cannon_rotator", GetName(), 10.0, GetAge());
			if(m_xTurret.IsValid())then
				qRot=m_xTurret.GetObj()^.GetRot();
				qAdditionalRot=m_xTurret.GetObj()^.GetAdditionalRot();
				pxGameObj^.SetRot(m_xTurret.GetObj()^.GetRot());
				pxGameObj^.SecRotAction(m_xTurret.GetObj()^.GetAdditionalRot(),0.00001);
				m_xTurret.GetObj()^.Delete();
			endif;
		endif;
		pxGameObj=cast<CBuildingCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("BuildingCorpse",GetOwner(),GetPos(),GetRotation()));
		if(pxGameObj!=null)then
			pxGameObj^.SetSource(this);
			pxGameObj^.Init("seas_hq_big_cannon", GetName(), 10.0, GetAge());
		endif;
		return true;
	endproc;
	
	export proc void Delete()
		if(m_xBirdie.IsValid())then m_xBirdie.GetObj()^.Delete(); endif;
		super.Delete();
	endproc;
	
	export proc bool AttackEnemy(^CFightingObj p_pxEnemy, vec3 p_vTarget, ref bool p_rbRotated)
//		if(GetHitpoints()<=INTERNAL_DAMAGE+50.0||(IsBurning()&&GetHitpoints()<=INTERNAL_DAMAGE*1.5))then
//			CFeedback.Print(GetOwner(), CFeedback.ATTACK, "_MIRAGE_NT_CannonOffline");
//			return false;
//		endif;
		var bool bReturned=super.AttackEnemy(p_pxEnemy,p_vTarget,p_rbRotated);
		var ^CGameObj pxBuildUp=m_xBirdie.GetObj();
		if(pxBuildUp!=null&&!p_rbRotated)then
			pxBuildUp^.SetAnim("attack_front",1);
		endif;
		return bReturned;
	endproc;
	
	//ParaworldFan: template for cannon exception for attacking the Wild agressive animals automatically
//	export proc void AttackSrv(^CGameObj p_pxEnemy)
//		return;
//	endproc;
	
	export proc ^CArrow CreateProjectileAndShoot(^CFightingObj p_pxEnemy, vec3 p_vPos)
		return super.CreateProjectileAndShoot(p_pxEnemy, p_vPos);
	endproc;
	
	export proc ^CArrow CreateProjectileAndShoot(^CFightingObj p_pxEnemy, vec3 p_vPos, string p_sProjectileType)
		var ^CArrow pxArrow=super.CreateProjectileAndShoot(p_pxEnemy, p_vPos, p_sProjectileType);
//		if(pxArrow!=null)then
//			var string sPlayerName="Unknown opponent";
//			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
//			if(pxLevel!=null)then
//				var ^CPlayer pxPlayer=pxLevel^.GetPlayer(GetOwner());
//				if(pxPlayer!=null)then
//					sPlayerName=pxLevel^.GetLevelInfo().GetPlayerSlot(pxPlayer^.GetPlayerSlotID()).GetName();
//				endif;
//				var int i=0;
//				for(i=0)cond(i<CGameBase.GetMaxPlayers())iter(i++)do
//					var ^CPlayer pxPlayer=pxLevel^.GetPlayer(i);
//					if(pxPlayer==null)then continue; endif;
//					if(cast<CAiPlayer>(pxPlayer)!=null)then continue; endif;
//					if(CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), i))then continue; endif;
//					CSrvWrap.SendGenericEvtToPlayer(i, "MiniMapAttack\t"+p_vPos.ToString()+"\tCannon");
//					CFeedback.Print(i, CFeedback.ATTACK, "_MIRAGE_NT_CannonAttack\t"+sPlayerName);
//				endfor;
//			endif;
//		endif;
		return pxArrow;
	endproc;
	
	export proc void Die()
//		var string sPlayerName="";
//		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
//		if(pxLevel!=null)then
//			var ^CPlayer pxPlayer=pxLevel^.GetPlayer(GetOwner());
//			if(pxPlayer!=null)then
//				sPlayerName=pxLevel^.GetLevelInfo().GetPlayerSlot(pxPlayer^.GetPlayerSlotID()).GetName();
//				CFeedback.Print(CFeedback.ALL, CFeedback.ATTACK, "_MIRAGE_NT_CannonDestroyed\t"+sPlayerName);
//			endif;
//		endif;
		super.Die();
	endproc;
	
	export proc void ThrowBack()
//		CFeedback.Print(GetOwner(), CFeedback.ATTACK, "_MIRAGE_NT_CannonDamage");
////		AddHitpoints(-350.0f);
//		var real fMaxDmg=Math.Min((GetHitpoints()+5.0),INTERNAL_DAMAGE);
//		fMaxDmg*=-1.0;
//		AddHitpoints(fMaxDmg);
	endproc;
	
endclass;
	
class CSeasMgNest inherit CTower
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
		endif;
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		if(m_bBuildingReady)then
			SetTurretLink("we");
			SetTurret("seas_hq_machinegun_nest_top");
			m_sTurretAttackAnim="attack_front";
		endif;
	endproc;
	
endclass;
	
class CSeasMine inherit CGrowingField
	
	var bool					m_bEquipped;
	var CObjList			m_xAddons;
	var array vec3		m_avAddonOffsets;
	
	constructor()
		m_bEquipped=false;
	endconstructor;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="SeMi")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			if(iVersion>=1)then
				(pxArc^) << m_bEquipped;
				var int i,iC;
				(pxArc^) << iC;
				m_avAddonOffsets=iC;
				for(i=0) cond(i<iC) iter(i++)do
					(pxArc^) << m_avAddonOffsets[i];
				endfor;
				m_xAddons.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="SeMi";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		(pxArc^) << m_bEquipped;
		var int i,iC=m_avAddonOffsets.NumEntries();
		(pxArc^) << iC;
		for(i=0) cond(i<iC) iter(i++)do
			(pxArc^) << m_avAddonOffsets[i];
		endfor;
		m_xAddons.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;
	
//	export proc void OnInit(bool p_bLoad)
//		super.OnInit(p_bLoad);
//		if(!p_bLoad)then
//			BuildAddons();
//		endif;
//	endproc;
	
	export proc void SetReady()
		super.SetReady();
		if(m_bBuildingReady)then
			BuildAddons();
		endif;
	endproc;
	
	proc void BuildAddons()
		if(!m_bEquipped)then
			m_bEquipped=true;
			var CFourCC xLink="NOPE";
			var ^CMirageDeco pxA;
			m_avAddonOffsets.AddEntry({1.82,6.54,0.0});
			m_avAddonOffsets.AddEntry({-1.75,4.54,3.01});
			m_avAddonOffsets.AddEntry({-4.89,-0.41,-3.07});
			m_avAddonOffsets.AddEntry({-1.43,0.39,6.39});
			m_avAddonOffsets.AddEntry({6.94,-0.02,0.0});
			m_avAddonOffsets.AddEntry({1.63,-6.16,0.0});
			var int i, iC=m_avAddonOffsets.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				pxA=cast<CMirageDeco>(CSrvWrap.GetObjMgr()^.CreateObj("seas_mine_misc_"+i.ToString(),GetOwner(),GetPos()));
				if(pxA!=null)then
					m_xAddons.AddEntry(pxA^.GetHandle());
					AddGroupedChildren(pxA^.GetGuid());
					pxA^.LinkAction(GetHandle(),xLink,m_avAddonOffsets[i]);
				endif;
			endfor;
		endif;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		var CFourCC xLink="NOPE";
		var int i, iC=m_xAddons.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CGameObj pxA=m_xAddons[i].GetObj();
			if(pxA!=null)then
				pxA^.LinkAction(GetHandle(),xLink,m_avAddonOffsets[i]);
			endif;
		endfor;
	endproc;
	
	export proc void TransferLinkedObjs(CObjHndl p_xC)
		if(!p_xC.IsValid())then return; endif;
		var CFourCC xLink="NOPE";
		while(m_xAddons.NumEntries()>0)do
			var ^CGameObj pxA = m_xAddons[0].GetObj();
			if(pxA==null)then
				m_xAddons.DeleteEntry(0);
				m_avAddonOffsets.DeleteEntry(0);
				continue;
			endif;
			RemGroupedChildren(pxA^.GetGuid());
			pxA^.TerminateAction();
			pxA^.LinkAction(p_xC,xLink,m_avAddonOffsets[0]);
			m_xAddons.DeleteEntry(0);
			m_avAddonOffsets.DeleteEntry(0);
		endwhile;
		m_xAddons.Clear();
	endproc;
	
	export proc CObjList GetAddons();
		return m_xAddons;
	endproc;
	
endclass;
	
class CSeasPortalTerminus inherit CPortalTerminus
	/*
	var CObjList			m_xAddons;
	var array vec3		m_avAddonOffsets;
	
	const vec3				FRONT_OFFSET			= {0.0,12.0,-5.0};
	const vec3				WALL_O_OFFSET			= {11.53,1.1,0.0};
	const vec3				WALL_T_OFFSET			= {-11.53,1.1,0.0};
	
	export constructor()
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			AddDecoration();
		endif;
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="SeWa")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			if(iVersion>=1)then
				m_xAddons.DoKArc(pxArc^);
				var int i,iC;
				(pxArc^) << iC;
				m_avAddonOffsets=iC;
				for(i=0) cond(i<iC) iter(i++)do
					(pxArc^) << m_avAddonOffsets[i];
				endfor;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="SeWa";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xAddons.DoKArc(pxArc^);
		var int i,iC=m_avAddonOffsets.NumEntries();
		(pxArc^) << iC;
		for(i=0) cond(i<iC) iter(i++)do
			(pxArc^) << m_avAddonOffsets[i];
		endfor;
		pxWalk^.Close();
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		if(m_bBuildingReady)then
//			CalcRelPos(pxAddon);
//			AddDecoration();
		endif;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		var CFourCC xLink="NOPE";
		var int i, iC=m_xAddons.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CGameObj pxA=m_xAddons[i].GetObj();
			if(pxA!=null)then
				pxA^.LinkAction(GetHandle(),xLink,m_avAddonOffsets[i]);
			endif;
		endfor;
	endproc;
	
	export proc void Die()
		var int i, iC=m_xAddons.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CGameObj pxB=m_xAddons[i].GetObj();
			if(pxB!=null)then
				pxB^.Delete();
			endif;
		endfor;
		super.Die();
	endproc;
	
	export proc void CalculateReleasePos()
		return;
	endproc;
	
	export proc void AddDecoration()
		var CFourCC xLink="NONE", xTmp="Cr_1";
		var vec3 vPos=GetPos();
		var vec3 vTmp;
		GetLinkPosWorld(xTmp,vTmp);
		vTmp.SetZ(vPos.GetZ());
		CMirageSrvMgr.Debug("vPos: '"+(vPos).ToString()+"'");
		CMirageSrvMgr.Debug("vTmp: '"+(vTmp).ToString()+"'");
		var string sName="seas_warp_misc_one";
		var vec3 vOffset;
		var real fRot=Math.Pihalf();
		var ^CPropDB.CNode pxCustom;
		var ^CPropDB pxSource=new CPropDB;
		if(pxSource^.Load("C:/source.txt"))then
			pxCustom=^((pxSource^).GetRoot());
			vOffset.SetXYZ(pxCustom^.GetValueR("x",0.0),pxCustom^.GetValueR("y",0.0),pxCustom^.GetValueR("z",0.0));
			fRot=pxCustom^.GetValueR("rot",fRot);
			sName=pxCustom^.GetValueS("name",sName);
		endif;
		var ^CMirageDeco pxAddon=cast<CMirageDeco>(CSrvWrap.GetObjMgr()^.CreateObj(sName,GetOwner(),GetPos(),GetRotation()));
		if(pxAddon!=null)then
			m_xAddons.AddEntry(pxAddon^.GetHandle());
			AddGroupedChildren(pxAddon^.GetGuid());
			pxAddon^.LinkAction(GetHandle(),xLink,FRONT_OFFSET);
			m_avAddonOffsets.AddEntry(FRONT_OFFSET);
			pxAddon^.LinkAction(GetHandle(),xLink,vOffset);
			m_avAddonOffsets.AddEntry(vOffset);
			var vec3 vDir=vTmp-vPos;
			CMirageSrvMgr.Debug("vDir: '"+(vDir).ToString()+"'");
			var Quat qRot = pxAddon^.GetAdditionalRot();
			var vec3 vSelfDirection = {0.0f, 1.0f, 0.0};
			pxAddon^.GetRot().VecRotateU(vSelfDirection);
			qRot.VecRotateU(vSelfDirection);
			vSelfDirection.SetZ(0.0f);
			vSelfDirection.Normalize();
			var Quat qR;
			qRot.FromXYDir(vSelfDirection.GetX(), vSelfDirection.GetY());
			CMirageSrvMgr.Debug("fRot: '"+(fRot).ToString()+"'");
			CMirageSrvMgr.Debug("qRot: '"+(qRot).ToString()+"'");
			CMirageSrvMgr.Debug("qR: '"+(qRot).ToString()+"'");
			qR.FromXYDir(vDir.GetX(),vDir.GetY());
			CMirageSrvMgr.Debug("qR 2: '"+(qRot).ToString()+"'");
			qR /= pxAddon^.GetRot();
			qRot.RotateZ(fRot);
			qR.RotateZ(fRot);
			CMirageSrvMgr.Debug("qRot 2: '"+(qRot).ToString()+"'");
			CMirageSrvMgr.Debug("qR 3: '"+(qRot).ToString()+"'");
			pxAddon^.SetAdditionalRot(qRot);
			CMirageSrvMgr.Debug("");
		endif;
		return;
	endproc;
	*/
endclass;
	
class CSeasPsiDisruptor inherit CBuilding
	
	//BadGun Tuning: Psi Disruptor
	const real DISRUPT_RADIUS=40.0f;
	export const string DISRUPT_PATH="/Filters/SEAS/Upgrades/seas_disruptor/reduce_speed";
	static var array string ms_asTypes;
	
	export constructor()
		if(ms_asTypes.NumEntries()==0)then
			ms_asTypes.AddEntry("CHTR");
			ms_asTypes.AddEntry("ANML");
			ms_asTypes.AddEntry("VHCL");
			ms_asTypes.AddEntry("SHIP");
		endif;
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			AddRangedBuff("owner_less_attack_speed");
			SetAnim("open",0,0);
		endif;
		m_xSink.m_xOnObjAdd=OnObjAdd;
		m_xSink.m_xOnObjRem=OnObjRem;
	endproc;
	
//	export proc void Load(^CUOFReaderNode p_pxReaderNode)
//		if(p_pxReaderNode^.GetType()=="SePsDis")then
//			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
//			var CGuid xG;
//			pxArc^<< xG;
//		else
//			super.Load(p_pxReaderNode);
//		endif;
//	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		if(!m_bBuildingReady)then
			SetAnim("open",0,0);
		endif;
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		SetAnim("open",1);
		//var real fRange=m_xTechTree.GetValueR("MiscValues/SEAS/Disruptor_radius",40.0);
		if(!HasPersonalRegion())then
			//var vec3 vE;vE.SetXYZ(fRange, fRange, 0.0f);
			var vec3 vE;vE.SetXYZ(DISRUPT_RADIUS, DISRUPT_RADIUS, 0.0f);
			CreatePersonalRegion("PsiDisruptor_"+GetName()+"_"+Random.GetInt().ToString(), vE, 010b);
		endif;
	endproc;
	
	proc bool OnObjAdd(CObjHndl p_xHndl)
		if(m_bToBeDeleted)then return false; endif;
		var ^CFightingObj pxFO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxFO!=null&&(CSrvWrap.GetDiplomacyMgr().GetIsEnemy(GetOwner(), pxFO^.GetOwner())||CSrvWrap.GetDiplomacyMgr().GetIsEnemy(pxFO^.GetOwner(),GetOwner())))then
			if(ms_asTypes.FindEntry(pxFO^.GetType().AsString())<0)then return false; endif;
			m_xRegionObjects.Include(p_xHndl);
			pxFO^.SetMirageFlag(CFightingObj.MIRAGE_PSI_DISRUPT,true);
		endif;
		return true;
	endproc;
	
	proc bool OnObjRem(CObjHndl p_xHndl)
		if(m_xRegionObjects.FindEntry(p_xHndl)==-1)then return false; endif;
		m_xRegionObjects.RemEntry(p_xHndl);
		var ^CFightingObj pxFO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxFO!=null)then
			pxFO^.SetMirageFlag(CFightingObj.MIRAGE_PSI_DISRUPT,false);
		endif;
		return true;
	endproc;
	
	export proc void InitOwnRegion()
		if(!HasPersonalRegion())then
			var vec3 vE;vE.SetXYZ(DISRUPT_RADIUS, DISRUPT_RADIUS, 0.0f);
			CreatePersonalRegion("PsiDisruptor_"+GetName()+"_"+Random.GetInt().ToString(), vE, 010b);
		endif;
	endproc;
	
	export proc string GetReportCode()
		return "defence";
	endproc;
	
endclass;
	
class CSeasPub inherit CNPCSeller
	
	var bool					m_bEquipped;
	var CObjList			m_xAddons;
	var array vec3		m_avAddonOffsets;
	
	constructor()
		m_bEquipped=false;
	endconstructor;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="SePu")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			if(iVersion>=1)then
				(pxArc^) << m_bEquipped;
				var int i,iC;
				(pxArc^) << iC;
				m_avAddonOffsets=iC;
				for(i=0) cond(i<iC) iter(i++)do
					(pxArc^) << m_avAddonOffsets[i];
				endfor;
				m_xAddons.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="SePu";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		(pxArc^) << m_bEquipped;
		var int i,iC=m_avAddonOffsets.NumEntries();
		(pxArc^) << iC;
		for(i=0) cond(i<iC) iter(i++)do
			(pxArc^) << m_avAddonOffsets[i];
		endfor;
		m_xAddons.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;
	
//	export proc void OnInit(bool p_bLoad)
//		super.OnInit(p_bLoad);
//		if(!p_bLoad)then
//			BuildAddons();
//		endif;
//	endproc;
	
	export proc void SetReady()
		super.SetReady();
		if(m_bBuildingReady)then
			BuildAddons();
		endif;
	endproc;
	
	proc void BuildAddons()
		if(!m_bEquipped)then
			m_bEquipped=true;
			var CFourCC xLink="NOPE";
			var ^CMirageDeco pxA;
			m_avAddonOffsets.AddEntry({-1.0,3.05,-0.3}); // Henry: gate
			m_avAddonOffsets.AddEntry({5.17,2.28,3.34}); // Henry: antenna
			var int i, iC=m_avAddonOffsets.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				pxA=cast<CMirageDeco>(CSrvWrap.GetObjMgr()^.CreateObj("seas_pub_misc_"+i.ToString(),GetOwner(),GetPos()));
				if(pxA!=null)then
					m_xAddons.AddEntry(pxA^.GetHandle());
					AddGroupedChildren(pxA^.GetGuid());
					pxA^.LinkAction(GetHandle(),xLink,m_avAddonOffsets[i]);
				endif;
			endfor;
		endif;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		var CFourCC xLink="NOPE";
		var int i, iC=m_xAddons.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CGameObj pxA=m_xAddons[i].GetObj();
			if(pxA!=null)then
				pxA^.LinkAction(GetHandle(),xLink,m_avAddonOffsets[i]);
			endif;
		endfor;
	endproc;
	
//	export proc void Delete()
//		var int i, iC=m_xAddons.NumEntries();
//		for(i=0)cond(i<iC)iter(i++)do
//			var ^CGameObj pxA=m_xAddons[i].GetObj();
//			if(pxA!=null)then
//				RemGroupedChildren(pxA^.GetGuid());
//				pxA^.Delete();
//			endif;
//		endfor;
//		super.Delete();
//	endproc;
	
	export proc void TransferLinkedObjs(CObjHndl p_xC)
		if(!p_xC.IsValid())then return; endif;
		var CFourCC xLink="NOPE";
		while(m_xAddons.NumEntries()>0)do
			var ^CGameObj pxA = m_xAddons[0].GetObj();
			if(pxA==null)then
				m_xAddons.DeleteEntry(0);
				m_avAddonOffsets.DeleteEntry(0);
				continue;
			endif;
			RemGroupedChildren(pxA^.GetGuid());
			pxA^.TerminateAction();
			pxA^.LinkAction(p_xC,xLink,m_avAddonOffsets[0]);
			m_xAddons.DeleteEntry(0);
			m_avAddonOffsets.DeleteEntry(0);
		endwhile;
		m_xAddons.Clear();
	endproc;
	
	export proc CObjList GetAddons();
		return m_xAddons;
	endproc;
	
endclass;
	
class CSeasScorpionLaunchpad inherit CBuilding
	
	const int SCLAUNCHPAD_STANDUP				=40096;
	const int SCLAUNCHPAD_REPLACE				=40097;
	
	var bool m_bActive;
	var bool m_bReplacing;
	var bool m_bAlreadySetLevel;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="ScLP")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			if(iVersion>=1)then
				pxArc^<<m_bActive;
				pxArc^<<m_bReplacing;
			endif;
			if(iVersion>=2)then
				pxArc^<<m_bAlreadySetLevel;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="ScLP";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,2);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		pxArc^ << m_bActive;
		pxArc^ << m_bReplacing;
		pxArc^ << m_bAlreadySetLevel;
		pxWalk^.Close();
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetCanWalk(false);
		SetCanSwim(false);
		SetCanFly(false);
		if(!p_bLoad)then
			m_bActive=false;
			m_bReplacing=false;
			m_bAlreadySetLevel=false;
//			var string sPlayerName="";
//			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
//			if(pxLevel!=null)then
//				var ^CPlayer pxPlayer=pxLevel^.GetPlayer(GetOwner());
//				if(pxPlayer!=null)then
//					sPlayerName=pxLevel^.GetLevelInfo().GetPlayerSlot(pxPlayer^.GetPlayerSlotID()).GetName();
//					CFeedback.Print(CFeedback.ALL, CFeedback.ATTACK, "_MIRAGE_NT_ScorpionStarted\t"+sPlayerName);
//				endif;
//			endif;
		endif;
	endproc;
	
	export proc void IgniteBuilding(real p_fDmg, int p_iMaxCount, CObjHndl p_xSource, int p_iSource)
		return;
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		if(m_bBuildingReady)then
			var string sGFX=m_xTechTree.GetValueS(GetObjPath()+"/gfx","");
			if(!sGFX.IsEmpty()&&sGFX!=GetGfxName())then
				super.SetGFX(sGFX);
//				if(!m_bActive)then
				SetAnim("stand_up",0,2);
//				endif;
			endif;
		endif;
		if(m_bActive)then return; endif;
		CreateTimer(SCLAUNCHPAD_STANDUP, CGameTimeSpan.OneSecond()*1.0,false);
		m_bActive=true;
		SetSelectable(false);
		SetHitable(false);
//		var string sPlayerName="";
//		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
//		if(pxLevel!=null)then
//			var ^CPlayer pxPlayer=pxLevel^.GetPlayer(GetOwner());
//			if(pxPlayer!=null)then
//				sPlayerName=pxLevel^.GetLevelInfo().GetPlayerSlot(pxPlayer^.GetPlayerSlotID()).GetName();
//				CFeedback.Print(CFeedback.ALL, CFeedback.ATTACK, "_MIRAGE_NT_ScorpionFinished\t"+sPlayerName);
//			endif;
//		endif;
	endproc;
	
	export proc bool IsAbleToFight()
		return false;
	endproc;
	
	//Henry: HACK
	export proc void SetGFX(string p_sString)
		if(p_sString==GetFakeGfx())then
			super.SetGFX(p_sString);
		else
			return;
		endif;
	endproc;
	
	export proc bool SetAnim(string p_sAnim, int p_iMod)
		return SetAnim(p_sAnim,p_iMod,1);
	endproc;
	
	export proc bool SetAnim(string p_sAnim, int p_iMod, int p_iStart)
		var real fDur;
		return SetAnim(p_sAnim,p_iMod,p_iStart,fDur);
	endproc;
	
	export proc bool SetAnim(string p_sAnim, int p_iMod, int p_iStart, ref real p_rfDur)
		if(!m_bReplacing&&p_sAnim!="stand_up")then p_sAnim="stand_up"; p_iMod=0; p_iStart=2; endif;
		return super.SetAnim(p_sAnim,p_iMod,p_iStart,p_rfDur);
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(m_bActive)then return; endif;
		super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
	endproc;
	
	proc bool UpdateDestructionFlags()
		return false;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==SCLAUNCHPAD_STANDUP)then
				m_bReplacing=true;
				var real fAnimDuration;
				SetAnim("stand_up",1);
				fAnimDuration=GetCurrentAnimLength();
				CreateTimer(SCLAUNCHPAD_REPLACE,CGameTimeSpan.OneSecond()*fAnimDuration,false);
			elseif(iTimerID==SCLAUNCHPAD_REPLACE)then
				SetAnim("standanim",1);
				m_bReplacing=true;
				SetVisible(false);
				var ^CSeasScorpion pxScorpion=cast<CSeasScorpion>(CSrvWrap.GetObjMgr()^.CreateObj("seas_scorpion",GetOwner(),GetPos(),GetRotation()));
				if(pxScorpion!=null)then
					var ^CAttribs pxAttr=pxScorpion^.GetAttribs();
					if(pxAttr!=null)then
						pxAttr^.SetValue("clientpyramid_replacecard", GetName());
					endif;
					pxScorpion^.SetLevelClean(GetLevel());
					pxScorpion^.SetIdleAnim();
					pxScorpion^.ExamineEnemies(false);
					Die();
				endif;
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	export proc bool CreateBuildingCorpse()
		return true;
	endproc;
	
	export proc void Die()
//		if(!IsReady())then
//			var string sPlayerName="";
//			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
//			if(pxLevel!=null)then
//				var ^CPlayer pxPlayer=pxLevel^.GetPlayer(GetOwner());
//				if(pxPlayer!=null)then
//					sPlayerName=pxLevel^.GetLevelInfo().GetPlayerSlot(pxPlayer^.GetPlayerSlotID()).GetName();
//					CFeedback.Print(CFeedback.ALL, CFeedback.ATTACK, "_MIRAGE_NT_ScorpionDestroyed\t"+sPlayerName);
//				endif;
//			endif;
//		endif;
		super.Die();
	endproc;
	
	export proc void OnKill()
		if(m_bActive)then return; endif;
		return super.OnKill();
	endproc;
	
	export proc bool DoesCountInUnitLimit()
		return true;
	endproc;
	
	export proc void DoSelfRepair()
		return;
	endproc;
	
	export proc string GetReportCode()
		return "unit";
	endproc;
	
//	export proc bool SetLevel(int p_iLevel)
//		if(m_bAlreadySetLevel)then return false; endif;
//		m_bAlreadySetLevel=super.SetLevel(p_iLevel);
//		return m_bAlreadySetLevel;
//	endproc;
	
//	export proc bool SetLevelClean(int p_iLevel)
//		if(m_bAlreadySetLevel)then return false; endif;
//		m_bAlreadySetLevel=super.SetLevelClean(p_iLevel);
//		return m_bAlreadySetLevel;
//	endproc;
	
endclass;
	
class CSeasSmallCannon inherit CTower
	
	export proc void SetReady()
		super.SetReady();
		if(m_bBuildingReady)then
			SetTurretLink("we");
			SetTurret("seas_hq_defense_turret_top");
			m_sTurretAttackAnim="attack_front";
		endif;
	endproc;
	
endclass;

class CSeasShoreCannon inherit CTower

	export proc void SetReady()
		super.SetReady();
		if(m_bBuildingReady)then
			SetTurretLink("we");
			SetTurret("seas_carrier_turret");
			m_sTurretAttackAnim="attack_front";
		endif;
	endproc;
	
	export proc void SetTurret(string p_sObjName)
		if(m_xTurret.IsValid())then
			m_xTurret.GetObj()^.Delete();
		endif;
		if(p_sObjName.IsEmpty())then return; endif;
		var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj(p_sObjName, GetOwner());
		if(pxO==null)then return();endif;
		pxO^.LinkAction(GetHandle(), m_xTurretLink, {0.0,0.0,-7.05});
		m_xTurret=pxO^.GetHandle();
		AddGroupedChildren(pxO^.GetGuid());
		var ^CAttribs pxA=pxO^.GetAttribs();
		if(pxA!=null)then
			pxA^.SetValue("maxhitpoints", GetAttribs()^.GetValueFloat("maxhitpoints"));
			pxA^.SetValue("hitpoints", GetAttribs()^.GetValueFloat("hitpoints"));
		endif;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		var ^CGameObj pxO=m_xTurret.GetObj();
		if(pxO!=null)then
			pxO^.LinkAction(GetHandle(), m_xTurretLink, {0.0,0.0,-7.05});
		endif;
	endproc;

endclass;
	
class CSeasSpeaker inherit CBuilding
	
	const real SPEAKER_RADIUS=50.0f;
	
	static var array string ms_asTypes;
	
	export constructor()
		if(ms_asTypes.NumEntries()==0)then
			ms_asTypes.AddEntry("CHTR");
			ms_asTypes.AddEntry("ANML");
			ms_asTypes.AddEntry("VHCL");
		endif;
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		m_xSink.m_xOnObjAdd=OnObjAdd;
		m_xSink.m_xOnObjRem=OnObjRem;
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		//var real fRange=m_xTechTree.GetValueR("MiscValues/SEAS/Speaker_range",50.0);
		if(!HasPersonalRegion())then
			//var vec3 vE;vE.SetXYZ(fRange, fRange, 0.0f);
			var vec3 vE;vE.SetXYZ(SPEAKER_RADIUS, SPEAKER_RADIUS, 0.0f);
			CreatePersonalRegion("SEASSpeaker_"+GetName()+"_"+Random.GetInt().ToString(), vE, 010b);
			AddRangedBuff("owner_more_defense");
			AddRangedBuff("owner_more_armor");
		endif;
	endproc;
	
	proc bool OnObjAdd(CObjHndl p_xHndl)
		if(m_bToBeDeleted)then return false; endif;
		var ^CFightingObj pxO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxO==null)then return false; endif;
		if(ms_asTypes.FindEntry(pxO^.GetType().AsString())<0)then return false; endif;
		if(!((GetOwner()==pxO^.GetOwner()) || (AuraSharing()&&(CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxO^.GetOwner(), GetOwner())&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxO^.GetOwner())))))then return false; endif;
		if(pxO^.GetType()=="BLDG")then return false; endif;
		m_xRegionObjects.Include(p_xHndl);
		pxO^.SetMirageFlag(CFightingObj.MIRAGE_SPEAKER, true);
		return true;
	endproc;
	
	proc bool OnObjRem(CObjHndl p_xHndl)
		if(m_xRegionObjects.FindEntry(p_xHndl)==-1)then return false; endif;
		var ^CFightingObj pxO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxO==null)then return false; endif;
		pxO^.SetMirageFlag(CFightingObj.MIRAGE_SPEAKER, false);
		m_xRegionObjects.RemEntry(p_xHndl);
		return true;
	endproc;
	
	export proc void InitOwnRegion()
		if(!HasPersonalRegion())then
			var vec3 vE;vE.SetXYZ(SPEAKER_RADIUS, SPEAKER_RADIUS, 0.0f);
			CreatePersonalRegion("SEASSpeaker_"+GetName()+"_"+Random.GetInt().ToString(), vE, 010b);
			AddRangedBuff("owner_more_defense");
			AddRangedBuff("owner_more_armor");
		endif;
	endproc;
	
	export proc string GetReportCode()
		return "defence";
	endproc;
	
endclass;
	
class CSeasStaircase inherit CBuilding
	
	class CSeasBUI
		export var int			m_iGroupCmdID; ///< group command id, used for build up the staircase
		export var CObjHndl	m_xStaircase; ///< staircase to build up
		export var CObjHndl	m_xWall; ///< targeted wall
	endclass;
	
	static var array CSeasBUI			ms_axBUI;
	var CDockInfo									m_xDockInfo;
	var bool											m_bEquipped;
	var CObjList									m_xAddons;
	var array vec3								m_avAddonOffsets;
	var CObjList									m_xClimbers;
	var bool											m_bSiegeBreak;
	
	export static proc void RegisterStaircaseBuildUp(int p_iCmdID,CObjHndl p_xStaircase,CObjHndl p_xWall)
		var CSeasBUI xNew;
		xNew.m_iGroupCmdID=p_iCmdID;
		xNew.m_xStaircase=p_xStaircase;
		xNew.m_xWall=p_xWall;
		ms_axBUI.AddEntry(xNew);
	endproc;
	
	export static proc CObjHndl GetStaircaseBuildUp(int p_iCmdID, CObjHndl p_xWall)
		var int i,iC=ms_axBUI.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(ms_axBUI[i].m_iGroupCmdID==p_iCmdID&&ms_axBUI[i].m_xWall==p_xWall&&ms_axBUI[i].m_xWall.IsValid())then
				return ms_axBUI[i].m_xStaircase;
			endif;
		endfor;
		return CObjHndl.Invalid();
	endproc;
	
	export static proc void UnregisterStaircaseBuildUp(CObjHndl p_xStaircase)
		var int i,iC=ms_axBUI.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(ms_axBUI[i].m_xStaircase==p_xStaircase)then
				ms_axBUI.DeleteEntry(i);
				return;
			endif;
		endfor;
	endproc;
	
	export constructor()
		m_xDockInfo.SetMoveCallback(Climb);
		m_bEquipped=false;
	endconstructor;
	
	export proc ref CDockInfo GetDockInfo()
		return m_xDockInfo;
	endproc;
	
	proc real Climb(CObjHndl p_xActor,bool p_bUp)
		var ^CCharacter pxActor=cast<CCharacter>(p_xActor.GetObj());
		if(pxActor==null)then return -1.0f; endif;
		return pxActor^.StartStaircaseClimb(GetHandle(),p_bUp,false,false);
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		m_xDockInfo.SetDockedDocker(true,GetHandle());
		UnregisterStaircaseBuildUp(GetHandle());
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("IsSiegeUnit", 1);
			pxAttr^.SetValue("IsDockingWall", 1);
		endif;
		if(m_bBuildingReady)then
			BuildAddons();
		endif;
	endproc;
	
	export proc void Delete()
		m_xDockInfo.SetDockedDocker(false,GetHandle());
		super.Delete();
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="Stai";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xDockInfo.DoKArc(pxArc^);
		(pxArc^) << m_bEquipped;
		var int i,iC=m_avAddonOffsets.NumEntries();
		(pxArc^) << iC;
		for(i=0) cond(i<iC) iter(i++)do
			(pxArc^) << m_avAddonOffsets[i];
		endfor;
		m_xAddons.DoKArc(pxArc^);
		m_xClimbers.DoKArc(pxArc^);
		pxArc^ << m_bSiegeBreak;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="Stai")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xDockInfo.DoKArc(pxArc^);
			(pxArc^) << m_bEquipped;
			var int i,iC;
			(pxArc^) << iC;
			m_avAddonOffsets=iC;
			for(i=0) cond(i<iC) iter(i++)do
				(pxArc^) << m_avAddonOffsets[i];
			endfor;
			m_xAddons.DoKArc(pxArc^);
			m_xClimbers.DoKArc(pxArc^);
			pxArc^ << m_bSiegeBreak;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool RegisterClimber(CObjHndl p_xClimber)
		if(!p_xClimber.IsValid()||m_bSiegeBreak)then return false; endif;
		m_xClimbers.Include(p_xClimber);
		return true;
	endproc;
	
	export proc bool UnregisterClimber(CObjHndl p_xClimber)
		if(!p_xClimber.IsValid())then return false; endif;
		if(m_xClimbers.FindEntry(p_xClimber)==-1)then return false; endif;
		m_xClimbers.RemEntry(p_xClimber);
		return true;
	endproc;
	
	proc void BuildAddons()
		if(!m_bEquipped)then
			m_bEquipped=true;
			var CFourCC xLink="NOPE";
			var ^CMirageDeco pxA;
			m_avAddonOffsets.AddEntry({-2.7,6.3,-2.8}); // Henry: ladder
			m_avAddonOffsets.AddEntry({-2.7,2.0,0.0}); // Henry: supporter
			var int i, iC=m_avAddonOffsets.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				pxA=cast<CMirageDeco>(CSrvWrap.GetObjMgr()^.CreateObj("seas_staircase_misc_"+i.ToString(),GetOwner(),GetPos()));
				if(pxA!=null)then
					m_xAddons.AddEntry(pxA^.GetHandle());
					AddGroupedChildren(pxA^.GetGuid());
					var vec3 vDir=pxA^.GetPos()-GetPos();
					var Quat qRot;
					qRot.FromXYDir(vDir.GetX(),vDir.GetY());
					qRot.RotateZ(Math.Pihalf());
					pxA^.SecRotAction(qRot,0.01);
					pxA^.LinkAction(GetHandle(),xLink,m_avAddonOffsets[i]);
				endif;
			endfor;
		endif;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		var CFourCC xLink="NOPE";
		var int i, iC=m_xAddons.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CGameObj pxA=m_xAddons[i].GetObj();
			if(pxA!=null)then
				var vec3 vDir=pxA^.GetPos()-GetPos();
				var Quat qRot;
				qRot.FromXYDir(vDir.GetX(),vDir.GetY());
				qRot.RotateZ(Math.Pihalf());
				pxA^.SecRotAction(qRot,0.01);
				pxA^.LinkAction(GetHandle(),xLink,m_avAddonOffsets[i]);
			endif;
		endfor;
	endproc;
	
	export proc void TransferLinkedObjs(CObjHndl p_xC)
		if(!p_xC.IsValid())then return; endif;
		var CFourCC xLink="NOPE";
		while(m_xAddons.NumEntries()>0)do
			var ^CGameObj pxA = m_xAddons[0].GetObj();
			if(pxA==null)then
				m_xAddons.DeleteEntry(0);
				m_avAddonOffsets.DeleteEntry(0);
				continue;
			endif;
			RemGroupedChildren(pxA^.GetGuid());
			pxA^.TerminateAction();
			pxA^.LinkAction(p_xC,xLink,m_avAddonOffsets[0]);
			m_xAddons.DeleteEntry(0);
			m_avAddonOffsets.DeleteEntry(0);
		endwhile;
		m_xAddons.Clear();
	endproc;
	
	export proc CObjList GetAddons();
		return m_xAddons;
	endproc;
	
	export proc void SetExtRot(Quat p_qRot)
		SetRot(p_qRot);
		m_xBUMgr.SetExtRot(p_qRot);
	endproc;
	
	export proc void SetExtPosZ(real p_fZ)
		GetPos().SetZ(p_fZ);
		m_xBUMgr.SetExtPosZ(p_fZ);
	endproc;
	
	proc void OnDockedWallDeleted()
		BreakSiege();
	endproc;
	
	export proc void BreakSiege()
		m_bSiegeBreak=true;
		while(m_xClimbers.NumEntries()>0)do
			var ^CCharacter pxC=cast<CCharacter>(m_xClimbers[0].GetObj());
			m_xClimbers.DeleteEntry(0);
			if(pxC!=null)then
				pxC^.TerminateAction();
				pxC^.BreakSieging();
			endif;
		endwhile;
		m_xClimbers.Clear();
		return super.DiePerHarakiri();
	endproc;
	
	export proc void SetSiegeBreak(bool p_bOn)
		m_bSiegeBreak=p_bOn;
	endproc;
	
	export proc void DiePerHarakiri()
		if(m_xClimbers.Validate()>0)then return; endif;
		return super.DiePerHarakiri();
	endproc;
	
	export proc string GetReportCode()
		return "unit";
	endproc;
	
endclass;

class CItemStorage inherit CBuilding

	var CObjList 	m_xItems;
	var bool 		m_bAboutToDie;

endclass;

class CCharPrison inherit CRallyBuilding

endclass;
	
class CSeasStygiNest inherit CBuilding
	
	var CObjHndl m_xNest;
	//var CObjHndl m_xSecondNest;
	const real NEST_RADIUS_1 = 70.0f; // the nests territory (Stygi)
	const real NEST_RADIUS_2 = 140.0f; // the nests tolerance zone
	var bool m_bNestGrow;
	const real NEST_GROW = 360.0f; // time which after more animal spawns from the nest
	const int NEW_EGGS = 2; // increasement of max spawned animals from the nest
	
	export constructor()
		m_bNestGrow=false;
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="SeSt";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,2);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xNest.DoKArc(pxArc^);
		(pxArc^) << m_bNestGrow;
		//m_xSecondNest.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="SeSt")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xNest.DoKArc(pxArc^);
			//m_xSecondNest.DoKArc(pxArc^);
			if(p_pxReaderNode^.GetVersion()>=2)then
				(pxArc^) << m_bNestGrow;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		if(!m_bNestGrow)then
			if(HasTimer(NEST_GROW_TIMER))then DeleteTimer(NEST_GROW_TIMER); endif;
			CreateTimer(NEST_GROW_TIMER,CGameTimeSpan.OneSecond()*NEST_GROW,false);
		endif;
		if(m_xNest.IsValid())then return; endif;
		var ^CNest pxNest=cast<CNest>(CSrvWrap.GetObjMgr()^.CreateObj("seas_stygo_nest_spawn",GetOwner(),GetPos()+{0.0,0.0,0.0},GetRotation()));
		if(pxNest!=null)then
			m_xNest=pxNest^.GetHandle();
			AdjustNestAreas(pxNest);
			var CFourCC xT="NOPE";
			pxNest^.LinkAction(GetHandle(), xT);
			pxNest^.SetVisible(false);
		endif;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==NEST_GROW_TIMER)then
				var ^CNest pxN=cast<CNest>(m_xNest.GetObj());
				if(pxN!=null)then
					if(pxN^.ChangeSpawnAmount(NEW_EGGS))then
						m_bNestGrow=true;
					endif;
				else
					DeleteTimer(NEST_GROW_TIMER);
					CreateTimer(NEST_GROW_TIMER,CGameTimeSpan.OneSecond()*NEST_GROW,false);
				endif;
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
/*
	export proc void UpdateGfxFlags()
		if(!m_xSecondNest.IsValid()&&GetClassName()=="seas_stygimoloch_nest")then
			var bool bCreateSecNest=CRequirementsMgr.Get().CheckInvention(this, GetOwner(), "seas_nest_upgrade", GetTribeName());
			if(bCreateSecNest)then
				if(m_bBuildingReady)then
					var ^CNest pxSecondNest=cast<CNest>(CSrvWrap.GetObjMgr()^.CreateObj("seas_tric_nest_spawn",GetOwner(),GetPos(),GetRotation()));
					if(pxSecondNest!=null)then
						m_xSecondNest=pxSecondNest^.GetHandle();
						AdjustSecondNestAreas(pxSecondNest);
						pxSecondNest^.SetVisible(false);
						var CFourCC xT="NOPE";
						pxSecondNest^.LinkAction(GetHandle(), xT);
					endif;
				endif;
			endif;
		endif;
	endproc;
*/
	export proc void OnPostLoad()
		super.OnPostLoad();
		if(!IsBuildMode())then
			SetReady();
		endif;
	endproc;
	
	proc void AdjustNestAreas(^CNest p_pxNest)
		//var real fRange=m_xTechTree.GetValueR("MiscValues/SEAS/Stygonest_radius",50.0);
		//var vec3 vE; vE.SetXYZ(fRange, fRange, 0.0f);
		var ^CRegion pxRgn=p_pxNest^.GetActionAreaPtr();
		var vec3 vE; vE.SetXYZ(NEST_RADIUS_1, NEST_RADIUS_1, 0.0f);
		if(pxRgn!=null)then
			pxRgn^.Clear();
			pxRgn^.AddSubRegion(010b, GetPos(), vE);
		endif;
		pxRgn=p_pxNest^.GetSafeAreaPtr();
		if(pxRgn!=null)then
			pxRgn^.Clear();
			pxRgn^.AddSubRegion(010b, GetPos(), vE);
		endif;
		vE.SetXYZ(NEST_RADIUS_2, NEST_RADIUS_2, 0.0f);
		pxRgn=p_pxNest^.GetToleranceAreaForced();
		if(pxRgn!=null)then
			pxRgn^.Clear();
			pxRgn^.AddSubRegion(010b, GetPos(), vE);
		endif;
	endproc;
/*
	proc void AdjustSecondNestAreas(^CNest p_pxNest)
		var ^CRegion pxRgn=p_pxNest^.GetActionAreaPtr();
		//var real fRange=m_xTechTree.GetValueR("MiscValues/SEAS/Carnonest_radius",50.0);
		//var vec3 vE; vE.SetXYZ(fRange, fRange, 0.0f);
		var vec3 vE; vE.SetXYZ(NEST_RADIUS_1, NEST_RADIUS_2, 0.0f);
		pxRgn^.Clear();
		pxRgn^.AddSubRegion(010b, GetPos(), vE);
		pxRgn=p_pxNest^.GetSafeAreaPtr();
		pxRgn^.Clear();
		pxRgn^.AddSubRegion(010b, GetPos(), vE);
	endproc;
*/
	export proc void Die()
		var ^CNest pxN=cast<CNest>(m_xNest.GetObj());
		//var ^CNest pxSN=cast<CNest>(m_xSecondNest.GetObj());
		if(pxN!=null)then
			pxN^.Die();
		endif;
		//if(pxSN!=null)then
			//pxSN^.Die();
		//endif;
		super.Die();
	endproc;
	
	export proc string GetReportCode()
		return "defence";
	endproc;
	
endclass;
	
class CSeasWarpGate inherit CWarpGate
	/*
	var CObjList			m_xAddons;
	var array vec3		m_avAddonOffsets;
	var bool					m_bWarpDone;
	var bool					m_bActive;
	
	const real				ANIM_DELAY				= 1.75f;
	const int					TIMERID_OPEN			= 40051;
//	const vec3				TESLA_OFFSET			= {0.0,12.73,0.0};
	const vec3				WALL_O_OFFSET			= {11.53,1.1,0.0};
	const vec3				WALL_T_OFFSET			= {-11.53,1.1,0.0};
	const vec3				WARP_OFFSET				= {0.0,3.66,-7.56};
	
	export constructor()
		m_bWarpDone=false;
		m_bActive=false;
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			m_bWarpDone=false;
			m_bActive=false;
		endif;
		if(!m_bBuildingReady)then
			//SetAnim("open",0,0);
		elseif(m_bActive)then
			SetAnim("open",0,120);
		endif;
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="SeWa")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			if(iVersion>=1)then
				(pxArc^) << m_bWarpDone;
				var int i,iC;
				(pxArc^) << iC;
				m_avAddonOffsets=iC;
				for(i=0) cond(i<iC) iter(i++)do
					(pxArc^) << m_avAddonOffsets[i];
				endfor;
			endif;
			if(iVersion>=2)then
				m_xAddons.DoKArc(pxArc^);
			endif;
			if(iVersion>=3)then
				(pxArc^) << m_bActive;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="SeWa";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,3);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		(pxArc^) << m_bWarpDone;
		var int i,iC=m_avAddonOffsets.NumEntries();
		(pxArc^) << iC;
		for(i=0) cond(i<iC) iter(i++)do
			(pxArc^) << m_avAddonOffsets[i];
		endfor;
		m_xAddons.DoKArc(pxArc^);
		(pxArc^) << m_bActive;
		pxWalk^.Close();
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		if(m_bBuildingReady)then
			SetAnim("open",0,0);
			var CFourCC xLink="NOPE";
			var ^CMirageDeco pxAddon=cast<CMirageDeco>(CSrvWrap.GetObjMgr()^.CreateObj("seas_warp_misc_two",GetOwner(),GetPos()));
			if(pxAddon!=null)then
				m_xAddons.AddEntry(pxAddon^.GetHandle());
				AddGroupedChildren(pxAddon^.GetGuid());
				pxAddon^.LinkAction(GetHandle(),xLink,WALL_O_OFFSET);
				m_avAddonOffsets.AddEntry(WALL_O_OFFSET);
			endif;
			pxAddon=cast<CMirageDeco>(CSrvWrap.GetObjMgr()^.CreateObj("seas_warp_misc_two",GetOwner(),GetPos()));
			if(pxAddon!=null)then
				m_xAddons.AddEntry(pxAddon^.GetHandle());
				AddGroupedChildren(pxAddon^.GetGuid());
				pxAddon^.LinkAction(GetHandle(),xLink,WALL_T_OFFSET);
				m_avAddonOffsets.AddEntry(WALL_T_OFFSET);
			endif;
		endif;
		if(!m_bWarpDone)then
			var real fAnimDuration;
			SetAnim("open",1);
			fAnimDuration=GetCurrentAnimLength() - ANIM_DELAY;
			CreateTimer(TIMERID_OPEN,CGameTimeSpan.OneSecond()*fAnimDuration,false);
			m_bWarpDone=true;
		endif;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==TIMERID_OPEN)then
				SetAnim("open",0,120);
				m_bActive=true;
				var CFourCC xLink="NOPE";
				var ^CMirageDeco pxAddon=cast<CMirageDeco>(CSrvWrap.GetObjMgr()^.CreateObj("seas_warp_misc_three",GetOwner(),GetPos()));
				if(pxAddon!=null)then
					m_xAddons.AddEntry(pxAddon^.GetHandle());
					AddGroupedChildren(pxAddon^.GetGuid());
					pxAddon^.LinkAction(GetHandle(),xLink,WARP_OFFSET);
					m_avAddonOffsets.AddEntry(WARP_OFFSET);
				endif;
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		if(!m_bBuildingReady)then
			//SetAnim("open",0,0);
		elseif(m_bActive)then
			SetAnim("open",0,120);
		endif;
		var CFourCC xLink="NOPE";
		var int i, iC=m_xAddons.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CGameObj pxA=m_xAddons[i].GetObj();
			if(pxA!=null)then
				pxA^.LinkAction(GetHandle(),xLink,m_avAddonOffsets[i]);
			endif;
		endfor;
	endproc;
	
	export proc void Die()
		var int i, iC=m_xAddons.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CGameObj pxB=m_xAddons[i].GetObj();
			if(pxB!=null)then
				pxB^.Delete();
			endif;
		endfor;
		super.Die();
	endproc;
	*/
endclass;
	
class CSeasWell inherit CBuilding
	
	export constructor()
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			SetNoParticles(true);
			//InitAttribs();
			SetSelectable(true);
			SetHitable(true);
		endif;
		//InitEvents();
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		if(IsBuildMode())then
			SetNoParticles(true);
		endif;
	endproc;
	
	export proc void SetReady()
		super.SetReady();
		SetNoParticles(false);
//		SetAnim("base_anim",3);
		//StartReplenishTimer();
		UpdateEnergy();
	endproc;
	
	export proc void ObjArrived(CObjHndl p_xObj)
		var ^CFightingObj pxObj=cast<CFightingObj>(p_xObj.GetObj());
		if(pxObj==null)then return; endif;
		if(IsBuildMode())then return; endif;
		if(pxObj^.GetOwner()!=GetOwner()&&!CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxObj^.GetOwner(), GetOwner()))then return; endif;
		var real fHitpoints=pxObj^.GetHitpoints();
		var real fMaxHitpoints=pxObj^.GetMaxHitpoints();
		if(fHitpoints==fMaxHitpoints)then return; endif;
		var real fDiff=m_fEnergyState-(fMaxHitpoints-fHitpoints);
		if(fDiff>=0.0)then
			pxObj^.FullHeal();
			pxObj^.FountainOfYouth(fMaxHitpoints-fHitpoints);
		else
			pxObj^.HealMe(m_fEnergyState);
			pxObj^.FountainOfYouth(m_fEnergyState);
			fDiff=0.0;
		endif;
		pxObj^.FountainArrived(GetHandle());
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("energyamount",fDiff.ToInt());
		endif;
		m_fEnergyState=fDiff;
		StartReplenishTimer();
		if(HasAnim("fill_anim"))then
			InvokeGenericSCEvent(23,0.0);
		endif;
	endproc;
	
	export proc bool StartReplenishTimer()
		if(!IsReady())then return false; endif;
		return super.StartReplenishTimer();
	endproc;
	
	export proc string GetReportCode()
		return "defence";
	endproc;
	
endclass;
	
class CSpecialBox inherit CBuilding
	
	const int TIMER_REST_MISC = 40179;
	var bool					m_bEquipped;
	var CObjList			m_xAddons;
	var array vec3		m_avAddonOffsets;
	
	constructor()
		m_bEquipped=false;
	endconstructor;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="SBox")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			if(iVersion>=1)then
				(pxArc^) << m_bEquipped;
				var int i,iC;
				(pxArc^) << iC;
				m_avAddonOffsets=iC;
				for(i=0) cond(i<iC) iter(i++)do
					(pxArc^) << m_avAddonOffsets[i];
				endfor;
				m_xAddons.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="SBox";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		(pxArc^) << m_bEquipped;
		var int i,iC=m_avAddonOffsets.NumEntries();
		(pxArc^) << iC;
		for(i=0) cond(i<iC) iter(i++)do
			(pxArc^) << m_avAddonOffsets[i];
		endfor;
		m_xAddons.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;
	
//	export proc void OnInit(bool p_bLoad)
//		super.OnInit(p_bLoad);
//		if(!p_bLoad)then
//			BuildAddons();
//		endif;
//	endproc;
	
	export proc void SetReady()
		super.SetReady();
		if(m_bBuildingReady)then
			BuildAddons();
		endif;
	endproc;
	
	proc void BuildAddons()
		if(!m_bEquipped)then
			CreateTimer(TIMER_REST_MISC, CGameTimeSpan.OneSecond() * 18000.0, true);
			m_bEquipped=true;
			var CFourCC xLink="NOPE";
			var ^CMirageDeco pxA;
			m_avAddonOffsets.AddEntry({-1.35,0.0,0.3}); // Henry: lemur
			m_avAddonOffsets.AddEntry({1.35,0.0,0.3}); // Henry: sloth
			var int i, iC=m_avAddonOffsets.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				pxA=cast<CMirageDeco>(CSrvWrap.GetObjMgr()^.CreateObj("special_box_misc_"+i.ToString(),GetOwner(),GetPos()));
				if(pxA!=null)then
					m_xAddons.AddEntry(pxA^.GetHandle());
					AddGroupedChildren(pxA^.GetGuid());
					pxA^.LinkAction(GetHandle(),xLink,m_avAddonOffsets[i]);
					pxA^.SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_HELMET,true);
					pxA^.SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMOR,true);
					pxA^.SetSLEAnim("rest",99999,true,true);
				endif;
			endfor;
		endif;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==TIMER_REST_MISC)then
				var int i, iC=m_xAddons.NumEntries();
				for(i=0)cond(i<iC)iter(i++)do
					var ^CGameObj pxA=m_xAddons[i].GetObj();
					if(pxA!=null)then
						pxA^.SetSLEAnim("rest",99999,true,true);
					endif;
				endfor;
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		var CFourCC xLink="NOPE";
		var int i, iC=m_xAddons.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CGameObj pxA=m_xAddons[i].GetObj();
			if(pxA!=null)then
				pxA^.LinkAction(GetHandle(),xLink,m_avAddonOffsets[i]);
				pxA^.SetSLEAnim("rest",99999,true,true);
			endif;
		endfor;
	endproc;
	
	export proc void Delete()
		DeleteTimer(TIMER_REST_MISC);
		var int i, iC=m_xAddons.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CGameObj pxA=m_xAddons[i].GetObj();
			if(pxA!=null)then
				RemGroupedChildren(pxA^.GetGuid());
				pxA^.Delete();
			endif;
		endfor;
		super.Delete();
	endproc;
	
	export proc CObjList GetAddons();
		return m_xAddons;
	endproc;
	
endclass;
	
class CTeslaMachine inherit CBuilding
	
//	export proc void Save(^CUOFWriterNode p_pxWriterNode)
//		super.Save(p_pxWriterNode);
//		var CFourCC xBase="SeTM";
//		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
//		var ^CArc pxArc=^(pxWalk^.GetArc());
//		pxWalk^.Close();
//	endproc;
//	
//	export proc void Load(^CUOFReaderNode p_pxReaderNode)
//		if(p_pxReaderNode^.GetType()=="SeTM")then
//			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
//		else
//			super.Load(p_pxReaderNode);
//		endif;
//	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetRallySite(true);
	endproc;
	
endclass;
	
class CVolcano inherit CBuilding
	
	export const real BREAK_HEIGHT=12.0;
	export const real LAVA_RADIUS=30.0;
	const real RAISE_STEP=0.25;
	const real MAGMA_SPILL=0.25;
	const real ERUPT_DURATION=180.0;
	const real MAGMA_DAMAGE=15.0;
	const real MAGMA_FIRE=50.0;
	const int FIRE_EJECT=40059;
	const int VULCAN_DORMANT=40060;
	const int VULCAN_REACTIVATE=40061;
	const int VULCAN_SOUND=40064;
	const int MAGMA_TICK=50;
	const vec3 MAGMA_OFFSET={0.0,0.0,10.0};
	var real m_fHeight;
	var real m_fGoal;
	var int m_iState;
	var CObjHndl m_xMagma;
	var CObjHndl m_xCaster;
	var int m_iCaster;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xType="Volc";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xMagma.DoKArc(pxArc^);
		m_xCaster.DoKArc(pxArc^);
		(pxArc^) << m_iState;
		(pxArc^) << m_fHeight;
		(pxArc^) << m_fGoal;
		(pxArc^) << m_iCaster;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="Volc")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xMagma.DoKArc(pxArc^);
			m_xCaster.DoKArc(pxArc^);
			(pxArc^) << m_iState;
			(pxArc^) << m_fHeight;
			(pxArc^) << m_fGoal;
			(pxArc^) << m_iCaster;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetPlaceBlocker(true);
		m_xSink.m_xOnObjAdd=EnterDangerZone;
		m_xSink.m_xOnObjRem=LeaveDangerZone;
		if(!p_bLoad)then
			m_iState=0;
			InitEvents();
			SetHitable(false);
			SetSelectable(false);
			SetFOW(0.0);
			SetNoParticles(true);
			var vec3 vSpawn=GetPos();
			m_fHeight=vSpawn.GetZ();
			m_fGoal=CSrvWrap.GetScapeMgr().GetHeight(vSpawn.GetX(),vSpawn.GetY());
			//Henry: for leveled placement...
			if(CSrvWrap.GetGame().IsLevelEd())then
				SetHitable(true);
				SetSelectable(true);
				Erupt();
			endif;
			if(!HasPersonalRegion())then
				var vec3 vP;
				vP.SetXYZ(LAVA_RADIUS,LAVA_RADIUS,LAVA_RADIUS);
				CreatePersonalRegion("VulcanRegion_"+GetName()+"_"+Random.GetInt().ToString(), vP, 010b);
			endif;
		endif;
	endproc;
	
	export proc void IgniteBuilding(real p_fDmg, int p_iMaxCount, CObjHndl p_xSource, int p_iSource)
		return;
	endproc;
	
	export proc bool CreateBuildingCorpse()
		return true;
	endproc;
	
	export proc void SetCaster(int p_iCaster, CObjHndl p_xCaster)
		m_iCaster=p_iCaster;
		if(p_xCaster.IsValid())then
			var ^CFightingObj pxCaster=cast<CFightingObj>(p_xCaster.GetObj());
			if(pxCaster!=null)then
				m_xCaster=p_xCaster;
			endif;
		endif;
	endproc;
	
	proc bool EnterDangerZone(CObjHndl p_xObj)
		var ^CFightingObj pxFO=cast<CFightingObj>(p_xObj.GetObj());
		if(pxFO!=null /*&& CSrvWrap.GetDiplomacyMgr().GetIsEnemy(GetOwner(), pxFO^.GetOwner())*/)then
			m_xRegionObjects.Include(p_xObj);
		endif;
		return true;
	endproc;
	
	proc bool LeaveDangerZone(CObjHndl p_xObj)
		if(m_xRegionObjects.FindEntry(p_xObj)==-1)then return false; endif;
		m_xRegionObjects.RemEntry(p_xObj);
		return true;
	endproc;
	
	export proc void OnActionEnd(bool p_bBroken)
		if(m_iState==3)then
			Delete();
		endif;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		if(m_xMagma.IsValid())then
			var CFourCC xLink="NOPE";
			var ^CGameObj pxO=m_xMagma.GetObj();
			if(pxO!=null)then
				pxO^.LinkAction(GetHandle(), xLink, MAGMA_OFFSET);
			endif;
		endif;
	endproc;
	
	export proc void Erupt()
		SetNoParticles(false);
		m_iState=1;
		CreateTimer(FIRE_EJECT, CGameTimeSpan.OneSecond() * MAGMA_SPILL, true);
		CreateTimer(VULCAN_SOUND, CGameTimeSpan.OneSecond() * 3.0f, true);
		CreateTimer(VULCAN_DORMANT, CGameTimeSpan.OneSecond() * (Random.MTRandF(ERUPT_DURATION * 0.75f, ERUPT_DURATION * 1.5f)), false);
		SetNoParticles(false);
		var CFourCC xLink="NOPE";
		var CObjHndl xHndl=AddFX("volcano_fire",-1.0);
		if(xHndl.IsValid())then
			xHndl.GetObj()^.LinkAction(GetHandle(),xLink);
		endif;
		m_xMagma=AddFX("volcano_magma",-1.0);
		if(m_xMagma.IsValid())then
			m_xMagma.GetObj()^.LinkAction(GetHandle(), xLink, MAGMA_OFFSET);
		endif;
	endproc;
	
	proc void MagmaBurn()
		var int i,iC=m_xRegionObjects.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(m_xRegionObjects[i]==m_xCaster)then continue; endif;
			var ^CFightingObj pxObj=cast<CFightingObj>(m_xRegionObjects[i].GetObj());
			if(pxObj==null)then continue; endif;
			if(pxObj^.GetClassName()=="volcano")then continue; endif;
			if(!pxObj^.IsHitable())then continue; endif;
			if(pxObj^.GetTransportObj().IsValid())then continue; endif;
			//if(!CSrvWrap.GetDiplomacyMgr().GetIsEnemy(m_iCaster, pxObj^.GetOwner()))then continue; endif;
			var CObjHndl xEnemy=CObjHndl.Invalid();
			//if(m_xCaster.IsValid())then
				//xEnemy=m_xCaster;
			//endif;
			pxObj^.TakeDirectMeleeDmg(MAGMA_DAMAGE, xEnemy);
			if(pxObj^.GetType()=="BLDG")then
				pxObj^.IgniteBuilding(MAGMA_FIRE, MAGMA_TICK, GetHandle(),GetOwner());
				//pxObj^.SetLastEnemy(xEnemy);
			endif;
			//pxObj^.SetLastDamage(m_iCaster);
			pxObj^.UpdateAttacker(this);
		endfor;
	endproc;
	
	export proc void Sleep()
		SetNoParticles(true);
		m_iState=2;
		if(HasTimer(FIRE_EJECT))then DeleteTimer(FIRE_EJECT); endif;
		if(HasTimer(VULCAN_SOUND))then DeleteTimer(VULCAN_SOUND); endif;
		ClearFX();
		m_xMagma=CObjHndl.Invalid();
		SetNoParticles(true);
		if(HasTimer(VULCAN_REACTIVATE))then DeleteTimer(VULCAN_REACTIVATE); endif;
		Random.Seed();
		CreateTimer(VULCAN_REACTIVATE, CGameTimeSpan.OneSecond() * (Random.MTRandF(ERUPT_DURATION, ERUPT_DURATION*2.0f)), false);
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==FIRE_EJECT)then
				MagmaBurn();
			elseif(p_rxEvtPtr.GetInt(0)==VULCAN_DORMANT)then
				Sleep();
			elseif(p_rxEvtPtr.GetInt(0)==VULCAN_SOUND)then
				CSoundEvent.PlayAll("FX_CVolcano",1,GetPos());
			elseif(p_rxEvtPtr.GetInt(0)==VULCAN_REACTIVATE)then
				if(HasTimer(VULCAN_REACTIVATE))then DeleteTimer(VULCAN_REACTIVATE); endif;
				Erupt();
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	export proc bool IsRisen()
		var vec3 vPos=GetPos();
		if(m_fHeight >= m_fGoal)then
			vPos.SetZ(m_fGoal);
			SetPos(vPos);
			return true;
		endif;
		m_fHeight += RAISE_STEP;
		vPos.SetZ(m_fHeight);
		SetPos(vPos);
		InvokeGenericSCEvent(45,5.0);
		return false;
	endproc;
	
	export proc void Sink()
		m_iState=3;
		var vec3 vP=GetPos();
		vP.SetZ(0.0f);
		MoveAction(vP, 2.0f);
	endproc;
	
	export proc void Delete()
		//DeletePersonalRegion();
		if(m_iState!=0)then
			ClearFX();
			m_xMagma=CObjHndl.Invalid();
			var vec3 vPos=GetPos();
			vPos.SetZ(vPos.GetZ()+6.0f);
			if(m_iState==1)then
				CreateCustomFX(3,vPos,true);
				new CAreaDamage(CObjHndl.Invalid(),10.0f,MAGMA_DAMAGE*2.0f,MAGMA_DAMAGE*0.5f,-1,GetPos(),12);
			endif;
			var ^CCustomCorpse pxGameObj=cast<CCustomCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("mirage_custom_corpse",GetOwner(),GetPos(),GetRotation()));
			if(pxGameObj!=null)then
				pxGameObj^.SetSource(this);
				pxGameObj^.Init(GetName(), 30.0, "Ash_Lavastream_01");
				pxGameObj^.SetPlaceBlocker(true);
				pxGameObj^.SetNoParticles(!(m_iState==1));
			endif;
		endif;
		super.Delete();
	endproc;
	
	export proc void OnKill()
		return;
	endproc;
	
	export proc string GetReportCode()
		return "";
	endproc;
	
endclass;
	
class CZeppelinLaunchPad inherit CBuilding
	
	export var vec3		m_vHeight;
	export var int		m_iBuildLevel;
	export var bool		m_bReady;
	export var int		m_iConstructLevel;
	
	export constructor()
		m_bReady =false;
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="ZeLa"; //ZeppelinLaunchPad
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		(pxArc^) << m_vHeight;
		(pxArc^) << m_iBuildLevel;
		(pxArc^) << m_bReady;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="ZeLa")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			(pxArc^) << m_vHeight;
			(pxArc^) << m_iBuildLevel;
			(pxArc^) << m_bReady;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc bool DoesCountInUnitLimit()
		return true;
	endproc;
	
	export proc string GetCranesName()
		return "hu";
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetNoParticles(true);
		if(!p_bLoad)then
			var int iLevel=(m_xTechTree.GetValueI("/Actions/"+GetTribeName()+"/Build/"+GetType().ToString()+"/"+GetClassName()+"/results/0/flags/level",1)-1);
			SetLevelClean(iLevel);
			m_iBuildLevel=iLevel;
			CreatePersonalProduceUnit(false);
		endif;
		var vec3 vPosition=GetPos();
		m_vHeight=vPosition;
		m_vHeight.SetZ(vPosition.GetZ()-11.0f);
	endproc;
	
	export proc void CreatePersonalProduceUnit(bool p_bSetReady)
		var ^CVirtualProduceUnit pxUnit=cast<CVirtualProduceUnit>(CSrvWrap.GetObjMgr()^.CreateObj("Virtual_Produce_Unit",GetOwner(),GetPos()));
		if(pxUnit!=null)then
			pxUnit^.Init(GetHandle());
			pxUnit^.SetLevelClean(m_iBuildLevel);
			m_xProduceUnit=pxUnit^.GetHandle();
			if(p_bSetReady)then
				pxUnit^.SetReady();
			endif;
		endif;
		return;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
		if(IsTrapped() &&!(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill"))then return; endif;
		super.ReactToGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams,p_bQ,p_bS,p_bA);
	endproc;
	
	export proc void SetReady()
		m_bReady=true;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("unit_count",false);
		endif;
		SetVisible(false);
		super.SetReady();
		Die();
	endproc;
	
	export proc void Die()
		if(!IsDead())then
			var string sTribe=GetTribeName();
			sTribe.MakeLower();
			m_fHitpoints=0.0f;
			SetDead(true);
			if(m_bReady)then
				var ^CZeppelin pxZeppelin=cast<CZeppelin>(CSrvWrap.GetObjMgr()^.CreateObj(sTribe+"_zeppelin",GetOwner(),m_vHeight,GetRotation()));
				if(pxZeppelin!=null)then
					var ^CAttribs pxAttr=pxZeppelin^.GetAttribs();
					if(pxAttr!=null)then
						pxAttr^.SetValue("clientpyramid_replacecard", GetName());
					endif;
					pxZeppelin^.SetLevelClean(m_iBuildLevel);
				endif;
			endif;
			Delete();
		endif;
	endproc;
	
	export proc void CreateCorpse()
	endproc;
	
	export proc bool CreateBuildingCorpse()
		return true;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		if(!IsBuildMode())then
			SetReady();
		endif;
	endproc;
	
	export proc string GetReportCode()
		return "unit";
	endproc;
	
endclass;
	
	//========================================================================================
	//=== Projectiles ========================================================================
	//========================================================================================
	
class CAjeBigDinoBullet inherit CLongRangeProjectile
	
	proc void OnImpact()
		ValidateObjects();
		if(m_pxFighter!=null)then
			var ^CAjeBigDinoAmmoEgg pxO=cast<CAjeBigDinoAmmoEgg>(CSrvWrap.GetObjMgr()^.CreateObj("aje_big_ammo_dino_dest", m_pxFighter^.GetOwner(), m_vTarget));
			var vec3 vP;
			vP=m_vTarget;
			if(pxO!=null)then
				pxO^.SetSpawner(m_xFighter,m_pxFighter^.GetCurEnemy(),m_pxFighter^.GetLevel());
				pxO^.SetPos(vP);
			endif;
		endif;
	endproc;
	
endclass;
	
class CAjeBigDinoAmmoEgg inherit CGameObj
	
	var bool m_bAnimPlayed;
	var bool m_bMoved;
	var CObjHndl m_xFighter;
	
	export proc void OnInit(bool p_bLoad)
		m_bAnimPlayed=true;
		var vec3 vPos=GetPos();
		var real fScapeZ=CSrvWrap.GetScapeMgr().GetHeight(vPos.GetX(), vPos.GetY());
		var real fSea=CSrvWrap.GetScapeMgr().GetSeaLevel();
		if(!p_bLoad)then
			if(fScapeZ+5.0f>=fSea)then
				AnimAction("destroy");
				var vec3 vPos=GetPos();
				var real fScapeZ=CSrvWrap.GetScapeMgr().GetHeight(vPos.GetX(), vPos.GetY());
				var real fSea=CSrvWrap.GetScapeMgr().GetSeaLevel();
				if(fScapeZ+5.0f>=fSea)then
					var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("aje_psittacosaurus", GetOwner());
					if(pxO!=null)then
						pxO^.SetPos(GetPos());
						m_xFighter = pxO^.GetHandle();
					endif;
				endif;
			else
				MoveAction(GetPos()+{0.1f,0.0f,0.0f}, 1.0f);
			endif;
		endif;
	endproc;
	
	export proc void OnActionEnd(bool p_bBroken)
		if(m_bMoved)then
			Delete();
			return;
		endif;
		var vec3 vPos=GetPos();
		var real fScapeZ=CSrvWrap.GetScapeMgr().GetHeight(vPos.GetX(), vPos.GetY());
		vPos.SetZ(fScapeZ-4.0f);
		MoveAction(vPos,2.0f);
		m_bMoved=true;
	endproc;
	
	export proc void SetSpawner(CObjHndl p_xFighter, CObjHndl p_xCurEnemy, int p_iLevel)
		if(m_xFighter.IsValid())then
			var ^CFightingObj pxO = cast<CFightingObj>(m_xFighter.GetObj());
			if(pxO!=null)then
				pxO^.SetSpawningPool(p_xFighter);
				pxO^.SetLevelClean(p_iLevel);
				if(p_xCurEnemy.IsValid())then
					pxO^.SetCurEnemy(p_xCurEnemy);
					pxO^.ExamineEnemies(true);
				endif;
			endif;
		endif;
	endproc;
	
endclass;
	
class CAjeExploDinoBullet inherit CLongRangeProjectile
	
	proc void OnImpact()
		ValidateObjects();
		if(m_pxFighter!=null)then
			var ^CAjeExploDinoAmmoEgg pxO=cast<CAjeExploDinoAmmoEgg>(CSrvWrap.GetObjMgr()^.CreateObj("aje_explo_ammo_dino_dest", m_pxFighter^.GetOwner(), m_vTarget));
			var vec3 vP;
			vP=m_vTarget;
			if(pxO!=null)then
				pxO^.SetSpawner(m_xFighter,m_pxFighter^.GetCurEnemy(),m_pxFighter^.GetLevel());
				pxO^.SetPos(vP);
			endif;
		endif;
	endproc;
	
endclass;
	
class CAjeExploDinoAmmoEgg inherit CGameObj
	
	var bool m_bAnimPlayed;
	var bool m_bMoved;
	var CObjHndl m_xFighter;
	
	export proc void OnInit(bool p_bLoad)
		m_bAnimPlayed=true;
		var vec3 vPos=GetPos();
		var real fScapeZ=CSrvWrap.GetScapeMgr().GetHeight(vPos.GetX(), vPos.GetY());
		var real fSea=CSrvWrap.GetScapeMgr().GetSeaLevel();
		if(!p_bLoad)then
			if(fScapeZ+5.0f>=fSea)then
				AnimAction("destroy");
				var vec3 vPos=GetPos();
				var real fScapeZ=CSrvWrap.GetScapeMgr().GetHeight(vPos.GetX(), vPos.GetY());
				var real fSea=CSrvWrap.GetScapeMgr().GetSeaLevel();
				if(fScapeZ+5.0f>=fSea)then
					var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("aje_heterodontosaurus", GetOwner());
					if(pxO!=null)then
						pxO^.SetPos(GetPos());
						m_xFighter = pxO^.GetHandle();
					endif;
				endif;
			else
				MoveAction(GetPos()+{0.1f,0.0f,0.0f}, 1.0f);
			endif;
		endif;
	endproc;
	
	export proc void OnActionEnd(bool p_bBroken)
		if(m_bMoved)then
			Delete();
			return;
		endif;
		var vec3 vPos=GetPos();
		var real fScapeZ=CSrvWrap.GetScapeMgr().GetHeight(vPos.GetX(), vPos.GetY());
		vPos.SetZ(fScapeZ-4.0f);
		MoveAction(vPos,2.0f);
		m_bMoved=true;
	endproc;
	
	export proc void SetSpawner(CObjHndl p_xFighter, CObjHndl p_xCurEnemy, int p_iLevel)
		if(m_xFighter.IsValid())then
			var ^CFightingObj pxO = cast<CFightingObj>(m_xFighter.GetObj());
			if(pxO!=null)then
				pxO^.SetSpawningPool(p_xFighter);
				pxO^.SetLevelClean(p_iLevel);
				if(p_xCurEnemy.IsValid())then
					pxO^.SetCurEnemy(p_xCurEnemy);
					pxO^.ExamineEnemies(true);
				endif;
			endif;
		endif;
	endproc;
	
endclass;
	
class CMeteorite inherit CGameObj
	
	export const real		IMPACT_RADIUS=30.0f;
	var int							m_iMeteoriteOwner;
	var CObjHndl				m_xOwner;
	var vec3						m_vTarget;
	const real					MAX_DMG=250.0f;
	const real					MIN_DMG=250.0f;
	const int						FALL_TIMER=40056;
	
	export proc void OnInit(bool p_bLoad)
		SetVisible(false);
		InitEvents();
		if(!p_bLoad)then
			SetType("PROD");
		endif;
		SetHitable(false);
		SetSelectable(false);
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xType="Meti";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xOwner.DoKArc(pxArc^);
		(pxArc^) << m_iMeteoriteOwner;
		(pxArc^) << m_vTarget;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="Meti")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xOwner.DoKArc(pxArc^);
			(pxArc^) << m_iMeteoriteOwner;
			(pxArc^) << m_vTarget;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Set(vec3 p_vTarget, CObjHndl p_xOwner, int p_iOwner)
		SetGFX("rolling_stone");
		m_xOwner=p_xOwner;
		m_vTarget=p_vTarget;
		m_iMeteoriteOwner=p_iOwner;
		CreateTimer(FALL_TIMER, CGameTimeSpan.OneSecond() * 3.0, false);
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==FALL_TIMER)then
				Fall();
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	export proc void Fall()
		SetVisible(true);
		SetShowSpeedLines(true);
		if(HasTimer(FALL_TIMER))then DeleteTimer(FALL_TIMER);endif;
		if(m_vTarget!={0.0,0.0,0.0})then
			m_vTarget.SetZ(m_vTarget.GetZ()-2.5f);
			BallisticAction(m_vTarget,50.0,3.0);
			if(!HasAction())then
				Delete();
			endif;
		else
			Delete();
		endif;
	endproc;
	
	proc void OnActionStart()
	endproc;
	
	proc void OnActionEnd(bool p_bBroken)
		if(m_vTarget!={0.0,0.0,0.0})then
			var CObjHndl xDruid=CObjHndl.Invalid();
			if(m_xOwner.IsValid())then
				xDruid=m_xOwner;
			endif;
			new CAreaDamage(xDruid,IMPACT_RADIUS,MAX_DMG,MIN_DMG,m_iMeteoriteOwner,m_vTarget,10,100.0f);
			var vec3 vEffect=GetPos();
			var int m=0;
			if(IsInWater())then
				m=1;
				vEffect.SetZ(CSrvWrap.GetScapeMgr().GetSeaLevel()+2.0f);
				CreateCustomFX(4,vEffect,false);
			else
				CreateCustomFX(0,vEffect,true);
				CreateCustomFX(5,vEffect,true);
			endif;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel!=null)then
				var int i;
				for(i=0)cond(i<8)iter(i++)do
					var ^CPlayer pxPlayer=pxLevel^.GetPlayer(i);
					if(pxPlayer!=null)then
						var ^CAiPlayer pxAiPl=cast<CAiPlayer>(pxPlayer);
						if(pxAiPl==null)then
							CSrvWrap.SendGenericEvtToPlayer(i, "meteor\t" +vEffect.ToString()+"\t"+m.ToString());
						endif;
					endif;
				endfor;
			endif;
		endif;
		Delete();
	endproc;
	
	export proc void CreateCustomFX(int p_iIndex, vec3 p_vPos, bool p_bGroundLevel)
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel!=null)then
			if(p_bGroundLevel)then
				var real fHeight=CSrvWrap.GetScapeMgr().GetHeight(p_vPos.GetX(),p_vPos.GetY());
				p_vPos.SetZ(fHeight);
			endif;
			var int i;
			for(i=0)cond(i<8)iter(i++)do
				var ^CPlayer pxPlayer=pxLevel^.GetPlayer(i);
				if(pxPlayer!=null)then
					var ^CAiPlayer pxAiPl=cast<CAiPlayer>(pxPlayer);
					if(pxAiPl==null)then
						CSrvWrap.SendGenericEvtToPlayer(i, "mrg\t"+p_iIndex.ToString()+"\t" +p_vPos.ToString());
					endif;
				endif;
			endfor;
		endif;
	endproc;
	
endclass;
	
class CPirateShipArrow inherit CArrow
	
	var int m_iIndex;
	
	export proc void SetIndex(int p_iIdx)
		m_iIndex=p_iIdx;
	endproc;
	
	export proc void Shoot()
		SetVisible(true);
		DeleteTimer(CArrow.START_TIMER);
		ValidateObjects();
		var bool bLinkRemoved=false;
		if(ValidateObjects())then
			TerminateAction();
			var vec3 vSelfPos=m_pxFighter^.GetProjectileStartPos(m_iIndex);
			var real fSpeed=m_fProjectileSpeed;
			var real fFallOff=m_fProjectileFallOff;
			SetPos(vSelfPos);
			var vec3 vPos=m_pxEnemy^.GetPos();
			var real fRadius;
			m_vTarget=vPos;
			if(m_bRandomize)then
				RandomizePosInRadius(m_vTarget, m_fJitter);
			endif;
			var ^CTrap pxBldg=cast<CTrap>(m_pxEnemy); 
			var ^CGrowingField pxField=cast<CGrowingField>(m_pxEnemy); 
			if(pxBldg==null&&pxField==null)then
				if(!m_pxEnemy^.FindNearestAttackZone(m_pxFighter^.GetPos(),vPos,fRadius,2.0,100.0))then
					m_vFlyPos=vPos;
					if(m_bRandomize)then
						RandomizePosInRadius(vPos, m_fJitter);
						m_vFlyPos=vPos;
						m_vFlyPos.SetZ( m_vFlyPos.GetZ()+m_pxEnemy^.GetSize().GetZ()*0.3 );
					else
						CalculatePointOfImpact(vSelfPos, m_vFlyPos, m_pxEnemy^.GetSize(), fSpeed, -fFallOff);
					endif;
				else
					RandomizePosInRadius(vPos,fRadius);
					//m_vTarget=vPos;
					m_vFlyPos=vPos;
					CalculatePointOfImpact(vSelfPos, m_vFlyPos, {0.0,0.0,0.0}, fSpeed, -fFallOff);
				endif;
			else
				//m_vTarget=vPos;
				m_vFlyPos=vPos;
			endif;
			var CProjectileMgr.CInitDesc xPInit;
			xPInit.m_hSourceObj=m_xFighter;
			xPInit.m_hTargetObj=m_xEnemy;
			xPInit.m_iOwner=GetOwner();
			xPInit.m_sGFX=GetGfxName();
			xPInit.m_vSrc=vSelfPos;
			xPInit.m_vDst=m_vFlyPos;
			xPInit.m_fSpeed=fSpeed;
			xPInit.m_fG=fFallOff;
			xPInit.m_bColDet=true;
			xPInit.m_sImpactAnim="impact";
			var CProjectileMgr.CSpawnDesc xSpawn;
			if(!CSrvWrap.GetObjMgr()^.GetProjectileMgr().SpawnProjectile(xPInit,xSpawn))then
				Delete();
			endif;
			WaitAction(xSpawn.m_fImpactDelay);
			m_bFired=true;
		elseif(m_bAttackScape)then
			if(m_xFighter.IsValid())then
				var vec3 vSelfPos=m_pxFighter^.GetProjectileStartPos(m_iIndex);
				if(m_bRandomize)then
					RandomizePosInRadius(m_vTarget, m_fJitter);
				endif;
				var CProjectileMgr.CInitDesc xPInit;
				xPInit.m_hSourceObj=m_xFighter;
				//xPInit.m_hTargetObj=m_xEnemy;
				xPInit.m_iOwner=GetOwner();
				xPInit.m_sGFX=GetGfxName();
				xPInit.m_vSrc=vSelfPos;
				xPInit.m_vDst=m_vTarget;
				xPInit.m_fSpeed=m_fProjectileSpeed;
				xPInit.m_fG=m_fProjectileFallOff;
				xPInit.m_bColDet=true;
				xPInit.m_sImpactAnim="impact";
				var CProjectileMgr.CSpawnDesc xSpawn;
				if(!CSrvWrap.GetObjMgr()^.GetProjectileMgr().SpawnProjectile(xPInit,xSpawn))then
					Delete();
				endif;
				WaitAction(xSpawn.m_fImpactDelay);
				m_bFired=true;
			endif;
		else
			Delete();
		endif;
	endproc;
	
endclass;
	
class CNeurotoxicDart inherit CArrow
	
	proc void OnImpact()
		ValidateObjects();
		if(m_pxEnemy!=null)then
			m_pxEnemy^.SetPinnedDown(true,15.0);
			m_pxEnemy^.SetSedated(true,15.0);
			m_pxEnemy^.SetBlinded(true,15.0);
		endif;
		Delete();
	endproc;
	
	export proc void Set(^CFightingObj p_pxFighter, ^CFightingObj p_pxEnemy)
		Set(p_pxFighter, p_pxEnemy, p_pxFighter^.GetDmg(), p_pxFighter^.GetEndDmg(), p_pxFighter^.GetHitRange(), p_pxFighter^.GetProjectileJitter(), p_pxFighter^.GetProjectileDelay(), p_pxFighter^.GetWeaponSizeClass());
		m_bDirect=false;
	endproc;
	
	export proc void SetXtraDelay(^CFightingObj p_pxFighter, ^CFightingObj p_pxEnemy, real p_fXtraDelay)
		Set(p_pxFighter, p_pxEnemy, p_pxFighter^.GetDmg(), p_pxFighter^.GetEndDmg(), p_pxFighter^.GetHitRange(), p_pxFighter^.GetProjectileJitter(), p_pxFighter^.GetProjectileDelay() * p_fXtraDelay,p_pxFighter^.GetWeaponSizeClass());
		m_bDirect=false;
	endproc;

	export proc void Set(^CFightingObj p_pxFighter, ^CFightingObj p_pxEnemy, real p_fDmg)
		Set(p_pxFighter, p_pxEnemy, p_fDmg,  p_pxFighter^.GetEndDmg(), p_pxFighter^.GetHitRange(),  p_pxFighter^.GetProjectileJitter(), p_pxFighter^.GetProjectileDelay(),p_pxFighter^.GetWeaponSizeClass());
		m_bDirect=true;
	endproc;

	export proc void Set(^CFightingObj p_pxFighter, ^CFightingObj p_pxEnemy, real p_fDmg, real p_fEndDmg, real p_fHitRange)
		Set(p_pxFighter, p_pxEnemy, p_fDmg, p_fEndDmg, p_fHitRange,  p_pxFighter^.GetProjectileJitter(), 0.75f,p_pxFighter^.GetWeaponSizeClass());
	endproc;

	export proc void Set(^CFightingObj p_pxFighter, ^CFightingObj p_pxEnemy, real p_fDmg, real p_fEndDmg, real p_fHitRange, real p_fJitterRange, real p_fDelay, int p_iSizeClass)
		super.Set(p_pxFighter, p_pxEnemy, p_fDmg, p_fEndDmg, p_fHitRange, p_fJitterRange, 1.72, p_iSizeClass);
	endproc;
	
	export proc void Set(^CFightingObj p_pxFighter, ^CFightingObj p_pxEnemy, ^CBuildUpWeapon p_pxBuildUp)
		super.Set(p_pxFighter, p_pxEnemy, p_pxBuildUp);
	endproc;

endclass;
	
class CDinamit inherit CGameObj
	
	var CObjHndl				m_xOwner;
	var CObjHndl				m_xSource;
	var int							m_iSource;
	const int						EXPLOSION_TIMER=40078;
	export const real		IMPACT_RADIUS=25.0f;
	const real					MAX_DMG=500.0f;
	const real					MIN_DMG=100.0f;
	
	export proc void OnInit(bool p_bLoad)
		SetVisible(false);
		InitEvents();
		if(!p_bLoad)then
			SetType("PROD");
		endif;
		SetHitable(false);
		SetSelectable(false);
	endproc;
	
	export proc void OnPostLoad()
		if(m_xOwner.IsValid())then
			var CFourCC xLink="NONE";
			LinkAction(m_xOwner, xLink);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xType="Dnmt";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xOwner.DoKArc(pxArc^);
		m_xSource.DoKArc(pxArc^);
		(pxArc^) << m_iSource;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="Dnmt")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xOwner.DoKArc(pxArc^);
			m_xSource.DoKArc(pxArc^);
			(pxArc^) << m_iSource;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Set(CObjHndl p_xSource, int p_iSource, real p_fTime, CObjHndl p_xOwner)
		m_xSource=p_xSource;
		m_iSource=p_iSource;
		m_xOwner=p_xOwner;
		if(m_xOwner.IsValid())then
			var CFourCC xLink="NONE";
			LinkAction(m_xOwner, xLink);
		endif;
		CreateTimer(EXPLOSION_TIMER, CGameTimeSpan.OneSecond() * p_fTime, false);
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==EXPLOSION_TIMER)then
				Detonate();
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	export proc void Detonate()
		if(HasTimer(EXPLOSION_TIMER))then DeleteTimer(EXPLOSION_TIMER);endif;
		if(m_xOwner.IsValid())then
			var ^CFightingObj pxOwner=cast<CFightingObj>(m_xOwner.GetObj());
			if(pxOwner!=null)then
				var vec3 vPos=pxOwner^.GetPos();
				CreateCustomFX(1,vPos,true);
//				pxOwner^.TakeDirectMeleeDmg(999999.9,m_iSource,m_xSource);
				pxOwner^.OneHitKilling(m_iSource,m_xSource);
				new CAreaDamage(m_xSource,IMPACT_RADIUS,MAX_DMG,MIN_DMG,m_iSource,vPos,10);
			endif;
			Delete();
		else
			Delete();
		endif;
	endproc;
	
	export proc void CreateCustomFX(int p_iIndex, vec3 p_vPos, bool p_bGroundLevel)
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel!=null)then
			if(p_bGroundLevel)then
				var real fHeight=CSrvWrap.GetScapeMgr().GetHeight(p_vPos.GetX(),p_vPos.GetY());
				p_vPos.SetZ(fHeight);
			endif;
			var int i;
			for(i=0)cond(i<8)iter(i++)do
				var ^CPlayer pxPlayer=pxLevel^.GetPlayer(i);
				if(pxPlayer!=null)then
					var ^CAiPlayer pxAiPl=cast<CAiPlayer>(pxPlayer);
					if(pxAiPl==null)then
						CSrvWrap.SendGenericEvtToPlayer(i, "mrg\t"+p_iIndex.ToString()+"\t" +p_vPos.ToString());
					endif;
				endif;
			endfor;
		endif;
	endproc;
	
endclass;
	
	//========================================================================================
	//=== MISC ===============================================================================
	//========================================================================================
	
class CDecorChar inherit CGameObj
	
	export proc void OnInit(bool p_bLoad)
		SetType("DECO");
		SetSelectable(false);
		SetHitable(false);
		var ^CAttribs pxA=GetAttribs();
		var ^CGameSrv pxGame=^(CSrvWrap.GetGame());
		if(pxGame==null)then return; endif;
		if(pxGame^.IsLevelEd())then return; endif;
		if(GetClassName()== "trader_deco")then
			SetAnim("res_fight_standanim",3);
		//elseif(GetClassName()== "zxy_seismo")then
			//SetAnim("standanim",3);
		endif;
		
	endproc;
endclass;
	
class CHCGate inherit CDecoObj
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetPlaceBlocker(false);
		SetFreeBorderBlocker(false);
		RemovePFBlocker();
		CSrvWrap.GetPathfinder().RemPFBlocker(this);
		//SetPFBlockerMask();
		SetAnim("anim",0,44);
	endproc;
	
endclass;
	
class CHiveMind inherit CFightingObj
//								inherit CGameObj
	
	export var CObjHndl m_xParent;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
//		if(!p_bLoad)then
//			SetType("PROD");
//		endif;
		SetCanWalk(false);
		SetCanSwim(false);
		SetCanFly(false);
		SetHitable(false);
//		SetSelectable(false);
		SetVisible(true);
//		if(!p_bLoad)then
//			SetCanFightAttrib(false);
//		endif;
	endproc;
	
	export proc void Die()
		Delete();
	endproc;
	
	export proc void Init(CObjHndl p_xParent)
		m_xParent=p_xParent;
		var CFourCC xLink;
		LinkAction(m_xParent, xLink);
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="HiMi";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,0);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xParent.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="HiMi")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xParent.DoKArc(pxArc^);
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		if(!m_xParent.IsValid())then
			Delete();
		endif;
	endproc;
	
	export proc CObjHndl GetParent()
		return m_xParent;
	endproc;
	
	export proc void ReactToGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams, bool p_bQ, bool p_bS, bool p_bA)
//		if(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="Kill")then return; endif;
		if(m_xParent.IsValid())then
			var ^CFightingObj pxParent=cast<CFightingObj>(m_xParent.GetObj());
			if(pxParent==null)then return; endif;
			if(pxParent^.GetCmdID()!=GetOwner())then return; endif;
			if(pxParent^.IsUnavailable())then return; endif;
			if(p_sMiscParams.Find("/Kill")!=-1||p_sCommand=="kill")then
				pxParent^.RetainConsciousness();
				return;
			endif;
			pxParent^.ReactToGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams, p_bQ, p_bS, p_bA);
		endif;
		return;
	endproc;
	
	export proc bool CanBuild()
		return true;
	endproc;
	
	export proc bool DoesCountInUnitLimit()
		return false;
	endproc;
	
	proc void AddUnit()
		return;
	endproc;
	
	proc void RemoveUnit()
		return;
	endproc;
	
endclass;
	
class CMrgSprt inherit CGameObj
	
	const int TIMER_SPIRIT_DEATH			= 40161;
	const int TIMER_SPIRIT_VANISH			= 40160;
	const int TIMER_SPIRIT_APPEAR			= 40159;
	const int TIMER_SPIRIT_POSTLOAD		= 40164;
	
	var CGameTime											m_xAscensionStart;
	var Quat													m_qSprtRotation;
	var vec3													m_vSprtRotation;
	var vec3													m_vSprtPosition;
	var string												m_sSprtClass;
	var string												m_sSprtDesc;
	var string												m_sSprtGFX;
	var int														m_iSprtLevel;
	var int														m_iSprtOwner;
	var bool													m_bReanimation;
	var int														m_iSprtCount;
	var int														m_iSprtSupply;
	var CObjHndl											m_xSprtCorpse;
	var int														m_iSprtKC;
	var int														m_iSprtKH;
	var int														m_iSprtAS;
	var string												m_sID;
	var string												m_sDur;
	var string												m_sStart;
	var string												m_sDeath;
	var real													m_fReanimDur;
	var real													m_fSprtLifeTime;
	var real													m_fSprtRadius;
	var real													m_fAscSpeed;
	var array string									m_asSprtFilters;
	var bool													m_bVIP;
	var bool													m_bDeactivated;
	var CObjList											m_xResurrecterList;
	var int														m_iSprtHP;
	var int														m_iResearch;
	var CObjHndl											m_xSprtPyCO;
	var bool													m_bPreState;
	var string												m_sSprtNode;
	var bool													m_bMakePyCO;
	var vec3													m_vFinalDestination;
	var int														m_iProgress;
	var int														m_iLastRecord;
	var real													m_fLastProgress;
	var int 													m_iWouldBeOwner;
	
	export constructor()
		m_bDeactivated=false;
		m_bPreState=false;
		m_bMakePyCO=false;
		m_fAscSpeed=0.25f;
		m_sSprtNode="";
		m_iProgress=0;
		m_iLastRecord=0;
		m_fLastProgress=0.0f;
		m_iWouldBeOwner=-1;
	endconstructor;
	
	export destructor()
		var ^CPyramidCardObject pxTmp = cast<CPyramidCardObject>(m_xSprtPyCO.GetObj());
		if(pxTmp!=null)then
			pxTmp^.SetSpiritHandle(CObjHndl.Invalid());
			CSrvWrap.GetObjMgr()^.DeleteObject(pxTmp);
			m_xSprtPyCO=CObjHndl.Invalid();
		endif;
		if(m_iSprtCount>0)then
			var ^CPlayer pxPlayer=CSrvWrap.GetCurLevel()^.GetPlayer(m_iWouldBeOwner);
			if(pxPlayer!=null)then
				var ^CAttribs pxPlAttr=pxPlayer^.GetAttribs();
				if(pxPlAttr!=null)then
					pxPlAttr^.SetValue("virtual_supply", pxPlAttr^.GetValueInt("virtual_supply")-m_iSprtSupply);
					pxPlAttr^.SetValue(m_sSprtNode, pxPlAttr^.GetValueInt(m_sSprtNode)-1);
				endif;
			endif;
		endif;
	enddestructor;
	
	export proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="NMST")then
			var int iVersion=p_pxNode^.GetVersion();
			var ^CArc pxArc=^(p_pxNode^.GetArc());
			(pxArc^) << m_qSprtRotation;
			(pxArc^) << m_vSprtPosition;
			(pxArc^) << m_vSprtRotation;
			(pxArc^) << m_sSprtClass;
			(pxArc^) << m_sSprtDesc;
			(pxArc^) << m_sSprtGFX;
			(pxArc^) << m_iSprtLevel;
			(pxArc^) << m_iSprtOwner;
			(pxArc^) << m_bReanimation;
			(pxArc^) << m_bVIP;
			(pxArc^) << m_iSprtCount;
			(pxArc^) << m_iSprtSupply;
			(pxArc^) << m_iSprtKC;
			(pxArc^) << m_iSprtKH;
			(pxArc^) << m_iSprtAS;
			(pxArc^) << m_sID;
			(pxArc^) << m_sDur;
			(pxArc^) << m_sStart;
			(pxArc^) << m_sDeath;
			(pxArc^) << m_fReanimDur;
			(pxArc^) << m_fSprtLifeTime;
			(pxArc^) << m_bDeactivated;
			(pxArc^) << m_bPreState;
			(pxArc^) << m_iSprtHP;
			(pxArc^) << m_iResearch;
			(pxArc^) << m_fSprtRadius;
			(pxArc^) << m_fAscSpeed;
			(pxArc^) << m_sSprtNode;
			var int i, iC;
			(pxArc^) << iC;
			m_asSprtFilters=iC;
			for(i=0)cond(i<iC)iter(i++)do
				(pxArc^) << m_asSprtFilters[i];
			endfor;
			m_xSprtCorpse.DoKArc(pxArc^);
			m_xSprtPyCO.DoKArc(pxArc^);
			m_xAscensionStart.DoKArc(pxArc^);
			m_xResurrecterList.DoKArc(pxArc^);
			(pxArc^) << m_bMakePyCO;
			(pxArc^) << m_vFinalDestination;
			(pxArc^) << m_iProgress;
			(pxArc^) << m_iLastRecord;
			(pxArc^) << m_fLastProgress;
			(pxArc^) << m_iWouldBeOwner;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="NMST";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,2);
		var ^CArc pxArc=^(pxN^.GetArc());
		(pxArc^) << m_qSprtRotation;
		(pxArc^) << m_vSprtPosition;
		(pxArc^) << m_vSprtRotation;
		(pxArc^) << m_sSprtClass;
		(pxArc^) << m_sSprtDesc;
		(pxArc^) << m_sSprtGFX;
		(pxArc^) << m_iSprtLevel;
		(pxArc^) << m_iSprtOwner;
		(pxArc^) << m_bReanimation;
		(pxArc^) << m_bVIP;
		(pxArc^) << m_iSprtCount;
		(pxArc^) << m_iSprtSupply;
		(pxArc^) << m_iSprtKC;
		(pxArc^) << m_iSprtKH;
		(pxArc^) << m_iSprtAS;
		(pxArc^) << m_sID;
		(pxArc^) << m_sDur;
		(pxArc^) << m_sStart;
		(pxArc^) << m_sDeath;
		(pxArc^) << m_fReanimDur;
		(pxArc^) << m_fSprtLifeTime;
		(pxArc^) << m_bDeactivated;
		(pxArc^) << m_bPreState;
		(pxArc^) << m_iSprtHP;
		(pxArc^) << m_iResearch;
		(pxArc^) << m_fSprtRadius;
		(pxArc^) << m_fAscSpeed;
		(pxArc^) << m_sSprtNode;
		var int i, iC;
		iC=m_asSprtFilters.NumEntries();
		(pxArc^) << iC;
		for(i=0)cond(i<iC)iter(++i)do
			(pxArc^) << m_asSprtFilters[i];
		endfor;
		m_xSprtCorpse.DoKArc(pxArc^);
		m_xSprtPyCO.DoKArc(pxArc^);
		m_xAscensionStart.DoKArc(pxArc^);
		m_xResurrecterList.DoKArc(pxArc^);
		(pxArc^) << m_bMakePyCO;
		(pxArc^) << m_vFinalDestination;
		(pxArc^) << m_iProgress;
		(pxArc^) << m_iLastRecord;
		(pxArc^) << m_fLastProgress;
		(pxArc^) << m_iWouldBeOwner;
		pxN^.Close();
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			SetType("NMST");
			SetVisInFOW(true);
//			SetVisible(false);
		else
			SetVisible(false);
		endif;
		CheckEvents();
		CheckAttribs();
		SetHitable(true);
		SetSelectable(true);
		SetDisableShadowCast(true);
		SetDisableShadowReceive(true);
//		SetCamouflage(true);
//		SetCanFly(true);
		if(!p_bLoad)then
			InvokeGenericSCEvent(26,5.0f);
		endif;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		if(!m_bDeactivated)then
			SetVisible(false);
			if(HasTimer(TIMER_SPIRIT_POSTLOAD))then DeleteTimer(TIMER_SPIRIT_POSTLOAD); endif;
			CreateTimer(TIMER_SPIRIT_POSTLOAD, CGameTimeSpan.OneSecond() * 3.0, false);
//			InvokeGenericSCEvent(26,5.0f,5.0f);
		endif;
		if(m_xSprtCorpse.IsValid())then
			var ^CFoodFood pxFF=cast<CFoodFood>(m_xSprtCorpse.GetObj());
			if(pxFF!=null)then
				pxFF^.SetSprt(GetHandle());
			endif;
		endif;
//		if(HasTimer(TIMER_SPIRIT_VANISH)&&!m_bReanimation)then
		if(HasTimer(TIMER_SPIRIT_DEATH)&&!m_bReanimation)then
//			var vec3 vDest=GetPos();
//			vDest.SetZ(m_vSprtPosition.GetZ()+200.0f);
			MoveAction(m_vFinalDestination,m_fAscSpeed);
		endif;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==TIMER_SPIRIT_APPEAR)then
				AppearFunction();
				return;
			elseif(p_rxEvtPtr.GetInt(0)==TIMER_SPIRIT_POSTLOAD)then
				if(!m_bDeactivated)then
					SetVisible(true);
					InvokeGenericSCEvent(26,5.0f,2.0f);
				endif;
				return;
			elseif(p_rxEvtPtr.GetInt(0)==TIMER_SPIRIT_DEATH)then
				Delete();
				return;
			elseif(p_rxEvtPtr.GetInt(0)==TIMER_SPIRIT_VANISH)then
				CommenceSelfDestruction();
				SetHitable(false);
				SetSelectable(false);
				return;
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	export proc void Initialize(Quat p_qRot, vec3 p_vPos, vec3 p_vRot, string p_sClass, int p_iLevel, int p_iOwner, bool p_bReanim, int p_iAState, int p_iCount, int p_iKillerCount, int p_iKillerHistory, CObjHndl p_xCorpse, string p_sID, string p_sDur, string p_sStart, string p_sDeath, real p_fDuration, real p_fLifeTime, array string p_asFilters, string p_sGFX, real p_fSpeed, real p_fRadius, int p_iResearch, string p_sName, bool p_bPyCO)
		m_qSprtRotation=p_qRot;
		m_vSprtPosition=p_vPos;
		m_vSprtPosition.SetZ(Math.Max(CSrvWrap.GetScapeMgr().GetHeight(m_vSprtPosition.GetX(),m_vSprtPosition.GetY()),CSrvWrap.GetScapeMgr().GetSeaLevel()));
		SetPos(m_vSprtPosition);
		m_vSprtRotation=p_vRot;
		m_sSprtClass=p_sClass;
		m_iSprtLevel=p_iLevel;
		m_iSprtOwner=p_iOwner;
		m_bReanimation=p_bReanim;
		m_iSprtAS=p_iAState;
		m_iSprtCount=p_iCount;
		m_iSprtKC=p_iKillerCount;
		m_iSprtKH=p_iKillerHistory;
		m_xSprtCorpse=p_xCorpse;
		if(m_xSprtCorpse.IsValid())then
			var ^CFoodFood pxFF=cast<CFoodFood>(m_xSprtCorpse.GetObj());
			if(pxFF!=null)then
				pxFF^.SetSprt(GetHandle());
			endif;
		endif;
		m_sID=p_sID;
		m_sDur=p_sDur;
		m_sStart=p_sStart;
		m_sDeath=p_sDeath;
		m_fReanimDur=p_fDuration;
		if(m_fReanimDur<=0.0f)then
			m_fReanimDur=20.0f;
		endif;
		m_fSprtLifeTime=p_fLifeTime;
		if(m_fSprtLifeTime<=0.0f)then
			m_fSprtLifeTime=60.0f;
		endif;
		m_fSprtRadius=p_fRadius;
		m_fAscSpeed=p_fSpeed;
		if(m_fAscSpeed<0.2f)then
			m_fAscSpeed=0.2f;
		endif;
		begin CalculatingDest;
			var vec3 vTmp=m_vSprtPosition;
			vTmp.SetZ(vTmp.GetZ()+10.0f);
			var vec3 vDirection=(vTmp-m_vSprtPosition).GetNormalized();
			var real fDist=m_fAscSpeed*m_fSprtLifeTime;
			m_vFinalDestination=m_vSprtPosition+(vDirection*fDist);
		end CalculatingDest;
		m_iResearch=p_iResearch;
		if(m_iResearch<0)then
			m_iResearch=0;
		elseif(m_iResearch>6)then
			m_iResearch=6;
		endif;
		var ^CAttribs pxA=CheckAttribs();
		if(pxA!=null)then
//			pxA^.SetValue("hitpoints",m_fReanimDur.ToInt());
//			pxA^.SetValue("maxhitpoints",m_fSprtLifeTime.ToInt());
			pxA^.SetValue("hitpoints",0);
			pxA^.SetValue("maxhitpoints",m_iSprtHP);
		endif;
		m_sSprtGFX=p_sGFX;
		if(GetGfxName()!=m_sSprtGFX&&(m_sSprtGFX=="fx_ghost_sml"||m_sSprtGFX=="fx_ghost_med"||m_sSprtGFX=="fx_ghost_big"||m_sSprtGFX=="fx_ghost_chief"))then
			SetGFX(m_sSprtGFX);
		endif;
		m_xAscensionStart=CTimeMgr.Get().GetTime();
		var int i, iC=p_asFilters.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			m_asSprtFilters.AddEntry(p_asFilters[i]);
		endfor;
		m_bVIP=(m_sSprtClass=="Miyagi_s0"||m_sSprtClass=="special_eusmilus"||m_sSprtClass=="babbage_s0"||m_sSprtClass=="Barry_s0"||m_sSprtClass=="Bela_s0"||m_sSprtClass=="Cole_s0"||m_sSprtClass=="darwin_s0"||m_sSprtClass=="Harry_s0"||m_sSprtClass=="hermit_s0"||m_sSprtClass=="Larry_s0"||m_sSprtClass=="livingstone_s0"||m_sSprtClass=="lovelace_s0"||m_sSprtClass=="mayor_s0"||m_sSprtClass=="schliemann_s0"||m_sSprtClass=="Stina_s0"||m_sSprtClass=="Tarna_s0"||m_sSprtClass=="tesla_s0"||m_sSprtClass=="aje_atroxosaurus"||m_sSprtClass=="hu_triceratops"||m_sSprtClass=="ninigi_seismosaurus"||m_sSprtClass=="seas_rex"||m_sSprtClass=="aje_catapult_rex"||m_sSprtClass=="ninigi_kong");
		m_bMakePyCO=p_bPyCO;
		if(m_bMakePyCO)then
			var ^CBasePlayer pxBPl=CBasePlayer.GetPlayer(m_iSprtOwner);
			if(pxBPl!=null)then
				m_bPreState=true;
				m_iSprtSupply = CMirageSrvMgr.Get().GetSupply(m_sSprtClass);
				m_sSprtNode = "virtual_units_"+m_iSprtLevel.ToString();
//				var ^CAttribs pxPAttr=pxBPl^.GetAttribs();
//				if(pxPAttr!=null)then
//					pxPAttr^.SetValue("virtual_supply", pxPAttr^.GetValueInt("virtual_supply")+m_iSprtSupply);
//					pxPAttr^.SetValue(m_sSprtNode, pxPAttr^.GetValueInt(m_sSprtNode)+1);
//				endif;
				var ^CPyramidCardObject pxTmp = cast<CPyramidCardObject>(CSrvWrap.GetObjMgr()^.CreateObj("pyramid_card_object",-1,m_vSprtPosition));
				if(pxTmp!=null)then
					var ^CAttribs pxAttr = pxTmp^.GetAttribs();
					if(pxAttr!=null)then
						pxAttr^.SetValue("level", m_iSprtLevel);
//						pxAttr^.SetValue("hitpoints",m_fReanimDur.ToInt());
//						pxAttr^.SetValue("maxhitpoints",m_fSprtLifeTime.ToInt());
						pxAttr^.SetValue("hitpoints", 0);
						pxAttr^.SetValue("maxhitpoints", m_iSprtHP);
						pxAttr^.SetValue("CurTask", "");
						pxAttr^.SetValue("clientpyramid_slotid", -1);
						pxAttr^.SetValue("ObjPath", m_sSprtDesc);
						pxAttr^.SetValue("dead", true);
						pxAttr^.SetValue("TaskDescription", "");
						pxAttr^.SetValue("unit_count", true);
						pxAttr^.SetValue("clientpyramid_replacecard", p_sName);
						pxAttr^.SetValue("vertical_fill", 0);
						pxAttr^.SetValue("is_spirit", 1);
					endif;
					pxTmp^.InitTechTreeDef();
					var ^CTechTreeDef pxTTDef = pxTmp^.GetTechTreeDef();
					if(pxTTDef!=null)then
						var int i, iC = m_asSprtFilters.NumEntries();
						for(i=0) cond(i<iC) iter(i++) do
							pxTTDef^.EnableFilter(m_asSprtFilters[i]);
						endfor;
					endif;
					pxTmp^.SetOwner(m_iSprtOwner);
					var CObjHndl xMe=GetHandle();
					pxTmp^.SetPreSpirit(true,xMe.AsInt());
					m_xSprtPyCO = pxTmp^.GetHandle();
					pxTmp^.SetSpiritHandle(xMe);
//					pxTmp^.SetResurectMod(m_iSprtOwner,-1,m_sSprtNode,m_iSprtSupply,m_fSprtLifeTime);
//					m_iSprtCount=1;
				endif;
			endif;
		endif;
		CreateTimer(TIMER_SPIRIT_APPEAR, CGameTimeSpan.OneSecond() * 1.0, false);
//		AppearFunction();
	endproc;
	
	proc void AppearFunction()
		SetVisInFOW(false);
		SetOwner(m_iSprtOwner);
//		SetVisible(true);
//		InvokeGenericSCEvent(26,1.5f);
//		SetCamouflage(true);
//		CreateTimer(TIMER_SPIRIT_VANISH, CGameTimeSpan.OneSecond() * 120.0, false);
		CreateTimer(TIMER_SPIRIT_DEATH, CGameTimeSpan.OneSecond() * m_fSprtLifeTime, false);
//		var vec3 vDest=GetPos();
//		vDest.SetZ(m_vSprtPosition.GetZ()+200.0f);
		MoveAction(m_vFinalDestination,m_fAscSpeed);
		if(m_xSprtCorpse.IsValid())then
			var ^CFoodFood pxFF=cast<CFoodFood>(m_xSprtCorpse.GetObj());
			if(pxFF!=null)then
				pxFF^.SpiritCorpseTimer(false,m_fSprtLifeTime);
			endif;
		endif;
	endproc;
	
	export proc bool GetNeutralObject()
		return true;
	endproc;
	
	proc ^CGameEvtQueue CheckEvents()
		var ^CGameEvtQueue pxQueue=GetEvents();
		if(pxQueue==null)then
			pxQueue=InitEvents();
		endif;
		return pxQueue;
	endproc;
	
	proc ^CAttribs CheckAttribs()
		var ^CAttribs pxAttribs=GetAttribs();
		if(pxAttribs==null)then
			pxAttribs=InitAttribs();
		endif;
		return pxAttribs;
	endproc;
	
	export proc void SetDescriptionClass(string p_sDesc, string p_sClass, int p_iOwner)
		m_sSprtClass=p_sClass;
		m_sSprtDesc=p_sDesc;
		var ^CAttribs pxA=CheckAttribs();
		if(pxA!=null)then
			pxA^.SetValue("desc_of_source",p_sDesc);
			pxA^.SetValue("class_of_source",p_sClass);
			pxA^.SetValue("id_of_source",p_iOwner);
		endif;
	endproc;
	
	export proc real GetResurrectDuration()
		return m_fReanimDur;
	endproc;
	
	export proc bool AddSprtResurrecter(CObjHndl p_xRes)
		if(!p_xRes.IsValid())then return false; endif;
		m_xResurrecterList.Include(p_xRes);
		return true;
	endproc;
	
	export proc bool RemSprtResurrecter(CObjHndl p_xRes)
		if(!p_xRes.IsValid())then return false; endif;
		if(m_xResurrecterList.FindEntry(p_xRes)==-1)then return false; endif;
		m_xResurrecterList.RemEntry(p_xRes);
		return true;
	endproc;
	
	export proc void SetResurrectMode(bool p_bOn, bool p_bAlliedTask, real p_fProgress)
		m_bReanimation=p_bOn;
		if(m_bReanimation)then
			TerminateAction();
//			if(HasTimer(TIMER_SPIRIT_VANISH))then
//				DeleteTimer(TIMER_SPIRIT_VANISH);
//			endif;
			if(HasTimer(TIMER_SPIRIT_DEATH))then
				DeleteTimer(TIMER_SPIRIT_DEATH);
			endif;
		else
//			var vec3 vDest=GetPos();
//			vDest.SetZ(m_vSprtPosition.GetZ()+200.0f);
			m_iLastRecord=m_iProgress;
			m_fLastProgress=p_fProgress;
			m_fReanimDur=m_fReanimDur-(m_fReanimDur*(m_fLastProgress/100.0f));
			m_xAscensionStart=CTimeMgr.Get().GetTime();
			var vec3 vCur=GetPos();
			var real fDist=(m_vFinalDestination-vCur).Abs();
			m_fAscSpeed=fDist/m_fSprtLifeTime;
			MoveAction(m_vFinalDestination,m_fAscSpeed);
//			if(!HasTimer(TIMER_SPIRIT_VANISH))then
//				CreateTimer(TIMER_SPIRIT_VANISH, CGameTimeSpan.OneSecond() * m_fSprtLifeTime, false);
//			endif;
			if(!HasTimer(TIMER_SPIRIT_DEATH))then
				CreateTimer(TIMER_SPIRIT_DEATH, CGameTimeSpan.OneSecond() * m_fSprtLifeTime, false);
			endif;
//			if(m_bMakePyCO)then
			if(m_bMakePyCO&&p_bAlliedTask)then
				var ^CBasePlayer pxBPl=CBasePlayer.GetPlayer(m_iSprtOwner);
				if(pxBPl!=null)then
//					m_bPreState=true;
					var ^CPyramidCardObject pxTmp = cast<CPyramidCardObject>(m_xSprtPyCO.GetObj());
					if(pxTmp!=null)then
						var ^CAttribs pxAttr = pxTmp^.GetAttribs();
						if(pxAttr!=null)then
							pxAttr^.SetValue("CurProcess", m_fLastProgress.ToInt());
						endif;
						var CObjHndl xMe=GetHandle();
						pxTmp^.SetPreSpirit(true,xMe.AsInt());
						pxTmp^.SetSpiritHandle(xMe);
					endif;
				endif;
			endif;
		endif;
		if(m_xSprtCorpse.IsValid())then
			var ^CFoodFood pxFF=cast<CFoodFood>(m_xSprtCorpse.GetObj());
			if(pxFF!=null)then
				var real fDur=-1.0f;
				if(!m_bReanimation)then
					fDur=m_fSprtLifeTime;
				endif;
				pxFF^.SpiritCorpseTimer(m_bReanimation,fDur);
			endif;
		endif;
	endproc;
	
	export proc bool GetResurrectMode()
		return m_bReanimation;
	endproc;
	
	export proc void SetResurrectionValue(int p_iNew)
		m_iSprtCount=p_iNew;
	endproc;
	
	export proc int GetResurrectionValue()
		return m_iSprtCount;
	endproc;
	
	export proc int GetSprtLevel()
		return m_iSprtLevel;
	endproc;
	
	export proc string GetSprtClass()
		return m_sSprtClass;
	endproc;
	
	export proc string GetSprtDescription()
		return m_sSprtDesc;
	endproc;
	
	export proc int GetSprtHP()
		return m_iSprtHP;
	endproc;
	
	export proc int GetSprtProgress()
		return m_iProgress;
	endproc;
	
	export proc real GetLastSprtProgress()
		return m_fLastProgress;
	endproc;
	
	export proc void SetHP(int p_iNew)
		m_iSprtHP=p_iNew;
	endproc;
	
	export proc int GetResearch()
		return m_iResearch;
	endproc;
	
	export proc int GetSprtOwner()
		return m_iSprtOwner;
	endproc;
	
	export proc void SetNextOwner(int p_iNew)
		m_iWouldBeOwner=p_iNew;
	endproc;
	
	export proc void GetTTFilters(ref array string p_rasFilters)
		var int i, iC=m_asSprtFilters.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			p_rasFilters.AddEntry(m_asSprtFilters[i]);
		endfor;
	endproc;
	
	export proc Quat GetSprtRot()
		return m_qSprtRotation;
	endproc;
	
	export proc vec3 GetSprtPos()
		return m_vSprtPosition;
	endproc;
	
	export proc real GetSprtRadius()
		return m_fSprtRadius;
	endproc;
	
	export proc bool GetVIP()
		return m_bVIP;
	endproc;
	
	export proc void GetProperties(ref bool p_rbCorpse,ref vec3 p_rvPos,ref vec3 p_rvRot)
		p_rvPos=m_vSprtPosition;
		p_rvRot=m_vSprtRotation;
		if(m_xSprtCorpse.IsValid()&&m_xSprtCorpse.GetObj()!=null)then
			p_rvPos=m_xSprtCorpse.GetObj()^.GetPos();
			p_rbCorpse=true;
			p_rvRot=m_xSprtCorpse.GetObj()^.GetRotation();
		endif;
		p_rvPos.SetZ(Math.Max(CSrvWrap.GetScapeMgr().GetHeight(p_rvPos.GetX(),p_rvPos.GetY()),CSrvWrap.GetScapeMgr().GetSeaLevel()));
	endproc;
	
	export proc void DeleteSprt(ref int p_riKC,ref int p_riKH,ref string p_rsID,ref string p_rsDur,ref string p_rsStart,ref string p_rsDeath, ref int p_riAS)
		p_riKC=m_iSprtKC;
		p_riKH=m_iSprtKH;
		p_rsID=m_sID;
		p_rsDur=m_sDur;
		p_rsStart=m_sStart;
		p_rsDeath=m_sDeath;
		p_riAS=m_iSprtAS;
		if(m_xSprtCorpse.IsValid()&&m_xSprtCorpse.GetObj()!=null)then
			m_xSprtCorpse.GetObj()^.Delete();
		endif;
		m_iSprtCount=0;
//		m_xSprtCorpse=CObjHndl.Invalid();
//		CommenceSelfDestruction();
		Delete();
	endproc;
	
	export proc void StartReanimation(real p_fDur)
		var CGameTime xNow = CTimeMgr.Get().GetTime();
		var CGameTimeSpan xDiff=xNow-m_xAscensionStart;
		m_fSprtLifeTime=Math.Max(m_fSprtLifeTime-xDiff.GetSecondsF(),0.1f);
		var vec3 vCur=GetPos();
		var real fSpeed, fDist=(m_vSprtPosition-vCur).Abs();
		fSpeed=fDist/p_fDur;
		MoveAction(m_vSprtPosition,fSpeed);
	endproc;
	
	export proc void UpdateProgress(real p_fProgress)
		var real fToFill=(m_iSprtHP-m_iLastRecord).ToReal();
		var int iNew=(fToFill*(p_fProgress/100.0f)).ToInt();
		m_iProgress=iNew+m_iLastRecord;
		var ^CAttribs pxA=CheckAttribs();
		if(pxA!=null)then
			pxA^.SetValue("hitpoints",m_iProgress);
		endif;
	endproc;
	
	proc void CommenceSelfDestruction()
		m_bDeactivated=true;
		var ^CAttribs pxA=CheckAttribs();
		if(pxA!=null)then
			pxA^.SetValue("deactivated",1);
		endif;
		if(m_xSprtCorpse.IsValid())then
			var ^CFoodFood pxFF=cast<CFoodFood>(m_xSprtCorpse.GetObj());
			if(pxFF!=null)then
				pxFF^.SetSprt(CObjHndl.Invalid());
				pxFF^.SpiritCorpseTimer(false,-1.0f);
			endif;
		endif;
		CreateTimer(TIMER_SPIRIT_DEATH, CGameTimeSpan.OneSecond() * 10.0, false);
		SetVisible(false);
	endproc;
	
	export proc void Kill()
		if(m_xSprtCorpse.IsValid()&&m_xSprtCorpse.GetObj()!=null)then
			m_xSprtCorpse.GetObj()^.Delete();
		endif;
//		m_xSprtCorpse=CObjHndl.Invalid();
//		CommenceSelfDestruction();
		Delete();
	endproc;
	
	export proc bool IsDeactivated()
		return m_bDeactivated;
	endproc;
	
	export proc bool HasResurrecter()
		return m_xResurrecterList.Validate()>0;
	endproc;
	
	export proc void InvalidateSprtPyCO()
		m_xSprtPyCO=CObjHndl.Invalid();
	endproc;
	
	export proc CObjHndl GetSprtPyCO()
		return m_xSprtPyCO;
	endproc;
	
	export proc void SetSprtPyCO(CObjHndl p_xPyCO)
		m_xSprtPyCO=p_xPyCO;
	endproc;
	/*
	export proc void DestroyPyCO()
//		m_iSprtCount=0;
		var ^CPyramidCardObject pxTmp = cast<CPyramidCardObject>(m_xSprtPyCO.GetObj());
		if(pxTmp!=null)then
//			pxTmp^.StopTimer();
			pxTmp^.SetSpiritHandle(CObjHndl.Invalid());
		endif;
		if(m_xSprtPyCO.IsValid())then
			CSrvWrap.GetObjMgr()^.DeleteObject(m_xSprtPyCO.GetObj());
			m_xSprtPyCO=CObjHndl.Invalid();
		endif;
//		var ^CPlayer pxPlayer=CSrvWrap.GetCurLevel()^.GetPlayer(m_iSprtOwner);
//		if(pxPlayer==null)then return; endif;
//		var ^CAttribs pxPlAttr=pxPlayer^.GetAttribs();
//		if(pxPlAttr==null)then return; endif;
//		pxPlAttr^.SetValue("virtual_supply", pxPlAttr^.GetValueInt("virtual_supply")-m_iSprtSupply);
//		pxPlAttr^.SetValue(m_sSprtNode, pxPlAttr^.GetValueInt(m_sSprtNode)-1);
	endproc;
	*/
	export proc void DestroyPyCO()
		m_bMakePyCO=false;
		var ^CPyramidCardObject pxTmp = cast<CPyramidCardObject>(m_xSprtPyCO.GetObj());
		if(pxTmp!=null)then
			pxTmp^.SetSpiritHandle(CObjHndl.Invalid());
			CSrvWrap.GetObjMgr()^.DeleteObject(m_xSprtPyCO.GetObj());
			m_xSprtPyCO=CObjHndl.Invalid();
		endif;
	endproc;
	
endclass;

class CLakeOfLava inherit CGameObj
	
	var string		m_sRegionName;
	var int				m_iDamage;
	var real			m_fHeight;
	var bool			m_bInstaKill;
	const int			TIMER_LAVA = 40167;
	var CObjHndl	m_xActor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		m_xActor = CObjHndl.Invalid();
		if(!p_bLoad)then
			SetType("LAVA");
			SetHitable(false);
			SetSelectable(false);
			SetVisible(false);
			InitAttribs();
		else
			var ^CAttribs pxA = GetAttribs();
			if(pxA!=null)then
				m_iDamage=pxA^.GetValueInt("damage_per_tick");
				m_fHeight=pxA^.GetValueFloat("height");
				m_bInstaKill=pxA^.GetValueBool("insta_kill");
				m_sRegionName=pxA^.GetValue("region_name");
			endif;
		endif;
		InitEvents();
		DeleteTimer(TIMER_LAVA);
		CreateTimer(TIMER_LAVA,CGameTimeSpan.OneSecond()*3.0,true);
	endproc;
	
	proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==TIMER_LAVA)then
				Damage();
			endif;
		endif;
	endproc;
	
	proc void Damage()
		var ^CRegion pxRegion=CSrvWrap.GetRegionMgr().GetRegion(m_sRegionName);
		if(pxRegion==null)then return; endif;
		var CObjList xObjList;
		var int i,iC=pxRegion^.NumObjects();
		for(i=0)cond(i<iC)iter(i++)do
			xObjList.AddEntry(pxRegion^.GetObject(i));
		endfor;
		iC=xObjList.NumEntries();
		var string sClass;
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFightingObj pxFighter=cast<CFightingObj>(xObjList[i].GetObj());
			if(pxFighter==null)then continue; endif;
			if(pxFighter^.GetPosZ()>m_fHeight)then continue; endif;
			if(pxFighter^.GetTransportObj().IsValid())then continue; endif;
			if(pxFighter^.GetOnWall())then continue; endif;
			if(pxFighter^.IsFlyingUnit())then continue; endif;
			if(pxFighter^.GetNoReceiveDamage())then continue; endif;
			sClass=pxFighter^.GetClassName();
			if(sClass.Find("_zeppelin")!=-1||sClass=="seas_helicopter")then continue; endif;
			if(m_bInstaKill)then
				pxFighter^.OneHitKilling(-1,m_xActor);
			else
				pxFighter^.TakeDirectMeleeDmg(m_iDamage.ToReal(),m_xActor);
			endif;
		endfor;
	endproc;
	
endclass;
	
class CNewTrainingDummy inherit CTrainingDummy
	
	var array int				m_aiTypes;
	var array int				m_aiLoopes;
	var array string		m_asAnims;
	var array vec3			m_avPositions;
	var array real			m_afRotations;
	var array real			m_afSpeeds;
	
	export proc void StartTraining(string p_sGFX)
		StartTraining(p_sGFX,"farm_anim_1");
	endproc;
	
	export proc void StartTraining(string p_sGFX, real p_fHeight)
		var vec3 vPos=GetPos();
		vPos.SetZ(vPos.GetZ()+p_fHeight);
		SetPos(vPos);
		SetGFX(p_sGFX);
		if(p_sGFX=="Kentrosaurus"||p_sGFX=="Macrolemys"||p_sGFX=="Stegosaurus"||p_sGFX=="Mammoth")then
			SetRndInvMaskSingleFlagInv(11,true);
		endif;
		OnActionEnd(false);
		return;
	endproc;
	
	export proc void StartTraining(string p_sGFX,string p_sAnim)
		return;
	endproc;
	
	export proc void OnActionEnd(bool p_bBroken)
		if(m_aiTypes.NumEntries()>0)then
			switch(m_aiTypes[0])
				case(0)do
					if(m_aiLoopes[0]<=0)then
						AnimAction(m_asAnims[0]);
					else
						AnimAction(m_asAnims[0],m_aiLoopes[0], true, true);
					endif;
				endcase;
				case(1)do
					MoveAnimAction(m_avPositions[0], m_afSpeeds[0], m_asAnims[0]);
				endcase;
				case(2)do
					var Quat qRot=GetRot();
					qRot.RotateZ(m_afRotations[0]);
					RotateAction(qRot,m_asAnims[0]);
//					RotateAction(qRot,m_asAnims[0], m_afSpeeds[0], m_aiLoopes[0], true, true);
				endcase;
				case(3)do
					WalkAction(m_avPositions[0], m_afSpeeds[0].ToInt());
				endcase;
				case(4)do
					SetAnim(m_asAnims[0],m_aiLoopes[0]);
					MoveAction(m_avPositions[0], m_afSpeeds[0]);
				endcase;
				case default do endcase;
			endswitch;
			DeleteArrayElement();
		else
			Delete();
		endif;
		return;
	endproc;
	
	export proc void AddParams(int p_iType, string p_sAnim, vec3 p_vPos, real p_fRot, real p_fSpeed, int p_iLoopes)
		m_aiTypes.AddEntry(p_iType);
		m_asAnims.AddEntry(p_sAnim);
		m_avPositions.AddEntry(p_vPos);
		m_afRotations.AddEntry(p_fRot);
		m_afSpeeds.AddEntry(p_fSpeed);
		m_aiLoopes.AddEntry(p_iLoopes);
	endproc;
	
	proc void DeleteArrayElement()
		m_aiTypes.DeleteEntry(0);
		m_asAnims.DeleteEntry(0);
		m_avPositions.DeleteEntry(0);
		m_afRotations.DeleteEntry(0);
		m_afSpeeds.DeleteEntry(0);
		m_aiLoopes.DeleteEntry(0);
	endproc;
	
endclass;

class CParasite inherit CGameObj
	
	const int TRACKER_TIMER=40058;
	const int TIMER_PARASITE_LIFE=40181;
	const real ENERGY=480.0f;
	
	var CObjHndl m_xHost;
	
	export proc void OnInit(bool p_bLoad)
		InitEvents();
		SetHitable(false);
		SetSelectable(false);
		if(!p_bLoad)then
			SetType("PROD");
			SetFOW(1.0f);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xType="Para";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xHost.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="Para")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xHost.DoKArc(pxArc^);
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Set(CObjHndl p_xHost)
		if(!p_xHost.IsValid())then return; endif;
		var ^CFightingObj pxHost=cast<CFightingObj>(p_xHost.GetObj());
		if(pxHost==null)then return; endif;
		if(!pxHost^.AddParasite(GetHandle()))then
			Delete();
			return;
		endif;
		SetGFX("dummy");
		m_xHost=p_xHost;
		var CFourCC xLink="NONE";
		LinkAction(p_xHost,xLink);
		SetFOW(pxHost^.GetFOWRange());
		CreateTimer(TRACKER_TIMER, CGameTimeSpan.OneSecond() * 60.0, false); //Henry: after 1 minute, owner gets the bufficon to show owner the parasite
		var real fLife=ENERGY;
//		if(pxHost^.GetOwner()==-1&&pxHost^.IsWildAnimal())then
//			fLife*=2.0;
//		endif;
		CreateTimer(TIMER_PARASITE_LIFE, CGameTimeSpan.OneSecond() * fLife, false);
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==TRACKER_TIMER)then
				if(m_xHost.IsValid())then
					var ^CFightingObj pxHost=cast<CFightingObj>(m_xHost.GetObj());
					if(pxHost!=null)then
						//var bool bDelete=pxHost^.RemParasite(GetHandle());
						pxHost^.AddRangedBuff("parasite_host");
					endif;
				endif;
			elseif(p_rxEvtPtr.GetInt(0)==TRACKER_TIMER)then
				if(m_xHost.IsValid())then
					var ^CFightingObj pxHost=cast<CFightingObj>(m_xHost.GetObj());
					if(pxHost!=null)then
						var bool bDelete=pxHost^.RemParasite(GetHandle());
					endif;
				endif;
				Delete();
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	export proc void Removement()
		if(HasTimer(TRACKER_TIMER))then DeleteTimer(TRACKER_TIMER); endif;
		Delete();
	endproc;
	
	export proc bool GetNeutralObject()
		return true;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		if(!m_xHost.IsValid())then Delete(); return; endif;
		var ^CFightingObj pxHost=cast<CFightingObj>(m_xHost.GetObj());
		if(pxHost==null)then Delete(); return; endif;
		SetGFX("dummy");
		var CFourCC xLink="NONE";
		LinkAction(m_xHost,xLink);
		SetFOW(pxHost^.GetFOWRange());
	endproc;
	
endclass;
	
	//========================================================================================
	//=== Nest copies ========================================================================
	//========================================================================================
	
	//========================================================================================
	//=== Corpses ============================================================================
	//========================================================================================
	
class CAjeAmazonTempleCorpse inherit CUniversalCorpse
	
	var int m_iState;
	
	export proc void OnInit(bool p_bLoad)
		SetDestructLevel(2);
		super.OnInit(p_bLoad);
		SetVisible(true);
	endproc;
	
	export proc void Init(string p_sName, real p_fDuration)
		SetName(p_sName);
		InvokeGenericSCEvent(40,4.0);
		if(p_fDuration>0.0)then
			CreateTimer(TIMER_DELETE, CGameTimeSpan.OneSecond()*p_fDuration,false);
		endif;
		m_iState=1;
	endproc;
	
	export proc void OnPostLoad()
		if(m_iState==2 || m_iState==1)then
			Delete();
		endif;
	endproc;
	
	export proc void OnActionEnd(bool p_bBroken)
		if(m_iState==2)then
			Delete();
		endif;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID = p_rxEvtPtr.GetInt(0);
			if(iTimerID==TIMER_DELETE)then
				m_iState=2;
				var vec3 vP = GetPos();
				vP.SetZ(0.0f);
				MoveAction(vP, 1.0f);
			endif;
		endif;
	endproc;
	
	export destructor()
	enddestructor;
	
endclass;
	
class CCargolifterCorpse inherit CUniversalCorpse
	
	var int m_iState;
	var CObjList m_xFXObjects;
	var vec3 m_vHeight;
	var real m_fFix;
	export const int TIMERID_SINK=40011;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="CLiC")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVer=p_pxReaderNode^.GetVersion();
			m_xFXObjects.DoKArc(pxArc^);
			pxArc^ << m_iState;
			if(iVer>=3)then
				pxArc^ << m_fFix;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="CLiC";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,3);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xFXObjects.DoKArc(pxArc^);
		pxArc^ << m_iState;
		pxArc^ << m_fFix;
		pxWalk^.Close();
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetVisible(true);
	endproc;
	
	export proc void Init(string p_sName, real p_fDuration, real p_fFix)
		SetName(p_sName);
		m_fFix=p_fFix;
		InvokeGenericSCEvent(40,4.0);
		if(p_fDuration>0.0)then
			CreateTimer(TIMER_DELETE, CGameTimeSpan.OneSecond()*p_fDuration,false);
		endif;
		var CObjHndl xHndl=AddFX("fire_corpses",-1.0);
		if(xHndl.IsValid())then
			var CFourCC xLink="Dri1";
			xHndl.GetObj()^.LinkAction(GetHandle(),xLink);
		endif;
		m_iState=1;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==TIMER_DELETE)then
				m_iState=2;
				var vec3 vP=GetPos();
				var real fHeight = Math.Max(CSrvWrap.GetScapeMgr().GetHeight(vP.GetX(), vP.GetY()), CSrvWrap.GetScapeMgr().GetSeaLevel());
				fHeight+=m_fFix;
				vP.SetZ(fHeight);
				MoveAction(vP, 15.0f);
			elseif(iTimerID==TIMERID_SINK)then
				m_iState=3;
				var vec3 vP=GetPos();
				vP.SetZ(0.0f);
				MoveAction(vP, 1.0f);
			endif;
		endif;
	endproc;
	
	export proc void OnActionEnd(bool p_bBroken)
		if(m_iState==2)then
			CreateTimer(TIMERID_SINK, CGameTimeSpan.OneSecond()*5.0f,false);
		elseif(m_iState==3)then
			ClearFX();
			Delete();
		endif;
	endproc;
	
	export destructor()
	enddestructor;
	
	export proc ref CObjHndl AddFX(string p_sFX, real p_fTime)
		var int iIndex;
		var bool bAlreadyExists=false;
		var int i, iC=m_xFXObjects.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFX pxObj=cast<CFX>(m_xFXObjects[i].GetObj());
			if(pxObj!=null&&pxObj^.GetFXClass()==p_sFX)then
				bAlreadyExists=true;
				iIndex=i;
				break;
			endif;
		endfor;
		if(!bAlreadyExists)then
			var ^CFX pxFX=cast<CFX>(CSrvWrap.GetObjMgr()^.CreateObj(p_sFX,GetOwner(),GetPos(),GetRotation()));
			if(pxFX!=null)then
				iIndex=m_xFXObjects.Include(pxFX^.GetHandle());
				if(p_fTime>0.0)then
					pxFX^.SetTimer(p_fTime);
				endif;
				pxFX^.SetFXClass(p_sFX);
				pxFX^.SetParent(GetHandle());
			endif;
		endif;
		return m_xFXObjects[iIndex];
	endproc;
	
	export proc void ClearFX()
		var int i;
		for(i=0)cond(i<m_xFXObjects.NumEntries())iter(i++)do
			var ^CFX pxObj=cast<CFX>(m_xFXObjects[i].GetObj());
			m_xFXObjects.DeleteEntry(i);
			if(pxObj!=null)then
				pxObj^.Delete();
			endif;
			i--;
		endfor;
	endproc;
	
endclass;
	
class CAjeHarbourSink inherit CUniversalCorpse
	
	var string		m_sGfx;
	var int				m_iState;
	
	export proc void Init(string p_sGfx, string p_sName, real p_fDuration)
		m_sGfx=p_sGfx;
		super.Init(p_sGfx, p_sName, p_fDuration);
		m_iState=1;
	endproc;
	
	export proc void OnPostLoad()
		if(m_iState==2||m_iState==1)then
			Delete();
		endif;
	endproc;
	
	export proc void OnActionEnd(bool p_bBroken)
		if(m_iState==2)then
			Delete();
		endif;
	endproc;
	
	export proc void SetGFX(string p_sString)
		super.SetGFX(p_sString);
	endproc;
	
	proc void PlayAnim(int p_iPlayMode)
		AnimAction("sink");
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==TIMER_DELETE)then
				m_iState=2;
				var vec3 vP=GetPos();
				vP.SetZ(0.0f);
				MoveAction(vP, 100.0f);
			endif;
		endif;
	endproc;
	
	export destructor()
	enddestructor;
	
endclass;
	
class CCarrierSink inherit CUniversalCorpse
	
	var string		m_sGfx;
	var int				m_iState;
	var CObjHndl	m_xTurret;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="CaSi")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xTurret.DoKArc(pxArc^);
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="CaSi";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xTurret.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;
	
	export proc void Init(string p_sGfx, string p_sName, real p_fDuration)
		var ^CGameObj pxTurret=CSrvWrap.GetObjMgr()^.CreateObj("seas_carrier_turret", GetOwner());
		if(pxTurret!=null)then
			m_xTurret=pxTurret^.GetHandle();
			var CFourCC xLink="we";
			pxTurret^.LinkAction(GetHandle(),xLink);
		endif;
		m_sGfx=p_sGfx;
		super.Init(p_sGfx, p_sName, p_fDuration);
		m_iState=1;
	endproc;
	
	export proc void OnPostLoad()
		if(m_iState==2||m_iState==1)then
			Delete();
		endif;
	endproc;
	
	export proc void OnActionEnd(bool p_bBroken)
		if(m_iState==2)then
			Delete();
		endif;
	endproc;
	
	export proc void Delete()
		if(m_xTurret.IsValid())then
			var ^CGameObj pxTurret=m_xTurret.GetObj();
			if(pxTurret!=null)then
				pxTurret^.Delete();
			endif;
		endif;
		super.Delete();
	endproc;
	
	export proc void SetGFX(string p_sString)
		super.SetGFX(p_sString);
	endproc;
	
	proc void PlayAnim(int p_iPlayMode)
		AnimAction("sink");
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==TIMER_DELETE)then
				m_iState=2;
				var vec3 vP=GetPos();
				vP.SetZ(0.0f);
				MoveAction(vP, 100.0f);
			endif;
		endif;
	endproc;
	
	proc void OnMine()
	endproc;
	
	export destructor()
	enddestructor;
	
endclass;
	
// CCHAR_FOOD =================================
class CChar_Food inherit CFoodFood
	
	var int				m_iState;
	var int				m_iAggressive;
	const int			ROTTENTIMER=229;
	const int			COVERTIMER1=1923;
	const int			COVERTIMER2=1924;
	const int			TIMER_SPIRIT_CORPSE=40162;
	var CObjHndl	m_xCorpseObj;
	var string		m_sCaste;
	var CObjHndl	m_xHeadObj;
	var bool			m_bStillAnim;
	var int				m_iStillAnimFrame;
	var string		m_sAnim;
	var int				m_iPlayMode;
	var bool			m_bResurrecting;
	var bool			m_bDelImminent;
	
	constructor()
		m_iState=-1;
		m_iAggressive=0;
		m_sAnim="";
		m_sCaste="res";
		m_iPlayMode=1;
		m_bResurrecting=false;
		m_bDelImminent=false;
	endconstructor;
	
	export destructor()
		if(m_xHeadObj.IsValid())then
			m_xHeadObj.GetObj()^.Delete();
		endif;
	enddestructor;
	
	export proc void OnInit(bool p_bLoad)
		if(!p_bLoad)then
			SetDynamicBBox(true);
		endif;
		InitEvents();
		super.OnInit(p_bLoad);
		SetPlaceBlocker(false);
		var vec3 vPos=GetPos();
		var real fHeight=CSrvWrap.GetScapeMgr().GetHeight(vPos.GetX(),vPos.GetY());
		if(Math.Abs(vPos.GetZ()-fHeight)>1.0)then
			vPos.SetZ(fHeight);
			SetPos(vPos);
		endif;
		InvokeGenericSCEvent(40,4.0);
		if(!p_bLoad)then
			var ^CAttribs pxAttr=GetAttribs();
			if(pxAttr!=null)then
				var string sClassName=GetClassName();
				sClassName.Replace("_food","");
				sClassName.Replace("_corpse","");
				pxAttr^.SetValue("class",sClassName);
				pxAttr^.SetValue("Meat", true);
				pxAttr^.SetValue("food_guid", GetGuid().ToString());
			endif;
			var real fRottenDur=50.0f;
			CreateTimer(ROTTENTIMER, CGameTimeSpan.OneSecond()*fRottenDur, false);
		endif;
	endproc;
	
	export proc void SetCaste(string p_sCaste)
		m_sCaste=p_sCaste;
	endproc;
	
	export proc void SetHead(CObjHndl p_xHndl)
		m_xHeadObj=p_xHndl;
	endproc;
	
	export proc void SetStillAnim(string p_sAnim, int p_iFrame)
		m_sAnim=p_sAnim;
		m_iStillAnimFrame=p_iFrame;
		m_bStillAnim=true;
	endproc;
	
	export proc void SetDieAnim(string p_sAnim, bool p_bPlayAnim)
		m_sAnim=p_sAnim;
		if(p_bPlayAnim)then
			m_iPlayMode=1;
		else
			m_iPlayMode=0;
		endif;
	endproc;
	
	proc void PlayAnim(int p_iMode)
		if(m_bStillAnim)then
			SetAnim(m_sAnim, 0, m_iStillAnimFrame);
		else
			var string sA="dying";
			if(m_sAnim==""&&HasAnim(sA))then
				SetAnim(sA,p_iMode);
			elseif(HasAnim(m_sAnim))then
				SetAnim(m_sAnim,p_iMode);
			endif;
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="ChFo"; //Character Food
		var int iVersion=2;
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,iVersion);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		(pxArc^) << m_iAggressive;
		if(iVersion>=2)then
			(pxArc^) << m_bResurrecting;
			(pxArc^) << m_bDelImminent;
		endif;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="ChFo")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVer=p_pxReaderNode^.GetVersion();
			if(iVer>=1)then
				(pxArc^) << m_iAggressive;
			endif;
			if(iVer>=2)then
				(pxArc^) << m_bResurrecting;
				(pxArc^) << m_bDelImminent;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc int GetAggressive()
		return m_iAggressive;
	endproc;
	
	export proc void SetAggressive(int p_iValue)
		m_iAggressive=p_iValue;
	endproc;
	
	export proc void Initialize(^CFightingObj p_pxObj)
		if(p_pxObj==null)then return; endif;
		p_pxObj^.m_xCorpse=GetHandle();
		var ^CAttribs pxAttribs=GetAttribs();
		if(pxAttribs!=null)then
			pxAttribs^.SetValue("Meat", true);
			pxAttribs^.SetValue("ObjPath",p_pxObj^.GetObjPath());
		endif;
		var ^CUniversalCorpse pxGameObj=cast<CUniversalCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("Corpse",p_pxObj^.GetOwner(),p_pxObj^.GetPos(),p_pxObj^.GetRotation()));
		if(pxGameObj!=null)then
			pxGameObj^.SetSource(p_pxObj);
			pxGameObj^.SetVisible(false);
			pxGameObj^.SetFoodObj(GetHandle());
			m_xCorpseObj=pxGameObj^.GetHandle();
		endif;
	endproc;
	
	export proc void Init()
		PlayAnim(m_iPlayMode);
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==ROTTENTIMER)then
				m_bDelImminent=true;
				SetSkipThis();
				if(!m_bResurrecting&&!HasTimer(TIMER_SPIRIT_CORPSE))then
					Rot();
				endif;
			elseif(p_rxEvtPtr.GetInt(0)==TIMER_SPIRIT_CORPSE)then
				Rot();
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	proc void OnActionEnd(bool p_bBroken)
		if(m_iState==1)then
			if(m_xCorpseObj.IsValid())then
				m_xCorpseObj.GetObj()^.Delete();
			endif;
			Delete();
		endif;
	endproc;
	
	proc void Rot()
		var vec3 vSize=GetSize();
		vSize.SetX(0.0);
		vSize.SetY(0.0);
		SetSelectable(false);
		SetHitable(false);
		var real fRadius=GetRadius();
		if(fRadius<=3.5)then
			InvokeGenericSCEvent(18,4.0f);
		elseif(fRadius<=5.0)then
			InvokeGenericSCEvent(6,4.0f);
		else
			InvokeGenericSCEvent(19,4.0f);
		endif;
		MoveAction(GetPos()-vSize, (vSize.Abs()/5.0));
		m_iState=1;
	endproc;
	
	export proc real Mine(real p_fValue)
		if(!HasTimer(ROTTENTIMER))then
			return 0.0;
		else
			DeleteTimer(ROTTENTIMER);
			CreateTimer(ROTTENTIMER, CGameTimeSpan.OneSecond() * 50.0, false);
			var real fRet=super.Mine(p_fValue);
			if(m_xCorpseObj.IsValid())then
				var ^CUniversalCorpse pxCorpse=cast<CUniversalCorpse>(m_xCorpseObj.GetObj());
				if(pxCorpse!=null)then
					var ^CAttribs pxA=GetAttribs();
					if(pxA!=null)then
						var real fHP=pxA^.GetValueInt("hitpoints").ToReal();
						var real fMaxHP=pxA^.GetValueInt("maxhitpoints").ToReal();
						if(fMaxHP==0.0f)then
							pxCorpse^.SetHPPercent(0);
						else
							pxCorpse^.SetHPPercent((fHP/(fMaxHP*0.01f)).ToInt());
						endif;
					endif;
				endif;
			endif;
			return fRet;
		endif;
	endproc;
	
	proc void OnMine()
	endproc;
	
	export proc CObjHndl GetCorpseHandle()
		return m_xCorpseObj;
	endproc;
	
	export proc void SpiritCorpseTimer(bool p_bOn, real p_fDuration)
		var bool bPrev=m_bResurrecting;
		m_bResurrecting=p_bOn;
		if(p_fDuration>0.0f)then
			if(CMirageSrvMgr.Get().UnitResources())then
				if(HasTimer(TIMER_SPIRIT_CORPSE))then
					DeleteTimer(TIMER_SPIRIT_CORPSE);
				endif;
				CreateTimer(TIMER_SPIRIT_CORPSE,CGameTimeSpan.OneSecond()*(p_fDuration+2.0f),false);
			else
				if(!p_bOn&&m_bDelImminent)then
					Rot();
				endif;
			endif;
		else
			if(HasTimer(TIMER_SPIRIT_CORPSE))then
				DeleteTimer(TIMER_SPIRIT_CORPSE);
			endif;
			if(!p_bOn&&m_bDelImminent)then
				Rot();
			endif;
		endif;
	endproc;
	
	export proc bool SkipThis()
		return m_bDelImminent;
	endproc;
	
	export proc void RemoveFG()
		m_bDelImminent=true;
		SetSkipThis();
		if(!m_bResurrecting&&!HasTimer(TIMER_SPIRIT_CORPSE))then
//			Delete();
			Rot();
		endif;
		return;
	endproc;
	
endclass;
	
class CCustomCorpse inherit CUniversalCorpse
	
	var int					m_iState;
	
	export destructor()
	enddestructor;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="CCor")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			pxArc^ << m_iState;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="CCor";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		pxArc^ << m_iState;
		pxWalk^.Close();
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetVisible(true);
	endproc;
	
	export proc void Init(string p_sName, real p_fDuration)
		SetName(p_sName);
		InvokeGenericSCEvent(40,4.0);
		if(p_fDuration>0.0)then
			CreateTimer(TIMER_DELETE, CGameTimeSpan.OneSecond()*p_fDuration,false);
		endif;
		m_iState=1;
	endproc;
	
	export proc void Init(string p_sName, real p_fDuration, string p_sGfx)
		SetGFX(p_sGfx);
		SetName(p_sName);
		InvokeGenericSCEvent(40,4.0);
		if(p_fDuration>0.0)then
			CreateTimer(TIMER_DELETE, CGameTimeSpan.OneSecond()*p_fDuration,false);
		endif;
		m_iState=1;
	endproc;
	
	export proc void OnPostLoad()
		if(m_iState==2||m_iState==1)then
			Delete();
		endif;
	endproc;
	
	export proc void OnActionEnd(bool p_bBroken)
		if(m_iState==2)then
			Delete();
		endif;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==TIMER_DELETE)then
				m_iState=2;
				var vec3 vP=GetPos();
				vP.SetZ(0.0f);
				MoveAction(vP, 1.0f);
			endif;
		endif;
	endproc;
	
endclass;
	
class CFakeCorpse inherit CUniversalCorpse
	
	var int				m_iState;
	var CObjList	m_xFXObjects;
	var CObjList	m_xAddons;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="FCor")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xFXObjects.DoKArc(pxArc^);
			pxArc^ << m_iState;
			if(p_pxReaderNode^.GetVersion()>=2)then
				m_xAddons.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="FCor";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,2);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xFXObjects.DoKArc(pxArc^);
		pxArc^ << m_iState;
		m_xAddons.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetNoParticles(true);
		SetVisible(true);
	endproc;
	
	export proc void Init(string p_sName, real p_fDuration)
		SetName(p_sName);
		InvokeGenericSCEvent(40,4.0);
		if(p_fDuration>0.0)then
			CreateTimer(TIMER_DELETE, CGameTimeSpan.OneSecond()*p_fDuration,false);
		endif;
		var CObjHndl xHndl=AddFX("fire_corpses",-1.0);
		if(xHndl.IsValid())then
			var CFourCC xLink="NOPE";
			xHndl.GetObj()^.LinkAction(GetHandle(),xLink);
		endif;
		m_iState=1;
	endproc;
	
	export proc void Init(string p_sName, real p_fDuration, string p_sGfx)
		SetGFX(p_sGfx);
		SetName(p_sName);
		InvokeGenericSCEvent(40,4.0);
		if(p_fDuration>0.0)then
			CreateTimer(TIMER_DELETE, CGameTimeSpan.OneSecond()*p_fDuration,false);
		endif;
		var CObjHndl xHndl=AddFX("fire_corpses",-1.0);
		if(xHndl.IsValid())then
			var CFourCC xLink="NOPE";
			xHndl.GetObj()^.LinkAction(GetHandle(),xLink);
		endif;
		m_iState=1;
	endproc;
	
	export proc void OnPostLoad()
		if(m_iState==2||m_iState==1)then
			ClearFX();
			Delete();
		endif;
	endproc;
	
	export proc void OnActionEnd(bool p_bBroken)
		if(m_iState==2)then
			ClearFX();
			Delete();
		endif;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==TIMER_DELETE)then
				m_iState=2;
				var vec3 vP=GetPos();
				vP.SetZ(0.0f);
				MoveAction(vP, 1.0f);
			endif;
		endif;
	endproc;
	
	export destructor()
	enddestructor;
	
	export proc ref CObjHndl AddFX(string p_sFX, real p_fTime)
		var int iIndex;
		var bool bAlreadyExists=false;
		var int i, iC=m_xFXObjects.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFX pxObj=cast<CFX>(m_xFXObjects[i].GetObj());
			if(pxObj!=null&&pxObj^.GetFXClass()==p_sFX)then
				bAlreadyExists=true;
				iIndex=i;
				break;
			endif;
		endfor;
		if(!bAlreadyExists)then
			var ^CFX pxFX=cast<CFX>(CSrvWrap.GetObjMgr()^.CreateObj(p_sFX,GetOwner(),GetPos(),GetRotation()));
			if(pxFX!=null)then
				iIndex=m_xFXObjects.Include(pxFX^.GetHandle());
				if(p_fTime>0.0)then
					pxFX^.SetTimer(p_fTime);
				endif;
				pxFX^.SetFXClass(p_sFX);
				pxFX^.SetParent(GetHandle());
			endif;
		endif;
		return m_xFXObjects[iIndex];
	endproc;
	
	export proc void ClearFX()
		var int i;
		for(i=0)cond(i<m_xFXObjects.NumEntries())iter(i++)do
			var ^CFX pxObj=cast<CFX>(m_xFXObjects[i].GetObj());
			m_xFXObjects.DeleteEntry(i);
			if(pxObj!=null)then
				pxObj^.Delete();
			endif;
			i--;
		endfor;
		for(i=0)cond(i<m_xAddons.NumEntries())iter(i++)do
			var ^CGameObj pxO=m_xAddons[i].GetObj();
			m_xAddons.DeleteEntry(i);
			if(pxO!=null)then
				pxO^.Delete();
			endif;
			i--;
		endfor;
	endproc;
	
	export proc void AddAddons(CObjList p_xList)
		m_xAddons=p_xList;
	endproc;
	
endclass;
	
class CPteranodonCorpse inherit CUniversalCorpse
	
	export const int	TIMERID_SINK=40009;
	var int	m_iState;
	var vec3	m_vHeight;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="PCor")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			pxArc^ << m_iState;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="PCor";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,2);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		pxArc^ << m_iState;
		pxWalk^.Close();
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetVisible(true);
	endproc;
	
	export proc void Init(string p_sName, real p_fDuration)
		m_vHeight=GetPos();
		var real fAnimLength;
		SetAnim("dying",1,0,fAnimLength);
		SetName(p_sName);
		InvokeGenericSCEvent(40,4.0);
		if(p_fDuration>0.0)then
			CreateTimer(TIMER_DELETE, CGameTimeSpan.OneSecond()*p_fDuration,false);
		endif;
		m_iState=1;
	endproc;
	
	export proc void OnPostLoad()
		if(m_iState==2||m_iState==1)then
			Delete();
		endif;
	endproc;
	
	export proc void OnActionEnd(bool p_bBroken)
		if(m_iState==2)then
			SetAnim("dying",0,40);
			CreateTimer(TIMERID_SINK, CGameTimeSpan.OneSecond()*5.0f,false);
		elseif(m_iState==3)then
			Delete();
		endif;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==TIMER_DELETE)then
				m_iState=2;
				var real fHeight=CSrvWrap.GetScapeMgr().GetHeight(m_vHeight.GetX(),m_vHeight.GetY());
				var vec3 vP=GetPos();
				vP.SetZ(fHeight+3.5f);
				MoveAction(vP, 15.5f);
			elseif(iTimerID==TIMERID_SINK)then
				m_iState=3;
				var vec3 vP=GetPos();
				vP.SetZ(0.0f);
				MoveAction(vP, 1.0f);
			endif;
		endif;
	endproc;
	
	export destructor()
	enddestructor;
	
endclass;
	
class CScorpionCorpse inherit CUniversalCorpse
	
	var string	m_sGfx;
	var int			m_iState;
	const int		TIMERID_STILLSTAND=40000;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="SCor")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			pxArc^ << m_iState;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="SCor";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,2);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		pxArc^ << m_iState;
		pxWalk^.Close();
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetVisible(true);
	endproc;
	
	export proc void Init(string p_sGfx, string p_sName, real p_fDuration, real p_fStillStand)
		m_sGfx=p_sGfx;
		if(p_fStillStand>0.0)then
			CreateTimer(TIMERID_STILLSTAND, CGameTimeSpan.OneSecond()*p_fStillStand,false);
		endif;
		super.Init(p_sGfx+"_dest", p_sName, p_fDuration);
		m_iState=1;
	endproc;
	
	export proc void OnPostLoad()
		if(m_iState==2||m_iState==1)then
			Delete();
		endif;
	endproc;
	
	export proc void SetGFX(string p_sString)
		super.SetGFX(p_sString);
	endproc;
	
	proc void PlayAnim(int p_iPlayMode)
		AnimAction("destroy");
	endproc;
	
	export proc void OnActionEnd(bool p_bBroken)
		if(m_iState==2)then
			Delete();
		endif;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==TIMERID_STILLSTAND)then
				if(GetSourceClass()=="seas_final_boss"||GetSourceClass()=="seas_scorpion")then
					SetAnim("destroy",0,249);
				endif;
			elseif(iTimerID==TIMER_DELETE)then
				m_iState=2;
				var vec3 vP=GetPos();
				vP.SetZ(0.0f);
				MoveAction(vP, 1.0f);
			endif;
		endif;
	endproc;
	
	export destructor()
	enddestructor;
	
endclass;
	
class CScorpionStill inherit CUniversalCorpse
	
	var string	m_sGfx;
	var int		m_iState;
	
	export proc void OnInit(bool p_bLoad)
		SetAnim("stand_up",0,2);
		super.OnInit(p_bLoad);
		SetVisible(true);
	endproc;
	
	export proc void Init(string p_sGfx, string p_sName, real p_fDuration)
		m_sGfx=p_sGfx;
		super.Init(p_sGfx, p_sName, p_fDuration);
		m_iState=1;
		SetAnim("stand_up",0,2);
	endproc;
	
	export proc void OnPostLoad()
		if(m_iState==2||m_iState==1)then
			Delete();
		endif;
	endproc;
	
	export proc void OnActionEnd(bool p_bBroken)
		if(m_iState==2)then
			Delete();
		endif;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==TIMER_DELETE)then
				m_iState=2;
				var vec3 vP=GetPos();
				vP.SetZ(0.0f);
				MoveAction(vP, 1.0f);
			endif;
		endif;
	endproc;
	
endclass;
	
class CSiegeTowerCorpse inherit CUniversalCorpse
	
	var int						m_iState;
	var CObjList			m_xFXObjects;
	var vec3					m_vHeight;
	export const int	TIMERID_SINK=40011;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="SToC")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xFXObjects.DoKArc(pxArc^);
			pxArc^ << m_iState;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="SToC";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,2);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xFXObjects.DoKArc(pxArc^);
		pxArc^ << m_iState;
		pxWalk^.Close();
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetVisible(true);
	endproc;
	
	export proc void Init(string p_sName, real p_fDuration)
		SetName(p_sName);
		InvokeGenericSCEvent(40,4.0);
		if(p_fDuration>0.0)then
			CreateTimer(TIMER_DELETE, CGameTimeSpan.OneSecond()*p_fDuration,false);
		endif;
		var CObjHndl xHndl=AddFX("fire_corpses",-1.0);
		if(xHndl.IsValid())then
			var CFourCC xLink="NONE";
			xHndl.GetObj()^.LinkAction(GetHandle(),xLink);
		endif;
		m_iState=1;
	endproc;
	
	export proc void OnActionEnd(bool p_bBroken)
		if(m_iState==2)then
			ClearFX();
			Delete();
		endif;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==TIMER_DELETE)then
				m_iState=2;
				var vec3 vP=GetPos();
				vP.SetZ(0.0f);
				MoveAction(vP, 5.0f);
			endif;
		endif;
	endproc;
	
	export destructor()
	enddestructor;
	
	export proc ref CObjHndl AddFX(string p_sFX, real p_fTime)
		var int iIndex;
		var bool bAlreadyExists=false;
		var int i, iC=m_xFXObjects.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFX pxObj=cast<CFX>(m_xFXObjects[i].GetObj());
			if(pxObj!=null&&pxObj^.GetFXClass()==p_sFX)then
				bAlreadyExists=true;
				iIndex=i;
				break;
			endif;
		endfor;
		if(!bAlreadyExists)then
			var ^CFX pxFX=cast<CFX>(CSrvWrap.GetObjMgr()^.CreateObj(p_sFX,GetOwner(),GetPos(),GetRotation()));
			if(pxFX!=null)then
				iIndex=m_xFXObjects.Include(pxFX^.GetHandle());
				if(p_fTime>0.0)then
					pxFX^.SetTimer(p_fTime);
				endif;
				pxFX^.SetFXClass(p_sFX);
				pxFX^.SetParent(GetHandle());
			endif;
		endif;
		return m_xFXObjects[iIndex];
	endproc;
	
	export proc void ClearFX()
		var int i;
		for(i=0)cond(i<m_xFXObjects.NumEntries())iter(i++)do
			var ^CFX pxObj=cast<CFX>(m_xFXObjects[i].GetObj());
			m_xFXObjects.DeleteEntry(i);
			if(pxObj!=null)then
				pxObj^.Delete();
			endif;
			i--;
		endfor;
	endproc;
	
endclass;
	
// CSTONE_CORPSE =================================
class CStone_Corpse inherit CStone
	
	var int				m_iState;
	var int				m_iAggressive;
	const int			ROTTENTIMER=229;
	const int			AREADAMAGETIMER=1905;
	const int			TIMERID_STILLSTAND=40000;
	var CObjHndl	m_xCorpseObj;
	var bool			m_bStillAnim;
	var int				m_iStillAnimFrame;
	var string		m_sAnim;
	var int				m_iPlayMode;
	
	constructor()
		m_iState=-1;
		m_iAggressive=0;
		m_sAnim="";
		m_iPlayMode=1;
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		if(!p_bLoad)then
			SetDynamicBBox(true);
		endif;
		InitEvents();
		super.OnInit(p_bLoad);
		SetFreeBorderBlocker(false);
		CSrvWrap.GetPathfinder().RemPFBlocker(this);
		SetPlaceBlocker(false);
		//SetPlaceBlocker(true);
		var vec3 vPos=GetPos();
		var real fHeight=CSrvWrap.GetScapeMgr().GetHeight(vPos.GetX(),vPos.GetY());
		if(Math.Abs(vPos.GetZ()-fHeight)>1.0)then
			vPos.SetZ(fHeight);
			SetPos(vPos);
		endif;
		InvokeGenericSCEvent(40,4.0);
		if(!p_bLoad)then
			var ^CAttribs pxAttr=GetAttribs();
			if(pxAttr!=null)then
				var string sClassName=GetClassName();
				sClassName.Replace("_dest","");
				sClassName.Replace("_stone","");
				sClassName.Replace("_corpse","");
				pxAttr^.SetValue("class",sClassName);
			endif;
			var real fRottenDur=130.0f;
			CreateTimer(ROTTENTIMER, CGameTimeSpan.OneSecond()*fRottenDur, false);
		endif;
	endproc;
	
	export proc void AreaDamage(real p_fTime)
		if(!CResource.ms_bCORPSEDMG)then return; endif;
		CreateTimer(AREADAMAGETIMER,CGameTimeSpan.OneSecond()*p_fTime,false);
	endproc;
	
	export proc void SetStillAnim(string p_sAnim, int p_iFrame)
		m_sAnim=p_sAnim;
		m_iStillAnimFrame=p_iFrame;
		m_bStillAnim=true;
	endproc;
	
	export proc void SetDieAnim(string p_sAnim, bool p_bPlayAnim)
		m_sAnim=p_sAnim;
		if(p_bPlayAnim)then
			m_iPlayMode=1;
		else
			m_iPlayMode=0;
		endif;
	endproc;
	
	proc void PlayAnim(int p_iMode)
		if(m_bStillAnim)then
			SetAnim(m_sAnim, 0, m_iStillAnimFrame);
		else
			var string sA="dying";
			if(m_sAnim==""&&HasAnim(sA))then
				SetAnim(sA,p_iMode);
			elseif(HasAnim(m_sAnim))then
				SetAnim(m_sAnim,p_iMode);
			endif;
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="StCo"; //Character Food
		var int iVersion=1;
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,iVersion);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		(pxArc^) << m_iAggressive;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="StCo")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVer=p_pxReaderNode^.GetVersion();
			if(iVer>=1)then
				(pxArc^) << m_iAggressive;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc int GetAggressive()
		return m_iAggressive;
	endproc;
	
	export proc void SetAggressive(int p_iValue)
		m_iAggressive=p_iValue;
	endproc;
	
	export proc void Initialize(^CFightingObj p_pxObj)
		if(p_pxObj==null)then return; endif;
		var ^CVehicle pxVehicle=cast<CVehicle>(p_pxObj);
		if(pxVehicle!=null)then
			var bool bUpdate=UpdateValues(pxVehicle);
		elseif(p_pxObj^.GetClassName()=="special_mobile_suit")then
			var ^CSpecialMobileSuit pxSuit=cast<CSpecialMobileSuit>(p_pxObj);
			if(pxSuit!=null)then
				var bool bUpdate=UpdateValues(pxSuit);
			endif;
		else
			var ^CCharacter pxCharacter=cast<CCharacter>(p_pxObj);
			if(pxCharacter!=null)then
				var bool bUpdate=UpdateValuesSpecial(pxCharacter);
			endif;
		endif;
		var ^CAttribs pxAttribs=GetAttribs();
		if(pxAttribs!=null)then
			pxAttribs^.SetValue("ObjPath",p_pxObj^.GetObjPath());
		endif;
		var ^CUniversalCorpse pxGameObj=cast<CUniversalCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("Corpse",p_pxObj^.GetOwner(),p_pxObj^.GetPos(),p_pxObj^.GetRotation()));
		if(pxGameObj!=null)then
			pxGameObj^.SetSource(p_pxObj);
			pxGameObj^.SetVisible(false);
			pxGameObj^.SetFoodObj(GetHandle());
			m_xCorpseObj=pxGameObj^.GetHandle();
		endif;
	endproc;
	
	export proc void Init()
		PlayAnim(m_iPlayMode);
	endproc;
	
	export proc void Init(real p_fStillStand, int p_iLastFrame)
		if(p_fStillStand>0.0)then
			m_iStillAnimFrame=p_iLastFrame;
			CreateTimer(TIMERID_STILLSTAND, CGameTimeSpan.OneSecond()*p_fStillStand,false);
		endif;
		PlayAnim(m_iPlayMode);
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==ROTTENTIMER)then
				Rot();
			elseif(p_rxEvtPtr.GetInt(0)==TIMERID_STILLSTAND)then
				SetAnim(m_sAnim,0,m_iStillAnimFrame);
			elseif(p_rxEvtPtr.GetInt(0)==AREADAMAGETIMER)then
				var ^CAreaDamage pxDmg=new CAreaDamage(GetCollisionRadius()+5.0f,300.0,150.0,GetOwner(),GetPos(),10);
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	proc void OnActionEnd(bool p_bBroken)
		if(m_iState==1)then
			if(m_xCorpseObj.IsValid())then
				m_xCorpseObj.GetObj()^.Delete();
			endif;
			Delete();
		endif;
	endproc;
	
	proc void Rot()
		var vec3 vSize=GetSize();
		vSize.SetX(0.0);
		vSize.SetY(0.0);
		SetSelectable(false);
		SetHitable(false);
		var real fRadius=GetRadius();
		if(fRadius<=3.5)then
			InvokeGenericSCEvent(18,4.0f);
		elseif(fRadius<=5.0)then
			InvokeGenericSCEvent(6,4.0f);
		else
			InvokeGenericSCEvent(19,4.0f);
		endif;
		MoveAction(GetPos()-vSize, (vSize.Abs()/5.0));
		m_iState=1;
	endproc;
	
	export proc real Mine(real p_fValue)
		if(!HasTimer(ROTTENTIMER))then
			return 0.0;
		else
			DeleteTimer(ROTTENTIMER);
			CreateTimer(ROTTENTIMER, CGameTimeSpan.OneSecond() * 130.0, false);
			var real fRet=super.Mine(p_fValue);
			if(m_xCorpseObj.IsValid())then
				var ^CUniversalCorpse pxCorpse=cast<CUniversalCorpse>(m_xCorpseObj.GetObj());
				if(pxCorpse!=null)then
					var ^CAttribs pxA=GetAttribs();
					if(pxA!=null)then
						var real fHP=pxA^.GetValueInt("hitpoints").ToReal();
						var real fMaxHP=pxA^.GetValueInt("maxhitpoints").ToReal();
						if(fMaxHP==0.0f)then
							pxCorpse^.SetHPPercent(0);
						else
							pxCorpse^.SetHPPercent((fHP/(fMaxHP*0.01f)).ToInt());
						endif;
					endif;
				endif;
			endif;
			return fRet;
		endif;
	endproc;
	
	export proc CObjHndl GetCorpseHandle()
		return m_xCorpseObj;
	endproc;
	
//	export proc bool UpdateValues(^CVehicle p_pxVehicle)
	export proc bool UpdateValues(^CTransportObj p_pxVehicle)
		if(p_pxVehicle==null)then return true; endif;
		var ^CAttribs pxAttribs=GetAttribs();
		var ^CPropDB pxTable=CServerApp.GetPropDB_Resources();
		if(pxTable!=null)then
			var ^CPropDB.CNode pxRoot=^(pxTable^.GetRoot());
			if(pxRoot!=null)then
				var ^CPropDB.CNode pxType=pxRoot^.Get("STON");
				if(pxType!=null)then
					var ^CPropDB.CNode pxResource=pxType^.Get(p_pxVehicle^.GetClassName()+"_wreck");
					if(pxResource!=null)then
						m_fValue=pxResource^.GetValueI("value").ToReal();
						pxAttribs^.SetValue("value",m_fValue.ToInt());
						pxAttribs^.SetValue("hitpoints",m_fValue.ToInt());
						pxAttribs^.SetValue("maxhitpoints",m_fValue.ToInt());
					endif;
				endif;
			endif;
		endif;
		return true;
	endproc;
	
	//ParaworldFan: "UpdateValues" for specific classnames, that are "CHTR" type, but with "STONE" corpse resource
	export proc bool UpdateValuesSpecial(^CCharacter p_pxCharacter)
		if(p_pxCharacter==null)then return true; endif;
		var ^CAttribs pxAttribs=GetAttribs();
		var ^CPropDB pxTable=CServerApp.GetPropDB_Resources();
		if(pxTable!=null)then
			var ^CPropDB.CNode pxRoot=^(pxTable^.GetRoot());
			if(pxRoot!=null)then
				var ^CPropDB.CNode pxType=pxRoot^.Get("STON");
				if(pxType!=null)then
					var ^CPropDB.CNode pxResource=pxType^.Get(p_pxCharacter^.GetClassName()+"_wreck");
					if(pxResource!=null)then
						m_fValue=pxResource^.GetValueI("value").ToReal();
						pxAttribs^.SetValue("value",m_fValue.ToInt());
						pxAttribs^.SetValue("hitpoints",m_fValue.ToInt());
						pxAttribs^.SetValue("maxhitpoints",m_fValue.ToInt());
					endif;
				endif;
			endif;
		endif;
		return true;
	endproc;
	
endclass;
	
// CWOOD_CORPSE =================================
class CWood_Corpse inherit CWood
	
	var int				m_iState;
	var int				m_iAggressive;
	const int			ROTTENTIMER=229;
	var CObjHndl	m_xCorpseObj;
	var bool			m_bStillAnim;
	var int				m_iStillAnimFrame;
	var string		m_sAnim;
	var int				m_iPlayMode;
	
	constructor()
		m_iState=-1;
		m_iAggressive=0;
		m_sAnim="";
		m_iPlayMode=1;
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		InitEvents();
		super.OnInit(p_bLoad);
		SetPlaceBlocker(false);
		var vec3 vPos=GetPos();
		var real fHeight=CSrvWrap.GetScapeMgr().GetHeight(vPos.GetX(),vPos.GetY());
		if(Math.Abs(vPos.GetZ()-fHeight)>1.0)then
			vPos.SetZ(fHeight);
			SetPos(vPos);
		endif;
		InvokeGenericSCEvent(40,4.0);
		if(!p_bLoad)then
			var ^CAttribs pxAttr=GetAttribs();
			if(pxAttr!=null)then
				var string sClassName=GetClassName();
				sClassName.Replace("_dest","");
				sClassName.Replace("_wood","");
				sClassName.Replace("_corpse","");
				pxAttr^.SetValue("class",sClassName);
			endif;
			var real fRottenDur=125.0f;
			CreateTimer(ROTTENTIMER, CGameTimeSpan.OneSecond()*fRottenDur, false);
		endif;
	endproc;
	
	export proc void SetStillAnim(string p_sAnim, int p_iFrame)
		m_sAnim=p_sAnim;
		m_iStillAnimFrame=p_iFrame;
		m_bStillAnim=true;
	endproc;
	
	export proc void SetDieAnim(string p_sAnim, bool p_bPlayAnim)
		m_sAnim=p_sAnim;
		if(p_bPlayAnim)then
			m_iPlayMode=1;
		else
			m_iPlayMode=0;
		endif;
	endproc;
	
	proc void PlayAnim(int p_iMode)
		if(m_bStillAnim)then
			SetAnim(m_sAnim, 0, m_iStillAnimFrame);
		else
			var string sA="dying";
			if(m_sAnim==""&&HasAnim(sA))then
				SetAnim(sA,p_iMode);
			elseif(HasAnim(m_sAnim))then
				SetAnim(m_sAnim,p_iMode);
			endif;
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
	
		var CFourCC xBase="WoCo"; //Character Food
		var int iVersion=1;
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,iVersion);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		(pxArc^) << m_iAggressive;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="WoCo")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVer=p_pxReaderNode^.GetVersion();
			if(iVer>=1)then
				(pxArc^) << m_iAggressive;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc int GetAggressive()
		return m_iAggressive;
	endproc;
	
	export proc void SetAggressive(int p_iValue)
		m_iAggressive=p_iValue;
	endproc;
	
	export proc void Initialize(^CFightingObj p_pxObj)
		if(p_pxObj==null)then return; endif;
		var ^CVehicle pxVehicle=cast<CVehicle>(p_pxObj);
		if(pxVehicle!=null)then
			var bool bUpdate=UpdateValues(pxVehicle);
		endif;
		var ^CAttribs pxAttribs=GetAttribs();
		if(pxAttribs!=null)then
			pxAttribs^.SetValue("ObjPath",p_pxObj^.GetObjPath());
		endif;
		var ^CUniversalCorpse pxGameObj=cast<CUniversalCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("Corpse",p_pxObj^.GetOwner(),p_pxObj^.GetPos(),p_pxObj^.GetRotation()));
		if(pxGameObj!=null)then
			pxGameObj^.SetSource(p_pxObj);
			pxGameObj^.SetVisible(false);
			pxGameObj^.SetFoodObj(GetHandle());
			m_xCorpseObj=pxGameObj^.GetHandle();
		endif;
	endproc;
	
	export proc void Init()
		PlayAnim(m_iPlayMode);
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==ROTTENTIMER)then
				Rot();
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	proc void OnActionEnd(bool p_bBroken)
		if(m_iState==1)then
			if(m_xCorpseObj.IsValid())then
				m_xCorpseObj.GetObj()^.Delete();
			endif;
			Delete();
		endif;
	endproc;
	
	proc void Rot()
		var vec3 vSize=GetSize();
		vSize.SetX(0.0);
		vSize.SetY(0.0);
		SetSelectable(false);
		SetHitable(false);
		var real fRadius=GetRadius();
		if(fRadius<=3.5)then
			InvokeGenericSCEvent(18,4.0f);
		elseif(fRadius<=5.0)then
			InvokeGenericSCEvent(6,4.0f);
		else
			InvokeGenericSCEvent(19,4.0f);
		endif;
		MoveAction(GetPos()-vSize, (vSize.Abs()/5.0));
		m_iState=1;
	endproc;
	
	export proc real Mine(real p_fValue)
		if(!HasTimer(ROTTENTIMER))then
			return 0.0;
		else
			DeleteTimer(ROTTENTIMER);
			CreateTimer(ROTTENTIMER, CGameTimeSpan.OneSecond() * 150.0, false);
			var real fRet=super.Mine(p_fValue);
			if(m_xCorpseObj.IsValid())then
				var ^CUniversalCorpse pxCorpse=cast<CUniversalCorpse>(m_xCorpseObj.GetObj());
				if(pxCorpse!=null)then
					var ^CAttribs pxA=GetAttribs();
					if(pxA!=null)then
						var real fHP=pxA^.GetValueInt("hitpoints").ToReal();
						var real fMaxHP=pxA^.GetValueInt("maxhitpoints").ToReal();
						if(fMaxHP==0.0f)then
							pxCorpse^.SetHPPercent(0);
						else
							pxCorpse^.SetHPPercent((fHP/(fMaxHP*0.01f)).ToInt());
						endif;
					endif;
				endif;
			endif;
			return fRet;
		endif;
	endproc;
	
	export proc CObjHndl GetCorpseHandle()
		return m_xCorpseObj;
	endproc;
	
	export proc bool UpdateValues(^CVehicle p_pxVehicle)
		if(p_pxVehicle==null)then return true; endif;
		var ^CAttribs pxAttribs=GetAttribs();
		var ^CPropDB pxTable=CServerApp.GetPropDB_Resources();
		if(pxTable!=null)then
			var ^CPropDB.CNode pxRoot=^(pxTable^.GetRoot());
			if(pxRoot!=null)then
				var ^CPropDB.CNode pxType=pxRoot^.Get("WOOD");
				if(pxType!=null)then
					var ^CPropDB.CNode pxResource=pxType^.Get(p_pxVehicle^.GetClassName()+"_wreck");
					if(pxResource!=null)then
						m_fValue=pxResource^.GetValueI("value").ToReal();
						pxAttribs^.SetValue("value",m_fValue.ToInt());
						pxAttribs^.SetValue("hitpoints",m_fValue.ToInt());
						pxAttribs^.SetValue("maxhitpoints",m_fValue.ToInt());
					endif;
				endif;
			endif;
		endif;
		return true;
	endproc;
	
endclass;
	
// CBLDG_CORPSE_STONE =================================
class CBldg_Corpse_Stone inherit CStone
	
	var int				m_iState;
	var int				m_iAggressive;
	const int			ROTTENTIMER=229;
	var CObjHndl		m_xCorpseObj;
	var bool			m_bStillAnim;
	var int				m_iStillAnimFrame;
	var string			m_sAnim;
	var int				m_iPlayMode;
	
	constructor()
		m_iState=-1;
		m_iAggressive=0;
		m_sAnim="";
		m_iPlayMode=1;
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		InitEvents();
		super.OnInit(p_bLoad);
		SetPlaceBlocker(true);
		var vec3 vPos=GetPos();
		var real fHeight=CSrvWrap.GetScapeMgr().GetHeight(vPos.GetX(),vPos.GetY());
		if(Math.Abs(vPos.GetZ()-fHeight)>1.0)then
			vPos.SetZ(fHeight);
			SetPos(vPos);
		endif;
		InvokeGenericSCEvent(40,4.0);
		if(!p_bLoad)then
			var ^CAttribs pxAttr=GetAttribs();
			if(pxAttr!=null)then
				var string sClassName=GetClassName();
				sClassName.Replace("_dest","");
				pxAttr^.SetValue("class",sClassName);
			endif;
			var real fRottenDur=125.0f;
			CreateTimer(ROTTENTIMER, CGameTimeSpan.OneSecond()*fRottenDur, false);
		endif;
	endproc;
	
	export proc void SetStillAnim(string p_sAnim, int p_iFrame)
		m_sAnim=p_sAnim;
		m_iStillAnimFrame=p_iFrame;
		m_bStillAnim=true;
	endproc;
	
	export proc void SetDieAnim(string p_sAnim, bool p_bPlayAnim)
		m_sAnim=p_sAnim;
		if(p_bPlayAnim)then
			m_iPlayMode=1;
		else
			m_iPlayMode=0;
		endif;
	endproc;
	
	proc void PlayAnim(int p_iMode)
		if(m_bStillAnim)then
			SetAnim(m_sAnim, 0, m_iStillAnimFrame);
		else
			var string sA="dying";
			if(m_sAnim==""&&HasAnim(sA))then
				SetAnim(sA,p_iMode);
			elseif(HasAnim(m_sAnim))then
				SetAnim(m_sAnim,p_iMode);
			endif;
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
	
		var CFourCC xBase="WoCo"; //Character Food
		var int iVersion=1;
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,iVersion);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		(pxArc^) << m_iAggressive;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="WoCo")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVer=p_pxReaderNode^.GetVersion();
			if(iVer>=1)then
				(pxArc^) << m_iAggressive;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc int GetAggressive()
		return m_iAggressive;
	endproc;
	
	export proc void SetAggressive(int p_iValue)
		m_iAggressive=p_iValue;
	endproc;
	
	export proc void Initialize(^CFightingObj p_pxObj)
		if(p_pxObj==null)then return; endif;
		var ^CBuilding pxBuilding=cast<CBuilding>(p_pxObj);
		if(pxBuilding!=null)then
			var bool bUpdate=UpdateValues(pxBuilding);
		endif;
		var ^CAttribs pxAttribs=GetAttribs();
		if(pxAttribs!=null)then
			pxAttribs^.SetValue("ObjPath",p_pxObj^.GetObjPath());
		endif;
		var ^CUniversalCorpse pxGameObj=cast<CUniversalCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("Corpse",p_pxObj^.GetOwner(),p_pxObj^.GetPos(),p_pxObj^.GetRotation()));
		if(pxGameObj!=null)then
			pxGameObj^.SetSource(p_pxObj);
			pxGameObj^.SetVisible(false);
			pxGameObj^.SetFoodObj(GetHandle());
			m_xCorpseObj=pxGameObj^.GetHandle();
		endif;
	endproc;
	
	export proc void Init()
		PlayAnim(m_iPlayMode);
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==ROTTENTIMER)then
				Rot();
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	proc void OnActionEnd(bool p_bBroken)
		if(m_iState==1)then
			if(m_xCorpseObj.IsValid())then
				m_xCorpseObj.GetObj()^.Delete();
			endif;
			Delete();
		endif;
	endproc;
	
	proc void Rot()
		var vec3 vSize=GetSize();
		vSize.SetX(0.0);
		vSize.SetY(0.0);
		SetSelectable(false);
		SetHitable(false);
		var real fRadius=GetRadius();
		if(fRadius<=3.5)then
			InvokeGenericSCEvent(18,4.0f);
		elseif(fRadius<=5.0)then
			InvokeGenericSCEvent(6,4.0f);
		else
			InvokeGenericSCEvent(19,4.0f);
		endif;
		MoveAction(GetPos()-vSize, (vSize.Abs()/5.0));
		m_iState=1;
	endproc;
	
	export proc real Mine(real p_fValue)
		if(!HasTimer(ROTTENTIMER))then
			return 0.0;
		else
			DeleteTimer(ROTTENTIMER);
			CreateTimer(ROTTENTIMER, CGameTimeSpan.OneSecond() * 150.0, false);
			var real fRet=super.Mine(p_fValue);
			if(m_xCorpseObj.IsValid())then
				var ^CUniversalCorpse pxCorpse=cast<CUniversalCorpse>(m_xCorpseObj.GetObj());
				if(pxCorpse!=null)then
					var ^CAttribs pxA=GetAttribs();
					if(pxA!=null)then
						var real fHP=pxA^.GetValueInt("hitpoints").ToReal();
						var real fMaxHP=pxA^.GetValueInt("maxhitpoints").ToReal();
						if(fMaxHP==0.0f)then
							pxCorpse^.SetHPPercent(0);
						else
							pxCorpse^.SetHPPercent((fHP/(fMaxHP*0.01f)).ToInt());
						endif;
					endif;
				endif;
			endif;
			return fRet;
		endif;
	endproc;
	
	export proc CObjHndl GetCorpseHandle()
		return m_xCorpseObj;
	endproc;
	
	export proc bool UpdateValues(^CBuilding p_pxBuilding)
		if(p_pxBuilding==null)then return true; endif;
		var ^CAttribs pxAttribs=GetAttribs();
		var ^CPropDB pxTable=CServerApp.GetPropDB_Resources();
		if(pxTable!=null)then
			var ^CPropDB.CNode pxRoot=^(pxTable^.GetRoot());
			if(pxRoot!=null)then
				var ^CPropDB.CNode pxType=pxRoot^.Get("STON");
				if(pxType!=null)then
					var ^CPropDB.CNode pxResource=pxType^.Get(p_pxBuilding^.GetClassName()+"_wreck");
					if(pxResource!=null)then
						m_fValue=pxResource^.GetValueI("value").ToReal();
						pxAttribs^.SetValue("value",m_fValue.ToInt());
						pxAttribs^.SetValue("hitpoints",m_fValue.ToInt());
						pxAttribs^.SetValue("maxhitpoints",m_fValue.ToInt());
					endif;
				endif;
			endif;
		endif;
		return true;
	endproc;
endclass;

// CBLDG_CORPSE_WOOD =================================
class CBldg_Corpse_Wood inherit CWood
	
	var int				m_iState;
	var int				m_iAggressive;
	const int			ROTTENTIMER=229;
	var CObjHndl		m_xCorpseObj;
	var bool			m_bStillAnim;
	var int				m_iStillAnimFrame;
	var string			m_sAnim;
	var int				m_iPlayMode;
	
	constructor()
		m_iState=-1;
		m_iAggressive=0;
		m_sAnim="";
		m_iPlayMode=1;
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		InitEvents();
		super.OnInit(p_bLoad);
		SetPlaceBlocker(true);
		var vec3 vPos=GetPos();
		var real fHeight=CSrvWrap.GetScapeMgr().GetHeight(vPos.GetX(),vPos.GetY());
		if(Math.Abs(vPos.GetZ()-fHeight)>1.0)then
			vPos.SetZ(fHeight);
			SetPos(vPos);
		endif;
		InvokeGenericSCEvent(40,4.0);
		if(!p_bLoad)then
			var ^CAttribs pxAttr=GetAttribs();
			if(pxAttr!=null)then
				var string sClassName=GetClassName();
				sClassName.Replace("_dest","");
				pxAttr^.SetValue("class",sClassName);
			endif;
			var real fRottenDur=125.0f;
			CreateTimer(ROTTENTIMER, CGameTimeSpan.OneSecond()*fRottenDur, false);
		endif;
	endproc;
	
	export proc void SetStillAnim(string p_sAnim, int p_iFrame)
		m_sAnim=p_sAnim;
		m_iStillAnimFrame=p_iFrame;
		m_bStillAnim=true;
	endproc;
	
	export proc void SetDieAnim(string p_sAnim, bool p_bPlayAnim)
		m_sAnim=p_sAnim;
		if(p_bPlayAnim)then
			m_iPlayMode=1;
		else
			m_iPlayMode=0;
		endif;
	endproc;
	
	proc void PlayAnim(int p_iMode)
		if(m_bStillAnim)then
			SetAnim(m_sAnim, 0, m_iStillAnimFrame);
		else
			var string sA="dying";
			if(m_sAnim==""&&HasAnim(sA))then
				SetAnim(sA,p_iMode);
			elseif(HasAnim(m_sAnim))then
				SetAnim(m_sAnim,p_iMode);
			endif;
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
	
		var CFourCC xBase="WoCo"; //Character Food
		var int iVersion=1;
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,iVersion);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		(pxArc^) << m_iAggressive;
		pxWalk^.Close();
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="WoCo")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVer=p_pxReaderNode^.GetVersion();
			if(iVer>=1)then
				(pxArc^) << m_iAggressive;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc int GetAggressive()
		return m_iAggressive;
	endproc;
	
	export proc void SetAggressive(int p_iValue)
		m_iAggressive=p_iValue;
	endproc;
	
	export proc void Initialize(^CFightingObj p_pxObj)
		if(p_pxObj==null)then return; endif;
		var ^CBuilding pxBuilding=cast<CBuilding>(p_pxObj);
		if(pxBuilding!=null)then
			var bool bUpdate=UpdateValues(pxBuilding);
		endif;
		var ^CAttribs pxAttribs=GetAttribs();
		if(pxAttribs!=null)then
			pxAttribs^.SetValue("ObjPath",p_pxObj^.GetObjPath());
		endif;
		var ^CUniversalCorpse pxGameObj=cast<CUniversalCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("Corpse",p_pxObj^.GetOwner(),p_pxObj^.GetPos(),p_pxObj^.GetRotation()));
		if(pxGameObj!=null)then
			pxGameObj^.SetSource(p_pxObj);
			pxGameObj^.SetVisible(false);
			pxGameObj^.SetFoodObj(GetHandle());
			m_xCorpseObj=pxGameObj^.GetHandle();
		endif;
	endproc;
	
	export proc void Init()
		PlayAnim(m_iPlayMode);
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==ROTTENTIMER)then
				Rot();
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	proc void OnActionEnd(bool p_bBroken)
		if(m_iState==1)then
			if(m_xCorpseObj.IsValid())then
				m_xCorpseObj.GetObj()^.Delete();
			endif;
			Delete();
		endif;
	endproc;
	
	proc void Rot()
		var vec3 vSize=GetSize();
		vSize.SetX(0.0);
		vSize.SetY(0.0);
		SetSelectable(false);
		SetHitable(false);
		var real fRadius=GetRadius();
		if(fRadius<=3.5)then
			InvokeGenericSCEvent(18,4.0f);
		elseif(fRadius<=5.0)then
			InvokeGenericSCEvent(6,4.0f);
		else
			InvokeGenericSCEvent(19,4.0f);
		endif;
		MoveAction(GetPos()-vSize, (vSize.Abs()/5.0));
		m_iState=1;
	endproc;
	
	export proc real Mine(real p_fValue)
		if(!HasTimer(ROTTENTIMER))then
			return 0.0;
		else
			DeleteTimer(ROTTENTIMER);
			CreateTimer(ROTTENTIMER, CGameTimeSpan.OneSecond() * 150.0, false);
			var real fRet=super.Mine(p_fValue);
			if(m_xCorpseObj.IsValid())then
				var ^CUniversalCorpse pxCorpse=cast<CUniversalCorpse>(m_xCorpseObj.GetObj());
				if(pxCorpse!=null)then
					var ^CAttribs pxA=GetAttribs();
					if(pxA!=null)then
						var real fHP=pxA^.GetValueInt("hitpoints").ToReal();
						var real fMaxHP=pxA^.GetValueInt("maxhitpoints").ToReal();
						if(fMaxHP==0.0f)then
							pxCorpse^.SetHPPercent(0);
						else
							pxCorpse^.SetHPPercent((fHP/(fMaxHP*0.01f)).ToInt());
						endif;
					endif;
				endif;
			endif;
			return fRet;
		endif;
	endproc;
	
	export proc CObjHndl GetCorpseHandle()
		return m_xCorpseObj;
	endproc;
	
	export proc bool UpdateValues(^CBuilding p_pxBuilding)
		if(p_pxBuilding==null)then return true; endif;
		var ^CAttribs pxAttribs=GetAttribs();
		var ^CPropDB pxTable=CServerApp.GetPropDB_Resources();
		if(pxTable!=null)then
			var ^CPropDB.CNode pxRoot=^(pxTable^.GetRoot());
			if(pxRoot!=null)then
				var ^CPropDB.CNode pxType=pxRoot^.Get("WOOD");
				if(pxType!=null)then
					var ^CPropDB.CNode pxResource=pxType^.Get(p_pxBuilding^.GetClassName()+"_wreck");
					if(pxResource!=null)then
						m_fValue=pxResource^.GetValueI("value").ToReal();
						pxAttribs^.SetValue("value",m_fValue.ToInt());
						pxAttribs^.SetValue("hitpoints",m_fValue.ToInt());
						pxAttribs^.SetValue("maxhitpoints",m_fValue.ToInt());
					endif;
				endif;
			endif;
		endif;
		return true;
	endproc;
endclass;
	
class CWreckageStill inherit CUniversalCorpse
	
	var string		m_sGfx;
	var int				m_iState;
	
	export proc void OnInit(bool p_bLoad)
		SetAnim("dying",0,60);
		super.OnInit(p_bLoad);
		SetVisible(true);
	endproc;
	
	export proc void Init(string p_sGfx,string p_sName,real p_fDuration,int p_iLast)
		m_sGfx=p_sGfx;
		super.Init(p_sGfx, p_sName, p_fDuration);
		m_iState=1;
		SetAnim("dying",0,p_iLast);
	endproc;
	
	export proc void OnPostLoad()
		if(m_iState==2||m_iState==1)then
			Delete();
		endif;
	endproc;
	
	export proc void OnActionEnd(bool p_bBroken)
		if(m_iState==2)then
			Delete();
		endif;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==TIMER_DELETE)then
				m_iState=2;
				var vec3 vP=GetPos();
				vP.SetZ(0.0f);
				MoveAction(vP, 1.0f);
			endif;
		endif;
	endproc;
	
endclass;
	
class CZeppelinCorpse inherit CUniversalCorpse
	
	var int							m_iState;
	var CObjList				m_xFXObjects;
	var vec3						m_vHeight;
	export const int		TIMERID_SINK=40010;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="ZCor")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xFXObjects.DoKArc(pxArc^);
			pxArc^ << m_iState;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="ZCor";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,2);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xFXObjects.DoKArc(pxArc^);
		pxArc^ << m_iState;
		pxWalk^.Close();
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetVisible(true);
	endproc;
	
	export proc void Init(string p_sName, real p_fDuration)
		SetName(p_sName);
		InvokeGenericSCEvent(40,4.0);
		if(p_fDuration>0.0)then
			CreateTimer(TIMER_DELETE, CGameTimeSpan.OneSecond()*p_fDuration,false);
		endif;
		var CObjHndl xHndl=AddFX("fire_corpses",-1.0);
		if(xHndl.IsValid())then
			var CFourCC xLink="Dri2";
			xHndl.GetObj()^.LinkAction(GetHandle(),xLink);
		endif;
		m_iState=1;
	endproc;
	
	export proc void OnActionEnd(bool p_bBroken)
		if(m_iState==2)then
			CreateTimer(TIMERID_SINK, CGameTimeSpan.OneSecond()*5.0f,false);
		elseif(m_iState==3)then
			ClearFX();
			Delete();
		endif;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==TIMER_DELETE)then
				m_iState=2;
				var vec3 vP=GetPos();
				var real fHeight=CSrvWrap.GetScapeMgr().GetHeight(vP.GetX(),vP.GetY());
				fHeight-=12.26f;
//				vP.SetZ(fHeight+6.8f);
				vP.SetZ(fHeight);
				MoveAction(vP, 15.5f);
			elseif(iTimerID==TIMERID_SINK)then
				m_iState=3;
				var vec3 vP=GetPos();
				vP.SetZ(0.0f);
				MoveAction(vP, 1.0f);
			endif;
		endif;
	endproc;
	
	export destructor()
	enddestructor;
	
	export proc ref CObjHndl AddFX(string p_sFX, real p_fTime)
		var int iIndex;
		var bool bAlreadyExists=false;
		var int i, iC=m_xFXObjects.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFX pxObj=cast<CFX>(m_xFXObjects[i].GetObj());
			if(pxObj!=null&&pxObj^.GetFXClass()==p_sFX)then
				bAlreadyExists=true;
				iIndex=i;
				break;
			endif;
		endfor;
		if(!bAlreadyExists)then
			var ^CFX pxFX=cast<CFX>(CSrvWrap.GetObjMgr()^.CreateObj(p_sFX,GetOwner(),GetPos(),GetRotation()));
			if(pxFX!=null)then
				iIndex=m_xFXObjects.Include(pxFX^.GetHandle());
				if(p_fTime>0.0)then
					pxFX^.SetTimer(p_fTime);
				endif;
				pxFX^.SetFXClass(p_sFX);
				pxFX^.SetParent(GetHandle());
			endif;
		endif;
		return m_xFXObjects[iIndex];
	endproc;
	
	export proc void ClearFX()
		var int i;
		for(i=0)cond(i<m_xFXObjects.NumEntries())iter(i++)do
			var ^CFX pxObj=cast<CFX>(m_xFXObjects[i].GetObj());
			m_xFXObjects.DeleteEntry(i);
			if(pxObj!=null)then
				pxObj^.Delete();
			endif;
			i--;
		endfor;
	endproc;
	
endclass;
	
	//========================================================================================
	//=== Decorations ========================================================================
	//========================================================================================
	
class CNestBuildUp inherit CTaskBuildUp
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetHitable(false);
		SetSelectable(false);
	endproc;
	
endclass;
	
class CMirageDeco inherit CTaskBuildUp
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetHitable(false);
		SetSelectable(false);
	endproc;
	
endclass;
	
	//========================================================================================
	//=== Classes from CEP, big thanks to AyCe ===============================================
	//========================================================================================
	
// Author: AyCe
	
class CBuildUpMgr
	
	var CObjHndl					m_xFakeBU;
	var int								m_iConstructLevel;
	var int								m_iDestructLevel;
	var CObjHndl					m_xParent;
	var bool							m_bStarted;
	var bool							m_bEnded;
	var bool							m_bInited;
	var real							m_fHeight;
	var real							m_fHeightOffset;
	
	export constructor()
		m_bStarted=false;
		m_bEnded=false;
		m_bInited=false;
	endconstructor;
	
	export destructor()
		DieAndOut(false);
	enddestructor;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="BUMg")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xFakeBU.DoKArc(pxArc^);
			(pxArc^) << m_iConstructLevel;
			(pxArc^) << m_iDestructLevel;
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		var CFourCC xBase="BUMg";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xFakeBU.DoKArc(pxArc^);
		(pxArc^) << m_iConstructLevel;
		(pxArc^) << m_iDestructLevel;
		pxWalk^.Close();
	endproc;
	
	proc ^CBuilding GetObj()
		if(!m_xParent.IsValid())then
			DieAndOut(false);
		endif;
		var ^CBuilding pxO=cast<CBuilding>(m_xParent.GetObj());
		if(pxO==null)then
			DieAndOut(false);
		endif;
		return pxO;
	endproc;
	
	export proc void Init(^CBuilding p_pxParent, real p_fHeight, real p_fHeightOffset)
		if(m_bStarted||m_bEnded)then
			return;
		endif;
		if(p_pxParent==null)then 
			DieAndOut(false);
		endif;
		m_xParent=p_pxParent^.GetHandle();
		InitVars(p_fHeight, p_fHeightOffset);
		m_bStarted=true;
		//Update(p_pxParent^.GetGfxName());
		Update(p_pxParent^.GetTtGfx());
	endproc;
	
	proc void InitVars(real p_fHeight, real p_fHeightOffset)
		m_fHeight=p_fHeight;
		m_fHeightOffset=p_fHeightOffset;
		m_bInited=true;
	endproc;
	
	export proc void DieAndOut(bool p_bAnim)
		if(!m_bStarted||m_bEnded)then
			return;
		endif;
		var ^CFakeBuildUp pxBUD=cast<CFakeBuildUp>(m_xFakeBU.GetObj());
		if(pxBUD!=null)then
			pxBUD^.Delete();
		endif;
		if(p_bAnim)then
			// TODO
		endif;
		m_bEnded=true;
	endproc;
	
	proc vec3 GetPosByLevel(vec3 p_vPos, real p_fProgress)
		var vec3 vPos=p_vPos;
		vPos.SetZ(vPos.GetZ()-(m_fHeight-p_fProgress*m_fHeight));
		return vPos;
	endproc;
	
	export proc void Update(string p_sGFX)
		if(!m_bStarted||m_bEnded||!m_bInited)then
			return;
		endif;
		var ^CBuilding pxO=GetObj();
		if(pxO!=null)then
			var vec3 vPos=pxO^.GetPos();
			vPos.SetZ(vPos.GetZ()+m_fHeightOffset);
			var real fProgress=0.0f;
			var ^CAttribs pxAttr=pxO^.GetAttribs();
			if(pxAttr!=null)then
				fProgress=pxAttr^.GetValueInt("BuildupProcess").ToReal();
			endif;
			var int iConstructLevel=pxO^.GetConstructLevel();
			var int iDestructLevel=pxO^.GetDestructLevel();
			if(iConstructLevel<4&&cast<CFakeBuildUp>(m_xFakeBU.GetObj())==null)then
			//if(iConstructLevel<4&&!m_xFakeBU.IsValid())then
				var ^CFakeBuildUp pxBUD=cast<CFakeBuildUp>(CSrvWrap.GetObjMgr()^.CreateObj("fake_buildup", pxO^.GetOwner(), GetPosByLevel(vPos, 0.0f), pxO^.GetRotation()));
				pxBUD^.SetModel(p_sGFX);
				m_xFakeBU=pxBUD^.GetHandle();
				pxO^.AddGroupedChildren(pxBUD^.GetGuid());
				CSrvWrap.GetGame().DumpAttribs();
			endif;
			var ^CFakeBuildUp pxBUD=cast<CFakeBuildUp>(m_xFakeBU.GetObj());
			if(pxBUD!=null)then
				//HACK Henry: for seas scorpion
				if(pxBUD^.GetGfxName()=="scorpion")then
					pxBUD^.SetAnim("stand_up",0,2);
				endif;
				//ENDHACK
				if(iConstructLevel==4)then
					pxBUD^.Delete();
					m_xFakeBU=CObjHndl.Invalid();
				else
					fProgress /= 100.0f;
					pxBUD^.DoMove(GetPosByLevel(vPos, fProgress));
				endif;
			endif;
			m_iConstructLevel=iConstructLevel;
			m_iDestructLevel=iDestructLevel;
		endif;
	endproc;
	
	export proc void SetExtRot(Quat p_qRot)
		var ^CFakeBuildUp pxBUD=cast<CFakeBuildUp>(m_xFakeBU.GetObj());
		if(pxBUD!=null)then
			pxBUD^.SetRot(p_qRot);
		endif;
	endproc;
	
	export proc void SetExtPosZ(real p_fZ)
		var ^CFakeBuildUp pxBUD=cast<CFakeBuildUp>(m_xFakeBU.GetObj());
		if(pxBUD!=null)then
			pxBUD^.GetPos().SetZ(p_fZ);
		endif;
	endproc;
	
endclass;
	
class CFakeBuildUp inherit CTaskBuildUp
	
	var bool					m_bDelete;
	var vec3					m_vMustPos;
	
	export constructor()
		m_bDelete=false;
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc void SetModel(string p_sGfx)
		SetGFX(p_sGfx);
		//HACK Henry: for seas scorpion
		if(p_sGfx=="scorpion")then
			SetAnim("stand_up",0,2);
		endif;
		//ENDHACK
	endproc;
	
	export proc void DoMove(vec3 p_vTo)
		//HACK Henry: for seas scorpion
		if(GetGfxName()=="scorpion")then
			SetAnim("stand_up",0,2);
		endif;
		//ENDHACK
		m_vMustPos=p_vTo;
		SetPos(p_vTo);
	endproc;
	
	export proc void OnActionEnd(bool p_bBroken)
		if(m_bDelete)then
			Delete();
		endif;
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="FaBU")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			pxArc^ << m_bDelete;
			pxArc^ << m_vMustPos;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="FaBU";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		pxArc^ << m_bDelete;
		pxArc^ << m_vMustPos;
		pxWalk^.Close();
	endproc;
	
endclass;
	
// Class to workaround MapPings vanishing when game is saved & loaded
// Only for map-pings which stay until removed by trigger
// By AyCe
	
class CMapPingObj inherit CGameObj
	
	var array int	m_aiOwner; // (-2) for send to all or a number for the player
	var array vec3	m_avPos;
	var string	m_sID;
	var int		m_iTimeToLife;
	var int		m_iNumRepeats;
	var int		m_iMSBetween;
	var string	m_sColorType;
	var bool	m_bDeleted;
	
	constructor()
		m_aiOwner=0;
		m_avPos=0;
		m_bDeleted=false;
	endconstructor;
	
	destructor()
	enddestructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			SetType("MAPI");
			SetVisible(false);
			InitAttribs();
		else
			//
		endif;
	endproc;
	
	// This is called by the ActionFactory after creating the map-ping object
	export proc void InitMapPing(array int p_aiOwner, array vec3 p_avPos, string p_sID, int p_iTimeToLife, int p_iNumRepeats, int p_iMSBetween, string p_sColorType)
		m_aiOwner=p_aiOwner;
		m_avPos=p_avPos;
		m_sID=p_sID;
		m_iTimeToLife=p_iTimeToLife;
		m_iNumRepeats=p_iNumRepeats;
		m_iMSBetween=p_iMSBetween;
		m_sColorType=p_sColorType;
		SendMapPing(true);
	endproc;
	
	// This is called by the ActionFactory when removing the map-ping
	export proc void KillMapPing()
		SendMapPing(false);
		m_bDeleted=true;
		Delete();
	endproc;
	
	proc string GetEventString(int p_iIndex, bool p_bAdd)
		if(m_sColorType.IsEmpty())then
			m_sColorType="Attack";
		endif;
		var string sMsg="MiniMapEvent\t"+m_avPos[p_iIndex].ToString()+"\t"+m_sColorType;
		sMsg+="\ttrue\t"+p_bAdd.ToString()+"\t"+m_sID;
		sMsg+="\t"+m_iTimeToLife.ToString()+"\t"+m_iNumRepeats.ToString()+"\t"+m_iMSBetween.ToString();
		return sMsg;
	endproc;
	
	// Sends a "start the MapPing" event(s) to clients
	proc void SendMapPing(bool p_bAdd)
		if(m_bDeleted)then
			return;
		endif;
		var string sMsg;
		var int i2, i,iC=m_avPos.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			sMsg=GetEventString(i, p_bAdd);
			if(m_aiOwner[i]==-2)then
				for(i2=0)cond(i2<8)iter(i2++)do
					CSrvWrap.SendGenericEvtToPlayer(i2, sMsg);
				endfor;
			else
				CSrvWrap.SendGenericEvtToPlayer(m_aiOwner[i], sMsg);
			endif;
		endfor;
	endproc;
	
	export proc string GetMapPingID()
		if(m_bDeleted)then
			return "";
		endif;
		return m_sID;
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="MAPI")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int i,iC;
			(pxArc^) << iC;
			m_avPos=iC;
			m_aiOwner=iC;
			for(i=0) cond(i<iC) iter(++i)do
				(pxArc^) << m_avPos[i];
				(pxArc^) << m_aiOwner[i];
			endfor;
			(pxArc^) << m_sID;
			(pxArc^) << m_iTimeToLife;
			(pxArc^) << m_iNumRepeats;
			(pxArc^) << m_iMSBetween;
			(pxArc^) << m_sColorType;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="MAPI";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		var int i,iC=m_avPos.NumEntries();
		(pxArc^) << iC;
		for(i=0) cond(i<iC) iter(++i)do
			(pxArc^) << m_avPos[i];
			(pxArc^) << m_aiOwner[i];
		endfor;
		(pxArc^) << m_sID;
		(pxArc^) << m_iTimeToLife;
		(pxArc^) << m_iNumRepeats;
		(pxArc^) << m_iMSBetween;
		(pxArc^) << m_sColorType;
		pxWalk^.Close();
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();
		SendMapPing(true);
	endproc;
	
endclass;
	
	//========================================================================================
	//=== Workaround classes =================================================================
	//========================================================================================
	
class CPoolMixer inherit CFightingObj
	
	class CSpiritInfo
	
		export var CObjHndl						m_xCorpse;
		export var int								m_iSpiritHandle;
		export var int								m_iKillerCount;
		export var int								m_iKillerHistory;
		export var string							m_sID;
		export var string							m_sDur;
		export var string							m_sStart;
		export var string							m_sDeath;
	
		export proc void DoKArc(ref CArc p_rxArc, int p_iVersion)
			m_xCorpse.DoKArc(p_rxArc);
			p_rxArc << m_iSpiritHandle;
			p_rxArc << m_iKillerCount;
//			if(p_iVersion>=2)then
				p_rxArc << m_iKillerHistory;
				p_rxArc << m_sID;
				p_rxArc << m_sDur;
				p_rxArc << m_sStart;
				p_rxArc << m_sDeath;
//			else
//				m_iKillerHistory=0;
//				m_sID="";
//				m_sDur="";
//				m_sStart="";
//				m_sDeath="";
//			endif;
		endproc;
	
		export proc bool op_Equal(ref CPoolMixer.CSpiritInfo p_rxInfo)
			var bool bValidCorpse=(m_xCorpse.IsValid())&&(p_rxInfo.m_xCorpse.IsValid())&&(m_xCorpse==p_rxInfo.m_xCorpse);
			return (m_iSpiritHandle==p_rxInfo.m_iSpiritHandle||bValidCorpse);
		endproc;
	
		export proc void Delete(^CPoolMixer p_pxPM,int p_iID)
			if(p_pxPM!=null)then
				p_pxPM^.m_axSpiritPack.DeleteEntry(p_iID);
			endif;
			delete this;
		endproc;
	
	endclass;
	
	class CSpiritSorter
	
		export var int m_iSpiritLevel;
		export var real m_fRadius;
		export var int m_iMaxHP;
		export var string m_sClass;
		export var int m_iHandle;
		export var bool m_bVIP;
		export var bool m_bOwn;
		
		export proc bool op_Greater(ref CPoolMixer.CSpiritSorter p_rxOther)
			if(m_bOwn!=p_rxOther.m_bOwn)then
				return p_rxOther.m_bOwn;
			elseif(m_bVIP!=p_rxOther.m_bVIP)then
				return p_rxOther.m_bVIP;
			elseif(m_iSpiritLevel!=p_rxOther.m_iSpiritLevel)then
				return m_iSpiritLevel<p_rxOther.m_iSpiritLevel;
			elseif(m_iMaxHP!=p_rxOther.m_iMaxHP)then
				return m_iMaxHP<p_rxOther.m_iMaxHP;
			else
				return m_fRadius<p_rxOther.m_fRadius;
			endif;
		endproc;
		
	endclass;
	
	// Henry: hero pool stuff
	const int TIMER_POOL_MIXING=40067;
	
	// Henry: spirit-corpse stuff
	const int TIMER_SPIRIT=40079;
	const real SPIRIT_FREQUENCY=60.0f;
	export var array CSpiritInfo m_axSpiritPack;
	
	// Henry: ai leveling permission stuff
	const int TIMER_LEVELING=40114;
	const real LEVELING_FREQUENCY=600.0f; // Henry: 10 minutes
	var bool m_bLeveling;
	
	// Henry: phantom mode stuff
	const int TIMER_PHANTOM_AI_ACTIVATE=40153;
	const int TIMER_PHANTOM_UNVEIL=40152;
	const int TIMER_PHANTOM_REAPING=40118;
	const int TIMER_PHANTOM_TRIBUTE=40119;
	const int TIMER_PHANTOM_REVEAL=40120;
	const int TIMER_PHANTOM_SEER=40121;
	const int TIMER_PHANTOM_INCREASE=40125;
	const int TIMER_PHANTOM_POPULATION=40126;
	const int TIMER_PHANTOM_PRODUCTION=40127;
	const real PHANTOM_CHOOSING=30.0f;
	const real PHANTOM_FREQUENCY=5.0f;
	const real PHANTOM_INFORMING=1500.0f;
	const real SEER_FORESIGHT=90.0f;
	const real PHANTOM_AI_FREQ=600.0f;
	const real INCREASE_FREQUENCY=150.0f;
	const real POPULATION_FREQUENCY=600.0f;
	const real PRODUCTION_FREQUENCY=1800.0f;
	var bool m_bReapingOver;
	var int m_iSeer;
	var int m_iDefenders;
	var int m_iConquerors;
	var int m_iConqueror1;
	var int m_iConqueror2;
	var int m_iConqueror3;
	var int m_iConqueror4;
	var ^CBasePlayer m_pxConqueror1;
	var ^CBasePlayer m_pxConqueror2;
	var ^CBasePlayer m_pxConqueror3;
	var ^CBasePlayer m_pxConqueror4;
	var int m_iPaladins;
	var int m_iPaladin1;
	var int m_iPaladin2;
	var int m_iPaladin3;
	var int m_iPaladin4;
	var ^CBasePlayer m_pxPaladin1;
	var ^CBasePlayer m_pxPaladin2;
	var ^CBasePlayer m_pxPaladin3;
	var ^CBasePlayer m_pxPaladin4;
	const int PHANTOM_FOOD=10;
	const int PHANTOM_SKULL=10;
	const int PHANTOM_STONE=10;
	const int PHANTOM_WOOD=10;
	var int m_iPhantomIncrease;
	var int m_iPhantomGrowth;
	var int m_iPaladinIncrease;
	var real m_fBounty;
	var real m_fBountyStep;
	var array string m_asConquerors;
	
	export constructor()
		m_asConquerors=0;
		m_bLeveling=false;
		m_bReapingOver=false;
		m_iSeer=-1;
		m_iDefenders=0;
		m_iConquerors=0;
		m_iConqueror1=-1;
		m_iConqueror2=-1;
		m_iConqueror3=-1;
		m_iConqueror4=-1;
		m_pxConqueror1=null;
		m_pxConqueror2=null;
		m_pxConqueror3=null;
		m_pxConqueror4=null;
		m_iPaladins=0;
		m_iPaladin1=-1;
		m_iPaladin2=-1;
		m_iPaladin3=-1;
		m_iPaladin4=-1;
		m_pxPaladin1=null;
		m_pxPaladin2=null;
		m_pxPaladin3=null;
		m_pxPaladin4=null;
		m_iPhantomIncrease=1;
		m_iPaladinIncrease=1;
		m_iPhantomGrowth=1;
		m_fBounty=0.1f;
		m_fBountyStep=0.1f;
		CMirageSrvMgr.ms_fBounty=m_fBounty;
	endconstructor;
	
	export destructor()
		CMirageSrvMgr.ms_pxPoolMixer=null;
	enddestructor;
	
	export proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="PoMi")then
			var int iVersion=p_pxNode^.GetVersion();
			var ^CArc pxArc=^(p_pxNode^.GetArc());
			var int i, iC;
			if(iVersion<4)then
				(pxArc^) << iC;
				for(i=0)cond(i<iC)iter(i++)do
					var ^CPoolMixer.CSpiritInfo pxPack=^(m_axSpiritPack.NewEntryRef());
					pxPack^.DoKArc(pxArc^,iVersion);
				endfor;
			endif;
			if(iVersion>=2)then
				pxArc^<<m_bLeveling;
			endif;
			if(iVersion>=3)then
				pxArc^<<m_bReapingOver;
				pxArc^<<m_iSeer;
				pxArc^<<m_iDefenders;
				pxArc^<<m_iConquerors;
				pxArc^<<m_iConqueror1;
				pxArc^<<m_iConqueror2;
				pxArc^<<m_iConqueror3;
				pxArc^<<m_iConqueror4;
				pxArc^<<m_iPaladins;
				pxArc^<<m_iPaladin1;
				pxArc^<<m_iPaladin2;
				pxArc^<<m_iPaladin3;
				pxArc^<<m_iPaladin4;
				pxArc^<<m_iPhantomIncrease;
				pxArc^<<m_iPaladinIncrease;
				pxArc^<<m_iPhantomGrowth;
				pxArc^<<m_fBounty;
				CMirageSrvMgr.ms_fBounty=m_fBounty;
			endif;
			if(iVersion>=4)then
				(pxArc^) << iC;
				m_asConquerors=iC;
				for(i=0)cond(i<iC)iter(i++)do
					pxArc^<<m_asConquerors[i];
				endfor;
			endif;
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="PoMi";
		var int iVersion=4;
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,iVersion);
		var ^CArc pxArc=^(pxN^.GetArc());
//		(pxArc^) << m_iTimer;
		var int i, iC;
//		iC=m_axSpiritPack.NumEntries();
//		(pxArc^) << iC;
//		for(i=0)cond(i<iC)iter(i++)do
//			m_axSpiritPack[i].DoKArc(pxArc^,iVersion);
//		endfor;
		pxArc^<<m_bLeveling;
		pxArc^<<m_bReapingOver;
		pxArc^<<m_iSeer;
		pxArc^<<m_iDefenders;
		pxArc^<<m_iConquerors;
		pxArc^<<m_iConqueror1;
		pxArc^<<m_iConqueror2;
		pxArc^<<m_iConqueror3;
		pxArc^<<m_iConqueror4;
		pxArc^<<m_iPaladins;
		pxArc^<<m_iPaladin1;
		pxArc^<<m_iPaladin2;
		pxArc^<<m_iPaladin3;
		pxArc^<<m_iPaladin4;
		pxArc^<<m_iPhantomIncrease;
		pxArc^<<m_iPaladinIncrease;
		pxArc^<<m_iPhantomGrowth;
		pxArc^<<m_fBounty;
		iC=m_asConquerors.NumEntries();
		(pxArc^) << iC;
		for(i=0)cond(i<iC)iter(i++)do
			pxArc^<<m_asConquerors[i];
		endfor;
		pxN^.Close();
		var ^CGameOverMgr pxGOM=^(CGameOverMgr.Get());
		pxGOM^.SaveOrLoadSandGlassOver(true);
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(GetOwner()!=-1)then
			Delete();
			return;
		endif;
		begin Query;
			var bool bDuplication=false;
			var CObjQuery xQuery;
			xQuery.SetOwner(-1);
			xQuery.SetClass("pool_mixer");
			var CObjList xList;
			if(xQuery.Execute(xList))then
				var int i, iC=xList.NumEntries();
				for(i=0)cond(i<iC)iter(i++)do
					if(!xList[i].IsValid())then continue; endif;
					if(xList[i]==GetHandle())then continue; endif;
					bDuplication=true;
					break;
				endfor;
			endif;
			if(bDuplication)then
				Delete();
				return;
			endif;
		end Query;
//		CheckEvents();
		CMirageSrvMgr.ms_pxPoolMixer=this;
		if(!p_bLoad)then
			SetType("PLMX");
			var ^CAttribs pxAttr=CheckAttribs();
			begin TimerInit;
				CreateTimer(TIMER_SPIRIT, CGameTimeSpan.OneSecond() * SPIRIT_FREQUENCY, true);
			end TimerInit;
		endif;
		if(CMirageSrvMgr.Get().PhantomMode()&&!m_bReapingOver&&!HasTimer(TIMER_PHANTOM_REAPING))then
			StartHarrowing();
		endif;
		SetHitable(false);
		SetSelectable(false);
		SetFreeBorderBlocker(false);
		SetPlaceBlocker(false);
		CSrvWrap.GetPathfinder().RemPFBlocker(this);
		SetDynamicBBox(false);
		var ^CAttribs pxAttribs=GetAttribs();
		if(pxAttribs!=null)then
			var int iTBH=0, iSSA=0, iURS=0, iURC=0, iHPS=0, iFSE=0, iESE=0, iTSE=0, iFUE=0, iTR=0;
//			if(CMirageSrvMgr.Get().TransportHealing())then iTBH=1; endif;
			if(CMirageSrvMgr.Get().GetTHF()>=0.5f)then iTBH=1; endif;
			if(CMirageSrvMgr.Get().UseSupply())then iSSA=1; endif;
			if(CMirageSrvMgr.Get().ResourcesUnlimited())then iURS=1; endif;
			if(CMirageSrvMgr.Get().HeroPool())then iHPS=1; endif;
//			if(CMirageSrvMgr.Get().UnitResources())then iURC=1; endif;
			if(CMirageSrvMgr.Get().FreeSpecials())then iFSE=1; endif;
			if(CMirageSrvMgr.Get().EpochSix())then iESE=1; endif;
			if(CMirageSrvMgr.Get().TitanSlots())then iTSE=1; endif;
			if(CMirageSrvMgr.Get().FlyingEnabled())then iFUE=1; endif;
			if(CMirageSrvMgr.Get().RemoveTitans())then iTR=1; endif;
			pxAttribs^.SetValue("tbasket_healing",iTBH);
			pxAttribs^.SetValue("supply_system",iSSA);
			pxAttribs^.SetValue("unlimited_storage",iURS);
//			pxAttribs^.SetValue("resource_corpse",iURC);
			pxAttribs^.SetValue("hero_pool",iHPS);
			pxAttribs^.SetValue("free_specials",iFSE);
			pxAttribs^.SetValue("epoch_six",iESE);
			pxAttribs^.SetValue("titan_slots",iTSE);
			pxAttribs^.SetValue("flying_enabled",iFUE);
			pxAttribs^.SetValue("titans_disabled",iTR);
			pxAttribs^.SetValue("inited",1);
		endif;
		if(!m_bLeveling)then
			var bool bMultiplayer=false;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel!=null)then
				var CLevelInfo xLevelInfo=pxLevel^.GetLevelInfo();
				bMultiplayer=xLevelInfo.IsMultiplayer();
			endif;
			if(bMultiplayer)then
				CreateTimer(TIMER_LEVELING, CGameTimeSpan.OneSecond() * LEVELING_FREQUENCY, false);
			elseif(pxAttribs!=null)then
				pxAttribs^.SetValue("leveling_allowed",1);
				m_bLeveling=true;
			endif;
		endif;
		if(m_bReapingOver)then
			var ^CBasePlayer pxP;
			if(m_iConqueror1!=-1)then
				m_pxConqueror1=CBasePlayer.GetPlayer(m_iConqueror1);
			endif;
			if(m_iConqueror2!=-1)then
				m_pxConqueror2=CBasePlayer.GetPlayer(m_iConqueror2);
			endif;
			if(m_iConqueror3!=-1)then
				m_pxConqueror3=CBasePlayer.GetPlayer(m_iConqueror3);
			endif;
			if(m_iConqueror4!=-1)then
				m_pxConqueror4=CBasePlayer.GetPlayer(m_iConqueror4);
			endif;
			if(m_iPaladin1!=-1)then
				m_pxPaladin1=CBasePlayer.GetPlayer(m_iPaladin1);
			endif;
			if(m_iPaladin2!=-1)then
				m_pxPaladin2=CBasePlayer.GetPlayer(m_iPaladin2);
			endif;
			if(m_iPaladin3!=-1)then
				m_pxPaladin3=CBasePlayer.GetPlayer(m_iPaladin3);
			endif;
			if(m_iPaladin4!=-1)then
				m_pxPaladin4=CBasePlayer.GetPlayer(m_iPaladin4);
			endif;
		endif;
	endproc;
	
	proc ^CGameEvtQueue CheckEvents()
		var ^CGameEvtQueue pxQueue=GetEvents();
		if(pxQueue==null)then
			pxQueue=InitEvents();
		endif;
		return pxQueue;
	endproc;
	
	proc ^CAttribs CheckAttribs()
		var ^CAttribs pxAttribs=GetAttribs();
		if(pxAttribs==null)then
			pxAttribs=InitAttribs();
		endif;
		return pxAttribs;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==TIMER_SPIRIT)then
				ValidateSpirits();
			elseif(iTimerID==TIMER_LEVELING)then
				var ^CAttribs pxAttribs=GetAttribs();
				if(pxAttribs!=null)then
					pxAttribs^.SetValue("leveling_allowed",1);
					m_bLeveling=true;
				endif;
			elseif(iTimerID==TIMER_PHANTOM_TRIBUTE)then
				AidConqueror();
				AidPaladin();
			elseif(iTimerID==TIMER_PHANTOM_PRODUCTION)then
				PhantomProductionDecr();
			elseif(iTimerID==TIMER_PHANTOM_POPULATION)then
				PhantomPopulationIncr();
			elseif(iTimerID==TIMER_PHANTOM_INCREASE)then
				PhantomTributeIncr();
			elseif(iTimerID==TIMER_PHANTOM_REVEAL)then
				Revelation();
			elseif(iTimerID==TIMER_PHANTOM_SEER)then
				SeerForesight();
			elseif(iTimerID==TIMER_PHANTOM_REAPING)then
				Culling();
			elseif(iTimerID==TIMER_PHANTOM_UNVEIL)then
				UnveilPhantoms();
			elseif(iTimerID==TIMER_PHANTOM_AI_ACTIVATE)then
				AIWarDeclaration();
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	export proc void ValidateSpirits()
		var int i, iC=m_axSpiritPack.NumEntries()-1;
		for(i=iC)cond(i>=0)iter(i--)do
			var ^CSpirit pxSpirit=CSrvWrap.GetSpiritMgr().GetSpirit(m_axSpiritPack[i].m_iSpiritHandle);
			if(pxSpirit==null)then
				m_axSpiritPack.DeleteEntryUS(i);
//				m_axSpiritPack.DeleteEntry(i);
			endif;
		endfor;
	endproc;
	
	export proc void RegisterSpirit(int p_iSpirit,int p_iKillerCount,int p_iKillerHistory,CObjHndl p_xHandle,string p_sID,string p_sDur,string p_sStart,string p_sDeath)
		var CPoolMixer.CSpiritInfo xInfo;
		xInfo.m_iSpiritHandle=p_iSpirit;
		var int iIdx=m_axSpiritPack.FindEntry(xInfo);
		if(iIdx==-1)then
			var ^CPoolMixer.CSpiritInfo pxInfo=^(m_axSpiritPack.NewEntryRef());
			pxInfo^.m_xCorpse=p_xHandle;
			pxInfo^.m_iSpiritHandle=p_iSpirit;
			pxInfo^.m_iKillerCount=p_iKillerCount;
			pxInfo^.m_iKillerHistory=p_iKillerHistory;
			pxInfo^.m_sID=p_sID;
			pxInfo^.m_sDur=p_sDur;
			pxInfo^.m_sStart=p_sStart;
			pxInfo^.m_sDeath=p_sDeath;
		endif;
	endproc;
	
	export proc ^CSpirit GetBestSpiritToResurrect(int p_iPlayer, vec3 p_vCheckPos, real p_fMaxDistance, ref int p_riSpirit)
		var int i, iC=m_axSpiritPack.NumEntries();
		if(iC<1)then return null; endif;
		var array CPoolMixer.CSpiritSorter axList;
		for(i=0)cond(i<iC)iter(i++)do
			var ^CSpirit pxSpirit=CSrvWrap.GetSpiritMgr().GetSpirit(m_axSpiritPack[i].m_iSpiritHandle);
			if(pxSpirit==null)then m_axSpiritPack.DeleteEntryUS(i); i--; iC--; continue; endif;
			if(pxSpirit^.GetRessurectMode())then continue; endif;
			if(pxSpirit^.GetOwner()!=p_iPlayer)then
				if(!(CSrvWrap.GetDiplomacyMgr().GetIsFriend(pxSpirit^.GetOwner(), GetOwner())&&CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxSpirit^.GetOwner())))then
					continue;
				endif;
			endif;
			var vec3 vSpirit=pxSpirit^.GetPos();
			vSpirit.SetZ(CSrvWrap.GetScapeMgr().GetHeight(vSpirit.GetX(), vSpirit.GetY()));
			if((vSpirit-p_vCheckPos).Abs2()>p_fMaxDistance)then continue; endif;
			if(iC==1)then
				p_riSpirit=m_axSpiritPack[i].m_iSpiritHandle;
				return pxSpirit;
			endif;
			var ^CPoolMixer.CSpiritSorter pxEntry=^(axList.NewEntryRef());
			var string sClass=pxSpirit^.GetClass();
			pxEntry^.m_iHandle=pxSpirit^.GetHandle();
			pxEntry^.m_iSpiritLevel=pxSpirit^.GetLevel();
			pxEntry^.m_fRadius=pxSpirit^.GetRadius();
			pxEntry^.m_iMaxHP=pxSpirit^.GetMaxHP();
			pxEntry^.m_bOwn=pxSpirit^.GetOwner()==p_iPlayer;
			pxEntry^.m_bVIP=(sClass=="Miyagi_s0"||sClass=="special_eusmilus"||sClass=="babbage_s0"||sClass=="Barry_s0"||sClass=="Bela_s0"||sClass=="Cole_s0"||sClass=="darwin_s0"||sClass=="Harry_s0"||sClass=="hermit_s0"||sClass=="Larry_s0"||sClass=="livingstone_s0"||sClass=="lovelace_s0"||sClass=="mayor_s0"||sClass=="schliemann_s0"||sClass=="Stina_s0"||sClass=="Tarna_s0"||sClass=="tesla_s0"||sClass=="aje_atroxosaurus"||sClass=="hu_triceratops"||sClass=="ninigi_seismosaurus"||sClass=="seas_rex");
		endfor;
		axList.QSort();
		iC=axList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CSpirit pxTarget=CSrvWrap.GetSpiritMgr().GetSpirit(axList[i].m_iHandle);
			if(pxTarget!=null)then
				p_riSpirit=axList[i].m_iHandle;
				return pxTarget;
			endif;
		endfor;
		return null;
	endproc;
	
	export proc void DeleteSpirit(int p_iSpirit,ref int p_riKillerCount,ref int p_riKillerHistory,ref string p_rsID,ref string p_rsDur,ref string p_rsStart,ref string p_rsDeath)
		if(m_axSpiritPack.NumEntries()==0)then
			return;
		endif;
		var CPoolMixer.CSpiritInfo xInfo;
		xInfo.m_iSpiritHandle=p_iSpirit;
		var int iIdx=m_axSpiritPack.FindEntry(xInfo);
		if(iIdx!=-1)then
			p_riKillerCount=m_axSpiritPack[iIdx].m_iKillerCount;
			p_riKillerHistory=m_axSpiritPack[iIdx].m_iKillerHistory;
			p_rsID=m_axSpiritPack[iIdx].m_sID;
			p_rsDur=m_axSpiritPack[iIdx].m_sDur;
			p_rsStart=m_axSpiritPack[iIdx].m_sStart;
			p_rsDeath=m_axSpiritPack[iIdx].m_sDeath;
			if(m_axSpiritPack[iIdx].m_xCorpse.IsValid()&&m_axSpiritPack[iIdx].m_xCorpse.GetObj()!=null)then
				m_axSpiritPack[iIdx].m_xCorpse.GetObj()^.Delete();
			endif;
			m_axSpiritPack.DeleteEntryUS(iIdx);
//			m_axSpiritPack.DeleteEntry(iIdx);
		endif;
	endproc;
	
	export proc void GetProperties(int p_iSpirit,ref bool p_rbCorpse,ref vec3 p_rvPos,ref vec3 p_rvRot)
		if(m_axSpiritPack.NumEntries()==0)then
			return;
		endif;
		var CPoolMixer.CSpiritInfo xInfo;
		xInfo.m_iSpiritHandle=p_iSpirit;
		var int iIdx=m_axSpiritPack.FindEntry(xInfo);
		if(iIdx!=-1)then
			if(m_axSpiritPack[iIdx].m_xCorpse.IsValid()&&m_axSpiritPack[iIdx].m_xCorpse.GetObj()!=null)then
				p_rvPos=m_axSpiritPack[iIdx].m_xCorpse.GetObj()^.GetPos();
				p_rbCorpse=true;
				p_rvPos.SetZ(CSrvWrap.GetScapeMgr().GetHeight(p_rvPos.GetX(),p_rvPos.GetY()));
				p_rvRot=m_axSpiritPack[iIdx].m_xCorpse.GetObj()^.GetRotation();
//				m_axSpiritPack[iIdx].m_xCorpse.GetObj();
			endif;
		endif;
	endproc;
	
	export proc bool GetSpirit(CObjHndl p_xCorpse, ref int p_riSpirit)
		if(m_axSpiritPack.NumEntries()<=0||!p_xCorpse.IsValid())then
			return false;
		endif;
		var CPoolMixer.CSpiritInfo xInfo;
		xInfo.m_xCorpse=p_xCorpse;
		var int iIdx=m_axSpiritPack.FindEntry(xInfo);
		if(iIdx!=-1)then
			p_riSpirit=m_axSpiritPack[iIdx].m_iSpiritHandle;
			return true;
		endif;
		return false;
	endproc;
	
	export proc void SetAttribString(string p_sName, string p_sValue)
		var ^CAttribs pxAttribs=CheckAttribs();
		if(pxAttribs!=null)then
			pxAttribs^.SetValue(p_sName,p_sValue);
		endif;
	endproc;
	
	export proc void SetAttribInt(string p_sName, int p_iValue)
		var ^CAttribs pxAttribs=CheckAttribs();
		if(pxAttribs!=null)then
			if(CNPCMgr.Get().CheckHero(p_sName))then
				pxAttribs^.SetValue(p_sName,p_iValue);
			endif;
		endif;
	endproc;
	
	export proc string GetAttribString(string p_sName)
		var ^CAttribs pxAttribs=CheckAttribs();
		if(pxAttribs!=null)then
			return pxAttribs^.GetValue(p_sName);
		endif;
		return "";
	endproc;
	
	export proc int GetAttribInt(string p_sName)
		var ^CAttribs pxAttribs=CheckAttribs();
		if(pxAttribs!=null)then
			return pxAttribs^.GetValueInt(p_sName);
		endif;
		return -3;
	endproc;
	
	proc void StartHarrowing()
		if(m_bReapingOver)then return; endif;
		CreateTimer(TIMER_PHANTOM_REAPING, CGameTimeSpan.OneSecond() * PHANTOM_CHOOSING, false);
	endproc;
	
	proc void Culling()
		if(m_bReapingOver)then return; endif;
		var ^CLevel pxLvl=CSrvWrap.GetCurLevel();
		if(pxLvl==null)then return; endif;
		var ^CLevelInfoHost pxLevelInfo=^(pxLvl^.GetLevelInfo());
		if(pxLevelInfo==null)then return; endif;
		Random.Seed();
		var bool bAIPhantom=false;
		var array int aiHumans, aiAll, aiCandidates, aiAI;
		var ^CGameOverMgr pxGOM=^(CGameOverMgr.Get());
		var int iAlive=pxGOM^.GetStateCode("alive");
		var ^CBasePlayer pxPlayer;
		var int i, iC=8;
		for(i=0)cond(i<iC)iter(i++)do
			if(!pxGOM^.CheckPlayerState(i,iAlive))then continue; endif;
			pxPlayer=cast<CBasePlayer>(pxLvl^.GetPlayer(i));
			if(pxPlayer==null)then continue; endif;
			aiAll.AddEntry(i);
			if(pxPlayer^.IsHuman())then
				aiHumans.AddEntry(i);
			else
				aiAI.AddEntry(i);
			endif;
		endfor;
		if(aiAll.NumEntries()<2)then
			return;
		else
			m_iDefenders=aiAll.NumEntries();
		endif;
		aiCandidates=aiAll;
		var bool bRandomRoles=CMirageSrvMgr.Get().RandomRoles();
		var string sSuffixQ="_MULTI", sSuffixP="_MULTI", sSuffixD="_MULTI";
		var array int aiC, aiP, aiD;
		var int iK, iRemain, iMid, iMax=aiAll.NumEntries();
		iRemain=iMax;
		iMid=Math.Clamp((iMax-2)/2,0,4);
		if(CMirageSrvMgr.Get().SeerPlayer()&&aiHumans.NumEntries()>0)then
			var int iSeer=Random.GetInt()%aiHumans.NumEntries();
			m_iSeer=aiHumans[iSeer];
			CreateTimer(TIMER_PHANTOM_SEER, CGameTimeSpan.OneSecond() * SEER_FORESIGHT, false);
		endif;
		if(bRandomRoles)then
			m_iConquerors=Math.Clamp((Random.GetInt()%3)+1,1,Math.Max(iMid,1));
			iRemain-=m_iConquerors;
			iMid=Math.Clamp(iMid,0,iRemain);
			m_iPaladins=Math.Clamp((Random.GetInt()%3)+1,1,iMid);
			iRemain-=m_iPaladins;
			m_iDefenders=iRemain;
		else
			m_iConquerors=Math.Clamp(CMirageSrvMgr.Get().Conquerors(),1,4);
			iRemain-=m_iConquerors;
			m_iPaladins=Math.Clamp(CMirageSrvMgr.Get().Paladins(),0,Math.Max(5,iRemain));
			iRemain-=m_iPaladins;
//			m_iDefenders=Math.Clamp(CMirageSrvMgr.Get().Defenders(),0,Math.Max(7,iRemain));
			m_iDefenders=iRemain;
		endif;
//		begin testing;
//			m_iConquerors=2;
//			m_iPaladins=1;
//			m_iDefenders=1;
//		end testing;
		begin RandomChoosing;
			var string sPhantomName;
			iK=aiCandidates.NumEntries()-1;
			var int iRandom;
			if(m_iConquerors>=4&&iK>0)then
				iRandom=Random.GetInt()%iK;
				m_iConqueror4=aiCandidates[iRandom];
				aiC.AddEntry(m_iConqueror4);
				aiCandidates.DeleteEntry(iRandom);
				iK-=1;
				m_pxConqueror4=cast<CBasePlayer>(pxLvl^.GetPlayer(m_iConqueror4));
				if(m_pxConqueror4==null)then return; endif;
				if(!bAIPhantom&&aiAI.FindEntry(m_iConqueror4)!=-1)then
					bAIPhantom=true;
				endif;
				sPhantomName=m_pxConqueror4^.GetPName();
				if(sPhantomName=="")then
					var ^CLevelInfo.CPlayerSlot pxPlayerSlot=pxLevelInfo^.GetOwnerPlayerSlot(m_iConqueror4);
					if(pxPlayerSlot!=null)then
						sPhantomName=pxPlayerSlot^.GetName();
					endif;
				endif;
				m_asConquerors.AddEntry(sPhantomName);
//				m_pxConqueror4^.SetConqueror(true);
				m_pxConqueror4^.SetPhantomRole(CGameOverMgr.PHANTOM_CONQUEROR);
				CGameOverMgr.Get().AddPhantomMember(m_iConqueror4,CGameOverMgr.PHANTOM_CONQUEROR,m_iConqueror4);
			endif;
			if(m_iConquerors>=3&&iK>0)then
				iRandom=Random.GetInt()%iK;
				m_iConqueror3=aiCandidates[iRandom];
				aiC.AddEntry(m_iConqueror3);
				aiCandidates.DeleteEntry(iRandom);
				iK-=1;
				m_pxConqueror3=cast<CBasePlayer>(pxLvl^.GetPlayer(m_iConqueror3));
				if(m_pxConqueror3==null)then return; endif;
				if(!bAIPhantom&&aiAI.FindEntry(m_iConqueror3)!=-1)then
					bAIPhantom=true;
				endif;
				sPhantomName=m_pxConqueror3^.GetPName();
				if(sPhantomName=="")then
					var ^CLevelInfo.CPlayerSlot pxPlayerSlot=pxLevelInfo^.GetOwnerPlayerSlot(m_iConqueror3);
					if(pxPlayerSlot!=null)then
						sPhantomName=pxPlayerSlot^.GetName();
					endif;
				endif;
				m_asConquerors.AddEntry(sPhantomName);
//				m_pxConqueror3^.SetConqueror(true);
				m_pxConqueror3^.SetPhantomRole(CGameOverMgr.PHANTOM_CONQUEROR);
				CGameOverMgr.Get().AddPhantomMember(m_iConqueror3,CGameOverMgr.PHANTOM_CONQUEROR,m_iConqueror3);
			endif;
			if(m_iConquerors>=2&&iK>0)then
				iRandom=Random.GetInt()%iK;
				m_iConqueror2=aiCandidates[iRandom];
//				m_iConqueror2=0;
				aiC.AddEntry(m_iConqueror2);
				aiCandidates.DeleteEntry(iRandom);
				iK-=1;
				m_pxConqueror2=cast<CBasePlayer>(pxLvl^.GetPlayer(m_iConqueror2));
				if(m_pxConqueror2==null)then return; endif;
				if(!bAIPhantom&&aiAI.FindEntry(m_iConqueror2)!=-1)then
					bAIPhantom=true;
				endif;
				sPhantomName=m_pxConqueror2^.GetPName();
				if(sPhantomName=="")then
					var ^CLevelInfo.CPlayerSlot pxPlayerSlot=pxLevelInfo^.GetOwnerPlayerSlot(m_iConqueror2);
					if(pxPlayerSlot!=null)then
						sPhantomName=pxPlayerSlot^.GetName();
					endif;
				endif;
				m_asConquerors.AddEntry(sPhantomName);
//				m_pxConqueror2^.SetConqueror(true);
				m_pxConqueror2^.SetPhantomRole(CGameOverMgr.PHANTOM_CONQUEROR);
				CGameOverMgr.Get().AddPhantomMember(m_iConqueror2,CGameOverMgr.PHANTOM_CONQUEROR,m_iConqueror2);
			endif;
			if(m_iConquerors>=1&&iK>0)then
				iRandom=Random.GetInt()%iK;
				m_iConqueror1=aiCandidates[iRandom];
//				m_iConqueror1=1;
				aiC.AddEntry(m_iConqueror1);
				aiCandidates.DeleteEntry(iRandom);
				iK-=1;
				m_pxConqueror1=cast<CBasePlayer>(pxLvl^.GetPlayer(m_iConqueror1));
				if(m_pxConqueror1==null)then return; endif;
				if(!bAIPhantom&&aiAI.FindEntry(m_iConqueror1)!=-1)then
					bAIPhantom=true;
				endif;
				sPhantomName=m_pxConqueror1^.GetPName();
				if(sPhantomName=="")then
					var ^CLevelInfo.CPlayerSlot pxPlayerSlot=pxLevelInfo^.GetOwnerPlayerSlot(m_iConqueror1);
					if(pxPlayerSlot!=null)then
						sPhantomName=pxPlayerSlot^.GetName();
					endif;
				endif;
				m_asConquerors.AddEntry(sPhantomName);
//				m_pxConqueror1^.SetConqueror(true);
				m_pxConqueror1^.SetPhantomRole(CGameOverMgr.PHANTOM_CONQUEROR);
				CGameOverMgr.Get().AddPhantomMember(m_iConqueror1,CGameOverMgr.PHANTOM_CONQUEROR,m_iConqueror1);
			endif;
			if(m_iPaladins>=4&&iK>0)then
				iRandom=Random.GetInt()%iK;
				m_iPaladin4=aiCandidates[iRandom];
				aiP.AddEntry(m_iPaladin4);
				aiCandidates.DeleteEntry(iRandom);
				iK-=1;
				m_pxPaladin4=cast<CBasePlayer>(pxLvl^.GetPlayer(m_iPaladin4));
				if(m_pxPaladin4==null)then return; endif;
				m_pxPaladin4^.SetPhantomRole(CGameOverMgr.PHANTOM_PALADIN);
				CGameOverMgr.Get().AddPhantomMember(m_iPaladin4,CGameOverMgr.PHANTOM_PALADIN,m_iPaladin4);
			endif;
			if(m_iPaladins>=3&&iK>0)then
				iRandom=Random.GetInt()%iK;
				m_iPaladin3=aiCandidates[iRandom];
				aiP.AddEntry(m_iPaladin3);
				aiCandidates.DeleteEntry(iRandom);
				iK-=1;
				m_pxPaladin3=cast<CBasePlayer>(pxLvl^.GetPlayer(m_iPaladin3));
				if(m_pxPaladin3==null)then return; endif;
				m_pxPaladin3^.SetPhantomRole(CGameOverMgr.PHANTOM_PALADIN);
				CGameOverMgr.Get().AddPhantomMember(m_iPaladin3,CGameOverMgr.PHANTOM_PALADIN,m_iPaladin3);
			endif;
			if(m_iPaladins>=2&&iK>0)then
				iRandom=Random.GetInt()%iK;
				m_iPaladin2=aiCandidates[iRandom];
				aiP.AddEntry(m_iPaladin2);
				aiCandidates.DeleteEntry(iRandom);
				iK-=1;
				m_pxPaladin2=cast<CBasePlayer>(pxLvl^.GetPlayer(m_iPaladin2));
				if(m_pxPaladin2==null)then return; endif;
				m_pxPaladin2^.SetPhantomRole(CGameOverMgr.PHANTOM_PALADIN);
				CGameOverMgr.Get().AddPhantomMember(m_iPaladin2,CGameOverMgr.PHANTOM_PALADIN,m_iPaladin2);
			endif;
			if(m_iPaladins>=1&&iK>0)then
				iRandom=Random.GetInt()%iK;
				m_iPaladin1=aiCandidates[iRandom];
//				m_iPaladin1=2;
				aiP.AddEntry(m_iPaladin1);
				aiCandidates.DeleteEntry(iRandom);
				iK-=1;
				m_pxPaladin1=cast<CBasePlayer>(pxLvl^.GetPlayer(m_iPaladin1));
				if(m_pxPaladin1==null)then return; endif;
				m_pxPaladin1^.SetPhantomRole(CGameOverMgr.PHANTOM_PALADIN);
				CGameOverMgr.Get().AddPhantomMember(m_iPaladin1,CGameOverMgr.PHANTOM_PALADIN,m_iPaladin1);
			endif;
			if(!bRandomRoles)then
				if(m_iConquerors<2)then
					sSuffixQ="_SOLO";
				endif;
				if(m_iPaladins<2)then
					sSuffixP="_SOLO";
				endif;
				if(m_iDefenders<2)then
					sSuffixD="_SOLO";
				endif;
			endif;
			m_bReapingOver=true;
		end RandomChoosing;
		AidConqueror();
		AidPaladin();
		var real fMultiplier=1.0f;
		if(iMax<5)then
			fMultiplier=4.0f;
		elseif(iMax<7)then
			fMultiplier=2.0f;
		endif;
		CreateTimer(TIMER_PHANTOM_PRODUCTION, CGameTimeSpan.OneSecond() * PRODUCTION_FREQUENCY, false);
		CreateTimer(TIMER_PHANTOM_INCREASE, CGameTimeSpan.OneSecond() * (INCREASE_FREQUENCY*fMultiplier), true);
		CreateTimer(TIMER_PHANTOM_TRIBUTE, CGameTimeSpan.OneSecond() * PHANTOM_FREQUENCY, true);
		if(CMirageSrvMgr.Get().PopulationBonus())then
			if(iMax<5)then
				fMultiplier=2.0f;
			elseif(iMax<7)then
				fMultiplier=1.5f;
//			else
//				fMultiplier=1.0f;
			endif;
			PhantomPopulationIncr();
			CreateTimer(TIMER_PHANTOM_POPULATION, CGameTimeSpan.OneSecond() * (POPULATION_FREQUENCY*fMultiplier), true);
		endif;
		if(m_iConquerors>1&&CMirageSrvMgr.Get().Revelation())then
			CreateTimer(TIMER_PHANTOM_REVEAL, CGameTimeSpan.OneSecond() * PHANTOM_INFORMING, false);
		endif;
		iC=aiAll.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			pxPlayer=cast<CBasePlayer>(pxLvl^.GetPlayer(aiAll[i]));
			if(pxPlayer!=null)then
				if(aiC.FindEntry(aiAll[i])!=-1)then
					CFeedback.Print(aiAll[i], CFeedback.GAMEPLAY, "_MIRAGE_NT_CONQUEROR"+sSuffixQ);
				elseif(aiP.FindEntry(aiAll[i])!=-1)then
					CFeedback.Print(aiAll[i], CFeedback.GAMEPLAY, "_MIRAGE_NT_PALADIN"+sSuffixP);
				else
					pxPlayer^.SetPhantomRole(CGameOverMgr.PHANTOM_DEFENDER);
					CGameOverMgr.Get().AddPhantomMember(i,CGameOverMgr.PHANTOM_DEFENDER,i);
					CFeedback.Print(aiAll[i], CFeedback.GAMEPLAY, "_MIRAGE_NT_DEFENDER"+sSuffixD);
				endif;
			endif;
		endfor;
		if(bAIPhantom)then
			CreateTimer(TIMER_PHANTOM_AI_ACTIVATE, CGameTimeSpan.OneSecond() * PHANTOM_AI_FREQ, false);
		endif;
	endproc;
	
	proc void AidConqueror()
		var int iF=PHANTOM_FOOD*m_iPhantomIncrease, iI=PHANTOM_SKULL*m_iPhantomIncrease, iS=PHANTOM_STONE*m_iPhantomIncrease, iW=PHANTOM_WOOD*m_iPhantomIncrease;
		if(m_pxConqueror1!=null)then
			m_pxConqueror1^.AddFood(iF);
			m_pxConqueror1^.AddSkulls(iI);
			m_pxConqueror1^.AddStone(iS);
			m_pxConqueror1^.AddWood(iW);
		endif;
		if(m_pxConqueror2!=null)then
			m_pxConqueror2^.AddFood(iF);
			m_pxConqueror2^.AddSkulls(iI);
			m_pxConqueror2^.AddStone(iS);
			m_pxConqueror2^.AddWood(iW);
		endif;
		if(m_pxConqueror3!=null)then
			m_pxConqueror3^.AddFood(iF);
			m_pxConqueror3^.AddSkulls(iI);
			m_pxConqueror3^.AddStone(iS);
			m_pxConqueror3^.AddWood(iW);
		endif;
		if(m_pxConqueror4!=null)then
			m_pxConqueror4^.AddFood(iF);
			m_pxConqueror4^.AddSkulls(iI);
			m_pxConqueror4^.AddStone(iS);
			m_pxConqueror4^.AddWood(iW);
		endif;
	endproc;
	
	proc void AidPaladin()
		var int iF=PHANTOM_FOOD*m_iPaladinIncrease, iI=PHANTOM_SKULL*m_iPaladinIncrease, iS=PHANTOM_STONE*m_iPaladinIncrease, iW=PHANTOM_WOOD*m_iPaladinIncrease;
		if(m_pxPaladin1!=null)then
			m_pxPaladin1^.AddFood(iF);
//			m_pxPaladin1^.AddSkulls(iI);
			m_pxPaladin1^.AddStone(iS);
			m_pxPaladin1^.AddWood(iW);
		endif;
		if(m_pxPaladin2!=null)then
			m_pxPaladin2^.AddFood(iF);
//			m_pxPaladin2^.AddSkulls(iI);
			m_pxPaladin2^.AddStone(iS);
			m_pxPaladin2^.AddWood(iW);
		endif;
		if(m_pxPaladin3!=null)then
			m_pxPaladin3^.AddFood(iF);
//			m_pxPaladin3^.AddSkulls(iI);
			m_pxPaladin3^.AddStone(iS);
			m_pxPaladin3^.AddWood(iW);
		endif;
		if(m_pxPaladin4!=null)then
			m_pxPaladin4^.AddFood(iF);
//			m_pxPaladin4^.AddSkulls(iI);
			m_pxPaladin4^.AddStone(iS);
			m_pxPaladin4^.AddWood(iW);
		endif;
	endproc;
	
	proc void PhantomTributeIncr()
		m_iPhantomIncrease+=m_iPhantomGrowth;
	endproc;
	
	export proc void PhantomBloodIncrease()
		m_iPhantomGrowth*=2;
	endproc;
	
	export proc void PaladinBloodIncrease()
		m_iPaladinIncrease*=2;
	endproc;
	
	export proc void IncreaseBounty()
		m_fBounty+=m_fBountyStep;
		CMirageSrvMgr.ms_fBounty=m_fBounty;
	endproc;
	
	proc void PhantomPopulationIncr()
		if(m_pxConqueror1!=null)then
			m_pxConqueror1^.PopulationIncr(5,3,2,1,0,10);
		endif;
		if(m_pxConqueror2!=null)then
			m_pxConqueror2^.PopulationIncr(5,3,2,1,0,10);
		endif;
		if(m_pxConqueror3!=null)then
			m_pxConqueror3^.PopulationIncr(5,3,2,1,0,10);
		endif;
		if(m_pxConqueror4!=null)then
			m_pxConqueror4^.PopulationIncr(5,3,2,1,0,10);
		endif;
	endproc;
	
	proc void Revelation()
		if(!m_bReapingOver)then return; endif;
		var ^CLevel pxLvl=CSrvWrap.GetCurLevel();
		if(pxLvl==null)then return; endif;
		var array string asNames;
		var array int aiConq;
		var ^CGameOverMgr pxGOM=^(CGameOverMgr.Get());
		var int i, iC, k, iAlive=pxGOM^.GetStateCode("alive");
		if(pxGOM^.CheckPlayerState(m_iConqueror1,iAlive)&&m_pxConqueror1!=null)then
			aiConq.AddEntry(m_iConqueror1);
			asNames.AddEntry(m_pxConqueror1^.GetPName());
		endif;
		if(pxGOM^.CheckPlayerState(m_iConqueror2,iAlive)&&m_pxConqueror2!=null)then
			aiConq.AddEntry(m_iConqueror2);
			asNames.AddEntry(m_pxConqueror2^.GetPName());
		endif;
		if(pxGOM^.CheckPlayerState(m_iConqueror3,iAlive)&&m_pxConqueror3!=null)then
			aiConq.AddEntry(m_iConqueror3);
			asNames.AddEntry(m_pxConqueror3^.GetPName());
		endif;
		if(pxGOM^.CheckPlayerState(m_iConqueror4,iAlive)&&m_pxConqueror4!=null)then
			aiConq.AddEntry(m_iConqueror4);
			asNames.AddEntry(m_pxConqueror4^.GetPName());
		endif;
		iC=aiConq.NumEntries();
		if(iC<2)then return; endif;
		var ^CBasePlayer pxTmp, pxConq;
		for(i=0)cond(i<iC)iter(i++)do
			pxConq=cast<CBasePlayer>(pxLvl^.GetPlayer(aiConq[i]));
			for(k=0)cond(k<iC)iter(k++)do
				if(k!=i)then
					CFeedback.Print(aiConq[i], CFeedback.GAMEPLAY,"_MIRAGE_NT_PhantomIdentity\t"+asNames[k]);
					pxTmp=cast<CBasePlayer>(pxLvl^.GetPlayer(aiConq[k]));
					if(pxTmp!=null&&pxConq!=null)then
						CSrvWrap.GetDiplomacyMgr().SetRelation(aiConq[i], aiConq[k], 2);
						pxTmp^.SetDiplomacy(aiConq[i], 2, true);
//						CFeedback.Print(CFeedback.ALL, CFeedback.DIPLOMACY, "_MIRAGE_NT_TrucePhantom\t"+pxConq^.GetPName()+"\t"+pxTmp^.GetPName());
					endif;
				endif;
			endfor;
		endfor;
	endproc;
	
	proc void SeerForesight()
		if(!m_bReapingOver||m_iSeer<0)then return; endif;
		CFeedback.Print(m_iSeer, CFeedback.GAMEPLAY,"_MIRAGE_NT_SeerForesight\t"+m_iConquerors.ToString()+"\t"+m_iPaladins.ToString()+"\t"+m_iDefenders.ToString()+"\t");
	endproc;
	
	proc void PhantomProductionDecr()
		if(m_pxConqueror1!=null)then
			m_pxConqueror1^.ReduceProductionTime();
		endif;
		if(m_pxConqueror2!=null)then
			m_pxConqueror2^.ReduceProductionTime();
		endif;
		if(m_pxConqueror3!=null)then
			m_pxConqueror3^.ReduceProductionTime();
		endif;
		if(m_pxConqueror4!=null)then
			m_pxConqueror4^.ReduceProductionTime();
		endif;
	endproc;
	
	export proc bool IsTheReapingOver()
		return m_bReapingOver;
	endproc;
	
//	export proc void OnPostLoad()
//		super.OnPostLoad();
//		if(!m_bReapingOver)then return; endif;
//		var ^CLevel pxLvl=CSrvWrap.GetCurLevel();
//		if(pxLvl==null)then return; endif;
//		var ^CGameOverMgr pxGOM=^(CGameOverMgr.Get());
//		var int iAlive=pxGOM^.GetStateCode("alive");
//		var ^CBasePlayer pxTemp;
//		var int i, iC=8;
//		for(i=0)cond(i<iC)iter(i++)do
////			if(!pxGOM^.CheckPlayerState(i,iAlive))then continue; endif;
//			pxTemp=cast<CBasePlayer>(pxLvl^.GetPlayer(i));
//			if(pxTemp==null)then continue; endif;
//			if(pxTemp^.IsConqueror())then
//				CGameOverMgr.Get().AddConqueror();
//			elseif(pxTemp^.IsPaladin()||pxTemp^.IsDefender())then
//				CGameOverMgr.Get().AddGuardian();
//			endif;
//		endfor;
//	endproc;
	
	export proc void StartUnveilTimer(int p_iSandGlassTime)
		if(p_iSandGlassTime<1)then return; endif;
		var real fDeadLine=((p_iSandGlassTime*60)-15).ToReal();
		CreateTimer(TIMER_PHANTOM_UNVEIL, CGameTimeSpan.OneSecond()*fDeadLine, false);
	endproc;
	
	proc void UnveilPhantoms()
		var int i, iC=m_asConquerors.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			CFeedback.Print(CFeedback.ALL, CFeedback.GAMEPLAY, "_MIRAGE_NT_PhantomRevelation\t"+m_asConquerors[i]);
		endfor;
	endproc;
	
	proc void AIWarDeclaration()
		var ^CLevel pxLvl=CSrvWrap.GetCurLevel();
		if(pxLvl==null)then return; endif;
		var ^CGameOverMgr pxGOM=^(CGameOverMgr.Get());
		var ^CBasePlayer pxTmp;
		var int i, iC=8, iAlive=pxGOM^.GetStateCode("alive");
		if(pxGOM^.CheckPlayerState(m_iConqueror4,iAlive)&&m_pxConqueror4!=null&&!m_pxConqueror4^.IsHuman())then
			for(i=0)cond(i<iC)iter(i++)do
				if(i==m_iConqueror4)then continue; endif;
				if(!pxGOM^.CheckPlayerState(i,iAlive))then continue; endif;
				pxTmp=cast<CBasePlayer>(pxLvl^.GetPlayer(i));
				if(pxTmp==null)then continue; endif;
				if(pxTmp^.GetMaster()==m_iConqueror4)then continue; endif;
				CSrvWrap.GetDiplomacyMgr().SetRelation(m_iConqueror4, i, 0);
				pxTmp^.SetDiplomacy(m_iConqueror4, 0, true);
//				CFeedback.Print(CFeedback.ALL, CFeedback.DIPLOMACY, "_MIRAGE_NT_WarPhantom\t"+m_pxConqueror4^.GetPName()+"\t"+pxTmp^.GetPName());
			endfor;
		endif;
		if(pxGOM^.CheckPlayerState(m_iConqueror3,iAlive)&&m_pxConqueror3!=null&&!m_pxConqueror3^.IsHuman())then
			for(i=0)cond(i<iC)iter(i++)do
				if(i==m_iConqueror3)then continue; endif;
				if(!pxGOM^.CheckPlayerState(i,iAlive))then continue; endif;
				pxTmp=cast<CBasePlayer>(pxLvl^.GetPlayer(i));
				if(pxTmp==null)then continue; endif;
				if(pxTmp^.GetMaster()==m_iConqueror3)then continue; endif;
				CSrvWrap.GetDiplomacyMgr().SetRelation(m_iConqueror3, i, 0);
				pxTmp^.SetDiplomacy(m_iConqueror3, 0, true);
//				CFeedback.Print(CFeedback.ALL, CFeedback.DIPLOMACY, "_MIRAGE_NT_WarPhantom\t"+m_pxConqueror3^.GetPName()+"\t"+pxTmp^.GetPName());
			endfor;
		endif;
		if(pxGOM^.CheckPlayerState(m_iConqueror2,iAlive)&&m_pxConqueror2!=null&&!m_pxConqueror2^.IsHuman())then
			for(i=0)cond(i<iC)iter(i++)do
				if(i==m_iConqueror2)then continue; endif;
				if(!pxGOM^.CheckPlayerState(i,iAlive))then continue; endif;
				pxTmp=cast<CBasePlayer>(pxLvl^.GetPlayer(i));
				if(pxTmp==null)then continue; endif;
				if(pxTmp^.GetMaster()==m_iConqueror2)then continue; endif;
				CSrvWrap.GetDiplomacyMgr().SetRelation(m_iConqueror2, i, 0);
				pxTmp^.SetDiplomacy(m_iConqueror2, 0, true);
//				CFeedback.Print(CFeedback.ALL, CFeedback.DIPLOMACY, "_MIRAGE_NT_WarPhantom\t"+m_pxConqueror2^.GetPName()+"\t"+pxTmp^.GetPName());
			endfor;
		endif;
		if(pxGOM^.CheckPlayerState(m_iConqueror1,iAlive)&&m_pxConqueror1!=null&&!m_pxConqueror1^.IsHuman())then
			for(i=0)cond(i<iC)iter(i++)do
				if(i==m_iConqueror1)then continue; endif;
				if(!pxGOM^.CheckPlayerState(i,iAlive))then continue; endif;
				pxTmp=cast<CBasePlayer>(pxLvl^.GetPlayer(i));
				if(pxTmp==null)then continue; endif;
				if(pxTmp^.GetMaster()==m_iConqueror1)then continue; endif;
				CSrvWrap.GetDiplomacyMgr().SetRelation(m_iConqueror1, i, 0);
				pxTmp^.SetDiplomacy(m_iConqueror1, 0, true);
//				CFeedback.Print(CFeedback.ALL, CFeedback.DIPLOMACY, "_MIRAGE_NT_WarPhantom\t"+m_pxConqueror1^.GetPName()+"\t"+pxTmp^.GetPName());
			endfor;
		endif;
	endproc;
	
	export proc void Delete()
		CMirageSrvMgr.ms_pxPoolMixer=null;
		super.Delete();
	endproc;
	
endclass;
	
class CGPCEmitter inherit CGameObj
	
	class CQueueSelectionSorter
		export var int m_iQueueEntries;
		export var CObjHndl m_xHndl;
		export var int m_iCurProgress;
	
		export proc bool op_Greater(ref CGPCEmitter.CQueueSelectionSorter p_rxOther)
			if(m_iQueueEntries!=p_rxOther.m_iQueueEntries)then
				return m_iQueueEntries>p_rxOther.m_iQueueEntries;
			else
				return m_iCurProgress<p_rxOther.m_iCurProgress;
			endif;
		endproc;
		
	endclass;
	
	export constructor()
	endconstructor;
	
	export proc void Load(^CUOFReaderNode p_pxNode)
		if(p_pxNode^.GetType()=="GPCE")then
			var int iVersion=p_pxNode^.GetVersion();
			var ^CArc pxArc=^(p_pxNode^.GetArc());
		else
			super.Load(p_pxNode);
		endif;
	endproc;
	
	export proc void Save(^CUOFWriterNode p_pxNode)
		super.Save(p_pxNode);
		var CFourCC xF="GPCE";
		var ^CUOFWriterNode pxN=p_pxNode^.AddSubChunk(xF,1);
		var ^CArc pxArc=^(pxN^.GetArc());
		pxN^.Close();
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(GetClassName().IsEmpty())then return; endif;
		var int iOwner=GetClassName().Right(1).ToInt();
		if(GetOwner()!=iOwner)then
			Delete();
			return;
		endif;
		begin Query;
			var bool bDuplication=false;
			var CObjQuery xQuery;
			xQuery.SetOwner(GetOwner());
			xQuery.SetClass(GetClassName());
			var CObjList xList;
			if(xQuery.Execute(xList))then
				var int i, iC=xList.NumEntries();
				for(i=0)cond(i<iC)iter(i++)do
					if(!xList[i].IsValid())then continue; endif;
					if(xList[i]==GetHandle())then continue; endif;
					bDuplication=true;
					break;
				endfor;
			endif;
			if(bDuplication)then
				Delete();
				return;
			endif;
		end Query;
		CheckEvents();
		if(!p_bLoad)then
			SetType("GPCE");
		endif;
		SetHitable(false);
		SetSelectable(false);
		SetVisible(false);
	endproc;
	
	proc ^CGameEvtQueue CheckEvents()
		var ^CGameEvtQueue pxQueue=GetEvents();
		if(pxQueue==null)then
			pxQueue=InitEvents();
		endif;
		return pxQueue;
	endproc;
	
	proc ^CAttribs CheckAttribs()
		var ^CAttribs pxAttribs=GetAttribs();
		if(pxAttribs==null)then
			pxAttribs=InitAttribs();
		endif;
		return pxAttribs;
	endproc;
	
	export proc void HandleGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams)
//		CMirageSrvMgr.Debug("Debug information - command: "+p_sCommand+"; param: "+p_sMiscParams+".");
		if(p_sCommand=="SetCamPos"&&p_vPos!={0.0,0.0,0.0})then
//			var int iCam=p_sMiscParams.ToInt();
//			if(iCam<1||iCam>8 )then return; endif;
			var ^CBasePlayer pxBase=CBasePlayer.GetPlayer(GetOwner());
			if(pxBase==null)then return; endif;
			pxBase^.SetAttribs("camera_pos_"+p_sMiscParams, p_vPos.ToString());
			return;
		elseif(p_sCommand=="TributeResis"&&p_sMiscParams!="")then
			var array string asInput;
			p_sMiscParams.Split(asInput,"&",false);
			TransferTribute(asInput[0].ToInt(),asInput[1].ToInt(),asInput[2].ToInt(),asInput[3]);
		elseif(p_sCommand=="SkipOldTraps")then
			var ^CPlayer pxPlayer=CSrvWrap.GetCurLevel()^.GetPlayer(GetOwner());
			if(pxPlayer!=null)then
				var ^CTechTreeDef pxDef=^(pxPlayer^.GetPlayerTechTreeDef());
				if(pxDef!=null)then
					if(!pxDef^.HasFilter("/Filters/Ninigi/Upgrades/xenage/skip_old_traps"))then
						pxDef^.EnableFilter("/Filters/Ninigi/Upgrades/xenage/skip_old_traps");
					endif;
				endif;
			endif;
		elseif(p_sCommand.Left(6).Find("|LA|")!=-1)then
			var string sPath=p_sCommand.Mid(p_sCommand.Find("|LA|")+4);
			var ^CFightingObj pxSubject=SortByQueue(p_sMiscParams);
			if(pxSubject!=null)then
				var string sPrefix;
				if(p_sCommand.Left(2)=="S_")then
					sPrefix="S_";
				endif;
				pxSubject^.HandleGamePlayCommand(sPrefix+"Action",p_pxObject,p_vPos,sPath);
			endif;
		else
			return;
		endif;
	endproc;
	
	proc void TransferTribute(int p_iPlayerId1, int p_iPlayerId2, int p_iTribute, string p_sTributeType)
		if(p_iPlayerId1!=GetOwner()||p_iPlayerId2==GetOwner())then return; endif;
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel==null)then return; endif;
		var ^CBasePlayer pxPlayer1=CBasePlayer.GetPlayer(p_iPlayerId1);
		if(pxPlayer1==null)then return; endif;
		var ^CBasePlayer pxPlayer2 =CBasePlayer.GetPlayer(p_iPlayerId2);
		if(pxPlayer2==null)then return; endif;
		if(p_iTribute<=0)then return; endif;
		var ^CAttribs pxPlAttr1=pxPlayer1^.GetAttribs();
		if(pxPlAttr1==null)then return; endif;
		var int iValue1=pxPlAttr1^.GetValueInt(p_sTributeType);
		var ^CAttribs pxPlAttr2=pxPlayer2^.GetAttribs();
		if(pxPlAttr2==null)then return; endif;
		var int iValue2=pxPlAttr2^.GetValueInt(p_sTributeType);
		if(iValue1<p_iTribute)then
			p_iTribute=iValue1;
		endif;
		iValue1 -= p_iTribute;
		var int iMaxValue=pxPlAttr2^.GetValueInt("max_"+p_sTributeType);
		iValue2 += p_iTribute;
		pxPlAttr1^.SetValue(p_sTributeType,iValue1);
		pxPlAttr2^.SetValue(p_sTributeType,iValue2);
		var string sPlayerName=pxLevel^.GetLevelInfo().GetPlayerSlot(pxPlayer1^.GetPlayerSlotID()).GetName();
		var string sTribLoc=p_sTributeType;
		sTribLoc.MakeUpper();
		if(sTribLoc=="STONE")then
			sTribLoc="STON";
		endif;
		sTribLoc="_NT_AI_RESSOURCE_"+sTribLoc;
		if(pxPlayer2^.GetDiplomacy(p_iPlayerId1)==2)then
			CSrvWrap.SendGenericEvtToPlayer(p_iPlayerId2, "AllyTribute");
		endif;
		CFeedback.Print(p_iPlayerId2, CFeedback.DIPLOMACY,"_NT_DiplTribute\t"+sTribLoc+"\t"+p_iTribute.ToString()+"\t"+sPlayerName);
		CStatsMgr.Get().GetPlayerStats(p_iPlayerId1)^.AddTribute(p_iPlayerId2, p_sTributeType, p_iTribute);
		var ^CStatisticMgr pxStatisticMgr=^(pxLevel^.GetStatisticMgr());
		pxStatisticMgr^.AddSample( CStatisticSample.Tribute.ToInt(), p_iPlayerId1,  p_iTribute );
		pxStatisticMgr^.AddSample( CStatisticSample.Tribute.ToInt(), p_iPlayerId2, -p_iTribute );
		CSrvWrap.GetGameLogger().Log("Tribute",p_iPlayerId1.ToString(),p_iPlayerId2.ToString(),p_iTribute.ToString(),p_sTributeType);
	endproc;

	export proc ^CFightingObj SortByQueue(string p_sCodes)
		var ^CFightingObj pxReturn=null;
		var array string asUnits;
		p_sCodes.Split(asUnits,"|",true);
		var int i, iC=asUnits.NumEntries();
		if(iC<1)then return null; endif;
		var CObjList xNew;
		var array CGPCEmitter.CQueueSelectionSorter axList;
		for(i=0)cond(i<iC)iter(i++)do
			var string sName=CMirageSrvMgr.Get().GetNameFromCode(asUnits[i]);
			var ^CFightingObj pxFO=cast<CFightingObj>(CSrvWrap.GetObjMgr()^.GetObjByName(sName));
			if(pxFO==null)then pxFO=cast<CFightingObj>(CSrvWrap.GetObjMgr()^.GetObjByName(asUnits[i])); endif;
			if(pxFO==null||pxFO^.GetOwner()!=GetOwner())then continue; endif;
			if(pxFO^.IsUnavailable())then continue; endif;
			if(iC==1)then return pxFO; endif;
			if(xNew.FindEntry(pxFO^.GetHandle())==-1)then xNew.AddEntry(pxFO^.GetHandle()); else continue; endif;
			var ^CGPCEmitter.CQueueSelectionSorter pxEntry=^(axList.NewEntryRef());
			pxEntry^.m_xHndl=pxFO^.GetHandle();
			pxEntry^.m_iQueueEntries=0+pxFO^.GetPQENO()+pxFO^.GetPQENR();
			var int iProgress=0;
			var ^CAttribs pxA=pxFO^.GetAttribs();
			if(pxA!=null)then
				iProgress+=pxA^.GetValueInt("CurProcess")+pxA^.GetValueInt("ReactorCurProcess");
			endif;
			pxEntry^.m_iCurProgress=iProgress;
		endfor;
		axList.QSort();
		iC=axList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(axList[i].m_xHndl.IsValid())then
				return cast<CFightingObj>(axList[i].m_xHndl.GetObj());
			endif;
		endfor;
		return null;
	endproc;
	
endclass;

class CRevealer inherit CGameObj
	
	const int					SENSOR_TIMER			= 40048;
	const real				SENSOR_INTERVALL	= 2.0;
	var real					m_fSensorRange;
	
	constructor()
		m_fSensorRange = 15.0f;
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetPlaceBlocker(false);
		SetVisible(false);
		SetFOW(25.0f);
		InitEvents();
		var ^CAttribs pxAttribs=GetAttribs();
		if(!p_bLoad)then
			SetType("REVE");
			if(pxAttribs==null)then
				pxAttribs=InitAttribs();
			endif;
			CreateTimer(SENSOR_TIMER, CGameTimeSpan.OneSecond()*SENSOR_INTERVALL,true);
		endif;
		if(pxAttribs!=null)then
			m_fSensorRange=pxAttribs^.GetValueFloat("reveal_radius");
		endif;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==SENSOR_TIMER)then
				FindTraces();
			endif;
		endif;
	endproc;
	
	export proc void FindTraces()
		var CObjQuery xSearch;
		xSearch.Clear();
		xSearch.SetType("CHTR");
		xSearch.SetType("ANML",true);
		xSearch.SetOwner(0, false);
		xSearch.SetOwner(1, true);
		xSearch.SetOwner(2, true);
		xSearch.SetOwner(3, true);
		xSearch.SetOwner(4, true);
		xSearch.SetOwner(5, true);
		xSearch.RegionCircle(GetPos(), m_fSensorRange);
		var CObjList xList;
		if(!xSearch.Execute(xList))then return; endif;
		var int i,iC=xList.NumEntries();
		for (i=0) cond (i<xList.NumEntries()) iter (++i)do
			var ^CFightingObj pxObj=cast<CFightingObj>(xList[i].GetObj());
			if(pxObj==null)then continue; endif;
			if(pxObj^.GetCamouflage()||pxObj^.IsFeignDeath())then
				pxObj^.Reveal();
			endif;
		endfor;
	endproc;
	
endclass;
	
class CSkullDistributer inherit CGameObj
	
	const int					TIMER_SKULL_SEND	= 40173;
	const real				SKULL_INTERVALL		= 60.0;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetPlaceBlocker(false);
		SetVisible(false);
		InitEvents();
		var ^CAttribs pxAttribs=GetAttribs();
		if(!p_bLoad)then
			CreateTimer(TIMER_SKULL_SEND, CGameTimeSpan.OneSecond()*SKULL_INTERVALL,true);
		endif;
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			var int iTimerID=p_rxEvtPtr.GetInt(0);
			if(iTimerID==TIMER_SKULL_SEND)then
				DistributeSkulls();
			endif;
		endif;
	endproc;
	
	proc void DistributeSkulls()
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		var ^CStatsMgr pxStatsMgr=^(CStatsMgr.Get());
		var ^CStatisticMgr pxStatisticMgr=^(pxLevel^.GetStatisticMgr());
		if(pxLevel==null||pxStatsMgr==null||pxStatisticMgr==null)then return; endif;
		var string sFeedBack="_NT_AI_RESSOURCE_IRON", sResType="iron";
		var int i, iC=8, j, jC=3, iStep=0;
		for(i=6)cond(i<iC)iter(i++)do
			var ^CBasePlayer pxPlayerBot=cast<CBasePlayer>(pxLevel^.GetPlayer(i));
			if(pxPlayerBot!=null)then
				var int iSkullsBot=pxPlayerBot^.GetSkulls(), iShare;
				iShare=(iSkullsBot/3);
				if(iShare>0)then
					var string sShare=iShare.ToString(), sNameBot=pxPlayerBot^.GetPName();
					var ^CBasePlayer pxTeam;
					for(j=iStep)cond(j<jC)iter(j++)do
						pxTeam=cast<CBasePlayer>(pxLevel^.GetPlayer(j));
						if(pxTeam!=null)then
							pxTeam^.AddSkulls(iShare);
							CSrvWrap.SendGenericEvtToPlayer(j, "AllyTribute");
							CFeedback.Print(j, CFeedback.INFO,"_NT_DiplTribute\t"+sFeedBack+"\t"+sShare+"\t"+sNameBot);
							pxStatsMgr^.GetPlayerStats(i)^.AddTribute(j, sResType, iShare);
							pxStatisticMgr^.AddSample(CStatisticSample.Tribute.ToInt(), i,  iShare);
							pxStatisticMgr^.AddSample(CStatisticSample.Tribute.ToInt(), j, -iShare);
							CSrvWrap.GetGameLogger().Log("Tribute",i.ToString(),j.ToString(),sShare,sResType);
						endif;
					endfor;
					iSkullsBot-=(iShare*3);
					pxPlayerBot^.SetRessource(sResType, iSkullsBot);
				endif;
			endif;
			iStep+=3;
			jC+=iStep;
		endfor;
	endproc;
	
endclass;
